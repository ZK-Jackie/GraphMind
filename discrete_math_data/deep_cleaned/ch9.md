# 第九章  树的基本理论与算法  

树是大家非常熟悉的一类植物。通过对树的观察，不难发现自然界中的树总是有根、枝和叶，且具有这样一些特点：从根上可以长出枝来，从树杈上可以长出枝或叶，叶梢不长在一起，根、枝、叶之间总是畅通的，但它们之间不能构成圈。从结构上看，树是所有连通无向图中边数最少的图模型，同时也是所有无环无向图中边数最多的图模型。我们不得不惊叹大自然的神奇，竟然创造出如此高效而又和谐的离散结构。对自然界中树的这种特殊离散结构进行抽象，就可得到一种特殊的图模型，即树模型。在所有的图模型中，树模型是一种最简洁的连通无环结构，其中各结点之间有着最直接、最必要的联结关系。这种最简洁的连通结构决定了树在图模型知识体系中占有特别重要的地位。目前，树作为一种特殊图模型已被广泛应用于计算机各个领域，例如操作系统采用树结构来组织文件数据，编译程序采用树表示源程序的语法结构，在数据库系统中树被用来组织信息等等。  

本章主要介绍树模型基本理论及其算法设计的基本知识，首先介绍树模型的基本概念与性质、生成树与最小生成树等关于树模型的基本理论，然后具体讨论根树的概念与算法，包括树的递归遍历算法、森林与树的转换算法、最优树的构造与编码算法等，并在此基础上进一步学习若干典型特殊树模型及其基本算法，包括平衡树、红黑树、$B$树等，最后给出树模型的若干应用实例，包括决策树、博弈树等。  

## § 9.1 无向树的基本知识  

我们知道图模型主要分为有向图和无向图两大类，树作为一类特殊的图模型，自然也就有有向树与无向树之分。不过，如果从树的根结点看过去，树模型从根结点到叶子结点的层次结构本身就蕴含着一种方向。因此，一般不再关心树中各个边的方向差异而专注树结构的层次方向。换句话说，对于有向树，必须将其转化为一种特殊的无向树即根树进行讨论。基于以上原因，若无特别说明，我们通常所说的树模型均指无向树模型。  

### 9.1.1  无向树的概念与性质  

我们知道，自然界中任何一棵树都一个连通的整体，其根、枝、叶之间总相互畅通以保证养分能够顺利到达树的各个部分。此外，从树的结构上看，树的根、枝、叶之间没有任何回路。将树的上述两个基本特征进行抽象，就可得到树的本质结构特征：树模型其实就是一种无环的连通无向图。由此得到如下关于树的定义：  

【定义9.1】连通无回路的无向图称为树。树中悬挂结点称为树叶结点，简称为叶结点或叶，其它结点称为分支点或内点。平凡图称为空树。所有连通分支均为树的无向图称为森林，单个的树模型本身可看成是一个森林。

【定理9.1】假设${G}=\left\langle{V},{E}\right\rangle$是任意给定的一个无向图模型，且 $\vert V\vert=n,\vert E\vert=m$，则下述各个命题相互等值：  

（1）$G$连通而不含回路（即$G$是树）； 

（2）$G$中无回路且$m=n-1$； 

（3）$G$是连通的且$m=n-1$； 

（4）$G$中无回路，但在$G$中任意增加一条新边，就会得到唯一一条基本回路；

（5）当$n\geq2$时，$G$是连通的，但删除$G$中的任一条边后，便不连通；  （6）当$n\geq2$时，$G$中每一对结点之间都有唯一的一条基本通路。  

下面定理9.2 给出了关于树模型叶结点的一个基本性质：

【定理 9.2】 任意非平凡树$T(n,m)$都至少有两片叶。【分析】 利用握手定理和$m=n-1$即可证明。

### 9.1.2 无向图的生成树  

如前所述，树模型是大自然赐予的一种最简洁最高效的连通无向图，任意两个结点之间有且仅有一条路径联结。因此，在对一般连通无向图进行化简的时候，经常会删除图的一些边将其转化为树结构的生成子图。这种生成子图称为无向图的生成树，其定义如下：  

【定义9.2】假设$G=\langle V,E\rangle$是任意给定的一个无向图模型，若$G$的某个生成子图是树，则称该树为$G$的一个生成树，记为$T_{G}$。生成树$T_{G}$中的每条边均称为树枝；$G$中不在$T_{G}$中的每条边均称为弦；$T_{G}$的所有弦的集合称为生成树的补。  

显然，对于一个无向连通图$G$，如果$G$本身就是树，则其生成树就是它自己，因而是唯一的。但是，如果$G$不是树，则其生成树就不是唯一的。下面的定理9.3 保证了无向连通图模型生成树的存在性，为无向连通图的化简提供了坚实的基础：  

【定理9.3】假设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$存在其生成树$T_{G}=\langle V_{T}\,,\,\,\,E_{T}\rangle$的充分必要条件是$G$是连通的。  

事实上，上述定理证明过程给出了构造生成树的一种具体算法，通常称之为破圈法。该算法的关键是判断图$G$中是否有回路。若有回路，则删除回路中的一条边，直到图中无回路为止。假设图$G$中有${n}$个结点和$m$条边，则由生成树结点与边的关系知，要构造该图的生成树，必需删除$m-n+1$条边。  

此外，由于含$n$个结点和$m$条边无向连通图$G=(n,m)$一定存在生成树，且生成树中必有$n$个顶点，$n-1$条树枝和$m-n+1$条弦。因此，在$G$中选择不构成任何回路的$n-1$条边就一定可以得到$G$的一个生成树。这种构造生成树的方法，通常称为避圈法。  

破圈法和避圈法需要找出回路或验证不存在回路，计算量通常较大。由于在对一般连通无向图进行广度遍历搜索的时候，会自然形成一个无回路的连通生成子图，即该图生成树。因此，可以通过广度优先遍历算法构造生成树。该算法无需判断回路，因而具有较高的计算效率，比较适合计算机处理。对于连通图$G=\langle V,E\rangle$，该算法的具体过程如下：  

（1）任选$s\in V$，将$s$标记为0，令$L=\{s\},\;V=V-\{s\},k=0$； 

（2）如果$v=\varnothing$，则转（4），否则令$\cdot k=k+1$； 

（3）依次对$L$中的所有标记为$k-1$的结点$v$，如果它与𝑉中的结点𝑤相连接，则将𝑤标记为$k$，指定$v$为$w$的前驱，令$L=L\cup\{w\}$，转（2）；

（4）$E_{G}=\{(v, w) \mid w \in L-\{s\}, v \text { 为 } w \text { 的前驱 }\}$ 结束。 

### 9.1.3  最小生成树  

【定义9.3】设假设$G=\langle V,E,W\rangle$是任意给定的一个连通无向赋权图模型，𝑇是𝐺的一棵生成树，𝑇的每个树枝所赋权值之和称为𝑇的权，记为$\omega(T)$。图$G$中具有最小权的生成树称为$G$的最小生成树。  

需要注意的是，由于一个无向图的生成树不唯一。因此，一般不能保证一个赋权图的最小生成树一定是唯一的。但生成树的最小权一定是唯一的，对于不同的最小生成树，它们的权肯定彼此相等并且都等于最小权。  

下面介绍连通无向赋权图的最小生成树构造方法。求赋权图最小生成树的方法很多，其中最常见的主要是普莱姆算法和克鲁斯卡尔算法。  

普莱姆算法基于贪心策略，从图中任意一个结点开始，每次选择增加一条权最小的边构成一棵新树，基本思路就是每次在所有一端已经入选一端未入选的边中，选择权值最小的边加入且不构成回路。算法的具体过程如下：  

（1）从$G$中任意选取一个结点$v_{1}$，置$V_{T}=\{v_{1}\}$，$E_{T}=\varnothing$，$k=1$ 。

（2）在$V-V_{T}$中选取与某个$v_{i}\in V_{T}$邻接的结点$v_{j}$，使得边$(v_{i},\ v_{j})$的权最小，置$V_{T}=$${T}\cup\{v_{j}\},\;\;E_{T}=E_{T}\cup\{(v_{i}\,,\;\,v_{j})\},\;\;k=k+1$。

（3）重复步骤(2)，直到$k=|V|$。 

在普莱姆算法的步骤(2)中，若满足条件的最小权边不止一条，则可从中选择一条。由此会产生不同的最小生成树。  

由于普莱姆算法基于贪心策略， 每次循环只考虑本次选择的最优结果， 而不考虑下次如 何选择，是一种局部最优算法。因此，必须证明算法的正确性。下面定理9.4 证明了普莱姆算法的正确性，保证了该算法可通过不断计算局部最优值获得整体最优值。  

【定理9.4】假设$G=\langle V,E,W\rangle$是任一给定的连通无向赋权图，则由普莱姆算法构造的任何生成树$T=G\{e_{1},e_{2},\ldots,e_{n-1}\}$都是$G$的最小生成树，其中$n$为$G$的结点数。  


【定理9.5】假设$G=\langle V,E,W\rangle$是任一给定的连通无向赋权图，则由克鲁斯卡尔算法构造的任何生成树$T=G\{e_{1},e_{2},\ldots,e_{n-1}\}$都是$G$的最小生成树，其中$n$为𝐺的结点数。  

## § 9.2 根树的基本知识  

前面学习了无向树模型的基本知识。细心的读者可能已经发现，作为连通无环图的一般无向树模型并没有完全反映出自然界树模型的基本特征。例如，自然界中的树有树根、树枝和树叶，而前述无向树模型并没有很好地反映树的这些层次结构特征。为此，本节在无向树模型基础上进一步引入树根、树枝和树叶等概念，刻画无向树模型的层次结构，建立一种名为根树的特殊无向树模型，并讨论根树模型的基本性质、基本算法与应用。  

### 9.2.1 有向树与根树

我们知道无向树是一种由无向图构成的特殊图模型.那么如何定义和处理由有向图构成的有向树模型呢？现在就来讨论这个问题，首先给出如下有向树模型的定义：  

【定义9.4】对于任意一个给定的有向图，如果略去其所有有向边的方向而得到的无向图是一棵树，则该有向图称为一棵有向树。  

从上述定义及例题可以看出，有向树模型的连通性与无环性是由其伴随的无向图模型决定的，或者说是略去边的方向而直接将有向树看成是无向树.这与一般有向图模型的概念和处理方式有很大差异.因此，如果在树模型的框架下讨论有向树中某条或某几条边在方向上的差异，则没有太大意义，甚至有时还会引起概念上的混淆。  

事实上，自然界中的树模型本身就蕴含着一种方向，这种方向体现在由树根、树枝和树叶结点所构成的层次结构当中，由树根、树枝和树叶结点之间在属性上的差异来刻画边的方向性，不过这种边的方向不是个别边的方向而是所有边的整体方向，即从根到叶的方向或从叶到根的方向。对自然界中树模型的上述特征进行抽象，得到如下根树的概念：  

【定义9.5】对于一棵非平凡的有向树，如果恰有一个结点的入度为0，其余所有结点的入度均为1，则称之为根树或外向树.入度为0 的结点称为根结点,简称为根；出度为0 的结点称为叶结点，简称为叶；入度为1，出度大于0 的称为内结点，简称为内点；又将内点和根统称为分支结点，简称为分支点。在根树中，从根到任一结点的通路长度，称为该结点的层数；所有结点的层数最大值称为根树的高。  

通常使用倒置法表示根树，即把根画在最上方，叶画在最下方，有向边的方向均指向下方。


从根树的定义及上述例题不难发现，根树作为一种特殊的有向树其所有边均是朝着一个方向，即是从根结点到叶结点的方向。既然如此就可以对这种特殊的有向图进行化简，即省略根树中所有边的方向将其转化为无向树。由此可知，根树其实是一种具有根、枝、叶等层次结构的特殊无向树。  


如图9-14 所示，根树是一种由子树不断嵌套而产生的一种层次结构模型，故还可用如下递归的方式定义根树：  

【定义9.6】树是一个$n(n>0)$元有限集，集合中所有数据元素具有如下层次关系：当$n=0$ 时，集合为空集，称之为空树；当$n>0$ 时，集合中有且只有一个特定的结点，称之为树模型的根；当$n>1$ 时，除根以外的其余结点可分为$m(m>0)$个互不相交的有限集$T_{1},T_{2},\cdots,T_{m}$，其中每个集合本身又是一棵树，并称$T_{1},T_{2},\cdots,T_{m}$称为根的子树。  

例如，图9-15 表示一个具体的树模型结构。该树有10 个结点，其中𝐴是根结点，其余结点被分为 3  个互不相交的子集： $T_{1}=\{B,E,F\},T_{2}=\{C,G\},T_{3}=\{D,H,I,J\}$ ； $T_{1}$ ， $T_{2}$ ， $T_{3}$ 都 是 𝐴 的子树，它们本身也分别是一棵树。  

也可用家族关系表示根树中各节点间的关系。  

【定义9.7】在根树中，若从结点$v_{i}$到$v_{j}$可达，则称$v_{i}$是$v_{j}$的祖先，$v_{j}$是$v_{i}$的后代；又若 $\langle v_{i},v_{j}\rangle$是根树中的有向边，则称$v_{i}$是$v_{j}$的父亲，$v_{j}$是$v_{i}$的儿子；如果两个结点是同一个结点的儿子，则称这两个结点是兄弟。  

有时还会在根树的同层次的兄弟结点之间规定具体的大小排序，一般是从左到右进行排序，有时也可以用边的次序代替结点的次序。  

在根树的实际应用中，例如对目标的排序与查找等，需要经常对其中间结点的分支数进行度量、设计和分析，为此给出如下关于$k$元根树或$k$叉根树的概念：  

【定义9.8】 在根树𝑇中，若每个分支点至多有${k}$个儿子，则称𝑇为𝒌元树或𝒌叉树；若每个分支点都恰有${k}$个儿子，则称𝑇为完全$ k$元树或完全$ k$叉树；若$k$元树𝑇的兄弟结点之间有序，则称𝑇为𝒌元有序树或$k$叉有序树；若完全$ k$元树𝑇的兄弟结点之间有序，则称𝑇为有序完全𝒌元树或有序完全$k$叉树。在根树$T$中，任一结点$v$及其所有后代导出的子图$T^{\prime}$称为$𝑇$的以$v$为根的子树.当然$T^{\prime}$也可以有自己的子树.有序二元树的每个结点$𝑣$至多有两个儿子，分别称为 $𝑣$ 的左儿子和右儿子，至多有两棵子树，分别称为 $𝑣$ 的左子树和右子树。  

注意：以$v$为根的子树包含$𝑣$，而$𝑣$的左右子树则不包含$𝑣$

【定理9.6】在$k$元完全树中，若叶为𝑡，分支点数为 $i$，则下式成立：  

  $(k-1)\times i=t-1~~~~~~~~~~~~~~\quad(9-1)$



### 9.2.2 根树的基本算法  

对于根树，一个十分重要的问题是要找到一些方法能系统地访问树的结点，使得每个结点恰好访问一次，这就是根树的遍历问题。由于二元树在计算机中最易处理且任意根树都可转化为二元树，因此在$k$元树中，应用得最广泛的是二元树。下面先介绍二元树的三种常用的遍历方法，然后介绍如何将任意根树转化为二元树。  

二元树的遍历算法主要有先根遍历算法、中根遍历算法和后根次序遍历算法，这三种算法都是采用递归的方式进行：  

先根遍历算法，顾名思义就是首先递归访问根结点；然后递归访问根的左子树，最后，就递归访问根的右子树；中根遍历算法，首先递归访问根的左子树；然后递归访问根结点；最后递归访问根的右子树；后根遍历算法，首先递归访问根的左子树；然后递归访问根的右子树；最后递归访问根结点。  



### 9.2.3  前缀码与最优树  

为此引入如下前缀及前缀码的概念：  

【定义9.9】设$a_{1}a_{2}\cdots a_{n-1}a_{n}$是长度为$n$的符号串，则称其子串$a_{1},a_{1}a_{2},a_{1}a_{2}a_{3},\cdots\,,$,$a_{1}a_{2}\cdots a_{n-1}$分别为$a_{1}a_{2}\cdots a_{n-1}a_{n}$的长度为1，2，⋯，$n-1$的前缀。  

【定义9.10】设$A=\{b_{1},b_{2},\cdots,b_{m}\}$是一个符号串集合，若对任意$b_{i}$，$b_{j}\in A$，$b_{i}\neq$$b_{j}$，$b_{i}$不是$b_{j}$的前缀，$b_{j}$也不是$b_{i}$的前缀，则称𝐴为前缀码。若在符号串$b_{i}\bigl(i=1,2,\cdots,\ \mathsf{m}\bigr)$中，只出现0 和1 两个符号，则称𝐴为二元前缀码,在不引起混淆时简称为前缀码。  

事实上，可用一棵二元树来产生一个二元前缀码：  

给定一棵有𝑡片叶二元树𝑇。设$v$是𝑇的任一分支点，则$v$至少一个儿子至多两个儿子。若𝑣有两个儿子，则在由𝑣引出的两条边上，左边的标0，右边的标1；若$v$只有一个儿子，在$v$引出的边上可标0 也可标1。设${v}_{i}$为𝑇的任意一片叶，从树根到$v_{i}$的通路上各边的标号组成的符号串放在$v_{i}$处，$t$片叶处的𝑡个符号串组成的集合为一个二元前缀码。  

由上述做法可知，$v_{i}$中符号串的前缀码均在${v}_{i}$所在通路上，因而所得集合为0 和1 组成前缀码。显然，若𝑇存在带一个儿子的分支点，则𝑇产生不唯一的前缀码， 𝑇若为二元完全树，则𝑇产生唯一的前缀码。例如，图9-26 所示二元树产生的前缀码为：  

【定义9.11】设有一棵二元树𝑇，若对其所以的𝑡片叶赋以权值$w_{1},w_{2},\cdots,w_{t}$，则称之为赋权二元树；若权为$w_{i}$的叶的层数为$L(w_{i})$，则称：  

$$
w(T)=\sum_{i=1}^{t}w_{i}\times L(w_{i})
$$

为该赋权二元树 𝑇 的权；   $w(T)$ 最小的二元树称为最优树。  

下面的定理9.7 给出了构造最优树的一个基本思路：  

【定理9.7】假设𝑇是一棵带有权值为$|w_{1}\leq w_{2}\leq\cdots\leq w_{t}$二元最优树。其中权$w_{1}$和$w_{2}$所对应叶结点必定是兄弟，并且如果将其父结点由分支结点改为带权$w_{1}+w_{2}$的叶结点，则由此得到的一棵新树$T^{\prime}$也是一棵最优树。  

根据上述定理，美国计算机科学家霍夫曼在1952 年提出一种构造最优树的算法，通常称之为霍夫曼算法。对于任意给定的权值 $w_{1}\leq w_{2}\leq\cdots\leq w_{t}$，算法的基本思路是：要画一棵带有$t$个权的最优树，则可依据定理9.7 将问题转化为要画一棵带有𝑡−1个权的最优树，依次类推.具体做法是：首先找出两个最小的权值设为$w_{1}$和$w_{2}$，然后对𝑡−1个权$w_{1}+$$w_{2},w_{3},\cdots,w_{t}$求作最优树，并将这棵最优树中权$w_{1}+w_{2}$对应的叶结点分叉出两个儿子，依次类推，直到只有一个权值的最优树的情形.具体算法过程如下：  

（1）初始：令${\cal{S}}=\{w_{1},w_{2},\cdots,\}$ ;

（2）从𝑆中取出两个最小的权$w_{i}$和$w_{j}$，画结点$v_{i}$，带权$w_{i}$，画结点$v_{j}$，带权$w_{j}$。画$v_{i}$和$v_{j}$的父亲$v$，连接$v_{i}$和$v$，$v_{j}$和$v$，令$v$带权$w_{i}+w_{j}$；  

（3）令$S=\left(S-\left\{w_{i},w_{j}\right\}\right)\cup\{w_{i}+w_{j}\};$  

（4）判断𝑆是否只含一个元素。若是，则停止，否则转（2）。

从上述算法过程可以看出，霍夫曼算法采用递推的方式构造最优树，核心思想是逐步从从带权为$w_{1}+w_{2},w_{3},\cdots,w_{t}$的最优树${T^{\prime}}$中得到带权为$w_{1}$，$w_{2}$，⋯，$w_{t}$的最优树。  

## § 9.3 特殊根数与算法  

根树是一类非常重要的树模型，能够对很多复杂的数据信息进行表示和处理，广泛应用于程序设计、数据结构、算法设计与分析、操作系统等多门后续课程。根树的种类很多，可以针对不同类型的问题或数据建立相应类型的根树模型。本节着重介绍三种最为典型的特殊根树模型，即平衡树模型、红黑树模型和𝐵树模型，并分析和讨论这些模型的插入、删除、更改、旋转等基本算法，旨在为后续相关专业课程的学习打下良好的基础。  

### 9.3.1 平衡树模型  

对于二叉树的一些基本操作，比如插入、删除和查找等，其算法时间复杂度都与树的高度有关。因此，适当控制树高是一个非常关键的问题。显然，控制树高的一个有效措施就是尽量保持树的左右子树高度大致平衡，由此产生平衡二叉树的概念。  

平衡二叉树是一种特殊的二叉树，要求树中任何结点的两棵子树高度差不能超过1，如果插入或者删除一个结点使得高度之差大于1，就要进行结点之间的旋转操作，将二叉树重新维持在一个平衡状态。  

平衡二叉树是一种非常重要的树模型，因为它可以保证一些在树上的基本操作具有较好的最坏情况性能，这使它在信息查找等很多场合有着十分重要的作用。后面将会详细介绍平衡二叉树的若干特例，如红黑树、$B$树等。  

平衡二叉树的操作主要有查找、插入和删除结点等。其中插入和删除结点操作可能需要通过一次或多次旋转操作来重新平衡该树，使其满足平衡二叉树的要求。下面简要介绍有关平衡二叉树的一些基本概念和操作。  

树模型中某结点左子树的高度减去该结点右子树的高度，所形成的差值称为该结点的平衡因子，即$\mathrm{Balance~Fector(BF)=}$左子树的高度-右子树的高度。  

平衡二叉树的平衡因子为-1，0 或1。设计平衡二叉树操作算法的关键在于如何使得平衡二叉树保持平衡。以下四种情况下的插入操作可能会导致原有平衡二叉树发生不平衡:  

（1）LL：若某一节点的平衡因子为1，当在其左子树的左子树上插入一个新结点时会导致该结点的平衡因子由1 变为2。  

（2）RR：若某一节点的平衡因子为-1，当在其右子树的右子树上插入一个新结点时会导致该结点的平衡因子由-1 变为-2。  

（3）LR：若某一节点的平衡因子为1，当在其左子树的右子树上插入一个新结点时会导致该结点的平衡因子由1 变为2。  

（4）RL：若某一节点的平衡因子为-1，当在其右子树的左子树上插入一个新结点时会导致该结点的平衡因子由-1 变为-2。  

平衡二叉树有四种基本的旋转方式，分别为：左旋转，右旋转，先左后右旋转，先右后左旋转。针对上述四种情况可能导致的不平衡，可通过旋转的方式使得平衡二叉树恢复平衡，具体做法如下（箭头中数字为子树的高度，结点旁边的数字为其平衡因子）：  


（1）LL 型调整：插入操作，当三个结点处于一条直线，并均是左结点时(导致LL 情况)需要以中间结点为旋转轴向右侧(顺时针)旋转一次。如图9-30 所示。具体步骤如下：  

步骤一：将 $𝐴$ 的左子树 $B$ 提升为新二叉树的根   

步骤二：将原来的 $𝐴$ 连同其右子树 ${\mathbf{}}A_{R}$ 向下旋转，使其成为 𝐵 的右子树   

步骤三：将$B$的原右子树${B_{R}}$作为左子树连接到𝐴上  

（2）RR 型调整：插入操作，当三个结点处于一条直线，并均是右结点时(导致RR 情况)需要以中间的结点为旋转轴向左侧(逆时针)旋转一次。如图9-31 所示。具体步骤如下：  

步骤一：将 $𝐴$ 的右子树 $B$ 提升为新二叉树的根   

步骤二：将原来的 $𝐴 $连同其左子树 ${}^{;}A_{L}$ 向下旋转，使其成为 $𝐵$ 的左子树   

步骤三：将$\cdot B$的原左子树$B_{L}$作为左子树连接到𝐴上  

（3）LR 型调整：插入操作，当三结点不在一直线且均是左结点时，需以插入结点为旋转轴向左侧(逆时针)旋转一次，然后向右侧(顺时针)旋转一次，即先做RR 操作再做一次LL 操作（在LR 情况，需要先将$B$左旋转，再将𝐴右旋转），如图9-32 所示。具体步骤如下：  

首先执行RR 旋转：  

步骤一：将 $B$ 的右子树 $C$ 提升为新二叉树的“根”  

步骤二：将原来的 $B$ 连同其左子树 ${'}B_{L}$ 向下旋转，使其成为 𝐶 的左子树   

步骤三：将$C$的原左子树$C_{L}$作为右子树连接到$B$上

然后再执行LL 旋转：  

步骤四：将$𝐴 $的左子树 $C$ 提升为新二叉树的根   

步骤五：将原来的 $𝐴$ 连同其右子树 ${\mathbf{}}A_{R}$ 向下旋转，使其成为 $𝐶$ 的右子树   

步骤六：将𝐶的原右子树$C_{R}$作为左子树连接到𝐴上  

（4）RL 型调整：插入操作，当三结点不在一直线且均是右结点时，需以插入结点为旋转轴向右侧(顺时针)旋转一次，然后向左侧(逆时针)旋转一次，即先做LL 操作再做一次RR 操作（在RL 情况，需先将$B$右旋转，再将𝐴左旋转）。如图9-33 所示。具体步骤如下：  

首先执行LL 旋转  

步骤一：将 $B$ 的左子树 $C$ 提升为新二叉树的“根”  

步骤二：将原来的 $B$ 连同其右子树 $B_{R}$ 向下旋转，使其成为 $𝐶$ 的右子树 

步骤三：将$𝐶$的原右子树$C_{R}$作为左子树连接到$B$上  

然后再执行 RR  旋转  

步骤四：将 $𝐴$ 的右子树 $C$ 提升为新二叉树的根   

步骤五：将原来的 $𝐴$ 连同其左子树 ${}^{;}A_{L}$ 向下旋转，使其成为 $𝐶$ 的左子树  

步骤六：将$𝐶$的原左子树$C_{L}$作为右子树连接到$𝐴$上 在上述四种旋转基础上，就可对平衡二叉树进行插入和删除操作，具体如下：  

（1）插入操作：插入完成后需要从插入的结点开始维护一个到根结点的路径，每经过一个结点都要维持树的平衡，需要根据高度差的特点采取不同的旋转策略进行调整，使整棵树恢复成为平衡树。  

（2）删除操作：首先定位要删除的结点，删除完成后，要从删除结点的父亲开始向上维护树的平衡一直到根结点，然后采取不同的旋转策略调整，使整棵树恢复成为平衡树。  

### 9.3.2 红黑树模型  

红黑树是一种自平衡二叉查找树。与其他二叉查找树的不同，红黑树在每个结点上增加一个存储位来表示结点的颜色，可以是红色或黑色，通过自动控制红色和黑色这两种颜色的结点分布，以保证树的高度达到近似平衡，从而能够得到比较高的算法效率。  

一棵红黑树需要满足以下五条性质：（1）每个结点是红色或者是黑色；（2）根结点是黑色；（3）每个叶结点，即空结点（NIL）是黑色的；（4）如果一个结点是红色，那么它的两个子结点都是黑色；（5）对每个结点，从该结点到其所有后代叶结点的所有路径上包含相同数目的黑结点。  

其中性质（4）保证了红黑树中任何一条简单路径上不可能出现两个相邻的红色结点，因此最短路径上可能全为黑色结点，最长路径可能为相互交替的红色和黑色结点；性质（5）决定了所有最长的路径都包含相同数目的黑色结点。这两个性质表明，在红黑树中，从根到叶子的最长路径长度不大于最短的路径的两倍，这样就有效地限制了红黑树的高度。由此可以设计出高效的查找算法。  

在对红黑树进行插入和删除等操作时，可能会破坏红黑树的性质，需要及时对红黑树进行调整，以继续保持或恢复红黑树的性质。具体调整方法包括对结点重新着色，以及对树进行旋转操作，即：通过修改某些结点的颜色及指针结构，使得红黑树在插入或删除结点等操作后仍能保持其性质或平衡。下面具体介绍红黑树插入和删除操作算法。  

插入操作主要为以下3 个基本步骤：  

步骤1： 查找要插入的位置；  

步骤2： 将新结点的颜色域赋值为红色；  

步骤3： 自下而上重新调整该树为红黑树；  

在步骤1 中，查找方法与一般二叉查找树类似，不再赘述；在步骤2 中，把新结点的颜色赋值为红色的原因是：如果将其颜色赋值为黑色，将会使得从根到叶子的路径中有一条路上会出现一个额外的黑色结点，这个在后续的修改中难以调整。相反，将其赋值为红色，尽管可能会出现连续两个红色结点的情况，但是这种情况可以在后续的修改中通过旋转和颜色变换进行调整，而且比较容易。下面着重讨论步骤3 的具体实现方法：  

假设要插入的结点为𝑁，其父亲结点为𝑃，$P$的兄弟结点为𝑈。考虑以下两类情况：

（1）如果𝑃是黑色的，那么整棵树已经是红黑树不需要再进行调整。  

（2）如果𝑃是红色的，那么插入$N$后，将与第4 条性质不符，这时需要进行旋转调整。具体的调整方法又可以分为以下3 种情况：  

1）$N$的叔叔$U$是红色（图中使用阴影表示红色），将结点$P$和结点𝑈的定义为黑色并定义结点𝐺为红色。此时，插入结点𝑁的父亲结点𝑃为黑色。因为通过父结点$P$或结点$U$的任何路径都必定通过结点$G$，而在这些路径上黑色结点的数目没有改变。但是，结点$G$的父结也可能是红色的，因此需要以结点$G$向上递归调整结点颜色。  

2）$N$的叔叔$𝑈$是黑色的，且$N$是右孩子，此时对结点$P$进行一次左旋转调换，然后按情形3）的方法处理。  

3）$N$的叔叔𝑈是黑色的，且$N$是左孩子，此时需对结点$G$ 做一次右旋转调换，使得在变换后的树中结点$P$是新结点𝑁和结点$G$ 的父结点，然后调换之前的结点$P$和结点𝐺的颜色，使之满足第4 和第5 条性质。  


下面介绍红黑树的删除操作算法。  

红黑树结点删除方法和二叉搜索树的删除方法基本相同，分如下三种情况：若结点没有子女，则直接删除该结点；若结点只有一个子女，则修改它的父结点，使父结点直接连接其子结点；若结点有两个子女的话，则可以找到该结点的前驱或者后继，然后更换两个结点的值，再将前驱或者后继结点删除（由于任意一个结点的前驱或者后继都必定至多只有一个非空子结点，因而删除这样的结点就可以按照前两种情形进行处理）。  

由上分析可知，红黑树删除操作分为以下三个基本步骤：  

(1) 查找要删除结点的位置；

(2) 用其后继替换该结点； 

(3) 若替换结点为黑色，则需重新调整树模型使其重新成为红黑树。  

其中：步骤1 中查找方法和一般二叉查找树类似，不再赘述；步骤2 使用后继结点替换被删除结点，可保证该结点以上部分仍为红黑树；在步骤3 中，若被删除结点为红色，则其父结点和孩子结点全为黑，此时可直接删除该结点，若被删除结点为黑色，则要分以下四种情况分别进行处理：  

设被删除的结点为$N$，其父结点为$𝑃$，其兄弟结点为$𝑆$。由于结点$𝑁$是黑色的，则结点$P$和$𝑆$都有可能是黑色或红色。  

（1）结点$𝑆$是红色的。此时结点$𝑃$肯定是黑色。对结点$𝑁$的父结点$P$做左旋转，然后把红色兄弟结点转换成结点$𝑁$的祖父。接着转换结点$𝑁$的父亲和祖父的颜色。接下去按 第二、第三或第四种情况来处理。  

（2）结点$𝑆$及其的孩子全是黑色的。这种情况下，结点$𝑃$可能是黑色也可能是红色的。此时，首先把结点$𝑆$赋值为红色。然后要调整以$𝑃$作为$𝑁$递归调整树。  


（3）$𝑆$是黑色的，$𝑆$的左孩子是红色，右孩子是黑色。这种情况下，对结点$𝑆$做右旋转，这样 $S$ 的左孩子就成为 $S$ 的父亲和$𝑁$的新兄弟。这样就将问题转化到第四种情况。此时${\mathbf{}}N$和它的父结点都不受这个变换的影响。  

（4）$𝑆$是黑色的，$𝑆$的右孩子是红色。这种情况下，对$𝑁$的父结点做左旋转，这样$𝑆$成为$𝑁$的父结点和$𝑆$右儿子父结点。接着交换$𝑁$的父结点和$𝑆$的颜色，并使$𝑆$的右儿子为黑色。此时，$N$增加了一个黑色祖先: 要么$𝑁$的父结点变成黑色，要么它是黑色而$𝑆$增加了一个黑色祖父。所以，通过$𝑁$的路径都增加了一个黑色结点。  


### 9.3.3 B树模型  

$B$树是一种为磁盘或其他直接存取存储设备而设计的平衡多路查找树。与红黑树类似，两者都是平衡搜索树，而且具有 ${n}$ 个结点的$ 𝐵$ 树与具有 ${n}$ 个结点的红黑树高度一样，都 为$O(l o g\,n)$。但是$B$树的每个结点可以有很多孩子，而红黑树最多只能有两个孩子，因此𝐵树在磁盘${I}/O$ 操作上更为简洁，在数据库系统等动态集合操作方面具有广泛应用。我们先给出$B$树的基本性质，然后详细讨论其查找、插入和删除操作算法。  

$B$树中所有结点的孩子结点数目的最大值称为$ B$树的阶，通常用$m$表示，出于查找效率考虑，要求$m\geq3$。一棵$m$阶$B$树一般具有以下性质：  

（1）每个结点最多有$m$个分支，最少分支数要看是否为根结点，若为根结点，则根结点的分支数至少为2，否则非根结点至少有$\lfloor m/2\rfloor$个分支。  

（2）结点的分支数等于关键字数加1，即 $n(k\leq n\leq m)$个分支的结点含有$n-1$个关键字，它们按递增顺序排列。其中，$k=2$(根结点)或$\lfloor m/2\rfloor$ (非根结点)。   

其中，$n$为结点中关键字个数，$k_{i}(1\leq i\leq n)$表示该结点的关键字，且$k_{i}<k_{i+1}$。$P_{i}(1\le$$i\leq n)$表示该结点的孩子结点指针，且$P_{i}(1\leq i\leq n-1)$指向的结点的键值介于$k_{i}$和$k_{i+1}$之间，$P_{0}$指向的结点上的关键字值小于$ k_{1}$，$P_{n}$指向的结点上的键值大于$K_{n}$。  

（3）结点内各关键字互不相同，并按升序排列。

（4）各个底层结点都是叶子结点，并且处于同一层。  


#### 1. B树的查找  

根据结点的孩子数做分支界定。比较要查找的值与当前值的大小，若比当前值小则在其左子树，否则在其右子树，递归查找，直到找到相等的结点为止，并返回该结点的位置。如果直到叶子结点仍然没有找到则返回$Null$。在本书第七章查找算法设计中将详细介绍和讨论$𝐵$树查找算法，不再赘述。  

#### 2. B树的插入  

插入操作后所构成的新树必须满足$B$树性质，因此插入结点时需注意关键字的个数$n$不大于$m-1$。对于高度为ℎ的$m$阶$B$树，新结点一般插在第$B$层。通过查找算法可确定关键字应该插入的结点位置。确定插入结点位置后，分两种情况讨论具体的插入算法：  

（1）若该结点中关键字个数小于$m-1$，则直接插入即可。  

（2）若该结点中关键字个数等于$m-1$，则将引起结点的分裂，以中间关键字为界将结点一分为二，产生一个新结点，并把中间关键字插入到父结点中；  

重复上述步骤，直到完成插入过程。最坏情况是一直分裂到根结点，建立一个新的根结点，此时整个$ B$树增加一层。  

#### 3 . B树的删除  

插入操作只可以从叶结点插入，而删除则可以从任意结点中删除一个关键字，所以删除操作比插入操作需要考虑的情况更加复杂。  

如果待删除关键字所在的结点是叶子结点，则此时可以分3 种情况进行讨论。第一种情况，若删除前该结点中关键字个数$n\geq\lceil m/2\rceil$，那么直接删除该结点。

第二种情况，删除前结点关键字个数为$n=\lceil m/2\rceil-1$，若这时与该结点相邻结点的关键字个数$ n\geq\lceil m/2\rceil$，则进行如下操作。  

（1）将双亲结点中刚刚大于（或小于）该被删除关键字的关键字$K_{i}$，$1\leq i\leq n$下移。  

（2）将右兄弟（或左兄弟）结点中的最小（或最大）关键字上移到双亲节点的$K_{i}$ 位置。  

（3）将右兄弟（或左兄弟）结点中的最左（或最右）子树指针平移到被删关键字所在结点中最后（或最前）子树指针位置的$K_{i}$位置。  

（4）在右兄弟（或左兄弟）结点中，将被移走的关键字和指针位置用剩余的关键字和指针填补，在将结点中的关键字个数减1。


第三种情况，删除前结点关键字个数$n=\lceil m/2\rceil-1$，若这时与该结点相邻结点的关键字个数$n=\lceil m/2\rceil-1$，则需要合并结点，此时进行如下操作。  

（1）将双亲结点$p$中相应关键字下移到选定保留的结点中。若要合并$ p$中的子树指针$p_{i}$与$p_{i+1}$所指的结点，且保留$p_{i}$所指结点，则把$p$中的关键字 $K_{i+1}$下移到${p_{i}}$所指的结点中。  

（2）把$p$中子树指针$p_{i+1}$所指结点中的全部指针和关键字都照搬到$p_{i}$所指结点的后面。删除$p_{i+1}$所指的结点。  

（3）在结点$p$中用后面剩余的关键字和指针填补关键字$ K_{i+1}$和指针$p_{i+1}$。

（4）修改结点$p$和选定保留结点的关键字个数。  


需要指出的是，删除操作有可能并未结束。可以看到，在合并结点的过程中，双亲节点中的关键字个数减少了。这里还需要分情况讨论，如果双亲节点是根结点且结点关键字个数减到0，则该双亲结点应从树上删去，合并后保留的结点成为新的根结点；如果双亲结点不是根结点，且关键字个数减到$\lceil m/2\rceil-2$，就要与它自己的兄弟结点合并，重复上面的合并步骤。最坏情况下这种结点合并处理要自底向上直到根结点。  

讨论完待删除关键字所在结点为叶结点的情况之后，现在再看待删除关键字所在结点不是叶结点的情况。如果关键字所在街道不是叶子结点，则在删去该关键字之后，以该结点$p_{i}$所指示子树中的最小关键字$x$来代替被删除关键字$ k_{i}$所在的位置，然后再$x$ 所在的叶子结点中删除$x$。此时，问题就转化为已讨论过的删除关键字所在的叶子结点的情况。  

## § 9.4 树模型的应用  

基于树模型的算法应用范围十分广泛，本节通过介绍若干树模型的一些常见应用，以进一步阐述树模型算法的构造、优化原则和方法，便于读者更加深入彻底地认识和掌握该类算法的设计与应用。  

### 9.4.1 找假币问题  

所谓找假币问题，就是有若干外观完全一样的硬币，其中有一个是假币，该假币的种类与其余硬币在重量上有一定差异，需要通过称重的方式把该假币找出来。这种找假币问题，其实可以看作为一种决策问题，即根据每一步的决策，选择走相应的步骤。  

对于决策问题，首先想到的是使用决策树来解决。从树根开始，每次回答一个问题，走相应的边，最后将会达到一个叶结点，即做出了选择。这样的一棵树称为决策树。

决策树作为树模型的一个典型应用，它可以把做出判决的逻辑关系用树结构的形式表现出来，最后的结果都集中在叶子上，条理清晰，一目了然，并且可以用决策树表示算法，使得在最坏情形下花费时间最少。因此，可以采取一种经典的树模型——决策树来解决这个问题。下面介绍两种基于决策树的解法，分别体现在如下问题一和问题二中，一种是基于两两比较的策略，另一种是基于分组比较的策略。  


问题一、现有5 枚外观相同的硬币，其中有1 枚是假的，假币与真币在重量上有差异，但不知孰重孰轻。问如何使用一架无砝码天平找出假币并判别其与真币的重量关系？  

问题分析与求解：用天平来称𝐴和𝐵两枚硬币，只有$A<B$、$A=B$、$A>B$三种可能的情形，因此可构造3 元决策树来解决。

问题二、现有12 个外观相同的硬币，其中有一枚是假的，且已知假币比真币重，要求用一个无砝码天平，只称3 次，把假币找出来。  

问题分析与求解：把硬币等分成三份，用天平分别对这三份进行称重。确定假币在哪一份，之后再对假币所在的那一份进行等分，并称重，直到找到假币。

决策树在生活中有着广泛的应用，除了解决假币问题，还可以解决排序类问题。  

### 9.4.2 轮流摸牌问题  

轮流摸牌问题，作为一种经典的博奕类游戏，问题的具体描述如下：  

桌上有𝑀堆扑克牌，每堆牌的数量分别为$N_{i}(i=1,2,\dots,M)$。现有两个选手，分别记为先手和后手，轮流进行摸牌，每一次摸牌可以任意选择一堆并取走其中的任意张牌，规定每次至少取一张，多者不限；桌上的扑克牌全部取光，则游戏结束，那么最后一次摸牌的选手即为胜者。现在问题如下：先手如果想赢，第一步有几种选择?  

轮流摸牌问题可以采用博弈树解决。博弈树是一种特殊的树模型，它的每个结点表示游戏进行时的一种局面，用每条边表示这些局面之间合乎规则的演变或移动。博弈树通常比较庞大，通常需要对其进行化简才能高效地使用。  

轮流摸扑克牌游戏为典型的尼姆博弈问题。尼姆博弈的关键在于游戏开始时游戏处于何种状态（平衡或非平衡）和先手是否能够按照取子游戏的获胜策略来进行游戏。  

此外，这种博弈的方法已经应用到很多的计算机程序研究中。某些博弈程序都能做到与人类选手进行对决，比如国际象棋等，可以看到如何将树应用到博弈策略的研究中具有重要的现实意义。

### 9.4.3 关键道路问题  

一项工程往往由许多作业构成，其中某些作业可以同时进行，而某些作业却必须按照一定先后顺序执行。例如，在建筑工程中，一般涉及到采购材料、平整地基、预制构件、埋设管道、砌墙立屋、室内装修等多个作业。其中平整地基和预制构件可以同时进行，而室内装修却必须在砌墙立屋之后才能动工等。这样就存在问题：为了使使得工期最短、成本最低，我们应该采取什么方法安排各个作业实施？  

我们知道，PERT 图模型可以很好地解决这类问题.。PERT 图中不含有向回路。在作业网络中每条有向边表示一个作业，边上的权表示完成该项作业所需要的时间（或者费用）。源点（简称源）$𝑠$表示工程的开始，汇点（简称汇）$𝑡$表示工程的结束，其余结点$V_i$表示以该结点为终点的有向边代表的作业的结束和以该结点为始点的有向边代表的作业的开始。  

第 8 章采用直接计算各个作业最早完成时间和最晚完成时间的方法计算关键路径，现在采用生成树方法计算源到其它结点的最长道路即关键道路，计算思路如下：  

（1）构造一棵以源𝑠为根的生成根树$T$，且求出$s$到根树的各个结点$v$的距离$L\left(\nu\right)$ 。

（2）对任何一条权为$𝑊$$(u,v)$的弦$\langle u,v\rangle$，若$L(v)<\ L(u)+\ W(u,v)$，则从$T$中去掉以$v$为终点的有向边，而以有向边$\langle u,v\rangle$代之，同时使以$v$为根的子树中的各结点距离都增加$W(u,v)$，如此反复进行，直到考察完所有的弦。  
