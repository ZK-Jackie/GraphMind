entity,type,source,attribute,uid,level,content
"(n,m)图",概念,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.2 图的定义与分类']","{'实体类型': '概念', '定义': '含有n个结点，m条边的图'}",,3,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)"
0-1法记分,算法,"['第六章 特殊关系模型', '§ 6.3 偏序关系与元素比较', '6.4.2 得分评判问题']","{'实体类型': '算法', '定义': '通过比较选手表现，用0和1记录优劣的记分方法', '应用': '在比赛过程中对选手进行动态排名'}",,3,"在很多需要排名次的非相互对抗场合，如歌手大赛中的参赛选手、成员的考评、电视节目中主持人大赛中参赛选手的考评等，其评断标准并不像球赛中进球、失球那样准确无误，往往由评判员们分别打分，通过分数计算名次。然而，分数有其不公平的一面。例如，甲、乙、丙三名歌手的得分分别为94 分，92 分，90 分。  
甲的分数-乙的分数$=$乙的分数-丙的分数。  
虽然这两个差相等，但并不能说明甲高出乙的水平等于乙高出丙的水平，因为这里1 分所表示的水平差距并不唯一确定，而是与评判者紧密相关。又如，对于期末考试中某班平均分语文85 分与数学60 分，该班某学生语文80 分，数学70 分，尽管$80>70$，也不能说明这名学生语文学的比数学好。因为这里分数基准点是不一致的。因此有了“标准分”和“等级记分”等科学记分方法，如 “优秀，良好，合格，不合格”四级打分法便是其中一种。  
由偏序关系的定义可知，任何排名次必是一个偏序关系，并且在很大情况下应是线性关系。因此，在上述排名场合（如歌手大赛考评等）可使用“0-1”法记分，并利用偏序关系的反对称性，在比赛过程对选手进行动态排名。下面结合具体实例介绍具体排名过程：  
设有 $A_{1},A_{2},A_{3},A_{4},A_{5},A_{6}$ 这 6  名参赛者，按其下标次序出场比赛。分别为每名评判员准 备一张如表$6–4$ 所示的表格用于对选手进行打分评判。  
表6-4 评判表
![](images/4c85af2d68ddc01acb3d234836cc3dd6fee35852bbb1e27a76917d56b5336e04.jpg)  
每个评判员的打分方法如下：当$A_{2}$参赛结束时，立即把他与$A_{1}$比较，谁更好一些，若$A_{2}$好一些，在表6-4 的$\mathsf{C}_{21}$位置填上1，若$A_{1}$好一些，则在该位置填上0；$A_{3}$参赛结束后，依次与$A_{1}$、$A_{2}$比较谁好一些，好一些为1，差一些为0，并把这两个比较出来的数依次填在${\mathsf C}_{31}$和  
${\mathsf{C}}_{32}$的位置上。如此下去，知道所有的选手参赛结束。即有：  
$$
C_{ij}=\begin{cases}1&\quad\text{当}A_i\text{比}A_j\text{好时}\\0&\quad\text{当}A_i\text{比}A_j\text{好时}\end{cases}\quad(j<i)\quad\text{(6-5)}
$$  
注意的是，当某一位选手比赛结束都要与他参赛的每一名选手比较而且给出谁好谁差的结论(是1 还是0)。也可以利用偏序关系的传递性减少比较次数。如$A_{5}$比$A_{1}$强，而此时已经有$\mathsf{C}_{31}=\mathsf{C}_{41}=0$，则必有${\mathsf{C}}_{53}={\mathsf{C}}_{54}=1$。表6-5 是某一位评判员所裁判的结果。  
表6-5   评判结果
![](images/0095a64294f10a0d76e1eae14906fdb5c9f5e6a5bc895b20e56aa4e7f6a6e039.jpg)  
如$|A_{5}$行说明$A_{5}$比$A_{1}$好，比$A_{2}$差，比$A_{3}$好，比$A_{4}$  
然后对表6-5 进行整理：首先利用偏序关系的反对称性填充表格的上角，上表虚线为对称轴，右上角各个位置(如$\mathsf C_{12}$)看它的对称位置(即$\mathsf{C}_{21}$)上的数，若其对称位置上数为$1\left(\mathbb{C}_{21}=1\right)$,则它为$0\left(\mathsf{C}_{12}=0\right)$)；若其对称位置上的数为1，则它就是0。即有：  
$$
\mathrm{C}_{ij}=\begin{cases}0&\quad\text{当C}_{ji}=1\text{时}\\1&\quad\text{当C}_{ji}=0\text{时}\end{cases}\quad(i<j)\quad\text{(6-6)}
$$  
完成后如表6-6 所示：  
表6-6 对评判结果的整理
![](images/620931865382a676e3093ac6d3295347415e7bef2cda108424f0318f6d3c3129.jpg)  
把表6-6 各行的数字加起来填入总分列中（倒数第二列），这个列中各数分别为其所在行中相应选手的得分。它们不可能有两个相等的数，否则说明评判或填表有误应作废。把这个列的各数相加填入这一列最后一格为总分和$σ$。事实上$σ$是一个固定数$σ=m(m-1)/2$其中$m$为参赛选手的人数。本例中$m=6$，故有$σ=6*(6-1)/2=15$。  
把表6-6 中各列数字加起来，填入最后一行（即总分行）的相应位置上，分别为其所在列上相应选手的失分，以虚线为对称轴和其对称位置上的得分加起来应该等于$m-1$，  
减1 是因为自己不与自己比较，总分行总分和也等于$m(m-1)/2$。表的最后一列是把各选手的得分转化为人们习惯的百分制，本例中用的是$(m-1)*$得分数$+60$，以避免出现低于60 分的情况，最后把所有评判员有效给出的各个选手成绩相应加起来求平均成绩，按平均成绩高低排名次，此时可能出现并列名次。"
BP神经网络模型,算法,"['第八章  图的基本理论与算法', '§ 8.5 图模型的应用', '8.5.3 机器学习问题']","{'实体类型': '算法', '提出时间': '20世纪80年代末期', '应用': '浅层机器学习'}",,3,"1959 年，美国塞缪尔教授设计了一个具有学习能力的下棋程序。它可在不断对弈中改善自己的棋艺。4 年后，该程序战胜了设计者本人。又过3 年，该程序战胜了美国常胜冠军。由此可以看出机器学习的能力，特别是当下谷歌设计的AlphaGo 程序与围棋大师李世石的围棋大战，更是体现了机器学习的威力。所谓机器学习，就是数学模型或求解算法中具有似于人类的学习机制，能够从实际问题中采集适当样本数据，根据样本数据自动算出参数值，并随着样本数据的变化自动调整参数取值，使得数学模型和求解算法具有良好的普适性和自适应性。按机器学习的模型结构层次来分，机器学习经历了两次浪潮，分别是浅层学习和深度学习。近年来，机器学习的概念异常火爆，各种机器学习算法层出不穷。本小节简要介绍图模型在浅层学习和深度学习中的与应用。  
![图8-73 BP 网络结构](images/3e28bfeab67aaebdd2a54ed46ef1bb594380bb5384ccdde94e5e1d5ae51f9049.jpg)  
![图8-74 支持向量机结构](images/0d16cdb37dc68fb29e3b36be467fd837d3d52e2ccd7acbba9de1c8c373e6974d.jpg)  
无论是浅层学习还是深度学习的模型结构都是基于图模型。  图8-73 所示的图模型是20 世纪80 年代末期提出BP 神经网络模型，图8-74 所示的图模型是20 世纪90 年代中期提出支持向量机模型。 这些都是机器学习中的经典图模型用于浅层的机器学习。 正是这些图模型的建立给机器学习带来了希望，掀起了基于统计模型机器学习热潮。人们使用这类权图模型从大量训练样本中学习统计规律，然后根据学到的规律对未知事件进行预测。  
![图8-75 简单函数对复杂函数的逼近 ](images/fbe962cff1ffa6a7bb0339da768141046705e07e74feba559a3752dfe9c241b2.jpg)  
![图8-76 多层模型表示复杂函数  ](images/272fe3358ea6997e106f1355c74465d9d8b3888427cf64765b441f271abcfeac.jpg)  
然而，进入21 世纪，浅层学习研究的发展遇到瓶颈。从而，人们创立了深度学习的相关概念和理论，并借助分布式云计算的大数据平台，在机器学习领域取得了突破性进展。深度学习通过一种深层非线性网络结构，组合低层特征形成更加抽象的高层表示属性类别或特征，实现由简单函数向复杂函数的有效逼近，以发现数据的分布式特征表示。其具有强大的从少数样本中集中学习数据集本质特征的能力。图8-75 表示一个通过简单函数逼近复杂函数的实例。  
简单地说，深度学习就是对拥有深层结构的模型进行训练。所谓深层结构，是相对于前述的浅层结构而言的，两者的差异主要在于拥有的非线性运算单元的层数不同。深层结构是指非线性转换单元的层数大于或等于两层的模型，而使用多层模型的优势即可以使用较少的参数表示复杂的函数。使用多层模型表示复杂函数的例子如图8-76 所示。  
![图8-77 含多隐含层的深度学习模型图  ](images/a696f4639cd9bb8eadcb3b542d30322c2127fff383c01a8ce40760e85d44b787.jpg)  
![图8-78 自动编码器(AE)结构示意图  ](images/d437ba8ccbf4e13b83ff799a9ddec1778e03cc7629e09224d02fe81a54b359de.jpg)  
深度学习在模型中构建多层隐含层，并通过大量样本训练模型参数，获得更有用的特征，从而有效提升分类或预测的准确性。相比较传统的浅层结构，深度学习更强调了模型结构的深度，通常有5 至6 层隐含层，有的模型结构甚至包含10 层以上隐含层。此外，深度学习明确突出了特征学习的重要性。深度学习实现多层堆叠，每一层的输出作为下一层的输入，高层的特征是低层特征的组合，从低层到高层的特征表示越来越抽象，越来越能表现语义或者意图。而抽象层面越高，存在的可能猜测就越少，就越利于分类。换句话说，深度学习通过逐层特征变换，将样本在原始特征空间表示逐层变换到新的特征空间，从而使分类或预测的效果更加准确。图8-77 表示一个含多隐含层的深度学习模型。事实上，由如图8-78 所示自动编码器组合或其简单变形的模型也可看成是深度结构，例如堆叠自动编码器，稀疏自动编码器等。  
深度学习是机器学习发展的产物。与传统的机器学习方法相比，深度学习优势明显，目前在图像识别、语音识别、自然语言理解等领域得到广泛的应用。"
B树,概念,"['第九章  树的基本理论与算法', '§ 9.3 特殊根数与算法', '2. B树的插入', '9.3.3 B树模型']","{'实体类型': '概念', '相关算法': '典型特殊树模型及其基本算法', '定义': ['为磁盘或其他直接存取存储设备而设计的平衡多路查找树', '一种自平衡的树数据结构，用于存储排序数据'], '特点': ['每个结点可以有很多孩子，在磁盘I/O操作上更为简洁', '每个结点包含多个关键字，关键字个数不大于m-1'], '应用': '在数据库系统等动态集合操作方面具有广泛应用', '性质': ['每个结点最多有m个分支，最少分支数要看是否为根结点，若为根结点，则根结点的分支数至少为2，否则非根结点至少有⌊m/2⌋个分支', '结点的分支数等于关键字数加1，即n(k≤n≤m)个分支的结点含有n-1个关键字，它们按递增顺序排列', '每个结点的结构包括关键字和指向孩子结点的指针，且关键字按升序排列', '结点内各关键字互不相同，并按升序排列', '各个底层结点都是叶子结点，并且处于同一层'], '插入操作': '插入结点时需注意关键字的个数，若结点关键字个数等于m-1则引起结点分裂', '分裂过程': '以中间关键字为界将结点一分为二，中间关键字插入到父结点中，可能一直分裂到根结点'}",,1,"树是大家非常熟悉的一类植物。通过对树的观察，不难发现自然界中的树总是有根、枝和叶，且具有这样一些特点：从根上可以长出枝来，从树杈上可以长出枝或叶，叶梢不长在一起，根、枝、叶之间总是畅通的，但它们之间不能构成圈。从结构上看，树是所有连通无向图中边数最少的图模型，同时也是所有无环无向图中边数最多的图模型。我们不得不惊叹大自然的神奇，竟然创造出如此高效而又和谐的离散结构。对自然界中树的这种特殊离散结构进行抽象，就可得到一种特殊的图模型，即树模型。在所有的图模型中，树模型是一种最简洁的连通无环结构，其中各结点之间有着最直接、最必要的联结关系。这种最简洁的连通结构决定了树在图模型知识体系中占有特别重要的地位。目前，树作为一种特殊图模型已被广泛应用于计算机各个领域，例如操作系统采用树结构来组织文件数据，编译程序采用树表示源程序的语法结构，在数据库系统中树被用来组织信息等等。  
本章主要介绍树模型基本理论及其算法设计的基本知识，首先介绍树模型的基本概念与性质、生成树与最小生成树等关于树模型的基本理论，然后具体讨论根树的概念与算法，包括树的递归遍历算法、森林与树的转换算法、最优树的构造与编码算法等，并在此基础上进一步学习若干典型特殊树模型及其基本算法，包括平衡树、红黑树、$B$树等，最后给出树模型的若干应用实例，包括决策树、博弈树等。"
B树插入,算法,"['第九章  树的基本理论与算法', '§ 9.3 特殊根数与算法', '9.3.3 B树模型', '2. B树的插入']","{'实体类型': '算法', '步骤': '确定插入结点位置，根据结点关键字个数决定直接插入或进行分裂', '分裂条件': '结点关键字个数等于m-1', '结果': '可能增加树的高度'}",,4,"插入操作后所构成的新树必须满足$B$树性质，因此插入结点时需注意关键字的个数$n$不大于$m-1$。对于高度为ℎ的$m$阶$B$树，新结点一般插在第$B$层。通过查找算法可确定关键字应该插入的结点位置。确定插入结点位置后，分两种情况讨论具体的插入算法：  
（1）若该结点中关键字个数小于$m-1$，则直接插入即可。  
（2）若该结点中关键字个数等于$m-1$，则将引起结点的分裂，以中间关键字为界将结点一分为二，产生一个新结点，并把中间关键字插入到父结点中；  
重复上述步骤，直到完成插入过程。最坏情况是一直分裂到根结点，建立一个新的根结点，此时整个$ B$树增加一层。  
下面举例说明插入操作过程。插入以下字符到一棵空的5 阶𝐵树中（非根结点关键字数小于2 个就合并，大于4 个就分裂）：A C G N H E K Q M F W L T Z D P R X Y S。  
（1）首先，结点空间足够，4 个字母插入相同的结点中，如图9-42 所示。  
（2）当尝试插入H 时，结点空间不够，所以将其分裂成2 个结点，中间元素G 向上移动到新的根结点中。如图9-43 所示。  
![](images/4252a61f0ce4fd7310cb10ae1c8ef9c4cfae235cd68e80db30453bdc99e5d47e.jpg)  
（3）当插入E，K，Q 时，不需要任何分裂操作，直接插入即可。 如图9-44 所示。  
（4）当插入M 时，需要一次分裂操作，M 恰好是关键字中间元素，所以向上移动到父结点中。如图9-45 所示。  
![图9-44 插入关键字E、K、 ](images/413fc8320073f6da8cae62a3551646b6ad17f52b2f2f3caa12b077b03b93686c.jpg)  
![图9-45 插入关键字M ](images/76c9ba7db0359db7182dec9348774647f14e47a0638c3639e74fc1bfaea175f7.jpg)  
（5）当插入F，W，L，T 时，不需要任何分裂操作，直接插入即可。如图9-46 所示：  
（6）当插入Z 时，由于最右侧的叶子结点空间满了，所以需要进行分裂操作，其中间元素T 向上移动到父结点中。如图9-47 所示。  
![图9-46 插入关键字F、W、L、](images/d374a861c9384b4be501fa4310531c8976cfd9c204a9c7d08ed4c30a0261306f.jpg)  
![图9-47 插入关键字Z ](images/42aa51968fd33b9d1c3398201657eb65ce8553616837c9b57361320bef21dce1.jpg)  
（7）当插入D 时，由于最左侧的叶子结点空间满了，所以需要进行分裂操作，D 恰好也是中间元素，向上移动到父结点中，然后继续插入字符P，R，X，Y，不需要任何分裂操作，直接插入即可。如图9-48 所示。  
![图9-48 插入关键字 ](images/1874fefa5d34c0110fe81e072d0de6ba5528071a8c60552512913414998d6a65.jpg)  
![图 9-49   插入 关键字 S  ](images/53a2894f1112d19b944696c842dc4e67f6f7578920a01e421aa4d4aefbc623c2.jpg)  
（8）最后，当插入S 时，含有N，P，Q，R 的结点需要进行分裂操作，把中间元素Q向上移动到父结点中，但是，父结点中已经满了，所以也需要进行分裂，将父结点中的中间元素M 向上移动到新形成的根结点中。这样具体的插入操作完成，如图9-49 所示。"
B树查找算法,算法,"['第九章  树的基本理论与算法', '§ 9.3 特殊根数与算法', '9.3.3 B树模型', '1. B 树的查找']","{'实体类型': '算法', '详细介绍': '在本书第七章查找算法设计中将详细介绍和讨论B树查找算法'}",,4,根据结点的孩子数做分支界定。比较要查找的值与当前值的大小，若比当前值小则在其左子树，否则在其右子树，递归查找，直到找到相等的结点为止，并返回该结点的位置。如果直到叶子结点仍然没有找到则返回$Null$。在本书第七章查找算法设计中将详细介绍和讨论$𝐵$树查找算法，不再赘述。
B树模型,模型,"['第九章  树的基本理论与算法', '§ 9.3 特殊根数与算法', '3. B 树的删除', '1. B 树的查找', '9.3.3 B树模型']","{'实体类型': ['模型', '概念'], '特点': '特殊根树模型之一', '定义': 'B树的具体实现模型，描述了B树的结构和操作', '查找方法': '根据结点的孩子数做分支界定，比较要查找的值与当前值的大小，若比当前值小则在其左子树，否则在其右子树，递归查找，直到找到相等的结点为止，并返回该结点的位置', '查找结果': '如果直到叶子结点仍然没有找到则返回Null', '删除操作': '可以从任意结点中删除一个关键字，比插入操作复杂', '删除情况': {'叶子结点删除': {'情况1': '若结点中关键字个数$n\\\\geq\\\\lceil m/2\\\\rceil$，直接删除该结点', '情况2': '若结点关键字个数为$n=\\\\lceil m/2\\\\rceil-1$，且相邻结点关键字个数$n\\\\geq\\\\lceil m/2\\\\rceil$，进行关键字和子树指针的调整', '情况3': '若结点关键字个数为$n=\\\\lceil m/2\\\\rceil-1$，且相邻结点关键字个数也为$n=\\\\lceil m/2\\\\rceil-1$，进行结点合并'}, '非叶子结点删除': '以子树中的最小关键字代替被删除关键字，再在叶子结点中删除该关键字'}, '合并结点处理': '可能需要自底向上直到根结点'}",,2,根树是一类非常重要的树模型，能够对很多复杂的数据信息进行表示和处理，广泛应用于程序设计、数据结构、算法设计与分析、操作系统等多门后续课程。根树的种类很多，可以针对不同类型的问题或数据建立相应类型的根树模型。本节着重介绍三种最为典型的特殊根树模型，即平衡树模型、红黑树模型和𝐵树模型，并分析和讨论这些模型的插入、删除、更改、旋转等基本算法，旨在为后续相关专业课程的学习打下良好的基础。
CP规则,规则,"['第三章  命题演算与推理', '§ 3.5 命题逻辑的演绎推理', '3.5.2 命题公式推演系统']","{'实体类型': '规则', '定义': '如果能从给定的前提集合Γ与公式P推导出S，则能从此前提集合Γ推导出P→S', '适用条件': '适用于结论为条件式的有效推理'}",,3,"现在我们学习命题的数理逻辑推理。首先给出如下有效推理的概念：  
【定义3.28】设$G_{1},G_{2}\cdots G_{n}$，$H$是一些命题公式，如果它们满足下列性质：对于这些公式的任意一个解释𝐼，$G_{1},G_{2}\cdots G_{n}$在该解释下同时为真的情况下$\cdot_{H}$在该解释下也为真，则称命题公式$G_{1},G_{2}\cdots G_{n}$可有效推出公式$\cdot H$，或称由$G_{1},G_{2}\cdots G_{n}$得到$H$的逻辑推理为有效推理，记为$G_{1},G_{2}\cdots G_{n}\Rightarrow H$，并称$G_{1},G_{2}\cdots G_{n}$为推理前提，$H$为$G_{1},G_{2}\cdots G_{n}$的逻辑结论。  
从上述定义不难看出，有效推理其实就是把永真蕴含关系由两个命题公式之间的关系推广到多个命题公式之间的关系，即由一组命题公式构成的永真蕴含前件与一个永真蕴含后件之间的关系。下面定理表明有效推理的过程其实就是证明逻辑蕴含式的过程。  
【定理3.14】命题公式$H$是命题公式$G_{1},G_{2},\cdots,G_{n}$的逻辑结论，即$G_{1},G_{2},\cdots,G_{n}\Rightarrow H$，当且仅当$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\to H$为永真公式。  
从理论上讲，利用真值表技术完全可以在有限的步骤内完成对任意含有限个命题变量的永真蕴含关系进行判定或者说进行有效的命题逻辑推理。但是，在针对具体问题的命题逻辑推理时，推理的前提条件一般包含很多个命题公式，有时会涉及大量的命题变量，此时真值表方法就出现组合爆炸问题而变的不可行。因此，需要建立一种命题公式推演系统，在少量基本等值关系式和永真蕴含关系式的基础上，通过建立若干推理规则进行演绎推证的方式实现命题逻辑的有效推理。人们提出了很多各具特色的推演系统，对这系统的详细讨论已经超出了本课程的学习范畴，有兴趣的读者可以查阅相关资料。我们主要介绍一种最基本的推演系统，下图3-9 表示系统的基本结构。  
![](images/9e9fac00c2d40b2f3ec288b2f0ea17c474bc9160a1447874b9a37744cd5272d2.jpg)
图3-9 推演系统的基本结构  
上图表示的推演系统中包括事实库、公理库和推理规则这三个基本模块，公理库和事实库构成命题推理的基本依据。公理库包含已被证明为正确的24 个基本等值式和15 个基本永真蕴含式，这些基本关系式构成推演系统的基础知识资源，事实库由具体命题推理实例的所有前提条件以及推理过程中产生的有效中间结论组成；推理规则是命题逻辑推理的核心机制，主要由$P$规则、$T$规则和$C P$规则这三个基本规则组成。  
（1）$P$规则（前提引用规则）：推导过程中可随时引入前提集合中的任意一个前提。  
（2）$T$规则（逻辑结果引用规则）推导的过程中可随时引入公式𝑆，该公式𝑆是由其前的一个或多个公式推导出来的逻辑结果。  
（3）$C P$规则（附加前提规则）如果能从给定的前提集合$\Gamma$与公式$P$推导出𝑆，则能从此前提集合$\Gamma$ 推导出$P\rightarrow S$。  
注意：$C P$规则适用于结论为条件式的有效推理。使用𝐶𝑃规则就是把结论中的前件作为附加前提加入前提集合，共同去推出结论的后件。  
根据上述命题演算推理系统，就可进行有效的命题逻辑推理。通过有效推理，就可证明命题逻辑中所有定理。所谓证明，就是有效推理的具体推演过程，具体定义如下：  
【定义3.29】从前提集合Г 推出结论$\cdot H$的一个演绎或形式证明，就是构造一个命题公式的有限序列：$H_{1},H_{2},H_{3},\ldots,H_{n}$。其中：$H_{i}$或者是Г 中的某个前提，或者是前面的某些${\cdot}H_{j}(j{<}i)$的有效结论，并且${\cal H}_{n}$就是$H$。此时称$H$为该演绎的有效结论。"
Ford-Fulkerson算法,算法,"['第十章  特殊图模型与算法', '§ 10.4 网络流图及其优化问题', '10.4.3 最大流求解算法']","{'实体类型': '算法', '提出者': 'Ford.L.R和Fulkerson.D.R', '基本思路': '迭代寻找增广路径增加流值，直到残留网络中不包括增广路径', '依赖概念': '残留网络、增广路径、切割', '正确性保证': '最大流最小切割定理'}",,3,"网络流理论的创立主要用于解决最大网络流问题，即在一定的约束条件下，如何使得网络中流的总量达到最大。该理论证明了最大流量一定等于最小割容量这个重要结论，并根据这一结论设计并实现了多种最大流的算法。其中比较经典的有Ford-Fulkerson 算法、Edmonds-Karp 算法、Dinic 算法以及预流推进算法等。  
本节主要介绍其中最具代表性的Ford-Fulkerson 算法。该算法由美国普林斯顿大学的两位著名运筹学教授Ford.L.R 和Fulkerson.D.R 提出。Ford-Fulkerson 算法是一种迭代算法，基本思路如下：首先，对所有结点$u,v\in V$令$f(u,v)=0$。然后，通过迭代的方式不断在残留网络中寻找一个增广路径来增加流值，直到残留网络中不包括增广路径为止。  
具体地说：首先，初始化一条容量为0 的流$f$和一个残余网络$G_{f}$，第一个残余网络为原  
图$G$，每条边的残留容量初始化为每条边的初始容量$c_{f}(u,v)=c(u,v)$。然后，在残留网络$G_{f}$中寻找增广路径$P$，取增广路径$P$中的边的残留容量$c_{f}(u,v)$最小值作为流的增量$\triangle\,f$，使得$f^{\prime}=f+\triangle\,f$。修改剩余图中每条边的容量：  
$$
c_{f}^{\prime}(u,v)=c_{f}(u,v)-\triangle\,f
$$  
得到残留网络$ G_{f}$。重复上述过程，直到找不到一条增广路径为止。  
Ford-Fulkerson 算法依赖于残留网络、增广路径和切割这三个概念。算法的正确性可由最大流最小切割定理保证。设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和𝑡分别为其源点和汇点，$f$为$G$的一个流，则该算法基本过程如下：  
1）对网络$G=\langle V,E\rangle$初始化，使$f(e)=0$，$e\in E$  
2）给源点𝑠标号$(-,\ \infty)$，其它结点均未标号；  
3）依次选一个未标号的结点，根据其方向进行标号，若当前标号的结点为汇点𝑡，转步骤4），否则转步骤6）；  
4）选择一条标号过的增流路径进行增流；  
5）转步骤2）  
6）这时得到的$f$就是最大可行流。  
对于如图10-72 为初始网络$G$，其中边上的数字表示对应边的容量，下面介绍通过Ford-Fulkerson 算法寻找其的最大可行流的具体实现过程：  
1）首先初始化$f(e)=0$，$e\in E$，如图10-73 所示；  
2）给源点$𝑠$标号$(-,\infty)$，其它结点均未标号，如图10-74 所示；  
![](images/d01d4ec14f1aff44a86873230240f7edbcb814f97a9366a1ac732e953b2aaa81.jpg)  
3 ）选可进行正向或反向标号的结点进行标号，若当前标号的结点为 𝑡 ，则转步骤 4 ） ； 若 没有这样的结点可选时，则转步骤6），如图10-75 所示；  
4）当前标号的结点为𝑡，对标号过的增流路径进行增流，增流路径为：$(s-\textit{a}-\textit{b}-$$c-\ t)$，增量$\triangle\,f$取增广路径中的边的残留容量$c_{f}(u,v)$最小值2，如图10-76 所示；  
5）转到步骤2），即给源点𝑠标号$(-,\infty)$，其它结点均未标号，如图10-77 所示；  
![](images/34aabd8b5a71470ee2b35d4d37961da9a5f6ada16975b230634ead0f16e07488.jpg)  
6）类似地，按照步骤3 再次进行标号，如图10-78 所示；  
7）当前标号的结点为𝑡，对标号过的增流路径进行增流，增流路径为：$(s-b-a-t)$增量$\triangle\,f$取增广路径中的边的残留容量$c_{f}(u,v)$最小值6，如图10-79 所示；  
8）同理，再对源点𝑠标号$(-,\ \infty)$，其他结点均未标号，如图10-80 所示；  
![](images/0f5b5f38aed586b9e60d5dccb4b3630e897dacff029a529f37f234c7155e86b7.jpg)  
9）按步骤3，再次进行标号，如图10-81 所示；  
10）当前标号的结点为𝑡，对标号过的增流路径进行增流，增流路径为：$\begin{array}{r l r}{~~~}&{{}(s-}&{b-a-}\end{array}$$t)$，增量$\triangle\,f$取增广路径中的边的残留容量$c_{f}(u,v)$最小值2，如图10-82 所示；  
11）同理，再对源点𝑠标号$(-,\ \infty)$，其他结点均未标号，类似的，增流路径为：$(s-\ b-$$c-t)$，增量$\triangle\,f$取1，如图10-83 所示；  
![](images/062c661062259beec86ff3629be8e97fdac80b28c61e2ace5ae35565f4731050.jpg)  
12）同理，再对源点𝑠标号$(-,\ \infty)$，其它结点均未标号，类似地，增流路径为：$\begin{array}{l l}{(s-}&{c-}\end{array}$$t)$，增量$\triangle\,f$取2，如图10-84 所示；  
13）同理，再对源点𝑠标号$(-,\ \infty)$，其它结点均未标号，类似地，增流路径为：$(s-c-$$b-a)$，此时当前结点为$a$，算法结束，所得可行流即为所求最大流，如图10-85 所示。  
![图10-84  增流过程  5](images/1913d4d69345305d204c147879cef0c2b861b90402556b9d5ebafe81eeaf5bff.jpg)  
![图10-85  网络$G$最大流  ](images/d7adb0913e78b96ab009478c7164178b41b7185b8446090115774418a82e3cf7.jpg)  
下面给出网络最大流的一个具体应用实例：  
【例题10.17】某货运车站有$n$个车道，由于车道长度有限，每个车道在某时刻最多只能停靠一列货运列车。车站正常运行后，每天有$m$列货运列车从车站经过，其中第$i$ 列列车到达车站的时间为$𝑅𝑒𝑎𝑐ℎ[𝑖]$，列车上装有价值$𝐶𝑜𝑠𝑡[𝑖]$的货物。如果准许列车𝑖进站，则车站将获得$10\%\times C o s t[i]$的收益，受到货物搬运时间制约，列车在站停留时间长度为$𝑆𝑡𝑎𝑦[𝑖]$。这段时间内，列车将占用车站某个车道；若不允许某列车进站，则该列车直接出站，此时车站无任何收益。现有2 个车道，5 列列车，列车进站时间、停车价值、停留时间如表10-1 所示，如何合理安排列车的进站与出站，才能使得车站的总收益最大？  
![表10-1 时间价值表 ](images/a7dc7c1c3b8b134efa88b94b361c280ae0e7e4db6c3d4edd361dc330595e5076.jpg)  
![图10-86 进出站时间 ](images/2c392864c4179f14536de4f9b63f959455c42ecc7344ede3aef7ced37250a84d.jpg)  
【解】可用一个流网络对该问题进行建模，具体过程如下：  
1）将每一列列车看成是联结两个结点的一条带权边，如第𝑖列列车拆成点$𝑖$和$i^{\prime}$，$𝑖$到$i^{\prime}$之间加一条容量为1，费用为$10\%\times C o s t[i]$的边$i\rightarrow i^{\prime}$；若$i\rightarrow i^{\prime}$的边的流量为1，则表示该列火车进站，并获得$10\%\times C o s t[i]$。  
2）增加一个源点$S$，$S$与每个点$i$连一条容量为1 费用为0 的边$S\rightarrow i$；如果$S\rightarrow i$的流量为1，则表示列车$𝑖$作为某个车道的第一列入站的列车  
3）再增加一个源点$S^{\prime}$，$S^{\prime}{\to}S$的容量为$n$，表示有$n$个车道；  
4）增加一个汇点$T$，每个点$i^{\prime}$与𝑇连一条容量为1 费用为0 的边$i^{\prime}\rightarrow T$；如果𝑖’ $\rightarrow T$的流量为1，则表示列车$𝑖$作为某个车道的最后一列入站的列车；  
5）对于所有$𝑖$和$j(i\neq j)$，如果$R e a c h[i]+S t a y[i]<R e a c h[j]$，则在$i^{\prime}$与$𝑗$之间连一条容量为1，费用为0 边，表示可以在某一个车道先停入列车𝑖，等𝑖出站后再停入列车𝑗。  
![图10-86 列车流量网络模型  ](images/e877c0962ea89c788357a0ce9a48c4f306c3bc33bc71d559136cc0a052c8c375.jpg)  
![图10-87 列车调度问题总收益最大流图  ](images/820628b77bdb2600c45369a5e8ccfe88b488f7bb28ab752799b5e76d0dabc2f0.jpg)  
如图10-86 所示的流网络为列车调度的流量网络模型，其中粗线箭头上的数字表示费用，未标数字的弧的费用为 0 ，未标明容量的弧的容量为 1 。  
![图10-88 列车进站安排  ](images/25158a79180787e9c0c3c5ee956180ccd3bcebdba893d1c1a3d3773d0bfcced1.jpg)  
对于求解出来的所有最大流分别计算整个网络的费用，求得如图10-87 所示的最大流即为安排列车的进站与出站，使得车站的总收益最大的方案，其中粗线箭头上的数字表示流量，未标数字的弧的流量为0。由图10-87 知，列车进站的最优安排方案为：让列车1、3 进站并停留在第一车道，列车2、5 进站并停留在第二车道，具体如图10-88 所示，其中粗线表示先停入列车1 再停入列车3；细线表示先停入列车2 再停入列车5。此时车站最大收益为$0.5+0.6+0.4+0.3=1.8$。"
PERT图,概念,"['第八章  图的基本理论与算法', '§ 8.5 图模型的应用', '8.5.2 作业规划问题']","{'实体类型': '概念', '定义': '一个有向连通图G=⟨V,E⟩，每条边表示一个作业，边的非负实数权表示完成该作业所需的时间，每个顶点表示作业的开始和结束，没有有向回路和环，有且仅有一个顶点的入度为0（源点）和出度为0（汇点）', '特点': '用于表示工程中作业的依赖关系和时间', '应用': '求解关键路径问题，合理安排工程活动'}",,3,"生活中有着多种多样的工程，而每一项工程往往都是由多种不同的活动相互组合而成，这些活动中，有的可以并行执行，而有的活动却必须要等到前面的准备活动都做好之后才能开始进行。例如，在一个软件开发项目中，包括以下几个阶段：需求分析，系统设计，模块代码编写，单元测试，软件维护。其中代码编写和单元测试可以同时进行，但是代码编写却一定要在需求分析和系统设计完成之后才行，需求分析和系统设计构成了代码编写的准备工作。既然存在这样的现象，那么在一项很复杂的工程中，如何合理的安排活动的进行，能够使得整个工程完成时间最早呢？其实，这就是关键路径问题。在求解关键路径问题之前，我们有必要先了解下PERT 图的相关概念。  
PERT 图是一个有向连通图$G=\langle V,E\rangle$，且  
（1）每条边表示一个作业（工序），边的非负实数权表示完成该作业所需的时间；  
（2）每个顶点表示以该顶点为起点的作业开始，也表示以该顶点为终点的作业结束；  
（3）作业开始条件：某条有向边$e=\langle v,u\rangle$所代表的作业可以开始 当且仅当 以v为终点的有向边所代表的作业全部完成；  
（4）G没有有向回路，也没有环；  
（5）G中有且仅有一个顶点的入度为0，称该顶点为源点；同时G中有且禁言一个顶点的出度为0，称该顶点为汇点。  
对于给定的PERT 图$G=\langle V,E\rangle$，我们主要关心其关键路径，以及每个作业的最早开始时间和最晚开始时间。关于PERT 图，有如下定义：  
（1）关键路径：G中从源点到汇点最长带权路径路径称为关键路径。关键路径的长度T为完成整个任务（即包括所有作业）所必需的最少时间。  
（2）关键作业：关键路径上的边所代表的作业称为关键作业。  
（3）最早启动时间：对于某个作业${e}=\left<v_{i},-\right>$，源点到该作业起点$v_{i}$的最长路径长度$\pi_{i}$称为该作业的最早启动时间。  
（4）最晚启动时间：设$v_{i}$到汇点${v}_{n}$的最长路径长度为$\pi_{i}^{\prime}$，则该作业可最晚于$\mathsf{\Delta}\mathsf{T}_{i}=\mathsf{T}-$$\uppi_{i}^{\prime}$时间启动而不影响整个任务完成的预期时间T，$\uptau_{i}$称为该作业的最晚启动时间。  
显然，作业${e}=\langle v_{i},-\rangle$是关键作业当且仅当$\pi_{i}=\uptau_{i}$，因为这时e是处于源点到汇点最长带权路径上。故可通过求每个作业的最早启动时间和最晚启动时间而得到PERT 图的关键路径。那么如何求解作业的最早启动时间和最晚启动时间呢？下面给出了求解方法：  
设PERT 图$G=\langle V,E\rangle$的顶点编号$v_{1},v_{2},\dots,v_{n}$，使得边$e=\langle v_{i},v_{j}\rangle\in E$蕴含$i<j$  
令$\pi_{1}=0$，$\pi_{j}=m a x\{\pi_{m}+w(v_{m},v_{j})|1\leq m<j\}$，则$\pi_{i}(1\leq i\leq n)$是作业$e=\langle v_{i},v_{j}\rangle$的最早启动时间。这里$w(v_{m},v_{j})$定义为：  
$w(v_m,v_j)=\begin{cases}\text{边}\langle v_m,v_j\rangle\text{的非负实数权,~~~~~~~~若}\langle v_m,v_j\rangle\in E;\\-\infty,&\text{否则}\end{cases}\text{(8-18)}$  
令$\tau_{n}=\pi_{n}$，$\tau_{k}=m a x\{\tau_{k},\tau_{k}-w(v_{k},v_{m})|k<m\leq n\}$，则$\tau_{i}(1\leq i\leq n)$是作业$e=$$\langle v_{i},v_{j}\rangle$的最晚启动时间。  
由于某顶点的最早启动时间（最晚启动时间）就是所有以该顶点为起点的作业的最早启动时间（最晚启动时间）。因此求解关键路径，可以通过计算每个顶点的最早启动时间和最晚启动时间来确定。  
另外，为了更方便的判断顶点$v_{i}$是否为关键路径上的顶点，在此定义$v_{i}$的缓冲时间$S_{i}=$$\tau_{i}-\pi_{i}$。在关键路径上，各顶点的缓冲时间𝑆均为0，任何关键作业如果耽误了时间𝑡，整个工程就耽误了时间𝑡。下面给出求解关键路径的具体例子。"
PERT图模型,原理,"['第九章  树的基本理论与算法', '§ 9.4 树模型的应用', '9.4.3 关键道路问题']","{'实体类型': '原理', '应用': '解决工程作业安排问题', '特点': '图中不含向回路，边表示作业，权表示时间或费用'}",,3,"一项工程往往由许多作业构成，其中某些作业可以同时进行，而某些作业却必须按照一定先后顺序执行。例如，在建筑工程中，一般涉及到采购材料、平整地基、预制构件、埋设管道、砌墙立屋、室内装修等多个作业。其中平整地基和预制构件可以同时进行，而室内装修却必须在砌墙立屋之后才能动工等。这样就存在问题：为了使使得工期最短、成本最低，我们应该采取什么方法安排各个作业实施？  
我们知道，PERT 图模型可以很好地解决这类问题。图9-60 是一个PERT 图，图中不含有向回路。在作业网络中每条有向边表示一个作业，边上的权表示完成该项作业所需要的时间（或者费用）。源点（简称源）$𝑠$表示工程的开始，汇点（简称汇）$𝑡$表示工程的结束，其余结点$V_i$表示以该结点为终点的有向边代表的作业的结束和以该结点为始点的有向边代表的作业的开始。  
![](images/8a39c66fbf3ebe2db46646bd71380173dfca51b0b0532f41788a6ce4873cbcb6.jpg)  
第 8 章采用直接计算各个作业最早完成时间和最晚完成时间的方法计算关键路径，现在采用生成树方法计算源到其它结点的最长道路即关键道路，计算思路如下：  
（1）构造一棵以源 𝑠 为根的生成根树 $T$，且求出$s$到根树的各个结点 $v$ 的距离$L\left(\nu\right)$ 。  
（2）对任何一条权为$𝑊$$(u,v)$的弦$\langle u,v\rangle$，若$L(v)<\ L(u)+\ W(u,v)$，则从$T$中去掉以$v$为终点的有向边，而以有向边$\langle u,v\rangle$代之，同时使以$v$为根的子树中的各结点距离都增加$W(u,v)$，如此反复进行，直到考察完所有的弦。  
【例题9.21】求如图9-60 所示的作业网络的关键路径。  
【解】先构造由源𝑠到各个结点的最长道路的生成根树，即优化生成树，如图9-61 (a)- (d) 所示。再构造各个结点到汇 𝑡 的生成树，如图 $9–61\ (\mathsf{e})\tilde{\mathbf{\tau}}(\mathsf{g})$ 所示，然后在原图各个结点 $v$ 处 标以一个有序对$(a,b)$，其中$a$是图9-61 (d)中各$\mathbf{\nabla}^{\mathcal{V}}$的值，$b$是最长道路的权减去图9-61 (g)中各𝑣的值后的结果，如表9-2 所示。其中$a$与𝑏相等的结点所对应作业即为关键作业，由此可以得到如图9-61 (h)所示的关键路径。  
![](images/afad317ae3fcf5f241994658e1d9b51d47e2a890fb3c403b89c9e67033bfa386.jpg)  
![表 9-2  各个结点对应的有序对 ](images/2a1c04e98ea2f09c56274c954a2e76e48122dca03ff9c00a36aff31b122580fe.jpg)  
从图9-61 可知，$P=s V_{3}V_{1}V_{2}V_{4}t$是关键道路，$P$上的作业是关键作业。不在$P$上的作业都有缓冲期，例如$\langle s,V_{1}\rangle$只需3 个单位时间，在整个工程中它的动工时间为0，最晚完成时间为8，有5 个单位的多余机动时间。又比如作业$\langle V_{5},V_{6}\rangle$其最早动工时间为7，最晚完成时间为17，作业所需的时间为4，因此右6 个单位的机动时间，即使从时间13 开始也能按期完成。通过关键道路算法，重视关键作业的完成并合理利用非关键作业的缓冲期，就能做到整个项目的全盘把握，合理分配使用人力物力资源。"
P规则,规则,"['第三章  命题演算与推理', '§ 3.5 命题逻辑的演绎推理', '3.5.2 命题公式推演系统']","{'实体类型': '规则', '定义': '推导过程中可随时引入前提集合中的任意一个前提'}",,3,"现在我们学习命题的数理逻辑推理。首先给出如下有效推理的概念：  
【定义3.28】设$G_{1},G_{2}\cdots G_{n}$，$H$是一些命题公式，如果它们满足下列性质：对于这些公式的任意一个解释𝐼，$G_{1},G_{2}\cdots G_{n}$在该解释下同时为真的情况下$\cdot_{H}$在该解释下也为真，则称命题公式$G_{1},G_{2}\cdots G_{n}$可有效推出公式$\cdot H$，或称由$G_{1},G_{2}\cdots G_{n}$得到$H$的逻辑推理为有效推理，记为$G_{1},G_{2}\cdots G_{n}\Rightarrow H$，并称$G_{1},G_{2}\cdots G_{n}$为推理前提，$H$为$G_{1},G_{2}\cdots G_{n}$的逻辑结论。  
从上述定义不难看出，有效推理其实就是把永真蕴含关系由两个命题公式之间的关系推广到多个命题公式之间的关系，即由一组命题公式构成的永真蕴含前件与一个永真蕴含后件之间的关系。下面定理表明有效推理的过程其实就是证明逻辑蕴含式的过程。  
【定理3.14】命题公式$H$是命题公式$G_{1},G_{2},\cdots,G_{n}$的逻辑结论，即$G_{1},G_{2},\cdots,G_{n}\Rightarrow H$，当且仅当$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\to H$为永真公式。  
从理论上讲，利用真值表技术完全可以在有限的步骤内完成对任意含有限个命题变量的永真蕴含关系进行判定或者说进行有效的命题逻辑推理。但是，在针对具体问题的命题逻辑推理时，推理的前提条件一般包含很多个命题公式，有时会涉及大量的命题变量，此时真值表方法就出现组合爆炸问题而变的不可行。因此，需要建立一种命题公式推演系统，在少量基本等值关系式和永真蕴含关系式的基础上，通过建立若干推理规则进行演绎推证的方式实现命题逻辑的有效推理。人们提出了很多各具特色的推演系统，对这系统的详细讨论已经超出了本课程的学习范畴，有兴趣的读者可以查阅相关资料。我们主要介绍一种最基本的推演系统，下图3-9 表示系统的基本结构。  
![](images/9e9fac00c2d40b2f3ec288b2f0ea17c474bc9160a1447874b9a37744cd5272d2.jpg)
图3-9 推演系统的基本结构  
上图表示的推演系统中包括事实库、公理库和推理规则这三个基本模块，公理库和事实库构成命题推理的基本依据。公理库包含已被证明为正确的24 个基本等值式和15 个基本永真蕴含式，这些基本关系式构成推演系统的基础知识资源，事实库由具体命题推理实例的所有前提条件以及推理过程中产生的有效中间结论组成；推理规则是命题逻辑推理的核心机制，主要由$P$规则、$T$规则和$C P$规则这三个基本规则组成。  
（1）$P$规则（前提引用规则）：推导过程中可随时引入前提集合中的任意一个前提。  
（2）$T$规则（逻辑结果引用规则）推导的过程中可随时引入公式𝑆，该公式𝑆是由其前的一个或多个公式推导出来的逻辑结果。  
（3）$C P$规则（附加前提规则）如果能从给定的前提集合$\Gamma$与公式$P$推导出𝑆，则能从此前提集合$\Gamma$ 推导出$P\rightarrow S$。  
注意：$C P$规则适用于结论为条件式的有效推理。使用𝐶𝑃规则就是把结论中的前件作为附加前提加入前提集合，共同去推出结论的后件。  
根据上述命题演算推理系统，就可进行有效的命题逻辑推理。通过有效推理，就可证明命题逻辑中所有定理。所谓证明，就是有效推理的具体推演过程，具体定义如下：  
【定义3.29】从前提集合Г 推出结论$\cdot H$的一个演绎或形式证明，就是构造一个命题公式的有限序列：$H_{1},H_{2},H_{3},\ldots,H_{n}$。其中：$H_{i}$或者是Г 中的某个前提，或者是前面的某些${\cdot}H_{j}(j{<}i)$的有效结论，并且${\cal H}_{n}$就是$H$。此时称$H$为该演绎的有效结论。"
RSA算法,算法,"['第二章  整数与算法设计基础', '§ 2.2 同余算术及其应用', '2.2.3 整数加密算法']","{'实体类型': '算法', '定义': '一种非对称加密算法，使用整数模余运算性质生成公钥和私钥', '应用': '特别适合于对通过互联网传送的数据进行加密，通常用于数字签名等场合', '原理': '基于欧拉定理和费马小定理', '安全性': '依赖于大整数素因子分解的困难性'}",,3,"为防止机密信息被泄露或破坏，需采用数据加密技术对其进行保护。数据加密的基本思想是对原始数据加以伪装，使非法接入者无法理解信息的真正含义，基本过程就是对原来为明文信息或数据按某种算法进行处理，使其成为不可读的一段代码，称为密文，使其只能在输入相应密钥之后才能显示出本来内容。数据加密通常分为对称式加密和非对称式加密两大类。本节介绍两种基于整数理论的经典加密算法，一种是名为仿射加密算法的对称加密算法，另一种是名为RSA 的非对称加密算法。  
仿射加密算法又称为凯撒加密算法，是一种简单且广为人知的加密技术。它是一种替换加密技术，基本思想如下：首先使用0 到25 之间的数字表示A 到Z 这26 个字母。然后，对于每个不大于25 的非负整数$\cdot p$，定义其加密函数值$f(p)$为$\{0,1,2,\ \cdots,25\}$中某个数字。加密函数$f(p)$的有多种定义方法，例如可采用如下加密函数：  
$$
f(p)=(p+3)\;{\bmod{\,}}26
$$  
对于上述加密函数，此时用整数$(p+3)\,\mathrm{mod}\,26$代表的字母替代由整数$p$表示的字母实现加密。例如，对“WELCOME TO HEFEI”进行加密，首先用数字代替字母，然后使用加密函数$f(p)=(p+3)\mod 26$ 代替$p$，翻译成字母后，得到获得到的加密信息为：“ZHOFRPH VR KHIHL”具体过程如下：  
表2-3 凯撒密码的加密过程
![](images/168580ee1913d8c32220b048da1875515ce367981f5bce7472f95af1471231b8.jpg)  
解密则需要使用加密函数的$f(p)$反函数 $f^{-1}(p)$  
$$
f^{-1}(p)=(p-3){\bmod{\,}}26
$$  
解密时需将加密信息转换成数字，然后使用$f^{-1}(p)$把$\{0,1,2,\ \cdots,25\}$中整数$\cdot p$恢复成信息原文对应的整数，之后再将数字装换成字母获得原文。  
RSA 算法由三位数学家Rivest、Shamir 和Adleman 于1977 年共同提出，是至今最为广泛使用的非对称加密算法，特别适合于对通过互联网传送的数据进行加密，通常于数字签名等场合。RSA 算法使用整数模余运算性质生成公钥和私钥，并进行加密和解密。RSA 算法原理基于欧拉定理和费马小定理，为此首先介绍这两个定理。  
【定理2.29】（欧拉定理）设$m$ 是任一正整数，$a$ 是任一与$m$ 互素的整数，则有：  
$$
a^{\varphi(m)}\equiv1({\bmod{\ m}})\tag{2-15}
$$  
其中$\varphi(m)$是欧拉函数。  
如果上述猜想能够成立，则提供了一个非常有效的素数判定方法。但是遗憾的是，上述猜想并不成立。事实上，$p$ 为只要是素数，则其必满足上式，但反之不然。法国数学家给出了如下称之为费马小定理更一般结论：  
【定理2.30】（费马小定理）假设$p$ 是一个任意给定的素数，则对于任意整数$a$，有：  
$$
a^{p}\equiv a({\bmod{\ p}})\tag{2-16}
$$  
特别地，当$a$与$p$ 互素时，有：$a^{p-1}\equiv1({\bmod{\ p}})$。  
下面介绍RSA 算法的基本原理和具体计算过程。RSA 算法理论基础是同余算术以及欧拉定理和费马小定理，其安全性依赖于大整数素因子分解的困难性，即已知整数$n$ 是两个大素数$p$ 和$q$ 的乘积，则难以在可接受的时间范围内通过$n$ 的素因子分解方法获得$p$ 和$q$ 的取值。RSA 算法的密钥生成、加密、解密的具体过程如下：  
1） 密钥的生成  
首先生成两个互不相同的大素数$p$ 和$q$，并令$n=p\cdot q$。其中$p$ 和$q$ 是属于解密信息，不可对外公开，整数$n$ 属于加密信息，需要对外公开。  
然后，令$\varphi(n)=(p-1)(q-1)$，并任意选择一个与$\varphi(n)$互素的正整数$e$，满足：  
$2\leq e\leq\varphi(n)$  
其中$\varphi(n)$不可对外公开，$e$ 为加密密钥，需要对外公开。  
由于$p$ 和$q$ 都是素数，故小于$p$ 且与$p$ 互素的非负整数的个数为$(p-1)$个，小于$q$ 且与$q$ 互素的非负整数的个数为$(q-1)$个。注意到$n=p\cdot q$，由计数的乘法原理及素数的性质可知，小于$\cdot n$且与$n$互素的非负整数的个数为$(p-1)$ $(q-1)$个，因此，$\varphi(n)=(p-1)(q-$1)其实就是欧拉函数。  
由于$e$ 的模$\varphi(n)$互素，因此$e$ 的模$\varphi(n)$同余逆$d$存在且唯一。算出$e$ 的模$\varphi(n)$同余逆$d$，使其满足：  
$$
e d\equiv1({\bmod{\ }}\varphi(n))\tag{2-17}
$$  
整数$d$ 属于解密密钥，不可对外公开。  
由此得到RSA 加密算法中作为公钥的加密密钥$e$，作为私钥的解密密钥$d$。  
2） 加密过程  
在RSA 加密算法中，要将明文信息转化成若干组整数序列。为此，首先将每个字母翻译成相应的整数，例如可以使用前述的凯撒加密算法完成这项工作。然后，将这些由明文字母对应的整数合并成若干组，每个组分别形成一个大整数，代表一个字母段。  
RSA 加密过程其实就是每个表示明文字母段的大整数$M$逐个转化为表示密文字母段的大整数$C$，具体转化公式如下：  
$$
C=M^{e}{\pmod{n}}\tag{2-18}
$$  
在转化过程中总是假定$M<n$。如果$M\geq n$，则需要对表示明文的所有整数重新进行分组以确保每个字母段对应的大整数小于$n$。  
3） 解密过程  
由于$d$ 是$e$ 的模$\varphi(n)$逆，即是$e$ 的模$(p-1)(q-1)$逆，故有：  
$$
e d\equiv1(\bmod(p-1)(q-1))\tag{2-19}
$$  
也就是说，$_{e d}$除以$(p-1)(q-1)$的余数为1，故存在整数$k$，使得：  
$$
e d={\begin{array}{l}{(p-1)(q-1)k+1}\end{array}}
$$  
故有：  
$$
C^{d}\equiv(M^{e})^{d}\equiv M^{e d}\equiv M^{(p-1)(q-1)k+1}\,({\mathrm{mod}}\,\,n)
$$  
假定$M$与$p$ 和$q$ 均为互素，则根据费马小定理有：  
$$
M^{p-1}\equiv1(\mathrm{\;mod}\;\left(p\right))\mathcal{X}M^{p-1}\equiv1(\mathrm{\;mod}\;\,q)
$$  
从而有：  
$$
\begin{array}{r}{C^{d}\equiv M^{(p-1)(q-1)k+1}\equiv\!\!M\!\cdot\!(M^{p-1})^{k(q-1)}\!\!\equiv\!\!M\!\cdot\!1\!\equiv\!\!M\,(\mathrm{mod}\,p)}\\ {C^{d}\equiv M^{(p-1)(q-1)k+1}\equiv\!\!M\!\cdot\!(M^{q-1})^{k(p-1)}\!\!\equiv\!\!M\!\cdot\!1\!\equiv\!\!M\,(\mathrm{mod}\,q)}\end{array}
$$  
由于$p$ 与$q$ 互素，则根据中国余数定理，有：  
$$
C^{d}\equiv M\,({\sf m o d}\,\,\,p\cdot q)\mathbb{\bar{X}}C^{d}\equiv M\,({\sf m o d}\,\,\,n)
$$  
由于$M<n$，故必有：$M=C^{d}\;({\mathsf{m o d}}\;\,n)$  
因此，若已知解密密钥$d$，就可使用公式$M=C^{d}\,({\sf m o d}\,n),$对密文$C$ 进行解密。  
在RSA 加密和解密算法中，如果$p,\ q$ 被信息窃取者获得，则可算出$(p-1)(q-1).$。由于$e$ 是公开密钥，且$d$是$e$ 关于关于模$(p-1)(q-1)$的逆，则不难求出$d$，如此RSA 系统便被完全攻破，信息窃取者就会很容易获得加密的信息。  
RSA 算法中的素数都是十进制整数，怎样才能选择好的$p$ 和$q$，这是$R S A$ 加密算法最关键的问题。针对素数$p$ 和$q$ 的选择，1978 年Rivest 等人在关于RSA 公开密钥的论文中，建议对素数$p$ 和$q$ 的选择应当满足：  
1）$p$ 和$q$ 要足够长，在长度上应相差几位，且二者之差与$p$ 和$q$ 位数相近；  
2）$p{-}1$ 和$q{-}1$ 的最大公约数$\operatorname*{gcd}(p -1\,,\,\,\,q-\!\!1)$要尽量小；  
3）$p{-}1$ 和$q{-}1$ 均应至少含有一个大的素数因子。  
并把满足这些条件的素数称为安全素数。  
从实用的观点看，如果加密后的信息能够保证在足够长的时间内不能被破解，则认为这个加密方法是安全的。相对于RSA 加密算法而言，如果整数$n$ 不是足够大，例如只有10 位，那么按照计算机目前的计算能力，几乎可以立刻求出其所有素因子实现对RSA 加密算法的破解。如果计算机的计算能力得到进一步的提高，则或许能够破解200 位的整数$n$。但是，如果使用200 素数$p$ 和200 位素数$q$ 构成400 位整数$n$，则计算机无法破解由此设计的RSA加密算法。因此，就目前以及今后一段时间而言，RSA 加密算法具有较好的安全性。"
T规则,规则,"['第三章  命题演算与推理', '§ 3.5 命题逻辑的演绎推理', '3.5.2 命题公式推演系统']","{'实体类型': '规则', '定义': '推导的过程中可随时引入公式S，该公式S是由其前的一个或多个公式推导出来的逻辑结果'}",,3,"现在我们学习命题的数理逻辑推理。首先给出如下有效推理的概念：  
【定义3.28】设$G_{1},G_{2}\cdots G_{n}$，$H$是一些命题公式，如果它们满足下列性质：对于这些公式的任意一个解释𝐼，$G_{1},G_{2}\cdots G_{n}$在该解释下同时为真的情况下$\cdot_{H}$在该解释下也为真，则称命题公式$G_{1},G_{2}\cdots G_{n}$可有效推出公式$\cdot H$，或称由$G_{1},G_{2}\cdots G_{n}$得到$H$的逻辑推理为有效推理，记为$G_{1},G_{2}\cdots G_{n}\Rightarrow H$，并称$G_{1},G_{2}\cdots G_{n}$为推理前提，$H$为$G_{1},G_{2}\cdots G_{n}$的逻辑结论。  
从上述定义不难看出，有效推理其实就是把永真蕴含关系由两个命题公式之间的关系推广到多个命题公式之间的关系，即由一组命题公式构成的永真蕴含前件与一个永真蕴含后件之间的关系。下面定理表明有效推理的过程其实就是证明逻辑蕴含式的过程。  
【定理3.14】命题公式$H$是命题公式$G_{1},G_{2},\cdots,G_{n}$的逻辑结论，即$G_{1},G_{2},\cdots,G_{n}\Rightarrow H$，当且仅当$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\to H$为永真公式。  
从理论上讲，利用真值表技术完全可以在有限的步骤内完成对任意含有限个命题变量的永真蕴含关系进行判定或者说进行有效的命题逻辑推理。但是，在针对具体问题的命题逻辑推理时，推理的前提条件一般包含很多个命题公式，有时会涉及大量的命题变量，此时真值表方法就出现组合爆炸问题而变的不可行。因此，需要建立一种命题公式推演系统，在少量基本等值关系式和永真蕴含关系式的基础上，通过建立若干推理规则进行演绎推证的方式实现命题逻辑的有效推理。人们提出了很多各具特色的推演系统，对这系统的详细讨论已经超出了本课程的学习范畴，有兴趣的读者可以查阅相关资料。我们主要介绍一种最基本的推演系统，下图3-9 表示系统的基本结构。  
![](images/9e9fac00c2d40b2f3ec288b2f0ea17c474bc9160a1447874b9a37744cd5272d2.jpg)
图3-9 推演系统的基本结构  
上图表示的推演系统中包括事实库、公理库和推理规则这三个基本模块，公理库和事实库构成命题推理的基本依据。公理库包含已被证明为正确的24 个基本等值式和15 个基本永真蕴含式，这些基本关系式构成推演系统的基础知识资源，事实库由具体命题推理实例的所有前提条件以及推理过程中产生的有效中间结论组成；推理规则是命题逻辑推理的核心机制，主要由$P$规则、$T$规则和$C P$规则这三个基本规则组成。  
（1）$P$规则（前提引用规则）：推导过程中可随时引入前提集合中的任意一个前提。  
（2）$T$规则（逻辑结果引用规则）推导的过程中可随时引入公式𝑆，该公式𝑆是由其前的一个或多个公式推导出来的逻辑结果。  
（3）$C P$规则（附加前提规则）如果能从给定的前提集合$\Gamma$与公式$P$推导出𝑆，则能从此前提集合$\Gamma$ 推导出$P\rightarrow S$。  
注意：$C P$规则适用于结论为条件式的有效推理。使用𝐶𝑃规则就是把结论中的前件作为附加前提加入前提集合，共同去推出结论的后件。  
根据上述命题演算推理系统，就可进行有效的命题逻辑推理。通过有效推理，就可证明命题逻辑中所有定理。所谓证明，就是有效推理的具体推演过程，具体定义如下：  
【定义3.29】从前提集合Г 推出结论$\cdot H$的一个演绎或形式证明，就是构造一个命题公式的有限序列：$H_{1},H_{2},H_{3},\ldots,H_{n}$。其中：$H_{i}$或者是Г 中的某个前提，或者是前面的某些${\cdot}H_{j}(j{<}i)$的有效结论，并且${\cal H}_{n}$就是$H$。此时称$H$为该演绎的有效结论。"
k元根树,概念,"['第九章  树的基本理论与算法', '§ 9.2 根树的基本知识', '9.2.1  有向树与根树']","{'实体类型': '概念', '定义': '在根树T中，若每个分支点至多有k个儿子，则称T为k元树或k叉树；若每个分支点都恰有k个儿子，则称T为完全k元树或完全k叉树；若k元树T的兄弟结点之间有序，则称T为k元有序树或k叉有序树；若完全k元树T的兄弟结点之间有序，则称T为有序完全k元树或有序完全k叉树'}",,3,"我们知道无向树是一种由无向图构成的特殊图模型.那么如何定义和处理由有向图构成的有向树模型呢？现在就来讨论这个问题，首先给出如下有向树模型的定义：  
【定义9.4】对于任意一个给定的有向图，如果略去其所有有向边的方向而得到的无向图是一棵树，则该有向图称为一棵有向树。  
![图 9-12 有向树与非有向树  ](images/2fdb86589dcfaa78bb54f5eaf1ee2b9affe960919c61d426d8acd7eff5e51d45.jpg)  
例如，对于图9-12 所示若干有向图，略去其所有边的方向，则由图9-12(a)、（b）得到的无向图都是树，而由图9-12（c）得到的无向图有回路，由图9-12（d）得到的无向图为森林。因此，图9-12（a）、（b）均是有向树，图9-12（c）、（d）均不是有向树。  
从上述定义及例题可以看出，有向树模型的连通性与无环性是由其伴随的无向图模型决定的，或者说是略去边的方向而直接将有向树看成是无向树.这与一般有向图模型的概念和处理方式有很大差异.因此，如果在树模型的框架下讨论有向树中某条或某几条边在方向上的差异，则没有太大意义，甚至有时还会引起概念上的混淆。  
事实上，自然界中的树模型本身就蕴含着一种方向，这种方向体现在由树根、树枝和树叶结点所构成的层次结构当中，由树根、树枝和树叶结点之间在属性上的差异来刻画边的方向性，不过这种边的方向不是个别边的方向而是所有边的整体方向，即从根到叶的方向或从叶到根的方向。对自然界中树模型的上述特征进行抽象，得到如下根树的概念：  
【定义9.5】对于一棵非平凡的有向树，如果恰有一个结点的入度为0，其余所有结点的入度均为1，则称之为根树或外向树.入度为0 的结点称为根结点,简称为根；出度为0 的结点称为叶结点，简称为叶；入度为1，出度大于0 的称为内结点，简称为内点；又将内点和根统称为分支结点，简称为分支点。在根树中，从根到任一结点的通路长度，称为该结点的层数；所有结点的层数最大值称为根树的高。  
通常使用倒置法表示根树，即把根画在最上方，叶画在最下方，有向边的方向均指向下方。例如，图9-13（a）中的有向树就是一棵根树，其中$v_{1}$为根，$v_{5},v_{6},v_{8},v_{9},v_{10},v_{12},v_{13}$为叶，$v_{2},v_{3},v_{4},v_{7},v_{11}$为内点。其中，$v_{1}$处在第0 层，层数为0；$v_{2},v_{3},v_{4}$同处在第一层，层数为1；$v_{5},v_{6},v_{7},v_{8},v_{9}$同处在第二层，层数为2；$v_{10},v_{11},v_{12}$同处在第三层，层数为3；$v_{13}$处在第四层，层数为4；这棵树的高度为4。  
![图9-13 根树的方向与方向省略  ](images/f923bd763ba9a19de150bb3a9be8189594c2d07589f0b79f2493ff5c6c70768a.jpg)  
从根树的定义及上述例题不难发现，根树作为一种特殊的有向树其所有边均是朝着一个方向，即是从根结点到叶结点的方向，如图9-13（a）所示。既然如此就可以对这种特殊的有向图进行化简，即省略根树中所有边的方向将其转化为无向树，如图9-13（b）所示.由此可知，根树其实是一种具有根、枝、叶等层次结构的特殊无向树。  
![图9-14 根树的层次结构  ](images/d86c7aab6ba7ea9d62cfd7298cb652c45b9ae862b8d84a5cb286853843255862.jpg)  
如图9-14 所示，根树是一种由子树不断嵌套而产生的一种层次结构模型，故还可用如下递归的方式定义根树：  
【定义9.6】树是一个$n(n>0)$元有限集，集合中所有数据元素具有如下层次关系：当$n=0$ 时，集合为空集，称之为空树；当$n>0$ 时，集合中有且只有一个特定的结点，称之为树模型的根；当$n>1$ 时，除根以外的其余结点可分为$m(m>0)$个互不相交的有限集$T_{1},T_{2},\cdots,T_{m}$，其中每个集合本身又是一棵树，并称$T_{1},T_{2},\cdots,T_{m}$称为根的子树。  
例如，图9-15 表示一个具体的树模型结构。该树有10 个结点，其中𝐴是根结点，其余结点被分为 3  个互不相交的子集： $T_{1}=\{B,E,F\},T_{2}=\{C,G\},T_{3}=\{D,H,I,J\}$ ； $T_{1}$ ， $T_{2}$ ， $T_{3}$ 都 是 𝐴 的子树，它们本身也分别是一棵树。  
![](images/64aed744b0075ece5ec5a03893d3b845267949822e6760ad07e255b850f44d71.jpg)  
也可用家族关系表示根树中各节点间的关系。  
【定义9.7】在根树中，若从结点$v_{i}$到$v_{j}$可达，则称$v_{i}$是$v_{j}$的祖先，$v_{j}$是$v_{i}$的后代；又若 $\langle v_{i},v_{j}\rangle$是根树中的有向边，则称$v_{i}$是$v_{j}$的父亲，$v_{j}$是$v_{i}$的儿子；如果两个结点是同一个结点的儿子，则称这两个结点是兄弟。  
例如，对于图9-16 所表示的树，结点𝐴 的出度为3，结点$B$的出度为2，结点𝑀的出度为0；结点$A$的孩子为$(B,C,D)$，结点$B$的孩子为$(E,F)$；结点𝐴的层次为1，结点𝑀的层次为4 ； 叶结点有 $(K,L,F,G,M,I,J)$ ， 分枝结点有 $(A,B,C,D,E,H)$ ； 结点 𝐼 的双亲为 $D$ ， 结点 𝐿 的双亲 为$E$；结点$B,C,D$为兄弟，结点$K$，$L$为兄弟；树的高度为4；结点𝐴是结点$F$、$G$的祖先，结点$B$，$C$是结点𝐴的子孙。  
有时还会在根树的同层次的兄弟结点之间规定具体的大小排序，一般是从左到右进行排序，有时也可以用边的次序代替结点的次序。  
在根树的实际应用中，例如对目标的排序与查找等，需要经常对其中间结点的分支数进行度量、设计和分析，为此给出如下关于$\cdot k$元根树或$k$叉根树的概念：  
【定义9.8】 在根树𝑇中，若每个分支点至多有${k}$个儿子，则称𝑇为𝒌元树或𝒌叉树；若每个分支点都恰有${k}$个儿子，则称𝑇为完全$ k$元树或完全$ k$叉树；若$k$元树𝑇的兄弟结点之间有序，则称𝑇为𝒌元有序树或$k$叉有序树；若完全$ k$元树𝑇的兄弟结点之间有序，则称𝑇为有序完全𝒌元树或有序完全$k$叉树。在根树$T$中，任一结点$v$及其所有后代导出的子图$𝑇′$称为$𝑇$的以$v$为根的子树.当然$T^{\prime}$也可以有自己的子树.有序二元树的每个结点$𝑣$至多有两个儿子，分别称为 $𝑣$ 的左儿子和右儿子，至多有两棵子树，分别称为 $𝑣$ 的左子树和右子树。  
注意：以$v$为根的子树包含$𝑣$，而$𝑣$的左右子树则不包含$𝑣$  
【定理9.6】在$k$元完全树中，若叶为𝑡，分支点数为 $i$，则下式成立：  
$(k-1)\times i=t-1~~~~~~~~~~~~~~\quad(9-1)$"
n元有序组,概念,"['第五章 关系模型与理论', '§ 5.1 关系的数学模型', '5.1.1  序偶与笛卡尔积']","{'实体类型': '概念', '定义': '由n个元素组成的有序组，记作⟨a1,a2,...,an⟩'}",,3,"要用数学方式表达关系模型，首先必须建立有一种有效的数学机制将来自相同集合或不同集合的两个元素绑定在一起，以表明它们之间具体某种特定的关系。为此，下面给出二元组的相关概念来实现这种机制。  
【定义5.1】假设𝐴和$B$是任意给定的两个集合，则对于分别来自这两个集合中的元素$x$和𝑦，可将它们组合成一个整体并称之为二元组。如果这个二元组为无序二元组，则称其为无序偶对，简称为无序偶，通常记为$(x,y)$；如果这个二元组为有序二元组，则称其为有序偶对，简称为序偶，通常记为$\langle x,y\rangle$，并称$\cdot x\in A$为第一元素，$y\in B$为第二元素。  
在关系的数学理论中，通常使用序偶的概念绑定具有某种确定联系的两个元素。事实上序偶的用途非常广泛，日常生活和工作中的很多问题或概念都可用序偶表示。例如，平面上点$A$ 的横坐标是$x$，纵坐标是$y$，可用序偶表示为$\langle x,y\rangle$，$x,y\in R$；合肥是安徽的省会、南京是江苏的省会，可分别用序偶表示为〈合肥, 安徽〉，〈南京, 江苏〉；数学书在桌上、英语书在床上，可分别用序偶表示为〈数学书, 桌上〉，〈英语书,床上〉。  
由序偶的定义容易知道，序偶可以看作是具有两个元素的集合，但序偶中的两个元素是具有确定次序的，如果两个含有两个元素的集合相等，并不意味着这两个集合元素构成的序偶相等，因此即使成立$\{a,b\}=\{b,a\}$，在$a\neq b$的情况下会有：成立$\langle a,b\rangle\neq\langle b,a\rangle$。例如，对于前述的序偶〈合肥, 安徽〉，从集合的角度看，显然有{合肥, 安徽}$\}=$ {安徽,合肥}，但是序偶〈合肥, 安徽〉和〈安徽, 合肥〉显然代表的是两个不同的含义：前者表示合肥是安徽的省会，前者表示安徽是合肥的省会。因此，有：〈合肥, 安徽〉 $\neq$〈安徽,合肥〉。  
下面给出两个序偶相等的具体定义：  
【定义5.2】假设$\langle a,b\rangle$和$\langle c,d\rangle$是任意给定的两个序偶，如果$a=b$，$c=d$，那称这两个序偶相等，记为：$\langle a,b\rangle=\langle c,d\rangle$。  
从上述定义可知，两个序偶相等当且仅当这两个序偶在对应位置上的元素相等。例如，若有$\langle2x-3y,3x+2y\rangle=\langle1,3\rangle$，则有$2x-3y=1$且$3x+2y=3$；反之亦然。  
显然，可将上述序偶及其相等的相关定义自然推广到多个元素的情形。例如，对于任意给定的三个元素$x,y,z$，则可根据如下递归方式定义由这三个元素组成的有序三元组：  
$$
\langle x,y,\mathrm{z}\rangle=\langle\langle x,y\rangle,\mathrm{z}\rangle\tag{5-1}
$$  
从上式可以看出，所谓有序三元组，其实就是序偶的序偶。一般地，可得到如下关于$^{\cdot n}$元有序组的相关定义：  
【定义5.3】由$n$个元素$a_{1}$ ,$a_{2},\dotsc,a_{n}$组成 $n$元有序组由$n-1$元有序组$\langle a_{1}\;\,,a_{2},\dots,a_{n-1}\rangle$和元素$a_{n}$组成的序偶，记作$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$。即：$\langle a_{1}\;\;,a_{2},\ldots,a_{n}\rangle=\langle\langle a_{1}\;\;,a_{2},\ldots,a_{n-1}\rangle,a_{n}\rangle$。  
【定义5.4】假设$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$和$\langle b_{1},b_{2},\dots,b_{n}\rangle$是任意给定的两个$ n$元有序组，如果$a_{i}=$$b_{i}$，$i=1,2,\dots,n$，则称它们相等，记为：$\langle a_{1}\,\ ,a_{2},\ldots,a_{n}\rangle=\langle b_{1},b_{2},\ldots,b_{n}\rangle\,.$。  
【定义5.5】设$A,B$是任意给定的两个集合，用$A$中任意一个元素为第一元素、$B$中任任意一个元素为第二元素构成的所有可能的序偶组成的集合，称为$A$ 与$B$ 的笛卡尔积，亦称为$A$ 与$B$ 的直积，记为$A\times B$。即有：$A\times B=\{\langle x,y\rangle|(x\in A)\land(y\in B)\}$。  
由上述定义可知，集合$A$ 与$B$ 的笛卡尔积运算结果$A\times B$仍是一个集合，并且$A\times B$中的每个元素都是一个序偶，序偶中第一个元素取自集合$A$、第二个元素取自集合$B$。  
假设根据笛卡尔积的定义，不难证明笛卡尔积运算满足如下几条基本性质：  
（1）假设$A$,$B$是任意给定的两个集合，则有：$A\times\emptyset=B\times\emptyset=\emptyset$；  
（2）假设 $A$, $B$ 是任意给定的两个集合，则有 $A\times B=\emptyset$ ，当且仅当 $A=\emptyset$ 或 $B=\emptyset$；  
（3）当$A,B$是有限集合时，有：$|A\times B|=|B\times A|=|A||B|$  
下面定理表明笛卡尔积运算对集合的并运算和交运算均满足分配律：  
【定理5.1】设$A$、$B$、$C$ 是任意集合，则有：  
$A\times(B\cup C)=(A\times B)\cup(A\times C);\quad A\times(B\cap C)=(A\times B)\cap(A\times C);$  
$(A\cup B)\times C=(A\times C)\cup(B\times C);\quad(A\cap B)\times C=(A\cup C)\times(B\times C)\,$。  
【定理5.2】设$A$、${B}、{C}$ 是任意集合且$C\neq\emptyset$，则有：
$$
A\subseteq B\Leftrightarrow(A\times C\subseteq B\times C);\,\,\,A\subseteq B\Leftrightarrow(C\times A\subseteq C\times B)
$$  
【定理5.3】设$A、\ B、C、D$为非空集合，则有：
$$
A\subseteq C\land B\subseteq D\Leftrightarrow A\times B\subseteq C\times D
$$  
【定理5.4】假设集合$\cdot A_{1},A_{2},\cdots,A_{n}$均为有限集合，则有：
$$
|A_{1}\times A_{2}\times\cdots\times A_{n}|=|A_{1}|\times|A_{2}|\times\cdots\times|A_{n}|
$$"
n元真值函数,概念,"['第三章  命题演算与推理', '§ 3.3 联结词的完备集', '3.3.1  联结词的枚举']","{'实体类型': '概念', '定义': '含有n个命题变元的命题公式，其自变量和函数值的取值为{真，假}或{0, 1}', '性质': 'n元真值函数的种类数即为n元真值函项的个数'}",,3,"不难看出，每个运算联结词分别对应一个命题公式，且彼此不同的运算联结词所对应的命题公式也互不相同。尽管可以通过命题公式的定义构造出无穷多个形态各异的命题公式，但是这些命题公式中有很多是彼此等值的。因此，如果我们将彼此等值命题公式视为同一种类型并且能够计算出类型的数目，那么命题运算联结词的枚举问题便迎刃而解。  
对于任意一个含有$\cdot_{n}$个命题变量的命题公式，都可以将它看成是一个由这$n$个变量为自变量的𝑛元函数。显然，每个自变量的取值以及函数值的取值均为{真，假}或{0, 1}，故有如下𝑛元真值函数的相关定义：  
【定义3.17】假设𝐺是一个含有$\cdot_{n}$个命题变元的命题公式，则称𝐺是一个$\mathbfit{n}$元真值函数。在所有的$n$元真值函数中，将相互等值的真值函数归为一类，并从每个类中分别选取一个$_{n}$元真值函数作为该的类代表，称这种具有代表性质的真值函数为$\mathbfit{n}$元真值函项。  
显然，$n$元真值函数的种类数就是$n$元真值函项的个数。因此，下面着重考察如何对n 元真值函项进行计数和枚举。  
对于一元真值函数$G(P)$，它只含有一个命题变元𝑃。由于$P$只有$T$和$F$两种取值状态且对于每种状态，$G(P)$都只有$T$和$F$两种不同取值方式，由计数的乘法原理知，$G(P)$有且仅有有4 种不同的表现形式，如表3-13 所示。  
表3-13  一元真值函数
![](images/7e299ca38127d46167de49648c7ba3b93226e9a0d0de2bd6d7016fad80f5bc00.jpg)  
从表3-13 中可以看出，一元真值函数$G(P)$有且仅有4 种不同类型。由此可以得到如下全部四个不同的一元真值函项：  
$$
G_{1}(P)\Leftrightarrow T;\,\,\,G_{2}(P)\Leftrightarrow P;\,\,\,G_{3}(P)\Leftrightarrow\neg P\,;\,\,\,\,\,G_{4}(P)\Leftrightarrow F
$$  
由此可见，非平凡的一元逻辑运算联结词只有$\neg$运算，即 $G_{3}(P)=\neg P$  
下面考察二元真值函数$G(P,Q)$：由于每个命题变量分别取T和F两种状态，故$P$与$Q$的取值状态组合数为4。对于$\cdot P$与$Q$每一种组合状态，$G(P,Q)$都有$T$和$F$这两种取值状态，由计数的乘法原理知，$G(P,Q)$有且仅有有$2^{4}{=}16$ 种不同表现形式，如表3-14 所示。  
![](images/07f980b35eb2afa32c89cb472f39cdcc1aa211c2d1dac882499a493bebe3a0fa.jpg)  
从表3-14 中可以看出，二元真值函数$G(P,Q)$有且仅有16 种不同类型。由此可以得到如下全部16 个不同的二元真值函项：  
$G_{1}(P,Q)\Leftrightarrow P\land\lnot P;\,\,\,G_{2}(P,Q)\Leftrightarrow P\land Q;\,\,\,G_{3}(P,Q)\Leftrightarrow\lnot(P\to Q)\,;\quad G_{4}(P,Q)\Leftrightarrow P\,;$ $G_{5}(P,Q)\Leftrightarrow\neg(Q\to P);\;\;G_{6}(P,Q)\Leftrightarrow Q;\;\;G_{7}(P,Q)\Leftrightarrow\neg(P\leftrightarrow Q);\quad G_{8}(P,Q)\Leftrightarrow P\lor Q;$ $G_{9}(P,Q)\Leftrightarrow\neg(P\vee Q);\;\;G_{10}(P,Q)\Leftrightarrow P\leftrightarrow Q;\;\;G_{11}(P,Q)\Leftrightarrow\neg Q;\quad G_{12}(P,Q)\Leftrightarrow Q\rightarrow P$ $G_{13}(P,Q)\Leftrightarrow\neg P;\;\;G_{14}(P,Q)\Leftrightarrow P\rightarrow Q;\;\;G_{15}(P,Q)\Leftrightarrow\neg(P\wedge Q);\quad\;G_{16}(P,Q)\Leftrightarrow P\vee\neg P$  
由此可见，非平凡二元逻辑运算联结词一共有9 个，除了前面已学的5 个常用联结词$\neg，\wedge，\vee，\rightarrow，\leftrightarrow$之外，还有如下4 个新的运算联结词，即：$\overline{{\mathsf{V}}}\,,\,\nrightarrow\,\uparrow\,,\,\downarrow$。这4 种联结词的真值取值规则如表3-15 和表3-16 所示。  
表3-15  4 种新联结词的含义与表示
![](images/06836354c54edf7769126bc450a894d316d020c9711d3c09afa06457b363815b.jpg)  
表3-16  4 种新联结词的真值
![](images/731846b634a2ef84c0898fbd837a1e716d721d529b86c9bb6916ff3a66582dbc.jpg)  
由表3-15 和表3-16 真可知：  
$P\;{\overline{{\lor}}}\;Q\Leftrightarrow\neg(P\leftrightarrow Q)\colon\;P\nrightarrow Q\Leftrightarrow\neg(P\rightarrow Q)\colon\;P\uparrow Q\Leftrightarrow\neg(P\wedge Q)\colon\;P\downarrow Q\Leftrightarrow\neg(P\vee Q)$  
对于一般$_{n}$元真值函数$G(P_{1},P_{2},\cdots,P_{n})$，其$.n$个命题变量$P_{1},P_{2},\cdots,P_{n}$的取值状态组合数为$2^{n}$。对于每个取值状态的组合，$G(P_{1},P_{2},\cdots,P_{n})$均有$T$和$F$这两种取值。因此，$G(P_{1},P_{2},\cdots,P_{n})$有且仅有$2^{2^{n}}$种不同表现形式，即有且仅有$\cdot2^{2^{n}}$个$_{n}$元真值函项。例如，当$n=3$时，有且仅有$2^{8}{=}256$ 个真值函项，由此可得到所有非平凡三元逻辑运算联结词，具体不再赘述。"
n元谓词,概念,"['第四章  谓词演算与推理', '§ 4.1 个体词、谓词与量词', '4.1.2  命题函数与谓词', '三、谓词与谓词填式']","{'实体类型': '概念', '定义': '表示含有n个个体变量的语句', '特点': '当n=1时，描述个体的性质；当n>1时，描述个体之间的联系'}",,4,"从结构上看，简单命题函数主要通过将原子命题中的个体常量泛化为个体变量的方式实现对命题结构的分解和对命题含义的抽象。在这个分解与抽象过程中，原子命题中表示个体性质与联系的谓语部分则不做任何抽象和改变而直接继承下来成为命题函数的函数名，并称之为谓词。谓词是简单命题函数中具有实质性含义的部分，刻画了命题函数中个体变量的性质与联系，构成了简单命题函数的主体。从本质上看，含有变元的简单命题函数其实就是含有变元的谓词。因此，通常将$_{\cdot n}$元简单命题函数称为$^n$元谓词。具体定义如下：  
【定义4.5】对于$\cdot n$元简单命题函数$P(x_{1},x_{2},\cdots x_{n})$，将其中的函数名$P$ 称为谓词，将$n$元简单命题函数$P(x_{1},x_{2},\cdots x_{n})$称为$n$元谓词。  
单纯的个体词或单纯的谓词都无法完成一个完整的逻辑含义，只有将它们结合起来才能构成完整独立的逻辑断言。因此，除非特别说明，通常情况下我们所说的谓词指的就是含有个体变元的谓词，即$n$元谓词。  
通过以上例题可以看出$n$元谓词主要用来描述个体的性质或者个体之间的联系。当$n=$1时，谓词描述的是个体的性质；当$n>1$时，谓词描述的是个体之间的联系。  
$n$元谓词$P(x_{1},x_{2},\cdots x_{n})$是表示含有$\cdot_{n}$个个体变量的语句。变量对个体指定的不确定性使得语句无法确定具体的真值，因而不是命题。当这些变量$x_{1},x_{2},\cdots x_{n}$均得到具体赋值或通过其它方式受到约束而获得明确具体的含义时，$P(x_{1},x_{2},\cdots x_{n})$就表示一个具体命题。  
例如，令一元谓词$P(x)$表示“$\cdot_{x}$ 是大学生”，则$P($小张)就是一个具体命题：小张是大学生。同样，$P($小李)也表示一个具体命题：小李是大学生。  
给$n$元谓词的个体变量赋值是一种最简单的约束方式，由此得到谓词填式的概念：  
【定义4.6】对于$\cdot n$元谓词$P(x_{1},x_{2},\cdots x_{n})$，若将其中每个个体变量$\cdot x_{1},x_{2},\cdots x_{n}$分别指定具体的个体，由此得到的命题$P(a_{1},a,\cdots a_{n})$，称为谓词填式，也称为命题的谓词式。  
谓词填式具有谓词的形式结构但不再含有个体变量，可以看成是零元谓词，是具体命题的谓词表示形式。例如：$P($小张)就是一个0 元谓词。因此，命题其实就是一种特殊的零元谓词，谓词逻辑是命题逻辑的一种自然推广。"
r-线排列,概念,"['第一章  集合与计数基础', '§ 1.3 有限集的基本计数技术', '1.3.3 排列计数与组合计数', '一、不重复的排列与组合']","{'实体类型': '概念', '定义': '有时亦将r-排列称为r-线排列或线排列'}",,4,"首先考察如下排列问题：  
某班有35 名同学，现从中选出15 名同学排成一排，问有多少种排列方式？  
这个问题有如下两个关键要点：第一、在排列中每位同学最多只能出现一次，也就是无重复性；第二、不同的次序构成不同的排列。由此得到如下不重复排列的概念：  
【定义1.21】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中依次取出$r$ 个不同元素并将其按取出的次序排成一排，由此形成的一个有序排列称之为不重复$r\cdot$-排列，简称为$r\cdot$-排列或排列，不重复$r\cdot$-排列的个数称为不重复$r\cdot$-排列数，简称为$r\cdot$-排列数或排列数，记为${P}_{n}^{r}$或$P(n,r)$。称$r=n$时构成的排列称为全排列，$r<n$时构成的排列为选排列。  
根据乘法原理，显然可以得到如下结论：  
【定理1.13】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r\cdot$-排列数计算公式：  
$P(n,r)=n(n-1)(n-2)\cdots(n-r+1)\ \ ={\frac{n!}{(n-r)!}}$ 其中：$n!=n(n-1)(n-2)\cdots2\cdot1$  
【定义1.22】假设$S$是由$n$ 个不同的元素组成的集合，从$S$ 中依次取出$r$ 个不同元素并将其按取出的次序排成一个圆圈，由此形成的一个有序圆排列称之为不重复$r\cdot$-圆排列，简称为$r\cdot$-圆排列或圆排列，不重复$r\cdot$圆排列的个数称为不重复$r\cdot$-圆排列数，简称为$r\cdot$-圆排列数或圆排列数，记为${\cal P}_{c}(n,r)$。  
相对于上述圆排列的概念，有时亦将$r\cdot$-排列称为$r$-线排列或线排列。由前面分析不难看出，如果将每个$r\cdot$-线排列的首尾相连构成一个$r\cdot$-圆排列，则由此构成的所有圆排列必然有$r$倍的重复数。故有如下$r\cdot$-圆排列计算公式：  
【定理1.14】对于任意给定的两个正整数$n$ 和$r$，且$r\leq n$，其$r\cdot$-圆排列数为$P_{c}(n,r)$：  
$$
P_{c}(n,r)=\frac{P(n,r)}{r}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r}=\frac{n!}{r(n-r)!}
$$  
以上例子的共有特点是所有选出的元素都有一定的次序。事实上，很多情况下并不需要选出的元素具有有次序。  
考察如下组合问题：  
某班有35 名同学，现从中任意选出15 名同学参加问卷活动，问有多少种选择方式？  
与前述$r$-排列问题不同的是，这个问题只考虑抽取的是哪15 名同学，并不考虑抽取次序以及与之相关的排列问题。由此得到如下不重复组合及相关组合数的概念：  
【定义1.23】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中任意取出$r$ 个不同元素组成一个子集合，称每一个这样的子集合为一个不重复$r$-组合，简称为$r\cdot$-组合或组合，不重复$r$-组合的个数称为不重复$r\cdot$-组合数，简称为$r\cdot$-组合数或组合数，记为$C_{n}^{r}$或$C(n,r)$。  
显然， $r$ - 组合与 $r$ - 排列的区别在于 $r\cdot$ 组合不考虑组合中元素的排列次序， $r\cdot$ - 排列必须考 虑排列中各元素的排列次序。如果两个$r\cdot$-排列所含的元素完全相同，仅仅是排列次序不同，两个$r\cdot$-排列是同一个组合，由此得到有如下组合数计算公式：  
【定理1.15】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r-$组合数计算公式：  
$$
C(n,r)=\frac{P(n,r)}{r!}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r!}=\frac{n!}{r!(n-r)!}
$$"
t-条件,定理,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.2.2 完备匹配与最大匹配']","{'实体类型': '定理', '条件': '二分图中X中每个结点至少关联t条边且Y中每个结点至多关联t条边', '应用': '判断二分图是否存在X-完备匹配'}",,3,"首先考察一个有趣的问题：假设在某个小型舞会上有5 名男士和5 名女士，其中某些男士与某些女士之间相互认识，问如何安排才能使得相互认识的男生和女士人成为舞伴。  
可用如图10-30（a）所示的二分图模型$G=\langle X,E,Y\rangle$表示上述舞伴配对问题，其中结点集合$X=\{x_{1},x_{2},x_{3},x_{4},x_{5}\}$和$Y=\{y_{1},y_{2},y_{3},y_{4},y_{5}\}$分别表示5 名男士和5 名女士构成的集合，图中有无向边$(x_{i},y_{j})$当且仅当男士$x_{i}$与女士$y_{j}$相互认识。  
![图10-30  舞伴的安排问题 ](images/e92b7888a1cc6a1b77006b78c8c42919c89a7e806394091bb76e5c5538b07826.jpg)  
通过观察，不难得到如图10-30（b）中实线边所示的一种安排方案。由于每个人最多只能与一个异性匹配成舞伴，故所得到的安排方案其实就是图$G=\langle X,E,Y\rangle$中5 条不相邻边组成的$E$的子集：$M=\{(x_{1},y_{3}),(x_{2},y_{1}),(x_{3},y_{2}),(x_{4},y_{5}),(x_{5},y_{4})\}_{\circ}$。  
不难看出，上述问题其实就是在两类不同性质的对象之间寻找某种配对或者匹配的问题。事实上，日常生活和工作中的很多问题，例如学生选课、工作任务安排等等，都可以归结为这种匹配问题。对上述实例进行抽象，得到如下匹配的相关概念：  
【定义10.4】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，图中互不相邻的边构成$.E$的子集$M$称为$G$的一个匹配，$G$中与$M$中的边关联的结点称为匹配$M$的饱和结点。如果$X$中每个结点都是某个匹配的饱和结点，则称该匹配为$G$的一个$X^{.}$-完备匹配；如果𝑌中每个结点都是某个匹配的饱和结点，则称该匹配为$G$的一个𝑌-完备匹配；如果$G$的某个匹配既是$X-$完备匹配，又是𝑌-完备匹配，则称该匹配为完备匹配。$G$中基数最大的匹配称为𝐺的最大匹配，最大匹配中的边数称为$G$的匹配数，记作$\alpha^{\prime}(G)$。  
由定义10.4 可知，二分图的$X^{-}$完备匹配、$Y-$完备匹配和完备匹配肯定是最大匹配，反之不然，最大匹配不一定是$X-$完备匹配、$Y-$完备匹配或完备匹配。对于任意一个给定的二分图，其最大匹配总是存在，但其$X{-}$完备匹配、$Y-$完备匹配或完备匹配不一定存在。如果一个二分图存在完备匹配，则必有$|X|=|Y|$，反之不然。  
![图10-31  二分图及其最大匹配  ](images/426797d69400c6077f0021e199ce3acdf2169381fe7ee70516dbf26e96f0ac68.jpg)  
例如，对于图10-31（a）所示的二分图，图10-31（b）所示的全部实线边构成的集合：  
$$
M=\{(x_{1},y_{3}),(x_{2},y_{1}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
是该二分图的一个最大匹配。该匹配显然不是$X^{-}$完备匹配、$Y-$完备匹配或完备匹配，因为$x_{4}$和$y_{4}$均是其非饱和点。再如，图10-30（b）中实线边所示的匹配显然是一个完备匹配，自然也是最大匹配。  
下面考察对于一个给定的二分图$G=\langle X,E,Y\rangle$，当$G$满足什么条件时存在完备匹配。这里仅讨论$X^{-}$完备匹配的情形，至于$Y-$完备匹配和完备匹配的情况，可类似讨论。  
首先给出著名的霍尔婚姻定理，该定理给出了二分图$G=\langle X,E,Y\rangle$存在$X^{-}$完备匹配的一个充分必要条件，具体如下：  
【定理10.8】（霍尔婚姻定理）设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，则$G$存在$X^{-}$完备匹配的充分必要条件是$X$中任意$k$个结点至少与𝑌中$k$个结点相邻。具体地说，就是对于$\forall S\subseteq X$，有$|S|\leq|\mathsf{N}(\mathsf{S})|$，其中N(S)表示𝑌中所有与S中结点相邻的结点组成的集合。  
![图10-32  $X$-完备匹配存在性的判定](images/e5661ccfd2ab0df27e3feadf55016324a2bdd2f775f9de7183f592d16a209926.jpg)  
例如，图10-32（a）所示二分图满足霍尔婚姻定理的条件，故存在$X^{-}$完备匹配，图$10-$32（b）所示二分图不满足霍尔婚姻定理的条件，故不存在$X^{-}$完备匹配。  
定理10.8 中需要计算𝑋中所有子集在𝑌中邻接结点的集合，在很多情况下计算量很大，不便使用。为此，下面给出一个名为$t-$条件的充分条件，具体如下：  
【定理10.9】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，如果$G$满足：$X$中每个结点至少关联t-条边且𝑌中每个结点至多关联$t^{-}$条边，则图$G$一定存在$X^{-}$完备匹配。  
判断𝑡条件非常简单，只需计算$X$中结点最小度$\delta(X)$和$\Delta(Y)$中结点最大度$\Delta$即可。例如，对于图10-32（a）所示二分图，显然有$\delta(X)=\Delta(Y)=2=t$，故存在$X{-}$完备匹配。"
∃型前束范式,概念,"['第四章  谓词演算与推理', '§ 4.3 谓词公式的范式', '4.3.2 非等值型范式', '一、∃型前束范式']","{'实体类型': '概念', '定义': '将所有存在量词排在所有全称量词的左边，且公式中至少含有一个存在量词的谓词公式', '特点': '公式的母式不含任何量词和自由变量', '应用': '用于谓词公式的演算和永真性保持'}",,4,"∃型前束范式将所有存在量词排在所有全称量词的左边，具体定义如下：  
【定义4.21】假设$G$ 是任意一个谓词公式，如果$G$ 具有如下形式：
$$
G\Leftrightarrow(\exists x_{1})(\exists x_{2})\cdots(\exists x_{i})(\forall x_{i+1})\cdots(\forall x_{n})M(x_{1},x_{2},\cdots x_{n})\tag{4-13}
$$  
即所有存在量词排在所有全称量词的左边且G中至少含有一个存在量词，则称$G$ 是一个∃型前束公式，其中$M(x_{1},x_{2},\cdots x_{n})$为公式的母式，要求既不含任何量词也无任何自由变量。如果∃型前束公式的模式是一个析取范式或合取范式，则称该∃型前束公式为∃型前束范式。  
例如，谓词公式$\exists z\exists w\forall x\forall y$$(\left(\neg P(x)\land\neg R(x,w)\right)\lor\left(\neg Q(z,y)\land\;\neg\;R(x,w)\right)$就是一个∃型前束析取范式。  
下面的定理给出了∃型前束范式的存在性以及在永真性保持上的性质。  
【定理4.4】假设$G$ 是任意一个谓词公式，则可将$G$ 转化为一个∃型前束范式，并且G是有效公式当且仅当其∃型前束范式也是一个有效公式。  
该定理表明有效谓词公式与其∃型前束范式等值，当一个谓词公式为有效公式时，便可使用其∃型前束范式进行演算。不过相对于前束范式的构造，∃型前束范式的构造稍微复杂一些，对于任意一个给定的谓词公式，其∃型前束范式的构造方法如下：  
第一步 将该谓词公式转化为前束型公式。  
第二步 将前束型公式转化为∃型前束范式。对于任意一个前束型公式$G$，显然只需将其转化为∃型前束公式即可，具体转化方法需要根据以下几种情况讨论：  
（1）当$G$ 中含有自由变量时，则需要将其每个自由变量分别加上相应的全称量词，使得谓词公式不再含有自由变量，即将公式变成一个闭式；  
（2）当$G$ 中不含自由变量且不含存在量词∃时，则需在公式中引入一个新的一元谓词及相应的个体变量$Q(u)$，得到一个新的公式：$\exists u(\iff G\land(Q(u)\lor\lnot Q(u)))$。然后将$G$中量词的辖域扩大到整个公式，即将$G$中所有量词提到$(G\wedge(Q(u)\vee\neg Q(u)))$的前面；  
（3）当$G$ 中不含自由变量且含有存在量词∃时，则需要通过引入新谓词的方法逐步将存在量词∃左边的全称量词$\forall$转化为存在量词$∃$。  
经过上述过程，便可将任意一个谓词公式转化为∃型前束型公式，从而可进一步转化为∃型前束范式。"
一元真值函数,概念,"['第三章  命题演算与推理', '§ 3.3 联结词的完备集', '3.3.1  联结词的枚举']","{'实体类型': '概念', '定义': '只含有一个命题变元的真值函数', '特点': '有且仅有4种不同类型'}",,3,"不难看出，每个运算联结词分别对应一个命题公式，且彼此不同的运算联结词所对应的命题公式也互不相同。尽管可以通过命题公式的定义构造出无穷多个形态各异的命题公式，但是这些命题公式中有很多是彼此等值的。因此，如果我们将彼此等值命题公式视为同一种类型并且能够计算出类型的数目，那么命题运算联结词的枚举问题便迎刃而解。  
对于任意一个含有$\cdot_{n}$个命题变量的命题公式，都可以将它看成是一个由这$n$个变量为自变量的𝑛元函数。显然，每个自变量的取值以及函数值的取值均为{真，假}或{0, 1}，故有如下𝑛元真值函数的相关定义：  
【定义3.17】假设𝐺是一个含有$\cdot_{n}$个命题变元的命题公式，则称𝐺是一个$\mathbfit{n}$元真值函数。在所有的$n$元真值函数中，将相互等值的真值函数归为一类，并从每个类中分别选取一个$_{n}$元真值函数作为该的类代表，称这种具有代表性质的真值函数为$\mathbfit{n}$元真值函项。  
显然，$n$元真值函数的种类数就是$n$元真值函项的个数。因此，下面着重考察如何对n 元真值函项进行计数和枚举。  
对于一元真值函数$G(P)$，它只含有一个命题变元𝑃。由于$P$只有$T$和$F$两种取值状态且对于每种状态，$G(P)$都只有$T$和$F$两种不同取值方式，由计数的乘法原理知，$G(P)$有且仅有有4 种不同的表现形式，如表3-13 所示。  
表3-13  一元真值函数
![](images/7e299ca38127d46167de49648c7ba3b93226e9a0d0de2bd6d7016fad80f5bc00.jpg)  
从表3-13 中可以看出，一元真值函数$G(P)$有且仅有4 种不同类型。由此可以得到如下全部四个不同的一元真值函项：  
$$
G_{1}(P)\Leftrightarrow T;\,\,\,G_{2}(P)\Leftrightarrow P;\,\,\,G_{3}(P)\Leftrightarrow\neg P\,;\,\,\,\,\,G_{4}(P)\Leftrightarrow F
$$  
由此可见，非平凡的一元逻辑运算联结词只有$\neg$运算，即 $G_{3}(P)=\neg P$  
下面考察二元真值函数$G(P,Q)$：由于每个命题变量分别取T和F两种状态，故$P$与$Q$的取值状态组合数为4。对于$\cdot P$与$Q$每一种组合状态，$G(P,Q)$都有$T$和$F$这两种取值状态，由计数的乘法原理知，$G(P,Q)$有且仅有有$2^{4}{=}16$ 种不同表现形式，如表3-14 所示。  
![](images/07f980b35eb2afa32c89cb472f39cdcc1aa211c2d1dac882499a493bebe3a0fa.jpg)  
从表3-14 中可以看出，二元真值函数$G(P,Q)$有且仅有16 种不同类型。由此可以得到如下全部16 个不同的二元真值函项：  
$G_{1}(P,Q)\Leftrightarrow P\land\lnot P;\,\,\,G_{2}(P,Q)\Leftrightarrow P\land Q;\,\,\,G_{3}(P,Q)\Leftrightarrow\lnot(P\to Q)\,;\quad G_{4}(P,Q)\Leftrightarrow P\,;$ $G_{5}(P,Q)\Leftrightarrow\neg(Q\to P);\;\;G_{6}(P,Q)\Leftrightarrow Q;\;\;G_{7}(P,Q)\Leftrightarrow\neg(P\leftrightarrow Q);\quad G_{8}(P,Q)\Leftrightarrow P\lor Q;$ $G_{9}(P,Q)\Leftrightarrow\neg(P\vee Q);\;\;G_{10}(P,Q)\Leftrightarrow P\leftrightarrow Q;\;\;G_{11}(P,Q)\Leftrightarrow\neg Q;\quad G_{12}(P,Q)\Leftrightarrow Q\rightarrow P$ $G_{13}(P,Q)\Leftrightarrow\neg P;\;\;G_{14}(P,Q)\Leftrightarrow P\rightarrow Q;\;\;G_{15}(P,Q)\Leftrightarrow\neg(P\wedge Q);\quad\;G_{16}(P,Q)\Leftrightarrow P\vee\neg P$  
由此可见，非平凡二元逻辑运算联结词一共有9 个，除了前面已学的5 个常用联结词$\neg，\wedge，\vee，\rightarrow，\leftrightarrow$之外，还有如下4 个新的运算联结词，即：$\overline{{\mathsf{V}}}\,,\,\nrightarrow\,\uparrow\,,\,\downarrow$。这4 种联结词的真值取值规则如表3-15 和表3-16 所示。  
表3-15  4 种新联结词的含义与表示
![](images/06836354c54edf7769126bc450a894d316d020c9711d3c09afa06457b363815b.jpg)  
表3-16  4 种新联结词的真值
![](images/731846b634a2ef84c0898fbd837a1e716d721d529b86c9bb6916ff3a66582dbc.jpg)  
由表3-15 和表3-16 真可知：  
$P\;{\overline{{\lor}}}\;Q\Leftrightarrow\neg(P\leftrightarrow Q)\colon\;P\nrightarrow Q\Leftrightarrow\neg(P\rightarrow Q)\colon\;P\uparrow Q\Leftrightarrow\neg(P\wedge Q)\colon\;P\downarrow Q\Leftrightarrow\neg(P\vee Q)$  
对于一般$_{n}$元真值函数$G(P_{1},P_{2},\cdots,P_{n})$，其$.n$个命题变量$P_{1},P_{2},\cdots,P_{n}$的取值状态组合数为$2^{n}$。对于每个取值状态的组合，$G(P_{1},P_{2},\cdots,P_{n})$均有$T$和$F$这两种取值。因此，$G(P_{1},P_{2},\cdots,P_{n})$有且仅有$2^{2^{n}}$种不同表现形式，即有且仅有$\cdot2^{2^{n}}$个$_{n}$元真值函项。例如，当$n=3$时，有且仅有$2^{8}{=}256$ 个真值函项，由此可得到所有非平凡三元逻辑运算联结词，具体不再赘述。"
一元运算,概念,"['第十一章  抽象代数结构通论', '§ 11.1 代数结构的基本概念', '11.1.2 运算的定义与表示']","{'实体类型': '概念', '定义': '从集合$A$到集合$A$的映射$f$', '例子': '整数集合$Z$上求相反数运算、幂集合上的求补运算、实矩阵集合上的求矩阵转置运算、命题集合中的非运算'}",,3,"所以代数结构，本质上就是由一个运算对象的集合和若干运算构成的系统。要学好代数结构，首先必须掌握运算的概念和性质。  
对于运算这个概念，其实我们并不陌生。例如实数的加、减、乘、除等二元运算。这些二元运算通过某种机制由两个运算对象构造出一个确定的新的对象，或者说按照某种既定的规则根据两个输入得到一个唯一确定的输出。因此，二元运算可以看成是一种特殊的二元映射或二元函数，具体定义如下：  
【定义11.1】假设$𝐴,B,C$任意给定的三个非空集合，则从$A\times B$到$C$上的二元映射$f$，称为一个从$A\times B$到$C$的二元运算，即有$f：A\times B\to C$。当$A=B=C$时，称$f：A\times A\to A$为$𝑨$上的二元运算。  
【定义11.2】设$A_{1},A_{2},\cdots,A_{n},A$均为一个非空集合，从集合$A_{1}\times A_{2}\times\cdots\times A_{n}$到集合$A$的映射$f$称为一个从集合$A_{1}\times A_{2}\times\cdots\times A_{n}$到集合𝐴的$\pmb{n}$元运算，即有：$f$：$A_{1}\times A_{2}\times\cdots\times$$A_{n}\to A$。若有$\  A_{1}=A_{2}=\cdots=A_{n}=A$，则称$f$：$A\times A\times\cdots\times A\to A$为集合𝑨上的一个$n$元运算。当$n=1$时，称$f$：$A\rightarrow A$为集合𝑨上的一元运算。  
从上述定义可以看出，多元运算其实就是一类特殊的多元函数。 例如，三元函数：  
$$
*\!:R^{3}\rightarrow R\,,\,\,\,*\left(x,y,z\right)=z\,,\,\,\,\forall x,y,z\in R
$$  
就是一个三元运算，该运算表示三维空间上的点$(x,y,z)$到$z$轴上的投影。  
目前，多元运算在关系数据库的多元关系演算等领域具有重要的应用价值。 不过，多元运算是对二元关系的自然推广，与二元关系没有本质上的差异。  因此，我们主要考察一元运算和二元运算的概念与性质。  例如，整数集合$Z$ 上求相反数运算、幂集合上的求补运算、实矩阵集合上的求矩阵转置运算、命题集合中的非运算等等，都是一元运算。  与二元运算的情形完全相同，可以使用运算符或运算表表示一元运算，这里不再赘述。"
一笔画问题,问题,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.1  图模型的由来']","{'实体类型': '问题', '特点': '遍历图的边而不重复', '条件': '1. 连通图每个结点关联偶数条边，可一笔画完；2. 连通图只有两个结点关联奇数条边，可一笔画成；3. 不满足前两个条件的图需用多笔画成', '结论': '哥尼斯堡七桥问题无解，因为每个结点均关联奇数条边'}",,3,"俄罗斯加里宁格勒州的首府加里宁格勒，原名为哥尼斯堡，是一个具有悠久历史的小镇。有一条名为普雷格尔的小河横穿这个小镇，并且在河中间形成两个小岛。在十八世纪的时候，人们在这条河上建有七座桥，将河中两个岛与河的两岸联结起来，建成一个如图8-1 (a)所示的公园。人们闲暇时常在这个公园里散步，有一天其中有个人突发奇想，提出一个问题：一 个步行者怎样才能不重复、不遗漏地一次走完七座桥，最后回到出发点。问题提出后，很多人对此很感兴趣，纷纷进行试验，但始终未能解决。  
![图8-1 哥尼斯堡七桥问题 ](images/ec575bdd4dc2973aa10919a05915ce2521c1b0a0f2f8089a7104e2a805855033.jpg)  
1735 年，有几名大学生写信给当时正在俄罗斯的彼得斯堡科学院任职的瑞士天才数学家欧拉，请他帮忙解决这一问题。欧拉在亲自观察了哥尼斯堡七桥，在经过为期一年的研究之后，29 岁的欧拉在1736 年提交了名为《哥尼斯堡七桥》的论文，圆满解决了这一问题。在论文中，欧拉将两个小岛和两岸构成的四块陆地分别抽象成结点，然后将连接这四块陆地的七座小桥分别抽象成连接这四个结点的边，如图8-1 (b)所示。这样遍历哥尼斯堡七桥问题就转化为遍历图8-1 (b)的七条边的问题或者说是对图8-1 (b)的一笔画问题。  
我们知道，对于任意一个结点，如果它是出发结点，那么它必然要关联一条边使得散步者能够回到这个结点，如果这个结点不是出发点，那么这个结点必须要关联偶数条边以保证散步者能够进出这个结点，因为每条边只能通过一次，进出一次这个结点需要关联两条不同的边。根据以上思路，不难得到如下三条关于一笔画结论：  
1.如果一个连通图的每个结点都关联偶数条边，那么可以任一结点为起点，用一笔画完此图并该结点为终点；  
2.如果一个连通图只有两个结点关联奇数条边，其余结点均关联偶数条边，那么该图一定可以用一笔画成，此时，关联奇数条边的两个结点分别为起点和终点；  
3.不满足前两个条件的图都不能用一笔画出，此时将关联奇数条边的结点数除以二便可得到该图需用几笔才能画成。  
现在考察哥尼斯堡七桥问题，图中每个结点均关联奇数条边，因而无解。  
欧拉解决哥尼斯堡七桥问题的思路非常巧妙，是一种全新的建模方式。在完美解决哥尼斯堡七桥问题之后，欧拉对这种模型的性质以及相关的建模方式做了深入系统的研究并由此创立了一套新的数学理论——图论。因此，欧拉被誉为图论之父。  
除欧拉之外，还有很多数学家对图论的研究做出重要成果，例如霍尔基夫基于图论的电路网络分析、麦比乌斯的四色猜想问题及解法、哈密尔顿的结点遍历问题及解法，等等。直至1936 年，匈牙利的数学家哥尼格出版了第一本图论专著《有限图与无限图的理论》，标志着图论从此成为一门相对独立完备的数学分支。"
上取整函数,概念,"['第七章 函数与特殊函数', '§ 7.1 函数的基本概念', '7.1.3 常用特殊函数']","{'实体类型': '概念', '定义': '对实数 x，f(x)取不小于 x的最小整数，则称f(x)为上取整函数，记为f(x)=\\left\\lceil x\\right\\rceil'}",,3,"数学中常用的特殊函数有很多，在初等数学和高等数学中都有大量的分析讨论，例如三角函数、指数函数等基本初等函数，不再一一赘述。在此，我们主要介绍在计算机科学应用中经常使用的一些函数，例如恒等函数、常函数、取整函数、布尔函数、自然映射函数等。下面给出这些常用特殊函数的定义。  
【定义7.6】设$𝐴$和$B$是任意给定的两个非空集合：  
（1）设$f\colon A\to B$，若有$c\in B$，对$\forall x\in A$都有$f(x)=c$，则称$f\colon A\to B$是常函数。  
（2）$𝐴$上的恒等函数就是$𝐴$的恒等关系$I_{A}$，对$\forall x\in A$，有$I_{A}(x)=x$。  
（3）对实数 $x$ ， $f(x)$ 取不小于 $ x$ 的最小整数，则称 $f(x)$ 为上取整函数， 记为 $f(x)=\left\lceil x\right\rceil$  
（4）对实数$x$，$f(x)$取不大于$ x$的最大整数，则称$f(x)$为下取整函数，记为$f(x)=\lfloor x\rfloor$  
（5）如果$f(x)$是从集合$𝐴$到$B=\{0,1\}$上的函数，则称$f(x)$为布尔函数。  
（6）设$R$是$𝐴$上的等价关系，$A/R$是$𝐴$在关系$R$上的商集，令$g\colon A\to A/R$，$g(x)=[x]_{R}$则称$g$是从$A$到$A/R$的自然映射。"
上近似集合,概念,"['第六章 特殊关系模型', '§ 6.3 偏序关系与元素比较', '6.4.1 粗集定义问题']","{'实体类型': '概念', '定义': '包含所有可能与粗集相交的等价类的集合'}",,3,"现实世界中很多对象群体的边界是很模糊或者不确定的，例如，对于“中年人”这样的群体，怎样用集合或者其它数学工具进行描述？如果将“中年人”这个群体看出是一个集合$𝑆$的话，则$𝑆$就不是经典意义下的集合，因为其成员不确定。事实上，可以使用两个经典集合来刻画$𝑆$，一个叫做$𝑆$的上近似集合${S}\uparrow$，一个叫做$𝑆$的下近似集合$ S\downarrow$，让前者$𝑆↑$尽可能的小，后者$𝑆↑$尽可能的大。当$𝑆↑$能够等同于$𝑆↓$时,$S$就是经典集合，当$𝑆↑$不能够等同于$𝑆↓$时，则称$𝑆$是粗糙集或粗集。例如，可以用$S\uparrow=\{x|25\le x\le60\}$，即用25 岁至60 岁的人的集合，表示“中年人的集合”；还可以用$S\downarrow=\{x|30\le x\le50\}$，即用30 岁至50 岁的人的集合，表示“中年人的集合”。由于无法构造适当的“中年人的集合”的上下近似$S\uparrow=S\downarrow$，因此，“中年人的集合”$𝑆$是一个粗糙集。  
那么如何用准确的数学语言来定义粗糙集呢？下面通过等价关系给出粗集准确的数学定义。设$U$是个体域（或全集），$R$是$U$上的等价关系，则可由$R$导出的$U$的一个划分，如图$6-$$24\left(a\right)$所示，每个方格表示划分的一个单元，也就是一个$ R$等价类。  
如图$6–24\left(b\right)$所示，若$𝑆$是粗糙集，则$𝑆$的上下近似分别是两个粗线条勾画出的多边形，其中$S\uparrow$由与$𝑆$交不空方格的并组成，$S\downarrow$由包含于$𝑆$的方格并组成。  
![](images/05225fe2f04f5f432dc9b2bbf25b62263d90d0d724be9df376f08ea318717259.jpg)  
通过以上分析，就可以给出粗糙集𝑆的定义：  
【定义6.18】设$U$是个体域(或全集)，$R$是$U$上的等价关系，已知$𝑆$的成员均在$U$中。令： ${\begin{array}{l l}{S\uparrow=\cup\,\{[x]_{R}|[x]_{R}\cap S\neq\emptyset\}}&{;\;\;S\downarrow=\cup\,\{[x]_{R}|[x]_{R}\subseteq S\}}\end{array}}\quad\text{(6-4)}$  
那么称$S\uparrow$为$𝑆$的上近似，$S\downarrow$为$𝑆$的下近似。当$\textit{S}\uparrow=\textit{S}$↓时，$S$即是$U$的子集；当$S\uparrow\ne\textit{S}\downarrow$时，称 $𝑆$ 是 $U$ 的粗糙子集，简称为粗糙集或粗集。  
例如，表是考生情况调查表，其中$U$为被调查对象，$R$为高考成绩$(A-$优，$B-$良，$C-$中，$D-$差)；$X$为升学情况($+$为上，$/$为未上)。可根据高考成绩和升学状况进行分类，并可分别计算出下近似集、上近似集。  
表6-3 对集合𝑈的两种划分
![](images/23b7c96f86908a1723f3af9fc2fde337caca13329476de93665a25a8e36ee553.jpg)  
![](images/1cdfc65fbfddc11bcd85c455f6521676d2bf7ff363efa7f28d82ea21a3e04ed5.jpg)  
事实上，可分别按成绩和升学对$U$进行划分：  
$U/R=\{\{1,6\},\{2\},\{3,5\},\{4\}\}=\{Y_{1},Y_{2},Y_{3},Y_{4}\};\quad U/X=\{\{2,3,5,6\},\{1,4\}\}=\{X_{1},X_{2}\}$ 分别得到粗糙集$S$的上近似和下近似集合：  
$$
S(X_{1})\uparrow=Y_{1}\cup Y_{2}\cup Y_{3}=\{1,2,3,5,6\}\;\;;\;\;\;S(X_{2})\uparrow=Y_{1}\cup Y_{4}=\{1,4,6\};
$$  
$$
S(X_{1})\downarrow=Y_{2}\cup Y_{3}=\{2,3,5\}\;\;;\;\;\;S(X_{2})\downarrow=\;\;Y_{4}=\{4\}。
$$  
粗糙集可以表示含义模糊且不太确定的概念，大大拓广了经典集合的概念和应用范围，更为重要的是，粗糙集可由经典集合借助等价关系进行定义，具有坚实的理论基础。目前，粗糙集理论在模式识别、数据挖掘等技术领域得到广泛应用。"
下取整函数,概念,"['第七章 函数与特殊函数', '§ 7.1 函数的基本概念', '7.1.3 常用特殊函数']","{'实体类型': '概念', '定义': '对实数x，f(x)取不大于x的最大整数，则称f(x)为下取整函数，记为f(x)=\\lfloor x\\rfloor'}",,3,"数学中常用的特殊函数有很多，在初等数学和高等数学中都有大量的分析讨论，例如三角函数、指数函数等基本初等函数，不再一一赘述。在此，我们主要介绍在计算机科学应用中经常使用的一些函数，例如恒等函数、常函数、取整函数、布尔函数、自然映射函数等。下面给出这些常用特殊函数的定义。  
【定义7.6】设$𝐴$和$B$是任意给定的两个非空集合：  
（1）设$f\colon A\to B$，若有$c\in B$，对$\forall x\in A$都有$f(x)=c$，则称$f\colon A\to B$是常函数。  
（2）$𝐴$上的恒等函数就是$𝐴$的恒等关系$I_{A}$，对$\forall x\in A$，有$I_{A}(x)=x$。  
（3）对实数 $x$ ， $f(x)$ 取不小于 $ x$ 的最小整数，则称 $f(x)$ 为上取整函数， 记为 $f(x)=\left\lceil x\right\rceil$  
（4）对实数$x$，$f(x)$取不大于$ x$的最大整数，则称$f(x)$为下取整函数，记为$f(x)=\lfloor x\rfloor$  
（5）如果$f(x)$是从集合$𝐴$到$B=\{0,1\}$上的函数，则称$f(x)$为布尔函数。  
（6）设$R$是$𝐴$上的等价关系，$A/R$是$𝐴$在关系$R$上的商集，令$g\colon A\to A/R$，$g(x)=[x]_{R}$则称$g$是从$A$到$A/R$的自然映射。"
下近似集合,概念,"['第六章 特殊关系模型', '§ 6.3 偏序关系与元素比较', '6.4.1 粗集定义问题']","{'实体类型': '概念', '定义': '包含所有完全属于粗集的等价类的集合'}",,3,"现实世界中很多对象群体的边界是很模糊或者不确定的，例如，对于“中年人”这样的群体，怎样用集合或者其它数学工具进行描述？如果将“中年人”这个群体看出是一个集合$𝑆$的话，则$𝑆$就不是经典意义下的集合，因为其成员不确定。事实上，可以使用两个经典集合来刻画$𝑆$，一个叫做$𝑆$的上近似集合${S}\uparrow$，一个叫做$𝑆$的下近似集合$ S\downarrow$，让前者$𝑆↑$尽可能的小，后者$𝑆↑$尽可能的大。当$𝑆↑$能够等同于$𝑆↓$时,$S$就是经典集合，当$𝑆↑$不能够等同于$𝑆↓$时，则称$𝑆$是粗糙集或粗集。例如，可以用$S\uparrow=\{x|25\le x\le60\}$，即用25 岁至60 岁的人的集合，表示“中年人的集合”；还可以用$S\downarrow=\{x|30\le x\le50\}$，即用30 岁至50 岁的人的集合，表示“中年人的集合”。由于无法构造适当的“中年人的集合”的上下近似$S\uparrow=S\downarrow$，因此，“中年人的集合”$𝑆$是一个粗糙集。  
那么如何用准确的数学语言来定义粗糙集呢？下面通过等价关系给出粗集准确的数学定义。设$U$是个体域（或全集），$R$是$U$上的等价关系，则可由$R$导出的$U$的一个划分，如图$6-$$24\left(a\right)$所示，每个方格表示划分的一个单元，也就是一个$ R$等价类。  
如图$6–24\left(b\right)$所示，若$𝑆$是粗糙集，则$𝑆$的上下近似分别是两个粗线条勾画出的多边形，其中$S\uparrow$由与$𝑆$交不空方格的并组成，$S\downarrow$由包含于$𝑆$的方格并组成。  
![](images/05225fe2f04f5f432dc9b2bbf25b62263d90d0d724be9df376f08ea318717259.jpg)  
通过以上分析，就可以给出粗糙集𝑆的定义：  
【定义6.18】设$U$是个体域(或全集)，$R$是$U$上的等价关系，已知$𝑆$的成员均在$U$中。令： ${\begin{array}{l l}{S\uparrow=\cup\,\{[x]_{R}|[x]_{R}\cap S\neq\emptyset\}}&{;\;\;S\downarrow=\cup\,\{[x]_{R}|[x]_{R}\subseteq S\}}\end{array}}\quad\text{(6-4)}$  
那么称$S\uparrow$为$𝑆$的上近似，$S\downarrow$为$𝑆$的下近似。当$\textit{S}\uparrow=\textit{S}$↓时，$S$即是$U$的子集；当$S\uparrow\ne\textit{S}\downarrow$时，称 $𝑆$ 是 $U$ 的粗糙子集，简称为粗糙集或粗集。  
例如，表是考生情况调查表，其中$U$为被调查对象，$R$为高考成绩$(A-$优，$B-$良，$C-$中，$D-$差)；$X$为升学情况($+$为上，$/$为未上)。可根据高考成绩和升学状况进行分类，并可分别计算出下近似集、上近似集。  
表6-3 对集合𝑈的两种划分
![](images/23b7c96f86908a1723f3af9fc2fde337caca13329476de93665a25a8e36ee553.jpg)  
![](images/1cdfc65fbfddc11bcd85c455f6521676d2bf7ff363efa7f28d82ea21a3e04ed5.jpg)  
事实上，可分别按成绩和升学对$U$进行划分：  
$U/R=\{\{1,6\},\{2\},\{3,5\},\{4\}\}=\{Y_{1},Y_{2},Y_{3},Y_{4}\};\quad U/X=\{\{2,3,5,6\},\{1,4\}\}=\{X_{1},X_{2}\}$ 分别得到粗糙集$S$的上近似和下近似集合：  
$$
S(X_{1})\uparrow=Y_{1}\cup Y_{2}\cup Y_{3}=\{1,2,3,5,6\}\;\;;\;\;\;S(X_{2})\uparrow=Y_{1}\cup Y_{4}=\{1,4,6\};
$$  
$$
S(X_{1})\downarrow=Y_{2}\cup Y_{3}=\{2,3,5\}\;\;;\;\;\;S(X_{2})\downarrow=\;\;Y_{4}=\{4\}。
$$  
粗糙集可以表示含义模糊且不太确定的概念，大大拓广了经典集合的概念和应用范围，更为重要的是，粗糙集可由经典集合借助等价关系进行定义，具有坚实的理论基础。目前，粗糙集理论在模式识别、数据挖掘等技术领域得到广泛应用。"
不交的图,性质,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.2.1 图的基本运算', '一、图的集合运算']","{'实体类型': '性质', '定义': '如果两个图模型的顶点集合交集为空，则称它们是不交的'}",,4,"图模型作为一种特殊的集合具有并、交、差、补、环和等集合运算，下面分别介绍这些集合运算及其相关性质。 首先给出两个图不交、不重的定义：  
【定义8.10】假设 $G_{1}=\langle V_{1},E_{1}\rangle$和 $G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，则有：  
（1）如果 $V_{1}\cap V_{2}=\varnothing$，则称 $G_{1}$ 与 $G_{2}$ 是不交的；  
（2）如果 $E_{1}\cap E_{2}=\varnothing$ ，则称 $G_{1}$ 与 $G_{2}$ 是边不交的，或者说是不重的。  
显然，对于任意两个不交的图它们必然是不重的，反之不然。  
下面给出图模型基本集合运算的定义：  
【定义 8.11 】假设   $G_{1}=\langle V_{1},E_{1}\rangle$ 和   $G_{2}=\langle V_{2},E_{2}\rangle$ 分别为不含孤立结点的图模型（它们 同为无向图或者同为有向图）。  
（1）令图 $G_{1}\cup G_{2}=\left\langle V,E\right\rangle$，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的并图，其中：$V=V_{1}\cup V_{2},\;\;E=E_{1}\cup E_{2}$  
当 $G_{1}$ 与 $G_{2}$ 不存在公共的边时，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$  的不重并。  
（2）设图 $G_{1}\cap G_{2}=\langle V,E\rangle$，称 $G_{1}\cap G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的交图，其中：$V=V_{1}\cap V_{2},\,\,\,E=E_{1}\cap E_{2}$  
$G_{1}\cap G_{2}$是由 $G_{1},G_{2}$ 中所有公共的边组成的图。  
（3）设图 $G_{1}-G_{2}=\langle V,E\rangle$，称 $G_{1}-G_{2}$ 为 $G_{1}$ 减 $G_{2}$ 的差图，其中：
$$
V=V_{1},\,\,\,E=E_{1}-E_{2}
$$  
$G_{1}-G_{2}$ 是在图 $G_{1}$ 中减去属于 $G_{2}$ 的边后所剩余的部分组成的图。  
（4）环和图 $G_{1}\oplus G_{2}$ 是由 $G_{1}$ 与 $G_{2}$ 的并图减去 $G_{1}$ 与 $G_{2}$ 的交图后得到的图。
$$
G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})
$$  
从上述定义可以看出，图模型的并、交、差、环和等集合运算其实就是普通集合运算的延伸。 需要注意的是：  
（1）若   $G_{1}=G_{2}$   ，则 $G_{1}\cup G_{2}=G_{1}\cap G_{2}=G_{1}(G_{2}),~~~~~G_{1}-G_{2}=G_{2}-G_{1}=\varnothing\,。$  
（2）$G_{1}$ 与 $G_{2}$ 不重时，$G_{1}\cap G_{2}=\varnothing$，$G_{1}-G_{2}=G_{1}$，  $G_2-G_1=G_2, G_1\oplus G_2=G_1\cup $$G_{2}$。  
（3）两个图的环和可用并、差、交给出，$G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})\,.$"
不可平面图,概念,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.3.1  平面图的概念与性质']","{'实体类型': '概念', '定义': '不能画在同一个平面上，存在边在非结点处交叉的图'}",,3,"所谓平面图，直观地说就是可以将该图嵌入到某个平面上。如图10-46（a）所示，图模型的边有时不仅在结点处相交，而且还在某些非结点处有交叉，这些非结点处交叉点的边重叠特征显然会导致图模型不能嵌入在同一个平面上。因此，为了将图模型嵌入平面，首先必须适当调整该图中边的走向，以保证任意两条边不会在非结点处有交叉，如图10-46（b）所示。由此得到可平面图和平面图的相关概念。  
【定义10.6】设$G=\langle V,E\rangle$是任意给定的一个图模型，如果该图中有两条边在非结点处有交叉，则称这两条边为该图的交叉边，交叉的具体位置称为交叉点。如果可将图𝐺画在同一个平面上，并且所有边除在结点处之外均不交叉，则称图𝐺可嵌入平面，或称𝐺为可平面图，否则称该图为不可平面图或非平面图。对于可平面图𝐺，将其边不交叉的画法称为𝐺的平面嵌入表示。以平面嵌入方式表示的图可平面图𝐺称为平面图。对于一个平面图𝐺，若对其再加一条边就变成不可平面图，则称𝐺为最大平面图。  
![](images/ad5984e0ab09600028eb4068193d74e75743de0f027a20b4d084511a312873d4.jpg)  
![（a）完全二分图$K_{3,3}$  （b）无法消除交叉  ](images/aa69f9dcec49f0e95a534b493200688a98dae4f4be8a347fbd35c04b8c21413b.jpg)  
例如，对于图10-46（a）所示的图，该图有三对交叉边，即$(v_{1},v_{4})$和$(v_{2},v_{3}),~(v_{1},v_{4})$和$(v_{2},v_{5})$、$(v_{1},v_{5})$和$(v_{2},v_{3})$。由于可将该图表示成图10-46（b）的形式，故该图是一个可平面图。图10-46（b）所示的图就是一个平面图。显然，如果在该平面图上增加一条边，则该图就变成一个不可平面图，故该是一个最大平面图。再如，对于图10-47（a）所示的图模型，无论怎么调整边的走向都不能将其以平面嵌入方式表示，如图10-47（b）所示。故图10-47（a）所示的图模型为不可平面图或非平面图。  
在没有特别要求的情况下，通常将可平面图与平面图不加区分地统称为平面图。与一般图模型显著不同的是，平面图模型除了具有结点和边这两个基本构件之外，还有一般图模型所没有的面的概念，并且由进一步面衍生出边界的概念。因此，平面图是一类非常重要的特殊图模型，无论在理论上还是在应用方面都具有非常重要的价值，在印刷电路板的设计、城市管网设计与规划等多个领域得到实际应用。  
图论之父欧拉对平面图有着比较深刻的研究，发现并论证了平面图的结点、边和面之间的数量关系，提出了著名的欧拉公式。下面给出平面图中面的相关概念：  
【定义10.7】设$G=\langle V,E\rangle$是任意给定的一个平面图，由𝐺中边所包围且内部不包含结点与边的区域，称为$G$的一个面。区域面积有限的面称为有限面，区域面积无限的面称为无限面。对于$G$的任意一个面$R$，包围面$R$的所有边构成的回路称为面𝑅的边界，面𝑅边界中边的个数称为面$R$的次数或度，记为${\bf d e g}(R)$。  
通俗地说，如果把一个平面图画在平面上，然后用小刀沿着图的边将平面切开，那么整个平面就被切成若干块，其中每一块就是图的一个面。或者说，平面图的一个面就是平面中一个以边为界线不能再分割的区域块。例如，对于图10-46（b）所示的平面图，一共有六个面，其中有一个面是无限面，其余五个是有限面。需要注意的是，对于任何一个平面图，该图有且仅有一个无限面。下面的定理10.11 给出了平面图中面数与边数的数量关系：  
【定理10.11】平面图中所有面的次数之和等于边数的两倍。  
下面定理10.12 是著名的欧拉公式，给出了平面图中结点、边和面之间的数量关系：  
【定理10.12】设$G=\langle V,E\rangle$是任意给定的一个连通平面图，若它有$n$个结点、$m$条边、$r$ 个面，则有  
$$
n-m+r=2\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
【定理10.13】如果平面连通图$G$每个面的次数均为$l(l\geq3)$，则有：  
$$
m=l(n-2)/(l-2)
$$  
其中$m$为$G$的边数，$n$为$G$的结点数。  
【定理10.14】设$G$是一个$(n,m)$简单连通平面图，若$m>1$，则有：  
$$
m\leq3n-6\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
由定理10.4 的逆命题不成立，也就是说满足不等式$m\leq3n-6$的简单连通图不一定是平面图。但是对于一个简单连通图，若不满足$m\leq3n-6$，则一定是非平面图。因此，可用定理10.4 的结论证明某个简单连通图不是非平面图。  
【定理10.15】设$G$为一平面连通简单图，其结点数$n\geq4$，边数为$m$，且$G$不以$K_{3}$为其子图，则有$m\leq2n-4$。  
【定义10.8】对于是任意给定的一个图模型$G=\langle V,E\rangle$  
设$e=(u,v)$是$G$的任意一条边，如果在图$G$中删除该边并新增一个结点$w$及两条边$e_{1}=$$(u,w)$、$e_{2}=(w,v)$ ，则称该操作为对图$G$的边切割操作；  
设𝑤是$G$中任意一个度数为2 的结点，且是边${e_{1}=(u,w)}$和$e_{2}=(w,v)$的公共结点，如果在图$G$中删除结点$w$及边$e_{1},\,e_{2}$，并增加边$e=(u,v)$，则称该操作为对图$G$的结点贯通操作；  
对图$G$的边切割操作和结点贯通操作统称为对图$G$的同胚操作。  
显然，边切割操作和结点贯通操作是一对互逆操作。例如，对于图10-48 所示的两个图模型，可通过对边的切割操作将$G_{1}$变成$G_{2}$，也可通过对结点做贯通操作将$G_{2}$变成$G_{1}$。  
![图10-48  图的同胚操作与同胚关系  ](images/17b45e1706460a818a5492fb4df19f0ddd6b072e9cf57afef7db0852f0c58237.jpg)  
下面在同胚操作的基础上，引入如下两个图之间的同胚关系：  
【定义10.9】设$G_{1}=\langle V_{1},E_{1}\rangle$和$G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，如果可用同胚操作将其中一个转化为另外一个，则称$G_{1}$与$G_{2}$具有同胚关系，简称为$G_{1}$与$G_{2}$同胚。  
根据上述同胚的概念，可以得到如下关于平面图判定的库拉托夫斯基定理：  
【定理10.16】（库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是$G$的任何子图都不同胚于$K_{5}$或$K_{3,3}$。  
【定理10.17】(库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是𝐺的任何子图都不能通过边的收缩得到$K_{5}$或$K_{3,3}$。  
![图10-51 彼得森图收缩为$ K_{5}$](images/b6cd48c8bf37519af48b0cc187afdf1adc13d2c5e160a08fe418ce5c94762fd6.jpg)  
库拉托夫斯基定理是一个非常著名定理，通常将$K_{5}$和$K_{3,3}$称为库拉托夫斯基图。可以使用该定理判定一个图是否为平面图。例如，对于图$10{-}51\mathrm{a}$）所示的彼得森图，收缩其边$(v_{i},u_{i})(i=1,2,3,4,5)$，则可得到图$K_{5}$，见图10-51b)。故彼得森图不是平面图。  
值得注意的是，虽然库拉托夫斯基定理给出了平面图判定的充分必要条件，但是目前还没有基于该定理得到一个有效的判定算法。因此，对于一个比较复杂的图模型，要判定其是否为平面图，有时并不是一件容易的事情。"
不可数集,概念,"['1.2.2 自然数的集合定义', '§ 1.2 可数集与不可数集', '二、自然数的归纳定义', '第一章  集合与计数基础']","{'实体类型': '概念', '定义': '基数为无穷大且不能与自然数集基数相同的集合，且不能用自然数集的子集来一一对应的集合', '特点': '无法通过自然数集进行一一对应', 'name': '不可数集'}",,2,我们知道，基数是度量集合规模大小的指标，当集合基数为有限数时，该集合为有限集，其基数就是集合中元素的个数。当集合基数为无穷大时，该集合为无限集。对于无限集，如何使用基数度量其大小规模？例如，对于自然数集与有理数集，如何比较这两个无限集的基数，对于有理数集和无理数集，又如何比较两者的基数，等等。无穷大到底有多大？是否可以对无穷大的规模进行差异性分析，将其划分为不同层次或等级？本节将通过探讨与此相关的概念和问题，使得读者能够对无限集有着比较清晰的认识和本质性把握。
不可数集合,概念,"['第一章  集合与计数基础', '§ 1.2 可数集与不可数集', '1.2.3 无限集的基数比较']","{'实体类型': '概念', '定义': '开区间(0, 1)称为不可数集合，其基数记为ℵ，读作阿列夫；凡是与开区间(0, 1)等势的集合都称为不可数集合', '特点': '不可数集合是比可数集合规模更大的一种无限集合类型'}",,3,"从前面的讨论不难看出，对于任意一个给定的自然数$n$，该自然数其实就是对所有含有$n$ 个元素集合的一种抽象。例如，自然数3 就是对所有含有3 个元素集合的抽象，或者说自然数3 就是将所有含有3 个元素的集合房子一起组成集族。因此，自然数可以根据集合中所含元素个数为标准对所有有限集进行分类，从而实现对有限集基数的度量和比较。  
对无限集基数的度量和比较则没有这么简单。如前所述，任意一个无限集合，都可以找到它的一个子集与自然数集等势。因此，自然数集应当是规模最小的一种无限集合，可用自然数集作为无限集基数的最小度量单位或者度量基准。据此得到如下定义：  
【定义1.19】凡是与自然数集$N$ 等势的集合都称为可数集合，该类集合的基数记为$\aleph_{0}$，读作阿列夫零。  
根据上述例题，可以得到关于有限集合和可数集合的如下基本性质：  
（1）两个有限集合等势，当且仅当它们具有相同的元素个数；（2）有限集合不可能与其任何真子集合等势； （3）可数集合可以与其可数的真子集等势。  
由此可知，元素个数不相等的无限集之间仍有可能存在等势关系。因此，无限集合的基数已经不能通过集合中元素的个数来度量，或者说不能用一个自然数来度量，而是需要以自然数集或其它无限集合的基数为标准进行度量。  
现在考察这样的一个问题，除了可数集合之外，还有没有其它的无限集合？或者说，是否每一个无限集合都能够与自然数集合建立一一对应的关系？事实上并非如此，例如开区间(0, 1)就不能与自然数建立等势关系，所有与开区间(0, 1)等势的集合构成了另外一类不同规模的集合，称之为不可数集合。其具体定义如下：  
【定义1.20】开区间(0, 1)称为不可数集合，其基数记为ℵ，读作阿列夫；凡是与开区间(0, 1)等势的集合都称为不可数集合。  
因此，不可数集合是比可数集合规模更大的一种无限集合类型。当然，还可以考虑不可数集合的幂集、不可数集合幂集的幂集等等，由此可以构造出很多种不同基数的无限集合。关于这些无限集合基数及其性质的讨论已经超出了离散数学的范畴，有兴趣的读者可以参阅实变函数理论中与连续统相关的内容。"
不相交轮换,概念,"['第七章 函数与特殊函数', '§ 7.4 有限集的置换函数', '7.4.3  置换的轮换分解']","{'实体类型': '概念', '定义': '设π和τ都是轮换，如果π和τ不含相同的元素，则称π与τ是不相交的'}",,3,"细心的读者可能会发现，前面几个置换函数例题的排列元素都只有3 个，这是主要因为置换数目的增长速度为排列元素数目的阶乘${n!}$，如果$n$比较大，则问题的规模会迅速增大而变得不可行。因此，对于有限集合$A=\{a_{1},a_{2},\cdots,a_{n}\}$上的置换，当$n$比较大时，就必须置换进行分解。现在我们考察对置换进行分解的具体方法。  
首先考察一种特殊的置换，在这种置换中的一些元素的函数映射呈现出一种循环的状态，而其余元素则的映射为恒等映射。例如，对于如下置换：  
$\begin{pmatrix}1&2&3&4&5&6&7&8\\4&3&5&2&1&6&7&8\end{pmatrix}$  
元素1 映射到4，元素4 映射到2，元素2 映射到3，元素3 映射到5，元素5 映射到1，然后循环。置换中这5 个元素1, 4, 2, 3, 5形成一个循环，而其余元素6, 7, 8则保持恒等映射，此时称这样的置换为长度为5 的轮换，记为(1, 4, 2, 3, 5),即有：  
$\begin{pmatrix}1&2&3&4&5&6&7&8\\4&3&5&2&1&6&7&8\end{pmatrix}=(1,4,2,3,5)  $  
轮换的具体定义如下：  
【定义7.14】设$A=\{a_{1},a_{2},\cdots,a_{n}\}$是任一非空有限集合，如果$𝐴$上的某个置换$P$把元素$a_{1}$变成$a_{2}$, $a_{2}$变成$a_{3},\ \cdots,a_{k-1}$变成$a_{k}$，又把$a_{k}$变成$a_{1}(k\leq n)$，但别的元素（如果有的话）都不变，则称$ P$是一个长度为$k$的轮换，简称为$\pmb{k}{-}$轮换，并将其记为$(a_{1},a_{2},\cdots,a_{k})$。其中长度为2 的轮换称为对换。  
由上述定义可知，轮换是置换另一种表达方式，它以元素变化次序为序，描述一种轮换过程$(a_{1},a_{2},\cdots,a_{k})=(a_{2},a_{3},\cdots,a_{k}a_{1})=\cdots=(a_{k},a_{1},\cdots,a_{k-1})。$例如对于轮换$(1,4, 2, 3, 5)$，有：$(1,4,2,3,5)=(\begin{array}{ccc}4,2,3,5,1)=(&2,3,5,1,4)=\cdots=(5,1,4,2,3)。\end{array}$  
值得注意的是，虽然轮换表达方式比置换更加简洁，轮换不能表达其所在置换的元素数目，需要采用其它方式说明置换的元素数目。  
现在考察轮换的运算。由于轮换是一种特殊的置换，故可像置换那样进行乘法运算。例如，对于集合$ A=\{1,2,3,4,5,6\}$上的两个轮换$(4,1,3,5)$和$(5,6,3)$，则可计算它们的乘积：  
$(4,1,3,5)\cdot(5,6,3)=\begin{pmatrix}1&2&3&4&5&&6\\3&2&5&1&4&&6\end{pmatrix}\cdot\begin{pmatrix}1&2&3&4&5&&6\\1&2&5&4&6&&3\end{pmatrix}$  
$=\begin{pmatrix}1&2&3&4&5&&6\\3&2&4&1&6&&5\end{pmatrix}$  
$\begin{aligned}(5,6,3)\cdot(4,1,3,5)&=\begin{pmatrix}1&2&3&4&5&6\\1&2&5&4&6&3\end{pmatrix}\cdot\begin{pmatrix}1&2&3&4&5&6\\3&2&5&1&4&6\end{pmatrix}.\\&=\begin{pmatrix}1&2&3&4&5&6\\5&2&6&1&4&3\end{pmatrix}\end{aligned}$  
可以看出$(4,\!1,\!3,\!5)\cdot(5,\!6,\!3)\neq(5,\!6,\!3)\cdot(4,\!1,\!3,\!5)$。因此，轮换的乘法不满足交换律。 显然，并不是每个置换都能成为轮换。例如，对于如下8 阶置换：  
$$
\tau=\begin{pmatrix}1&2&3&4&5&6&7\\3&5&6&4&2&1&7\end{pmatrix}
$$  
其不可能是轮换。但我们发现：  
$$
\tau=\begin{pmatrix}1&2&3&4&5&6&7\\3&5&6&4&2&1&7\end{pmatrix}
$$  
$$
=\bigl(\begin{matrix}1&2&3&4&5&6&7\\3&2&6&4&5&1&7\end{matrix}\bigr)\bigl(\begin{matrix}1&2&3&4&5&6&7\\1&5&3&4&2&6&7\end{matrix}\bigr)
$$  
$\quad\quad\quad\quad\quad=(\begin{matrix}1&3&6\\\end{matrix})(\begin{matrix}2&5\\\end{matrix})$  
由此可见，$\tau$虽不是轮换，但它可分解成是轮换的乘积。这为解决置换分解问题提供了一个思路。下面考虑对任意置换的轮换分解问题。首先给从下列定义：  
【定义7.15】设$\pi=(i_{1},i_{2},\cdots,i_{t})$和$\tau=(j_{1},j_{2},\cdots,j_{s})$都是轮换，如果$\pi$和$\cdot_{\tau}$不含相同的元素，则称$\pi$与$\tau$是不相交的。  
例如，集合$A=\{1,\!2,\!3,\!4,\!5,\!6\}$上的两个轮换(1,2,5)和(3,4,6)之间是不相交的，而轮换(1,2,5)和(2,4,6)之间则是相交的。  
下面给出对任意置换的轮换分解定理：  
【定理7.10】（轮换分解定理）任一$ n$元置换都可写成若干个不相交轮换的乘积。"
不重复圆排列,概念,"['第一章  集合与计数基础', '§ 1.3 有限集的基本计数技术', '1.3.3 排列计数与组合计数', '一、不重复的排列与组合']","{'实体类型': '概念', '定义': '假设S是由n个不同的元素组成的集合，从S中依次取出r个不同元素并将其按取出的次序排成一个圆圈，由此形成的一个有序圆排列称之为不重复r-圆排列，简称为r-圆排列或圆排列，不重复r-圆排列的个数称为不重复r-圆排列数，简称为r-圆排列数或圆排列数'}",,4,"首先考察如下排列问题：  
某班有35 名同学，现从中选出15 名同学排成一排，问有多少种排列方式？  
这个问题有如下两个关键要点：第一、在排列中每位同学最多只能出现一次，也就是无重复性；第二、不同的次序构成不同的排列。由此得到如下不重复排列的概念：  
【定义1.21】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中依次取出$r$ 个不同元素并将其按取出的次序排成一排，由此形成的一个有序排列称之为不重复$r\cdot$-排列，简称为$r\cdot$-排列或排列，不重复$r\cdot$-排列的个数称为不重复$r\cdot$-排列数，简称为$r\cdot$-排列数或排列数，记为${P}_{n}^{r}$或$P(n,r)$。称$r=n$时构成的排列称为全排列，$r<n$时构成的排列为选排列。  
根据乘法原理，显然可以得到如下结论：  
【定理1.13】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r\cdot$-排列数计算公式：  
$P(n,r)=n(n-1)(n-2)\cdots(n-r+1)\ \ ={\frac{n!}{(n-r)!}}$ 其中：$n!=n(n-1)(n-2)\cdots2\cdot1$  
【定义1.22】假设$S$是由$n$ 个不同的元素组成的集合，从$S$ 中依次取出$r$ 个不同元素并将其按取出的次序排成一个圆圈，由此形成的一个有序圆排列称之为不重复$r\cdot$-圆排列，简称为$r\cdot$-圆排列或圆排列，不重复$r\cdot$圆排列的个数称为不重复$r\cdot$-圆排列数，简称为$r\cdot$-圆排列数或圆排列数，记为${\cal P}_{c}(n,r)$。  
相对于上述圆排列的概念，有时亦将$r\cdot$-排列称为$r$-线排列或线排列。由前面分析不难看出，如果将每个$r\cdot$-线排列的首尾相连构成一个$r\cdot$-圆排列，则由此构成的所有圆排列必然有$r$倍的重复数。故有如下$r\cdot$-圆排列计算公式：  
【定理1.14】对于任意给定的两个正整数$n$ 和$r$，且$r\leq n$，其$r\cdot$-圆排列数为$P_{c}(n,r)$：  
$$
P_{c}(n,r)=\frac{P(n,r)}{r}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r}=\frac{n!}{r(n-r)!}
$$  
以上例子的共有特点是所有选出的元素都有一定的次序。事实上，很多情况下并不需要选出的元素具有有次序。  
考察如下组合问题：  
某班有35 名同学，现从中任意选出15 名同学参加问卷活动，问有多少种选择方式？  
与前述$r$-排列问题不同的是，这个问题只考虑抽取的是哪15 名同学，并不考虑抽取次序以及与之相关的排列问题。由此得到如下不重复组合及相关组合数的概念：  
【定义1.23】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中任意取出$r$ 个不同元素组成一个子集合，称每一个这样的子集合为一个不重复$r$-组合，简称为$r\cdot$-组合或组合，不重复$r$-组合的个数称为不重复$r\cdot$-组合数，简称为$r\cdot$-组合数或组合数，记为$C_{n}^{r}$或$C(n,r)$。  
显然， $r$ - 组合与 $r$ - 排列的区别在于 $r\cdot$ 组合不考虑组合中元素的排列次序， $r\cdot$ - 排列必须考 虑排列中各元素的排列次序。如果两个$r\cdot$-排列所含的元素完全相同，仅仅是排列次序不同，两个$r\cdot$-排列是同一个组合，由此得到有如下组合数计算公式：  
【定理1.15】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r-$组合数计算公式：  
$$
C(n,r)=\frac{P(n,r)}{r!}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r!}=\frac{n!}{r!(n-r)!}
$$"
不重复排列,概念,"['第一章  集合与计数基础', '§ 1.3 有限集的基本计数技术', '1.3.3 排列计数与组合计数', '一、不重复的排列与组合']","{'实体类型': '概念', '定义': '假设S是由n个不同的元素组成的集合，从S中依次取出r个不同元素并将其按取出的次序排成一排，由此形成的一个有序排列称之为不重复r-排列，简称为r-排列或排列，不重复r-排列的个数称为不重复r-排列数，简称为r-排列数或排列数', '特点': '无重复性，不同的次序构成不同的排列'}",,4,"首先考察如下排列问题：  
某班有35 名同学，现从中选出15 名同学排成一排，问有多少种排列方式？  
这个问题有如下两个关键要点：第一、在排列中每位同学最多只能出现一次，也就是无重复性；第二、不同的次序构成不同的排列。由此得到如下不重复排列的概念：  
【定义1.21】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中依次取出$r$ 个不同元素并将其按取出的次序排成一排，由此形成的一个有序排列称之为不重复$r\cdot$-排列，简称为$r\cdot$-排列或排列，不重复$r\cdot$-排列的个数称为不重复$r\cdot$-排列数，简称为$r\cdot$-排列数或排列数，记为${P}_{n}^{r}$或$P(n,r)$。称$r=n$时构成的排列称为全排列，$r<n$时构成的排列为选排列。  
根据乘法原理，显然可以得到如下结论：  
【定理1.13】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r\cdot$-排列数计算公式：  
$P(n,r)=n(n-1)(n-2)\cdots(n-r+1)\ \ ={\frac{n!}{(n-r)!}}$ 其中：$n!=n(n-1)(n-2)\cdots2\cdot1$  
【定义1.22】假设$S$是由$n$ 个不同的元素组成的集合，从$S$ 中依次取出$r$ 个不同元素并将其按取出的次序排成一个圆圈，由此形成的一个有序圆排列称之为不重复$r\cdot$-圆排列，简称为$r\cdot$-圆排列或圆排列，不重复$r\cdot$圆排列的个数称为不重复$r\cdot$-圆排列数，简称为$r\cdot$-圆排列数或圆排列数，记为${\cal P}_{c}(n,r)$。  
相对于上述圆排列的概念，有时亦将$r\cdot$-排列称为$r$-线排列或线排列。由前面分析不难看出，如果将每个$r\cdot$-线排列的首尾相连构成一个$r\cdot$-圆排列，则由此构成的所有圆排列必然有$r$倍的重复数。故有如下$r\cdot$-圆排列计算公式：  
【定理1.14】对于任意给定的两个正整数$n$ 和$r$，且$r\leq n$，其$r\cdot$-圆排列数为$P_{c}(n,r)$：  
$$
P_{c}(n,r)=\frac{P(n,r)}{r}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r}=\frac{n!}{r(n-r)!}
$$  
以上例子的共有特点是所有选出的元素都有一定的次序。事实上，很多情况下并不需要选出的元素具有有次序。  
考察如下组合问题：  
某班有35 名同学，现从中任意选出15 名同学参加问卷活动，问有多少种选择方式？  
与前述$r$-排列问题不同的是，这个问题只考虑抽取的是哪15 名同学，并不考虑抽取次序以及与之相关的排列问题。由此得到如下不重复组合及相关组合数的概念：  
【定义1.23】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中任意取出$r$ 个不同元素组成一个子集合，称每一个这样的子集合为一个不重复$r$-组合，简称为$r\cdot$-组合或组合，不重复$r$-组合的个数称为不重复$r\cdot$-组合数，简称为$r\cdot$-组合数或组合数，记为$C_{n}^{r}$或$C(n,r)$。  
显然， $r$ - 组合与 $r$ - 排列的区别在于 $r\cdot$ 组合不考虑组合中元素的排列次序， $r\cdot$ - 排列必须考 虑排列中各元素的排列次序。如果两个$r\cdot$-排列所含的元素完全相同，仅仅是排列次序不同，两个$r\cdot$-排列是同一个组合，由此得到有如下组合数计算公式：  
【定理1.15】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r-$组合数计算公式：  
$$
C(n,r)=\frac{P(n,r)}{r!}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r!}=\frac{n!}{r!(n-r)!}
$$"
不重复组合,概念,"['第一章  集合与计数基础', '§ 1.3 有限集的基本计数技术', '1.3.3 排列计数与组合计数', '一、不重复的排列与组合']","{'实体类型': '概念', '定义': '假设S是由n个不同的元素组成的集合，从S中任意取出r个不同元素组成一个子集合，称每一个这样的子集合为一个不重复r-组合，简称为r-组合或组合，不重复r-组合的个数称为不重复r-组合数，简称为r-组合数或组合数'}",,4,"首先考察如下排列问题：  
某班有35 名同学，现从中选出15 名同学排成一排，问有多少种排列方式？  
这个问题有如下两个关键要点：第一、在排列中每位同学最多只能出现一次，也就是无重复性；第二、不同的次序构成不同的排列。由此得到如下不重复排列的概念：  
【定义1.21】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中依次取出$r$ 个不同元素并将其按取出的次序排成一排，由此形成的一个有序排列称之为不重复$r\cdot$-排列，简称为$r\cdot$-排列或排列，不重复$r\cdot$-排列的个数称为不重复$r\cdot$-排列数，简称为$r\cdot$-排列数或排列数，记为${P}_{n}^{r}$或$P(n,r)$。称$r=n$时构成的排列称为全排列，$r<n$时构成的排列为选排列。  
根据乘法原理，显然可以得到如下结论：  
【定理1.13】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r\cdot$-排列数计算公式：  
$P(n,r)=n(n-1)(n-2)\cdots(n-r+1)\ \ ={\frac{n!}{(n-r)!}}$ 其中：$n!=n(n-1)(n-2)\cdots2\cdot1$  
【定义1.22】假设$S$是由$n$ 个不同的元素组成的集合，从$S$ 中依次取出$r$ 个不同元素并将其按取出的次序排成一个圆圈，由此形成的一个有序圆排列称之为不重复$r\cdot$-圆排列，简称为$r\cdot$-圆排列或圆排列，不重复$r\cdot$圆排列的个数称为不重复$r\cdot$-圆排列数，简称为$r\cdot$-圆排列数或圆排列数，记为${\cal P}_{c}(n,r)$。  
相对于上述圆排列的概念，有时亦将$r\cdot$-排列称为$r$-线排列或线排列。由前面分析不难看出，如果将每个$r\cdot$-线排列的首尾相连构成一个$r\cdot$-圆排列，则由此构成的所有圆排列必然有$r$倍的重复数。故有如下$r\cdot$-圆排列计算公式：  
【定理1.14】对于任意给定的两个正整数$n$ 和$r$，且$r\leq n$，其$r\cdot$-圆排列数为$P_{c}(n,r)$：  
$$
P_{c}(n,r)=\frac{P(n,r)}{r}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r}=\frac{n!}{r(n-r)!}
$$  
以上例子的共有特点是所有选出的元素都有一定的次序。事实上，很多情况下并不需要选出的元素具有有次序。  
考察如下组合问题：  
某班有35 名同学，现从中任意选出15 名同学参加问卷活动，问有多少种选择方式？  
与前述$r$-排列问题不同的是，这个问题只考虑抽取的是哪15 名同学，并不考虑抽取次序以及与之相关的排列问题。由此得到如下不重复组合及相关组合数的概念：  
【定义1.23】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中任意取出$r$ 个不同元素组成一个子集合，称每一个这样的子集合为一个不重复$r$-组合，简称为$r\cdot$-组合或组合，不重复$r$-组合的个数称为不重复$r\cdot$-组合数，简称为$r\cdot$-组合数或组合数，记为$C_{n}^{r}$或$C(n,r)$。  
显然， $r$ - 组合与 $r$ - 排列的区别在于 $r\cdot$ 组合不考虑组合中元素的排列次序， $r\cdot$ - 排列必须考 虑排列中各元素的排列次序。如果两个$r\cdot$-排列所含的元素完全相同，仅仅是排列次序不同，两个$r\cdot$-排列是同一个组合，由此得到有如下组合数计算公式：  
【定理1.15】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r-$组合数计算公式：  
$$
C(n,r)=\frac{P(n,r)}{r!}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r!}=\frac{n!}{r!(n-r)!}
$$"
与门,概念,"['第三章  命题演算与推理', '§ 3.6 命题逻辑的应用', '3.6.2 组合逻辑电路设计']","{'实体类型': '概念', '特点': '允许有多个输入'}",,3,"逻辑电路，又分为逻辑电路和时序逻辑电路。前者由最基本的“与门”、“或门”和“非门”电路组成，其输出值仅依赖于其输入变量的当前值，与输入变量的过去值无关—即不具记忆和存储功能；后者也由上述基本逻辑门电路组成，但存在反馈回路—它的输出值不仅依赖于输入变量的当前值， 也依赖于输入变量的过去值。 命题逻辑是组合逻辑电路设计的理论基础 和基本工具。如图3-10 所示，组合逻辑电路中的 “非门”、 “与门”、 “或门”，即为命题逻辑的“与”、“或”、“非”三种运算。通过利用这三种门，就可以构造出各种组合逻辑电路。  
![](images/e4f21b269b175874de7115f5156d6a3c1eb9e6666a1338dc9d4727bc0ca3ab30.jpg)
图3-10 基本类型的门  
“与门”和“或门”允许有多个输入，具有 $n$个输入的“与门”和“或门”如图3-11 所示。  
![](images/b8e3cbd2c8e7532c3d5f1acea4bd76306cd188918c6130d6354e264b174b34dc.jpg)
图3-11 具有 $n$ 个输入的门"
两两互素,概念,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.2 整数的因数分解', '二、互素的概念与性质']","{'实体类型': '概念', '定义': '如果多个整数中任意两个整数的最大公因数均为1，则称这些整数两两互素', '区分': '与互素是两个不同的概念，两两互素可以推出互素，反之不然'}",,4,"从整除的角度看，两个整数的公因数表达的是这两个整数共性成分。如果两个整数的最大公因数为1，则表明这两个整数除1 之外没有任何额外的共性成分。因此，从结构上看，这两个整数之间具有很强的独立性。这种很强的独立性我们称之为互素。互素是整数理论中一个非常重要的基本概念，整数的很多性质都与互素的概念有关，其具体定义如下：  
【定义2.7】假设$a_{1},a_{2},\cdots,a_{k}$是$k$个不全为零的整数，如果有$\operatorname*{gcd}(a_{1},a_{2},\cdots,a_{k})=1$，则称这$k$ 个整数$a_{1},a_{2},\cdots,a_{k}$为互素；如果$a_{1},a_{2},\cdots,a_{k}$中任意两个整数的最大公因数均为1，则称这$k$ 个整数$a_{1},a_{2},\cdots,a_{k}$为两两互素。  
$a_{1},a_{2},\cdots,a_{k}$互素与$a_{1},a_{2},\cdots,a_{k}$两两互素是两个不同的概念，在实际使用过程中应注意加以区分，避免混淆。显然，由$a_{1},a_{2},\cdots,a_{k}$两两互素可以推出$a_{1},a_{2},\cdots,a_{k}$互素，反之不然。例如，$\operatorname*{gcd}(3,6,9,10)=1$，此时这4 个整数仅仅为互素的关系，因为其中的3, 6, 9的最大公因数并不为1，所以不符合两两互素。  
【定理2.8】设$a$，$b$ 是任意两个整数，若$\operatorname*{gcd}(a,b)=a s+b t$，则$s$ 与$t$是互素的。  
【定理2.9】如果整数$a$ 与整数$b_{1},b_{2},\cdots,b_{n}$中的每一个都互质，那么$a$ 与乘积$b_{1}b_{2}\cdots b_{n}$也互质。  
【定理2.10】对于任意的整数$a$，$b$，$c$，下面结论成立：  
（1）若$b|a c$且$\operatorname*{gcd}(a,b)=1$，则有$b|c$；  
（2）若$b|c$且$a|c$，则有$a b|c$。  
【定理 2.11 】若 $\operatorname*{gcd}(a,b)=1$ ，则 $\operatorname*{gcd}(a,b k)=\operatorname*{gcd}(a,k)\,.$"
个体变量,概念,"['第四章  谓词演算与推理', '§ 4.1 个体词、谓词与量词', '4.1.2  命题函数与谓词', '二、个体变量与命题函数']","{'实体类型': '概念', '定义': '个体词以变量的方式泛指不确定的个体', '表示方法': '通常用带下标或不带下标的英文字母表示', '取值范围': '个体变量的取值范围称为个体域或论域'}",,4,"对于任一给定的原子命题，其主语或宾语是一种可以独立存在的确定对象，我们称之为个体常量，将个体常量抽象成含义不确定的变量后，则称之为个体变量。相关定义如下：  
【定义4.1】客观世界中可以独立存在的具体或抽象对象称为个体，表示个体的词称为个体词。若个体词以常量的方式表示特定个体，则称之为个体常量；若个体词以变量的方式泛指不确定的个体，则称之为个体变量。  
例如，前述原子命题“小张是大学生”中的个体为“小张”。再如，命题“电子计算机是科学技术的工具”中的个体为“电子计算机”；命题“张三比李四高”中的个体为：“张三”、“李四”.可用个体常量表示这些确定的个体。  
对于个体常量，通常用带下标或不带下标的英文字母$a$，$b$，$c$，…表示。例如，可用$a$和$b$ 分别表示前述个体“小张”和“电子计算机”。  
对于前述含变量的语句“$x$是大学生”、“$x>5$”、“$x+y=10$”、“$x+y<z$”，其中的x，y，$z$均表示泛指的不确定个体，因而它们都是个体变量。  
对于个体变量，通常用带下标或不带下标的英文字母$x$，y，$z$，…表示。  
个体变量的取值应有一个明确范围，故有如下个体域的概念：  
【定义4.2】个体变量的取值范围称为个体域或论域。宇宙间所有的个体域聚集在一起构成的个体域，称为全总个体域。  
个体变量的个体域可根据问题的实际状况或需要来确定。例如，对于含变量语句“$\cdot_{x}$ 是大学生”，其中个体变量$x$ 的变化范围，可以确定为全体人类，也可以确定为某单位的全体职工，还可以确定为某个大学的全班同学或者某个中学的全班同学，等等。显然，个体变量的个体域的不同，其相应含变量语句的含义也会有所不同。  
现在个体变量与个体域概念基础上，给出命题函数的定义：  
【定义4.3】设$x_{1},x_{2},\cdots x_{n}$为$n$个个体变量，其个体域均为非空集合$D$，则定义在$D^{n}$上取值于$\{0,1\}$的$n$元函数称为$^n$元简单命题函数，记为$P(x_{1},x_{2},\cdots x_{n})$。  
例如，前述表示“$x$ 是大学生”的式子”$P(x)$“，以及“$x>5$”、“$x+y=10$”、“$x+y<z$”，都是简单命题函数。其中”$P(x)$“和“$x>5$”为一元简单命题函数，“$x+y=10$”和“$x+y<z$”分别是二元和三元简单命题函数。  
如同原子命题可以通过联结词进行逻辑演算得到复合命题一样，简单命题函数也可通过联结词的逻辑演算，得到一种更为复杂的表达式，即复合命题函数。其具体定义如下：  
【定义4.4】简单命题函数通过“$\neg$”、“$\land$”、“$\lor$”、“$\rightarrow$”、“$\leftrightarrow$”等联结词进行逻辑演算得到的逻辑表达式，称为复合命题函数。  
例如，对于如下给定的简单命题函数：  
${A(x)\colon x\text{身体好};B(x)\colon x\text{学习好};C(x)\colon x\text{工作好}}$  
复合命题函数：  
$$
\neg A(x)\to(\neg B(x)\land\neg C(x))
$$  
表示如果$x$身体不好，那么学习和工作都不会好。"
个体域,概念,"['第四章  谓词演算与推理', '§ 4.1 个体词、谓词与量词', '4.1.2  命题函数与谓词', '二、个体变量与命题函数']","{'实体类型': '概念', '定义': '个体变量的取值范围称为个体域或论域', '全总个体域': '宇宙间所有的个体域聚集在一起构成的个体域'}",,4,"对于任一给定的原子命题，其主语或宾语是一种可以独立存在的确定对象，我们称之为个体常量，将个体常量抽象成含义不确定的变量后，则称之为个体变量。相关定义如下：  
【定义4.1】客观世界中可以独立存在的具体或抽象对象称为个体，表示个体的词称为个体词。若个体词以常量的方式表示特定个体，则称之为个体常量；若个体词以变量的方式泛指不确定的个体，则称之为个体变量。  
例如，前述原子命题“小张是大学生”中的个体为“小张”。再如，命题“电子计算机是科学技术的工具”中的个体为“电子计算机”；命题“张三比李四高”中的个体为：“张三”、“李四”.可用个体常量表示这些确定的个体。  
对于个体常量，通常用带下标或不带下标的英文字母$a$，$b$，$c$，…表示。例如，可用$a$和$b$ 分别表示前述个体“小张”和“电子计算机”。  
对于前述含变量的语句“$x$是大学生”、“$x>5$”、“$x+y=10$”、“$x+y<z$”，其中的x，y，$z$均表示泛指的不确定个体，因而它们都是个体变量。  
对于个体变量，通常用带下标或不带下标的英文字母$x$，y，$z$，…表示。  
个体变量的取值应有一个明确范围，故有如下个体域的概念：  
【定义4.2】个体变量的取值范围称为个体域或论域。宇宙间所有的个体域聚集在一起构成的个体域，称为全总个体域。  
个体变量的个体域可根据问题的实际状况或需要来确定。例如，对于含变量语句“$\cdot_{x}$ 是大学生”，其中个体变量$x$ 的变化范围，可以确定为全体人类，也可以确定为某单位的全体职工，还可以确定为某个大学的全班同学或者某个中学的全班同学，等等。显然，个体变量的个体域的不同，其相应含变量语句的含义也会有所不同。  
现在个体变量与个体域概念基础上，给出命题函数的定义：  
【定义4.3】设$x_{1},x_{2},\cdots x_{n}$为$n$个个体变量，其个体域均为非空集合$D$，则定义在$D^{n}$上取值于$\{0,1\}$的$n$元函数称为$^n$元简单命题函数，记为$P(x_{1},x_{2},\cdots x_{n})$。  
例如，前述表示“$x$ 是大学生”的式子”$P(x)$“，以及“$x>5$”、“$x+y=10$”、“$x+y<z$”，都是简单命题函数。其中”$P(x)$“和“$x>5$”为一元简单命题函数，“$x+y=10$”和“$x+y<z$”分别是二元和三元简单命题函数。  
如同原子命题可以通过联结词进行逻辑演算得到复合命题一样，简单命题函数也可通过联结词的逻辑演算，得到一种更为复杂的表达式，即复合命题函数。其具体定义如下：  
【定义4.4】简单命题函数通过“$\neg$”、“$\land$”、“$\lor$”、“$\rightarrow$”、“$\leftrightarrow$”等联结词进行逻辑演算得到的逻辑表达式，称为复合命题函数。  
例如，对于如下给定的简单命题函数：  
${A(x)\colon x\text{身体好};B(x)\colon x\text{学习好};C(x)\colon x\text{工作好}}$  
复合命题函数：  
$$
\neg A(x)\to(\neg B(x)\land\neg C(x))
$$  
表示如果$x$身体不好，那么学习和工作都不会好。"
个体常量,概念,"['第四章  谓词演算与推理', '§ 4.1 个体词、谓词与量词', '4.1.2  命题函数与谓词', '二、个体变量与命题函数']","{'实体类型': '概念', '定义': '个体词以常量的方式表示特定个体'}",,4,"对于任一给定的原子命题，其主语或宾语是一种可以独立存在的确定对象，我们称之为个体常量，将个体常量抽象成含义不确定的变量后，则称之为个体变量。相关定义如下：  
【定义4.1】客观世界中可以独立存在的具体或抽象对象称为个体，表示个体的词称为个体词。若个体词以常量的方式表示特定个体，则称之为个体常量；若个体词以变量的方式泛指不确定的个体，则称之为个体变量。  
例如，前述原子命题“小张是大学生”中的个体为“小张”。再如，命题“电子计算机是科学技术的工具”中的个体为“电子计算机”；命题“张三比李四高”中的个体为：“张三”、“李四”.可用个体常量表示这些确定的个体。  
对于个体常量，通常用带下标或不带下标的英文字母$a$，$b$，$c$，…表示。例如，可用$a$和$b$ 分别表示前述个体“小张”和“电子计算机”。  
对于前述含变量的语句“$x$是大学生”、“$x>5$”、“$x+y=10$”、“$x+y<z$”，其中的x，y，$z$均表示泛指的不确定个体，因而它们都是个体变量。  
对于个体变量，通常用带下标或不带下标的英文字母$x$，y，$z$，…表示。  
个体变量的取值应有一个明确范围，故有如下个体域的概念：  
【定义4.2】个体变量的取值范围称为个体域或论域。宇宙间所有的个体域聚集在一起构成的个体域，称为全总个体域。  
个体变量的个体域可根据问题的实际状况或需要来确定。例如，对于含变量语句“$\cdot_{x}$ 是大学生”，其中个体变量$x$ 的变化范围，可以确定为全体人类，也可以确定为某单位的全体职工，还可以确定为某个大学的全班同学或者某个中学的全班同学，等等。显然，个体变量的个体域的不同，其相应含变量语句的含义也会有所不同。  
现在个体变量与个体域概念基础上，给出命题函数的定义：  
【定义4.3】设$x_{1},x_{2},\cdots x_{n}$为$n$个个体变量，其个体域均为非空集合$D$，则定义在$D^{n}$上取值于$\{0,1\}$的$n$元函数称为$^n$元简单命题函数，记为$P(x_{1},x_{2},\cdots x_{n})$。  
例如，前述表示“$x$ 是大学生”的式子”$P(x)$“，以及“$x>5$”、“$x+y=10$”、“$x+y<z$”，都是简单命题函数。其中”$P(x)$“和“$x>5$”为一元简单命题函数，“$x+y=10$”和“$x+y<z$”分别是二元和三元简单命题函数。  
如同原子命题可以通过联结词进行逻辑演算得到复合命题一样，简单命题函数也可通过联结词的逻辑演算，得到一种更为复杂的表达式，即复合命题函数。其具体定义如下：  
【定义4.4】简单命题函数通过“$\neg$”、“$\land$”、“$\lor$”、“$\rightarrow$”、“$\leftrightarrow$”等联结词进行逻辑演算得到的逻辑表达式，称为复合命题函数。  
例如，对于如下给定的简单命题函数：  
${A(x)\colon x\text{身体好};B(x)\colon x\text{学习好};C(x)\colon x\text{工作好}}$  
复合命题函数：  
$$
\neg A(x)\to(\neg B(x)\land\neg C(x))
$$  
表示如果$x$身体不好，那么学习和工作都不会好。"
个体词,概念,"['4.1.3  量词与特性谓词', '二、个体变量与命题函数', '一、含变量的语句', '三、特性谓词及其应用', '第四章  谓词演算与推理', '§ 4.1 个体词、谓词与量词', '4.1.1  逻辑与谓词逻辑', '4.1.2  命题函数与谓词']","{'实体类型': '概念', '定义': '表示各种具体或抽象的对象，相当于陈述句中的主语或宾语部分；命题中的主语部分。表示个体的词称为个体词。若个体词以常量的方式表示特定个体，则称之为个体常量；若个体词以变量的方式泛指不确定的个体，则称之为个体变量。谓词中含有个体变量。', '特点': '用于表示具体对象', 'name': '个体词'}",,2,谓词逻辑的核心思想是将作为命题的陈述句分解成个体词与谓词这两个更为基本的要素。个体词表示各种具体或抽象的对象，相当于陈述句中的主语或宾语部分；谓词则表示对象的属性或对象之间的联系，相当于陈述句中的谓语部分。不同个体词会使命题产生不同含义以至于形成不同真值，同一个体词使用场合的不同也可能使命题的真值产生变化。为此，谓词逻辑引入量词概念，并通过将其与谓词相结合实现对个体词含义的准确限定。个体词、谓词和量词是谓词逻辑中最核心、最基本的概念，本节通过讨论这三个概念及其性质比较系统地介绍谓词逻辑中最基本的知识，包括谓词逻辑的由来、命题函数与谓词的概念、量词与特性谓词的概念、谓词逻辑的符号化等。
个体项,概念,"['第四章  谓词演算与推理', '§ 4.2  谓词公式与等值演算', '4.2.1 谓词公式的概念']","{'实体类型': '概念', '定义': '谓词逻辑中的个体项，被递归地定义为个体常量符号、个体变量符号、个体函数符号及其组合', '特点': '能有效地表达个体以及个体之间的复杂映射关系'}",,3,"类似于命题逻辑，谓词逻辑采用谓词公式的方式实现对谓词符号的表达。但谓词公式的定义比命题公式更加复杂，因为谓词公式的表达要深入到概念层次，需要用到更多种类的特殊符号来表达命题在概念层次上的各种组件。具体地说，除了前述两种量词符号之外，还有四种特殊符号，即：表示个体的个体常量符号、个体变量符号、个体函数符号，以及表示谓词的谓词符号。这四种符号的表达方式如下：  
（1）个体常量符号：用带或不带下标的小写英文字母$a,b,c,\cdots$表示个体常量。  
（2）个体变量符号：用带或不带下标的小写英文字母$x,y,z,$…表示个体变量。  
（3）个体函数符号：用带或不带下标的小写英文字母$f,\,g,\,h,\cdots$表示个体函数。所谓个体函数，就是个体与个体之间的映射关系。  
（4）谓词符号：用带或不带下标的大写英文字母$P,Q,R,\cdots$表示谓词。  
个体函数表示谓词逻辑中个体与个体之间的映射关系。例如，对于命题：小张的爸爸是教授。如果设立如下谓词和个体函数：  
$P(x)$:$x$是教授；$f(x)$:$x$的爸爸  
则该命题的谓词式可表示为：$P(f(x))$  
个体函数的使用为谓词逻辑中个体之间映射关系的表达带来了很大的方便，大大提升了谓词逻辑符号系统的表达能力。基于个体函数，可按如下方式定义一个称之为个体项的概念来专门表达谓词逻辑中的个体之间复杂的映射关系：  
【定义4.9】谓词逻辑中的个体项，被递归地定义为：  
（1）个体常量符号是个体项；  
（2）个体变量符号是个体项；  
（3）若$f(x_{1}\,,\ x_{2}\,,\ \ \dots\,,\ x_{n})$是$.n$元函数，$t_{1}$，$t_{2}$，… ，$t_{n}$是个体项，则$f(t_{1}\,,\,\,\,t_{2}\,,\,\,\,\dots\,,\,\,\,t_{n})$是个体项；  
（4）所有个体项都是有限次使用(1)，(2)，(3)生成的符号串。  
由定义可知，个体项具有非常强大的表达能力，能有效地表达个体以及个体之间的复杂的映射关系，谓词中的个体常量、个体变量和个体函数都可以统一用个体项的概念进行表达。例如复合函数$f(g(x,y),\ h(a,g(x,y),z))$都是个体项；再如，令$f(x)$表示“$x$ 的叔叔”；$P(x)$表示“$x$ 是医生”；$c$ 表示“周红”，则$f(c)$是一个体项，此时$P(f(c))$表示命题“周红的叔叔是医生”。有了个体项的概念，就可在$n$元谓词的基础上得到如下原子谓词公式的定义：  
【定义4.10】设$P(x_{1}\,,\ x_{2}\,,\ \ \dots\,,\ x_{n})$是$n$元谓词公式，$t_{1}\,,\,\,\,t_{2}\,,\,\,\,\dots\,,\,\,\,t_{n}$是个体项，则称$P(t_{1},\ t_{2},\ \dots,\ t_{n})$为谓词演算的原子公式，简称为原子谓词公式。  
可原子谓词公式的基础上进一步得到如下谓词合式公式的定义：  
【定义4.11】谓词合式公式亦称为谓词公式，它按下列递归方式定义：  
（1）原子谓词公式是谓词公式；  
（2）若$G$，$H$是谓词公式，则$(\neg G)$$),\;(G\!\!\lor \!\!H),\;(G\!\!\ \ \wedge  H),\;(G\!\!\to\!\!H),\;$$(G{\leftrightarrow}H)$是合式公式；  
（3）若$G$ 是谓词公式，$x$是$G$ 中的自由变量，则$\forall x G$，$\exists x G$都是谓词公式；  
（4）所有谓词公式都是有限次使用（1），（2），（3）生成的符号串。  
由上述定义可知，谓词公式是原子谓词公式、联结词、量词、圆括号和逗号按上述规则组成的符号串，且命题公式是谓词公式的一个特例。为方便起见，谓词公式中的括号可以像命题公式那样省略最外层括号。  
例如：$(\forall x)(\forall y)(P(x,y)\rightarrow(Q(x,y)\vee\neg R(x,a,f(z)))), (\forall x)(P(x)\vee(\exists y)R(x,y))$等都是谓词公式；$(\forall x)(P(x)\to R(x),\ (\exists y)(\forall x)(\lor P(x,y))$等则都不是公式，前者括号不配对，后者联结词无联结对象。"
中国余数定理,定理,"['第二章  整数与算法设计基础', '§ 2.2 同余算术及其应用', '2.2.2 同余方程与方程组']","{'实体类型': '定理', '条件': '所有模两两互素', '结论': '同余方程组有唯一的以M为模的解'}",,3,"相等的两个整数除以某一正整数$m$ 后得到的余数自然是相等的。因此，两个整数之间的同余关系不仅可以看成是对整除关系的一种推广，而且还可以看成是对两个整数相等关系的一种推广。下面定理表明整数相等关系与同余关系自己具有共同本质属性。  
【定理2.25】假设$m$ 是任一给定的正整数，则模$m$ 同余关系满足下列性质：  
(1) 自反性：$a\equiv a({\bmod{\ m}})$，对一切整数$a$ 成立；  
(2) 对称性：若$a\equiv b({\bmod{\ }}m)$，则$b\equiv a({\bmod{\ m}}).$；  
(3) 传递性：若$a\equiv b({\bmod{\ }}m)$，$b\equiv c({{\pmod{m}}})$，则$a\equiv c({{\pmod{m}}}).$。  
我们知道，根据整数之间相等关系的制约可以列出相应的整数方程和方程组。那么，根据整数同余关系的制约是否也可以列出相应的方程和方程组呢？如果可以，那么这些方程和方程组如何求解？本节我们就来讨论这些问题。  
【定义2.14】假设$m$ 是任一给定的正整数，$a$ 和$b$ 是任意给定的两个整数，下式：  
$$
a x\equiv b({\bmod{m}})\tag{2-13}
$$  
称为关于未知数$x$ 的一次线性同余方程，简称为同余方程，其中$x$ 为未知整数。若存在一个整数$\cdot x_{0}$，当$x=x_{0}$时，成立$.a x\equiv b({\bmod{\pmod{m}}})$，则称$\cdot x_{0}$是该同余方程的一个解。  
显然，如果$x_{0}$是某个同余方程的一个解，则与$x_{0}$同余的所有整数都是该同余方程的解，这是一种平凡情形，通常将与$x_{0}$同余的所有整数与$x_{0}$一起看成是同一个解。因此，同余方程解的计数标准为：凡是相互之间模$m$ 同余的解都视为同一个解，同余方程解的个数是指它的关于模$m$ 互不同余所有解的个数，亦即在模$m$ 的一个完全剩余系中解的个数。  
下面考察一次线性同余方程解的存在性：  
【定理2.26】假设$m$ 是任一给定的正整数，$a,b$ 是任意给定的两个整数，如果$a$ 与$m$之间没有整除关系，即有$a\not\equiv0({\bmod{m}})$ ，则下列同余方程  
$$
a x\equiv b({\bmod{m}})
$$  
有解的充要条件是$a$ 与$m$ 的最大公因数能够整除$b$。若有解，则解的个数为$\operatorname*{gcd}(a,m)$。  
对于同余方程$a\cdot x \equiv 1(\mod m)$，其有解的充要条件是$a$ 与$m$ 的最大公因数能够整除1，即互素$a$ 与$m$。且有解的情况下只有唯一解。由此给出如下关于$\bar{a}$的定义：  
【定义2.15】设$m$ 是任一给定的正整数，$a$ 是任一与$m$ 互素的整数，满足$a\cdot x\equiv$1 (mod $m^{\prime}$)的最小正整数解称为整数$a$的模$\pmb{m}$ 逆，记为$\cdot\bar{a}$。  
下面定理的证明过程给出了整数$a$ 模$m$ 逆$\bar{a}$的一个具体求法：  
【定理2.27】设$m$ 和$a$ 是两个互素的整数，且$m>1$，则存在唯一一个小于$m$ 的正整数$\bar{a}$，它是$a$ 的模$m$ 逆，即有：${\bar{a}}\cdot a\equiv1({\bmod{{m}}})$。  
【定义2.16】假设$m_{1},m_{2},\cdots,m_{k}$为$k$个正整数，$a_{1},a_{2},\cdots,a_{k}$为$k$ 个整数，由下列$k$ 个以$x$ 为未知整数的同余方程联立而成的方程组，称为同余方程组：  
$$
\left\{\begin{array}{l l}{x\equiv a_{1}(\bmod~m_{1})}\\ {x\equiv a_{2}(\bmod m_{2})}\\ {\qquad\dots}\\ {x\equiv a_{k}(\bmod~m_{k})}\end{array}\right.\tag{2-14}
$$  
若存在一个整数$\cdot x_{0}$满足上述所有同余方程，则称$\cdot x_{0}$是该同余方程组的一个解。  
当以上定义的同余方程组中所有模两两互素时，方程组一定有唯一的一组解。下面的中国余数定理是整数理论中一个非常著名的定理，又称为孙子定理。该定理不仅确认了上述结论，而且其证明过程其实给出了一个具体的求解方法。  
【定理2.28】（中国余数定理）设$m_{1}$$\cdot\ \ m_{2},\ \ \cdots m_{k}$是两两互素的正整数，那么同余式组（2-14）有唯一的以$M=m_{1}m_{2}\cdots m_{k}$为模的解。"
中国邮路问题,问题,"['第十章  特殊图模型与算法', '§ 10.1 欧拉图与哈密顿图', '10.1.3 中国邮路问题']","{'实体类型': '问题', '定义': '某邮递员从邮局出发去送信，期间要走完他负责投递的所有街道，最后返回邮局，选择路径使得总路程最短', '建模方法': '将街道抽象成无向边，街道道口抽象成结点，构成无向连通图，道路长度抽象成边的权值', '求解思路': '若图是欧拉图，使用弗洛莱算法求解欧拉回路；若不是欧拉图，添加重复边使其变为欧拉图并进行优化', '优化规则': '(1) 保证图中每条边重数小于等于2；(2) 保证图中每个基本回路上平行边的总权值不大于该回路权值的一半'}",,3,"中国邮路问题是我国数学家管梅谷教授在1960 年提出的一个著名网络优化问题：某邮递员从邮局出发去送信，期间要走完他负责投递的所有街道，最后返回邮局。该邮递员如何选择路径才能使得所走的总路程最短？  
可以用图模型对该问题进行建模。具体地说，就是将该邮递员负责投递的每条街道抽象成一条无向边，街道道口抽象成结点，构成一个无向连通图$G=\langle V,E\rangle$。若将每条道路的长度抽象成其所对应边的权值，则中国邮路问题可转化为如下关于图模型的问题：对于任意给定的一个连通图$G=\langle V,E\rangle$，如何遍历图中每条边，使得总路线最短（权重之和最小）。  
如果$G=\langle V,E\rangle$是一个欧拉图，则中国邮路问题的解显然就是该图的欧拉回路。因为根据问题要求，图中每条边必须至少经过一次，欧拉回路则是每条边经过且仅经过一次。这是最好的情形，可用弗洛莱算法得到具体的欧拉回路实现对该问题的求解。  
然而，如果$G=\langle V,E\rangle$不是一个欧拉图，那么就不能保证每条边仅通过一次，有些边需要两次。此时，让哪条边或哪些边通过两次则是一个需要认真考虑的问题。最直观的想法就是让权最小的边通过两次，但如此并不能保证能够遍历每条边。因此，基本的求解思路是在保证完成对边遍历的前提下，让权值尽可能小的边通过两次。换句话说，就是如何在图中添加权值尽可能小重复边，使得该图变成一个欧拉图。下面给出具体求解方案：  
我们知道，一个连通图之所以不是欧拉图，是因为图中存在偶数个奇度数结点。因此，需要将这些，将其强制性变成欧拉图。具体地说，就是以这些奇度点为结点，添加一些边，使得这些奇度结点变成偶度结点。 得到欧拉图之后，还要判断该欧拉图是否为最优， 也就是 说通过该欧拉图得到的总权值是否最小，否则就要对其做进一步优化。  
因此，中国邮路问题的基本求解思路为：若抽象出的图是欧拉图，则总路线固定，使用弗洛莱算法求解一条欧拉回路即可；若抽象出来图不是欧拉图，则需要添加重复边，将其变为欧拉图，并对当前欧拉图进行调优。下面给出后一种情况的具体求解方法：  
假设奇度数结点为$v_{1},v_{2},\cdots,v_{2h}$，则可依次添加重复边（可以有多种添加方案，只要能保证两两奇度数结点相连就好），即添加边$(v_{2i-1},v_{2i})$，其中$i=1,2,\cdots,h$，将图扩展为一个欧拉图。然后，基于如下两个规则对当前欧拉图进行优化：  
(1) 保证图中的每条边重数小于等于2：若边的重数大于或等于3，就去掉偶数条边。显然，在去掉偶数条边后，得到的图依然是欧拉图。  
(2) 保证图中的每个基本回路上平行边的总权值不大于该回路权值的一半：如果平行边的总权值大于了该回路权值的一半，则去掉该平行边，并在不影响图中结点度数奇偶性的前提下，给原来没有平行边的边加上平行边。  
下面结合具体实例介绍具体计算过程："
中根遍历算法,算法,"['第九章  树的基本理论与算法', '§ 9.2 根树的基本知识', '9.2.2 根树的基本算法']","{'实体类型': '算法', '步骤': '首先递归访问根的左子树，然后递归访问根结点，最后递归访问根的右子树'}",,3,"对于根树，一个十分重要的问题是要找到一些方法能系统地访问树的结点，使得每个结点恰好访问一次，这就是根树的遍历问题。由于二元树在计算机中最易处理且任意根树都可转化为二元树，因此在$k$元树中，应用得最广泛的是二元树。下面先介绍二元树的三种常用的遍历方法，然后介绍如何将任意根树转化为二元树。  
二元树的遍历算法主要有先根遍历算法、中根遍历算法和后根次序遍历算法，这三种算法都是采用递归的方式进行：  
先根遍历算法，顾名思义就是首先递归访问根结点；然后递归访问根的左子树，最后，就递归访问根的右子树；中根遍历算法，首先递归访问根的左子树；然后递归访问根结点；最后递归访问根的右子树；后根遍历算法，首先递归访问根的左子树；然后递归访问根的右子树；最后递归访问根结点。"
主合取范式,概念,"['§ 3.4 命题公式的范式', '3.4.4 主范式间的联系', '3.4.3 主合取范式', '二、主合取范式的概念', '第三章  命题演算与推理', '三、主合取范式构造举例']","{'实体类型': '概念', '定义': ['在保证合取范式基本构件完备性的前提下消除冗余析取式，构建具有表达形式唯一性的范式', '对于任意一个给定的合取范式，如果其中的每个析取式都是大项，则称该合取范式为主合取范式'], '构造方法': ['真值表构造法', '真值表法和等值演算法'], '真值表法': '在真值表中选出公式真值为假的所有行，并在选出的每一行中找到该行解释所对应的大项，将所有这些大项进行合取', '特点': ['对其合取运算形式做了进一步规范，具有更加规整的表达形式', '由大项构成'], '存在性定理': '任何一个命题公式都有与之等价的主合取范式', '应用': '判断命题公式是否为永真公式或永假公式'}",,3,合取范式由若干析取式通过合取运算组合而成，析取式是组成析取范式的基本构件。同样，造成和取范式表达形式不唯一的根本原因是其基本构件的种类太多而且存在冗余。类似于前面做法，可以对析取式的表达做进一步限定或规范，在保证合取范式基本构件完备性的前提下消除冗余析取式，由此构建具有表达形式唯一性的主合取范式。
主析取范式,概念,"['§ 3.4 命题公式的范式', '3.4.2 主析取范式', '3.4.4 主范式间的联系', '12.6.3 布尔表达式与函数', '§ 12.6 布尔代数基础', '第十二章 典型抽象代数结构', '第三章  命题演算与推理', '三、主析取范式构造举例', '一、小项的概念与性质', '二、主析取范式的概念']","{'实体类型': '概念', '定义': ['由极小项和布尔常元构成的特定布尔表达式', '由若干合取式通过析取运算组合而成，合取式是组成析取范式的基本构件', '对于任意一个给定的析取范式，如果其中的每个合取式都是小项，则称该析取范式为主析取范式'], '性质': '每个n元布尔表达式唯一等价于一个主析取范式', '特点': ['进一步限制表达形式使其满足唯一性', '基本构件的种类太多而且存在冗余，通过对合取运算的表达做进一步限定，在保证基本构件完备性的前提下消除冗余的合取式', '对其析取运算形式做了进一步规范，具有更加规整的表达形式', '由小项构成'], '真值表构造方法': '公式真值为T的指派所对应的小项的析取', '构造方法': '在真值表中选出公式为真的所有行，找到对应的小项，将所有这些小项进行析取', '应用': '判断命题公式是否为永真公式或永假公式'}",,3,"我们知道，无论是命题代数还是集合代数都可以通过相应的表达式进行计算，集合代数有集合运算表示式，命题代数有命题表达式或命题公式，事实上，可以从更加抽象的布尔代数的角度考察这些运算表达式，或者说可以将这些具体的运算表达式抽象成一般的布尔表达式研究其共同运算性质。由此得到布尔表达式的概念，具体定义如下：  
【定义12.38】设$\langle B,*,\oplus,^{-},0,1\rangle$是任意给定的一个布尔代数，则集合$ B$中的元素称为布尔常元，取值于$ B$中元素的变元称为布尔变元。  
与命题代数类似，使用归纳的方法定义布尔表达式：  
【定义12.39】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数，则 $B$上布尔表达式定义如下：  
（1）$B$中的任何一个布尔常元是布尔表达式；  
（2）$B$中的任何一个布尔变元是布尔表达式；  
（3）如果$e_{1}$和$e_{2}$是布尔表达式，则$\overline{{e_{1}}}$ ，$e_{1}*e_{2}$，$e_{1}\oplus e_{2}$也是布尔表达式；  
（4）只有有限次使用（1）、（2）和（3）所构造的符号串才是布尔表达式。  
【定义12.40】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数，$B$中含有${n}$个相异布尔变元的布尔表达式称为$\mathbf{n}$元布尔表达式，记为$f(x_{1},x_{2},\cdots,x_{n})$，其中$x_{1},x_{2},\cdots,x_{n}$是布尔变元。布尔表达式的值是指将$B$中的布尔常元作为布尔变元$x_{i}(i=1,2,\cdots,n)$的值来代替布尔表达式中相应的布尔变元，而计算出的布尔表达式的值。  
例如，表达式$f(x,y)=(a*x)\oplus({\bar{b}}\oplus y)\oplus(x\oplus{\bar{y}})$是布尔代数$\langle\lbrace0,a,b,1\rbrace,*,\oplus,^{-},0,1\rangle$上的二元布尔表达式。如果对该表达式中布尔变元$x,y$赋初值为$x=a,y=b$，则可得到：  
$$
f(a,b)=(a*a)\oplus\left({\bar{b}}\oplus b\right)\oplus\left(a\oplus{\bar{b}}\right)=a\oplus1\oplus\left(a\oplus{\bar{b}}\right)=1
$$  
【定义12.41】设$f_{1}(x_{1},x_{2},\cdots,x_{n})$和$f_{2}(x_{1},x_{2},\cdots,x_{n})$是$\langle B,*,\oplus,^{-},0,1\rangle$上的两个布尔表达式，如果对${x_{i}}$任意的赋值即$x_{i}=b_{i},b_{i}\in B,(i=1,2,\cdots,n)$均有：  
$$
f_{1}(b_{1},b_{2},\cdots,b_{n})=f_{2}(b_{1},b_{2},\cdots,b_{n})\quad\text{(12-26)}
$$  
则称这两个布尔表达式为等价或等值，记为$f_{1}(x_{1},x_{2},\cdots,x_{n})=f_{2}(x_{1},x_{2},\cdots,x_{n})\,。$  
如果要验证两个布尔表达式是等价的，一般情况下可以采取如下两种方法：一种是直接验证，另外一种是利用布尔代数的运算律进行有限次的推导。例如，对于$\langle B,*,\oplus,^{-},0,1\rangle$上两个布尔表达式：  
$$
f_{1}(x_{1},x_{2},x_{3})=x_{1}*(x_{2}\oplus x_{3}),\;\;f_{2}(x_{1},x_{2},x_{3})=(x_{1}*x_{2})\oplus(x_{1}*x_{3})
$$  
对于$\forall x_{i}=b_{i},b_{i}\in B,(i=1,2,3)$，可以直接验证$f_{1}(x_{1},x_{2},x_{3})=f_{2}(x_{1},x_{2},x_{3})$。也可以利用分配律验证其等价性。这与命题逻辑中的真值表法和演算法非常类似。  
对于布尔代数$\langle B,*,\oplus,^{-},0,1\rangle$上任意一个布尔表达式$f(x_{1},x_{2},\cdots,x_{n})$，由于运算${*,\bigoplus,^{-}}$在$B$上封闭，故对于$\langle x_{1},x_{2},\cdots,x_{n}\rangle$的任何赋值$\langle b_{1},b_{2},\cdots,b_{n}\rangle,b_{i}\in B$，有$f(b_{1},b_{2},\cdots,b_{n})\in B$。这表明$f(x_{1},x_{2},\cdots,x_{n})$确定了一个从$B^{n}$到$B$的函数。据此引入如下布尔函数的概念：  
【定义12.42】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数，$f$为一个从$B^{n}$到$B$的函数，如果它能够用$\langle B,*,\oplus,^{-},0,1\rangle$上的$n$元布尔表达式表示，则称该函数为布尔函数。  
对于任意一个给定的布尔函数，如何确定其所对应的布尔表达式呢？现在就来讨论这个问题，首先给出如下布尔表达式极小项的定义  
【定义12.43】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数，给定$n$个布尔变元$x_{1},x_{2},\cdots,x_{n}$，表达式$\widetilde{x}_{1}*\widetilde{x}_{2}*\widetilde{x}_{3}*\cdots*\widetilde{x}_{n}$称为极小项，其中$\tilde{x}_{i}$表示$ x_{i}$或$\overline{{x_{\iota}}}$。  
例如，对于两个布尔变元$x_{1},x_{2}$，其极小项为$x_{1}*x_{2}\,,\ \bar{x}_{1}*x_{2}\,,\ x_{1}*\bar{x}_{2}$和${x}_{1}*{x}_{2}$  。  
容易验证$n$个布尔变元可以构成$\ 2^{n}$个不同的极小项，分别记为$m_{0},m_{1},m_{2},\cdots,m_{2^{n}-1}$，其中下标是二进制数$a_{1}a_{2}\cdots a_{n}$对应的十进制数，其中：  
$$
a_i=\begin{cases}1,&\text{当}\widetilde{x_i}=x_i\text{时}\\0,&\text{当}\widetilde{x_i}=\bar{x_i}\text{时}\end{cases}(i=1, 2, \cdots, n)
$$  
具体可表述为：  
$m_{0}={\bar{x}}_{1}*{\bar{x}}_{2}*\cdots*{\bar{x}}_{n},\quad m_{1}={\bar{x}}_{1}*{\bar{x}}_{2}*\cdots*{\bar{x}}_{n-1}*x_{n},\ \cdots,\quad m_{n}=x_{1}*x_{2}*\cdots*x_{n}$ 不难验证极小项具有如下两个基本性质：  
（1）$m_{i}*m_{j}=0$，当$i\neq j$时；（2）$m_{0}\oplus m_{1}\oplus m_{2}\oplus\cdots\oplus m_{2^{n}-1}=1\,$。  
【定义12.44】设$<\mathrm{B},*,\oplus,\stackrel{\_}{\ },0,1>$布尔代数，称形如：
$$
(\,\alpha_{0}*m_{0}\,)\,\oplus(\alpha_{1}*m_{1})\oplus(\alpha_{2}*m_{2})\oplus\cdots\oplus(\alpha_{2^{n}-1}\oplus m_{2^{n}-1})
$$  
的布尔表达式成为主析取范式，这里$\alpha_{i}$是布尔常元，$m_{i}$是极小项$(i=1,\!2,\!\cdots,2^{n}-1)$.  
因为每个$\alpha_{i}$有$|B|$种取法，故具有$n$个布尔变元的不同主析取范式共有$|\mathrm{B}|^{2^{n}}$个，当$B=${0,1}时有$2^{2^{n}}$个。而$2^{n}$个极小项最多只能构造出$|\mathbf{B}|^{2^{n}}$个不同的主析取范式，所以一个$\mathsf{n}$ 元布尔表达式必等价于这$|\mathbf{B}|^{2^{n}}$个主析取范式之一。又由于任何两个不同的主析取范式显然是不等价的，所以一个n 元布尔表达式都唯一等价于一个主析取范式。可将${ n}$元布尔表达式化成等价的主析取范式，方法与将命题公式换成主析取范式的方法完全一致。  
对于任意给定的一个$ n$元布尔表达式，其${n}$个布尔变元的每一指派，都可确定该表达式在集合B中的一个取值，故每个布尔表达式都代表一个布尔函数。由于$n$个布尔变元的主析取范式最多只有$|\mathrm{B}|^{2^{n}}$个，故布尔表达式最多只能表示$|\mathrm{B}|^{2^{n}}$个不同函数。$B=\{0,1\}$时，从$B^{n}$到$B$的函数共有$2^{2^{n}}$个，主析取范式也有$2^{2^{n}}$个，恰好每一个主析取范式代表一个布尔函数，此时每个函数均可用布尔表达式表示。  
可用同样方法讨论极大项和主合取范式，不再赘述。
![](images/d9aea4daa121e3eccc7b12420a8fb81447c40edfd8e103d7c7a3a0401f26dc77.jpg)  
图 12-14 离散数学的知识体系  
从上述分析讨论不难看出，布尔表达式和布尔函数的运算性质与命题代数的演算基本上相同。因此，可将布尔代数看成是命题代数的一个抽象，将命题代数看成是布尔代数的一个具体实例。事实上，集合代数也是布尔代数的一个具体实例。如图12-14 所示，集合代数和命题（逻辑）代数作为一种理论基础共同支撑了离散数学结构的整个知识体系，同时两者又在抽象布尔代数的层次上实现了完美的统一。"
主范式,概念,"['§ 3.4 命题公式的范式', '第三章  命题演算与推理', '3.4.4 主范式间的联系', '3.4.2 主析取范式']","{'实体类型': '概念', '定义': '主析取范式和主合取范式的统称，满足唯一性的范式', '类型': '包括主析取范式和主合取范式', '特点': '可以利用其中一个主范式求出另一个主范式', 'name': '主范式'}",,3,"前述析取范式与合取范式虽然分别给出了命题公式的统一表达式，但这种表达形式并不唯一。例如公式$P\lor(Q\land R)$是一个析取范式，下述与其等值的公式也为其析取范式：
$$
\begin{array}{l}{P\lor(Q\land R) \Leftrightarrow (P\lor Q)\land(P\lor R)\Leftrightarrow((P\lor Q)\land P)\lor((P\lor Q)\land R)\Leftrightarrow\;\;(P\land P)\lor(P\land Q)\lor(P\land R)\lor(Q\land R)}\end{array}
$$  
范式表达形式的不唯一很容易给命题公式的研究与应用带来不便或混乱，应对其表达形式做进一步的限制使其满足唯一性，由此得到主范式的概念。主范式包括主析取范式和主合取范式两种基本类型，本小节主要讨论主析取范式，下一节介绍主合取范式。"
主范式性质,性质,"['第三章  命题演算与推理', '§ 3.4 命题公式的范式', '3.4.4 主范式间的联系']","{'实体类型': '性质', '内容': ['命题公式是永真公式当且仅当它的主析取范式包含所有的小项', '命题公式是永假公式当且仅当它的主合取范式包含所有的大项', '两个命题公式是相等的当且仅当它们所对应的主析取范式相等或主合取范式相等'], '应用': '判断命题公式的类型和等值性'}",,3,"如前所述，主析取范式和主合取范式统称为主范式。在主范式的具体构造过程中，有时求主析取范式更加方便，有时求主合取范式更为方便。此时，可以利用其中的一个主范式求出另外一个主范式。为此，我们进一步考察这两种主范式之间的内在联系。  
根据小项与大项的定义，易知二者之间存在着如下关系：  
$$
m_{i}\Leftrightarrow\neg M_{i};\quad M_{i}\Leftrightarrow\neg m_{i}\;\;(i=0,1,2,3,\dotsc,2^{n}-1)
$$  
例如，对含有两个命题变元$P,~Q$的小项与大项：  
$$
m_{0}\Leftrightarrow\neg P\land\neg Q\,,\;\;M_{0}\Leftrightarrow P\lor Q;\qquad m_{1}\Leftrightarrow\neg P\land Q\,,\;\;M_{1}=P\lor\neg Q
$$  
$$
m_{2}\Leftrightarrow P\land\lnot Q\,,\;\;M_{2}\Leftrightarrow\lnot P\lor Q;\quad m_{3}\Leftrightarrow P\land Q\,,\;\;M_{3}=\lnot P\lor\lnot Q\,
$$  
显然有：$m_{i}\Leftrightarrow\lnot M_{i};\ \ \ \ \ M_{i}\Leftrightarrow\lnot m_{i}$。因此小项与大项之间存在着一种互补关系。  
由于小项与大项之间存在互补关系，而主析取范式和主合取范式又分别由小项或大项构成，因此主析取范式和主合取范式之间存在一种互补关系。下面介绍一种利用主析取范式求主合取范式以及利用主合取范式求主析取范式的方法。  
已知公式$G$的主析取范式，求出公式$G$的主合取范式的步骤如下：  
第一步：求出$\neg G$的主析取范式，即公式$G$的主析取范式中没有出现过的小项的析取；  
第二步：$G\Leftrightarrow\neg\;\left(\neg G\right)$，即公式$G$的主合取范式。 已知公式$G$的主合取范式，求出公式$G$的主析取范式的步骤如下：  
第一步：求出$\neg G$的主合取范式，即公式$G$的主合取范式中没有出现过的大项的合取；  
第二步：$G\Leftrightarrow\neg\;\left(\neg G\right)$，即公式$G$的主析取范式。  
不难看出，主范式有如下性质：  
（1）命题公式是永真公式当且仅当它的主析取范式包含所有的小项，此时无主合取范式或者说主合取范式为空；  
（2）命题公式是永假公式当且仅当它的主合取范式包含所有的大项，此时无主析取范式或者说主析取范式为空；  
（3）两个命题公式是相等的当且仅当它们所对应的主析取范式相等，或者它们的所对应的主合取范式相等。  
利用主范式的性质，可以使用主范式判断两个命题公式是否等值。  
使用主范式的性质，还可以判断命题公式的类型：设𝐴是含有$n$个命题变项的命题公式，若$𝐴$为重言式，当且仅当𝐴的主析取范式中含全部$2^{n}$个小项；若𝐴为矛盾式，当且仅当𝐴的主析取范式中不含任何小项，此时记𝐴的主析取范式为0；若𝐴为可满足式，当且仅当𝐴的主析取范式中至少含一个小项。"
乘法原理,原理,"['第一章  集合与计数基础', '§ 1.3 有限集的基本计数技术', '1.3.1 加法原理与乘法原理']","{'实体类型': '原理', '定义': '如果一个任务可以分解为多个步骤，且每个步骤有若干种选择，则完成该任务的总方法数等于各步骤选择数的乘积', '应用': '用于计数多步骤任务的总方法数'}",,3,"加法原理和乘法原理是最基本的计数法则，其它所有计数方法或技巧都建立在这两个法则的基础之上。  
加法原理：对于任意一个有限集合$A$，如果它可以看成是多个集合的并集且这多个集合之间互不相交，即有：  
$$
A=A_{1}\cup A_{2}\cup\cdots\cup A_{n}\ \stackrel{\mathrm{~H~}}{\cdots}\ A_{i}\cap A_{j}=\varnothing\ \left(i\neq j\right)
$$  
则有：  
$$
|A|=|A_{1}|+|A_{2}|+\cdots+|A_{n}|
$$  
加法原理的另外一种说法如下：  
如果$n$ 个独立事件分别有$\cdot k_{1},k_{2},\cdots,k_{n}$种方式发生，那么这$n$ 个独立事件之一发生方式的总数$k$ 有可按下式计算：  
$$
k=k_{1}+k_{2}+\dots+k_{n}
$$  
加法原理的含义非常直观，其正确性是显然的。使用加法原理进行计数的关键在于如何将一个有限集合适当划分为若干互不相交的子集，并计算这些子集的基数。如果完成一个任务可以采用很多种不同的方法，而且每一种方法又有很多种不同的选择，那么完成该项任务的总方法数就等于这些所有选择数的总和。"
二元关系,概念,"['第五章 关系模型与理论', '§ 5.1 关系的数学模型', '5.1.2  关系的概念']","{'实体类型': '概念', '定义': '若𝑅⊆𝐴×𝐵，则称𝑅是𝐴到𝐵的一个二元关系，若𝑅⊆𝐴×𝐴，则称𝑅是𝐴上的一个二元关系', '分类': '若𝑅=∅，则称𝑅为空关系；若𝑅=𝐴×𝐵，则称𝑅为全关系'}",,3,"现在我们使用序偶与笛卡尔积这两个概念建立表示两个元素之间二元关系的数学模型。首先考察一个具体实例：假设某个班级正在上离散数学课，教室里有100 个座位和85 名学生，那么教室里有些座位有学生坐、有些座位没有学生坐，如果某个座位被某个学生坐了，则称这个座位与这个学生有关系，否则称这个座位与这个学生没有关系，现在考虑要用什么样的数学模型来表示或定义这种学生与座位之间的二元关系。  
令集合$A$表示该教室所有学生组成的集合，集合B表示该教室所有座位组成的集合，则根据乘法原理，$A$与$B$的笛卡尔集$A\times B$就表示将这85 名学生分布到100 个座位上所有可能发生的状态，$A\times B$中每个元素$\langle x,y\rangle$就表示学生$x$与座位𝑦之间可能发生的一种关系，即学生$x$坐在座位𝑦上的一种可能发生的状态。显然，一共有$85\times100=8500$可能的状态。但是，这些状态一般不会都发生，事实上，此时实际发生的只有85 个状态，即学生和座位之间实际发生关系的有且只有$A\times B$中的85 个元素。因此，可以将$A\times B$中这85 个实际发生的状态作为集合来表示这85 名学生和100 个座位之间的关系。换句话说，这85 名学生和100 个座位之间的二元关系其实就是$A$与$B$的笛卡尔集$A\times B$的某个子集。  
也可以从另外一个角度理解这个问题：将集合$𝐴$和$B$分别看成是学生维度和座位维度这两个一维空间，则$𝐴$与$B$的笛卡尔集$A\times B$就表示由这两个维度的元素组合而成的二维空间。现从𝐴中任选一位学生$x$，从$B$中任选一个座位𝑦，让学生$x$坐到座位𝑦上，由此形成一个序偶$\langle x,y\rangle$。这个序偶对应着$A\times B$所形成二维空间的一个点，所有这样的点或者序偶显然构成了这个二维空间的一个子集合。另外一方面，所有这样的点或序偶组成的集合完全枚举了学生与座位实际发生的关系，故可将学生与座位之间的二元关系就定义为所有这样的序偶组成的集合。因此，座位和学生之间的二元关系其实就是$𝐴$与$B$的笛卡尔集$A\times B$的某个子集。  
在实际生活中，还有很多类似的例子。再如机票和座位之间对号关系，若令$X$为机票的集合，Y 为座位号的集合， $R$ 表示对号关系，则对任意$x\in X$和$y\in Y$，$x$与$y$ 之间有对号和不对号两种状态。若将$R$ 看成是一些序偶的某个集合或$X$与$Y$ 的笛卡尔集$X\times Y$的某个子集，则对于任意一个序偶$\langle x,\ y\rangle$， $x$与$y$具有对号关系当且仅当$\langle x,y\rangle\in R$。因此，可将这里的对号关系定义为序偶的某个集合或$X\times Y$的某个子集合。  
通过以上分析发现，可用序偶的集合或者笛卡尔集的某个子集合来构造二元关系的数学模型。据此得到如下关于二元关系的定义：  
【定义5.6】设$𝐴$, $B$是任意给定的两个非空集合，$R$是$A\times B$的任何一个给定的子集合，则称$R$ 是一个从$𝐴$到$B$的二元关系，简称为关系。也就是说，若$R\subseteq A\times B$，则称$R$是$𝐴$到$B$的一个二元关系，若$\ R\subseteq A\times A$，则称$R$是$𝐴$上的一个二元关系。特别地，若$R=\emptyset$，则称$R$ 为空关系；若$R=A\times B$，则称$R$ 为全关系。  
【定义5.7】设$𝐴$, $B$是任意给定的两个非空集合，$R$是$𝐴$到$B$的一个二元关系，对于$A\times B$中的任意一个序偶$\langle x,y\rangle$，若$\langle x,y\rangle\in R$，这称集合$𝐴$中的元素$x$与集合$\ B$中的元素$𝑦$之间具有关系$R$；若$R$是$𝐴$上的一个二元关系且$\langle x,y\rangle\in R$，则称集合𝐴中的元素$x$与$𝑦$之间具有关系$R$。  
由上述两个定义可以看出，我们以集合为基本工具通过确定关系外延的方式给出关系概念的数学定义。这样就不必用数学符号来表示关系概念的内涵。事实上，对于有些关系，即使用自然语言也无法清楚表达其复杂的内涵。  
![](images/f21a296fae3e098faaa3900cc4615cee3ba4531b4f17c607a85fa8fb673d5d95.jpg)
图5-1 关系的五个域  
如图5-1 所示，集合$C$和$D$满足：$C=\{x|\langle x,y\rangle\in R\}$；$D=\{y|\langle x,y\rangle\in R\}$。此时称$C$为$R$ 的定义域，记为$C=\mathsf{d o m}R$；称$D$为$R$ 的值域，记为$D=ranR$；$A$ 为$R$ 的前域，$B$ 为$R$ 的后域，并称$\mathrm{fld}R=D\cup C$为$R$ 的域。一般地，我们有如下定义：  
【定义5.8】设$𝐴$, $B$是任意给定的两个非空集合，$R$是$𝐴$到$B$的一个二元关系，则有：称$A$是$R$的前域， $B$是$R$的后域；由$R$ 中所有序偶的第一元素构成的集合称为$R$ 的定义域，记作$dom𝑅$，即有$\mathrm{dom}R=\{x|\langle x,y\rangle\in R\}$；由$R$ 中所有序偶的第二元素构成的集合称为$R$ 的值域，记作$ran𝑅$，即有$\mathrm{ran}R=\{y|\langle x,y\rangle\in R\}$；称$\mathrm{fld}R=\mathrm{dom}R\cup\mathrm{ran}R$为$R$ 的域。"
二元关系模型,概念,"['第十一章  抽象代数结构通论', '§ 11.2 代数结构的运算性质']","{'实体类型': '概念', '基本性质': '自反性、反自反性、对称性、反对称性和传递性', '应用': '以这五个基本性质为标准来区分各种各样的关系'}",,2,具体的代数结构种类繁多、不胜枚举，逐个分析和探讨每个代数结构的性质显然是不可行的。因此，必须通过建立一些标准实现对这些代数结构进行分类，以便进行分门别类的考察和研究，揭示这些代数结构共性和差异。这种做法有点类似前面对二元关系模型的研究，首先总结出二元关系的五个基本性质，即自反性、反自反性、对称性、反对称性和传递性，然后以这五个基本性质为标准来区分各种各样的关系，例如，满足自反性、对称性和传递性的关系为等价关系、满足自反性、反对称性和传递性的关系为偏序关系等等。对于代数结构的研究思路也是如此，首先要考察代数结构的基本运算性质，然后以这些基本运算性质为标准考察和分析各种各样的具体代数结构。这些基本性质主要由若干二元运算律与特殊元素组成，本节比较系统地介绍些二元运算律与特殊元素。
二元真值函数,概念,"['第三章  命题演算与推理', '§ 3.3 联结词的完备集', '3.3.1  联结词的枚举']","{'实体类型': '概念', '定义': '含有两个命题变元的真值函数', '特点': '有且仅有16种不同类型'}",,3,"不难看出，每个运算联结词分别对应一个命题公式，且彼此不同的运算联结词所对应的命题公式也互不相同。尽管可以通过命题公式的定义构造出无穷多个形态各异的命题公式，但是这些命题公式中有很多是彼此等值的。因此，如果我们将彼此等值命题公式视为同一种类型并且能够计算出类型的数目，那么命题运算联结词的枚举问题便迎刃而解。  
对于任意一个含有$\cdot_{n}$个命题变量的命题公式，都可以将它看成是一个由这$n$个变量为自变量的𝑛元函数。显然，每个自变量的取值以及函数值的取值均为{真，假}或{0, 1}，故有如下𝑛元真值函数的相关定义：  
【定义3.17】假设𝐺是一个含有$\cdot_{n}$个命题变元的命题公式，则称𝐺是一个$\mathbfit{n}$元真值函数。在所有的$n$元真值函数中，将相互等值的真值函数归为一类，并从每个类中分别选取一个$_{n}$元真值函数作为该的类代表，称这种具有代表性质的真值函数为$\mathbfit{n}$元真值函项。  
显然，$n$元真值函数的种类数就是$n$元真值函项的个数。因此，下面着重考察如何对n 元真值函项进行计数和枚举。  
对于一元真值函数$G(P)$，它只含有一个命题变元𝑃。由于$P$只有$T$和$F$两种取值状态且对于每种状态，$G(P)$都只有$T$和$F$两种不同取值方式，由计数的乘法原理知，$G(P)$有且仅有有4 种不同的表现形式，如表3-13 所示。  
表3-13  一元真值函数
![](images/7e299ca38127d46167de49648c7ba3b93226e9a0d0de2bd6d7016fad80f5bc00.jpg)  
从表3-13 中可以看出，一元真值函数$G(P)$有且仅有4 种不同类型。由此可以得到如下全部四个不同的一元真值函项：  
$$
G_{1}(P)\Leftrightarrow T;\,\,\,G_{2}(P)\Leftrightarrow P;\,\,\,G_{3}(P)\Leftrightarrow\neg P\,;\,\,\,\,\,G_{4}(P)\Leftrightarrow F
$$  
由此可见，非平凡的一元逻辑运算联结词只有$\neg$运算，即 $G_{3}(P)=\neg P$  
下面考察二元真值函数$G(P,Q)$：由于每个命题变量分别取T和F两种状态，故$P$与$Q$的取值状态组合数为4。对于$\cdot P$与$Q$每一种组合状态，$G(P,Q)$都有$T$和$F$这两种取值状态，由计数的乘法原理知，$G(P,Q)$有且仅有有$2^{4}{=}16$ 种不同表现形式，如表3-14 所示。  
![](images/07f980b35eb2afa32c89cb472f39cdcc1aa211c2d1dac882499a493bebe3a0fa.jpg)  
从表3-14 中可以看出，二元真值函数$G(P,Q)$有且仅有16 种不同类型。由此可以得到如下全部16 个不同的二元真值函项：  
$G_{1}(P,Q)\Leftrightarrow P\land\lnot P;\,\,\,G_{2}(P,Q)\Leftrightarrow P\land Q;\,\,\,G_{3}(P,Q)\Leftrightarrow\lnot(P\to Q)\,;\quad G_{4}(P,Q)\Leftrightarrow P\,;$ $G_{5}(P,Q)\Leftrightarrow\neg(Q\to P);\;\;G_{6}(P,Q)\Leftrightarrow Q;\;\;G_{7}(P,Q)\Leftrightarrow\neg(P\leftrightarrow Q);\quad G_{8}(P,Q)\Leftrightarrow P\lor Q;$ $G_{9}(P,Q)\Leftrightarrow\neg(P\vee Q);\;\;G_{10}(P,Q)\Leftrightarrow P\leftrightarrow Q;\;\;G_{11}(P,Q)\Leftrightarrow\neg Q;\quad G_{12}(P,Q)\Leftrightarrow Q\rightarrow P$ $G_{13}(P,Q)\Leftrightarrow\neg P;\;\;G_{14}(P,Q)\Leftrightarrow P\rightarrow Q;\;\;G_{15}(P,Q)\Leftrightarrow\neg(P\wedge Q);\quad\;G_{16}(P,Q)\Leftrightarrow P\vee\neg P$  
由此可见，非平凡二元逻辑运算联结词一共有9 个，除了前面已学的5 个常用联结词$\neg，\wedge，\vee，\rightarrow，\leftrightarrow$之外，还有如下4 个新的运算联结词，即：$\overline{{\mathsf{V}}}\,,\,\nrightarrow\,\uparrow\,,\,\downarrow$。这4 种联结词的真值取值规则如表3-15 和表3-16 所示。  
表3-15  4 种新联结词的含义与表示
![](images/06836354c54edf7769126bc450a894d316d020c9711d3c09afa06457b363815b.jpg)  
表3-16  4 种新联结词的真值
![](images/731846b634a2ef84c0898fbd837a1e716d721d529b86c9bb6916ff3a66582dbc.jpg)  
由表3-15 和表3-16 真可知：  
$P\;{\overline{{\lor}}}\;Q\Leftrightarrow\neg(P\leftrightarrow Q)\colon\;P\nrightarrow Q\Leftrightarrow\neg(P\rightarrow Q)\colon\;P\uparrow Q\Leftrightarrow\neg(P\wedge Q)\colon\;P\downarrow Q\Leftrightarrow\neg(P\vee Q)$  
对于一般$_{n}$元真值函数$G(P_{1},P_{2},\cdots,P_{n})$，其$.n$个命题变量$P_{1},P_{2},\cdots,P_{n}$的取值状态组合数为$2^{n}$。对于每个取值状态的组合，$G(P_{1},P_{2},\cdots,P_{n})$均有$T$和$F$这两种取值。因此，$G(P_{1},P_{2},\cdots,P_{n})$有且仅有$2^{2^{n}}$种不同表现形式，即有且仅有$\cdot2^{2^{n}}$个$_{n}$元真值函项。例如，当$n=3$时，有且仅有$2^{8}{=}256$ 个真值函项，由此可得到所有非平凡三元逻辑运算联结词，具体不再赘述。"
二元算律,概念,"['第十一章  抽象代数结构通论', '§ 11.2 代数结构的运算性质', '11.2.1  二元算律']","{'实体类型': '概念', '定义': '基于单个或两个二元运算的性质', '包含': '结合律、交换律、幂等律、消去律、分配律和吸收律'}",,3,"现在我们介绍和讨论二元运算律。一共有六个二元运算律，即结合律、交换律、幂等律、消去律、分配律和吸收率。其中前面四个基于单个二元运算，后面两个基于两个二元运算。下面分别讨论这些运算律，首先讨论结合律。  
结合律是大家非常熟悉也是非常重要的一个二元运算律，实数加法与乘法运算、矩阵的加法与乘法运算、关系与函数的复合运算、整数集合上的模余运算、幂集合的交运算与并运算等都满足结合律。结合律的具体定义如下：  
【定义11.5】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由$𝐴$和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$，成立$(x*y)*z=x*(y*z)$，则称$\langle A,*\rangle$的运算 $^*$ 在 𝐴 上是可结合的，或者说 $\langle A,*\rangle$ 的运算 $^*$ 在 𝐴 上满足结合律。  
对于任意给定的集合𝐴，由于𝐴上的二元运算${\ast}$满足封闭性，故对于$\forall x,y,z\in A$，有${x\ *}$$y\in A$且$y*z\in A$。因此，$(x*y)*z$和$x*(y*z)$都是有意义的算式，如果$*$满足结合律，则表达式$x*y*z$就有一个确定的计算结果，即有：  
$$
x*y*z=(x*y)*z=x*(y*z)
$$  
如果 $*$ 不满足结合律，则有可能有 $(x*y)*z\neq x*(y*z).$ 。   此时，表达式 $x*y*z$ 的含义就有歧义。因此，只有当某个运算$*$满足结合律时，才能定义其方幂运算。在后续半群与群中元素方幂的的定义中，其元素运算的结合律起着基础性的支撑作用。  
下面考察运算的交换律，首先给出交换律的定义，具体如下：  
【定义11.6】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y\in A$，成立$x*y=y*x$，则称$\langle A,\ *\rangle$的运算$^*$在𝐴上是可交换的，或者说$\langle A,\ *\rangle$的运算$^*$在𝐴上满足交换律。  
交换律表示代数结构载体集合中的任意两个元素在运算时都可以交换次序。 例如，实数加法与乘法运算、矩阵的加法、整数集合上的模余运算、幂集合的交运算与并运算等都满足交换律。 但是，矩阵的乘法运算、关系与函数的复合运算等都不满足交换律。  
【定义11.7】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，若存在某个元素$a\in A$，满足 a$*$$a=a$，则称$a$是$\langle A,\ *\rangle$的一个幂等元。 如果𝐴中的每个元素都是$\langle A,\ *\rangle$的幂等元，则称$\langle A,\ *\rangle$的运算$*$在𝐴上满足幂等律。  
从上述定义可以看出，所谓幂等元，就是该元素与其自身运算之后仍然等于其自身。例如，对于某个幂集合上的交运算和并运算，幂集合中每个元素显然都是幂等元，因此，幂集合上的交运算和并运算均满足幂等性。但是，对于整数上的加法运算，除了整数0 之外，其余整数显然都不是幂等元，因此,整数上的加法运算不满足幂等律。  
【定义11.8】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$：  
（1）若$z*y=z*x$，有$y=x$，则称运算$*$在𝐴上是可左消去的，或者说运算$∗$在𝐴上满足左消去律，并称$\cdot z$是$A$中关于运算$^*$的左可消去元；  
（2）若$y*z=x*z$，有$y=x$，则称运算$^*$在𝐴上是可右消去的，或者说运算$^*$在𝐴上满足右消去律，并称𝑧是$A$中关于运算$^*$的右可消去元。  
（3）若上述两种情况均满足，则称运算$*$在𝐴上满足消去律，并称$z$是𝐴中关于运算$*$的可消去元。  
下面介绍基于两个二元运算的运算律，即分配律和吸收律。首先给出分配律的定义：  
【定义11.9】假设𝐴是任意给定的一个非空集合，$^*$和$\Delta$均为𝐴上的二元运算，在由$𝐴$、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y,z\in A$：  
若有$x*(y\Delta z)=(x*y)\Delta(x*z)$，则称运算$*$对$\Delta$在𝐴上满足左分配律。  
若有$(y\Delta z)*x=(y*x)\Delta(z*x)$，则称运算$*$对$\Delta$在𝐴上满足右分配律。  
若运算$*$对$\Delta$在𝐴上同时满足左右分配律，则称运算$*$对$\Delta$在𝐴上满足分配律。  
例如，实数集合上的普通乘法对加法满足分配律，$M_{n}(R)$上的矩阵乘法对加法满足分配律，幂集$P(B)$上的集合交运算对并运算满足分配律，并且并运算对交运算也满足分配律。  
将上述关于集合的吸收律推广到一般运算对象和一般运算，得到一个新的运算律，即吸收律。其具体定义如下：  
【定义11.10】设𝐴是任意给定的一个非空集合，$*$和$\Delta$均为为𝐴上二元运算，在由𝐴、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y\in A$，成立：  
$$
x*(y\Delta z)=x,\;\;x\Delta(y*z)=x
$$  
则称 $*$ 和 $\Delta$ 在 A  上满足吸收律。"
二元运算,概念,"['第十一章  抽象代数结构通论', '§ 11.1 代数结构的基本概念', '11.1.2 运算的定义与表示']","{'实体类型': '概念', '定义': '从$A\\\\times B$到$C$上的二元映射$f$，称为一个从$A\\\\times B$到$C$的二元运算', '特点': '当$A=B=C$时，称$f：A\\\\times A\\\\to A$为$𝑨$上的二元运算'}",,3,"所以代数结构，本质上就是由一个运算对象的集合和若干运算构成的系统。要学好代数结构，首先必须掌握运算的概念和性质。  
对于运算这个概念，其实我们并不陌生。例如实数的加、减、乘、除等二元运算。这些二元运算通过某种机制由两个运算对象构造出一个确定的新的对象，或者说按照某种既定的规则根据两个输入得到一个唯一确定的输出。因此，二元运算可以看成是一种特殊的二元映射或二元函数，具体定义如下：  
【定义11.1】假设$𝐴,B,C$任意给定的三个非空集合，则从$A\times B$到$C$上的二元映射$f$，称为一个从$A\times B$到$C$的二元运算，即有$f：A\times B\to C$。当$A=B=C$时，称$f：A\times A\to A$为$𝑨$上的二元运算。  
【定义11.2】设$A_{1},A_{2},\cdots,A_{n},A$均为一个非空集合，从集合$A_{1}\times A_{2}\times\cdots\times A_{n}$到集合$A$的映射$f$称为一个从集合$A_{1}\times A_{2}\times\cdots\times A_{n}$到集合𝐴的$\pmb{n}$元运算，即有：$f$：$A_{1}\times A_{2}\times\cdots\times$$A_{n}\to A$。若有$\  A_{1}=A_{2}=\cdots=A_{n}=A$，则称$f$：$A\times A\times\cdots\times A\to A$为集合𝑨上的一个$n$元运算。当$n=1$时，称$f$：$A\rightarrow A$为集合𝑨上的一元运算。  
从上述定义可以看出，多元运算其实就是一类特殊的多元函数。 例如，三元函数：  
$$
*\!:R^{3}\rightarrow R\,,\,\,\,*\left(x,y,z\right)=z\,,\,\,\,\forall x,y,z\in R
$$  
就是一个三元运算，该运算表示三维空间上的点$(x,y,z)$到$z$轴上的投影。  
目前，多元运算在关系数据库的多元关系演算等领域具有重要的应用价值。 不过，多元运算是对二元关系的自然推广，与二元关系没有本质上的差异。  因此，我们主要考察一元运算和二元运算的概念与性质。  例如，整数集合$Z$ 上求相反数运算、幂集合上的求补运算、实矩阵集合上的求矩阵转置运算、命题集合中的非运算等等，都是一元运算。  与二元运算的情形完全相同，可以使用运算符或运算表表示一元运算，这里不再赘述。"
二分图,概念,"['10.2.1  二分图的概念与性质', '第十章  特殊图模型与算法', '一、点着色与边着色', '10.2.3 最大匹配判定与构造', '三、结点着色算法', '10.3.3 着色问题与算法', '10.3.2 平面图的对偶图', '10.2.2 完备匹配与最大匹配', '§ 10.2 二分图与匹配问题', '二、平面图的着色问题']","{'实体类型': '概念', '应用': ['解决资源分配与匹配问题', '表示和处理两类对象之间的联系，如学生选课问题、工作任务安排问题、恋爱婚姻问题', '舞伴配对问题'], '相关理论': '二分图及相关理论', '定义': ['一种特殊图模型，所有结点被划分为两种基本类型，同一类型的结点之间无边联结，图中每条边仅联结分属不同类型的结点', '设G=⟨V,E⟩是任意给定的一个无向图，若存在结点集V的两个子集X,Y，满足X∩Y=∅且X∪Y=V，图G中任何一条边的两个端点均分别属于X和Y，则称G是一个二分图或偶图，X和Y称为互补结点子集，记为G=⟨X,E,Y⟩', '由两个互不相交的结点集合和连接这两个集合的边组成的图', '由两个互不相交的顶点集构成的图，其中一个顶点集中的每个顶点只与另一个顶点集中的顶点相连', '具有结点和边，结点可分成两个互不相交的集合，使得每条边的两个端点分别属于不同集合的图', '一种特殊图，其顶点集可以划分为两个互不相交的子集，使得每条边的两个端点分别属于不同的子集', '图的顶点集可以划分为两个互不相交的子集，使得每条边的两个端点分别属于不同的子集'], '特点': '没有两个端点同属X或Y的边，故二分图没有自回路'}",,1,"如前所述，图模型及其理论是数学家欧拉为解决哥尼斯堡七桥遍历问题而创立。事实上，图模型作为一种由结点和边组成的离散结构是一种非常强大的离散建模工具，除了能够解决哥尼斯堡七桥遍历问题之外，还可解决很多其它实际问题。例如，旅游的路径规划问题、资源分配与匹配问题、图的着色与并行流程的设计问题、最小费用流问题等等。针对不同的问题，通常需要设计出特定的图模型进行建模与求解。例如，解决哥尼斯堡七桥遍历问题需要使用欧拉图及相关理论、解决旅游的路径规划问题需要哈密顿图及相关理论、解决资源分配与匹配问题需要二分图及相关理论、解决图的着色与并行流程的设计问题需要平面图的相关理论、解决最小费用流问题需要网络流图的相关理论等等。由此产生很多种具有特殊结构和性质的图模型，每种特殊图模型都能针对性地有效地解决某一类或某几类特定问题。因此，要想高效合理地使用图模型实现对实际问题的建模与求解，除了掌握前述图模型的一般理论及算法之外，还需要进一步掌握多种特殊图模型的相关理论及算法。  
本章介绍几种重要的特殊图模型及相关算法，包括欧拉图模型的基本理论及边的遍历算法、哈密顿图的基本理论及结点的近似遍历算法、二分图模型的基本理论及匈牙利匹配构造算法、平面图的基本理论及着色算法、网络流图的基本理论及最大流算法，并结合具体实例分析和讨论这些特殊图模型的应用方法。"
二分图判定定理,定理,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.2.1  二分图的概念与性质']","{'实体类型': '定理', '条件': '设G=⟨V,E⟩是任意给定的一个无向图', '结论': 'G是一个二分图当且仅当G中所有回路的长度均为偶数'}",,3,"在给出二分图模型的概念之前，先考察这样一个问题：假设某单位有文秘、程序员、推销员和清洁工这四个空缺的岗位需要招聘员工，现在有甲、乙、丙三人前来应聘。其中甲能够胜任程序员、文秘、推销员岗位，乙能胜任程序员、推销员岗位，丙只能胜任清洁工岗位。则可用如图10-25 所示的图模型表示岗位和应聘者之间的关系，其中结点$A,B,C,D$分别表示程序员、文秘、推销员和清洁工这四个岗位。  
![图10-25 二分图模型  ](images/8864c10116e26697fbf05b1f18e2401c9842cde25d081b310532369c11ee7ce7.jpg)  
不难看出，可将如图10-25 所示图模型的所有结点划分为应聘者和岗位这两个不同的集合，属于同一个集合的结点之间无边联结，图中所有边的两个端点均分属两个不同的集合。具有这种特征的图模型就是二分图，其具体定义如下：  
【定义10.3】设$G=\langle V,E\rangle$是任意给定的一个无向图，若存在结点集𝑉的两个子集$X,Y$，满足$X\cap Y=\varnothing$且$X\cup Y=V$，图$G$中任何一条边的两个端点均分别属于 $X$和$𝑌$，则称$G$是一个二分图或偶图,$X$和$𝑌$称为互补结点子集，记为$G=\langle X,E,Y\rangle$。对于二分图$G=\langle X,E,Y\rangle$，若$ X$中每个结点与𝑌中每个结点都有且仅有一边联结，则称$G$为完全二分图或完全偶图，记作$K_{i,j}$，其中$|X|=i$，$|Y|=j$。平凡图和零图可看成是特殊二分图。  
![图10-26 完全二分图模型  ](images/ae1a646a89e375aa1b8c1c870d1cd9274cf83b1ce9ba6ad8326f6e1c44eef5ab.jpg)  
由定义10.3 可知，在二分图$G=\langle X,E,Y\rangle$中，没有两个端点同属𝑋或𝑌的边，故二分图没有自回路。如图10-25 表示两个为完全二分图：$K_{2,3}$，$K_{3,6}$。  
![（a）图𝐺                         （b）图$H$【例题10.8】如图10-27 所示的图$G$和$H$是否为二分图。  ](images/b80fa71a1e3c63a74ff7d12be601081cc8b875225af5fcb246ba93539d56929b.jpg)  
由于同构的图模型尽管结构相同但表现形式多种多样，故有时很难直接使用定义实现对二分图的判定。下面给出关于二分图判定的充要条件：  
【定理10.7】设$G=\langle V,E\rangle$是任意给定的一个无向图，则$G$是一个二分图当且仅当$G$中所有回路的长度均为偶数。"
互素,概念,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.2 整数的因数分解', '二、互素的概念与性质']","{'实体类型': '概念', '定义': '如果两个整数的最大公因数为1，则称这两个整数互素', '重要性': '整数理论中一个非常重要的基本概念', '相关性质': '整数的很多性质都与互素的概念有关'}",,4,"从整除的角度看，两个整数的公因数表达的是这两个整数共性成分。如果两个整数的最大公因数为1，则表明这两个整数除1 之外没有任何额外的共性成分。因此，从结构上看，这两个整数之间具有很强的独立性。这种很强的独立性我们称之为互素。互素是整数理论中一个非常重要的基本概念，整数的很多性质都与互素的概念有关，其具体定义如下：  
【定义2.7】假设$a_{1},a_{2},\cdots,a_{k}$是$k$个不全为零的整数，如果有$\operatorname*{gcd}(a_{1},a_{2},\cdots,a_{k})=1$，则称这$k$ 个整数$a_{1},a_{2},\cdots,a_{k}$为互素；如果$a_{1},a_{2},\cdots,a_{k}$中任意两个整数的最大公因数均为1，则称这$k$ 个整数$a_{1},a_{2},\cdots,a_{k}$为两两互素。  
$a_{1},a_{2},\cdots,a_{k}$互素与$a_{1},a_{2},\cdots,a_{k}$两两互素是两个不同的概念，在实际使用过程中应注意加以区分，避免混淆。显然，由$a_{1},a_{2},\cdots,a_{k}$两两互素可以推出$a_{1},a_{2},\cdots,a_{k}$互素，反之不然。例如，$\operatorname*{gcd}(3,6,9,10)=1$，此时这4 个整数仅仅为互素的关系，因为其中的3, 6, 9的最大公因数并不为1，所以不符合两两互素。  
【定理2.8】设$a$，$b$ 是任意两个整数，若$\operatorname*{gcd}(a,b)=a s+b t$，则$s$ 与$t$是互素的。  
【定理2.9】如果整数$a$ 与整数$b_{1},b_{2},\cdots,b_{n}$中的每一个都互质，那么$a$ 与乘积$b_{1}b_{2}\cdots b_{n}$也互质。  
【定理2.10】对于任意的整数$a$，$b$，$c$，下面结论成立：  
（1）若$b|a c$且$\operatorname*{gcd}(a,b)=1$，则有$b|c$；  
（2）若$b|c$且$a|c$，则有$a b|c$。  
【定理 2.11 】若 $\operatorname*{gcd}(a,b)=1$ ，则 $\operatorname*{gcd}(a,b k)=\operatorname*{gcd}(a,k)\,.$"
五色定理,定理,"['§ 10.2 二分图与匹配问题', '二、平面图的着色问题', '10.3.3 着色问题与算法', '第十章  特殊图模型与算法']","{'实体类型': '定理', '内容': '任何平面图可以用不超过五种颜色进行面着色，且任意连通简单平面图的点色数不超过5', 'name': '五色定理'}",,3,图的着色问题起源对平面图（地图）四色猜想，即至多用四种不同颜色给地图着色，就可使相互接壤的国家通过不同的颜色进行区分。四色猜想虽然针对平面图的面着色，但图的着色问题并不局限于平面图。事实上，对于一般的非平面图，可以研究其结点着色和边着色问题，对于平面图，可以研究结点着色、边着色和面着色问题。由于边着色和面着色问题可以通过适当方式转化为结点着色问题，故一般仅讨论结点着色算法。本节讨论图的着色问题与算法，主要包括点着色与边着色、面着色与五色定理、结点着色算法。
交图,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.2.1 图的基本运算', '一、图的集合运算']","{'实体类型': '概念', '定义': '两个图模型的顶点集合和边集合的交集组成的图'}",,4,"图模型作为一种特殊的集合具有并、交、差、补、环和等集合运算，下面分别介绍这些集合运算及其相关性质。 首先给出两个图不交、不重的定义：  
【定义8.10】假设 $G_{1}=\langle V_{1},E_{1}\rangle$和 $G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，则有：  
（1）如果 $V_{1}\cap V_{2}=\varnothing$，则称 $G_{1}$ 与 $G_{2}$ 是不交的；  
（2）如果 $E_{1}\cap E_{2}=\varnothing$ ，则称 $G_{1}$ 与 $G_{2}$ 是边不交的，或者说是不重的。  
显然，对于任意两个不交的图它们必然是不重的，反之不然。  
下面给出图模型基本集合运算的定义：  
【定义 8.11 】假设   $G_{1}=\langle V_{1},E_{1}\rangle$ 和   $G_{2}=\langle V_{2},E_{2}\rangle$ 分别为不含孤立结点的图模型（它们 同为无向图或者同为有向图）。  
（1）令图 $G_{1}\cup G_{2}=\left\langle V,E\right\rangle$，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的并图，其中：$V=V_{1}\cup V_{2},\;\;E=E_{1}\cup E_{2}$  
当 $G_{1}$ 与 $G_{2}$ 不存在公共的边时，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$  的不重并。  
（2）设图 $G_{1}\cap G_{2}=\langle V,E\rangle$，称 $G_{1}\cap G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的交图，其中：$V=V_{1}\cap V_{2},\,\,\,E=E_{1}\cap E_{2}$  
$G_{1}\cap G_{2}$是由 $G_{1},G_{2}$ 中所有公共的边组成的图。  
（3）设图 $G_{1}-G_{2}=\langle V,E\rangle$，称 $G_{1}-G_{2}$ 为 $G_{1}$ 减 $G_{2}$ 的差图，其中：
$$
V=V_{1},\,\,\,E=E_{1}-E_{2}
$$  
$G_{1}-G_{2}$ 是在图 $G_{1}$ 中减去属于 $G_{2}$ 的边后所剩余的部分组成的图。  
（4）环和图 $G_{1}\oplus G_{2}$ 是由 $G_{1}$ 与 $G_{2}$ 的并图减去 $G_{1}$ 与 $G_{2}$ 的交图后得到的图。
$$
G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})
$$  
从上述定义可以看出，图模型的并、交、差、环和等集合运算其实就是普通集合运算的延伸。 需要注意的是：  
（1）若   $G_{1}=G_{2}$   ，则 $G_{1}\cup G_{2}=G_{1}\cap G_{2}=G_{1}(G_{2}),~~~~~G_{1}-G_{2}=G_{2}-G_{1}=\varnothing\,。$  
（2）$G_{1}$ 与 $G_{2}$ 不重时，$G_{1}\cap G_{2}=\varnothing$，$G_{1}-G_{2}=G_{1}$，  $G_2-G_1=G_2, G_1\oplus G_2=G_1\cup $$G_{2}$。  
（3）两个图的环和可用并、差、交给出，$G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})\,.$"
交换律,性质,"['第十一章  抽象代数结构通论', '§ 11.2 代数结构的运算性质', '11.2.1  二元算律']","{'实体类型': '性质', '定义': '在二元代数结构中，对于任意元素x,y，成立x*y=y*x', '应用': '实数加法与乘法运算、矩阵的加法、整数集合上的模余运算、幂集合的交运算与并运算', '反例': '矩阵的乘法运算、关系与函数的复合运算'}",,3,"现在我们介绍和讨论二元运算律。一共有六个二元运算律，即结合律、交换律、幂等律、消去律、分配律和吸收率。其中前面四个基于单个二元运算，后面两个基于两个二元运算。下面分别讨论这些运算律，首先讨论结合律。  
结合律是大家非常熟悉也是非常重要的一个二元运算律，实数加法与乘法运算、矩阵的加法与乘法运算、关系与函数的复合运算、整数集合上的模余运算、幂集合的交运算与并运算等都满足结合律。结合律的具体定义如下：  
【定义11.5】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由$𝐴$和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$，成立$(x*y)*z=x*(y*z)$，则称$\langle A,*\rangle$的运算 $^*$ 在 𝐴 上是可结合的，或者说 $\langle A,*\rangle$ 的运算 $^*$ 在 𝐴 上满足结合律。  
对于任意给定的集合𝐴，由于𝐴上的二元运算${\ast}$满足封闭性，故对于$\forall x,y,z\in A$，有${x\ *}$$y\in A$且$y*z\in A$。因此，$(x*y)*z$和$x*(y*z)$都是有意义的算式，如果$*$满足结合律，则表达式$x*y*z$就有一个确定的计算结果，即有：  
$$
x*y*z=(x*y)*z=x*(y*z)
$$  
如果 $*$ 不满足结合律，则有可能有 $(x*y)*z\neq x*(y*z).$ 。   此时，表达式 $x*y*z$ 的含义就有歧义。因此，只有当某个运算$*$满足结合律时，才能定义其方幂运算。在后续半群与群中元素方幂的的定义中，其元素运算的结合律起着基础性的支撑作用。  
下面考察运算的交换律，首先给出交换律的定义，具体如下：  
【定义11.6】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y\in A$，成立$x*y=y*x$，则称$\langle A,\ *\rangle$的运算$^*$在𝐴上是可交换的，或者说$\langle A,\ *\rangle$的运算$^*$在𝐴上满足交换律。  
交换律表示代数结构载体集合中的任意两个元素在运算时都可以交换次序。 例如，实数加法与乘法运算、矩阵的加法、整数集合上的模余运算、幂集合的交运算与并运算等都满足交换律。 但是，矩阵的乘法运算、关系与函数的复合运算等都不满足交换律。  
【定义11.7】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，若存在某个元素$a\in A$，满足 a$*$$a=a$，则称$a$是$\langle A,\ *\rangle$的一个幂等元。 如果𝐴中的每个元素都是$\langle A,\ *\rangle$的幂等元，则称$\langle A,\ *\rangle$的运算$*$在𝐴上满足幂等律。  
从上述定义可以看出，所谓幂等元，就是该元素与其自身运算之后仍然等于其自身。例如，对于某个幂集合上的交运算和并运算，幂集合中每个元素显然都是幂等元，因此，幂集合上的交运算和并运算均满足幂等性。但是，对于整数上的加法运算，除了整数0 之外，其余整数显然都不是幂等元，因此,整数上的加法运算不满足幂等律。  
【定义11.8】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$：  
（1）若$z*y=z*x$，有$y=x$，则称运算$*$在𝐴上是可左消去的，或者说运算$∗$在𝐴上满足左消去律，并称$\cdot z$是$A$中关于运算$^*$的左可消去元；  
（2）若$y*z=x*z$，有$y=x$，则称运算$^*$在𝐴上是可右消去的，或者说运算$^*$在𝐴上满足右消去律，并称𝑧是$A$中关于运算$^*$的右可消去元。  
（3）若上述两种情况均满足，则称运算$*$在𝐴上满足消去律，并称$z$是𝐴中关于运算$*$的可消去元。  
下面介绍基于两个二元运算的运算律，即分配律和吸收律。首先给出分配律的定义：  
【定义11.9】假设𝐴是任意给定的一个非空集合，$^*$和$\Delta$均为𝐴上的二元运算，在由$𝐴$、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y,z\in A$：  
若有$x*(y\Delta z)=(x*y)\Delta(x*z)$，则称运算$*$对$\Delta$在𝐴上满足左分配律。  
若有$(y\Delta z)*x=(y*x)\Delta(z*x)$，则称运算$*$对$\Delta$在𝐴上满足右分配律。  
若运算$*$对$\Delta$在𝐴上同时满足左右分配律，则称运算$*$对$\Delta$在𝐴上满足分配律。  
例如，实数集合上的普通乘法对加法满足分配律，$M_{n}(R)$上的矩阵乘法对加法满足分配律，幂集$P(B)$上的集合交运算对并运算满足分配律，并且并运算对交运算也满足分配律。  
将上述关于集合的吸收律推广到一般运算对象和一般运算，得到一个新的运算律，即吸收律。其具体定义如下：  
【定义11.10】设𝐴是任意给定的一个非空集合，$*$和$\Delta$均为为𝐴上二元运算，在由𝐴、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y\in A$，成立：  
$$
x*(y\Delta z)=x,\;\;x\Delta(y*z)=x
$$  
则称 $*$ 和 $\Delta$ 在 A  上满足吸收律。"
交换环,概念,"['第十二章 典型抽象代数结构', '§ 12.4 环和域的基本知识', '12.4.1  环的概念与性质']","{'实体类型': '概念', '定义': '环结构中乘法是交换半群的环'}",,3,"我们知道，整数集合𝑍上具有加法$+$和乘法$\times$这两种运算，并且$\langle Z,+\rangle$是一个交换群、$\langle Z,\times\rangle$是一个半群，并且乘法对加法满足左、右分配律，即有：  
$$
a\times(b+c)=a\times b+a\times c;\ (b+c)\times a=b\times a+c a\times
$$  
由此可见，整数运算系统主要由两个运算子系统构成，即由一个基于加法运算的交换群和一个基于乘法运算的半群构成，并且乘法对加法满足分配律。  
将整数运算系统的上述性质进行抽象，就得到如果环代数结构的定义：  
【定义12.22】如果$\langle G,+,\times\rangle$是具有两个二元运算的代数系统，且满足：（1）$\langle G,+\rangle$是交换群；（2）$\langle G,\times\rangle$是半群；（3）$G$中的$\times$对$+$满足分配律。则称$\langle G,+,\times\rangle$是环代数结构或环代数系统，通常简称为环结构、环系统或环，并称$+$和$\times$分别为环中的加法和乘法。  
由上述定义可知，环结构由加法交换群和乘法半群这两个子结构组成，且满足乘法对加法的分配律。显然，代数系统$\langle Z,+,\times\rangle$就是一个环结构。  
此外，$\langle Q,+,\times\rangle,~\langle R,+,\times\rangle,~\langle C,+,\times\rangle$也都是环结构，其中$Q$是有理数集，$R$是实数集，$C$是复数集，分别称作整数环，有理数环，实数环和复数环。  
可根据构成环的群子结构或半群子结构的特点，对环结构做进一步的分类：  
【定义12.23】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果$\langle G,\times\rangle$是一个含幺半群，则称$\langle G,+,\times\rangle$是一个含幺环，如果$\langle G,\times\rangle$是一个交换半群，则称$\langle G,+,\times\rangle$是一个交换环，如果$\langle G,\times\rangle$是一个含幺交换半群，则称$\langle G,+,\times\rangle$是一个含幺交换环。  
为了叙述上的方便，通常将环中加法的单位元记作0，而将环中元素$x$关于加法的逆元称作$x$的负元，记作$-x$。如果环中乘法有单位元，就把这个单位元记作1，而将$ x$关于乘法的逆元（若存在的话）称为$x$的逆元，记作$:\!x^{-1}$。类似地，可用$x-y,$表示$ x+(-y)$，分别用$n x$和$x^{n}$表示$x$的加法和乘法$ n$次幂，即有：  
$$
n x=\underbrace{x+x+\cdots+x}_{n^{}个};\,\,\,x^{n}=\underbrace{x x\cdots x}_{n^{}个}
$$  
下面讨论环的基本性质。由环的定义可知，环中加法满足交换律、结合律，有单位元0  ，  
每个元素都有负元，环中乘法适合结合律，乘法对加法适合分配律。除此之外，我们进一步考察环的其它一些性质。首先考察环结构中加法逆元的性质：  
【定理12.28】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a,b\in G$，有：  
$$
-(a\times b)=a\times(-b)=(-a)\times b\quad\text{(12-20)}
$$  
下面考察环结构中加法单位元的性质：  
【定理12.29】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a\in G$，有：  
$$
a\times0=0\times a=0\quad\text{(12-21)}
$$  
上述定理12.29 表明，环结构中加法运算的单位元是乘法运算的零元，并且环中任二元素相乘，若其中至少有一个为零元，则乘积必为零元。但反之不然，因为在环中，两个非零元的乘积可能为零元，由此引出如下环结构中零因子的概念：  
【定义12.24】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果存在$G$中两个非零元素满足$a\cdot b=0$ ，称该环为含零因子环，元素 $a$ 和 $b$ 是其零因子，否则称该环为无零因子环。  
【定理12.30】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则$\langle G,+,\times\rangle$是无零因子环当且仅当于$\langle G,\times\rangle$满足消去律。  
由于环是由群和半群这两个子结构构成，故与群结构类似，环结构也存在子环、环同态的相关概念和理论。事实上，子环和环同态的概念和性质完全可以使用与群类似的思路进行讨论，这里不再赘述，读者可自行查阅环结构的相关资料深入学习。"
交换群,概念,"['§ 12.1 半群的概念与性质', '§ 12.2 群结构的基本知识', '12.2.1 群的基本概念', '第十二章 典型抽象代数结构']","{'实体类型': '概念', '定义': '一种满足交换律的特殊群；如果运算*满足交换律，即对于∀x,y∈G，有x*y=y*x，则称群⟨G,*⟩是一个交换群或阿贝尔群', '特点': '只含一个二元运算', 'name': '交换群'}",,2,"与群相关的抽象代数结构有很多个，其共同特征是只含一个二元运算，具体包括广群、半群、含幺半群、群、交换群等。如图12-1 所示，这些抽象代数结构按照由一般到特殊的次序逐步递进。其中：广群是最具一般性，只需满足运算的封闭性即可，其实就是一般的只含一个二元运算的代数结构或代数系统；半群则比广群稍微特殊一些，即在广群的基础上增加一个满足结合律的限制；含幺半群则是在半群的基础上再增加存在单位元的限制；群则是在含幺半群的基础上再增加存在逆元的限制，即要求半群不仅含有单位元，而且还必须保证载体集合中每个元素都必须含有逆元；交换群则是一种满足交换律的特殊群。  
![](images/c6e03e109e469ca83f4980264e0b87779198ee1bcaf3a206ea39fe5f280b87e9.jpg)
图12-1 与群相关的抽象代数结构  
我们将按照图12-1-1 所示次序展开讨论，其中广群作为最一般的代数结构在前面第十一章已做介绍。因此，本节着重介绍半群的基本理论，主要包括半群、含幺半群、元素方幂、循环半群的基本概念与性质。"
交通灯相位问题,问题,"['第八章  图的基本理论与算法', '§ 8.5 图模型的应用', '8.5.1 交通灯相位问题']","{'实体类型': '问题', '定义': '为了避免不同方向交通流之间的相互冲突，通过在时间上给各个方向交通流分配相应的通行权', '特点': '信号相位是根据交叉口通行权在一个周期内的更迭来划分的', '条件': '一个路口采用几相位的信号控制应由该路口的实际交通流状况决定', '结论': '合理地设置交通灯相位数目对于改善道路交通状况有重要意义'}",,3,"现实生活中，为了避免不同方向交通流之间的相互冲突，可以通过在时间上给各个方向交通流分配相应的通行权。例如，为了放行东西向的直行车流且同时避免南北向的直行、左转车流与其发生冲突，可以通过启亮东西向的绿色直行箭头灯将路口的通行权赋予东西向的直行车流，启亮南北向的红灯消除南北向直行、左转车流对东西向直行车流通行的影响。  
对于一组互不冲突的交通流同时获得通行权所对应的信号显示状态，我们将其称之为信号相位，简称为相位。可以看出，交通灯信号相位是根据交叉口通行权在一个周期内的更迭来划分的。一个红绿灯信号控制方案在一个周期内有几个信号相位。图8-65 所示就是一个采用4 相位信号控制的控制方案。一个路口采用几相位的信号控制应由该路口的实际交通流状况决定，十字路口通常采用2 到4 个相位。如果相位数设计的太少，则不能有效的分配好路口通行权，路口很容易出现交通混乱，交通安全下降；如果相位数设计的太多，虽然路口的交通次序与安全性得到了改善，但由于相位之间进行转换时都会损失一部分通行时间，过多的相位数会导致路口的通行能力下降，延长司机在路口的等待时间。  
因此合理地设置交通灯相位数目，对于改善道路交通状况，有着非常重要的现实意义。那么如何去设置交通灯相位数目呢？其实交通灯相位问题，可以看成是图的着色问题，因而运用图论相关知识，可以有效地解决这一问题。关于图的着色问题，本书第十章-特殊图部分将会详细介绍，本小节不在赘述。另外，图的着色问题在实际生活中应用十分广泛，比如空调管道设计问题、考试安排问题、排课表问题等，有兴趣的读者可以作进一步了解。  
![图8-65  交通灯相位 ](images/0ec4bd3e4d43385c2caf5ee668ee55d5cf1941926e063b0c9b7c9bdaa556d346.jpg)"
交错道,概念,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.2.3 最大匹配判定与构造']","{'实体类型': '概念', '定义': '从某个结点到另一个结点的一条通路，该通路由属于匹配和不属于匹配的边交替构成'}",,3,"对于任意给定的一个二分图，首先讨论如何判断该图中某个给定的匹配是否为最大匹配。为此，引入交错道和可增广道的概念，具体如下：  
【定义10.5】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图， $M$是图$G$的某个匹配，若从𝐺中的某个结点到另一个结点之间存在一条通路，且该通路由属于$\cdot M$和不属于$M$的边交替构成，则称此通路为 𝑴 交错道。若 $M$ 交错道的两端点均为 $M$ 非饱和点，则称其为 𝑴 可增广道。  
例如，对于图10-35（a）所示匹配，$P=y_{1}x_{2}y_{5}x_{4}y_{3}x_{1}$是一条交错道，对于图10-35（b）所示匹配，$P=y_{1}x_{2}y_{5}x_{4}y_{3}x_{1}$则是一条可增广道，具体见图10-35（b）的粗线部分。  
![图10-35  交错道与可增广道  ](images/f5e335487e12a671cc013f6ede9981700aa6193018e616b34157cc9869d086b6.jpg)  
在1957 年，法国著名数学家贝尔格给出了判定某个匹配是最大匹配的充分必要条件。这就是著名的贝尔格定理，具体如下：  
【定理10.10】（贝尔格定理）设$G=\langle X,E,Y\rangle$是任意给定的一个二分图， 𝑀是图𝐺的某个匹配，则$M$是图$G$最大匹配的充要条件是$G$中不存在$M$可增广道。  
在1965 年，匈牙利的著名数学家埃德蒙兹基于贝尔格定理提出构造二分图最大匹配的著名算法，为纪念他的祖国，将该算法命名为匈牙利算法。算法基本思路如下：  
假设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，如果对于该图的某个匹配𝑀，结点集合𝑋的每个结点都是饱和结点，则该匹配就是最大匹配。否则，任取𝑋中的某个非饱和结点为起点做匹配$M$的交错道。此时，如果该交错道最后一个结点是饱和结点，如图10-36 中$P_{1}$所示，则匹配$M$就是最大匹配。否则，如果该交错道最后一个结点也是一个非饱和结点，则得到一条可增广道，如图10-36 中$P_{2}$所示。  
![图 10-36   对可增广道的增广 ](images/18f50be9390d6af7d21020996653e950e5f8bda427f6af3f0640cd631a139c62.jpg)  
不难看出，该交错道$P_{2}$中不属于$M$的所有边数比属于属于$M$的边数多一个，而且交错道中不属于$M$的所有边数也是互不相邻的，故可由这些边构成一个新的匹配$M^{*}$。由于${\mathbf{\nabla}}^{*}$的边数比$M$的边数多一个，故称$M^{*}$是对$M$的一个增广。继续上述过程，直到图中没有可增广道路为止，此时的匹配就是所求的最大匹配。  
从上述讨论不难发现，匈牙利算法的核心思想就是首先在当前匹配基础上寻找可增广道，找到可增广道后，就通过对该可增广道上所有边的匹配属性取反，即对可增广道上所有边的集合$ E(P)$与匹配$M$做集合的对称差运算$\oplus$，由此得到新的集合就是一个规模更大的新匹配，然后在这个新匹配的基础上继续寻找新可增广道，如此下去，直到没有可增广道路为止。  
对于任意给定的二分图$G=\langle X,E,Y\rangle$，匈牙利算法的具体计算流程如下：  
（1）任给初始匹配$M$；  
（2）若𝑋中任一结点均饱和，则$M$即为所求，算法结束，否则转（3）；  
（3）在𝑋中找到一非$M$饱和点$x$，置$S=\{x\}$，$T=\varnothing$；  
（4）若$N_{G}(S)=T$，则停止，否则任选一点$y\in N_{G}(S)-T$；  
（5）若𝑦为$M$饱和点转（6），否则：求一条从$x$到𝑦的$M$可增广路$P$，置$M=M\oplus P$，转（2）  
（6）由于$ y$是$M$饱和点，故$M$中有一边 $(y,u)$，置$S=S\cup\{u\}$，$T=T\cup\{y\}$，转（4）。算法中$N_{G}(S)$表示 $G$上与$S$中任一结点相邻的所有结点组成的集合，$\oplus$表示集合的对称差运算。下面以图10-37 为例，详细介绍匈牙利算法的具体执行过程：  
![图10-37 二分图 ](images/e75e6b51eaa2d7dcbd869cabf1198a4ab254d8c498cf74b11e8db5905f80f0b4.jpg)  
![图10-38 步骤1 效果图 ](images/a85e16b732f3f408c1a3f889dd66171d41954384c66b3a6769a239cb765226ce.jpg)  
（1）首先任给一个初始匹配$M=\{(x_{1},y_{1}),\;\;(x_{3},y_{5}),\;\;(x_{5},y_{3})\}$，如图10-38 所示。  
（2）$x_{2},x_{4}$非饱和，故$X$非饱和。确定其中一个非饱和点$x_{2}$，令${S}=\{x_{2}\}$，$T=\varnothing$。  
（3）$S$邻接结点集${N}_{G}(S)=\{y_{2},y_{3}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{3}\}$，选择$y_{3}$  
（4）$y_{3}$已饱和，因$M$中有边$(y_{3},x_{5})$，故令：  
$$
S=S\cup\{x_{5}\}=\{x_{2},x_{5}\},\ T=T\cup\{y_{3}\}=\{y_{3}\}
$$  
（5）因为$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{4},y_{5}\}$，选择${{y}}_{5}$  
（6）$y_{5}$已饱和，因为$M$存在边$(y_{5},x_{3})$，故令：
$$
S=S\cup\{x_{3}\}=\{x_{2},x_{3},x_{5}\},\,\,\,T=T\cup\{y_{5}\}=\{y_{3},y_{5}\}
$$  
（7）$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{4}\},$,选择$y_{2}$  
（8）$y_{2}$不饱和，故存在从$x_{2}$到$y_{2}$的可增广道$P$。对于当前匹配$M=\{(x_{1},y_{1}),(x_{3},y_{5}),$$(x_{5},y_{3})\}$，求得可增广路$P$如图10 −39 加粗部分所示，得到$P$的边集：  
$$
E(P)=\{(x_{2},y_{3}),(y_{3},x_{5}),(x_{5},y_{5}),(y_{5},x_{3}),(x_{3},y_{2})\}
$$  
按下十重新调整匹配$M$，得到如图10 −40 所示一个新匹配$M$  
$$
M=M\oplus E(P)=\{(x_{1},y_{1}),(x_{2},y_{3}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
10-39 步骤8 过程图  
图10-40 步骤8 过程图2  
（9）在新匹配下继续查找可增广道。查看$ X$是否饱和，显然${{x}}_{4}$非饱和，选择该非饱和点$x_{4}$，并令$S=\{x_{4}\}$，$T=\varnothing$。  
（10）$N_{G}(S)=\{y_{3}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{3}\}$，选择$y_{3}$  
（11）$y_{3}$已饱和，因为匹配$M$中存在$(y_{3},x_{2})$，故令：
$$
S=S\cup\{x_{2}\}=\{x_{2},x_{4}\},\,\,\,T=T\cup\{y_{3}\}=\{y_{3}\}
$$  
（12）$N_{G}(S)=\{y_{2},y_{3}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{2}\}$，选择$y_{2}$（13）$y_{2}$已饱和，因为匹配$M$中存在$(y_{2},x_{3})$，故令：  
$$
S=S\cup\{x_{3}\}=\{x_{2},x_{3},x_{4}\},\,\,\,T=T\cup\{y_{2}\}=\{y_{2},y_{3}\}
$$  
（14）$N_{G}(S)=\{y_{2},y_{3},y_{5}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{5}\}$，选择$y_{5}$（15）$y_{5}$已饱和，因为匹配$M$中存在了$(y_{5},x_{5})$，故令：  
$$
S=S\cup\{x_{5}\}=\{x_{2},x_{3},x_{4},x_{5}\},\,\,\,T=T\cup\{y_{5}\}=\{y_{2},y_{3},y_{5}\}
$$  
（16 ）$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{4}\}$，选择${\cdot}y_{4}$（17）$y_{4}$不饱和，故可求一条从$x_{4}$到$y_{4}$的可增广路$ P$。对于当前匹配：  
$$
M=\{(x_{1},y_{1}),(x_{2},y_{3}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
求得如图10 −41 加粗部分所示的可增广道路$P$， $P$的边集为：  
$$
E(P)=\{(x_{4},y_{3}),(y_{3},x_{2}),(x_{2},y_{2}),(y_{2},x_{3}),(x_{3},y_{5}),(y_{5},x_{5}),(x_{5},y_{4})\}
$$  
按下式重新调整匹配$M$，得到如图10 −43 所示的一个新匹配  
![](images/ee96514b37bbad784ca2a76b1641bd0dbdac20d6a3f2ab76c80847e37bff2151.jpg)  
至此，集合$\cdot X$已经饱和，求得的如下最大匹配：  
$$
M=\{(x_{1},y_{1}),(x_{2},y_{2}),(x_{3},y_{5}),(x_{4},y_{3}),(x_{5},y_{4})\}
$$  
设二分图$G$有${n}$个结点$m$条边，使用匈牙利算法最大匹配时，初始匹配可以空，故算法最多找$n$条可增广道，每找一条可增广路，最多比较$m$条边。因此，匈牙利算法的最坏时间复杂度为$O(m n)$。由此可见，匈牙利算法是一个有效算法。"
产生式表示法,算法,"['第四章  谓词演算与推理', '§ 4.5 谓词逻辑的应用', '4.5.1 摘香蕉问题']","{'实体类型': '算法', '应用': '信息识别和判断等领域'}",,3,"假设某房间里有一只猴子（不妨设想其为机器人），位于$c$ 点；另有一只箱子，位于$a$点；而在$b$ 点的顶棚上吊着一把香蕉，如图4-2 所示。猴子自然希望能得到这把香蕉，但它因身材矮小够不到，当然，如果它站在箱子上便可如愿。但猴子的智慧尚不能像人那样，对将箱子推到香蕉下，踩在箱子上就可摘到香蕉的解决方案一目了然。试为猴子规划一个能摘到香蕉的行动计划。  
![](images/da6043b2c963f12fe3915d340fe42ec9b81a097c121fa6b1d07e9ec34d8173bb.jpg)
图4-2 猴子与香蕉问题  
可用谓词逻辑进行问题表示和求解。首先定义以下几个谓词：$A T\ (x,\ y)$，表示$x$ 在$y$处”；On_Box 表示“猴子在箱子上面”；Hold_$B$ 表示“猴子已经摘到香蕉”。并规定$x$的个体域为｛猴子、箱子、香蕉｝，$y$的个体域为$\{a,\ b,\ c\}$。则该问题可表示为：  
（1） 初始状态：  
AT（猴子，$a.$）：猴子在$a$ 处；$A T$（箱子，$c$）：箱子在$c$ 处；  
¬On_Box：猴子没有在箱子上面；  
¬Hold_$B$：猴子尚未摘到香蕉。  
（2） 目标状态：  
AT（猴子，$b$）：猴子在$b$ 处；$A T$（箱子，$b$）：箱子在$b$ 处；  
On_Box：猴子在箱子上面；Hold_B：猴子已经摘到香蕉。  
上述谓词只能描述事实性知识。下面再定义几个谓词表示过程性知识：  
Goto$(u,~\nu)$）：猴子从$u$ 处走到$\nu$ 处。  
条件：$A T$（猴子，$u$）为真——猴子必须在$u$ 处；$\neg O n\_B o x$ 为真——猴子不能在箱子上。  
动作：删除$A T$（猴子，$u$）；    增添$A T$（猴子，$\nu_{\cdot}$）。  
（1） pushBox$(\nu,\ \ w)$）：猴子将箱子从$\nu$ 处推到$w$ 处。  
条件：$A T$（猴子，$\nu$）为真——猴子须在$\nu$ 处；  
$A T$（箱子，$\nu$）为真——箱子须在$\nu$ 处；  
$\neg O n\_B o x$ 为真——猴子在箱子下才能推箱子。  
动作：删除$A T$（猴子，$\nu$）、$A T$（箱子，$\nu_{\perp}$）； 增添$A T$（猴子，$w$）、$A T$（箱子，$w$）  
（2） $ClimBox$：猴子爬上箱子。  
条件：AT（猴子，$u$）为真——猴子必须在$u$ 处；  
AT（箱子，$u$）为真——箱子也必须在$u$ 处；  
¬On_Box 为真——猴子不能在箱子上。  
动作：删除 $\neg O n\_B o x$ ；增添 On _ Box  
（3） Grasp：猴子已经摘到香蕉。  
条件：AT（猴子，$b$）为真——猴子必须在$b$ 处；  
AT（箱子，$b$）为真——箱子也必须在$b$ 处；  
On_Box 为真——猴子必须在箱子上；¬Hold_$B$ 为真——猴子没有摘到香蕉。  
动作：删除 ¬ Hold _ B ；   增添 Hold _ B  
可将该问题的状态描述成有序四元组$(\,W,\,x,\,y,\,z\,)$）。其中，$W$表示“猴子的水平位置”；$x$ 表示“猴子是否在箱顶（在则取1，否则为$_{0})$”；$y$ 表示“箱子的水平位置”；$z$ 表示“猴子是否摘到香蕉（摘到取1，否则为0）”。显然，$W$和$y$ 只能取$a$，$b$，$c$三个值，则基于上述操作性的谓词描述，该问题的求解过程即可描述如图4-3 所示。  
![](images/05c5b968cbbbe5fedfad9e5c185e1f46a65784eeb2eace9649980413581f7dfb.jpg)
图4-3 猴子与香蕉问题求解过程  
其实，在基于谓词逻辑思想的人工只能知识表示法中，还有产生式表示法，该表示法在信息识别和判断等诸多领域都有十分广泛的运用，此处不在赘述。"
代入定理,定理,"['§ 3.2 命题公式与等值演算', '三、命题公式的等值演算', '第三章  命题演算与推理', '3.2.2 等值关系与等值演算', '二、基本等值关系']","{'实体类型': '定理', '条件': '设G(P1,P2,⋯Pn)是一个命题公式，其中P1,P2,⋯Pn是G中的n个命题变元，G1(P1,P2,⋯Pn)，G2(P1,P2,⋯Pn)，⋯，Gn(P1,P2,⋯Pn)为任意命题公式', '结论': '若G为永真公式或永假公式，则用G1取代P1，用G2取代P2，⋯，用Gn取代Pn后得到的新的命题公式也是一个永真公式或者永假公式', '应用': '用于命题公式的等值演算'}",,4,"在初等代数中，我们常常借助一些已经证明为正确的恒等式，例如平方差公式等进行代数式的恒等变形或演算。在命题逻辑中，也可以这样做。具体地说，就是首先通过真值表证  
明一些基本的等值关系式，然后将这些基本等值关系式作为已知工具直接在命题公式等值演算中使用，达到简化演算过程的效果。这些基本等值关系式一共有24 个，具体如下：  
幂等律：$E_{1}\colon G\vee G\Leftrightarrow G$；                    $E_{2}\colon G\wedge G\Leftrightarrow G$；  
交换律：$E_{3}\colon G\vee H\Leftrightarrow H\vee G$；                 $E_{4}\colon G\wedge H=H\wedge\mathsf{G}$；  
结合律：$E_{5}\colon G\vee(H\vee S)\Leftrightarrow(G\vee H)\vee S \ \  \ \ E_{6}\colon G\wedge(H\wedge S)\Leftrightarrow(G\wedge H)\wedge S$  
同一律：$E_{7}\colon G\vee0\Leftrightarrow G$；                     $E_{8}\colon G\wedge1\Leftrightarrow G$；  
零  律： $E_{9}\colon G\vee1\Leftrightarrow1$；                     $𝐸_{10}: 𝐺∧0 ⇔0$；  
分配律：$E_{11}\colon G\vee(H\wedge S)\Leftrightarrow(G\vee H)\wedge(G\vee S)$$ 𝐸_{12}: 𝐺∧(𝐻∨𝑆) ⇔(𝐺∧𝐻) ∨(𝐺∧𝐻)；$  
吸收律：$E_{13}\colon G\vee(G\wedge H)\Leftrightarrow G$；               $𝐸_{14}: 𝐺∧(𝐺∨𝐻) ⇔𝐺； $  
矛盾律与排中律：$E_{15}{\colon G\wedge\neg G\Leftrightarrow0}$；            $E_{16}\colon G\vee\neg G\Leftrightarrow1;$；  
双从否定律：$E_{17}\colon\neg(\neg G)\Leftrightarrow G$  
德摩根律：$E_{18}\colon\neg(G\vee H)\Leftrightarrow\neg G\wedge\neg H$；         $E_{19}\colon\neg(G\wedge H)\Leftrightarrow\neg H\vee\neg G$  
等值蕴含与假言易位： $E_{20}\colon G\to H\Leftrightarrow\lnot G\vee H$ ； $E_{21}\colon G\to H=\neg H\to\neg G\colon$  
等价与等价否定：$E_{22}\colon G\leftrightarrow H\Leftrightarrow(\neg G\lor H)\land(\neg H\lor G);\quad $  
$E_{23}\colon G\leftrightarrow H\Leftrightarrow\neg G\leftrightarrow\neg H;$  
归谬论：$E_{24}\colon(G\to H)\wedge(G\to\lnot H)\Leftrightarrow\lnot G$。  
除了上述24 个基本等值关系之外，命题公式的等值演算还经常用到两个著名的定理，  
即代入定理和替换定理。  
对于任意一个永真式或永假式，其真值与公式中命题变元的取值状态无关。因此，用任意公式取代永真式或永假式中的变元，都不会改变其取值的永真性或永假性。下列代入定理正是表达了这个含义：  
【定理3.3**]**（代入定理）设$G(P_{1},P_{2},\cdots P_{n})$是一个命题公式，其中$P_{1},P_{2},\cdots P_{n}$是$G$中的$n$个命题变元，$G_{1}(P_{1},P_{2},\cdots P_{n})$，$G_{2}(P_{1},P_{2},\cdots P_{n})$，⋯，$G_{n}(P_{1},P_{2},\cdots P_{n})$为任意命题公式，此时若$G$为永真公式或永假公式，则用$G_{1}$取代$P_{1}$，用$G_{2}$取代$P_{2}$，⋯，用$G_{n}$取代$P_{n}$后得到的新的命题公式： $\mathsf{G}(G_{1},G_{2},\cdots G_{n})\,\Leftrightarrow\,G^{\prime}(P_{1},P_{2},\cdots P_{n})$也是一个永真公式或者永假公式。  
【定理3.4】（替换定理）设${\mathcal{G}}_{1}$是$G$的子公式，$H_{1}$是任一命题公式，在$G$中凡出现$G_{1}$处都以$H_{1}$替换后得到新的命题公式$\mathsf{H}$，若$G_{1}\Leftrightarrow H_{1}$，则$G\Leftrightarrow H$。"
代数格,概念,"['12.5.1 偏序格与代数格', '§ 12.5 格的概念与性质', '第十二章 典型抽象代数结构']","{'实体类型': '概念', '定义': '设⟨L,∧,∨⟩是具有两个二元运算的代数系统，若对于∀a,b,c∈L，满足交换律、结合律、吸收律，则称⟨L,∧,∨⟩是一个代数格', '特点': '满足幂等律'}",,2,格是一种非常特殊的代数结构。如前所述，数学主要有偏序、代数、拓扑和测度这四大基本结构，格结构同时具备偏序结构和代数结构，并与拓扑结构具有非常紧密的联系。不过从本质上看，格仍属于代数结构。格结构在密码学、计算机语义学、开关理论、逻辑设计等多个领域都具有非常重要的应用。本节主要介绍格的基本概念与性质，包括偏序格与代数格的概念、格结构的基本性质、格同态与同构以及若干常用的特殊格。
代数系统,概念,"['第十一章  抽象代数结构通论', '§ 11.1 代数结构的基本概念', '11.1.3 代数结构与子代数']","{'实体类型': '概念', '与代数结构的关系': '本书默认代数结构和代数系统是同一个概念'}",,3,"如前所述，代数结构由作为结构载体的集合、作为结构处理机制的运算和作为结构处理规则的运算律这三个部分组成。其中集合和运算是代数结构的构成成分，是代数结构的实体部分，而运算律则是代数结构中的公理系统或规章制度。这里着重介绍代数结构集合和运算，下一节将详细讨论代数结构的运算律。  
假设𝐴是一个任意给定的非空集合，则对于该集合上的一元运算或二运算$^{\ast}$，即：  
$*: A\to A \text{或} *: A\times A\to A$  
其运算结果并没有跑到集合𝐴之外，也就是说运算结果仍然是集合𝐴中的某个元素。这种性质通常称为运算的封闭性。由此可见，集合𝐴上的一元运算或二运算$^*$满足封闭性。  
根据以上讨论，可以得到如下关于代数结构的定义：  
【定义11.3】假设𝐴是一个任意给定的非空集合，$*_{1},*_{2},*_{3},\cdots,*_{k}$是𝐴上$k$个一元或二元运算，则集合𝐴与其上的$k$ 个运算$*_{1},*_{2},*_{3},\cdots,*_{k}$构成的整体称为一个代数结构或代数系统，简称为代数，记为$\langle A,\;\;*_{1},*_{2},*_{3},\cdots,*_{k}\rangle$。  
不难看出：$\langle N,+\rangle,\langle Z,+\rangle,\langle R,-\rangle,\langle N,+,\ \cdot\rangle,\langle R,+,\ \cdot\rangle:$都是代数结构，其中$+$，−，⋅都是普通的加法、减法和乘法；令𝑆表示所有含两个变量的命题公式组成的集合，则$\langle S,\ \wedge,\vee,\lnot\rangle$是一个代数结构，通常称之为命题代数；令𝐴表示任意一个给定的非空集合，则$\langle P(A),\;\cap,\;\cup, -\rangle$一个代数结构，通常称之为集合代数；令$M_{n}(R)$表示实数集合$R$上所有$n\times n$阶矩阵组成的集合，则$\langle M_{n}(R),+,\ \cdot\rangle$是一个代数结构，通常称之为矩阵代数。  
从上述讨论和定义可以看出，正是因为集合𝐴上的一元运算和二运算满足封闭性，才保证了集合𝐴能够成为整个代数结构的载体。由此可知，代数结构肯定也是具有封闭性的。  
例如$\langle N,+\rangle$显然是一个代数结构，而且普通‘$+$’运算在自然数N 上是具有封闭性。但是，在整数除法就不是整数集合𝑍上的二元运算，因为两个整数之商不一定是整数，不满足不封闭性，因此$ Z,+$不是代数结构。  
值得注意的是，有些离散数学书将代数结构和代数系统作为两个不同概念的进行来讨论。 具体地说，就是将运算性质的总和作为代数结构，将代数系统看成是代数结构和集合的集成。本书为了与数学结构的相关理论保持一致，默认代数结构和和代数系统是同一个概念，在后续的介绍和讨论中会不加区分地使用代数结构或代数系统这个两个名词。  
事实上，通过载体集合子集产生子代数系统是一个具有普适性的基本方法，每种具体的代数系统都可以通过这种方法产生子代数系统。例如，环代数系统可以产生各种子环、域代数系统可以产生各种子域、格代数系统可以产生各种子格等等。 其实，还可对代数系统的载 体集合做其它分析以产生新的代数系统，例如可通过集合的笛卡尔产生积代数、通过集合的上的等价关系产生商代数等，后面将会进一步讨论与此相关的内容，这里不再赘述。"
代数结构,概念,"['11.1.2 运算的定义与表示', '§ 11.2 代数结构的运算性质', '§ 11.1 代数结构的基本概念', '11.1.3 代数结构与子代数', '第十二章 典型抽象代数结构', '第十一章  抽象代数结构通论', '11.1.1 数学结构与代数结构', '第一章  集合与计数基础']","{'实体类型': '概念', '地位': '离散数学的分支之一', '基本思想': '以主动的方式定义一个由若干抽象对象为元素构成的集合，并在这个集合上定义一个或多个抽象运算，由此形成一个抽象的代数运算系统', '研究目标': '通过研究和讨论代数运算系统的运算性质获得该运算系统的结构', '特点': '相对于传统的初等代数，是一种全新的思维方式和观察问题的角度', '定义': '以运算作为处理机制的数学结构，由一个运算对象的集合和若干运算构成的系统，由作为结构载体的集合、作为结构处理机制的运算和作为结构处理规则的运算律这三个部分组成', '作用': '在数学理论体系和计算机数学建模中占据非常重要的作用', '发展历程': '从初等代数发展到抽象代数，目前正朝着泛代数的方向发展', '基本要素': '载体集合、处理机制、处理规则', '处理机制': '以元素之间的运算作为处理机制', '处理规则': '运算性质，如结合律、交换律、分配律等', '应用': '用于构造和研究子代数、积代数和商代数，考察代数结构之间的联系', '构成成分': '集合和运算是代数结构的构成成分，运算律是代数结构中的公理系统或规章制度', '封闭性': '集合上的一元运算或二元运算满足封闭性', '实例': '如 ⟨N,+⟩, ⟨Z,+⟩, ⟨R,−⟩, ⟨N,+⟩, ⟨R,+⟩, ⟨S,∧,∨,¬⟩, ⟨P(A),∩,∪,−⟩, ⟨M_n(R),+⟩', '研究方法': '通过建立一些标准实现对这些代数结构进行分类，以便进行分门别类的考察和研究，揭示这些代数结构共性和差异', '类比': '类似前面对二元关系模型的研究', '研究对象': '抽象集合和抽象运算', '运算性质': '结合律、交换律、幂等律、消去律、分配律和吸收律', '特殊元素': '幺元、零元、逆元、幂等元、消去元', '分类标准': '运算性质的满足程度'}",,1,离散数学以各种离散量的概念、关系、结构和运算性质为研究对象，以充分满足计算机相关学科对离散量进行表示和处理的数学需求。正如微积分支撑了作为近代工业文明基础的物理学，离散数学支撑了作为现代信息社会基础的计算机科学。事实上，离散数学是一门综合的数学学科，由多个数学分支组成，包括集合论、数理逻辑、图论、数论、组合分析、代数结构等，分别从不同角度出发研究各种离散量之间数与形的关系。本章比较系统地介绍集合论与计数的基础知识， 它们是学习各个离散数学分支所必备的入门基础。 尽管读者可能已 经从其它途径获悉其中某些概念，但是要想掌握作为支撑整个计算机学科基石的离散数学，就必须重新审视和系统地学习这些入门知识。
代数结构的基本概念,概念,['第十一章  抽象代数结构通论'],"{'实体类型': '概念', '内容': '包括代数结构与子代数、代数结构的运算性质、代数结构的同态与同构等'}",,1,"我们知道，小学数学中关于整数或分数的四则运算称之为算术，初中数学则将这些具体整数或分数抽象成字母，着重考察这些字母表达式的运算性质与运算技巧，称之为初等代数或代数。从本质上说，所谓代数，其实就是以运算为基本手段寻求针对某一类问题的通用求解方法或计算公式。因此，可运算性和通用性是代数学的两个核心要点。初等代数之所以用抽象字母代替具体的数，是因为字母比数更具一般性和通用性。事实上，我们的处理对象除数之外通常还有很多其它类型，例如向量、矩阵、命题、集合、函数、关系、图模型等等，这些对象都分别具有各自的运算及运算性质。那么就有一个想法：是否可以对这些对象做进一步抽象？具体地说，就是如同用字母表示数一样用一种抽象对象来统一表示这些各种各样的具体对象，并用一些抽象运算统一表示这些具体对象各自的运算及运算性质，从更加抽象的角度来考察这些不同对象所共有的一般性运算性质与规律，或者说从更加抽象的层次上根据运算性质的差异对这些不同对象进行分类。  
基于以上思想，就可得到抽象代数结构的概念。该结构是在初等代数抽象层次上的进一步抽象，其运算和运算性质具有更高层次的通用性和普适性。抽象代数结构的出现使得代数学由主要针对各种运算技巧的研究转变为主要针对各种运算性质和运算结构的研究，开辟了数学代数学发展的新纪元，将代数学带入了一个全新的发展阶段。从计算机的角度看，计算机处理的信息对象多种多样的且分别具有各自的运算和运算性质。对这些信息的处理一般需要建立若干抽象数据类型并将与之相关的数据运算封装于其中，并从抽象的角度考察它们的共同运算性质和运算规律。抽象代数结构的相关理论和技术可以为这些抽象的数据类型及相关运算的设计提供基本思路和方法技巧。此外，还可使用抽象代数结构理论设计出各种各样满足实际问题需要的计算模型。目前，这些计算模型已经在信息编码与纠错、自动机与形式语言、大数据信息处理与知识发现、信息安全等众多领域得到广泛应用。  
学习抽象代数结构知识不仅可以掌握抽象数据类型和计算模型的设计技巧，更为重要的是能够使得读者具备一种高度抽象的思维能力，可以站在比较高的层次上看待、分析和解决问题，获得一种更加宽广的视野。本章主要介绍抽象代数结构的基本知识，包括代数结构的基本概念、代数结构与子代数、代数结构的运算性质、代数结构的同态与同构等。"
仿射加密算法,算法,"['第二章  整数与算法设计基础', '§ 2.2 同余算术及其应用', '2.2.3 整数加密算法']","{'实体类型': '算法', '定义': '一种对称加密算法，使用0到25之间的数字表示字母，通过加密函数进行替换加密', '特点': '简单且广为人知'}",,3,"为防止机密信息被泄露或破坏，需采用数据加密技术对其进行保护。数据加密的基本思想是对原始数据加以伪装，使非法接入者无法理解信息的真正含义，基本过程就是对原来为明文信息或数据按某种算法进行处理，使其成为不可读的一段代码，称为密文，使其只能在输入相应密钥之后才能显示出本来内容。数据加密通常分为对称式加密和非对称式加密两大类。本节介绍两种基于整数理论的经典加密算法，一种是名为仿射加密算法的对称加密算法，另一种是名为RSA 的非对称加密算法。  
仿射加密算法又称为凯撒加密算法，是一种简单且广为人知的加密技术。它是一种替换加密技术，基本思想如下：首先使用0 到25 之间的数字表示A 到Z 这26 个字母。然后，对于每个不大于25 的非负整数$\cdot p$，定义其加密函数值$f(p)$为$\{0,1,2,\ \cdots,25\}$中某个数字。加密函数$f(p)$的有多种定义方法，例如可采用如下加密函数：  
$$
f(p)=(p+3)\;{\bmod{\,}}26
$$  
对于上述加密函数，此时用整数$(p+3)\,\mathrm{mod}\,26$代表的字母替代由整数$p$表示的字母实现加密。例如，对“WELCOME TO HEFEI”进行加密，首先用数字代替字母，然后使用加密函数$f(p)=(p+3)\mod 26$ 代替$p$，翻译成字母后，得到获得到的加密信息为：“ZHOFRPH VR KHIHL”具体过程如下：  
表2-3 凯撒密码的加密过程
![](images/168580ee1913d8c32220b048da1875515ce367981f5bce7472f95af1471231b8.jpg)  
解密则需要使用加密函数的$f(p)$反函数 $f^{-1}(p)$  
$$
f^{-1}(p)=(p-3){\bmod{\,}}26
$$  
解密时需将加密信息转换成数字，然后使用$f^{-1}(p)$把$\{0,1,2,\ \cdots,25\}$中整数$\cdot p$恢复成信息原文对应的整数，之后再将数字装换成字母获得原文。  
RSA 算法由三位数学家Rivest、Shamir 和Adleman 于1977 年共同提出，是至今最为广泛使用的非对称加密算法，特别适合于对通过互联网传送的数据进行加密，通常于数字签名等场合。RSA 算法使用整数模余运算性质生成公钥和私钥，并进行加密和解密。RSA 算法原理基于欧拉定理和费马小定理，为此首先介绍这两个定理。  
【定理2.29】（欧拉定理）设$m$ 是任一正整数，$a$ 是任一与$m$ 互素的整数，则有：  
$$
a^{\varphi(m)}\equiv1({\bmod{\ m}})\tag{2-15}
$$  
其中$\varphi(m)$是欧拉函数。  
如果上述猜想能够成立，则提供了一个非常有效的素数判定方法。但是遗憾的是，上述猜想并不成立。事实上，$p$ 为只要是素数，则其必满足上式，但反之不然。法国数学家给出了如下称之为费马小定理更一般结论：  
【定理2.30】（费马小定理）假设$p$ 是一个任意给定的素数，则对于任意整数$a$，有：  
$$
a^{p}\equiv a({\bmod{\ p}})\tag{2-16}
$$  
特别地，当$a$与$p$ 互素时，有：$a^{p-1}\equiv1({\bmod{\ p}})$。  
下面介绍RSA 算法的基本原理和具体计算过程。RSA 算法理论基础是同余算术以及欧拉定理和费马小定理，其安全性依赖于大整数素因子分解的困难性，即已知整数$n$ 是两个大素数$p$ 和$q$ 的乘积，则难以在可接受的时间范围内通过$n$ 的素因子分解方法获得$p$ 和$q$ 的取值。RSA 算法的密钥生成、加密、解密的具体过程如下：  
1） 密钥的生成  
首先生成两个互不相同的大素数$p$ 和$q$，并令$n=p\cdot q$。其中$p$ 和$q$ 是属于解密信息，不可对外公开，整数$n$ 属于加密信息，需要对外公开。  
然后，令$\varphi(n)=(p-1)(q-1)$，并任意选择一个与$\varphi(n)$互素的正整数$e$，满足：  
$2\leq e\leq\varphi(n)$  
其中$\varphi(n)$不可对外公开，$e$ 为加密密钥，需要对外公开。  
由于$p$ 和$q$ 都是素数，故小于$p$ 且与$p$ 互素的非负整数的个数为$(p-1)$个，小于$q$ 且与$q$ 互素的非负整数的个数为$(q-1)$个。注意到$n=p\cdot q$，由计数的乘法原理及素数的性质可知，小于$\cdot n$且与$n$互素的非负整数的个数为$(p-1)$ $(q-1)$个，因此，$\varphi(n)=(p-1)(q-$1)其实就是欧拉函数。  
由于$e$ 的模$\varphi(n)$互素，因此$e$ 的模$\varphi(n)$同余逆$d$存在且唯一。算出$e$ 的模$\varphi(n)$同余逆$d$，使其满足：  
$$
e d\equiv1({\bmod{\ }}\varphi(n))\tag{2-17}
$$  
整数$d$ 属于解密密钥，不可对外公开。  
由此得到RSA 加密算法中作为公钥的加密密钥$e$，作为私钥的解密密钥$d$。  
2） 加密过程  
在RSA 加密算法中，要将明文信息转化成若干组整数序列。为此，首先将每个字母翻译成相应的整数，例如可以使用前述的凯撒加密算法完成这项工作。然后，将这些由明文字母对应的整数合并成若干组，每个组分别形成一个大整数，代表一个字母段。  
RSA 加密过程其实就是每个表示明文字母段的大整数$M$逐个转化为表示密文字母段的大整数$C$，具体转化公式如下：  
$$
C=M^{e}{\pmod{n}}\tag{2-18}
$$  
在转化过程中总是假定$M<n$。如果$M\geq n$，则需要对表示明文的所有整数重新进行分组以确保每个字母段对应的大整数小于$n$。  
3） 解密过程  
由于$d$ 是$e$ 的模$\varphi(n)$逆，即是$e$ 的模$(p-1)(q-1)$逆，故有：  
$$
e d\equiv1(\bmod(p-1)(q-1))\tag{2-19}
$$  
也就是说，$_{e d}$除以$(p-1)(q-1)$的余数为1，故存在整数$k$，使得：  
$$
e d={\begin{array}{l}{(p-1)(q-1)k+1}\end{array}}
$$  
故有：  
$$
C^{d}\equiv(M^{e})^{d}\equiv M^{e d}\equiv M^{(p-1)(q-1)k+1}\,({\mathrm{mod}}\,\,n)
$$  
假定$M$与$p$ 和$q$ 均为互素，则根据费马小定理有：  
$$
M^{p-1}\equiv1(\mathrm{\;mod}\;\left(p\right))\mathcal{X}M^{p-1}\equiv1(\mathrm{\;mod}\;\,q)
$$  
从而有：  
$$
\begin{array}{r}{C^{d}\equiv M^{(p-1)(q-1)k+1}\equiv\!\!M\!\cdot\!(M^{p-1})^{k(q-1)}\!\!\equiv\!\!M\!\cdot\!1\!\equiv\!\!M\,(\mathrm{mod}\,p)}\\ {C^{d}\equiv M^{(p-1)(q-1)k+1}\equiv\!\!M\!\cdot\!(M^{q-1})^{k(p-1)}\!\!\equiv\!\!M\!\cdot\!1\!\equiv\!\!M\,(\mathrm{mod}\,q)}\end{array}
$$  
由于$p$ 与$q$ 互素，则根据中国余数定理，有：  
$$
C^{d}\equiv M\,({\sf m o d}\,\,\,p\cdot q)\mathbb{\bar{X}}C^{d}\equiv M\,({\sf m o d}\,\,\,n)
$$  
由于$M<n$，故必有：$M=C^{d}\;({\mathsf{m o d}}\;\,n)$  
因此，若已知解密密钥$d$，就可使用公式$M=C^{d}\,({\sf m o d}\,n),$对密文$C$ 进行解密。  
在RSA 加密和解密算法中，如果$p,\ q$ 被信息窃取者获得，则可算出$(p-1)(q-1).$。由于$e$ 是公开密钥，且$d$是$e$ 关于关于模$(p-1)(q-1)$的逆，则不难求出$d$，如此RSA 系统便被完全攻破，信息窃取者就会很容易获得加密的信息。  
RSA 算法中的素数都是十进制整数，怎样才能选择好的$p$ 和$q$，这是$R S A$ 加密算法最关键的问题。针对素数$p$ 和$q$ 的选择，1978 年Rivest 等人在关于RSA 公开密钥的论文中，建议对素数$p$ 和$q$ 的选择应当满足：  
1）$p$ 和$q$ 要足够长，在长度上应相差几位，且二者之差与$p$ 和$q$ 位数相近；  
2）$p{-}1$ 和$q{-}1$ 的最大公约数$\operatorname*{gcd}(p -1\,,\,\,\,q-\!\!1)$要尽量小；  
3）$p{-}1$ 和$q{-}1$ 均应至少含有一个大的素数因子。  
并把满足这些条件的素数称为安全素数。  
从实用的观点看，如果加密后的信息能够保证在足够长的时间内不能被破解，则认为这个加密方法是安全的。相对于RSA 加密算法而言，如果整数$n$ 不是足够大，例如只有10 位，那么按照计算机目前的计算能力，几乎可以立刻求出其所有素因子实现对RSA 加密算法的破解。如果计算机的计算能力得到进一步的提高，则或许能够破解200 位的整数$n$。但是，如果使用200 素数$p$ 和200 位素数$q$ 构成400 位整数$n$，则计算机无法破解由此设计的RSA加密算法。因此，就目前以及今后一段时间而言，RSA 加密算法具有较好的安全性。"
优先级函数,概念,"['第七章 函数与特殊函数', '§ 7.4 有限集的置换函数', '7.5.2 宽带分配问题']","{'实体类型': '概念', '定义': '表示用户优先级的函数', '计算方式': '用户已使用宽带与可使用最大宽带之比'}",,3,"随着互联网上语音视频业务的飞速增长，宽带成了影响服务质量的主要因素。一般来说，用户使用的宽带分成两部分：静态宽带和动态宽带。静态宽带是运营商承诺的最小宽带，已经预留给每个用户；动态宽带被所有的用户共享，根据需求进行分配。语音视频业务服务过程一般分成三步：建立连接、进行语音视频传输、结束服务。对于已经建立连接并正在进行传输的服务，运营商应该保证其所需要的宽带。而在连接阶段，如果所有客户申请的宽带总量超过运营商所提供的宽带时，则进行宽带分配。用户的优先级通常他可使用的最大宽带与已占有的宽带之比，需求量越大，被满足的宽带越小，则优先级越高。  
假设已知每一项业务所申请的宽带大小，在保证分配的宽带之和不超过网络总宽带的条件下，如何选择业务，以使得业务优先级收益（即所有业务的优先级之和）达到最大？  
可以用集合与函数对这个问题进行建模。设用户集合是$\{1,2,\cdots,n\}$，用户$𝑖$提出了$t_{i}$个宽带申请，其第$𝑗$个申请的宽带是$r(i,j)$，这里$i=1,\!2,\cdots,n,\:\:\:\mathrm{j}=1,\!2,\cdots,t_{i}.$。假设此刻运营商能提供的动态宽带总量是$B$用户$i$已使用的宽带为$C_{i j}$，可使用的最大宽带为，那么$C_{i j}\leq M_{i j}$。用户$i$的优先级函数记作$P(i,j)$，其中：$P(i,j)=C_{i j}/M_{i j}$。  
用函数$X(i,j)$表示对用户$i$的第𝑗个申请的分配结果$X(i,j)=1$表示分配$X(i,j)=0$表示不分配，那么问题的优化目标是使得下述函数，即优先级利益：  
$$
\sum_{i=1}^{n}\sum_{j=1}^{t_{i}}X(i,j)\cdot P(i,j)\quad\text{(7-9)}
$$  
达到最大，同时满足不超过总宽带的约束条件，即：  
$$
\sum_{i=1}^{n}\sum_{j=1}^{t_{i}}X(i,j)\cdot r(i,j)\leq B\quad\text{(7-10)}
$$  
这是个典型的组合优化问题，$n$个用户总计有$t_{1}+t_{2}+\cdots+t_{n}=m$个宽带请求，分别标号为${1,2,\cdots,m}$。在考虑前$n$项宽带请求$k=(1,\!2,\cdots,m)$，总宽带限制为$l(l=1,\!2,\cdots,B)$的情况下，设最佳分配的优先级收益为$v(k,l)$。  
如果此时把宽带分配给第$k$项业务（可能是第$𝑖$个用户的第$𝑗$个申请），该业务所需宽带是$r(k)$（在$r(k)=r(i,j)\leq l$的情况下），优先级收益是$P(k)=P(i,j)$。那么，剩下的宽带是$l-$$r(k)$。这些宽带将在${1,2,\cdots,k-1}$项业务中分配，所得到的优先级收益将是$v(k-1,l-r(k))$，因此总的优先级收益是$v(k-1,l-r(k)+P(k))\mathrm{v}$。相反，如果不把宽带分配给第$k$项业务，那么全部宽带𝑙将在${1,2,\cdots,k-1}$项业务中分配，总收益为$v(k-1,l)$为了使得优先级的总收益最大，只要在上述两个收益中选择最大的即可。  
上述分析可以总结成下面的递推公式，即$\forall k(0\leq k\leq m),\forall l(0\leq l\leq B)$，有  
$v(k,l)$  
![](images/ca1bba9e9c93f3e9595cc988da9323614b05bd9b58074b31eaf8aa4a7e6c05f3.jpg)  
根据这个公式：  
第一步先计算$k=1,\mathsf{l}=1,2,\cdots,B$的$v(1,l)$值，并把它们存到一个表中；  
第二步计算$k=2,\mathsf{l}=1,2,\cdots,B$的$v(2,l)$值，再把得到的值存到这个表中。  
每步计算若用到的较小的$v(k,l)$值，就到表中去取。照此做下去，直到计算出$k=m,l=$${1,2,\cdots,B}$的$v(m,l)$值为止，其中的$v(m,B)$就是最佳分配的优化函数值，即最大优先级收益。  
上述计算完成后，再根据$v(m,B)$的值逐步向前追溯，就可以找到最佳分配方案。先看$v(m,B)$是等于$v(m-1,B)$，还是等于$v\bigl(m-1,B-r(m)\bigr)+P(m)\,?$若等于前者，则没有选择第$m$项业务；若等于后者，则选择了第$m$项业务。然后根据剩下的部分是$v(m-1,B)$还是$v\big(m-1,B-r(m)\big)$来追溯第$m-1$项业务是否被选到。照此下去，直到$m$项业务都考察到，就得到问题的解。如果在计算每一项$v(k,l)$的时刻就把是否选择第$k$项业务记录下来，则就可以省略追溯过程，只需查一下全部记录，就能得到了问题的解。"
传递性,性质,"['§ 5.4 关系的性质闭包', '第六章 特殊关系模型', '第五章 关系模型与理论', '5.3.4 关系性质的判定', '§ 5.3 关系的基本性质']","{'实体类型': '性质', '定义': '如果关系中的元素a与元素b相关联，且元素b与元素c相关联，则元素a与元素c也相关联', '判定条件': 'R 是传递的当且仅当 R 与自身的合成关系包含于 R', '重要性': '关系的重要性质', '应用场景': '在很多关系问题的求解过程中需要用到'}",,2,现实世界中的关系错综复杂、种类繁多，这给我们使用关系的数学模型表示和解决关系问题带来一定的困难。因此，为了比较方便地研究和使用关系的数学模型，本节建立考察关系特性的若干标准并将这些标准看成是关系的基本性质。对于任意给定的一个关系，就可以使用这些标准来考察或评判该关系满足或不满足这几个标准中的哪几条，换句话说，就是考察该或评判该关系具有哪些基本性质。这样就可以依据这些标准将所有的关系划分为若干类型进行分门别类的研究。关系的这些考察标准或基本性质一共有五个，即自反性、反自反性、对称性、反对称性和传递性，本节具体介绍这些基本性质的概念及判定方法。
传递闭包,概念,"['§ 5.4 关系的性质闭包', '5.4.2 传递闭包的构造', '§ 8.2 图的运算与结构', '第五章 关系模型与理论', '8.3.2 可达性及其判定', '5.4.1  关系闭包的概念', '第八章  图的基本理论与算法']","{'实体类型': '概念', '定义': [""若存在关系R'，满足R'是传递的，且对任何传递关系R''，若R⊆R''，则R'⊆R''，则称R'为R的传递闭包"", '包含关系R的传递性关系中最小的集合', '图G中结点之间可达性产生的二元关系是图G所表示二元关系的传递闭包'], '构造方法': '通过关系复合运算逐步构造', '特点': '比自反闭包和对称闭包构造更复杂', '应用': '用于分析图中可达结点的联结通路或回路长度'}",,3,"首先，我们考察关系的自反闭包。假设$R$ 是集合$A$ 上的二元关系，如果$R$ 不满足自反性，就说明集合$A$ 中存在某个元素$a.$,使得$\langle a,a\rangle\not\in R$，此时可以将关系R 进行调整或修改，避免这种情况的发生。具体地说，就是将序偶$\langle a,a\rangle$纳入到关系$R$ 由此产生一个新的关系$R^{\prime}$。一般地，如果对于$A$ 中的每个元素${x}$，都将$\langle x,x\rangle$纳入到关系$R$，由此产生新的关系$R^{\prime}$必然满足自反性。事实上，关系$R^{\prime}$是对关系$R$ 的一种扩充，使得扩充后的关系能够满足自反性。若能证明这种扩充是满足扩充目的最小扩充，则$R^{\prime}$就是关系$R$ 的自反闭包。  
可同理考察对称闭包。假设$R$ 是集合$A$ 上的二元关系，如果$R$ 不满足对称性，就说明集合$A$ 中存在两个元素$a$和$b$使得$\langle a,b\rangle\in R$，但$\langle b,a\rangle\not\in R$。此时，只需将$\langle b,a\rangle$纳入$R$ 中就可避免这种情况发生。因此，可以对$R$ 进行适当扩充构成其对称闭包。  
可类似考虑传递闭包的基本思想，不再赘述。下面给出这三个闭包的具体定义：  
【定义5.22】设$R$ 是集合$A$ 上的关系，若存在$A$ 上的另一个关系$R^{\prime}$，满足：  
（1）$R^{\prime}$是自反的（对称的、或传递的）  
（2）对$A$ 上任何自反（对称的、或传递）关系$R^{\prime\prime}$，如果$R\subseteq R^{\prime\prime}$，那么$R^{\prime}\subseteq R^{\prime\prime}$，则称${R^{\prime}}$为$R$的自反闭包（对称闭包或传递闭包），记为$r(R)(s(R)$或$t(R))$。  
下面定理给出了自反闭包和传递闭包的构造方法：  
【定理5.12】设$R$ 是非空集合$A$ 上的关系，则有：  
$r(R)=R\cup R^{0};\,\,\,s(R)=R\cup R^{-1}$  
由上述例题可得利用关系图求关系$R$ 闭包的方法：  
（1）检查$R$ 的关系图，在没有自环的结点处加上自环，可得$r(R)$的关系图；  
（2）检查$R$ 的关系图，将每条单向边全部改成双向边，可得$s(R)$的关系图；  
（3）检查$R$ 的关系图，从每个结点出发，找到其终点，如果该结点到其终点没有边相连，就加上此边，由此可得$t(R)$的关系图。"
传递闭包构造定理,定理,"['第五章 关系模型与理论', '§ 5.4 关系的性质闭包', '5.4.2 传递闭包的构造']","{'实体类型': '定理', '内容': '设R是非空集合A上的关系，t(R)是R的传递闭包，则有t(R)=R∪R²∪R³∪…'}",,3,"自反闭包和对称闭包的构造比较简单，一般通过枚举的方法就可以得到解决。然而，传递闭包的构造比自反闭包和对称闭包要困难一些，需要一些技巧。因此，本小节对传递闭包概念做进一步深入理解并由此给出传递闭包构造方法和技巧。  
假设𝐴是任一给定的有限非空集合，$R$ 是$A$ 上的一个二元关系，$t(R)$是$R$ 的传递闭包，显然有${\boldsymbol{R}}\subseteq\ t({\boldsymbol{R}})$。现对于任意$\langle x,z\rangle\in R^{2}$或$\langle x,z\rangle\in R\circ R$，由$R\circ R$的定义知必存在$A$ 中某个元素$y$，使得$\langle x,y\rangle\in R$且$\langle y,z\rangle\in R$，那么根据关系$t(R)$的传递性，必有$\langle x,z\rangle\in t(R)$。故有：$R^{2}\subseteq\ t(R)$，即$R^{2}$也是$t(R)$的一个子集合。  
类似地，对于任意$\langle x,z\rangle\in R^{3}$或$\langle x,z\rangle\in R^{2}\circ R$，则必存在$A$ 中某元素$y$，使得$\langle x,y\rangle\in R^{2}$且$\langle y,z\rangle\in R$，从而有$\langle x,z\rangle\in t(R)$，故有$R^{3}\subseteq\ t(R)$。以此类推，可知，对于任意自然数$k$，必有$R^{k}\subseteq\ t(R)$。故有：
$$
R\ \cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots\subseteq\ t(R)\quad\text{(5-15)}
$$
根据传递闭包$t(R)$的定义，$t(R)$是包含$ R$的传递性关系中最小的集合，要证明：
$$
t(R)\ \,\subseteq\,R\,\cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots
$$
只需证明 $R\ \cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots$ 满足传递性即可。任取两个序偶 $\langle x,y\rangle$ 和 $\langle y,z\rangle$ ，满足：
$$
\langle x,y\rangle\in R\ \cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots;\ \ \langle y,z\rangle\in R\ \cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots
$$
则分别存在自然数$t,s$，使得$\langle x,y\rangle\in R^{t}$且$\langle y,z\rangle\in R^{s}$，则根据关系复合运算的定义，有：$\langle x,z\rangle\in R^{t}\circ R^{s}$，即有：$\langle x,z\rangle\in R^{t+s}$。故有：$\langle x,z\rangle\in\!\!R\,\cup\!R^{2}\cup\!R^{3}\cup\cdots\cup\!R^{k}\cup\cdots_{\circ}$。即有：
$$
t(R)\ \,\subseteq\,R\,\cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots\quad\text{(5-16)}
$$
经过以上分析，可得到如果关于传递闭包构造定理：  
【定理5.13】设$R$ 是非空集合$A$ 上的关系，$t(R)$是$R$ 的传递闭包，$M$和$M_{t}$分别为$R$ 和$t(R)$的关系矩阵，则有：
$$
t(R)=\,R\,\cup R^{2}\cup R^{3}\cup\cdots\quad\text{(5-17)}
$$  
$$
M_{t}=M\lor M^{2}\lor M^{3}\lor\cdots\quad\text{(5-18)}
$$  
通过前面的例题可以看出，使用集合运算法计算传递闭包比较繁琐晦涩，非常容易出错，使用矩阵计算则涉及计算量很大的方幂计算。为了更加方便地构造关系的传递闭包，下面介绍一个比较高效传递闭包构造算法，即著名的沃舍尔算法。  
假设$R$ 是非空集合$A$ 上的二元关系，$t(R)$是$R$ 的传递闭包，$G$ 是$R$ 的关系图。从前面分析可知，在传递闭包$t(R)$的关系图中，若从结点$x$到结点$y$有一条边，当且仅当在$R$的关系图$G$ 中存在一条从结点$x$到结点$y$且边数大于或等于1 的链路，即在图$G$ 可以从结点$x$连通到结点$y$。因此，关于$R$的传递闭包$t(R)$实际上就是$R$的关系图$G$ 的连通关系$R^{*}$，即有：  
$R^{*}=\{\langle x,y\rangle|$在图$G$中存在一条从结点结点$x$到结点𝑦有向链路}  
现考虑 $n+1$ 个矩阵序列 $M_{0},M_{1},\cdots,M_{n}$ ，将矩阵 ${M}_{k}$ 的第 $𝑖 $行第$ 𝑗 $列的元素记为 $M_{k}[i,j]$ 。对 于$k=0,1,\cdots n$，$M_{k}[i,j]=1$当且仅当在$R$的关系图$G$ 中存在一条结点$x_{i}$到结点$x_{j}$的一条链路，并且这条链路除两个端点之外的中间结点只能经过集合$\{x_{1},x_{2},\cdots,x_{k}\}$中的结点。显然，$M_{0}$就是$R$ 的关系矩阵，而$M_{n}$就是$R$ 的传递闭包$t(R)$的关系矩阵。沃舍尔算法的核心思想就是采用递推的方法从$M_{0}$逐步计算出$M_{n}$，据此给出$t(R)$的高效构造算法。  
假设$M_{k}$已经计算完成，那么如何从$M_{k}$计算出$M_{k+1}$呢？所谓计算出$M_{k+1}$，其实就是对每组$i,j$，确定$M_{k+1}[i,j]$是否为1。根据$M_{k+1}$的定义，$M_{k+1}[i,j]=1$当且仅当在$R$的关系图$G$中存在一条结点$x_{i}$到结点$x_{j}$的一条链路，并且这条链路除两个端点之外的中间结点只能经过集合$\{x_{1},x_{2},\cdots,x_{k},x_{k+1}\}$中的结点。这种链路只有两种可能性：  
第一种是只经过$\{x_{1},x_{2},\cdots,x_{k}\}$中的结点，此时$M_{k}[i,j]=1$  
第二种可能是链路经过了结点$x_{k+1}$，此时显然仅考虑只经过结点$x_{k+1}$一次的情形，因为如果经过两次$x_{k+1}$则必然形成一个回路，将该回路删除即可。将该链路分成如下两段，即：从结点$x_{i}$到结点$x_{k+1}$，以及从结点$x_{k+1}$到结点$x_{j}$。故有$M_{k}[i,k+1]{=}1$ 且$M_{k}[k+1,j]{=}1$。  
综上所述，可由下列公式从$M_{k}$计算出$M_{k+1}$
$$
M_{k+1}[i,j]=M_{k}[i,j]\vee M_{k}[i,k+1]\wedge M_{k}[k+1,j]\quad\text{(5-19)}
$$
具体地说，对于$k=0,1,2,\cdots,n-1$，从$M_{k}$构造$M_{k+1}$的具体过程如下：  
(1)$ M_{k}[i,j]=s_{i j},\,\,\,M_{k+1}[i,j]=t_{i j}$  
（2）将$M_{k}$中的所有值为1 元素复制到$M_{k+1}$中相应位置，即若$s_{i j}=1$，则$t_{i j}=1$  ;  
（3）对于所有$i,j=1,2,\cdots,n$，若$t_{i j}=0$，则当$s_{i k+1}=s_{k+1j}=1$时，令$t_{i j}=1$ 。"
伪代码,算法描述语言,"['第二章  整数与算法设计基础', '§ 2.3 算法设计的基本知识', '2.3.1 算法的基本概念']","{'实体类型': '算法描述语言', '定义': '一种介于自然语言和程序设计语言之间的文字符号来描述算法', '特点': '结构清晰，简单且易于修改，可读性较好，类似自然语言'}",,3,"计算机是处理数据并将数据转化为有用信息的电子设备。任何计算机都由程序指令控制，程序指令规定计算机的用途，并告诉计算机需要完成的工作。因此，要使计算机工作就需要编写计算机程序，告诉计算机如何按照步骤执行程序，以实现最终目标。值得注意的是：根据计算机的特点，在告诉计算机需要它完成什么任务的同时，还需要进一步确定或选择让它怎样去完成，这正是计算机算法的由来。  
算法一词出自《周髀算经》，即算术之法。目前，关于算法的概念有很多种不同的定义，至今没有一种得到大家的公认，但可从这些不同定义中找到一些基本的共识。为求同存异，现从广义和狭义这两个不同的角度来诠释与理解算法的概念。  
【定义2.17】从广义上讲，算法是指通过运算的方式按照某种机械的步骤逐步实现对问题的求解，从这个角度看，现实生活中的很多工作流程都可以看成是算法，例如烧菜的菜谱、理发的流程等，都可以叫算法。从狭义上讲，算法是一个由已知推求未知的过程，对于符合一定规范的输入，它能够在有限的时间内获得所需的输出。在计算机专业领域，主要是从狭义的角度来理解算法。  
本书的算法设计，主要是从计算机专业角度来理解算法。在计算机专业领域，对算法的理解不仅是狭义的，而且对算法概念诠释更加明确具体，即：算法是指用于计算机解决问题的清晰有穷指令序列，且满足以下五条基本性质：  
1) 有穷性：算法中每条指令的执行次数和时间均有限。执行次数或执行时间无穷的算法，对实际生产生活几乎没有意义，而且还会造成资源浪费。  
2) 确定性：对算法的描述必须无歧义，以保证算法执行结果是确定的，且符合要求和期望。如果算法对于同样的输入，在相同环境下产生不确定的结果，则是不能接受的。  
3) 输入：一个算法有0 个或多个输入，以确定运算对象的初始情况。所谓0 个输入是  
指算法本身给定了初始条件。  
4) 输出：一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的。  
5) 可行性：算法中有待实现的运算都是基本运算，算法原则上要能够精确地运行，且人们用笔和纸做有限次运算后就可以完成。  
从计算机专业角度来看，一个完整的算法应该具备如下三个基本要素：  
1) 基本运算和操作  
算法的实现形式有多种，但是这些实现形式都具有相同的基本运算和操作。这些基本运算和操作有以下四类：  
算术运算：加减乘除等运算；关系运算：大于、小于、等于、不等于等运算；逻辑运算：或、与、非等运算；数据操作：输入、输出、赋值等运算。  
2) 控制结构  
一个算法的功能结构不仅取决于所选用的操作，而且还与各操作之间的执行顺序紧密相关。算法的控制结构确定了算法的基本框架，决定着各个操作的执行顺序。算法控制结构有三种，即顺序结构、选择结构和循环结构。  
3) 数据结构  
在计算机领域，算法的操作对象是数据。为了方便快速的存取，数据一般以一些特定的结构进行存储，另一方面，具体实际问题及其数学模型的结构特点决定了数据之间总是存在着一些特定的逻辑关系或逻辑结构。这些存储结构和逻辑结构统称为数据结构。  
一个算法可以采用多种不同的形式进行表示，常用的表示方法有：自然语言、流程图、伪代码等。本书后面各章节的算法将主要采用伪代码进行描述，以利于读者将理论与实际相结合，通过自己亲自动手描述和实现算法，加深对算法的理解。  
伪代码不是真正编程语言，而是一种算法描述语言，使用介于自然语言和程序设计语言之间的文字符号来描述算法。使用伪代码描述算法，能够使被描述的算法可以容易地以任何一种编程语言实现。伪代码可以综合使用多种编程语言中的语法、保留字，甚至会用到自然语言。 因此，伪代码结构清晰，简单且易于修改，可读性较好，并且类似自然语言。"
值域,概念,"['第五章 关系模型与理论', '§ 5.1 关系的数学模型', '5.1.2  关系的概念']","{'实体类型': '概念', '定义': '由𝑅中所有序偶的第二元素构成的集合称为𝑅的值域，记作ran𝑅'}",,3,"现在我们使用序偶与笛卡尔积这两个概念建立表示两个元素之间二元关系的数学模型。首先考察一个具体实例：假设某个班级正在上离散数学课，教室里有100 个座位和85 名学生，那么教室里有些座位有学生坐、有些座位没有学生坐，如果某个座位被某个学生坐了，则称这个座位与这个学生有关系，否则称这个座位与这个学生没有关系，现在考虑要用什么样的数学模型来表示或定义这种学生与座位之间的二元关系。  
令集合$A$表示该教室所有学生组成的集合，集合B表示该教室所有座位组成的集合，则根据乘法原理，$A$与$B$的笛卡尔集$A\times B$就表示将这85 名学生分布到100 个座位上所有可能发生的状态，$A\times B$中每个元素$\langle x,y\rangle$就表示学生$x$与座位𝑦之间可能发生的一种关系，即学生$x$坐在座位𝑦上的一种可能发生的状态。显然，一共有$85\times100=8500$可能的状态。但是，这些状态一般不会都发生，事实上，此时实际发生的只有85 个状态，即学生和座位之间实际发生关系的有且只有$A\times B$中的85 个元素。因此，可以将$A\times B$中这85 个实际发生的状态作为集合来表示这85 名学生和100 个座位之间的关系。换句话说，这85 名学生和100 个座位之间的二元关系其实就是$A$与$B$的笛卡尔集$A\times B$的某个子集。  
也可以从另外一个角度理解这个问题：将集合$𝐴$和$B$分别看成是学生维度和座位维度这两个一维空间，则$𝐴$与$B$的笛卡尔集$A\times B$就表示由这两个维度的元素组合而成的二维空间。现从𝐴中任选一位学生$x$，从$B$中任选一个座位𝑦，让学生$x$坐到座位𝑦上，由此形成一个序偶$\langle x,y\rangle$。这个序偶对应着$A\times B$所形成二维空间的一个点，所有这样的点或者序偶显然构成了这个二维空间的一个子集合。另外一方面，所有这样的点或序偶组成的集合完全枚举了学生与座位实际发生的关系，故可将学生与座位之间的二元关系就定义为所有这样的序偶组成的集合。因此，座位和学生之间的二元关系其实就是$𝐴$与$B$的笛卡尔集$A\times B$的某个子集。  
在实际生活中，还有很多类似的例子。再如机票和座位之间对号关系，若令$X$为机票的集合，Y 为座位号的集合， $R$ 表示对号关系，则对任意$x\in X$和$y\in Y$，$x$与$y$ 之间有对号和不对号两种状态。若将$R$ 看成是一些序偶的某个集合或$X$与$Y$ 的笛卡尔集$X\times Y$的某个子集，则对于任意一个序偶$\langle x,\ y\rangle$， $x$与$y$具有对号关系当且仅当$\langle x,y\rangle\in R$。因此，可将这里的对号关系定义为序偶的某个集合或$X\times Y$的某个子集合。  
通过以上分析发现，可用序偶的集合或者笛卡尔集的某个子集合来构造二元关系的数学模型。据此得到如下关于二元关系的定义：  
【定义5.6】设$𝐴$, $B$是任意给定的两个非空集合，$R$是$A\times B$的任何一个给定的子集合，则称$R$ 是一个从$𝐴$到$B$的二元关系，简称为关系。也就是说，若$R\subseteq A\times B$，则称$R$是$𝐴$到$B$的一个二元关系，若$\ R\subseteq A\times A$，则称$R$是$𝐴$上的一个二元关系。特别地，若$R=\emptyset$，则称$R$ 为空关系；若$R=A\times B$，则称$R$ 为全关系。  
【定义5.7】设$𝐴$, $B$是任意给定的两个非空集合，$R$是$𝐴$到$B$的一个二元关系，对于$A\times B$中的任意一个序偶$\langle x,y\rangle$，若$\langle x,y\rangle\in R$，这称集合$𝐴$中的元素$x$与集合$\ B$中的元素$𝑦$之间具有关系$R$；若$R$是$𝐴$上的一个二元关系且$\langle x,y\rangle\in R$，则称集合𝐴中的元素$x$与$𝑦$之间具有关系$R$。  
由上述两个定义可以看出，我们以集合为基本工具通过确定关系外延的方式给出关系概念的数学定义。这样就不必用数学符号来表示关系概念的内涵。事实上，对于有些关系，即使用自然语言也无法清楚表达其复杂的内涵。  
![](images/f21a296fae3e098faaa3900cc4615cee3ba4531b4f17c607a85fa8fb673d5d95.jpg)
图5-1 关系的五个域  
如图5-1 所示，集合$C$和$D$满足：$C=\{x|\langle x,y\rangle\in R\}$；$D=\{y|\langle x,y\rangle\in R\}$。此时称$C$为$R$ 的定义域，记为$C=\mathsf{d o m}R$；称$D$为$R$ 的值域，记为$D=ranR$；$A$ 为$R$ 的前域，$B$ 为$R$ 的后域，并称$\mathrm{fld}R=D\cup C$为$R$ 的域。一般地，我们有如下定义：  
【定义5.8】设$𝐴$, $B$是任意给定的两个非空集合，$R$是$𝐴$到$B$的一个二元关系，则有：称$A$是$R$的前域， $B$是$R$的后域；由$R$ 中所有序偶的第一元素构成的集合称为$R$ 的定义域，记作$dom𝑅$，即有$\mathrm{dom}R=\{x|\langle x,y\rangle\in R\}$；由$R$ 中所有序偶的第二元素构成的集合称为$R$ 的值域，记作$ran𝑅$，即有$\mathrm{ran}R=\{y|\langle x,y\rangle\in R\}$；称$\mathrm{fld}R=\mathrm{dom}R\cup\mathrm{ran}R$为$R$ 的域。"
偏序关系,概念,"['第六章 特殊关系模型', '6.4.2 得分评判问题', '6.4.1 粗集定义问题', '6.3.3  全序与良序', '§ 6.3 偏序关系与元素比较', '6.3.1 偏序关系与哈斯图']","{'实体类型': '概念', '定义': ['刻画对象之间在某些方面的差异性，建立具有层次性的离散结构', '设R为非空集合A上的一个二元关系，如果R满足自反性、反对称性和传递性，则称R是A上的一个偏序关系，简称为偏序，记为≤，读作小于等于或先于', '集合上的一个关系，不保证任意两个元素之间都存在序关系', '在集合中定义的一种关系，用于描述元素之间的顺序关系，但不是全序关系', '任何排名次必是一个偏序关系'], '特点': ['最为典型且相对复杂', '集合中的部分元素之间存在这种序关系', '在很大情况下应是线性关系'], '应用': ['日常生活和工作中常用的序关系之一', '在排名场合（如歌手大赛考评等）使用“0-1”法记分，并利用偏序关系的反对称性进行动态排名'], '示例': '集合A={2,4,6,8}上的整除关系'}",,2,前面讨论的等价关系和相容关系主要刻画对象之间的在某些方面的无差异性或存在某些共性特征。序关系刻画则是对象之间的在某些方面差异性，通过对集合中元素之间的差异性比较建立一种具有层次性的离散结构。日常生活和工作中常用的序关系有很多种，包括拟序关系、偏序关系、全序关系和良序关系等，其中的偏序关系最为典型也相对复杂，本节着重介绍偏序关系的相关知识。如果掌握了偏序关系的概念和性质，那么对拟序关系、全序关系和良序关系等其它序关系知识的学习问题就可迎刃而解。
偏序关系模型,概念,['第六章 特殊关系模型'],"{'实体类型': '概念', '作用': '与元素的比较'}",,1,前面学习了关系模型的概念及其五个基本性质。不难发现，日常生活或工作中很多关系虽然从表面上看形态各异、互不相同，但都满足一些相同的基本性质。例如集合之间的相等关系、直线之间的平行关系、多边形之间的全等关系、学生同学关系、整数之间的同余关系等等，它们都满足自反性、对称性和传递性这三条基本性质。我们自然会想到把所有满足这三条性质的关系归为一类特殊关系，并考察这类关系有什么特殊性质和特殊作用，以便在大量错综复杂的具体关系中找到一些共性特征和规律性认识。同样，还有一些关系满足另外一些基本性质，例如集合之间的包含关系、整数之间的整除关系、实数之间的大小关系、英文单词之间的字典排序关系等等，这些关系虽然表面上互不相同、各不相关，但它们都满足自反性、反对称性和传递性这三条基本性质。我们自然会将所有这类关系归为另外一类特殊关系，并考察这类关系有什么相应的特殊性质和特殊作用。通过以上分析，不难得到研究关系的一个普适性方法，就是以关系模型的五个基本性质为标准，将所有关系按它们对这些基本性质满足程度和状态的不同划分为若干特殊类型，然后分门别类地研究同类型关系的共同性质和不同类型关系之间的区别与联系，由此构建各种特殊关系模型及相关理论。显然，通过状态组合构造出的特殊关系有很多，不便一一枚举。作为代表，本章着重介绍其中三种最典型、最基本的特殊关系模型，并分别讨论它们各自的作用，即等价关系模型与元素的分类、相容关系模型与元素的聚类、偏序关系模型与元素的比较。
偏序子格,概念,"['第十二章 典型抽象代数结构', '§ 12.5 格的概念与性质', '12.5.2 格的基本性质']","{'实体类型': '概念', '定义': '设⟨L,≤⟩是一个格，S⊆L，若S满足：1) S≠∅；2) 对∀a,b∈S，⟨L,≤⟩的保交和保联运算都有：a*b=GLB{a,b}∈S；a⊕b= LUB{a,b}∈S'}",,3,"对偶性是格结构最基本的特征。考察格的基本性质一般从格结构的对偶特征入手。从偏序关系的角度看，格$\langle L,\leq\rangle$结构在集合 $L$上定义的偏序关系$\leq$显然是可逆的。具体地说，对于集合$ L$上的偏序关系≤，其逆关系$\geq$也是集合$ L$上的偏序关系。由于将偏序集$\langle L,\leq\rangle$的哈斯图做一个上下翻转就得到偏序集$\langle L,\geq\rangle$的哈斯图，故对集合$L$的任意子集$𝐴$，$A$在偏序$\langle L,\leq\rangle$中的上确界是$𝐴$在偏序$\langle L,\geq\rangle$中的下确界，$A$在$\langle L,\leq\rangle$中的下确界是$𝐴$在$\langle L,\geq\rangle$的上确界。因为二元关系的逆关系保持原关系的自反性、反对称性和传递性不变，所以$\langle L,\geq\rangle$也是格。  
通常将格$\langle L,\leq\rangle$和格$\langle L,\geq\rangle$称为互为对偶的格。对偶格之间具有紧密联系，例如格$\langle L,\leq\rangle$的保交运算对应格$\langle L,\geq\rangle$的保联运算，反之亦然。假如在格$\langle L,\leq\rangle$和格$\langle L,\geq\rangle$中，$*$和$\oplus$分别代表格的下确界和上确界运算，如果在关于$\langle L,\leq\rangle$的命题中，分别用$*$、⊕、$≤$代替关于$\langle L,\geq\rangle$命题中的⊕、$∗$、$≥$，那么两个命题的真伪必定保持一致性。这就是对偶原理。  
【定理12.33】设$\langle L,\leq\rangle$是任意给定的一个格，关系“$≤$”是“$\geq\!\!$的逆关系，则对$\forall$ $a,b,c,d\in$$L$，有如下14 条基本性质：  
（1）自反性：  $a\leq a;\ \ a\geq a.$  
（2）反对称性：$a\leq b$且$b\leq a\Rightarrow a=b$；$a\geq b$且$b\geq a\Rightarrow a=b$.  
（3）传递性  $a\leq b$且$b\leq c\Rightarrow a\leq c$；$a\geq b$且$b\geq c\Rightarrow a\geq c$.  $(4)a*b\leq a;\;\;a\oplus b\geq a;\;\;a*b\leq b;\;\;a\oplus b\geq b.$  
（5）$c\leq a$且$c\leq b\Rightarrow c\leq a*b$；$c\geq a$且$c\geq b\Rightarrow c\geq a\oplus b$.  
（6）交换律：  $a*b=b*a;\ a\oplus b=b\oplus a$  
（7）结合律：  $a*(b*c)=(a*b)*c;\;\;a\oplus(b\oplus c)=(a\oplus b)\oplus c$  
（8）吸收律：  $a*(a\oplus b)=a;\ a\oplus(a*b)=a.$  
（9）幂等律：  $a*a=a;\;\;a\oplus a=a.$  
(10)  $a\leq b\Longleftrightarrow a*b=a\Longleftrightarrow a\oplus b=b\,.$  
（11）$a\leq b$且$c\leq d\Rightarrow a*c\leq b*d$；$a\leq b$且${\mathfrak{c}}\leq d\Rightarrow a\oplus c\leq b\oplus d$.  
（12）偏序对运算的保序性：  $a\leq b\Rightarrow a*c\leq b*c;\;\;a\leq b\Rightarrow a\oplus c\leq b\oplus c$  
（13）确界运算对偏序的分配不等式：
$$
a\oplus(b*c)\leq(a\oplus b)*(a\oplus c);\,\,\,a*(b\oplus c)\geq(a*b)\oplus(a*(c)
$$  
（14） 确界运算对偏序的模不等式：$a\leq c\Longleftrightarrow a\oplus(b*c)\leq(a\oplus b)*c$  
格是一个特殊的代数系统，那么是否存在子格和格同态呢，答案是肯定的。设集合$𝑆$是集合$ L$的子集，从格的定义角度出发，格要求运算必须满足交换律、结合律和吸收律，如果这些运算律在集合$L$上满足，那么在$𝑆$上也一定满足，因此只要集合$𝐴$是非空的，且运算在$𝑆$上满足封闭性，那么$𝑆$就为$L$的子格。一般地，有如下的定义：  
【定义12.28】设代数系统$\langle L,*,\oplus\rangle$是一个格，对于$L$的任意一个非空子集$𝑆$，若运算$*$和$\oplus$在$𝑆$上的满足封闭性，则称$\langle S,*,\oplus\rangle$是$\langle L,*,\oplus\rangle$的一个子格，简称$𝑆$是$L$的子格。  
上面给出了代数格的子格定义，那么对于偏序格的子格又改如何定义呢。事实上若非空集合$\textstyle S\subseteq L$，且$\langle L,\leq\rangle$是偏序格，由第六章的偏序关系知道$\langle S,\leq\rangle$一定是偏序集，甚至也可能是格，但不一定是子格，因为子格要对运算封闭。由此得到如下偏序子格的定义：  
【定义12.29】设$\langle L,\leq\rangle$是一个格，$S\subseteq L$，若𝑆满足：  
（1）$S\neq\emptyset$；（2）对$\forall\;\;a,b\in S,\;\;<L,\leq\;>$的保交和保联运算都有： $a*b=G L B\{a,b\}\in S;\;\;a\oplus b=L U B\{a,b\}\in S$  
则称$\langle S,\leq\rangle$是$\langle L,\leq\rangle$的一个子格，简称$𝑆$是$L$的子格。  
利用代数系统中的同态和同构概念，分别可以得到格的同态和同构的定义：  
【定义12.30】设$\langle L,\land,\lor\rangle$和$\langle S,*,\oplus\rangle$是两个格， $f$是从$L$到$𝑆$的映射，若对$\forall\;\;x,y\in L$，有：  
$$
f(x\wedge y)=f(x)*f(y);\ f(x\vee y)=f(x)\oplus(y)
$$  
则称 $f$ 为从格 $\langle L,\land,\lor\rangle$ 到格 $\langle S,*,\oplus\rangle$ 的格同态映射，简称格同态。如果 $f$ 分别是单射、满射和双 射，$f$分别称为单格同态、满格同态和格同构，将格$ L$到$L$的同态称为$ L $的自同态。"
偏序格,概念,"['12.5.1 偏序格与代数格', '§ 12.5 格的概念与性质', '第十二章 典型抽象代数结构']","{'实体类型': '概念', '定义': '对偏序集⟨L,≤⟩中的任意两个元素a,b，如果集合{a,b}恒存在上确界(𝐺𝐿𝐵)和下确界(𝐿𝑈𝐵)，则称偏序集⟨L,≤⟩是一个偏序格', '特点': '存在运算，对于偏序格⟨L,≤⟩中任意两个元素a,b构成的集合{a,b}，其上确界和下确界唯一存在且均属于L'}",,2,格是一种非常特殊的代数结构。如前所述，数学主要有偏序、代数、拓扑和测度这四大基本结构，格结构同时具备偏序结构和代数结构，并与拓扑结构具有非常紧密的联系。不过从本质上看，格仍属于代数结构。格结构在密码学、计算机语义学、开关理论、逻辑设计等多个领域都具有非常重要的应用。本节主要介绍格的基本概念与性质，包括偏序格与代数格的概念、格结构的基本性质、格同态与同构以及若干常用的特殊格。
偏序格与代数格的等价性,定理,"['第十二章 典型抽象代数结构', '§ 12.5 格的概念与性质', '12.5.1 偏序格与代数格']","{'实体类型': '定理', '结论': '偏序格和代数格的定义是等价的，任何一个偏序格都存在一个与之对应的代数格，并且任意一个代数格也存在一个与之对应的偏序格'}",,3,"格的特殊性主要是在代数结构中引入偏序关系，一个格结构，既可从偏序角度借助哈斯图直观地表示格结构，也可从代数角度通过子代数、同态和同构策略等分析讨论格结构。我们首先分别定义偏序格和代数格的概念，然后在证明这两个概念是等价的。首先给出偏序格的定义，具体如下：  
【定义12.26】对偏序集$\langle L,\leq\rangle$中的任意两个元素$a,b$，如果集合$\left\{a,b\right\}$恒存在上确界$(G L B)$和下确界$（𝐿𝑈𝐵）$，则称偏序集$\langle L,\leq\rangle$是一个格，或称为偏序格。  
我们知道，对于任意给定的一个偏序集$\langle L,\leq\rangle$，其中的任意两个元素所构成的子集不一定存在上确界或下确界，否则该偏序集就是偏序格。  
既然格是一种特殊的代数系统，那么这种偏序格一定存在运算。利用格的定义和偏序关系的反对称性不难证明：对于偏序格$\langle L,\leq\rangle$中任意两个元素$a,b$构成的集合$\{a,b\}$，其上确界和下确界唯一存在且均属于$ L$。因此，可用$a*b$表示集合$\{a,b\}$的下确界，称为$a$和$b$的保交，用$a\oplus b$表示集合$\left\{a,b\right\}$的上确界，称为a 和$b$ 的保联。$*$和⊕即为偏序格的两个二元运算，即：  
$$
a*b=G L B\{a,b\},\;\;a\oplus b=L U B\{a,b\}
$$  
有时也用∩和∪、$*$和$+、\wedge$和$\vee$分别表示保交和保联。  
例如，设$ Z^{+}$是正整数集合，在$Z^{+}$上定义一个二元运算“|”，对于$a,b\in Z^{+}$，$a|b$当且仅当$a$整除$b$。容易验证运算“|”是$Z^{+}$上一个偏序关系，故$\langle Z^{+},|\rangle$是偏序集。由于该偏序集中任意两个元素的最小公倍数和最大公约数就是这两个元素的最小上界和最大下界，因此，$\langle Z^{+},|\rangle$是格。再如，设$\varphi(S)$是给定集合$𝑆$的幂集，$\langle\varphi(S),\subseteq\rangle$是一个偏序集，则对于于$\varphi(S)$中的任意两 个元素$ S_{1}$，$S_{2}$，其最大下界为$S_{1}\cap S_{2}$，最小上界为$S_{1}\cup S_{2}$，所以$\langle\varphi(S),\subseteq\rangle$是格。  
从代数的角度出发，有如下关于格的定义：  
【定义12.27】设$\langle L,\land,\lor\rangle$是具有两个二元运算的代数系统，若对于$\forall a,b,c\in L$，满足：  
交换律：$a\vee b=b\vee a$， $a\wedge b=b\wedge a$；  
结合律：$a\lor(b\lor c)=(a\lor b)\lor c,\;\;a\land(b\land c)=(a\land b)\land c;$  
吸收律：$a\vee(a\wedge b)=a$，$a\wedge(a\vee b)=a$；  
则称$\langle L,\land,\lor\rangle$是一个格，或称为代数格。  
可以证明代数格还满足幂等律。事实上，对于$\forall a\in L_{\prime}$,有：  
$$
a\wedge a=a\wedge(a\vee(a\wedge a))=a;\enspace a\vee a=a\vee(a\wedge(a\vee a))=a
$$  
即有$a\wedge a=a$和$a\vee a=a$成立。  
下面的定理表明偏序格和代数格是等价的。  
【定理12.32】偏序格和代数格的定义是等价的。换言之，任何一个偏序格都存在一个与之对应的代数格，并且任意一个代数格也存在一个与之对应的偏序格。"
偏序集,概念,"['第六章 特殊关系模型', '§ 6.3 偏序关系与元素比较', '6.3.1 偏序关系与哈斯图']","{'实体类型': '概念', '定义': '如果集合A上有偏序关系R，则称A为是一个偏序集，记为⟨A,≤⟩'}",,3,"次序是日常生活和工作中经常遇到的一种关系，例如体育竞赛中的排名、全国高校排名、家族的长幼辈分、某单位的行政职位的级别、实数之间的大小关系、集合之间的包含关系、自然数集合上的整除关系等等，都是次序关系，刻画的是对象之间在某个方面的差异性比较关系。现在我们用数学方法来表示和处理这种序关系。  
我们知道，某集合幂集上的包含关系满足自反性、反对称性和传递性，自然数集合上的整除关系也满足自反性、反对称性和传递性。将这类关系抽象出来，可得到一种名为偏序关系的特殊关系，其具体定义如下：  
【定义6.9】设$R$非空集合$𝐴$上的一个二元关系，如果$𝑅$满足自反性、反对称性和传递性，则称 $R$是$𝐴$上的一个偏序关系,简称为偏序，记为$\preccurlyeq$，读作小于等于或先于。对于𝐴上的任意两个元素$x,y$，如果序偶$\langle x,y\rangle\in R$，则称$x$与𝑦可比且$x$前于$y$或$x$先于$ y$，记为$x\preccurlyeq y$。如果集合$𝐴$上有偏序关系$R$，则称$;A$为是一个偏序集,记为$\langle A,\preccurlyeq\rangle$。  
从上述定义可知，定义中小于等于或先于的含义并不一定是指数的大小，主要是指偏序关系中的顺序，$x$小于等于或先于$ y$的具体含义是：依照这个序关系$x$排在𝑦的前面或者$x$就是$y$。此外，定义中并没有保证$𝐴$中任意两个元素之间都必须具有这种序关系。这正是偏序的含义。所谓偏序,就是集合中的部分元素之间存在这种序关系。  
例如，集合$ A=\{2,4,6,8\}$上的整除关系为：  
$$
R=\{\ \langle2,2\rangle,\langle2,4\rangle,\langle2,6\rangle,\langle2,8\rangle,\langle4,6\rangle,\langle4,8\rangle,\langle6,6\rangle,\langle8,8\rangle\}
$$  
显然关系$R$具有自反性、反对称性和传递性，故为偏序关系。$\langle A,R\rangle$是一个偏序集。在这个偏序集中，4和8是可比的且4 先于8，而4 和6是不可比的。  
【定义6.10】设$𝑅$非空集合$𝐴$上的一个二元关系，如果$R$满足反自反性、反对称性和传递性，则称$𝑅$是$𝐴$上的一个拟序关系或半序关系,简称为拟序或半序，记为$\prec$，读作小于。对于$𝐴$上的任意两个元素$x,y$，如果序偶$\langle x,y\rangle\in R$，则称$x$与$𝑦$可比且$$x$$小于$ y$，记为$x\prec y$。如果集合$𝐴$上有偏序关系$R$，则称$𝐴$为是一个拟序集或半序集,记为$\langle A,\prec\rangle$。  
从上述定义可知，定义中小于的含义并不是指数的大小，而是指偏序关系中的顺序，$x$小于𝑦的含义是：依照这个序关系$x$排在𝑦的前面。显然，拟序关系的自反闭包就是偏序关系。因此，偏序关系是拟序关系一种扩充，拟序关系是偏序关系的一种缩减。例如，实数集上的实数小于关系就是一种拟序关系，小于等于关系则是一种偏序关系。"
元素,概念,"['§ 1.1 集合的基本知识', '1.1.2 集合的概念与表示', '一、集合与元素的概念', '第一章  集合与计数基础']","{'实体类型': '概念', '定义': '集合中的基本单位，集合中的每个对象称为该集合的元素', 'name': '元素'}",,3,集合论从一个比数更加基本的概念——集合出发，定义出数和数的运算，进而演化出整个数学学科的理论体系。本小节将从集合的基本概念出发，介绍集合论中最为基础的知识，包括集合概念的含义、元素的概念与性质、集合的表示方法、集合之间的相等与包含关系、若干常用的特殊集合等。
元素方幂,概念,"['第十二章 典型抽象代数结构', '§ 12.1 半群的概念与性质']","{'实体类型': '概念', '定义': '半群中的元素通过多次运算得到的结果'}",,2,"与群相关的抽象代数结构有很多个，其共同特征是只含一个二元运算，具体包括广群、半群、含幺半群、群、交换群等。如图12-1 所示，这些抽象代数结构按照由一般到特殊的次序逐步递进。其中：广群是最具一般性，只需满足运算的封闭性即可，其实就是一般的只含一个二元运算的代数结构或代数系统；半群则比广群稍微特殊一些，即在广群的基础上增加一个满足结合律的限制；含幺半群则是在半群的基础上再增加存在单位元的限制；群则是在含幺半群的基础上再增加存在逆元的限制，即要求半群不仅含有单位元，而且还必须保证载体集合中每个元素都必须含有逆元；交换群则是一种满足交换律的特殊群。  
![](images/c6e03e109e469ca83f4980264e0b87779198ee1bcaf3a206ea39fe5f280b87e9.jpg)
图12-1 与群相关的抽象代数结构  
我们将按照图12-1-1 所示次序展开讨论，其中广群作为最一般的代数结构在前面第十一章已做介绍。因此，本节着重介绍半群的基本理论，主要包括半群、含幺半群、元素方幂、循环半群的基本概念与性质。"
元素比较,概念,"['第六章 特殊关系模型', '§ 6.3 偏序关系与元素比较', '6.4.1 粗集定义问题']","{'实体类型': '概念', '定义': '在偏序关系下，对集合中元素进行大小或顺序的比较'}",,3,"现实世界中很多对象群体的边界是很模糊或者不确定的，例如，对于“中年人”这样的群体，怎样用集合或者其它数学工具进行描述？如果将“中年人”这个群体看出是一个集合$𝑆$的话，则$𝑆$就不是经典意义下的集合，因为其成员不确定。事实上，可以使用两个经典集合来刻画$𝑆$，一个叫做$𝑆$的上近似集合${S}\uparrow$，一个叫做$𝑆$的下近似集合$ S\downarrow$，让前者$𝑆↑$尽可能的小，后者$𝑆↑$尽可能的大。当$𝑆↑$能够等同于$𝑆↓$时,$S$就是经典集合，当$𝑆↑$不能够等同于$𝑆↓$时，则称$𝑆$是粗糙集或粗集。例如，可以用$S\uparrow=\{x|25\le x\le60\}$，即用25 岁至60 岁的人的集合，表示“中年人的集合”；还可以用$S\downarrow=\{x|30\le x\le50\}$，即用30 岁至50 岁的人的集合，表示“中年人的集合”。由于无法构造适当的“中年人的集合”的上下近似$S\uparrow=S\downarrow$，因此，“中年人的集合”$𝑆$是一个粗糙集。  
那么如何用准确的数学语言来定义粗糙集呢？下面通过等价关系给出粗集准确的数学定义。设$U$是个体域（或全集），$R$是$U$上的等价关系，则可由$R$导出的$U$的一个划分，如图$6-$$24\left(a\right)$所示，每个方格表示划分的一个单元，也就是一个$ R$等价类。  
如图$6–24\left(b\right)$所示，若$𝑆$是粗糙集，则$𝑆$的上下近似分别是两个粗线条勾画出的多边形，其中$S\uparrow$由与$𝑆$交不空方格的并组成，$S\downarrow$由包含于$𝑆$的方格并组成。  
![](images/05225fe2f04f5f432dc9b2bbf25b62263d90d0d724be9df376f08ea318717259.jpg)  
通过以上分析，就可以给出粗糙集𝑆的定义：  
【定义6.18】设$U$是个体域(或全集)，$R$是$U$上的等价关系，已知$𝑆$的成员均在$U$中。令： ${\begin{array}{l l}{S\uparrow=\cup\,\{[x]_{R}|[x]_{R}\cap S\neq\emptyset\}}&{;\;\;S\downarrow=\cup\,\{[x]_{R}|[x]_{R}\subseteq S\}}\end{array}}\quad\text{(6-4)}$  
那么称$S\uparrow$为$𝑆$的上近似，$S\downarrow$为$𝑆$的下近似。当$\textit{S}\uparrow=\textit{S}$↓时，$S$即是$U$的子集；当$S\uparrow\ne\textit{S}\downarrow$时，称 $𝑆$ 是 $U$ 的粗糙子集，简称为粗糙集或粗集。  
例如，表是考生情况调查表，其中$U$为被调查对象，$R$为高考成绩$(A-$优，$B-$良，$C-$中，$D-$差)；$X$为升学情况($+$为上，$/$为未上)。可根据高考成绩和升学状况进行分类，并可分别计算出下近似集、上近似集。  
表6-3 对集合𝑈的两种划分
![](images/23b7c96f86908a1723f3af9fc2fde337caca13329476de93665a25a8e36ee553.jpg)  
![](images/1cdfc65fbfddc11bcd85c455f6521676d2bf7ff363efa7f28d82ea21a3e04ed5.jpg)  
事实上，可分别按成绩和升学对$U$进行划分：  
$U/R=\{\{1,6\},\{2\},\{3,5\},\{4\}\}=\{Y_{1},Y_{2},Y_{3},Y_{4}\};\quad U/X=\{\{2,3,5,6\},\{1,4\}\}=\{X_{1},X_{2}\}$ 分别得到粗糙集$S$的上近似和下近似集合：  
$$
S(X_{1})\uparrow=Y_{1}\cup Y_{2}\cup Y_{3}=\{1,2,3,5,6\}\;\;;\;\;\;S(X_{2})\uparrow=Y_{1}\cup Y_{4}=\{1,4,6\};
$$  
$$
S(X_{1})\downarrow=Y_{2}\cup Y_{3}=\{2,3,5\}\;\;;\;\;\;S(X_{2})\downarrow=\;\;Y_{4}=\{4\}。
$$  
粗糙集可以表示含义模糊且不太确定的概念，大大拓广了经典集合的概念和应用范围，更为重要的是，粗糙集可由经典集合借助等价关系进行定义，具有坚实的理论基础。目前，粗糙集理论在模式识别、数据挖掘等技术领域得到广泛应用。"
元素聚类,概念,"['第六章 特殊关系模型', '§ 6.2 相容关系与元素聚类']","{'实体类型': '概念', '定义': '对集合中的元素进行聚类，同一元素可同时聚合到多个不同的类别', '区别': '与元素分类的主要区别在于同一元素可属于多个类别', '应用': '问题求解方法，用于计算机数据分析相关领域'}",,2,"相容关系，顾名思义就是一种能求同存异的关系，表示对象之间存在一些相同点或共性,例如国家之间的共同利益、人与人之间的共同兴趣爱好等。日常工作和生活中人与人之间的朋友关系、英文单词之间存在共同字母的关系等都可看成是相容关系。与等价关系相比，相容关系所表示对象之间的联系显然要弱一些，因为等价关系要求的是对象之间完全相同或相等。类似于等价关系可构造对集合的划分，相容关系则可构造对集合的覆盖。与划分不同的是构成集合覆盖的各个相容类之间的交集可以为非空。也就是说，集合中的同一元素可同时属于多个不同相容类。这相当于对集合中的元素进行聚类,因为在集合元素的聚类过程中，同一元素可同时聚合到多个不同的类别当中。这是元素聚类与元素分类的主要区别。聚类是有别于分类的另外一种非常重要的问题求解方法，可用于计算机数据分析相关的很多领域，例如数据挖掘和目标识别中的聚类分析等等。本节主要介绍相容关系的基本知识，主要包括相容关系与相容类的概念和性质、集合覆盖与完全覆盖的相关知识。"
先根遍历算法,算法,"['第九章  树的基本理论与算法', '§ 9.2 根树的基本知识', '9.2.2 根树的基本算法']","{'实体类型': '算法', '步骤': '首先递归访问根结点，然后递归访问根的左子树，最后递归访问根的右子树'}",,3,"对于根树，一个十分重要的问题是要找到一些方法能系统地访问树的结点，使得每个结点恰好访问一次，这就是根树的遍历问题。由于二元树在计算机中最易处理且任意根树都可转化为二元树，因此在$k$元树中，应用得最广泛的是二元树。下面先介绍二元树的三种常用的遍历方法，然后介绍如何将任意根树转化为二元树。  
二元树的遍历算法主要有先根遍历算法、中根遍历算法和后根次序遍历算法，这三种算法都是采用递归的方式进行：  
先根遍历算法，顾名思义就是首先递归访问根结点；然后递归访问根的左子树，最后，就递归访问根的右子树；中根遍历算法，首先递归访问根的左子树；然后递归访问根结点；最后递归访问根的右子树；后根遍历算法，首先递归访问根的左子树；然后递归访问根的右子树；最后递归访问根结点。"
克鲁斯卡尔算法,算法,"['第九章  树的基本理论与算法', '§ 9.1 无向树的基本知识', '9.1.3  最小生成树']","{'实体类型': '算法', '正确性证明': '定理9.5证明了克鲁斯卡尔算法的正确性，保证了该算法构造的任何生成树都是最小生成树'}",,3,"为了更好地了解理解最小生成树的概念，我们首先考察一个具体应用实例：对于图9-7所示的带权图𝐺表示在某地6 个小区结点之间修建能源管道的费用预算情况(单位为万元)，图中每条边的权表示在该边两个端点之间修建管道的费用预算，问题是如何在保证这6 个小区连通的前提下使用最少的管道修建费用。  
![图 9-7   带权无向连通图及其最小生成树  ](images/69b981817af345f5a438b8a88bfbbbd31ee6159c07c4129830a99641d06e89d2.jpg)  
显然，如果所修建的所有管道能够构成$G$的一个生成树，就能满足小区之间的连通性要求。但是，图$G$有多个不同的生成树，并且对于不同的生成树，其边也不完全相同，从而修建的总费用会有一些差异。因此，通常希望能够找到一个修建总费用达到最小的生成树，即各树枝权的总和为最小的生成树，由此得到如下最小生成树的概念：  
【定义9.3】设假设$G=\langle V,E,W\rangle$是任意给定的一个连通无向赋权图模型，𝑇是𝐺的一棵生成树，𝑇的每个树枝所赋权值之和称为𝑇的权，记为$\omega(T)$。图$G$中具有最小权的生成树称为$G$的最小生成树。  
例如，图9-7(b)所示的带权树就是图9-7(a)所示带权图的最小生成树。因此，在保证小区连通前提下管道修建费用最少为$10+10+7+6+5=38$(万元)。  
需要注意的是，由于一个无向图的生成树不唯一。因此，一般不能保证一个赋权图的最小生成树一定是唯一的。但生成树的最小权一定是唯一的，对于不同的最小生成树，它们的权肯定彼此相等并且都等于最小权。  
下面介绍连通无向赋权图的最小生成树构造方法。求赋权图最小生成树的方法很多，其中最常见的主要是普莱姆算法和克鲁斯卡尔算法。  
普莱姆算法基于贪心策略，从图中任意一个结点开始，每次选择增加一条权最小的边构成一棵新树，基本思路就是每次在所有一端已经入选一端未入选的边中，选择权值最小的边加入且不构成回路。算法的具体过程如下：  
（1）从$G$中任意选取一个结点$v_{1}$，置$V_{T}=\{v_{1}\}$，$E_{T}=\varnothing$，$k=1$ 。  
（2）在$V-V_{T}$中选取与某个$v_{i}\in V_{T}$邻接的结点$v_{j}$，使得边$(v_{i},\ v_{j})$的权最小，置$V_{T}=$${T}\cup\{v_{j}\},\;\;E_{T}=E_{T}\cup\{(v_{i}\,,\;\,v_{j})\},\;\;k=k+1.$  
（3）重复步骤(2)，直到$k=|V|$。  
在普莱姆算法的步骤(2)中，若满足条件的最小权边不止一条，则可从中选择一条。由此会产生不同的最小生成树。  
对于图9-7 所示带权图使用普莱姆算法构造其最小生成树的具体过程如图9-8 所示：  
![图9-8 普莱姆算法构造最小生成树](images/8a0f2320ecde8e2695b2e2cead9370c247645fefffa9f77fa84c367a18def480.jpg)  
由于普莱姆算法基于贪心策略， 每次循环只考虑本次选择的最优结果， 而不考虑下次如 何选择，是一种局部最优算法。因此，必须证明算法的正确性。下面定理9.4 证明了普莱姆算法的正确性，保证了该算法可通过不断计算局部最优值获得整体最优值。  
【定理9.4】假设$G=\langle V,E,W\rangle$是任一给定的连通无向赋权图，则由普莱姆算法构造的任何生成树$T=G\{e_{1},e_{2},\ldots,e_{n-1}\}$都是$G$的最小生成树，其中$n$为$G$的结点数。  
![图9-9 普莱姆算法构造最小生成树  ](images/75143a931b95de54e246d3f0ca5e18faed40466b8fb351a6ce6667aea6eaa5e2.jpg)  
![图9-9 普莱姆算法构造最小生成树  ](images/56147ba86dfc989b0cbc43dab1318a7a4a9458fc90e3612e58f3bc1a780819cd.jpg)  
【定理9.5】假设$G=\langle V,E,W\rangle$是任一给定的连通无向赋权图，则由克鲁斯卡尔算法构造的任何生成树$T=G\{e_{1},e_{2},\ldots,e_{n-1}\}$都是$G$的最小生成树，其中$n$为𝐺的结点数。"
全序关系,概念,"['第六章 特殊关系模型', '§ 6.3 偏序关系与元素比较', '6.3.3  全序与良序']","{'实体类型': '概念', '定义': '对于偏序集，如果任意两个元素都是可比的，则称该偏序关系为全序关系或线序关系', '特点': '全序关系必定是偏序关系，偏序关系则不一定是全序关系'}",,3,"前述集合$𝐴$上偏序关系并不保证$𝐴$上的任何两个元素之间都是可比的，也是就是说并不保证任何两个元素之间都存在序关系。然而，在很多场合我们都需要对所关心的所有对象排个次序，例如体育比赛中的种子选手排名、全国各高校的综合排名、大会嘉宾代表的入场次序等等，都需要对所有对象进行排序。现有偏序关系模型显然不能正确表示和处理这类问题。故须加强偏序关系约束条件，在偏序关系基础上引入全序关系，其具体定义如下：  
【定义6.14】对于偏序集$\langle A,\preccurlyeq\rangle$，如果$𝐴$中任意两个元素${x}$和$\boldsymbol{y}$都是可比的，即$x\preccurlyeq y$或者$y\preccurlyeq x$，则称该偏序关系为全序关系或线序关系，简称为全序或线序。并称$\langle A,\preccurlyeq\rangle$为全序集或线序集，也可称为集合$𝐴$的链。  
由上述定义可知，全序关系必定是偏序关系，偏序关系则不一定是全序关系。  
可用全序的概念定义偏序集$\langle A,\preccurlyeq\rangle$的一些特殊子集合，具体定义如下：  
【定义6.15】设$\langle A,\preccurlyeq\rangle$是一个偏序集，$B$是$𝐴$的任一子集，如果$𝐵$中任意两个元素都是可比的，则称$B$是$𝐴$的一条链，$B$中元素的个数称为该链的长度；反之，如果$B$中任意两个元素都是不可比的，则称 $B$是$𝐴$的一条反链，$B$中元素的个数称为该反链的长度。对于$𝐴$中由单个元素组成的集合，规定它既是链也是反链。  
例如，在偏序集〈{1,2,3,4,5,6,7,8,9}, |〉中，{1,2,4,8}是一条长度为4 的链，{2,4}是一条长度为2 的链，{2,3}则是一条长度为2 的反链。  
偏序集中的链表达了偏序集中部分元素之间存在全序关系，反链则表达了偏序集中部分元素相互之间不存在任何序关系。显然，链表达的是一种串行执行结构，反链表达的是一种并行执行结构。因此，可以使用偏序集中链和反链的概念优化实际问题求解的业务流程，有效提高问题求解的工作效率。  
![](images/18f7caa4d0b707d1ff49eb6f7a547c82b50926bf7ba3ab409aa786a7fcff2f4c.jpg)
图6-22 保险索赔业务流程  
例如，图6-22 是一个关于保险索赔的流程图。图中方框代表处理流程中业务，圆圈代表某种分支选择。将流程中循环抽象成一个单一的结点，如用单个结点𝑇代替流程图中业务$T_{7}$、$T_{8}$及其后的分支结点。由此得到的所有结点构成集合$𝐴$，在该集合元素之间定义如下偏序关系≼：对$\forall x,y\in A$，当且仅当$x=y$或者$𝑦$必须在$x$完成后才能开始时，成立$x\preccurlyeq y$。如此，集合$𝐴$与其上的偏序关系$\preccurlyeq$便构成一个偏序集$\langle A,\preccurlyeq\rangle$，  
图6.23 为其哈斯图。  
考虑偏序集中的链，最长链有4 条，其中2 条分别是：  
$\{T_1,T_2,T_3,S_1,T_6,,S_2,T,T_{10}\}; \{T_1,T_2,T_3,S_1,T_6,,S_2,T_9,T_{10}\}$  
长度都是8。显然，最长链的长度代表了整个流程中必须顺序执行的任务最多有多少个。如果完成每项任务的时间差距不大，那么这种最长链就反映了完成整个任务的最少时间。  
![](images/598fd43b47030dd50e3aa3bc789da0841fc0eb2b823d2c8cd7d0b88fecfb1eab.jpg)
图6-23 业务关系哈斯图  
并行执行业务是提供效率的一种有效途径。在一个偏序集中，如果能够将业务按照不相交的链进行分解，那么这些不相交的链就可在一定程度上并行执行。另一方面，如果把偏序集分解成不相交的反链，那么最长的反链长度则代表了在某个时间区间极大可并行的任务数。下面定理刻画了偏序集的分解与反链之间的关系：  
【定义6.16】设$\langle A,\preccurlyeq\rangle$为偏序集，如果$𝐴$中最长的链长度为$n$，则该偏序集可以分解为$𝑛$条不相交的反链。  
我们知道，对于一个偏序集合$\langle A,\preccurlyeq\rangle$，其任何子集${B}$上的最大值和最小值不一定存在或者不一定都存在。如果我们把偏序集合$\langle A,\preccurlyeq\rangle$的约束条件加强，要求$𝐴$的任何子集$𝐵$上的必须存在最小值，则得到如下良序关系的概念：  
【定义6.17】对于偏序集$\langle A,\preccurlyeq\rangle$，如果$𝐴$的任意一个非空子集$B$中都含有最小元素，则称该偏序关系为良序关系，简称为良序。称$\langle A,\preccurlyeq\rangle$为良序集。  
由上述定义可知，良序关系一定是偏序关系和全序关系，但偏序关系和全序关系不一定是良序关系。例如，实数集合上的小于等于关系显然是全序关系，但不是良序关系，因为开区间(0,1)没有最小值。不过有限的全序集一定是良序集。对于任何一个有限偏序集，可以通过适当排序将其改造成为一个全序集，从而使其成为良序集。"
全总个体域,概念,"['第四章  谓词演算与推理', '§ 4.1 个体词、谓词与量词', '4.1.3  量词与特性谓词', '三、特性谓词及其应用']","{'实体类型': '概念', '定义': '所有谓词和命题函数共用的统一个体域', '作用': '通过特性谓词确定不同个体变量的个体域'}",,4,"我们知道，谓词中含有个体变量，不同谓词的个体变量和个体域经常会有所不同。此时会给谓词逻辑运算结果的个体域确定带来混乱和困难。例如符号化下面两个命题：  
设立如下谓词：$P(x)$：$X$吃人；$Q(x)$：$X$ 登上过月球。则可将上述两个命题符号化为：  
$$
(\,1\,)\ \forall x P(x),\ \operatorname{x}\!\in\!\ \{ 老虎\};\ (\,2\,)\ \exists x Q(x),\ \operatorname{x}\!\in\!\{人\}
$$  
上述符号化表示，对每个表达式都注明了个体域。如果需要对上述两个命题的谓词式进行合取运算，得可到如下新命题的谓词式：$\forall x P(x)\land\exists x Q(x)$。则该谓词式的个体域就比较含糊和混乱。如果有多个类似的命题谓词式进行复杂的逻辑运算，那么对运算结果个体域的确定显然是一件非常麻烦的事情。  
另一方面，对于一个命题的谓词表达式，其个体域的确定又是非常重要的。因为个体域的差异往往会导致其真值取值的不同。例如对于命题“所有人都是大学生”，如果个体域是某大学的某个班，那么该命题显然为真；如果个体域是某中学的某个班，那么该命题显然为假；如果个体域为某电影院某场电影的全体观众，那么命题的真值就比较难以确定。  
因此，命题的谓词表达式不能采用对每个表达式分别指定个体域的方式。事实上，可以让所有的谓词和命题函数共用全总个体域作为一种统一的个体域，不同的个体变量可以通过设立与其含义相对应的特性谓词来确定其个体域。  
例如，可以设定特性谓词$U(x)$表示：$x$是老虎，则命题“所有的老虎都吃人”，就可完整地符号化为：$\forall x(U(x)\rightarrow P(x))$。该谓词式准确而完整地表达了命题的含义，可理解为：对于全总个体域中的每个$x$，如果$x$ 是老虎，则$x$一定吃人。  
如果将命题“所有的老虎都吃人” 符号化为：$(\forall x)(U(x)\ \land\ P(x))$。则这种表达显然是错误的，因为该式的含义是：“对于任意的一个对象$x,\ x$ 是老虎，并且$x$ 会吃人”，这与命题所表达的逻辑含义不符。  
同理，可以设定特性谓词$H(x)$表示：$x$是人，则命题“有些人登上过月球”，就可以完整地符号化为：$\exists x(H(x)\land Q(x))$。该谓词式准确而完整地表达了命题的含义，可理解为：在全总个体域中存在一些$x$，这些$x$ 不仅是人，而且登上过月球。  
如果将命题“有些人登上过月球”符号化为：$(\exists x)~(H(x)~\rightarrow~S(x))$。则这种表达显然是错误的，因为该式的含义是：“存在一些对象$x$，只要$x$ 是人，则$x$一定登上过月球”，这与命题所表达的逻辑含义不符。  
由此可知，特性谓词的使用与量词类型有着密切关系，具体方法如下：  
（1）对于全称量词$\forall x$，刻画其作用变量$x$ 个体域的特性谓词作为蕴含式前件加入；  
（2）对于存在量词$\exists x$，刻画其作用变量$x$ 个体域的特性谓词作为合取项加入。"
全排列,概念,"['第一章  集合与计数基础', '§ 1.3 有限集的基本计数技术', '1.3.3 排列计数与组合计数', '一、不重复的排列与组合']","{'实体类型': '概念', '定义': 'r=n时构成的排列称为全排列'}",,4,"首先考察如下排列问题：  
某班有35 名同学，现从中选出15 名同学排成一排，问有多少种排列方式？  
这个问题有如下两个关键要点：第一、在排列中每位同学最多只能出现一次，也就是无重复性；第二、不同的次序构成不同的排列。由此得到如下不重复排列的概念：  
【定义1.21】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中依次取出$r$ 个不同元素并将其按取出的次序排成一排，由此形成的一个有序排列称之为不重复$r\cdot$-排列，简称为$r\cdot$-排列或排列，不重复$r\cdot$-排列的个数称为不重复$r\cdot$-排列数，简称为$r\cdot$-排列数或排列数，记为${P}_{n}^{r}$或$P(n,r)$。称$r=n$时构成的排列称为全排列，$r<n$时构成的排列为选排列。  
根据乘法原理，显然可以得到如下结论：  
【定理1.13】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r\cdot$-排列数计算公式：  
$P(n,r)=n(n-1)(n-2)\cdots(n-r+1)\ \ ={\frac{n!}{(n-r)!}}$ 其中：$n!=n(n-1)(n-2)\cdots2\cdot1$  
【定义1.22】假设$S$是由$n$ 个不同的元素组成的集合，从$S$ 中依次取出$r$ 个不同元素并将其按取出的次序排成一个圆圈，由此形成的一个有序圆排列称之为不重复$r\cdot$-圆排列，简称为$r\cdot$-圆排列或圆排列，不重复$r\cdot$圆排列的个数称为不重复$r\cdot$-圆排列数，简称为$r\cdot$-圆排列数或圆排列数，记为${\cal P}_{c}(n,r)$。  
相对于上述圆排列的概念，有时亦将$r\cdot$-排列称为$r$-线排列或线排列。由前面分析不难看出，如果将每个$r\cdot$-线排列的首尾相连构成一个$r\cdot$-圆排列，则由此构成的所有圆排列必然有$r$倍的重复数。故有如下$r\cdot$-圆排列计算公式：  
【定理1.14】对于任意给定的两个正整数$n$ 和$r$，且$r\leq n$，其$r\cdot$-圆排列数为$P_{c}(n,r)$：  
$$
P_{c}(n,r)=\frac{P(n,r)}{r}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r}=\frac{n!}{r(n-r)!}
$$  
以上例子的共有特点是所有选出的元素都有一定的次序。事实上，很多情况下并不需要选出的元素具有有次序。  
考察如下组合问题：  
某班有35 名同学，现从中任意选出15 名同学参加问卷活动，问有多少种选择方式？  
与前述$r$-排列问题不同的是，这个问题只考虑抽取的是哪15 名同学，并不考虑抽取次序以及与之相关的排列问题。由此得到如下不重复组合及相关组合数的概念：  
【定义1.23】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中任意取出$r$ 个不同元素组成一个子集合，称每一个这样的子集合为一个不重复$r$-组合，简称为$r\cdot$-组合或组合，不重复$r$-组合的个数称为不重复$r\cdot$-组合数，简称为$r\cdot$-组合数或组合数，记为$C_{n}^{r}$或$C(n,r)$。  
显然， $r$ - 组合与 $r$ - 排列的区别在于 $r\cdot$ 组合不考虑组合中元素的排列次序， $r\cdot$ - 排列必须考 虑排列中各元素的排列次序。如果两个$r\cdot$-排列所含的元素完全相同，仅仅是排列次序不同，两个$r\cdot$-排列是同一个组合，由此得到有如下组合数计算公式：  
【定理1.15】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r-$组合数计算公式：  
$$
C(n,r)=\frac{P(n,r)}{r!}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r!}=\frac{n!}{r!(n-r)!}
$$"
全称推广规则(UG 规则),规则,"['第四章  谓词演算与推理', '§ 4.4 谓词逻辑的推理', '4.4.1 谓词公式推演系统']","{'实体类型': '规则', '基本形式': '$P(\\\\boldsymbol{y})\\\\Rightarrow\\\\ \\\\forall\\\\boldsymbol{x}\\\\ \\\\ P(\\\\boldsymbol{x})$', '基本含义': '如果个体变量$y$在个体域内取到每一个个体时都有$P(y)$为真，那么必有$\\\\forall x\\\\;\\\\;P(x)$为真'}",,3,"谓词公式的推演系统与命题公式的推演系统非常类似，主要由有效推理的基本概念、事实库、公理库和推理规则这几个部分组成。事实库和公理库构成谓词公式推理的基本依据，推理规则是谓词公式推理的核心机制。谓词公式推演系统的公理库和推理规则不仅涵盖了命题公式的推演系统的所有相关内容，而且更加丰富、复杂。  
谓词公式有效推理的概念与命题逻辑推理非常相似，具体定义如下：  
【定义4.22】设$G_{1},G_{2}\cdots G_{n}$，$\mathrm{H}$ 是一些谓词公式，如果它们满足下列性质：对于这些公式的任意一个解释I，$G_{1},G_{2}\cdots G_{n}$在该解释下同时为真的情况下$H$在该解释下也为真，则称公式$G_{1},G_{2}\cdots G_{n}$可有效推出公式$\mathrm{H}$，或称由$G_{1},G_{2}\cdots G_{n}$得到H 的逻辑推理为有效推理，记为$G_{1},G_{2}\cdots G_{n}\Rightarrow H$，并称$G_{1},G_{2}\cdots G_{n}$为推理前提，$\mathrm{H}$ 为$G_{1},G_{2}\cdots G_{n}$的逻辑结论。  
从上述定义不难看出，谓词逻辑推理的形式结构与命题逻辑推理的形式结构一致，是命题逻辑推理的自然推广。  
【定理4.6】谓词公式$H$是谓词公式$G_{1},G_{2}\cdots G_{n}$的逻辑结论，当且仅当下式：  
$$
G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\to H\tag{4-14}
$$  
为有效公式。  
上述定理表明谓词逻辑有效推理的过程就是证明谓词逻辑蕴含式的过程，这与命题逻辑的有效推理完全一致。  
谓词公式的推理依据主要是谓词公式推演系统中的事实库和公理库。事实库由具体谓词逻辑推理实例的所有前提条件以及推理过程中产生的有效中间结论组成；公理库不仅包含命题逻辑推演系统的公理库，即关于命题公式的24 个基本等值式和9 个基本永真蕴含式，而且还包含了关于谓词公式的所有基本等值式和基本逻辑蕴含式，具体可参加本章4.2.4 节中相关内容，这里不再一一罗列。  
现在着重介绍谓词公式的推理规则。由于在谓词合式公式中含有大量的量词，直接对其进行推理显然十分不便。为此，谓词公式推演系统引入一些专门处理量词的规则，以便在需要的时候可以方便地增加或消除量词。谓词逻辑中主要有全称特指、存在特指、全称推广和存在推广这四条基本的量词处理规则，其中全称特指和存在特指消除量词的规则，全称推广和存在推广则是添加量词的规则。下面具体介绍这些规则：  
1．全称特指规则(简称US 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)\forall x\ P(x)\Rightarrow\ P(y);\ (2)\forall x\ P(x){\Rightarrow}\ P(c)
$$  
US 规则的基本含义是：如果$\forall x\;\;P(x)$为真，那么对于论域中任何指定的个体$.c$，必有${P(c)}$为真。其中，$P$ 是谓词，(1)中的$y$ 是任意不在$P(x)$中约束出现的个体变量；(2)中的c为个体域中任意指定的一个个体常量。  
当谓词公式$P(x)$中不含任何量词和其它个体变量时，$US $规则显然不需要附加任何限制条件。但是，若$P(x)$中包含量词或其它个体变量时，(1)式中的约束“$y$ 是任意不在$P(x)$中约束出现的个体变量”就是必须的。例如，设$P(x)=\exists y(x<y)$，则$P(x)$在实数域上显然是真命题。但是，当$P(x)$中的$x$取𝑦时得到的$P(y)=\exists y(y<y)$显然是假命题。因此，限制引入的变量“不是在$P(x)$中约束出现的个体变量”是任何规则在引入变量时必需遵守的约定。  
2．存在特指规则(简称ES 规则)
$$
\exists x\ P(x)\Rightarrow\ P(c)
$$  
ES 规则的基本含义是：如果$\exists x$ $P(x)$为真，那么在个体域中必然至少存在某一个个体𝑐，使得$P(c)$为真。其中，$c$ 为个体域中使$P$ 成立的特定个体常量。  
当谓词公式$P(x)$中自由变量只是$x$的时候，上述规定可以保证使用ES 规则引入个体符号$c$ 的正确性。但是，如果谓词公式$P(x)$还含有其它自由个体变量，例如还有自由变量𝑦，那么使用ES 规则引入的符号c必须是以𝑦为自变量的个体函数，即$C(y)$。此外，还应当注意，在应用ES 规则时，其指定的个体$c$ 并不是任意含义下的自由变量，$c$ 的本质含义是某个或某些个体。因此，每次使用ES 规则指定的特定个体不能用之前的ES 规则或US 规则确定的个体替代，否则就会引起个体指代的混淆和错误。因为通常不能保证某次ES 指定的个体能够与其它次ES 或US 指定的个体之间具有必然的联系。  
3．全称推广规则(简称UG 规则)：  
$$
P(\boldsymbol{y})\Rightarrow\ \forall\boldsymbol{x}\ \ P(\boldsymbol{x})
$$
UG 规则的基本含义是：如果个体变量$y$在个体域内取到每一个个体时都有$P(y)$为真，那么必有$\forall x\;\;P(x)$为真。这里要求$x$既不是$P(y)$中约束变量也不是$P(y)$中的自由变量，即要求个体变量$x$不能在$P(y)$中出现。  
4．存在推广规则(简称EG 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)P(y)\Rightarrow\ \exists x\ P(x);\ (2)P(c)\Rightarrow\ \exists x\ P(x)
$$  
UG 规则的基本含义是：如果对于个体域中某个或某些指定的个体$.c$满足$P(c)$为真，那么必有 $\exists x P(x)$为真。其中，(1)式要求$P(y)$中无自由变量$x$；(2)式中要求$c$为个体域中的某个或某些个体常量。  
由以上分析可知，上述四个规则表面上看起来非常简单，但要能够做到真正理解并正确使用则不是一件容易的事情，实际使用时往往稍不注意就会出现错误。下面举例说明："
全称特指规则(US 规则),规则,"['第四章  谓词演算与推理', '§ 4.4 谓词逻辑的推理', '4.4.1 谓词公式推演系统']","{'实体类型': '规则', '基本形式': '(1)$\\\\forall x\\\\ P(x)\\\\Rightarrow\\\\ P(y);$ (2)$\\\\forall x\\\\ P(x){\\\\Rightarrow}\\\\ P(c)$', '基本含义': '如果$\\\\forall x\\\\;\\\\;P(x)$为真，那么对于论域中任何指定的个体$.c$，必有${P(c)}$为真'}",,3,"谓词公式的推演系统与命题公式的推演系统非常类似，主要由有效推理的基本概念、事实库、公理库和推理规则这几个部分组成。事实库和公理库构成谓词公式推理的基本依据，推理规则是谓词公式推理的核心机制。谓词公式推演系统的公理库和推理规则不仅涵盖了命题公式的推演系统的所有相关内容，而且更加丰富、复杂。  
谓词公式有效推理的概念与命题逻辑推理非常相似，具体定义如下：  
【定义4.22】设$G_{1},G_{2}\cdots G_{n}$，$\mathrm{H}$ 是一些谓词公式，如果它们满足下列性质：对于这些公式的任意一个解释I，$G_{1},G_{2}\cdots G_{n}$在该解释下同时为真的情况下$H$在该解释下也为真，则称公式$G_{1},G_{2}\cdots G_{n}$可有效推出公式$\mathrm{H}$，或称由$G_{1},G_{2}\cdots G_{n}$得到H 的逻辑推理为有效推理，记为$G_{1},G_{2}\cdots G_{n}\Rightarrow H$，并称$G_{1},G_{2}\cdots G_{n}$为推理前提，$\mathrm{H}$ 为$G_{1},G_{2}\cdots G_{n}$的逻辑结论。  
从上述定义不难看出，谓词逻辑推理的形式结构与命题逻辑推理的形式结构一致，是命题逻辑推理的自然推广。  
【定理4.6】谓词公式$H$是谓词公式$G_{1},G_{2}\cdots G_{n}$的逻辑结论，当且仅当下式：  
$$
G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\to H\tag{4-14}
$$  
为有效公式。  
上述定理表明谓词逻辑有效推理的过程就是证明谓词逻辑蕴含式的过程，这与命题逻辑的有效推理完全一致。  
谓词公式的推理依据主要是谓词公式推演系统中的事实库和公理库。事实库由具体谓词逻辑推理实例的所有前提条件以及推理过程中产生的有效中间结论组成；公理库不仅包含命题逻辑推演系统的公理库，即关于命题公式的24 个基本等值式和9 个基本永真蕴含式，而且还包含了关于谓词公式的所有基本等值式和基本逻辑蕴含式，具体可参加本章4.2.4 节中相关内容，这里不再一一罗列。  
现在着重介绍谓词公式的推理规则。由于在谓词合式公式中含有大量的量词，直接对其进行推理显然十分不便。为此，谓词公式推演系统引入一些专门处理量词的规则，以便在需要的时候可以方便地增加或消除量词。谓词逻辑中主要有全称特指、存在特指、全称推广和存在推广这四条基本的量词处理规则，其中全称特指和存在特指消除量词的规则，全称推广和存在推广则是添加量词的规则。下面具体介绍这些规则：  
1．全称特指规则(简称US 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)\forall x\ P(x)\Rightarrow\ P(y);\ (2)\forall x\ P(x){\Rightarrow}\ P(c)
$$  
US 规则的基本含义是：如果$\forall x\;\;P(x)$为真，那么对于论域中任何指定的个体$.c$，必有${P(c)}$为真。其中，$P$ 是谓词，(1)中的$y$ 是任意不在$P(x)$中约束出现的个体变量；(2)中的c为个体域中任意指定的一个个体常量。  
当谓词公式$P(x)$中不含任何量词和其它个体变量时，$US $规则显然不需要附加任何限制条件。但是，若$P(x)$中包含量词或其它个体变量时，(1)式中的约束“$y$ 是任意不在$P(x)$中约束出现的个体变量”就是必须的。例如，设$P(x)=\exists y(x<y)$，则$P(x)$在实数域上显然是真命题。但是，当$P(x)$中的$x$取𝑦时得到的$P(y)=\exists y(y<y)$显然是假命题。因此，限制引入的变量“不是在$P(x)$中约束出现的个体变量”是任何规则在引入变量时必需遵守的约定。  
2．存在特指规则(简称ES 规则)
$$
\exists x\ P(x)\Rightarrow\ P(c)
$$  
ES 规则的基本含义是：如果$\exists x$ $P(x)$为真，那么在个体域中必然至少存在某一个个体𝑐，使得$P(c)$为真。其中，$c$ 为个体域中使$P$ 成立的特定个体常量。  
当谓词公式$P(x)$中自由变量只是$x$的时候，上述规定可以保证使用ES 规则引入个体符号$c$ 的正确性。但是，如果谓词公式$P(x)$还含有其它自由个体变量，例如还有自由变量𝑦，那么使用ES 规则引入的符号c必须是以𝑦为自变量的个体函数，即$C(y)$。此外，还应当注意，在应用ES 规则时，其指定的个体$c$ 并不是任意含义下的自由变量，$c$ 的本质含义是某个或某些个体。因此，每次使用ES 规则指定的特定个体不能用之前的ES 规则或US 规则确定的个体替代，否则就会引起个体指代的混淆和错误。因为通常不能保证某次ES 指定的个体能够与其它次ES 或US 指定的个体之间具有必然的联系。  
3．全称推广规则(简称UG 规则)：  
$$
P(\boldsymbol{y})\Rightarrow\ \forall\boldsymbol{x}\ \ P(\boldsymbol{x})
$$
UG 规则的基本含义是：如果个体变量$y$在个体域内取到每一个个体时都有$P(y)$为真，那么必有$\forall x\;\;P(x)$为真。这里要求$x$既不是$P(y)$中约束变量也不是$P(y)$中的自由变量，即要求个体变量$x$不能在$P(y)$中出现。  
4．存在推广规则(简称EG 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)P(y)\Rightarrow\ \exists x\ P(x);\ (2)P(c)\Rightarrow\ \exists x\ P(x)
$$  
UG 规则的基本含义是：如果对于个体域中某个或某些指定的个体$.c$满足$P(c)$为真，那么必有 $\exists x P(x)$为真。其中，(1)式要求$P(y)$中无自由变量$x$；(2)式中要求$c$为个体域中的某个或某些个体常量。  
由以上分析可知，上述四个规则表面上看起来非常简单，但要能够做到真正理解并正确使用则不是一件容易的事情，实际使用时往往稍不注意就会出现错误。下面举例说明："
全称量词,概念,"['4.1.3  量词与特性谓词', '一、量词的概念', '第四章  谓词演算与推理', '§ 4.1 个体词、谓词与量词', '二、量词的展开与否定']","{'实体类型': '概念', '定义': ['量词的一种，表示对于变量x个体域中的每个个体', '表示对于个体域中任意一个个体，谓词均为真的命题'], '记法': '∀x', '性质': '取值为真当且仅当个体域中所有个体使得谓词为真；取值为假当且仅当个体域中至少存在一个个体使得谓词为假'}",,4,"如前所述，若给谓词中每个变量分别指定确定个体，则谓词就变成谓词填式并由此成为一个具体命题。事实上，除了直接给变量赋值之外，还可通过其它方法实现对变量的限制或者约束，使得谓词具有明确具体的含义而变成命题，即具有命题谓词式的具体命题。  
例如，对于前述苏格拉底三段论中的命题“所有人都是要死的”，句中的主语“人”其实并不是一个具体的个体常量，而是一个变量，但是整个句子却是一个真命题。原因是句中的“人”受到“所有的”这个词的限定或者约束，使得整个语句具有明确的含义。  
同理，对于“所有的老虎都吃人”、“有一些自然数是素数”、“有一些动物是哺乳动物”、“所有人都长着黑头发”等等之类的陈述句，其主语尽管是变量，但是都受到“所有的”、“有一些”之类词的约束或限定，具有明确的含义和指代，因此这些陈述句都是命题。  
这些能够对谓词中变量进行约束或限定的词，我们称之为量词。其具体定义如下：  
【定义4.7】对于给定的谓词$P(x)$，若个体变量$x$在其个体域内的所有赋值都使得$P(x)$的取值为真，则称$P(x)$得到全称量化，记为：$\forall x P(x)$。其中$\forall$称为全称量词，$\forall$后面的$x$ 称为其作用变量，$\forall x$的含义为“对于变量$x$ 个体域中的每个个体…”。  
【定义4.8】对于给定的谓词$P(x)$，若个体变量$x$在其个体域内至少存在一个赋值都使得$P(x)$的谓词填式取值为真，则称$P(x)$得到存在量化，记为：$\exists x P(x)$。其中∃称为全称量词，∃后面的$x$ 称为其作用变量，$\exists x$的含义为“变量$x$ 个体域中至少存在一个个体…”。"
全集,概念,"['1.1.2 集合的概念与表示', '四、常用的特殊集合', '1.空集与全集', '§ 1.1 集合的基本知识', '第一章  集合与计数基础']","{'实体类型': '概念', '特点': ['具有特殊性质', '一般用矩形表示全集，圆形表示非全集集合'], '定义': '相对固定范围之内所有元素组成的集合称为全集', '条件': '对于每个具体的问题，默认论域或背景应当是唯一的', 'name': '全集'}",,4,集合论中有一些非常重要和常用的特殊集合，它们分别具有一些特殊性质。离散数学中很多基本概念的定义及其性质讨论都离不开它们。下面具体介绍这些特殊集合的基本概念及性质，包括空集、全集、有限集、无限集、子集、幂集等。
公倍数,概念,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.2 整数的因数分解', '一、公因数与公倍数']","{'实体类型': '概念', '定义': ['两个或多个整数共有的倍数', '假设i和j是任意两个整数，如果i和j都能够整除整数a，则称a是i和j的一个公倍数'], '特点': '两个整数的乘积就是它们的公倍数', 'name': '公倍数'}",,3,对于任意两个整数，它们之间可以进行加法运算、减法运算和乘法运算，却不一定能够进行整除运算。因此，我们可以将整除运算作为一个基本工具来考察单个整数的离散结构特征以及整数与整数之间的各种联系。本节首先介绍公因数和公倍数的相关概念与性质，然后给出最大公因数的经典构造算法，最后讨论整数基于整除性质的分解。由于非零整数的正负号不影响其整除性质，因此，不失一般性，以下关于整数的讨论，在默认状态下是针对非负整数范围，所得结论可直接推广到所有整数的范围。
公因数,概念,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.2 整数的因数分解', '一、公因数与公倍数']","{'实体类型': '概念', '定义': '两个或多个整数共有的因数；假设i和j是任意两个整数，如果整数b能够同时整除i和j，则称b是i和j的一个公因数', '特点': '表达的是两个整数的共同部分', 'name': '公因数'}",,3,对于任意两个整数，它们之间可以进行加法运算、减法运算和乘法运算，却不一定能够进行整除运算。因此，我们可以将整除运算作为一个基本工具来考察单个整数的离散结构特征以及整数与整数之间的各种联系。本节首先介绍公因数和公倍数的相关概念与性质，然后给出最大公因数的经典构造算法，最后讨论整数基于整除性质的分解。由于非零整数的正负号不影响其整除性质，因此，不失一般性，以下关于整数的讨论，在默认状态下是针对非负整数范围，所得结论可直接推广到所有整数的范围。
公因数与公倍数,概念,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识']",{'实体类型': '概念'},,2,本节主要介绍整数理论中若干最基本的知识。我们知道，整数相加、相减、相乘的结果都是整数，而除法结果却不一定是整数。因此，整数理论研究的重点自然是运算结果相对比较复杂的除法。通过整数的除法运算可以得到整数的素因数分解，由此我们便可以素数为基本构件来考察或窥探整数的离散结构特征与变化规律。在这个过程中，素数作为构造整数的基本构件，其性质与分布规律自然是整数理论的重要内容。因此，本节内容主要包括整数与整数除法的概念、公因数与公倍数、整数的素因数分解、素数的性质及相关算法等。
公式演算法,算法,"['第三章  命题演算与推理', '§ 3.5 命题逻辑的演绎推理', '3.5.1 永真蕴含关系与判定', '三、永真蕴含关系判定法', '（2）公式演算法']","{'实体类型': '算法', '应用': '用于永真蕴含关系的判定和证明', '特点': '与真值表法基本思路相似，但表现形式不同'}",,5,通过上述例子可以发现，对于永真蕴含关系的判定和证明，公式演算法与真值表法的基本思路几乎一样，二者的差别仅仅在于求解的表现形式不同，一个通过真值表的枚举，另外一个是通过命题公式的逻辑演算。
公式组相容,概念,"['第三章  命题演算与推理', '§ 3.5 命题逻辑的演绎推理', '3.5.3 命题推证的基本策略', '三、间接证明法']","{'实体类型': '概念', '定义': '假设G1,G2,...,Gn是一组命题公式，P1,P2,...,Pn是出现在G1,G2,...,Gn中的一切命题变元，若有解释I使G1∧G2∧...∧Gn取值为“真”，则称公式G1,G2,...,Gn是一致的或相容的，否则称公式G1,G2,...,Gn为不一致的，或者说G1∧G2∧...∧Gn是一个矛盾式'}",,4,"间接证明法不仅使用$P$规则，$T$规则，还使用反证法或$C P$规则的推理方法。在引入间接证明法之前，首先给出公式组相容概念：  
【定义3.30】假设$G_{1},G_{2},\cdots,G_{n}$是一组命题公式，$P_{1},P_{2},\cdots,P_{n}$是出现在$G_{1},G_{2},\cdots,G_{n}$中的一切命题变元，若有解释I使$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}$取值为“真”，则称公式$G_{1},G_{2},\cdots,G_{n}$是一致的或相容的，否则称公式$G_{1},G_{2},\cdots,G_{n}$为不一致的，或者说$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}$是一个矛盾式。  
利用矛盾式的概念，可以给出一种推导过程，这个过程通常称为矛盾法或间接证明法，常被称为反证法。下面给出反证法的证明。  
【定理3.15】如果命题公式集合$\{G_{1},G_{2},\cdots,G_{n}\}$是相容的，那么从前提集合$\{G_{1},G_{2},\cdots,G_{n}\}$可以逻辑推出公式$\cdot H$，即$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\Rightarrow H$，的充要条件是从前提集合$\{G_{1},G_{2},\cdots,G_{n},\lnot H\}$出发，可以逻辑推出一个矛盾（永假）式来，即$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\wedge\neg H\Rightarrow F_{\circ}$。"
公理化集合论,原理,"['第一章  集合与计数基础', '§ 1.1 集合的基本知识', '1.1.1 数学危机与集合论']","{'实体类型': '原理', '作用': '有效解决理发师悖论问题', '影响': '稳定了数学根基，确立了集合论的基础地位'}",,3,"众所周知，数学是整个自然科学体系的基础，人们对自然界的认识结论一般需要通过数学演算或数学证明来保证其正确性。打铁还需自身硬，从理论上说，数学既然能够作为一种可以鉴别认识结论真伪的基本工具，那么其自身就不应该有任何错误或矛盾。但实际情况并没有这么简单，千百年来陆续出现的希帕索斯悖论、贝克莱悖论、理发师悖论，使得数学理论的正确性面临一次又一次严峻挑战，历史上称之为数学危机。为拯救数学于危机之中，捍卫数学理论的正确性，无数杰出科学家做了大量深入系统的研究工作。直到在十九世纪初，柯西、维尔斯特拉斯等数学家通过创立极限理论，终于解决了希帕索斯悖论、贝克莱悖论问题，为实数理论和微积分的正确性奠定了坚实的基础。  
但是，极限理论在逻辑上还有需要完善的地方.因为极限概念由自然数定义，要保证极限理论的正确性，首先必须要保证自然数概念及相关理论的正确性。虽然自然数是大家熟知且常用的一个基本概念，大家从小学就开始学习自然数的计数和运算，但是对自然数概念的理解主要还是依靠经验。为保证极限理论的正确性，必须对自然数进行正式的数学定义。数学家冯·诺依曼用集合的方式定义了自然数并取得成功。由此，对整个数学理论体系正确性和无矛盾性的论证就转化为对集合论的正确性和无矛盾性的论证，集合论成为整个数学大厦的根基。尽管卢素提出理发师悖论指出了集合论的局限性，一度动摇了这个根基，但是有惊无险，策莫罗提出的公理化集合论有效解决了理发师悖论问题，不仅稳定了数学根基，而且进一步确立了集合论在整个数学大厦中的基础地位。集合论被誉为十九世纪最伟大的数学成就，集合论的创始人康托被誉为整个十九世纪最伟大的数学家，没有之一。"
关系,概念,"['第五章 关系模型与理论', '§ 5.1 关系的数学模型', '5.1.2  关系的概念']","{'实体类型': '概念', '定义': '设𝐴, 𝐵是任意给定的两个非空集合，𝑅是𝐴×𝐵的任何一个给定的子集合，则称𝑅是一个从𝐴到𝐵的二元关系，简称为关系', '特点': '可用序偶的集合或者笛卡尔集的某个子集合来构造二元关系的数学模型'}",,3,"现在我们使用序偶与笛卡尔积这两个概念建立表示两个元素之间二元关系的数学模型。首先考察一个具体实例：假设某个班级正在上离散数学课，教室里有100 个座位和85 名学生，那么教室里有些座位有学生坐、有些座位没有学生坐，如果某个座位被某个学生坐了，则称这个座位与这个学生有关系，否则称这个座位与这个学生没有关系，现在考虑要用什么样的数学模型来表示或定义这种学生与座位之间的二元关系。  
令集合$A$表示该教室所有学生组成的集合，集合B表示该教室所有座位组成的集合，则根据乘法原理，$A$与$B$的笛卡尔集$A\times B$就表示将这85 名学生分布到100 个座位上所有可能发生的状态，$A\times B$中每个元素$\langle x,y\rangle$就表示学生$x$与座位𝑦之间可能发生的一种关系，即学生$x$坐在座位𝑦上的一种可能发生的状态。显然，一共有$85\times100=8500$可能的状态。但是，这些状态一般不会都发生，事实上，此时实际发生的只有85 个状态，即学生和座位之间实际发生关系的有且只有$A\times B$中的85 个元素。因此，可以将$A\times B$中这85 个实际发生的状态作为集合来表示这85 名学生和100 个座位之间的关系。换句话说，这85 名学生和100 个座位之间的二元关系其实就是$A$与$B$的笛卡尔集$A\times B$的某个子集。  
也可以从另外一个角度理解这个问题：将集合$𝐴$和$B$分别看成是学生维度和座位维度这两个一维空间，则$𝐴$与$B$的笛卡尔集$A\times B$就表示由这两个维度的元素组合而成的二维空间。现从𝐴中任选一位学生$x$，从$B$中任选一个座位𝑦，让学生$x$坐到座位𝑦上，由此形成一个序偶$\langle x,y\rangle$。这个序偶对应着$A\times B$所形成二维空间的一个点，所有这样的点或者序偶显然构成了这个二维空间的一个子集合。另外一方面，所有这样的点或序偶组成的集合完全枚举了学生与座位实际发生的关系，故可将学生与座位之间的二元关系就定义为所有这样的序偶组成的集合。因此，座位和学生之间的二元关系其实就是$𝐴$与$B$的笛卡尔集$A\times B$的某个子集。  
在实际生活中，还有很多类似的例子。再如机票和座位之间对号关系，若令$X$为机票的集合，Y 为座位号的集合， $R$ 表示对号关系，则对任意$x\in X$和$y\in Y$，$x$与$y$ 之间有对号和不对号两种状态。若将$R$ 看成是一些序偶的某个集合或$X$与$Y$ 的笛卡尔集$X\times Y$的某个子集，则对于任意一个序偶$\langle x,\ y\rangle$， $x$与$y$具有对号关系当且仅当$\langle x,y\rangle\in R$。因此，可将这里的对号关系定义为序偶的某个集合或$X\times Y$的某个子集合。  
通过以上分析发现，可用序偶的集合或者笛卡尔集的某个子集合来构造二元关系的数学模型。据此得到如下关于二元关系的定义：  
【定义5.6】设$𝐴$, $B$是任意给定的两个非空集合，$R$是$A\times B$的任何一个给定的子集合，则称$R$ 是一个从$𝐴$到$B$的二元关系，简称为关系。也就是说，若$R\subseteq A\times B$，则称$R$是$𝐴$到$B$的一个二元关系，若$\ R\subseteq A\times A$，则称$R$是$𝐴$上的一个二元关系。特别地，若$R=\emptyset$，则称$R$ 为空关系；若$R=A\times B$，则称$R$ 为全关系。  
【定义5.7】设$𝐴$, $B$是任意给定的两个非空集合，$R$是$𝐴$到$B$的一个二元关系，对于$A\times B$中的任意一个序偶$\langle x,y\rangle$，若$\langle x,y\rangle\in R$，这称集合$𝐴$中的元素$x$与集合$\ B$中的元素$𝑦$之间具有关系$R$；若$R$是$𝐴$上的一个二元关系且$\langle x,y\rangle\in R$，则称集合𝐴中的元素$x$与$𝑦$之间具有关系$R$。  
由上述两个定义可以看出，我们以集合为基本工具通过确定关系外延的方式给出关系概念的数学定义。这样就不必用数学符号来表示关系概念的内涵。事实上，对于有些关系，即使用自然语言也无法清楚表达其复杂的内涵。  
![](images/f21a296fae3e098faaa3900cc4615cee3ba4531b4f17c607a85fa8fb673d5d95.jpg)
图5-1 关系的五个域  
如图5-1 所示，集合$C$和$D$满足：$C=\{x|\langle x,y\rangle\in R\}$；$D=\{y|\langle x,y\rangle\in R\}$。此时称$C$为$R$ 的定义域，记为$C=\mathsf{d o m}R$；称$D$为$R$ 的值域，记为$D=ranR$；$A$ 为$R$ 的前域，$B$ 为$R$ 的后域，并称$\mathrm{fld}R=D\cup C$为$R$ 的域。一般地，我们有如下定义：  
【定义5.8】设$𝐴$, $B$是任意给定的两个非空集合，$R$是$𝐴$到$B$的一个二元关系，则有：称$A$是$R$的前域， $B$是$R$的后域；由$R$ 中所有序偶的第一元素构成的集合称为$R$ 的定义域，记作$dom𝑅$，即有$\mathrm{dom}R=\{x|\langle x,y\rangle\in R\}$；由$R$ 中所有序偶的第二元素构成的集合称为$R$ 的值域，记作$ran𝑅$，即有$\mathrm{ran}R=\{y|\langle x,y\rangle\in R\}$；称$\mathrm{fld}R=\mathrm{dom}R\cup\mathrm{ran}R$为$R$ 的域。"
关系代数模型,原理,"['5.5.1 关系代数模型', '第五章 关系模型与理论', '§ 5.5 关系模型的应用']","{'实体类型': ['原理', '概念'], '作用': '实现数据库中数据结构的描述，数据操作、操作优化及规范化的表示', '成果': ['由关系代数而建立起了关系数据库', '实现了以理论带动系统的重要突破'], '提出者': 'IBM 公司E.F.Codd', '提出时间': '1970 年', '实用化时间': '1976 年', '地位': '关系模型数据库系统是数据库中最具优势的数据模型', '定义': '一种以二维表的方式表示数据的多元关系结构以及相关的关系操作', '组成': '表框架及表元组', '表框架': '由表名及若干个命名属性列构成', '元组': '表中每行数据，由若干个分量组成，每个分量对应表框架中的一个属性值', '基本操作': '表的列指定、表的行选择、两表的合并、选择操作、删除操作、插入操作', '运算对应': '插入操作对应关系集合并运算、删除操作对应关系集合差运算、两表合并对应关系集合的笛卡尔积运算、多表查询运算对应关系的复合运算'}",,2,在计算机中专门用于存储与管理数据的系统称为数据库管理系统，而存储与管理数据的基本特征的抽象表示称为数据模型。一般来讲，数据模型都可以用数学形式表示，常用的有图的形式、关系形式及逻辑形式等。其中基于关系代数与关系演算的关系数据模型是计算机科学的重大理论成果，它对数据库的发展起着关键性与基础性的作用。关系代数模型运用了关系及关系运算，实现数据库中数据结构的描述，数据操作、操作优化及规范化的表示；关系演算模型运用了谓词逻辑理论，以实现数据库中数据结构的表示、数据操作及查询优化，并通过谓词推理获取查询结果。由关系代数而建立起了关系数据库，由关系演算而建立起了知识库与演绎数据库，开创了数据库学科研究的重大方向。几十年来，基于关系数据模型的关系型数据库系统一直是主流数据库系统。
关系图,概念,"['第五章 关系模型与理论', '§ 5.1 关系的数学模型', '5.1.3 关系的表示', '2、有向图表示法']","{'实体类型': '概念', '定义': '表示关系的有向图', '构造方法': '根据集合元素和关系中的序偶构建有向边'}",,4,"图是一种非常重要的数学模型，是问题表示和求解的基本工具。本书将在后续相关内容专门介绍和讨论图模型的基本理论及应用。这里主要给出二元关系的一种图模型表示方法。一般来说，图模型由一些结点和一些联结结点的边构成，一条边关联且仅关联两个结点。对于任意给定的一条边，如果将关联这条边的其中一个结点确定为起点，另外一个结点确定为终点，则称该边为有向边，若一个图中的每条边都是有向边，则称该图为有向图。在一般情况下，有向图只能表示有限集合上的二元关系。下面给出二元关系的一种有向图表示方法，通常称表示关系的有向图为关系图。  
假设𝐴, $B$是任意给定的两个非空有限集合，$R$是$𝐴$到$B$的一个二元关系： （1）当$A\ne B$时，不妨设$A=\{a_{1},a_{2},\cdots,a_{n}\}$，$B=\{b_{1},b_{2},\cdots,b_{m}\}$，则可将$𝐴,$ $B$中每个元素分别看成是有向图的一个结点，用“ ∘”表示，并将$𝐴$中元素$a_{1},a_{2},\cdots,a_{n}$对应的结点放在左边一列作为有向边的起点，将$B$中元素$\cdot b_{1},b_{2},\cdots,b_{m}$对应的结点放在右边一列作为有向边的终点。对于关系$R$中的每个序偶，则构成有向图中的一条有向边，也就是说，对于$𝐴$中的任一元素$a_{i}$和$B$中的任一元素$b_{j}$组合而成的序偶$\langle a_{i},b_{j}\rangle$，当且仅当$\langle a_{i},b_{j}\rangle\in R$时，以$a_{i}$对应的结点为起点、以$b_{j}$对应的结点为终点画出一条有向边，由此得到$R$的关系图。  
（2）当$A=B$时，设$A=B=\{a_{1},a_{2},\cdots,a_{n}\}$，此时$R$ 是集合$𝐴$上的关系，则将$𝐴$中的每个元素分别看成是有向图中的一个结点，用“ ∘”表示，对于任意一个序偶$\langle a_{i},a_{j}\rangle$：  
如果$a_{i}$和$a_{j}$对应的不是同一个结点，则当且仅当$\langle a_{i},a_{j}\rangle\in R$时，使用以$a_{i}$对应的结点为起点、以$b_{j}$对应的结点为终点的有向边联结$a_{i}$和$a_{j}$对应的两个结点；如果$a_{i}$和$a_{j}$对应的是同一个结点，即$a_{i}$和$a_{j}$是$𝐴$中同一个元素，则当且仅当$\langle a_{i},a_{i}\rangle\in R$时，则在$a_{i}$对应的结点上画一个从该结点出发并回到该结点的有向小圆环。  
下面举例说明关系图的构造方法："
关系性质的封闭性,性质,"['第五章 关系模型与理论', '§ 5.3 关系的基本性质', '5.3.4 关系性质的判定']","{'实体类型': '性质', '定义': '关系的基本性质在某些运算下仍然能够保持', '示例': '关系的对称性质在关系并运算下是封闭的'}",,3,"前面学习了关系的五个基本性质，在关系图和关系矩阵上都能够找到表征这些性质的相关图特征和矩阵特征。因此，对于一个任意给定的二元关系，可以使用关系图或关系矩阵的相关特征判定该关系是否具备关系的哪些基本性质。从本质上看，关系是以序偶为元素的集合。下面介绍和讨论如何从集合的角度判定关系的基本性质。  
【定理5.10】设$R$ 是集合$A$ 上的二元关系，则有：  
（1）$R$ 是自反的$\iff I_{A}\subseteq R$；  （2）$R$ 是反自反的$\iff R\cap I_{A}=\emptyset$；  
（3）$R$ 是对称的$\Leftrightarrow R=R^{-1}$； （4）$R$ 是反对称的$\iff R\cap R^{-1}\subseteq I_{A}$  
（5）$R$ 是传递的$\Longleftrightarrow R\circ R\subseteq R$。  
下面定理表明，对于关系一些基本性质在某些运算下仍然能够保持，此时称关系性质在该运算下具有封闭性。例如，如果$A$ 上$d$ 两个关系都是对称的，那么这两个关系的并运算也是对称的。也就是说，关系的对称性质在关系并运算下是封闭的。  
【定理5.11】设$R$、$S$是定义在$A$ 上的二元关系，则：  
（1）若$R$、$S$是自反的，则$R^{-1}$，$R\cup S$，$R\cap S$，$R\circ S$也是自反的；  
（2）若$R$、$S$是反自反的，则$R^{-1}$，$R\cup S$，$R\cap S$也是反自反的；  
（3）若$R$、$S$是对称的，则$R^{-1}$，$R\cup S$，$R\cap S$也是对称的；  
（4）若$R$、$S$是反对称的，则$R^{-1}$，$R\cap S$也是反对称的；  
（5）若$R$、$S$是传递的，则$R^{-1}$，$R\cap S$也是传递的。"
关系性质闭包,概念,"['第五章 关系模型与理论', '§ 5.4 关系的性质闭包']","{'实体类型': '概念', '定义': '对现有关系进行尽可能小的调整或改变，使其具有所需性质的变通方法', '应用': '在关系模型求解时，使现有关系具备所需性质', '基本内容': '包括关系闭包的基本概念、构造方法和基本性质'}",,2,自反性、对称性和传递性是关系的重要性质，在对很多关系问题的求解过程中都需要用到这些性质。然而，并不是所有二元关系都具备这些性质。在关系模型求解时必须用到但现有关系不具备这些性质的时候，通常需要做一些变通，采用适当方法对现有关系进行尽可能小的调整或改变，使其具有所需的性质。给关系加上适当的性质闭包就是一种常用的变通方法，在很多场合都有着成功的应用。本节着重介绍这种加闭包的方法，具体包括关系闭包的基本概念、构造方法和基本性质。
关系数学模型,概念,"['第五章 关系模型与理论', '§ 5.1 关系的数学模型']","{'实体类型': '概念', '定义': '使用高维空间中点的集合来表示两个集合元素之间关系的方法', '特点': '比传统用符号表示大小关系的方法更具普适性', '构建机制': '元素的序偶与集合的笛卡尔积'}",,2,从数学角度看，有些关系比较容易用数学符号表达。例如，自然数集合上自然数的大小比较关系，可用符号≤进行表示。但在很多时候，问题并没有这么简单，例如要表示某班每个学生与其籍贯之间的关系，这就涉及到该班学生集合与地域集合这两个集合元素之间的一种对应关系。此时，要想用数学符号表示这种对应关系，就需要一些巧妙的设计。事实上，可分别将学生集合和地域集合看成是两个在不同维度上的一维空间，并将这两个一维空间进行有序组合张成一个二维空间。此时，对于学生集合中任意一个给定的学生，将这个学生与其籍贯进行有序绑定后，就形成了这个二维空间中的一个点。所有这样的点构成的集合显然就准确地表示了该班每个学生与其籍贯之间的关系。由此可见，我们其实得到一种刻画两个集合中元素之间关系新方法，即首先将这两个集合组合成一个高维空间，然后用高维空间中点的集合来表示两个集合元素之间的关系。显然，这种新方法比前述用符号≤表示大小关系的传统方法更具普适性。本节着重介绍使用这种新方法构建的关系数学模型，为此首先介绍由两个集合组合成一个高维空间的数学机制，即元素的序偶与集合的笛卡尔积。
关系数据模型,概念,"['5.5.1 关系代数模型', '第五章 关系模型与理论', '§ 5.5 关系模型的应用']","{'实体类型': '概念', '地位': '计算机科学的重大理论成果', '作用': '对数据库的发展起着关键性与基础性的作用', '定义': '以二维表的方式表示数据的多元关系结构以及相关的关系操作', '组成': '表框架及表元组', '表框架': '由表名及若干个命名属性列构成', '元组': '表中每行数据，由若干个分量组成，每个分量对应表框架中的一个属性值'}",,2,在计算机中专门用于存储与管理数据的系统称为数据库管理系统，而存储与管理数据的基本特征的抽象表示称为数据模型。一般来讲，数据模型都可以用数学形式表示，常用的有图的形式、关系形式及逻辑形式等。其中基于关系代数与关系演算的关系数据模型是计算机科学的重大理论成果，它对数据库的发展起着关键性与基础性的作用。关系代数模型运用了关系及关系运算，实现数据库中数据结构的描述，数据操作、操作优化及规范化的表示；关系演算模型运用了谓词逻辑理论，以实现数据库中数据结构的表示、数据操作及查询优化，并通过谓词推理获取查询结果。由关系代数而建立起了关系数据库，由关系演算而建立起了知识库与演绎数据库，开创了数据库学科研究的重大方向。几十年来，基于关系数据模型的关系型数据库系统一直是主流数据库系统。
关系模型,概念,"['5.1.3 关系的表示', '第五章 关系模型与理论', '§ 5.1 关系的数学模型', '§ 5.5 关系模型的应用', '2、有向图表示法']","{'实体类型': '概念', '定义': ['用于表示和求解问题的数学模型', '存储与管理数据的基本特征的抽象表示'], '应用': ['表示二元关系', '用于数据库管理系统'], '特点': '可以用数学形式表示，常用的有图的形式、关系形式及逻辑形式', 'name': '关系模型'}",,4,"图是一种非常重要的数学模型，是问题表示和求解的基本工具。本书将在后续相关内容专门介绍和讨论图模型的基本理论及应用。这里主要给出二元关系的一种图模型表示方法。一般来说，图模型由一些结点和一些联结结点的边构成，一条边关联且仅关联两个结点。对于任意给定的一条边，如果将关联这条边的其中一个结点确定为起点，另外一个结点确定为终点，则称该边为有向边，若一个图中的每条边都是有向边，则称该图为有向图。在一般情况下，有向图只能表示有限集合上的二元关系。下面给出二元关系的一种有向图表示方法，通常称表示关系的有向图为关系图。  
假设𝐴, $B$是任意给定的两个非空有限集合，$R$是$𝐴$到$B$的一个二元关系： （1）当$A\ne B$时，不妨设$A=\{a_{1},a_{2},\cdots,a_{n}\}$，$B=\{b_{1},b_{2},\cdots,b_{m}\}$，则可将$𝐴,$ $B$中每个元素分别看成是有向图的一个结点，用“ ∘”表示，并将$𝐴$中元素$a_{1},a_{2},\cdots,a_{n}$对应的结点放在左边一列作为有向边的起点，将$B$中元素$\cdot b_{1},b_{2},\cdots,b_{m}$对应的结点放在右边一列作为有向边的终点。对于关系$R$中的每个序偶，则构成有向图中的一条有向边，也就是说，对于$𝐴$中的任一元素$a_{i}$和$B$中的任一元素$b_{j}$组合而成的序偶$\langle a_{i},b_{j}\rangle$，当且仅当$\langle a_{i},b_{j}\rangle\in R$时，以$a_{i}$对应的结点为起点、以$b_{j}$对应的结点为终点画出一条有向边，由此得到$R$的关系图。  
（2）当$A=B$时，设$A=B=\{a_{1},a_{2},\cdots,a_{n}\}$，此时$R$ 是集合$𝐴$上的关系，则将$𝐴$中的每个元素分别看成是有向图中的一个结点，用“ ∘”表示，对于任意一个序偶$\langle a_{i},a_{j}\rangle$：  
如果$a_{i}$和$a_{j}$对应的不是同一个结点，则当且仅当$\langle a_{i},a_{j}\rangle\in R$时，使用以$a_{i}$对应的结点为起点、以$b_{j}$对应的结点为终点的有向边联结$a_{i}$和$a_{j}$对应的两个结点；如果$a_{i}$和$a_{j}$对应的是同一个结点，即$a_{i}$和$a_{j}$是$𝐴$中同一个元素，则当且仅当$\langle a_{i},a_{i}\rangle\in R$时，则在$a_{i}$对应的结点上画一个从该结点出发并回到该结点的有向小圆环。  
下面举例说明关系图的构造方法："
关系模型与理论,概念,['第五章 关系模型与理论'],"{'实体类型': '概念', '定义': '用于表达和处理计算机领域各种对象之间关系的完备严谨的数学模型与理论', '应用': '为数据结构、数据库、信息检索、算法设计与分析、操作系统等计算机专业课程中各种对象之间关系的表达和处理提供有效的基础工具', '特点': '以数学方法表达和处理关系问题，基于集合论描述元素之间的二元或多元关系'}",,1,"我们知道，日常生活或工作中的各种对象之间存在着千丝万缕的联系，包括人与人之间、人与物之间、物与物之间的联系。这种联系通常称之为关系，例如人与人之间的关系有兄弟关系、姻亲关系、朋友关系、同学关系、同事关系等等。这些关系反映了人与人之间各种错综复杂的活动，以这些关系为基础便可进一步衍生出许许多多不同的含义。事实上，一个人社会关系的宽泛程度通常标志着这个人某种能力的大小、威望的高低等等。同样，计算机领域的各种对象之间也存在诸多错综复杂的关系，例如计算机程序中输入与输出之间的关系、数据库中各种数据属性之间的关系、计算机语言中各种标识符之间的关系等等。要想让计算机系统能够自动、高效、正确地处理好这些关系，就必须建立一套完备严谨的关系模型与理论，为数据结构、数据库、信息检索、算法设计与分析、操作系统等计算机专业课程中各种对象之间关系的表达和处理提供有效的基础工具。  
正如计算机不能正确理解和处理基于自然语言表达的形式逻辑，计算机同样不能正确理解和处理用自然语言表达的关系模型与理论。因此，就像使用数理逻辑表达和处理形式逻辑问题一样，我们必须使用数学方法来表达和处理关系问题，面向关系问题建立一整套完备严谨的数学模型与数学理论。事实上，关系问题也是数学学科的一个重要研究对象，处理关系的数学理论诞生于著名数学家豪斯道夫1914 年出版的著作《集论基础》。经过100 多年的发展，关系数学理论已与集合论、数理逻辑、组合学、图论和布尔代数等多个数学分支交叉融 合，并通过吸收、借鉴这些数学分支的相关内容形成了一套相对完备的关系数学理论。  
关系的数学理论以集合论为基础，旨在描述给定集合上元素与元素之间的二元或多元关系，并考察集合中元素之间在一定次序下是否具备某些特定关系。从本章开始的连续三章将系统地介绍和讨论关系的数学模型与理论，本章着重介绍关系数学模型与理论的基本知识，包括关系的数学模型、关系的基本运算、关系的基本性质、关系集合的闭包等。"
关系演算模型,原理,"['5.5.2 关系演算模型', '第五章 关系模型与理论', '§ 5.5 关系模型的应用']","{'实体类型': ['原理', '概念'], '作用': '实现数据库中数据结构的表示、数据操作及查询优化，并通过谓词推理获取查询结果', '成果': '由关系演算而建立起了知识库与演绎数据库', '定义': '以关系理论为基础，引入谓词推理机制，将推理与查询融为一体的数学模型', '应用': '实现关系数据库与知识库的一体化，主要用于操作优化，提高查询效率', '特点': '具备谓词推理机制，能够完成知识表示与推理，实现关系数据库系统与知识库系统有效整合', '价值': '在理论和应用方面具有非常重要的价值'}",,2,在计算机中专门用于存储与管理数据的系统称为数据库管理系统，而存储与管理数据的基本特征的抽象表示称为数据模型。一般来讲，数据模型都可以用数学形式表示，常用的有图的形式、关系形式及逻辑形式等。其中基于关系代数与关系演算的关系数据模型是计算机科学的重大理论成果，它对数据库的发展起着关键性与基础性的作用。关系代数模型运用了关系及关系运算，实现数据库中数据结构的描述，数据操作、操作优化及规范化的表示；关系演算模型运用了谓词逻辑理论，以实现数据库中数据结构的表示、数据操作及查询优化，并通过谓词推理获取查询结果。由关系代数而建立起了关系数据库，由关系演算而建立起了知识库与演绎数据库，开创了数据库学科研究的重大方向。几十年来，基于关系数据模型的关系型数据库系统一直是主流数据库系统。
关系的传递性,性质,"['第五章 关系模型与理论', '§ 5.3 关系的基本性质', '5.3.3 关系的传递性']","{'实体类型': '性质', '定义': '设R是集合A上的关系，对于任意x,y,z∈A，若从⟨x,y⟩∈R且⟨y,z⟩∈R这两个条件中推出⟨x,z⟩∈R，则称关系R是传递关系，或称关系R具有传递性'}",,3,"日常工作和生活中的很多关系都具有某种传播或传递性质，例如：对于同学关系，如果  
张三四是李四的同学，李四又是王五的同学，那么张三必然是王五的同学；对于两条直线之间的平行关系，如果直线$a$ 与直线$b$ 平行，而直线$b$ 又与直线c 平行，那么必有直线$a$ 与直线$c$ 平行；对于两个整数之间的整除关系，如果整数$m$ 能够整除整数$n$，整数$n$ 又能整除$k$，那么$m$ 必然能整除整数$k$，等等。将这些不同具体关系所具有传播性质或传递性质进行抽象，得到如下关于关系传递性质的概念：  
【定义5.21】设$R$ 是集合$A$ 上的关系，对于任意$x,y,z\in A$，若从$\langle x,y\rangle\in R$且$\langle y,z\rangle\in R$这两个条件中推出$\langle x,z\rangle\in R$，则称关系$R$ 是传递关系，或称关系$R$具有传递性。即有： $(\forall x)(\forall y)(\forall z)(x\in A\land y\in A\land z\in A\land\langle x,y\rangle\in R\land\langle y,z\rangle\in R\to\langle x,z\rangle\in R)\Leftrightarrow R$为传递关系$\quad\text{(5-14) }$"
关系的基本性质,概念,"['5.3.4 关系性质的判定', '第五章 关系模型与理论', '5.3.3 关系的传递性', '§ 5.3 关系的基本性质']","{'实体类型': '概念', '定义': ['关系所具有的传播或传递性质', '关系的五个基本性质在关系图和关系矩阵上能够找到表征这些性质的相关图特征和矩阵特征'], '判定方法': '使用关系图或关系矩阵的相关特征判定关系是否具备基本性质', '本质': '关系是以序偶为元素的集合', 'name': '关系的基本性质'}",,3,"日常工作和生活中的很多关系都具有某种传播或传递性质，例如：对于同学关系，如果  
张三四是李四的同学，李四又是王五的同学，那么张三必然是王五的同学；对于两条直线之间的平行关系，如果直线$a$ 与直线$b$ 平行，而直线$b$ 又与直线c 平行，那么必有直线$a$ 与直线$c$ 平行；对于两个整数之间的整除关系，如果整数$m$ 能够整除整数$n$，整数$n$ 又能整除$k$，那么$m$ 必然能整除整数$k$，等等。将这些不同具体关系所具有传播性质或传递性质进行抽象，得到如下关于关系传递性质的概念：  
【定义5.21】设$R$ 是集合$A$ 上的关系，对于任意$x,y,z\in A$，若从$\langle x,y\rangle\in R$且$\langle y,z\rangle\in R$这两个条件中推出$\langle x,z\rangle\in R$，则称关系$R$ 是传递关系，或称关系$R$具有传递性。即有： $(\forall x)(\forall y)(\forall z)(x\in A\land y\in A\land z\in A\land\langle x,y\rangle\in R\land\langle y,z\rangle\in R\to\langle x,z\rangle\in R)\Leftrightarrow R$为传递关系$\quad\text{(5-14) }$"
关系的基本运算,概念,"['5.2.2 关系的复合运算', '第五章 关系模型与理论', '§ 5.2 关系的基本运算', '5.2.1 关系的集合运算']","{'实体类型': '概念', '定义': '在关系概念的基础上考察的运算，对关系进行集合运算和复合运算的操作', '特点': '关系作为一种特殊的集合，可以按集合的概念进行交、并、差、补等集合运算，新的集合由序偶组成，也是关系', '应用': '通过适当的方式进行合成或串接形成一个新的关系，解决日常生活和工作中关系问题', '衍生运算': '关系的幂运算、逆运算，以及面向数据库操作的连接、投影等专用关系运算', 'name': '关系的基本运算'}",,2,本节在关系概念的基础上考察关系的基本运算。首先，关系作为一种特殊的集合，可以按集合的概念进行交、并、差、补等集合运算。此外，从关系图可以看出，从集合$𝐴$到集合$B$的关系是一种从此到彼的方向性联系，故此可将两个关系通过适当的方式进行合成或串接形成一个新的关系，由此得到关系的复合运算。由关系的集合运算与复合运算还可进一步衍生出关系的幂运算、逆运算，以及面向数据库操作的连接、投影等专用关系运算。
关系的复合运算,算法,"['第五章 关系模型与理论', '§ 5.2 关系的基本运算', '5.2.2 关系的复合运算']","{'实体类型': '算法', '定义': '通过中间媒介或传递作用，在两个关系之间产生新的关系', '条件': '仅当R的后域是S的前域时，R和S才可复合', '特点': '具有集合、关系图和矩阵三种表现形式下的具体计算方法'}",,3,"日常生活和工作中很多关系问题仅用关系的集合运算不能得到有效的解决。例如：假设集合$𝐴$表示某家族的全部成员构成的集合，在$𝐴$上定义如下两个关系$R$和$𝑆$：  
$R$表示$A$上的兄弟关系，$\langle x,y\rangle\in R$,当且仅当$x$是$y$的兄弟;  
$S$表示 $A$ 上的父子关系，$\langle y,z\rangle\in S$,当且仅当$y$ 是$z$ 的父亲。  
则可通过元素$y$的中间媒介或传递作用，在$x$与$z$之间产生一个新的关系，即叔侄关系。换句话说，叔侄关系是由兄弟关系和父子关系的合成。  
![](images/8ed5b0cc3c8222133404e26aeb757d647b1fb51cdae3d0c7fbf0c3754976758e.jpg)
图5-7 叔侄关系图  
例如，假设在小说《红楼梦》中人物的兄弟关系为𝑅、父子关系为𝑆，则有：
$$
\begin{aligned}&R=\left\{\langle\text{贾宝玉},\text{贾环}\rangle,\langle\text{贾政},\textbf{贾赦}\rangle,\cdots\right\};\\&S=\left\{\langle\text{贾政},\text{贾宝玉}\rangle,\langle\text{贾政},\text{贾环}\rangle,\langle\textbf{贾赦 贾琏}\rangle,\cdots\right\}\end{aligned}
$$
如图5-7 所示，在上述$R$和$𝑆$这两个二元关系中，贾政和贾琏之间通过贾赦的中间媒介或传递作用建立了叔侄关系。一般地，将关系这种合成机制进行抽象，用数学语言进行表达，就得到如下关系复合运算的定义：  
【定义5.14】假设$A$、$B$、$C$ 是三个非空集合，$R$ 是从$A$ 到$B$ 的关系，$S$ 是从$B$ 到$C$的关系，则$R$ 与$S$ 的复合关系$R\circ S$定义为如下从$A$ 到$C$的关系：  
$$R\circ S=\{\langle x,z\rangle|x\in A\land z\in C\land(\exists y)(y\in B\land x R y\land y S z)\quad\text{(5-5)}$$  
运算“ ∘”称为复合运算。  
从上述定义可知：不是任意两个关系都能进行复合运算，当且仅当$R$ 的后域是$S$的前域时，$R$ 和$S$ 才可复合；$R\circ S$的前域是$R$ 的前域$A$，$R\circ S$的后域是$S$ 的后域$C$。  
任何一个关系都有集合、关系图和矩阵这三种表现形式，复合运算在这三种不同表现形式下分别具有相应的具体计算方法，下面分别介绍这三种复合计算方法。  
令$A=\{a_1,a_2,\cdots,a_m\},B=\{b_1,b_2,\cdots,b_n\},C=\{c_1,c_2,\cdots,c_t\},R$ 是$A$ 到$B$ 的关系，$S$ 是$B$ 到 $C$ 的关系，即有$R$$\subseteq{A}\times{B}$, $S$$\subseteq{B}\times{C}$, 则$R\circ S$可按下列方法进行计算.  
1 ．集合法    由复合运算的定义可知，对于任意的 $a_{i}\in A,c_{j}\in C$ ，若 $\langle a_{i},c_{j}\rangle\in R\circ S$ ，则 必然存在某个$b_{k}\in B$，使得$\langle a_{i},b_{k}\rangle\in R$并且$\langle b_{k},c_{j}\rangle\in S$。故对于$R$中每个给定的序偶$\langle a_{i},b_{k}\rangle$，要在$S$中寻遍第一元素为$b_{k}$的序偶$\langle b_{k},c_{j}\rangle$，若存在$\langle b_{k},c_{j}\rangle\in S$，则取$R$中$\langle a_{i},b_{k}\rangle$的第一元素，以及$S$中对应序偶$\langle b_{k},c_{j}\rangle$的第二元素，形成一个新的序偶$\langle a_{i},c_{j}\rangle$，该序偶即为$R\circ S$中的一个元素。同理可找出$R\circ S$中的所有元素。  
2. 关系图法  由复合运算的定义可知，对于分别属于关系$R$ 和$S$的两个序偶，它们之间能够复合的关键在于能够在这两个序偶之间找到一个桥梁$b_{k}$，使得$b_{k}$既是前一个序偶($R$中序偶)的第二元素，同时又是后一个序偶(S 中序偶)的第一元素。因此，在画复合关系的关系图时，首先应该在$R$ 和$S$ 这两个关系的关系图中搭起这个桥梁，然后拆掉中间的桥梁，直接联结经过该桥梁的两个结点，便可得到$R\circ S$的关系图。  
3.关系矩阵法  将$R$ 和$S$ 的关系矩阵做布尔积运算$\odot$，即可得到$\mathrm{~\tt~R~o~}S$的关系矩阵，然后根据该矩阵写出$R\circ S$中元素即可。也就是说，令$R$ 和$S$ 的关系矩阵分别为：
$$
M_{R}=\begin{pmatrix}\langle a_1,b_1\rangle&\langle a_1,b_2\rangle&\cdots\langle a_1,b_n\rangle\\\langle a_2,b_1\rangle&\langle a_2,b_2\rangle&\cdots\langle a_2,b_n\rangle\\\vdots\\\langle a_m,b_1\rangle\langle a_m,b_2\rangle&\cdots\langle a_m,b_n\rangle\end{pmatrix};\quad M_{S}=\begin{pmatrix}\langle b_1,c_1\rangle&\langle b_1,c_2\rangle&\cdots&\langle b_1,c_t\rangle\\\langle b_2,c_1\rangle&\langle b_2,c_2\rangle&\cdots&\langle b_2,c_t\rangle\\\vdots\\\langle b_n,b_1\rangle\langle b_n,c_2\rangle&\cdots\langle b_n,c_t\rangle\end{pmatrix}
$$
则有：
$$
M_{R\circ S}=M_{R}\odot M_{S}=\left(\begin{array}{c}{{\langle a_{1},c_{1}\rangle\ \langle a_{1},c_{2}\rangle\ \cdots\ \langle a_{1},c_{t}\rangle}}\\ {{\langle a_{2}.\,c_{1}\rangle\ \langle a_{2},c_{2}\rangle\ \cdots\ \langle a_{2},c_{t}\rangle}}\\ {{\vdots}}\\ {{\langle a_{m},c_{1}\rangle\langle a_{m},c_{2}\rangle\cdots\langle a_{m},c_{t}\rangle}}\end{array}\right)
$$  
【定理5.5】设$A$、$B$、$C$ 和$D$ 是任意四个集合，$R$、$S$和$T$ 分别是从$A$ 到$B,\ B$到$C$和$C$ 到$D$ 的二元关系，$I_{A}$和$I_{B}$分别是$A$ 和$B$ 上恒等关系，则有：
$$
(1) (R\circ S)\circ T=R\circ(S\circ T);\quad(2) I_A\circ R=R\circ I_B=R
$$  
下面的定理给出了关系的集合运算与复合运算之间的关系：复合运算对并运算具有完全的分配律，而复合运算对交运算只有有半分配律。  
【定理5.6】设$A$、$B$、$C$和$D$ 是任意四个集合，$R$ 是$A$ 到$B$ 的关系，$S_{1},\ S_{2}$是从$B$ 到$C$的关系，$T$是从$C$ 到$D$ 的关系，则有：  
（1）$R\circ(S_{1}\cup S_{2})=(R\circ S_{1})\cup(R\circ S_{2});\,\,\,(2)\,\,\,R\circ(S_{1}\cap S_{2})\subseteq(R\circ S_{1})\cap(R\circ S_{2});$ （3）$(S_{1}\cup S_{2})\circ T=(S_{1}\circ T)\cup(S_{2}\circ T);\ \ (4)\ \ (S_{1}\cap S_{2})\circ T\subseteq(S_{1}\circ T)\cap(S_{2}\circ T)。$  
上述定理和例题表明，复合运算对并运算具有完全的分配律，即分配律是以集合相等的方式出现，但复合运算对交运算不具备完全分配律，只有半分配律，也就是说，分配律是以集合包含的方式出现。如果要将关系的这些运算与数的相关运算做一些类比的话，那么关系的复合运算就比较类似于数或矩阵的乘法运算，而关系的并运算就比较类似于数或矩阵的加法运算。事实上，从复合运算和并运算的关系矩阵运算特点上，就可看出它们与数乘、数加以及矩阵乘、矩阵加的类似之处。"
关系的数学模型,概念,"['第五章 关系模型与理论', '§ 5.1 关系的数学模型', '5.1.3 关系的表示', '3、矩阵表示法']","{'实体类型': '概念', '定义': '用于对实际问题进行建模的数学模型', '应用': '实现对实际问题的求解'}",,4,"在使用关系的数学模型对实际问题进行建模的时候，通常需要对关系模型进行一些定量的数值计算以实现对实际问题的求解，此时无论是关系的集合表示方法和关系图法，都不方便实现对关系模型定量的数值计算。为此，我们引入二元关系的矩阵表示法。  
假设$\boldsymbol A=\{a_{1},a_{2},\cdots,a_{n}\}$, $B=\{b_{1},b_{2},\cdots,b_{m}\}$是任意给定的两个非空有限集合，$R$是$A$到$B$的一个二元关系，则按下列方式定义的$m\times n$阶矩阵$M_{R}=(r_{i j})_{m\times n}$称为$R$的关系矩阵：
$$
r_{ij}=\begin{cases}1\text{,若}\langle a_i,b_j\rangle\in R\\0\text{,若}\langle a_i,b_j\rangle\not\in R\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-3)}
$$
其中$A$中元素$a_{i\cdot}$序号对应矩阵元素的行下标，$B$中元素$b_{j}$序号对应矩阵元素的列下标。  
值得注意的是：由关系矩阵的定义可知，关系矩阵的元素有且仅有0 和1 这两种状态，这样的矩阵一般称之为布尔矩阵，主要用于一些逻辑演算，在运算规则上与普通矩阵有一些差异。为满足后续内容学习的需要，在此简要介绍布尔矩阵的若干基本运算，具体包括并运算、交运算、补运算和布尔积运算，其具体定义如下：  
【定义5.9】设$A=\left(a_{i j}\right)$和$B=\left(b_{i j}\right)$是两个$m\times n$布尔矩阵，则$𝐴$和$B$的并矩阵定义为如下$m\times n$布尔矩阵：$A\lor B=C=\left(c_{i j}\right)$，其中：  
$c_{ij}=\begin{cases}1\text{,如果}a_{ij}=1\text{ 或}b_{ij}=1\\0\text{,如果}a_{ij}=0\text{ 且}b_{ij}=0\end{cases}(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-4)}$      （5-4）  
【定义5.10】设$A=\left(a_{i j}\right)$和$B=\left(b_{i j}\right)$是两个$m\times n$布尔矩阵，则$A$和$B$的交矩阵定义为如下一个$m\times n$布尔矩阵：$A\land B=C=\left(c_{i j}\right)$，其中：
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=1\text{ 且}b_{ij}=1\\0\text{,如果}a_{ij}=0\text{ 或}b_{ij}=0\end{cases}(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-5)}
$$
【定义5.11】设$A=\left(a_{i j}\right)$任意给定的一个$m\times n$布尔矩阵，则𝐴的补矩阵定义为如下$m\times$$n$布尔矩阵：$\bar{A}=C=\left(c_{i j}\right)$，其中：
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=0\\0\text{,如果}a_{ij}=1\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-6)}
$$
【定义5.12】设$A=\left(a_{i j}\right)$是$m\times p$矩阵，$B=\left(b_{i j}\right)$是$p\times n$矩阵，则$𝐴$和$B$的布尔积矩阵定义为如下$m\times n$布尔矩阵：$A\odot B=C=\left(c_{i j}\right)$，其中：  
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=0\\0\text{,如果}a_{ij}=1\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-6)}
$$
需要注意的是：两个布尔矩阵可进行布尔或和布尔与运算的前提是这两个矩阵具有相同的行数和列数，可进行布尔积运算的前提是前一个矩阵的列数等于后一个矩阵的行数。  
在学习了二元关系的三个基本表示方法后，下面我们考察空关系、完全关系和恒等关系这三个常用特殊关系的关系矩阵和关系图各有什么特点：  
(1) 空关系$\varnothing$  因为$\emptyset\subseteq A\times B$(或$\emptyset\subseteq A\times A)$)，所以$\varnothing$也是一个从$𝐴$到$B$(或$𝐴$上)的关系，称之为空关系，即无任何元素的关系。空关系的关系图中只有结点，无任何边，且关系矩阵中的元素全是0  
(2) 完全关系（全域关系） $A\times B$或(或$A\times A)$本身也是一个从$𝐴$到$B$(或$𝐴$上)的关系，称之为完全关系，即含有全部序偶的关系。完全关系的关系图中所有结点之间都有有向边互联，关系矩阵中的元素全是1。  
(3) 恒等关系 $I_{A}$  $I_{A}\subseteq A\times A$，则$I_{A}=\{\langle x,x\rangle|x\in A\}$为$A$上的恒等关系。完全关系的关系图中所有结点都有一个有向环，不同结点之间无任何有向边联结。  
![](images/9a95167e68610708edb7fef0f0474b8284d349dcc5f3b662d3280809d00fbf1e.jpg)
图5-6 空关系、全关系与恒等关系  
设$A=\left\{1,\ 2,\ 3\right\}$，则$A$ 上的空关系∅、完全关系$A\times A$及恒等关系$I_{A}$的关系图如图5-6 所示，下面三个布尔矩阵分别是它们的关系矩阵：  
$M_{\emptyset}=\left(\begin{array}{ccc}0&0&0\\0&0&0\\0&0&0\end{array}\right)\quad M_{A\times A}=\left(\begin{array}{ccc}1&1&1\\1&1&1\\1&1&1\end{array}\right)\quad M_{I_A}=\left(\begin{array}{ccc}1&0&0\\0&1&0\\0&0&1\end{array}\right)$"
关系的数学理论,原理,['第五章 关系模型与理论'],"{'实体类型': '原理', '基础': '集合论', '目的': '描述给定集合上元素与元素之间的二元或多元关系，考察集合中元素之间在一定次序下是否具备某些特定关系', '发展': '与集合论、数理逻辑、组合学、图论和布尔代数等多个数学分支交叉融合'}",,1,"我们知道，日常生活或工作中的各种对象之间存在着千丝万缕的联系，包括人与人之间、人与物之间、物与物之间的联系。这种联系通常称之为关系，例如人与人之间的关系有兄弟关系、姻亲关系、朋友关系、同学关系、同事关系等等。这些关系反映了人与人之间各种错综复杂的活动，以这些关系为基础便可进一步衍生出许许多多不同的含义。事实上，一个人社会关系的宽泛程度通常标志着这个人某种能力的大小、威望的高低等等。同样，计算机领域的各种对象之间也存在诸多错综复杂的关系，例如计算机程序中输入与输出之间的关系、数据库中各种数据属性之间的关系、计算机语言中各种标识符之间的关系等等。要想让计算机系统能够自动、高效、正确地处理好这些关系，就必须建立一套完备严谨的关系模型与理论，为数据结构、数据库、信息检索、算法设计与分析、操作系统等计算机专业课程中各种对象之间关系的表达和处理提供有效的基础工具。  
正如计算机不能正确理解和处理基于自然语言表达的形式逻辑，计算机同样不能正确理解和处理用自然语言表达的关系模型与理论。因此，就像使用数理逻辑表达和处理形式逻辑问题一样，我们必须使用数学方法来表达和处理关系问题，面向关系问题建立一整套完备严谨的数学模型与数学理论。事实上，关系问题也是数学学科的一个重要研究对象，处理关系的数学理论诞生于著名数学家豪斯道夫1914 年出版的著作《集论基础》。经过100 多年的发展，关系数学理论已与集合论、数理逻辑、组合学、图论和布尔代数等多个数学分支交叉融 合，并通过吸收、借鉴这些数学分支的相关内容形成了一套相对完备的关系数学理论。  
关系的数学理论以集合论为基础，旨在描述给定集合上元素与元素之间的二元或多元关系，并考察集合中元素之间在一定次序下是否具备某些特定关系。从本章开始的连续三章将系统地介绍和讨论关系的数学模型与理论，本章着重介绍关系数学模型与理论的基本知识，包括关系的数学模型、关系的基本运算、关系的基本性质、关系集合的闭包等。"
关系的集合表示法,概念,"['第五章 关系模型与理论', '§ 5.1 关系的数学模型', '5.1.3 关系的表示', '1、集合表示法（枚举法和描述法）']","{'实体类型': '概念', '定义': '将关系用集合的形式表示', '方法': '枚举法和描述法'}",,4,"关系的集合表示法主要有枚举法和描述法两种。所谓枚举法，就是将作为关系的集合中所有序偶一一枚举出来；所谓描述法，就是用集合的描述法表示作为关系的集合。例如，对于集合$A=\{1,2,3,4\}$上的整除关系$R$，如果用描述法表示，则有：${R=\{\langle a,b\rangle|a|b\}}$；如果用$R=\{\langle1,1\rangle,\langle1,2\rangle,\langle1,3\rangle,\langle1,4\rangle,\langle2,2\rangle,\langle2,4\rangle,\langle3,3\rangle,\langle4,4\rangle\}.$"
关系的集合运算,概念,"['第五章 关系模型与理论', '§ 5.2 关系的基本运算', '5.2.1 关系的集合运算']","{'实体类型': '概念', '定义': '设R、S都是从集合A到B的两个关系，定义它们的交、并、差、补运算', '性质': '集合交、并、差、补运算的性质对关系集合运算也成立'}",,3,"二元关系是以序偶为元素的集合，因此可以对它进行集合的运算，通过集合的交、并、差、补等运算而产生新的集合。这些新的集合显然也是由序偶组成的集合，因而也是关系。具体地说，如果$R、{S}$ 是$X$到$Y$的二元关系，那么$R\cup S$，$R\cap S$，$R-S$，$\bar{R}$也是$X$到$Y$的二元关系。具体定义如下：  
【定义5.13】设$R$、$S$都是从集合$A$ 到$B$ 的两个关系，则可按下列方式定义它们的交、并、差、补运算：
$$
R\cup S=\{\langle x,y\rangle|(x R y)\lor(x S y)\};\quad R\cap S=\{\langle x,y\rangle|(x R y)\land(x S y)\}
$$  
$$
R-S=\{\langle x,y\rangle|(x R y)\wedge(x S y)\};\quad\bar{R}=\{\langle x,y\rangle|(x S y)\}
$$
有关集合交、并、差、补运算的性质，对上述定义的关系集合运算显然也是成立的，这些性质就不再一一赘述了。这里就需要注意的是：对于任意一个从集合$A$ 到$B$ 的二元关系$R$，从集合的角度看$A\times B$是相对于$R$ 的全集，故有：
$$
\bar{R}=A\times B-R;\;\;\bar{R}\cup R=A\times B;\;\;\bar{R}\cap R=\emptyset;\;\;\bar{R}=R;\;\;S\subseteq R\Leftrightarrow\bar{R}\subseteq\bar{S}
$$
不难看出，关系的交、并、差、补运算结果还可以通过关系矩阵的计算得到：
$$
M_{H\cup S}=M_{H}\lor M_{S};\,\,\,M_{H\cap S}=M_{H}\land M_{S};\,\,\,M_{\bar{H}}=\bar{M}_{H};\,\,\,M_{H-S}=M_{H}\land\bar{M}_{S}
$$"
关系矩阵的计算,算法,"['第五章 关系模型与理论', '§ 5.2 关系的基本运算', '5.2.1 关系的集合运算']","{'实体类型': '算法', '应用': '通过关系矩阵的计算得到关系的交、并、差、补运算结果'}",,3,"二元关系是以序偶为元素的集合，因此可以对它进行集合的运算，通过集合的交、并、差、补等运算而产生新的集合。这些新的集合显然也是由序偶组成的集合，因而也是关系。具体地说，如果$R、{S}$ 是$X$到$Y$的二元关系，那么$R\cup S$，$R\cap S$，$R-S$，$\bar{R}$也是$X$到$Y$的二元关系。具体定义如下：  
【定义5.13】设$R$、$S$都是从集合$A$ 到$B$ 的两个关系，则可按下列方式定义它们的交、并、差、补运算：
$$
R\cup S=\{\langle x,y\rangle|(x R y)\lor(x S y)\};\quad R\cap S=\{\langle x,y\rangle|(x R y)\land(x S y)\}
$$  
$$
R-S=\{\langle x,y\rangle|(x R y)\wedge(x S y)\};\quad\bar{R}=\{\langle x,y\rangle|(x S y)\}
$$
有关集合交、并、差、补运算的性质，对上述定义的关系集合运算显然也是成立的，这些性质就不再一一赘述了。这里就需要注意的是：对于任意一个从集合$A$ 到$B$ 的二元关系$R$，从集合的角度看$A\times B$是相对于$R$ 的全集，故有：
$$
\bar{R}=A\times B-R;\;\;\bar{R}\cup R=A\times B;\;\;\bar{R}\cap R=\emptyset;\;\;\bar{R}=R;\;\;S\subseteq R\Leftrightarrow\bar{R}\subseteq\bar{S}
$$
不难看出，关系的交、并、差、补运算结果还可以通过关系矩阵的计算得到：
$$
M_{H\cup S}=M_{H}\lor M_{S};\,\,\,M_{H\cap S}=M_{H}\land M_{S};\,\,\,M_{\bar{H}}=\bar{M}_{H};\,\,\,M_{H-S}=M_{H}\land\bar{M}_{S}
$$"
关系逆运算与关系集合运算的分配律,定理,"['第五章 关系模型与理论', '§ 5.2 关系的基本运算', '5.2.3 幂关系与逆关系']","{'实体类型': '定理', '内容': '设R, S是从集合A到集合B的关系，则有如下分配律：(R∪S)^{-1}=R^{-1}∪S^{-1}; (R∩S)^{-1}=R^{-1}∩S^{-1}; (R-S)^{-1}=R^{-1}-S^{-1}'}",,3,"如前所述，关系的复合运算满足结合律。也就是说，如果有多个关系进行复合运算，只要不交换它们的运算次序，不管哪个先参与合成，最后结果都一样。由此可见，对于某个集合上的一个二元关系，如果它可以不断地与自己做复合运算，那么运算结果只与该关系以及复合运算次数有关，而与复合的次序无光。由此可得如下关系方幂运算的概念：  
【定义5.15】设$R$ 是集合$A$ 上的关系，则可归纳定义$R$ 的$n$次方幂${R^{n}}$运算如下：  
$（1）R^{0}=I_{A}=\left\{\langle a,\ a\rangle\big|a\in A\right\};\quad(\,2\,)\,\ R^{1}=R;\ (\,3\,)\,\ R^{n+1}=R^{n}\circ R=R\circ R^{n}\circ R.$    方幂运算的结果也显然也是$A$ 上的二元关系，即对于任何自然数$k$，有$R^{k}\subseteq A\times A$。通常称为$R$的方幂关系或幂关系，不难证明方幂运算满足如下运算法则：
$$
R^{m}\circ R^{n}=R^{m+n};\,\,\,(R^{m})^{n}=R^{m n}
$$  
由上述例题可以看出：  
（1）幂集$R^{n}$的基数$\vert{R}^{n}\vert$并非随着$n$ 的增加而增加，而是呈递减趋势；  
（2）当$n\geq|A|$时，则$R^{n}$出现循环取值或退化为空关系。 下面的定理给出了上述结论的一个解释：  
【定理5.7】设𝐴是一个具有${n}$个元素的有限集合，$R$ 是$𝐴$上的二元关系，则必存在自然数$s$ 和$t$，使得$R^{s}=R^{t}$，$0\leq s<t\leq2^{n^{2}}$。  
上述定理表明，对于任意一个有限集合，该集合上的二元关系总共只有有限多个，而对于该集合上的二元关系，其方幂运算则可以无限地进行下去且运算结果均为该集合上的二元关系。因此，在一定次数的方幂运算之后，后续的方幂运算结果自然是以某种循环的方式出现，或者以恒等于某个特定关系的方式出现。  
【定义5.16】设$A,\ B$ 是任意两个集合，$R$ 是$A$ 到$B$ 的关系，则从$B$ 到$A$ 的关系：
$$
R^{-1}=\{\langle b,a\rangle|\langle a,b\rangle\in R\}\quad\text{(5-9)}
$$
称为$R$ 的逆关系，运算“-1”称为关系的逆运算。  
关于逆关系概念的理解，需要注意如下几个要点：（1）关系是序偶的集合，逆关系也是序偶的集合；（2）如果$R$ 是一个关系，则其逆关系$R^{-1}$和补关系$\bar{R}$都是关系，但是两者是完全不同的两个关系，千万不要混淆；（3）显然有$(R^{-1})^{-1}=R$，$\varnothing^{-1}=\varnothing$。  
【定理5.8】设$A$，$B$ 和$C$是任意三个集合，$R$，$S$ 分别是从$A$ 到$B$ 和$B$ 到$C$的二元关系，则有：$(R\circ S)^{-1}=S^{-1}\circ R^{-1}$  
可以看出，复合关系的逆关系等于它们逆关系的反复合。要注意$(R\circ S)^{-1}\neq R^{-1}\circ S^{-1}$，因为$R^{-1}$是从$B$ 到$A$ 的关系，而$S^{-1}$是从$C$ 到$B$ 的关系，因此$S^{-1}$与$R^{-1}$之间是可复合的，而$R^{-1}$与$S^{-1}$之间是不可复合的。  
下面定理给出了关系逆运算与关系集合运算之间的分配运算律：  
【定理5.9】设$R,\ S$是从集合$A$ 到集合$B$ 的关系，则有如下分配律：
$$
(R\cup S)^{-1}=R^{-1}\cup S^{-1};\;\;(R\cup S)^{-1}=R^{-1}\cup S^{-1};\;\;(R-S)^{-1}=R^{-1}-S^{-1}
$$  
对于任意给定的集合𝐴和$B$，目前所讨论的二元关系有两种基本类型，一种是集合$𝐴$到集合$ B$上的二元关系，另外一种是集合𝐴上的二元关系。事实上，这两种关系没有本质上的区别，因为若令$C=A\cup B$，则集合$𝐴$到集合$B$上的二元关系就可以看成是$C\times C$的几个子集合，或者说是$C$上的二元关系。因此，在后续内容中所说的关系，若非特别说明，均为某个集合上的关系而不是从某个集合到另外一个集合上的关系。"
关系闭包,概念,"['第五章 关系模型与理论', '§ 5.4 关系的性质闭包', '5.4.1  关系闭包的概念']","{'实体类型': '概念', '定义': '对关系进行扩充，使其满足自反性、对称性或传递性的最小扩充', '类型': '包括自反闭包、对称闭包和传递闭包'}",,3,"首先，我们考察关系的自反闭包。假设$R$ 是集合$A$ 上的二元关系，如果$R$ 不满足自反性，就说明集合$A$ 中存在某个元素$a.$,使得$\langle a,a\rangle\not\in R$，此时可以将关系R 进行调整或修改，避免这种情况的发生。具体地说，就是将序偶$\langle a,a\rangle$纳入到关系$R$ 由此产生一个新的关系$R^{\prime}$。一般地，如果对于$A$ 中的每个元素${x}$，都将$\langle x,x\rangle$纳入到关系$R$，由此产生新的关系$R^{\prime}$必然满足自反性。事实上，关系$R^{\prime}$是对关系$R$ 的一种扩充，使得扩充后的关系能够满足自反性。若能证明这种扩充是满足扩充目的最小扩充，则$R^{\prime}$就是关系$R$ 的自反闭包。  
可同理考察对称闭包。假设$R$ 是集合$A$ 上的二元关系，如果$R$ 不满足对称性，就说明集合$A$ 中存在两个元素$a$和$b$使得$\langle a,b\rangle\in R$，但$\langle b,a\rangle\not\in R$。此时，只需将$\langle b,a\rangle$纳入$R$ 中就可避免这种情况发生。因此，可以对$R$ 进行适当扩充构成其对称闭包。  
可类似考虑传递闭包的基本思想，不再赘述。下面给出这三个闭包的具体定义：  
【定义5.22】设$R$ 是集合$A$ 上的关系，若存在$A$ 上的另一个关系$R^{\prime}$，满足：  
（1）$R^{\prime}$是自反的（对称的、或传递的）  
（2）对$A$ 上任何自反（对称的、或传递）关系$R^{\prime\prime}$，如果$R\subseteq R^{\prime\prime}$，那么$R^{\prime}\subseteq R^{\prime\prime}$，则称${R^{\prime}}$为$R$的自反闭包（对称闭包或传递闭包），记为$r(R)(s(R)$或$t(R))$。  
下面定理给出了自反闭包和传递闭包的构造方法：  
【定理5.12】设$R$ 是非空集合$A$ 上的关系，则有：  
$r(R)=R\cup R^{0};\,\,\,s(R)=R\cup R^{-1}$  
由上述例题可得利用关系图求关系$R$ 闭包的方法：  
（1）检查$R$ 的关系图，在没有自环的结点处加上自环，可得$r(R)$的关系图；  
（2）检查$R$ 的关系图，将每条单向边全部改成双向边，可得$s(R)$的关系图；  
（3）检查$R$ 的关系图，从每个结点出发，找到其终点，如果该结点到其终点没有边相连，就加上此边，由此可得$t(R)$的关系图。"
关系闭包的性质,性质,"['第五章 关系模型与理论', '§ 5.4 关系的性质闭包', '5.4.3  关系闭包的性质']","{'实体类型': '性质', '定义': '关系闭包的基本性质', '定理5.14': '若R是A上二元关系，则有：(1)R是自反的，当且仅当r(R)=R；(2)R是对称的，当且仅当s(R)=R；(3)R是传递的，当且仅当t(R)=R。', '定理5.15': '若R是A上二元关系，则有：(1)R是自反的，则s(R)和t(R)也是自反的；(2)R是对称的，则r(R)和t(R)也是对称的；(3)R是传递的，则r(R)也是传递的。', '说明': '上述定理讨论了关系性质和闭包运算之间的联系；(1)如果关系R是具有自反性，那么经过闭包运算之后得到的关系仍然具有自反性；(2)如果关系R是具有对称性，那么经过闭包运算之后得到的关系仍然具有对称性；(3)但是对于具有传递性的关系不是如此，其自反闭包仍然具有传递性，而其对称闭包则不一定具有传递性。', '定理5.16': '设A是一个非空有限集合，R和S均为A上二元关系，则有：(1)若R⊆S，则有：r(R)⊆r(S)；s(R)⊆s(S)；t(R)⊆t(S)。(2)r(R∪S)=r(R)∪r(S)；s(R∪S)=s(R)∪s(S)；t(R)∪t(S)⊆t(R∪S)。', '多重闭包的性质': '对于非空集合A上的二元关系R，由于其自反闭包r(R)、对称闭包s(R)和传递闭包t(R)仍然是A上的二元关系，因此可以对这些闭包进一步做不同的闭包，例如在自反闭包r(R)的基础上再做对称闭包或传递闭包、在对称闭包s(R)的基础上再做自反包或传递闭包、在传递闭包t(R)的基础上再做自反包或对称闭包等，由此可以得到多重闭包。', '定理5.17': '设A是一个含有n个元素的非空集合，R是A上二元关系，则有：(1)rs(R)=sr(R)；(2)rt(R)=tr(R)；(3)st(R)⊆ts(R)'}",,3,"下面讨论关系闭包的一些基本性质：  
【定理5.14】若$R$ 是$A$ 上二元关系，则有：  
（1）$R$ 是自反的，当且仅当$r(R)=R$  
（2）$R$ 是对称的，当且仅当$s(R)=R$；  
（3）$R$ 是传递的，当且仅当$t(R)=R$。  
【定理5.15】若$R$ 是$A$ 上二元关系，则有：  
（1）$R$ 是自反的，则$s(R)$和$t(R)$也是自反的；  
（2）$R$ 是对称的，则$r(R)$和$t(R)$也是对称的；  
（3）$R$ 是传递的，则$r(R)$也是传递的。  
说明：上述定理讨论了关系性质和闭包运算之间的联系；  
（1）如果关系$R$ 是具有自反性，那么经过闭包运算之后得到的关系仍然具有自反性；  
（2）如果关系$R$ 是具有对称性，那么经过闭包运算之后得到的关系仍然具有对称性；  
（3）但是对于具有传递性的关系不是如此，其自反闭包仍然具有传递性，而其对称闭包则不一一定具有传递性。例如，假设$A=\{1,\!2,\!3\}$, 则$R=\{\langle1,\!2\rangle\}$是𝐴上的传递关系，此时有$s(R)=\{\langle1,\!2\rangle,\langle2,\!1\rangle\}$。显然$s(R)$不具有传递性。  
下面定理给出了关系的闭包与集合运算之间的关系：  
【定理5.16】设$A$ 是一个非空有限集合，$R$和$𝑆$均为$A$ 上二元关系，则有：  
(1）若 $R\subseteq S$ ，则有： $r(R)\subseteq r(S);\,\,\,s(R)\subseteq s(S);\,\,\,t(R)\subseteq t(S)$ 。   (2)$r(R\cup S)=r(R)\cup r(S);\quad s(R\cup S)=s(R)\cup s(S);\quad t(R)\cup t(S)\subseteq t(R\cup S)\,。$  
对于非空集合$A$ 上的二元关系$𝑅$，由于其自反闭包$r(R)$、对称闭包$s(R)$和传递闭包$t(R)$仍然是$A$ 上的二元关系，因此可以对这些闭包进一步做不同的闭包，例如在自反闭包$r(R)$的基础上再做对称闭包或传递闭包、在对称闭包$s(R)$的基础上再做自反包或传递闭包、在传递闭包$t(R)$的基础上再做自反包或对称闭包等，由此可以得到多重闭包。下面定理给出了关于这些多重闭包的基本性质：  
【定理5.17】设$A$ 是一个含有${n}$个元素的非空集合，$R$ 是$A$ 上二元关系，则有： $(1)r s(R)=s r(R);~~~(2)r t(R)=t r(R);~~(3)~s t(R)\subseteq t s(R)$"
关联矩阵表示法,算法,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.3 图的表示方法', '二、关联矩阵表示法']","{'实体类型': '算法', '定义': '用关联矩阵表示图中结点与边之间的关联情况', '特点': '无向图的关联矩阵用数字2表示结点与边的自环关系，有向图的关联矩阵用数字-2表示结点与边的自环关系', '应用': '分析图中结点与边之间的结构信息'}",,4,"除了邻接矩阵外，还可以用关联矩阵表示图。关联矩阵主要表示图中每个结点与每条边之间的相关关系。对于任意给定的一个图模型$G$，其关联矩阵$M(G)$中元素$m_{i j}$的含义是图中结点$v_{i}$是否关联边$e_{j}$，如果$v_{i}$不关联$e_{j}$，则$m_{i j}=0$，如果$v_{i}$关联$e_{j}$，则用某个非零数字表示$m_{i j}$，具体数字依据图模型的类型和点边关联方式确定。  
与邻接矩阵一样，要确定一个图的关联矩阵，首先应对图中的所有结点进行编号，不同的结点编号对应于不同的关联矩阵，结点编号次序的交换对应于关联矩阵中行的交换。  
首先给出无向图关联矩阵的定义：  
【定义8.8】设$G=\langle V,E\rangle$是无向图 ，其中$\ V=\{v_{1},v_{2},\ldots,v_{n}\}$，$E=\{e_{1},e_{2},\dots,e_{m}\}$ ，则将$n\times m$阶矩阵$(m_{i j})_{n\times m}$称为 $G$ 的关联矩阵，记为 $M(G)$ 。其中元素$m_{i j}$ 表示图中结点 $v_{i}$ 与边 $e_{j}$ 的关联次数，具体定义如下：
$$
m_{ij}=\begin{cases}2,v_i的自环是e_j\\[2ex]1,v_i关联e_j且e_j不是自环\\[2ex]0,v_{i}不关联e_{j}\end{cases}
(i=1,2,\cdots,n,\quad j=1,\:2,\:...,\:m)(8-2)
$$  
从上述定义可以看出，无向图的关联矩阵用数字2 表示结点与边的自环关系，因为自环须与其关联结点关联 2  次。  
下面给出有向图关联矩阵的定义：  
【定义8.9】设 $D=\langle V,E\rangle$是有向图，其中 $V=\{v_{1},v_{2},\ldots,v_{n}\}$ ，$E=\{e_{1},e_{2},\dots,e_{m}\}$ ，则将${}n\times m$阶矩阵$(m_{i j})_{n\times m}$称为有向图 $D$ 的关联矩阵，记作 $M(D)$ 。 其中元素 $m_{i j}$ 表示图中结点 $v_{i}$ 与边 $e_{j}$ 的关联情况，具体定义如下：  
$$
m_{ij}=\begin{cases}-2,&v_i\text{为其关联自环}e_j\text{的起点和终点}\\1,&v_i\text{为其关联边}e_j\text{的起点但不是终点}\\-1,&v_i\text{为其关联边}e_j\text{的终点但不是起点}\\0,&v_i\text{不关联边}e_j\end{cases}
$$  
从上述定义可以看出，有向图的关联矩阵用数字−2表示结点与边的自环关系。事实上，有时候也可以用2 表示。因为有向图的自环是有方向的，即顺时针或逆时针方向。习惯上，用正数表示逆时针方向，负数表示顺时针方向。图中的自环默认为顺时针方向，故一般用−2表示结点与边的自环关系。  
对于无向图及其关联矩阵，由于每条非自环边关联2 个结点，故矩阵中每列元素之和必为2。而对于有向图及其关联矩阵，由于每条非自环有向边关联2 个结点，且一个为起点一个为终点，故图中每个非自环边在关联矩阵中所对应列元素之和必为0。  
因此，可以通过分析关联矩阵的数据特征分析来分析图中结点与边之间的结构信息。例如，对于任意一个关联矩阵，如果某行元素全为零，当且仅当该行所对应的结点为孤立结点。 再如，如果第 $j$列与第 $k$列相同，当且仅当 $e_{j}$ 与 $e_{k}$ 是平行边，或者说重边对应的列完全相同。 后面将经常使用关联矩阵分析图模型的各种结构特征。"
关联边,概念,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.2 图的定义与分类']","{'实体类型': '概念', '定义': '以结点u为端点的边'}",,3,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)"
关键作业,概念,"['第八章  图的基本理论与算法', '§ 8.5 图模型的应用', '8.5.2 作业规划问题']","{'实体类型': '概念', '定义': '关键路径上的边所代表的作业', '特点': '其最早启动时间和最晚启动时间相等'}",,3,"生活中有着多种多样的工程，而每一项工程往往都是由多种不同的活动相互组合而成，这些活动中，有的可以并行执行，而有的活动却必须要等到前面的准备活动都做好之后才能开始进行。例如，在一个软件开发项目中，包括以下几个阶段：需求分析，系统设计，模块代码编写，单元测试，软件维护。其中代码编写和单元测试可以同时进行，但是代码编写却一定要在需求分析和系统设计完成之后才行，需求分析和系统设计构成了代码编写的准备工作。既然存在这样的现象，那么在一项很复杂的工程中，如何合理的安排活动的进行，能够使得整个工程完成时间最早呢？其实，这就是关键路径问题。在求解关键路径问题之前，我们有必要先了解下PERT 图的相关概念。  
PERT 图是一个有向连通图$G=\langle V,E\rangle$，且  
（1）每条边表示一个作业（工序），边的非负实数权表示完成该作业所需的时间；  
（2）每个顶点表示以该顶点为起点的作业开始，也表示以该顶点为终点的作业结束；  
（3）作业开始条件：某条有向边$e=\langle v,u\rangle$所代表的作业可以开始 当且仅当 以v为终点的有向边所代表的作业全部完成；  
（4）G没有有向回路，也没有环；  
（5）G中有且仅有一个顶点的入度为0，称该顶点为源点；同时G中有且禁言一个顶点的出度为0，称该顶点为汇点。  
对于给定的PERT 图$G=\langle V,E\rangle$，我们主要关心其关键路径，以及每个作业的最早开始时间和最晚开始时间。关于PERT 图，有如下定义：  
（1）关键路径：G中从源点到汇点最长带权路径路径称为关键路径。关键路径的长度T为完成整个任务（即包括所有作业）所必需的最少时间。  
（2）关键作业：关键路径上的边所代表的作业称为关键作业。  
（3）最早启动时间：对于某个作业${e}=\left<v_{i},-\right>$，源点到该作业起点$v_{i}$的最长路径长度$\pi_{i}$称为该作业的最早启动时间。  
（4）最晚启动时间：设$v_{i}$到汇点${v}_{n}$的最长路径长度为$\pi_{i}^{\prime}$，则该作业可最晚于$\mathsf{\Delta}\mathsf{T}_{i}=\mathsf{T}-$$\uppi_{i}^{\prime}$时间启动而不影响整个任务完成的预期时间T，$\uptau_{i}$称为该作业的最晚启动时间。  
显然，作业${e}=\langle v_{i},-\rangle$是关键作业当且仅当$\pi_{i}=\uptau_{i}$，因为这时e是处于源点到汇点最长带权路径上。故可通过求每个作业的最早启动时间和最晚启动时间而得到PERT 图的关键路径。那么如何求解作业的最早启动时间和最晚启动时间呢？下面给出了求解方法：  
设PERT 图$G=\langle V,E\rangle$的顶点编号$v_{1},v_{2},\dots,v_{n}$，使得边$e=\langle v_{i},v_{j}\rangle\in E$蕴含$i<j$  
令$\pi_{1}=0$，$\pi_{j}=m a x\{\pi_{m}+w(v_{m},v_{j})|1\leq m<j\}$，则$\pi_{i}(1\leq i\leq n)$是作业$e=\langle v_{i},v_{j}\rangle$的最早启动时间。这里$w(v_{m},v_{j})$定义为：  
$w(v_m,v_j)=\begin{cases}\text{边}\langle v_m,v_j\rangle\text{的非负实数权,~~~~~~~~若}\langle v_m,v_j\rangle\in E;\\-\infty,&\text{否则}\end{cases}\text{(8-18)}$  
令$\tau_{n}=\pi_{n}$，$\tau_{k}=m a x\{\tau_{k},\tau_{k}-w(v_{k},v_{m})|k<m\leq n\}$，则$\tau_{i}(1\leq i\leq n)$是作业$e=$$\langle v_{i},v_{j}\rangle$的最晚启动时间。  
由于某顶点的最早启动时间（最晚启动时间）就是所有以该顶点为起点的作业的最早启动时间（最晚启动时间）。因此求解关键路径，可以通过计算每个顶点的最早启动时间和最晚启动时间来确定。  
另外，为了更方便的判断顶点$v_{i}$是否为关键路径上的顶点，在此定义$v_{i}$的缓冲时间$S_{i}=$$\tau_{i}-\pi_{i}$。在关键路径上，各顶点的缓冲时间𝑆均为0，任何关键作业如果耽误了时间𝑡，整个工程就耽误了时间𝑡。下面给出求解关键路径的具体例子。"
关键路径,概念,"['第八章  图的基本理论与算法', '§ 8.5 图模型的应用', '8.5.2 作业规划问题']","{'实体类型': '概念', '定义': 'G中从源点到汇点最长带权路径，长度T为完成整个任务所必需的最少时间', '特点': '决定了整个工程的最早完成时间'}",,3,"生活中有着多种多样的工程，而每一项工程往往都是由多种不同的活动相互组合而成，这些活动中，有的可以并行执行，而有的活动却必须要等到前面的准备活动都做好之后才能开始进行。例如，在一个软件开发项目中，包括以下几个阶段：需求分析，系统设计，模块代码编写，单元测试，软件维护。其中代码编写和单元测试可以同时进行，但是代码编写却一定要在需求分析和系统设计完成之后才行，需求分析和系统设计构成了代码编写的准备工作。既然存在这样的现象，那么在一项很复杂的工程中，如何合理的安排活动的进行，能够使得整个工程完成时间最早呢？其实，这就是关键路径问题。在求解关键路径问题之前，我们有必要先了解下PERT 图的相关概念。  
PERT 图是一个有向连通图$G=\langle V,E\rangle$，且  
（1）每条边表示一个作业（工序），边的非负实数权表示完成该作业所需的时间；  
（2）每个顶点表示以该顶点为起点的作业开始，也表示以该顶点为终点的作业结束；  
（3）作业开始条件：某条有向边$e=\langle v,u\rangle$所代表的作业可以开始 当且仅当 以v为终点的有向边所代表的作业全部完成；  
（4）G没有有向回路，也没有环；  
（5）G中有且仅有一个顶点的入度为0，称该顶点为源点；同时G中有且禁言一个顶点的出度为0，称该顶点为汇点。  
对于给定的PERT 图$G=\langle V,E\rangle$，我们主要关心其关键路径，以及每个作业的最早开始时间和最晚开始时间。关于PERT 图，有如下定义：  
（1）关键路径：G中从源点到汇点最长带权路径路径称为关键路径。关键路径的长度T为完成整个任务（即包括所有作业）所必需的最少时间。  
（2）关键作业：关键路径上的边所代表的作业称为关键作业。  
（3）最早启动时间：对于某个作业${e}=\left<v_{i},-\right>$，源点到该作业起点$v_{i}$的最长路径长度$\pi_{i}$称为该作业的最早启动时间。  
（4）最晚启动时间：设$v_{i}$到汇点${v}_{n}$的最长路径长度为$\pi_{i}^{\prime}$，则该作业可最晚于$\mathsf{\Delta}\mathsf{T}_{i}=\mathsf{T}-$$\uppi_{i}^{\prime}$时间启动而不影响整个任务完成的预期时间T，$\uptau_{i}$称为该作业的最晚启动时间。  
显然，作业${e}=\langle v_{i},-\rangle$是关键作业当且仅当$\pi_{i}=\uptau_{i}$，因为这时e是处于源点到汇点最长带权路径上。故可通过求每个作业的最早启动时间和最晚启动时间而得到PERT 图的关键路径。那么如何求解作业的最早启动时间和最晚启动时间呢？下面给出了求解方法：  
设PERT 图$G=\langle V,E\rangle$的顶点编号$v_{1},v_{2},\dots,v_{n}$，使得边$e=\langle v_{i},v_{j}\rangle\in E$蕴含$i<j$  
令$\pi_{1}=0$，$\pi_{j}=m a x\{\pi_{m}+w(v_{m},v_{j})|1\leq m<j\}$，则$\pi_{i}(1\leq i\leq n)$是作业$e=\langle v_{i},v_{j}\rangle$的最早启动时间。这里$w(v_{m},v_{j})$定义为：  
$w(v_m,v_j)=\begin{cases}\text{边}\langle v_m,v_j\rangle\text{的非负实数权,~~~~~~~~若}\langle v_m,v_j\rangle\in E;\\-\infty,&\text{否则}\end{cases}\text{(8-18)}$  
令$\tau_{n}=\pi_{n}$，$\tau_{k}=m a x\{\tau_{k},\tau_{k}-w(v_{k},v_{m})|k<m\leq n\}$，则$\tau_{i}(1\leq i\leq n)$是作业$e=$$\langle v_{i},v_{j}\rangle$的最晚启动时间。  
由于某顶点的最早启动时间（最晚启动时间）就是所有以该顶点为起点的作业的最早启动时间（最晚启动时间）。因此求解关键路径，可以通过计算每个顶点的最早启动时间和最晚启动时间来确定。  
另外，为了更方便的判断顶点$v_{i}$是否为关键路径上的顶点，在此定义$v_{i}$的缓冲时间$S_{i}=$$\tau_{i}-\pi_{i}$。在关键路径上，各顶点的缓冲时间𝑆均为0，任何关键作业如果耽误了时间𝑡，整个工程就耽误了时间𝑡。下面给出求解关键路径的具体例子。"
关键道路问题,概念,"['第九章  树的基本理论与算法', '§ 9.4 树模型的应用', '9.4.3 关键道路问题']","{'实体类型': '概念', '定义': '在工程中确定最短工期和最低成本的作业安排方法', '应用': '用于建筑工程等多个作业的合理安排', '解决方法': '采用PERT图模型和生成树方法计算关键路径', '计算步骤': '1. 构造以源为根的生成树并求距离；2. 调整生成树以优化路径', '特点': '通过识别关键作业和非关键作业的缓冲期，合理分配资源'}",,3,"一项工程往往由许多作业构成，其中某些作业可以同时进行，而某些作业却必须按照一定先后顺序执行。例如，在建筑工程中，一般涉及到采购材料、平整地基、预制构件、埋设管道、砌墙立屋、室内装修等多个作业。其中平整地基和预制构件可以同时进行，而室内装修却必须在砌墙立屋之后才能动工等。这样就存在问题：为了使使得工期最短、成本最低，我们应该采取什么方法安排各个作业实施？  
我们知道，PERT 图模型可以很好地解决这类问题。图9-60 是一个PERT 图，图中不含有向回路。在作业网络中每条有向边表示一个作业，边上的权表示完成该项作业所需要的时间（或者费用）。源点（简称源）$𝑠$表示工程的开始，汇点（简称汇）$𝑡$表示工程的结束，其余结点$V_i$表示以该结点为终点的有向边代表的作业的结束和以该结点为始点的有向边代表的作业的开始。  
![](images/8a39c66fbf3ebe2db46646bd71380173dfca51b0b0532f41788a6ce4873cbcb6.jpg)  
第 8 章采用直接计算各个作业最早完成时间和最晚完成时间的方法计算关键路径，现在采用生成树方法计算源到其它结点的最长道路即关键道路，计算思路如下：  
（1）构造一棵以源 𝑠 为根的生成根树 $T$，且求出$s$到根树的各个结点 $v$ 的距离$L\left(\nu\right)$ 。  
（2）对任何一条权为$𝑊$$(u,v)$的弦$\langle u,v\rangle$，若$L(v)<\ L(u)+\ W(u,v)$，则从$T$中去掉以$v$为终点的有向边，而以有向边$\langle u,v\rangle$代之，同时使以$v$为根的子树中的各结点距离都增加$W(u,v)$，如此反复进行，直到考察完所有的弦。  
【例题9.21】求如图9-60 所示的作业网络的关键路径。  
【解】先构造由源𝑠到各个结点的最长道路的生成根树，即优化生成树，如图9-61 (a)- (d) 所示。再构造各个结点到汇 𝑡 的生成树，如图 $9–61\ (\mathsf{e})\tilde{\mathbf{\tau}}(\mathsf{g})$ 所示，然后在原图各个结点 $v$ 处 标以一个有序对$(a,b)$，其中$a$是图9-61 (d)中各$\mathbf{\nabla}^{\mathcal{V}}$的值，$b$是最长道路的权减去图9-61 (g)中各𝑣的值后的结果，如表9-2 所示。其中$a$与𝑏相等的结点所对应作业即为关键作业，由此可以得到如图9-61 (h)所示的关键路径。  
![](images/afad317ae3fcf5f241994658e1d9b51d47e2a890fb3c403b89c9e67033bfa386.jpg)  
![表 9-2  各个结点对应的有序对 ](images/2a1c04e98ea2f09c56274c954a2e76e48122dca03ff9c00a36aff31b122580fe.jpg)  
从图9-61 可知，$P=s V_{3}V_{1}V_{2}V_{4}t$是关键道路，$P$上的作业是关键作业。不在$P$上的作业都有缓冲期，例如$\langle s,V_{1}\rangle$只需3 个单位时间，在整个工程中它的动工时间为0，最晚完成时间为8，有5 个单位的多余机动时间。又比如作业$\langle V_{5},V_{6}\rangle$其最早动工时间为7，最晚完成时间为17，作业所需的时间为4，因此右6 个单位的机动时间，即使从时间13 开始也能按期完成。通过关键道路算法，重视关键作业的完成并合理利用非关键作业的缓冲期，就能做到整个项目的全盘把握，合理分配使用人力物力资源。"
内否公式,概念,"['第三章  命题演算与推理', '§ 3.2 命题公式与等值演算', '3.2.3 公式的内否与对偶']","{'实体类型': '概念', '定义': '将命题公式中所有变量取反得到的新公式'}",,3,"前面学习了 “否定”、 “合取”、 “析取”、 “蕴涵”和“等价”这五个常用命题联结词，其中最常用的是“否定”、 “合取”、 “析取”这三个联结词。事实上，后面将会证明仅使用这三个最常用联结词就可以任意的命题公式。本小节主要考察仅由这三个联结词构成的命题公式，首先给出如下限制性命题公式的定义：  
【定义3.14】如果一个命题公式$G$中仅出现命题变量、命题常量，以及命题联结词“$\neg$”、“ $\wedge$“、”$\lor$“，则称$G$为限制性命题公式。  
例如公式$\neg Q\lor R\,\lor\,\neg(P\lor Q)\lor(Q\lor P)\,\lor\,G\lor(H\land S)$都是限制性命题公式。  
限制性命题公式中只有“$\neg$”、“ $\wedge$“、”$\lor$“这三种运算，其中”$\neg$”为一元运算，“ $\wedge$“和“$\lor$”均为二元运算。对于任意一个限制性命题公式，可以使用规律性修改其运算联结词的方式构造出与之相对应的新的命题公式。例如，对于“$\neg$”运算，可将命题公式中所有变量取反，即由$P$ 换成$\neg\mathrm{P}$，便可得到一个新的公式。由此得到如下内否公式的定义：  
【定义3.15】设$G\Leftrightarrow G(P_{1},P_{2},\cdots P_{n})$是任一限制性命题公式，$P_{1},P_{2},\cdots P_{n}$是其所有命题变量，则称$G(\neg P_{1},\neg P_{2},\cdots\neg P_{n})$是$G(P_{1},P_{2},\cdots P_{n})$的内否公式，记为$G^{\neg}$。  
例如：若 $G=\ \lnot P\lor Q$，则$G^{\neg}=P\lor\neg Q$。  
不难看出，$\wedge$和$\lor$运算具有一定的对等性。也就是说 $\wedge$运算具有的性质，$\lor$运算也都有，反之亦然。因此，对于任意一个限制性命题公式，可将其中 $\wedge$换成$\lor$、$\lor$换成$\wedge$、$T$换成$F$、$F$换成$T$，则可得到一个与之相关的新公式。由此得到如下命题公式对偶式的概念：  
【定义3.16】对于任意一个限制性命题公式$G$，将其中 $\wedge$换成$\lor$、$\vee$换成 $\wedge$、$T$换成$F$、$F$换成$T$，得到的新公式称为$G$的对偶式，记为$G^{*}$。  
例如：
$$
(1)G\Leftrightarrow(P\land F);\quad G^{*}=P\lor T_{\circ}\;\;(\,2\,)\;\;G\Leftrightarrow(P\lor Q)\land R;\;\;G^{*}\Leftrightarrow(P\land Q)\lor R\,_{\circ}
$$  
下面两个定理分别给出了内否式和对偶式的基本性质于基本关系：  
【定理3.5】假设$G$和$H$都是限制性命题公式，则成立下列等值式：  
$\begin{aligned}&(1) (G^{*})^{*}\Leftrightarrow G, (G^{\neg})^{\neg}\Leftrightarrow G; (2) (G\vee H)^{*}\Leftrightarrow G^{*}\wedge H^{*}; (G\vee H)^{\neg}\Leftrightarrow G^{\neg}\vee H^{\neg};\\&(3) (G\wedge H)^{*}\Leftrightarrow G^{*}\vee H^{*}; (G\wedge H)^{\neg}\Leftrightarrow G^{\neg}\wedge H^{\neg}。\end{aligned}$  
【定理3.6】设$G$和$G^{*}$互为对偶式，$P_{1},P_{2},\cdots P_{n}$是出现在$G$和$G^{*}$中的全部命题变项，将$G$和$G^{*}$写成$\mathsf{n}$ 元函数形式，则有：
$$
(1)\neg G(P_{1},P_{2},\cdots,P_{n})\Leftrightarrow G^{*}(\neg P_{1},\neg P_{2},\cdots,\neg P_{n})\Leftrightarrow(G^{\neg})^{*}(P_{1},\cdots,P_{n})\tag{3-1}
$$  
$$
G^{\neg}(P_{1},P_{2},\cdots,P_{n})\Leftrightarrow G(\neg P_{1},\neg P_{2},\cdots,\neg P_{n})\Leftrightarrow\neg G^{*}(P_{1},P_{2},\cdots,P_{n})\tag{3-2}
$$  
上述定理的第（1）条表明命题公式$G$的否定与其命题变元否定的对偶式，即与该公式内否式的对偶式等值；第（2）条表明命题公式$G$的内否式与该公式对偶式的否定等值。  
【定理3.7】（对偶原理）假设$P_{1},P_{2},\cdots,P_{n}$是出现在命题公式$P$和$Q$中的所有原子变元，如果$P\Leftrightarrow Q$，那么$P^{*}\Leftrightarrow Q^{*}$。  
对偶原理表明命题公式之间所有等值关系都是成对的。也就是说，对于任意一个等值式，都可由对偶原理构造一个与之对偶的等值式。例如，对于等值式$P\to Q\Leftrightarrow\neg P\lor Q$，则可构造出其对偶等值式$\neg P\land Q\Leftrightarrow\neg(\neg P\rightarrow\neg Q)$。因为$\neg P\land Q\Leftrightarrow\neg(P\lor\neg Q)\Leftrightarrow\neg(\neg P\to\neg Q)$。"
冲突,性质,"['第七章 函数与特殊函数', '§ 7.4 有限集的置换函数', '7.5.1 哈希查找问题']","{'实体类型': '性质', '定义': '不同的关键字映射到同一地址的现象', '特点': '哈希函数中不可避免的存在', '处理方法': '开放定址法、再哈希法、拉链法'}",,3,"在计算机系统中，数据的存放位置和时间都不能完全确定，此时需要一种有效的方法在有限的存储空间中合理存放数据并且能够实现快速定位查找。此时，如果建立一个关于存储位置和数据关键字的对应关系$f$，就能找给定值$k e y$的像$f(k e y)$。这里的对应关系$f$通常称为哈希函数，这种数据查找方法称为哈希查找。  
例如，如果要建立一张学生成绩表，最简单的方法是以学生的学号作为关键字，1 号学生的记录位置放在第一条，10 号学生的记录位置放在第10 条，以此类推。此时，如果要查看的学号为5 的学生的成绩，则只要取出第5 条记录就可以了.这样建立的表实际上就是一张简单的哈希表，其哈希函数为$f(k e y){=}\ k e y$。然而很多情况下的哈希函数并不如此简单。为了查看的方便，可能会以学生的名字作为关键字。此时，为了能够根据学生的名字直接定位出相应记录所在的位置，需要将这些名字转化为数字，构造出相应的哈希函数，下面给出两个不同的哈希函数：  
（1）考察学生名字的汉语拼音，将其中第一个字母在英语字母表中的序号作为哈希函数值。例如：“蔡军”的汉语拼音第一个字母为字母$C$，因此取03 作为其哈希值。  
（2）考察学生名字的汉语拼音，将其中第一个字母和最后一个字母在英语字母表中的序号之和作为哈希函数值。例如，“蔡军”的汉语拼音第一个字母和最后一个字母分别为$𝐶$和$N$，因此取17 作为其哈希值。  
分别应用这两个哈希函数，成绩表中部分学生名字不同的哈希函数值如表7-7 所示。  
表 7-7
![](images/a45025876fc98ab470bf113421a83e13ab1997baea6e789cdbd16990f25f7ba0.jpg)  
![](images/0f18f81e6e78fd7fb2b0f104794c8a798e21b0531706abe9d65a4f9970f2f012.jpg)  
在哈希表的构造过程中，可能会出现不同的关键字映射到同一地址的情况，即$k e y_{1}\neq$$k e y_{2}$，但$f(k e y_{1})=f(k e y_{2})$，也将这种现象称为冲突和碰撞。实际上，由于哈希函数是把任意长度的字符串映射为固定长度的字符串，冲突必然存在，只能尽可能减少。常见的构造哈希函数的方法有以下几种：  
（1）数字分析法。数字分析法适合于关键字由若干数码组成，同时各数码的分布规律事先知道的情况。具体方法是：分析关键字集合中每个关键字中的每一位数码的分布情况，找出数码分布均匀的若干位作为关键字的存储地址。例如，一个由80 个结点组成的结构，其关键字为6 位十进制数。选择哈希表长度为100，则可取关键字中的两位十进制数作为结点的存储地址。具体采用哪两位数码，需要用数字分析法对关键字中的数码分布情况进行分析。假设结点中有一部分关键字如下：  
$k e y_{1}=301514\;\;;\;\;\;k e y_{2}=303027;\;\;k e y_{3}=301103;\;\;\;k e y_{4}=308329;$ $k e y_{5}=300287;\;\;k e y_{6}=305939;\;\;k e y_{7}=300792;\;\;k e y_{8}=300463\circ878.$  
对上述关键字分析可以发现，关键字的第一位均是3，第二位均是0，分布集中，不适合作为存储地址。而第4 位和第5 位分布均匀，所以该哈希函数可以构造为取第4,5 位作为结点的存储地址。上述8 个节点的散列地址为：  
$f(k e y_{1})=51~~~~f(k e y_{2})=02~~~~f(k e y_{3})=10~~~~f(k e y_{4})=32$ $f(k e y_{5})=28\;\;\;\;\;f(k e y_{6})=93\;\;\;\;\;f(k e y_{7})=79\;\;\;\;\;f(k e y_{8})=46$  
（2）平方取中法。平方取中法是一种比较常用的构造哈希函数的方法，具体是：将关键字求平方后，取其中间的几位数字作为散列地址。由于关键字平方后的中间几位数字和组成关键字的每一位数字都有关，因此产生冲突的可能性较小，最后究竟取几位数字作为散列地址需要由散列表的长度决定。例如，若结构的存储地址范围是1\~999，则取平方值的中间三位，如表7-8 所示。  
表7-8  平方取中法
![](images/3bce2eeb41624a2b374dfdbdb4f5d0a22039c970673844c48a904ace588c42b7.jpg)  
（3）除留余数法。除留余数法取关键字被某个不大于哈希表表长$m$的数$ p$除后所得余数为哈希地址，即$f(k e y)=k e y({\bmod{\ p}})$，其中$p\leq m$。这是一种最简单也是最常用的构造哈希函数的方法。它不仅可以对关键字直接取模（mod），也可在平方取中等运算之后取模。值得注意的是，在使用除留余数法时，对$ p$的选择很重要。若$p$选的不好，容易产生同义词。由经验得知：一般情况下可以选$p$为质数或不包含小于20 的质因素的合数。  
哈希函数中会不可避免的存在冲突。因此，在建造哈希函数时不仅要设定一个“好”的哈希函数，而且要设定一种处理冲突的方法。假设哈希表地址集为$\!\sim\!(n-1)$，冲突是指由关键字得到的哈希地址为𝑗$(0\leq j\leq n-1)$的位置上已有记录，则“处理冲突”就是为该关键字的记录找到另一个“空”的哈希地址。  
在处理冲突的过程中可能得到一个地址序列$h_{i}$，其中，$h_{i}\in[0,\mathfrak{n}-1],\mathrm{i}=1,2,\cdots,\mathtt{k}$。即  
在处理哈希地址的冲突时，若得到的另一个哈希地址${\bf h}_{1}$ 仍然发生冲突，则再求下一个地址$h_{2}$，若$ h_{2}$仍然冲突，再求得$h_{3}$，依此类推，直至$h_{k}$不发生冲突为止，则$h_{k}$为记录在表中的地址。处理冲突的具体方法通常有开放定址法、再哈希法和拉链法，这里不再赘述。"
决策树,应用实例,"['第九章  树的基本理论与算法', '9.4.1 找假币问题', '§ 9.4 树模型的应用']","{'实体类型': ['应用实例', '算法'], '相关模型': '树模型的应用', '定义': '从树根开始，每次回答一个问题，走相应的边，最后达到一个叶结点，即做出了选择', '应用': '解决决策问题，如找假币问题、排序类问题', '特点': '把做出判决的逻辑关系用树结构的形式表现出来，结果集中在叶子上，条理清晰', 'name': '决策树'}",,1,"树是大家非常熟悉的一类植物。通过对树的观察，不难发现自然界中的树总是有根、枝和叶，且具有这样一些特点：从根上可以长出枝来，从树杈上可以长出枝或叶，叶梢不长在一起，根、枝、叶之间总是畅通的，但它们之间不能构成圈。从结构上看，树是所有连通无向图中边数最少的图模型，同时也是所有无环无向图中边数最多的图模型。我们不得不惊叹大自然的神奇，竟然创造出如此高效而又和谐的离散结构。对自然界中树的这种特殊离散结构进行抽象，就可得到一种特殊的图模型，即树模型。在所有的图模型中，树模型是一种最简洁的连通无环结构，其中各结点之间有着最直接、最必要的联结关系。这种最简洁的连通结构决定了树在图模型知识体系中占有特别重要的地位。目前，树作为一种特殊图模型已被广泛应用于计算机各个领域，例如操作系统采用树结构来组织文件数据，编译程序采用树表示源程序的语法结构，在数据库系统中树被用来组织信息等等。  
本章主要介绍树模型基本理论及其算法设计的基本知识，首先介绍树模型的基本概念与性质、生成树与最小生成树等关于树模型的基本理论，然后具体讨论根树的概念与算法，包括树的递归遍历算法、森林与树的转换算法、最优树的构造与编码算法等，并在此基础上进一步学习若干典型特殊树模型及其基本算法，包括平衡树、红黑树、$B$树等，最后给出树模型的若干应用实例，包括决策树、博弈树等。"
函数,概念,"['§ 7.1 函数的基本概念', '7.1.2 函数的基本类型', '7.1.1 函数的集合定义', '第七章 函数与特殊函数']","{'实体类型': '概念', '定义': ['一个集合到另外一个集合的映射，对于某个集合中的任一元素，在另外一个集合中存在唯一元素与之对应', '设A和B是任意两个非空集合，f是从A到B的关系。若对forall x in A都存在唯一的y in B，满足langle x,y rangle in f，则称关系f为从A到B的函数关系，简称为函数或映射', '从集合A到集合B的函数描述的是A中元素与B中元素之间的一种特殊对应关系，这种特殊对应关系可以是一对一的也可以是多对一的，但不能是一对多或多对多的关系'], '应用': '在自然科学、工程技术、某些社会科学中被广泛应用，解决数学问题和专业问题；实际问题求解的基本方法论，如深度学习中构造分类器', '特点': ['满足单值性要求的特殊二元关系', '函数f是从集合A到B的一种特殊二元关系，这种二元关系所包含序偶的第一元素为自变量，第二元素为因变量或函数值', '函数值域可以是B的某个真子集，也可以是B自身'], '历史': '由德国数学家莱布尼茨首次提出，通过集合论和关系理论得到完美定义', '来源': '追溯至伽利略，莱布尼茨首次使用函数一词', '符号': 'f(x) 由欧拉发明', '重要性': '数学中的重要内容，沟通学科间的桥梁，学习相关课程的基础', '性质': ['langle x,y rangle in f Leftrightarrow y=f(x)', 'langle x,y rangle in f wedge langle x,z rangle in f Rightarrow y=z', '|f|=|A|', 'f(x)表示一个变值，f代表一个集合，故f neq f(x)']}",,1,函数是一个在自然科学、工程技术，甚至在某些社会科学中被广泛应用的数学概念，无论在初等数学还是高等数学中，无论在基础课还是专业课中，大家都会经常与函数打交道，以函数为基本工具解决各种各样的数学问题和专业问题。然而，从严格意义角度给函数下个定义并不是一件容易的事情。有人会说，函数不就是一个集合到另外一个集合的映射吗？或者说，函数就是对于某个集合中的任一元素，在另外一个集合中存在唯一元素与之对应。这不就是函数的定义？如果函数是这样定义的话，那么映射或对应又怎么定义呢？这正是函数定义的困难所在。事实上，自函数概念首次被德国数学家被莱布尼茨提出以来，其定义一直没有得到很好地解决，因为没有人能够准确地回答什么叫映射或者对应。直到在集合论和关系理论出现后，人们才以关系理论为工具完美地解决了函数的定义。具体地说，函数就是一种满足单值性要求的特殊二元关系。通过关系模型定义函数，就用关系模型的特性来诠释映射或对应概念的含义。作为关系模型的一个具体应用，本章将从特殊关系的角度来介绍函数的基本知识及其应用，包括函数的基本概念、函数的基本运算，以及若干重要的特殊函数，例如特征函数、散列函数和置换函数等。
函数增长的阶,概念,"['第二章  整数与算法设计基础', '§ 2.3 算法设计的基本知识', '2.3.2 算法效率的度量']","{'实体类型': '概念', '定义': '描述或度量函数值随自变量增长而增长的速度的不同等级', '应用': '在输入规模足够大时，只需考虑高阶项'}",,3,"从实际应用考虑，如果一个算法的运行时间过久，比如需要长达数年的时间，那么该算法就不适合用来解决问题。同样，一个算法如果需要占用很大的内存开销，导致系统无法为其它程序提供必须的内存资源，那么这也是不能够接受的。因此，对于设计出来的算法，需要对其利用时间和内存空间的效率进行分析，这就是算法的效率分析。无论是时间效率还是空间效率上看，算法的效率都是问题规模的某个函数，并且函数值随着问题规模的增长而增长。如果函数值随问题规模的增长而增长得很快，则说明算法效率很低，反之，如果函数值随问题规模的增长而增长得很慢，则说明算法效率很高。  
因此，为了更好地分析算法的效率，需要一些合适的方法来描述或度量函数值随自变量增长而增长的速度，如果不能精确地算出函数增长的速度，那么至少也要针对函数增长的不同速度划分出若干性质不同的等级，这就是函数增长的阶。当输入规模足够大时，精确表示的运行时间函数中的常系数和低阶项会被输入规模所掩盖。此时，只需要考虑高阶项即可。比如若复杂度为多项式$x^{2+}\!x$，$x$的复杂度会被$x^{2}$的复杂所吸收，因此只需考虑最高阶。  
事实上，在分析和度量算法效率的时候，重点考虑的是当问题规模充分大时的函数值增长的情况。因此，分析和度量算法效率时，一般都使用渐近效率的概念，即从极限的角度考虑运行时间如何随输入规模的增长而增长。为了更加准确地阐释和度量算法复杂度随问题规模增长而增长的速度，计算机科学家在算法领域引入了一些函数增长符号，其中时间复杂度常用大𝑂符号表述，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。使用这种方式时，时间复杂度可被称为是渐近的，它主要考察当输入值充分大时的情况。  
对于绝大多数算法来说，其复杂度的增长速度还可以使用基本或常用函数增长类型通过示例性的方法来描述或表示，如常数级、对数级、多项式级、指数级、阶乘级增长速度，等等。这些常用函数的增长速度非常直观，以它们增长速度为标准对算法的计算复杂度进行度量，会使得算法复杂度分析变得易于理解。因此，掌握这些常用函数的基本增长类型对算法设计具有非常重要的指导意义，下面对其做简要介绍：  
（1）$\mathrm{O}(1)$：复杂度为常数级，例如从一个数据集中取出第一个元素；  
（2）$\mathrm{O}(\lg n)$：该类型常见于将一个数据集分成两半，然后将其中每一半再分成两半，以此类推。例如对有序数组进行二分查找，其时间复杂度就是$\mathrm{O}(\lg n)$；  
（3）$\mathrm{O}(n)$：该类型常见于数据集中的遍历，例如在线性结构中顺序查找某个元素的算法，其时间复杂度就是$\mathrm{O}(n)$；  
（4）$\mathrm{O}(n\lg n)$：该类型与前面所述的$\mathbf O(1g\ n)$有点类似，常见于将一个数据集分成两半，然后将每一半再分成两半，并且对每一半数据进行遍历，以此类推，例如归并排序时间复杂度就是$\mathrm{O}(n\,1\mathrm{g}\,n)$；  
（5）${\mathrm{O}}(n^{2})$：常见于两重嵌套循环的算法之中，也就是说在遍历一个数据集中的每一个元素的时候同时遍历另一个数量级相同的数据集，基本排序算法（如冒泡排序、直接插入排序、直接选择排序等）的时间复杂度是${\mathrm{O}}(n^{2})$；  
（6）${\mathrm{O}}(n^{3})$：该类型常见于三重嵌套循环的算法之中，在线性代数中，两个$n$阶方阵相乘的时间复杂度就是${\mathrm{O}}(n^{3})$，著名求解最短路径Floyd 算法的时间复杂度也是${\mathrm{O}}(n^{3})$；  
（7）$\mathrm{O}(2^{n})$：为一个数据集生成所有的子集，这种数量级的算法可以说是很低效的，在规模较大的时候是不可行的；  
（8）$\mathrm{O}(n!)$：对具有$n$ 个元素的集合进行全排列时就是该类型的典型例子，这种数量级的算法基本上是不可行的。"
函数的基本运算,概念,"['第七章 函数与特殊函数', '§ 7.2 函数的基本运算']","{'实体类型': '概念', '定义': '对函数进行各种运算以实现问题求解', '种类': '加、减、乘、除、复合运算、逆运算、积分运算、微分运算', '重点考察': '复合运算、逆运算和递归运算', '特点': '函数作为一种表示特殊二元关系的集合，其交、并、补、差运算结果不一定还是函数关系'}",,2,函数的运算对于大家来说并不陌生，我们在初等数学和高等数学中都会经常使用函数运算实现问题求解。事实上，函数的运算有很多种，除了前述的加、减、乘、除等算术运算之外，还有复合运算、逆运算、积分运算、微分运算等等，这里不再一一枚举。本节主要从关系的角度介绍和考察与计算机领域密切相关的一些函数运算。如前所述，函数作为一种表示特殊二元关系的集合，其交、并、补、差运算结果不一定还是函数关系。因此，我们不再考虑函数关系的集合运算，而着重考察函数关系的复合运算、逆运算和递归运算。
函数的复合运算,概念,"['第七章 函数与特殊函数', '§ 7.2 函数的基本运算', '7.2.1 函数的复合运算']","{'实体类型': '概念', '定义': '函数关系的合成', '前提条件': '前一个函数的值域是后一个函数定义域的子集', '定义域': '前一个函数的定义域', '值域': '后一个函数的值域', '运算结果': '仍然是函数'}",,3,"前面已经学习了二元关系的复合运算，函数作为一种特殊的二元关系，也可以进行复合运算，函数的复合运算其实就是函数关系的合成，下面定理保证了两个函数关系的复合后得到的关系仍然是一个函数关系，并据此得到复合函数的定义：  
【定理7.4】设$f\colon A\to B,g\colon B\to C$是两个函数，则$f$与$g$的复合关系：  
$f\circ g=\{\langle x,z\rangle|x\in A\wedge z\in C\wedge(\exists y)(y\in B\wedge xfy\wedge ygz)\}\quad\text{(7-1)}$  
是一个从$𝐴$到$C$的函数，称之为函数$f$与$g$的复合函数，记为$f\circ g\colon A\to C$。  
根据上述定理，由于两个函数的复合运算结果仍然是一个函数，故可将函数复合运算直接推广到多个函数的情形，并且多个函数复合运算结果仍是函数。由于函数复合是关系复合的一种特殊情形，故多个函数的复合同样满足结合律。此外，从上述定理可以看出：  
（1）函数$ f$与$g$可以复合的前提条件是，前一个函数$f$的值域$ran$ $f$必须是后一个函数$g$定义域$dom$ $g$的子集合，即有：$ran $$f\subseteq\operatorname{dom}\ g=B$；  
（2）复合函数$f\circ g$的定义域$\operatorname{dom}(f\circ g)$是前一个函数$ f$的定义域$dom$ $f$，值域ran$(f\circ g)$是后一个函数$$g$$的值域，即有：$\operatorname{dom}(f\circ g)=\operatorname{dom}\ f=A,\ \operatorname{ran}(f\circ g)=r a n g;$  
（3）对$\forall x\in A$，有：$f\circ g(x)=g(f(x))。$  
下面定理给出了函数单射、满射和双射性质在复合运算下的保持性：  
【定理7.5】设$f\colon A\to B,g\colon B\to C$是两个函数。  
（1）如果函数$f$和$g$都是满射，则复合函数$f\circ g$也是从$A$到$C$满射；  
（2）如果函数$f$和$g$都是单射，则复合函数$f\circ g$也是从$𝐴$到$C$单射；  
（3）如果函数$f$和$g$都是双射，则复合函数$f\circ g$也是从𝐴到$C$双射。  
需要注意的是上述定理的逆不成立，但有以下结论：  
【定理7.6】设$f\colon A\to B,g\colon B\to C$是两个函数，则有：  
（1）如果复合函数$f\circ g$是从$𝐴$到$C$满射，则函数$g$是$B$到$C$的满射；  
（2）如果复合函数$f\circ g$是从$𝐴$到$C$单射，则函数$f$是$𝐴$是$B$的单射；  
（3）如果复合函数$f\circ g$是从$A$到$C$双射，则$f$是$A$是$B$的单射，$g$是$B$到$C$的满射。"
函数的逆运算,概念,"['第七章 函数与特殊函数', '§ 7.2 函数的基本运算', '7.2.2 函数的逆运算']","{'实体类型': '概念', '定义': '设f:A→B的函数关系，如果其逆关系f^{-1}是一个从B到A的函数关系，则函数f可逆，并称f^{-1}是函数f的逆函数或反函数', '条件': '函数f存在逆函数f^{-1}当且仅当f是双射'}",,3,"在一般关系$𝑅$的求逆运算中，任意关系都可进行求逆运算而得到其逆关系，但是对于任意一个函数$𝑓$来说，只能保证它的逆$f^{-1}$是一个二元关系，并不能保证$f^{-1}$一定是函数关系。因此，在求一个函数的逆运算时，必须对该函数做一些特殊的要求。  
【定义7.7】设$f\colon A\to B$的函数关系，如果其逆关系：  
$$
f^{-1}=\{\langle y,x\rangle|x\in A\land y\in B\land\langle x,y\rangle\in f\}\quad\text{(7-2)}
$$  
是一个从$B$到$𝐴$的函数关系，则函数$f$可逆，并称$f^{-1}$是函数$f$的逆函数或反函数。  
由上述定义可可知，如果函数$f$可逆，则$f^{-1}$作为一个从$B$到$𝐴$的函数，集合$ B$中每个元素都有$ f^{-1}$下的像，而根据逆关系的定义，$B$中每个元素在函数$f^{-1}$下的像其实就是该元素在函数$f$下的原像，故$f$是从$𝐴$到$B$的满射。另一方面，$f^{-1}$作为一个函数，集合$ B$中每个元素都有$A$中唯一的元素与之对应。从函数$ f$的角度看，就是$𝐴$中不同的元素对应不同的像，因此，函数$f$是单射。综上所述，函数$f$存在逆函数$f^{-1}$当且仅当$f$是双射。  
【定理7.7】设$f\colon A\to B$的双射函数，则$f$的逆函数$f^{-1}$也是从$B$到$𝐴$的双射函数。  
下面定理给出了任一双射函数与其函数反函数及恒等函数之间的关系：  
【定理7.8】设$𝑓$:$A\rightarrow B$的双射函数，则有：  
$$
(1)f^{-1}\circ f=I_{B};\mathrm{~(~2~)~}\,f\circ f^{-1}=I_{A};\mathrm{~(~3~)~}\,I_{A}\circ f=f\circ I_{B}=f。
$$  
其中$I_{A}$和$I_{B}$分别表示集合$𝐴$和集合 $B$上的恒等函数。"
函数相等,定义,"['第七章 函数与特殊函数', '§ 7.1 函数的基本概念', '7.1.1 函数的集合定义']","{'实体类型': '定义', '定义': '设A和B是任意两个非空集合，f,g是两个从A到B的函数关系，如果f和g相互包含，即有f subseteq g wedge g subseteq f，则称函数f和函数g相等，记为f=g', '条件': '两个函数相等不仅要求它们的对应关系相等，而且要求它们的定义域也要相同'}",,3,"在初等数学或高等数学中，函数的概念从变量角度提出，而且主要局限于在实数集。计算机相关领域处理的对象除了实数之外，还有很多其它对象，例如矩阵、向量、命题等等，而且主要面对的是各种可数的离散对象。为此，需要扩展初等数学或高等数学中函数概念的含义，从集合与关系的角度给函数下一个更加本质性的定义，具体如下：  
【定义7.1】设$𝐴$和$B$是任意两个非空集合，$f$是从$𝐴$到$B$的关系。若对$\forall x\in A$都存在唯一的$y\in B$，满足$\langle x,y\rangle\in f$，则称关系$f$为从$𝐴$到$B$的函数关系，简称为函数或映射,记为 $f\!:\!A\longrightarrow$  
$B$或$y=f(x)$，并称$x$为$f$的自变量或源点，$𝑦$为$ x$在$f$下的函数值或像点。集合$𝐴$称为$𝑓$的定义域，记为$dom$ $f=A$，所有像点组成的集合称为$f$的值域或$f$的像，记为$ran $$f$或$f(A)$。  
从上述定义可以看出，函数$f$是从集合$𝐴$到$B$的一种特殊二元关系，这种二元关系所包含序偶的第一元素为自变量，第二元素为因变量或函数值。函数的定义域就是关系的前域$𝐴$，要求关系中所有序偶的第一元素互不相同并且要取遍集合$𝐴$中的每个元素。作为刻画作为函数的本质单值特征，要求对于关系中的任意两个序偶，若它们的第一元素相同，则第二元素必须相同。具体地说，如果一个从集合$𝐴$到$B$二元关系$f$，那么它必须满足如下几个性质：  
(1)$\langle x,y\rangle\in f\Leftrightarrow y=f(x);\qquad\mathrm{(2)}\ \langle x,y\rangle\in f\wedge\langle x,z\rangle\in f\Rightarrow y=z;$  
（3）$|f|=|A|$； （4）$f(x)$表示一个变值，$f$代表一个集合，故$f\neq f(x)$  
如果关系$f$具备下面两种情况之一，那么$f$就不是函数关系：  
（1）存在元素$a\in A$,在$B$中没有像；（2）存在元素$a\in A$, 在$ B$中至少有两个像。  
例如，关系$\begin{array}{r}{F_{1}=\{\langle x_{1},y_{1}\rangle,\langle x_{2},y_{1}\rangle,\langle x_{3},y_{2}\rangle,\langle x_{4},y_{3}\rangle\}}\end{array}$是函数，而如下关系：
$$
F_{2}=\{\langle x_{1},y_{1}\rangle,\langle x_{2},y_{1}\rangle,\langle x_{3},y_{2}\rangle,\langle x_{1},y_{2}\rangle\}
$$  
则不是函数，因为同时有$\langle x_{1},y_{1}\rangle\in F_{2}$和$\langle x_{1},y_{2}\rangle\in F_{2}$  
由上述例题可知，函数作为一种特殊关系或特殊集合，其集合运算的结果可能不再是函数。因此，要慎用函数的集合运算。另一方面，由于函数是一种特殊子集，因此可用集合相等的概念来定义两个函数相等，具体定义如下：  
【定义7.2】设$𝐴$和$B$是任意两个非空集合，$f,g$是两个从$A$到$B$的函数关系，如果$f$和$g$相互包含，即有$f\subseteq g\wedge g\subseteq f$，则称函数$f$和函数$g$相等，记为$f=g$。换句话说，如果$dom $$f=$$dom$ $g$且对$\forall x\in\mathsf{d o m}$ $f=\mathrm{dom}$ $g$有$f(x)=g(x)$，称$f$与$g$相等。  
从上述定义可以看出，两个函数相等不仅要求它们的对应关系相等，而且要求它们的定义域也要相同，两者缺一不可。  
现考察有限集合上函数的计数问题，即算出有限集合上有多少种不同函数。设集合$ A=$$\{a_{1},a_{2},\cdots,a_{n}\}$，$B=\{b_{1},b_{2},\cdots,b_{m}\}$，则要确定一个从$𝐴$到$B$的函数$ f$，就必须对$𝐴$中每个元素$a_{i}$，在$B$中找到一个唯一确定的元素$b_{m_{i}}$与之对应。显然，对于$𝐴$中每个元素$a_{i}$都有$|B|=m$种选择$b_{m_{i}}$的方式。而集合𝐴中共有$|A|=n$个元素，故根据乘法原理，得到所有方式的组合数为$m^{n}$或$|B|^{|A|}$种。即从$A$到$B$的不同函数一共有$|B|^{|A|}$种。由此得到如下定理：  
【定理7.1】设$𝐴$和$B$是任意两个非空有限集合，则从$A$到$B$一共有$|B|^{|A|}$种不同的函数。  
根据上述定理，可得到如下函数集定义及其表示方法：  
【定义7.3】设$𝐴$和$B$是任意两个非空集合，将从$A$到$B$的一切函数构成的集合称为从$𝐴$到$B$的函数集或函数空间，记为$B^{A}$。即有： $B^{A}=\{f|f\colon\ A\to B\}.$。  
根据上述定义，当$𝐴$和$B$是非空有限集合时，显然有：$|B^{A}|=|B|^{|A|}$  
通过以上分析不难发现，当𝐴和$B$为有限集时，函数和一般关系具有以下区别：  
（1）个数差异：从$𝐴$到$B$的不同关系有$2^{|A|\times|B|}$个，从$A$到$B$的不同函数仅有$|B|^{|A|}$个。  
（2）基数不同：每个函数基数均为$|A|$即$|f|=|A|$，关系的基数却为从0 到$\vert A\vert\times\vert B\vert$  
（3）第一元素的差别：关系的第一个元素可以相同，函数的第一个元素不能相同。  
下面进一步考察函数对定义域子集的映射性质，首先给出如下子集像的相关概念：  
【定义7.4】设$𝐴$和$B$是任意给定的两个非空集合，$A_{1}$和$B_{1}$分别是$𝐴$和$B$的任意两个非空子集合，即有$A_{1}\subseteq A,B_{1}\subseteq B$。$f$是一个从$𝐴$和$B$函数，即$f\colon A\to B$。  
（1）令$f(A_{1})=\{f(x)|x\in A_{1}\}$，称$f(A_{1})$为$|A_{1}$在$f$下的像。当$A_{1}=A$时，$f(A)$为$f$的像。  
（2）令$ f^{-1}(B_{1})=\{x|x\in A\Lambda f(x)\in B_{1}\}$，称$f^{-1}(B_{1})$为$B_{1}$在$f$下的完全原像。  
在上述定义中显然有：$f(A_{1})\subseteq B$且$f^{-1}(B_{1})\subseteq A$。  
下面定理给出了子集像的集合运算性质：  
【定理7.2】设$𝐴$和$B$是任意给定的两个非空集合，$X$和$𝑌$是集合$ A$的任意两个非空子集，即有$X\subseteq A,Y\subseteq A$。$f$是一个从$A$和$B$函数，即$f\colon A\to B$。则有：  
$$
(1)f(X\cup Y)=f(X)\cup f(Y);\ \ (2)\ \,f(X\cap Y)\subseteq f(X)\cap f(Y)
$$  
上述定理的第（2）结论等号不成立。  
事实上，设$A=\{a,b,c\}$，$B=\{1,\!2,\!3\}$，$f\colon X\to Y$为：$f(a)=1$，$f(b)=f(c)=2.$令$X=\{a,b\}$，$Y=\{c\}$，则有：$A\cap B=\emptyset$，$f(A\cap B)=\emptyset$。但是：  
$$
f(A)\ \cap f(B)=\{1,2\}\cap\{2\}\neq\emptyset
$$  
故$f(A)\ \cap f(B)\ \neq f(A\cap B)$。这表明只能成立：$f(A\cap B)\subseteq f(A)\cap f(B)\,。$  
至此，我们从二元关系的角度给了函数相关概念的本质定义，并以关系模型为基本工具分析讨论了函数的若干基本性质，为函数理论奠定了一个比较坚实的数学基础。下面就从以上函数概念及基本性质为出发点进一步介绍和讨论函数的相关理论及应用。"
函数迭代,概念,"['第七章 函数与特殊函数', '§ 7.2 函数的基本运算', '7.2.3 函数的递归运算']","{'实体类型': '概念', '定义': '假设A是任一给定的非空集合，f(x)是A上的某个函数，n个相同函数f(x)的复合运算称为对f(x)的n次迭代运算，运算结果记为f^n(x)，称为f(x)的n次迭代函数，并约定f(x)的0次迭代函数为其自变量x', '应用': '在很多情况下可使用函数迭代得到新的函数，例如牛顿迭代法、雅可比迭代法、高斯迭代法等等'}",,3,"前面从二元关系的角度讨论了函数关系的复合运算和逆运算，我们还可以将关系的幂运算引入函数关系之中。如前所述，关系的幂运算是一种特殊的复合运算，就是关系通过不断地与其自身进行复合从而产生新的关系。由于关系的复合运算满足结合律，故给定次数下的复合运算结果是唯一确定的。同样，一个函数关系也可以通过不断与其自身进行复合运算产生新的函数关系，由此可得函数迭代与递归运算的概念。  
【定义7.8】假设$𝐴$是任一给定的非空集合，$f(x)$是$A$上的某个函数，$n$个相同函数$f(x)$的复合运算称为对$f(x)$的$n$次迭代运算，运算结果记为$f^{n}(x)$，称为$f(x)$的$n$次迭代函数，并约定$f(x)$的0 次迭代函数为其自变量$x$，即有：  
$$
f^{(n)}(x)=f(f^{(n-1)}(x))\wedge f^{(0)}(x)\quad\text{(7-3)}
$$  
其中$f^{(0)}(x)=x。$  
迭代是函数的一个非常重要的运算，在很多情况下可使用函数迭代得到新的函数。例如，假设$f(x)$是自然数集上的后继函数，即有$f(x)=x+1$，则有$f^{(n)}(x)=~x+n$。还可以使用迭代方法解方程或方程组，例如牛顿迭代法、雅可比迭代法、高斯迭代法等等，有兴趣的读者可以数值分析的课程的相关内容，这里不再赘述。下面将函数迭代的概念做进一步推广，给出并讨论函数递归运算的概念。  
首先看一个引例。西萨·班·达依尔发明了国际象棋，国王问他需要什么奖赏，他说：“陛下，请您在这张棋盘的第1 个小格里赏给我一粒麦子，在第2 个小格里给2 粒，第3 个小格给4 粒，以后每一小格都比前一小格加一倍，直到摆满这64 个棋盘格”  
那么需要多少粒麦子呢？可以按如下方法计算：  
$$
f(1)=1;f(2)=2;f(3)=4;\cdots\cdots;f(n)=2*f(n-1)
$$  
最后得到：$f(64)=2^{64-1}=18446744073709551615.$是一个非常大的数字。  
上面的算式$f(n)=2*f(n-1)$表达的就是一个递归运算。该算式采用以步长为1 的逐步推进的方式，通过以$f(n-1)$为变量的某个具体表达式计算$f(n)$。  
下面给出函数递归运算的具体定义：  
【定义7.9】对于某一函数$f(x)$，其定义域是集合$𝐴$，那么若对于$𝐴$集合中的某一个值$x_{n}$，其函数值$f(x_{n})$由以$f(x_{n-1}),f(x_{n-2}),\cdots,f(x_{n-k})$变量的某个表达式确定决定，即有：  
$$
f(x_{n})=S(f(x_{n-1}),f(x_{n-2}),\cdots,f(x_{n-k}))\quad\text{(7-4)}
$$  
则称$f(x)$为一个$k$阶递归函数。  
递归函数的思想就是将复杂问题分解成若干简单且相同的子问题，将复杂的原问题转换为简单子问题的某种重复，通过简单子问题的机械重复得到复杂问题的解。  
例如，下列两个函数均为递归函数。  
（1）阶乘函数：  
$$
Fact(n)=\left\{\begin{matrix}1&&n=0\\&n*Fact(n-1)&&n>0\end{matrix}\right.
$$  
（2）2 阶的Fibonacci 数列：  
$$
Fib(n)=\begin{cases}0&\quad&n=0\\1&\quad&n=1\\&\quad&Fib(n-1)+Fib(n-2)&\quad\text{否则}\end{cases}
$$  
递归函数的上述思想非常符合计算机程序设计的思维方式。因此，递归方法是算法与程序设计的一个有效方法,使用递归方法能使程序变得简洁和清晰。  
值得注意的是，并不是任何函数都适合采用递归的形式进行计算。使用递归方式计算函  
数必须具备如下两个基本条件：  
（1）函数存在递归结束条件及结束时的值，称之为递归出口；  
（2）函数能够用递归形式表示，且递归向终止条件发展，称递归表达式为递归体。"
函数集,定义,"['第七章 函数与特殊函数', '§ 7.1 函数的基本概念', '7.1.1 函数的集合定义']","{'实体类型': '定义', '定义': '设A和B是任意两个非空集合，将从A到B的一切函数构成的集合称为从A到B的函数集或函数空间，记为B^A', '性质': '当A和B是非空有限集合时，显然有：|B^A|=|B|^|A|'}",,3,"在初等数学或高等数学中，函数的概念从变量角度提出，而且主要局限于在实数集。计算机相关领域处理的对象除了实数之外，还有很多其它对象，例如矩阵、向量、命题等等，而且主要面对的是各种可数的离散对象。为此，需要扩展初等数学或高等数学中函数概念的含义，从集合与关系的角度给函数下一个更加本质性的定义，具体如下：  
【定义7.1】设$𝐴$和$B$是任意两个非空集合，$f$是从$𝐴$到$B$的关系。若对$\forall x\in A$都存在唯一的$y\in B$，满足$\langle x,y\rangle\in f$，则称关系$f$为从$𝐴$到$B$的函数关系，简称为函数或映射,记为 $f\!:\!A\longrightarrow$  
$B$或$y=f(x)$，并称$x$为$f$的自变量或源点，$𝑦$为$ x$在$f$下的函数值或像点。集合$𝐴$称为$𝑓$的定义域，记为$dom$ $f=A$，所有像点组成的集合称为$f$的值域或$f$的像，记为$ran $$f$或$f(A)$。  
从上述定义可以看出，函数$f$是从集合$𝐴$到$B$的一种特殊二元关系，这种二元关系所包含序偶的第一元素为自变量，第二元素为因变量或函数值。函数的定义域就是关系的前域$𝐴$，要求关系中所有序偶的第一元素互不相同并且要取遍集合$𝐴$中的每个元素。作为刻画作为函数的本质单值特征，要求对于关系中的任意两个序偶，若它们的第一元素相同，则第二元素必须相同。具体地说，如果一个从集合$𝐴$到$B$二元关系$f$，那么它必须满足如下几个性质：  
(1)$\langle x,y\rangle\in f\Leftrightarrow y=f(x);\qquad\mathrm{(2)}\ \langle x,y\rangle\in f\wedge\langle x,z\rangle\in f\Rightarrow y=z;$  
（3）$|f|=|A|$； （4）$f(x)$表示一个变值，$f$代表一个集合，故$f\neq f(x)$  
如果关系$f$具备下面两种情况之一，那么$f$就不是函数关系：  
（1）存在元素$a\in A$,在$B$中没有像；（2）存在元素$a\in A$, 在$ B$中至少有两个像。  
例如，关系$\begin{array}{r}{F_{1}=\{\langle x_{1},y_{1}\rangle,\langle x_{2},y_{1}\rangle,\langle x_{3},y_{2}\rangle,\langle x_{4},y_{3}\rangle\}}\end{array}$是函数，而如下关系：
$$
F_{2}=\{\langle x_{1},y_{1}\rangle,\langle x_{2},y_{1}\rangle,\langle x_{3},y_{2}\rangle,\langle x_{1},y_{2}\rangle\}
$$  
则不是函数，因为同时有$\langle x_{1},y_{1}\rangle\in F_{2}$和$\langle x_{1},y_{2}\rangle\in F_{2}$  
由上述例题可知，函数作为一种特殊关系或特殊集合，其集合运算的结果可能不再是函数。因此，要慎用函数的集合运算。另一方面，由于函数是一种特殊子集，因此可用集合相等的概念来定义两个函数相等，具体定义如下：  
【定义7.2】设$𝐴$和$B$是任意两个非空集合，$f,g$是两个从$A$到$B$的函数关系，如果$f$和$g$相互包含，即有$f\subseteq g\wedge g\subseteq f$，则称函数$f$和函数$g$相等，记为$f=g$。换句话说，如果$dom $$f=$$dom$ $g$且对$\forall x\in\mathsf{d o m}$ $f=\mathrm{dom}$ $g$有$f(x)=g(x)$，称$f$与$g$相等。  
从上述定义可以看出，两个函数相等不仅要求它们的对应关系相等，而且要求它们的定义域也要相同，两者缺一不可。  
现考察有限集合上函数的计数问题，即算出有限集合上有多少种不同函数。设集合$ A=$$\{a_{1},a_{2},\cdots,a_{n}\}$，$B=\{b_{1},b_{2},\cdots,b_{m}\}$，则要确定一个从$𝐴$到$B$的函数$ f$，就必须对$𝐴$中每个元素$a_{i}$，在$B$中找到一个唯一确定的元素$b_{m_{i}}$与之对应。显然，对于$𝐴$中每个元素$a_{i}$都有$|B|=m$种选择$b_{m_{i}}$的方式。而集合𝐴中共有$|A|=n$个元素，故根据乘法原理，得到所有方式的组合数为$m^{n}$或$|B|^{|A|}$种。即从$A$到$B$的不同函数一共有$|B|^{|A|}$种。由此得到如下定理：  
【定理7.1】设$𝐴$和$B$是任意两个非空有限集合，则从$A$到$B$一共有$|B|^{|A|}$种不同的函数。  
根据上述定理，可得到如下函数集定义及其表示方法：  
【定义7.3】设$𝐴$和$B$是任意两个非空集合，将从$A$到$B$的一切函数构成的集合称为从$𝐴$到$B$的函数集或函数空间，记为$B^{A}$。即有： $B^{A}=\{f|f\colon\ A\to B\}.$。  
根据上述定义，当$𝐴$和$B$是非空有限集合时，显然有：$|B^{A}|=|B|^{|A|}$  
通过以上分析不难发现，当𝐴和$B$为有限集时，函数和一般关系具有以下区别：  
（1）个数差异：从$𝐴$到$B$的不同关系有$2^{|A|\times|B|}$个，从$A$到$B$的不同函数仅有$|B|^{|A|}$个。  
（2）基数不同：每个函数基数均为$|A|$即$|f|=|A|$，关系的基数却为从0 到$\vert A\vert\times\vert B\vert$  
（3）第一元素的差别：关系的第一个元素可以相同，函数的第一个元素不能相同。  
下面进一步考察函数对定义域子集的映射性质，首先给出如下子集像的相关概念：  
【定义7.4】设$𝐴$和$B$是任意给定的两个非空集合，$A_{1}$和$B_{1}$分别是$𝐴$和$B$的任意两个非空子集合，即有$A_{1}\subseteq A,B_{1}\subseteq B$。$f$是一个从$𝐴$和$B$函数，即$f\colon A\to B$。  
（1）令$f(A_{1})=\{f(x)|x\in A_{1}\}$，称$f(A_{1})$为$|A_{1}$在$f$下的像。当$A_{1}=A$时，$f(A)$为$f$的像。  
（2）令$ f^{-1}(B_{1})=\{x|x\in A\Lambda f(x)\in B_{1}\}$，称$f^{-1}(B_{1})$为$B_{1}$在$f$下的完全原像。  
在上述定义中显然有：$f(A_{1})\subseteq B$且$f^{-1}(B_{1})\subseteq A$。  
下面定理给出了子集像的集合运算性质：  
【定理7.2】设$𝐴$和$B$是任意给定的两个非空集合，$X$和$𝑌$是集合$ A$的任意两个非空子集，即有$X\subseteq A,Y\subseteq A$。$f$是一个从$A$和$B$函数，即$f\colon A\to B$。则有：  
$$
(1)f(X\cup Y)=f(X)\cup f(Y);\ \ (2)\ \,f(X\cap Y)\subseteq f(X)\cap f(Y)
$$  
上述定理的第（2）结论等号不成立。  
事实上，设$A=\{a,b,c\}$，$B=\{1,\!2,\!3\}$，$f\colon X\to Y$为：$f(a)=1$，$f(b)=f(c)=2.$令$X=\{a,b\}$，$Y=\{c\}$，则有：$A\cap B=\emptyset$，$f(A\cap B)=\emptyset$。但是：  
$$
f(A)\ \cap f(B)=\{1,2\}\cap\{2\}\neq\emptyset
$$  
故$f(A)\ \cap f(B)\ \neq f(A\cap B)$。这表明只能成立：$f(A\cap B)\subseteq f(A)\cap f(B)\,。$  
至此，我们从二元关系的角度给了函数相关概念的本质定义，并以关系模型为基本工具分析讨论了函数的若干基本性质，为函数理论奠定了一个比较坚实的数学基础。下面就从以上函数概念及基本性质为出发点进一步介绍和讨论函数的相关理论及应用。"
分治,算法,"['第二章  整数与算法设计基础', '§ 2.4 算法设计策略与应用', '2.4.2 递归与分治']","{'实体类型': '算法', '定义': '将一个难以解决的大问题，分割成一些与原问题相同的、规模较小的子问题，以便分而治之，然后递归地解决子问题，最后把子问题的解组合成原问题的解', '特点': '与递归经常同时应用在算法设计之中，形成高效算法'}",,3,递归是算法设计中一项非常重要的策略，其基本思想是把一个问题归结为一个或多个规模更小的子问题，然后用同样的方法解规模更小的子问题，要求子问题与原问题保持同一类型以保证可用同样方法求解，如此下去，直到子问题的规模小到可以直接求解为止。分治策略的思想则是将一个难以解决的大问题，分割成一些与原问题相同的、规模较小的子问题，以便分而治之，然后递归地解决子问题，最后把子问题的解组合成原问题的解。递归和分治就像一对孪生兄弟，经常同时应用在算法设计之中，并由此形成很多高效的算法。
分治策略,算法,"['第二章  整数与算法设计基础', '§ 2.4 算法设计策略与应用', '2.4.2 递归与分治', '二、分治策略']","{'实体类型': '算法', '定义': '把问题分解为若干规模较小的子问题，递归求解并合并解；对于一个规模为n的问题，若该问题可以容易地解决则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，求解这些子问题，然后将各子问题的解合并得到原问题的解', '特点': '递归方式求解子问题；由分治法产生的子问题往往是原问题的较小模式，为使用递归技术解决并实现分治策略提供了方便', '步骤': '（1）将原问题分解为若干相同的子问题；（2）若子问题的规模容易解决则直接求解，否则继续分解；（3）将子问题的解合并得到原问题的解', '计算复杂性分析': '通过构造递推表达式进行分析'}",,2,计算机问题求解算法虽然千差万别，但都遵循一些基本的设计策略。这些策略蕴含着很多非常深刻而又普适的求解智慧。例如，分治策略把一个问题分解为若干规模较小的子问题，然后以递归的方式求解它们并通过合并它们的解来实现对原问题的求解，而回溯策略则认为对未知世界的探索是一个试错的过程，并给出具体的试错方案，这恰恰是对人类生活经验的一种抽象和总结。不断学习、领会和掌握这些智慧，就可逐步形成良好的算法思维，从而能够更加透彻地从本质上理解算法设计的精髓，为设计出高水平算法打下坚实的基础。本章主要结合具体应用实例介绍和分析算法设计的若干基本策略，包括蛮力与贪心策略、递归与分治策略、回溯与动态规划策略。
分治递推关系,性质,"['第二章  整数与算法设计基础', '§ 2.4 算法设计策略与应用', '2.4.2 递归与分治', '二、分治策略']","{'实体类型': '性质', '定义': '若f(n)表示求解规模为n的问题所需的运算数，则f满足如下递推关系：f(n)=a f(n/b)+g(n)', '应用': '用于分析算法的复杂度'}",,4,"【定义2.21】对于一个规模为$n$ 的问题，若该问题可以容易地解决（比如说规模$n$ 较小）则直接解决，否则将其分解为$k$个规模较小的子问题，这些子问题互相独立且与原问题形式相同，求解这些子问题，然后将各子问题的解合并得到原问题的解。  
如定义所述，由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术解  决并实现分治策略提供了方便。分治法也可以看成是一种递归，因为必要时可把分解求得的子问题的解合并起来获得原问题的解。  
分治算法一般分为如下三个基本步骤：（1）将原问题分解为若干相同的子问题；（2）若子问题的规模容易解决则直接求解，否则继续分解；3）将子问题的解合并得到原问题的解，当遇到如折半查找等某些不必求出所有子问题的解的情况时，则省略合并操作。  
分治算法的计算复杂性可以通过构造递推表达式进行分析：假设一个递归算法把一个规模为$n$ 的问题分成$a$ 个子问题，其中每个子问题的规模是$n/b$（为简单起见，假设$n$是$b$的倍数），并设在把子问题解组合成原问题解的处理中需要总量为$g(n)$的额外运算。  
【定义2.22】若$f\!\!\left(n\right)$表示求解规模为$n$ 的问题所需的运算数，则$f$满足如下递推关系：  
$$
f~(n)=a f(n/b)+g(n)\tag{2-23}
$$  
上式称为分治递推关系。  
可通过上述递推关系来分析算法的复杂度。  
【定理2.31】假设$f$是满足递推关系：  
$$
f(n)=a f(n/b)+c
$$  
的增函数，其中$n$ 被$b$ 整除，$a{\geq}1$，$b$ 是大于1 的整数，$c$ 是一个正实数。则有：  
$$
f(n)={\left\{\begin{array}{l l}{O(n^{l o g_{b}\,a})}&{{如果a>1}}\\ {O(l o g\,n)}&{{如果a=1}}\end{array}\right.}\tag{2-24}
$$  
进一步，当$n=b^{k}$时（$k$ 是正整数），则有：  
$$
f(n)=C_{1}n^{l o g_{b}\,a}+C_{2}\tag{2-25}
$$  
其中$C_{1}{=}f\!\!(1){+}c/(a{\cdot}1)$且$C_{2}=-c/(a-1)$"
分配律,性质,"['第十一章  抽象代数结构通论', '§ 11.2 代数结构的运算性质', '11.2.1  二元算律']","{'实体类型': '性质', '定义': '在二元代数结构中，运算*对Δ满足左分配律、右分配律或同时满足左右分配律', '应用': '实数集合上的普通乘法对加法、矩阵乘法对加法、幂集上的集合交运算对并运算'}",,3,"现在我们介绍和讨论二元运算律。一共有六个二元运算律，即结合律、交换律、幂等律、消去律、分配律和吸收率。其中前面四个基于单个二元运算，后面两个基于两个二元运算。下面分别讨论这些运算律，首先讨论结合律。  
结合律是大家非常熟悉也是非常重要的一个二元运算律，实数加法与乘法运算、矩阵的加法与乘法运算、关系与函数的复合运算、整数集合上的模余运算、幂集合的交运算与并运算等都满足结合律。结合律的具体定义如下：  
【定义11.5】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由$𝐴$和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$，成立$(x*y)*z=x*(y*z)$，则称$\langle A,*\rangle$的运算 $^*$ 在 𝐴 上是可结合的，或者说 $\langle A,*\rangle$ 的运算 $^*$ 在 𝐴 上满足结合律。  
对于任意给定的集合𝐴，由于𝐴上的二元运算${\ast}$满足封闭性，故对于$\forall x,y,z\in A$，有${x\ *}$$y\in A$且$y*z\in A$。因此，$(x*y)*z$和$x*(y*z)$都是有意义的算式，如果$*$满足结合律，则表达式$x*y*z$就有一个确定的计算结果，即有：  
$$
x*y*z=(x*y)*z=x*(y*z)
$$  
如果 $*$ 不满足结合律，则有可能有 $(x*y)*z\neq x*(y*z).$ 。   此时，表达式 $x*y*z$ 的含义就有歧义。因此，只有当某个运算$*$满足结合律时，才能定义其方幂运算。在后续半群与群中元素方幂的的定义中，其元素运算的结合律起着基础性的支撑作用。  
下面考察运算的交换律，首先给出交换律的定义，具体如下：  
【定义11.6】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y\in A$，成立$x*y=y*x$，则称$\langle A,\ *\rangle$的运算$^*$在𝐴上是可交换的，或者说$\langle A,\ *\rangle$的运算$^*$在𝐴上满足交换律。  
交换律表示代数结构载体集合中的任意两个元素在运算时都可以交换次序。 例如，实数加法与乘法运算、矩阵的加法、整数集合上的模余运算、幂集合的交运算与并运算等都满足交换律。 但是，矩阵的乘法运算、关系与函数的复合运算等都不满足交换律。  
【定义11.7】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，若存在某个元素$a\in A$，满足 a$*$$a=a$，则称$a$是$\langle A,\ *\rangle$的一个幂等元。 如果𝐴中的每个元素都是$\langle A,\ *\rangle$的幂等元，则称$\langle A,\ *\rangle$的运算$*$在𝐴上满足幂等律。  
从上述定义可以看出，所谓幂等元，就是该元素与其自身运算之后仍然等于其自身。例如，对于某个幂集合上的交运算和并运算，幂集合中每个元素显然都是幂等元，因此，幂集合上的交运算和并运算均满足幂等性。但是，对于整数上的加法运算，除了整数0 之外，其余整数显然都不是幂等元，因此,整数上的加法运算不满足幂等律。  
【定义11.8】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$：  
（1）若$z*y=z*x$，有$y=x$，则称运算$*$在𝐴上是可左消去的，或者说运算$∗$在𝐴上满足左消去律，并称$\cdot z$是$A$中关于运算$^*$的左可消去元；  
（2）若$y*z=x*z$，有$y=x$，则称运算$^*$在𝐴上是可右消去的，或者说运算$^*$在𝐴上满足右消去律，并称𝑧是$A$中关于运算$^*$的右可消去元。  
（3）若上述两种情况均满足，则称运算$*$在𝐴上满足消去律，并称$z$是𝐴中关于运算$*$的可消去元。  
下面介绍基于两个二元运算的运算律，即分配律和吸收律。首先给出分配律的定义：  
【定义11.9】假设𝐴是任意给定的一个非空集合，$^*$和$\Delta$均为𝐴上的二元运算，在由$𝐴$、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y,z\in A$：  
若有$x*(y\Delta z)=(x*y)\Delta(x*z)$，则称运算$*$对$\Delta$在𝐴上满足左分配律。  
若有$(y\Delta z)*x=(y*x)\Delta(z*x)$，则称运算$*$对$\Delta$在𝐴上满足右分配律。  
若运算$*$对$\Delta$在𝐴上同时满足左右分配律，则称运算$*$对$\Delta$在𝐴上满足分配律。  
例如，实数集合上的普通乘法对加法满足分配律，$M_{n}(R)$上的矩阵乘法对加法满足分配律，幂集$P(B)$上的集合交运算对并运算满足分配律，并且并运算对交运算也满足分配律。  
将上述关于集合的吸收律推广到一般运算对象和一般运算，得到一个新的运算律，即吸收律。其具体定义如下：  
【定义11.10】设𝐴是任意给定的一个非空集合，$*$和$\Delta$均为为𝐴上二元运算，在由𝐴、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y\in A$，成立：  
$$
x*(y\Delta z)=x,\;\;x\Delta(y*z)=x
$$  
则称 $*$ 和 $\Delta$ 在 A  上满足吸收律。"
分配格,概念,"['第十二章 典型抽象代数结构', '§ 12.5 格的概念与性质', '12.5.3 常用特殊格结构']","{'实体类型': '概念', '定义': '满足分配律的格结构', '条件': '对于任意a,b,c，有a*(b⊕c)=(a*b)⊕(a*c)和a⊕(b*c)=(a⊕b)*(a⊕c)', '特点': '只需证明其中一个等式即可', '定理': '不存在与钻石格或五角格同构的子格；任意一条链都是分配格；具有特殊消去律'}",,3,"以上从偏序和代数这两个角度考察了格结构的基本概念和基本性质。如果对一般格结构赋予一些新的特征或约束条件，则可进一步得到相应的特殊格。本小节主要讨论若干重要的特殊格，主要包括分配格、有界格和有补格。  
一、分配格  
我们知道格结构的代数运算满足交换律、结合律和吸收律，但并没有要求其满足分配律。事实上，对于一般的格结构只能满足确界运算对偏序的分配不等式，这是一个以不等式形式出现分配形式，这只是一个弱分配律运算性质，如果将该性质加强为以等式形式构成真正意义上的分配律，由此便可得到一种名为分配格的特殊格结构，其具体定义如下：  
【定义12.31】设$\langle L,*,\oplus\rangle$是一个格，如果对于$\forall\ \ a,b,c\in L$，都有： $a*(b\oplus c)=(a*b)\oplus(a*c);\,\,\,a\oplus(b*c)=(a\oplus b)*(a\oplus c)$  
即运算满足分配律，则称$\langle L,*,\oplus\rangle$是一个分配格。  
值得注意的是，以上定义中两个式子其实是对偶式。因此，如要证明一个格是分配格只需证明上式中的任意一个等式即可。  
【定理12.34】设$\langle L,\leq\rangle$是任意给定的一个格结构，则$\langle L,\leq\rangle$是分配格当且仅当$\langle L,\leq\rangle$中即不存在与钻石格同构的子格，也不存在与五角格同构的子格  
【定理12.35】任意一条链都是一个分配格。  
消去律在格中一般不成立，但在分配格中具有如下一种特殊的消去律：  
【定理12.36】设$\langle L,*,\oplus\rangle$是任意给定的一个分配格，则对$\forall$$a,b,c\in L$$，如果a*b=a*c且$$a\oplus b=a\oplus c$，那么有$b=c$。  
二、有界格  
我们知道，格结构是一个偏序结构，如果在该结构的载体集合中引入存在最大值和最小值的约束条件，则可得到有界格的概念，具体如下：  
【定义12.32】设$\langle L,\leq\rangle$是任一给定的格，若$L$中存在最小元和最大元，即$\exists a,b\in L$，对∀ $x\in L$，有$a\leq x$且$x\leq b$，则称$\langle L,\leq\rangle$为有界格，通常将其最大元记为1，最小值记为0。 例如，设$𝑆$是一个非空集合，则格$\langle S,{\subseteq}\rangle$是一个有界格，其最大元是$𝑆$，最小元是$\varnothing$。并不是所有的格都是有界格，例如是实数集上的是小于或等于关系构成的格$<R,\leq\;>$，显然不是有界格。根据最小元和最大元以及幺元和零元的定义，易知成立下列等式：  
$1*x=x*1=x;1\oplus x=x\oplus1=1;0*x=x*0=0;0\oplus x=x\oplus0=x$  
也就是说1 是$*$和⊕的幺元与零元，0 是⊕和$*$的幺元和零元。  
【定理12.37】对于任意一个有界格$\langle L,\leq\rangle$，其最大值和最小值是唯一的。  
三、有补格  
对于格$\langle P(A),\subseteq\rangle$或$\langle{ P}(A),\cap,\cup\rangle$来说，集合$𝐴$和空集$\varnothing$显然是$P(A)$的最大元和最小元。我们知道，可在$\langle{ P}(A),\cap,\cup\rangle$上定义集合的补运算，即对于$\forall B\in P(A)$，存在${\bar{B}}\in P(A)$，满足：  
$$
B\cup\bar{B}=\ A;\ B\cap\bar{B}=\ \varnothing\quad\text{(12.5.9)}
$$  
通常称集合$\bar{B}$是集合$ B$的补集，或者称集合$\bar{B}$与$B$具有互补关系。现将格结构$\langle{ P}(A),\cap,\cup\rangle$或$\langle P(A),\subseteq\rangle$上的补运算推广到一般的有界格中，得到如下有补格的概念：  
【定义12.33】设$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$是任意给定的一个有界格，则对$\forall a\in L$，如果存在$b\in$$L$，满足$a*b=0$ 且$a\oplus b=1$，则称$ b$是$a$的补元素，通常简称为补元，记作$\bar{a}$。如果有界格$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$中每个元素都存在其补元素，则称$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$为有补格。  
由格结构的交换律可知，如果$b$是$a$的补元，那么$a$也是$b$的补元，即$a$与$b$互为补元。易知，在有界格中， 0 的唯一补元是1，1 的唯一补元是0。但是，对于有界格中一般的元素，其补元不一定存在。因此，虽然有补格一定是有界格，但有界格不一定是有补格。  
另一方面，对于任个有补格，并不能保证其中每个元素的补元素是唯一确定的。例如，对于如图12-8 所示的有界格，易知$a$补元是$b$和$c$，$b$的补元是$a$和$c$，$c$的补元是$a$和$b$。  
![](images/15c8cb1c91d0343f4329e4fe28808131c9c2a9b35b96281ded4f82ad6ec628e1.jpg)  
有补格中元素补元的这种不唯一性容易造成对问题分析和求解的混淆。因此，必须对一般的有补格结构附加适当的约束条件，使其能够满足格中任意元素补元的唯一性。事实上，如果对有补格附加满足分配律的约束，这可保证其补元的唯一性，即有如下定理：  
【定理12.38】设$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$是一个有补格并且也是一个分配格，即是一个有补分配格，则$L$中任意元素的补元存在且唯一。  
从以上分析讨论可知：有补格仅保证了补元的普遍性，即格中任意一个元素都至少存在一个补元，但不能保证补元的唯一性；分配格则可以保证补元的唯一性但不能保证补元的普遍性；有补分配格同时吸收了有补格和分配格这两种特殊格的优点，能够同时保证补元的普遍性和唯一性。因此，有补分配格是一个具有优良性质的特殊格结构。事实上，有补分配格就是在计算机、电子信息、自动化等科学与工程中大量用到的布尔格或布尔代数。"
切割,概念,"['第十章  特殊图模型与算法', '§ 10.4 网络流图及其优化问题', '10.4.1 流网络与切割']","{'实体类型': '概念', '定义': '将流网络结点集合划分为两部分，源点在一部分，汇点在另一部分', '特点': '切割容量为从一部分到另一部分所有有向边容量之和，净流量为穿过切割的流量代数和'}",,3,"首先介绍流网络模型的相关基本概念及其数据描述。如同每条公路有运输量、每根水管有最大流量限制一样，网络流图的每条边都有容量，或者说每条边都有一定的流量。网络流图其实就是每条边具有附带容量（可理解为权值）的有向图。其具体定义如下：  
【定义10.4.1】设有向图$G=\langle V,E\rangle$，$V$中包含一个源结点𝑠和一个汇结点$t$，且每条边$(u,v)\in E$均有一个非负容量$c(u,v)\geq0$，若$(u,v)\notin E$，则规定其容量$c(u,v)=0$，此时称有向图$G$是一个网络流图，简称为流网络或网络。源结点$s$即起点，汇结点$t$即终点。网络流是定义在网络$G$中关于边的一个实函数，用$f(u,v)$表示有向边$(u,v)\in E$上结点$ u$到结点$v$的网络流。$f(u,v)$表示$u$ 到$v$的净流。  
例如，如果$_{u}$到$v$有6 个单位的实际流，且$v$到$u$有3 个单位的实际流，那么$f(u,v)=$3，$f(v,u)=-3$，互为相反数。净流是实际通过的流量矢量和，可类比合力的概念。  
满足以下三个性质的网络流$f$称之为可行流：  
（1）容量限制：对所有的$(u,v)\in E$，都有$f(u,v)\leq c(u,\textit{}v)$。即一条边的流不能超过它的容量。这也很容易理解，如同自来水管的水流自然不会超过水管本身的容量。  
（2）斜对称：对所有$(u,v)\in E$，都有$f(u,v)=-f(v,u)$。即点$\cdot u$到$v$的净流必须与点𝑣到$u$的净流相反。可以类比物理中矢量概念，如作用力与反作用力，强调的是其方向性。  
（3）流守恒：对所有$u\in V-\{s,t\}$，都有$\textstyle\sum_{v\in V}f(u,v)=0$。即除源结点$𝑠$和汇结点$𝑡$外，其余每个结点的净流之和为0。  
![图10-68 网络及可行流  ](images/bada5974bba3db0db4c82fa8e3076a8834542abfa1641f17fac232a32e6fee29.jpg)  
例如，如图10-68 所示，网络中定义网络流$f(u,v)$是一条可行流。图中每条边所对应的序偶表示该边的容量和流量，第一个数字表示边的容量，第二个数字表示边的流量。  
下面结合图10-68 所示网络实例介绍网络流模型中与边相关的几个概念。可根据边的容量与流的大小关系对网络中的边进行分类：  
（1）满足$f(u,v)=c(u,v)$的边称为饱和边，如边(1,2)、 (2,3)  
（2）满足$f(u,v)<c(u,v)$的边称为非饱和边，如边(2,4)。  
（3）满足 $f(u,v)=0$ 的边称为零流边，如边 (3,4) ；满足 $f(u,v)>0$ 的边称为非零流 边，如边(5,4)。  
（4）既不是零流边也不是饱和边的边，称为弱流边，如边(5,6)  
如果把图10-78 看作是一个公路网，6 个结点分别表示6 座城镇，每条边上的权数表示两城镇间的距离。若现在需要从起点1 将一些物资运送到终点6，应怎样选择路线才能使总运输距离最短。我们知道，这样一类问题称为最短路径问题。类似的，如果把图10-1看作为一个输油管道网，结点1表示为发送点，结点6表示为接收点，其它点表示为中转站，各边的权数表示该段管道的最大运输油量。那么如何安排输油线路才能使从1到6的总运输量最大。这样一类问题就是最大流问题。  
最大流问题是网络优化中的一个典型的问题，简单地说，就是在满足容量约束的前提下将尽可能多的流从源结点流向汇结点。因此，最大流问题就是求流网络$G$中使其流量$f$达到最大的一个可行流，该可行流即为最大流。具体定义如下：  
【定义10.4.2】设有向图$G=\langle V,E\rangle$是任意给定的一个网络流图，若$f$是$G$ 中流量最大的的可行流，则称该可行流$f$是$G$ 的最大流，构构造网络流图$G$ 中最大流的问题，就称为网络流图的最大流问题。  
为了实现对最大流问题的求解，必须对网络流图中的增流空间进行合理的度量，通常使用一种名为残留网络的图模型实现这项工作。残留网络的具体定义如下：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图， $f$为$G$的一个流，对于$G$的任意一条边$(u,v)$，在不超过容量$c(u,v)$条件下，从$u$到$v$可压入的额外流量，称为$(u,v)$的残留容量。由$G$中所有边残留容量构成的带权有向图称为$G$的残留网络，记为$G_{f}=\langle V,E_{f}\rangle$。  
若$c_{f}(u,v)$为残留网络$G_{f}$中边$(u,v)$的残留容量，且边$(u,v)\in E$或边$(v,u)\in E$，则$(u,v)\in$$E_{f}$,$\,c_{f}(u,v)=c(u,v)-f(u,v)\,$。例如，若设$(u,v)$当前流量为(4,3)，此时$c(u,v)=4$，$f(u,v)$）$=3$，则有：$c_{f}(u,v)=1$。  
需要注意的是，残留网络具有这样的性质：假设从$_{.}u$到$v$已经有了3 个单位流量，那么从反方向上看，也就是从$v$ 到$u$ 就有了3 个单位的残留容量，这时$c_{f}(v,u)=3$。换句话说，从$u$ 到$v$ 有3 个单位流量，那么从$v$到$u$ 就有了将这3 个单位流量压回去的能力。因此，残留网络结点之间通常由双向带权边进行联结。例如，对于图10-69（a）所示的一个流网络$G$，图10-69（b）则表示该流网络𝐺的残留网络。  
![图10-69 流网络及其残留网络 ](images/d65d1c72064671125468548ae171a28ede5424f1d36d601972ed76c90131fc8c.jpg)  
对于任意给定的一个网络流图$G=\langle V,E\rangle$，可以通过其残留网络$G_{f}=\langle V,E_{f}\rangle$求得$G$的最大流。基本思路如下：首先，对所有的结点令初始状态时流的值为0，即对于$\forall u,v\in V$，有$f(u,v)=0$。然后，通过迭代方式其残留网络中不断寻找源点𝑠到汇点$t$之间的流量增广路径来增加网络流量值，直到残留网络没有这样的增广路径为止。  
因此，在残留网络$G_{f}=\langle V,E_{f}\rangle$寻找流量增广路径是最大流求解算法的关键。为正确理解该算法，现给出流网络增广路径的具体定义：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，$G_{f}=\langle V,E_{f}\rangle$为$G$在流$f$下的一个残留网络，则$G_{f}=\langle V,E_{f}\rangle$中任意一条从源点$s$到汇点$t$的简单路径$p$称为$G=\langle V,E\rangle$的一条流量增广路径，简称为增广路径。  
事实上，可将增广路径形象地理解为网络流图$G$中从源点𝑠到汇点𝑡的一条不违反流网络边容量限制的路径，并向这条路径压入一定的流量，以增加整个网络的流量值。例如，图10-69（b）所示的残留网络存在这样一条如图10-70 中加粗有向边所示的增广路径。  
![图10-70 增广路径 ](images/1e52dc98ce8f5b49283b093dbb72c0d5308ccdc9782306a98cb168474d58608f.jpg)  
![图10-71 流网络的一个切割](images/c52dd38b6f7d2bc46bb57e2440709d67355577a7b3d5fb2e920f10a5bfeb8598.jpg)  
若将图10-70 所示增广路径在流网络所对应每条边的流量增加4 个单位，得到一个新的流网络，其流量比原网络多4 个单位。然后，在新流网络所对应的残留网络中继续寻找新增广路径，直到找不到新增广路径为止。显然，现在的问题是：如果在残留网络$G_{f}=$$\langle V,E_{f}\rangle$中找不到增广路径，此时该残留网络所对应的流$f$是否就是流网络$G=\langle V,E\rangle$的最大流？要解决这个问题，必须进一步引入流网络切割的相关概念，具体如下：  
【定义10.4.4】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，如果将$G$的结点集合𝑉划分为𝑆和$T=V-S$两部分，使得源点$s\in S$且$t\in T$，则称$(S,T)$是$G=\langle V,E\rangle$的一个切割，简称为割。从集合 𝑆 到集合 𝑇 的所有有向边容量之和称为切割 $(S,T)$ 的容量，穿过切割 $(S,T)$所有边流量的代数和流量称为切割$(S,T)$的净流量，记为$f(S,T)$。  
主要注意的是，定义10.4.4 中边的流量带有正负方向，如果流从结点𝑆流向$T$，则该边的流量值为正，如果流从结点𝑇流向𝑆，则该边的流量值为负。例如，对图10-69（a）所示的流网络，可画一个如图10-71 所示的切割$(S,T)$，其容量为：  
$$
c(u,w)+c(v,x)=12+14=26
$$  
穿过该切割的净流量为：  
$$
f(u,w)+f(v,x)-f(w,v)=12+11-4=19
$$  
显然，对于任意一个切割，穿过该切割的净流量上界就是该切割的容量，即穿过切割的净流量不可能超过割的容量。由于流网络中所有切割的流都相等并且等于网络的流，因此，网络最大流必然无法超过网络的最小割。由此得到如下最大流最小割定理：  
【定理10.4.1】（最大流最小割定理）设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和$t$分别为其源点和汇点，则$G=\langle V,E\rangle$的最大流量等于其最小割切的容量。对于$G=\langle V,E\rangle$上的任意一个流$f$，以下三个结论彼此等价：  
(1) $f$是流网络$G=\langle V,E\rangle$的一个最大流；  
(2) 流网络$G=\langle V,E\rangle$的残留网络中不包括任何增广路径；  
(3) 存在流网络$G=\langle V,E\rangle$的某个切割$(S,T)$，满足：
$$
f(S,T)=c(S,T)
$$"
删除操作,算法,"['第九章  树的基本理论与算法', '§ 9.3 特殊根数与算法', '9.3.1 平衡树模型']","{'实体类型': '算法', '步骤': '首先定位要删除的结点，删除完成后从删除结点的父亲开始向上维护树的平衡，采取不同的旋转策略调整'}",,3,"对于二叉树的一些基本操作，比如插入、删除和查找等，其算法时间复杂度都与树的高度有关。因此，适当控制树高是一个非常关键的问题。显然，控制树高的一个有效措施就是尽量保持树的左右子树高度大致平衡，由此产生平衡二叉树的概念。  
平衡二叉树是一种特殊的二叉树，要求树中任何结点的两棵子树高度差不能超过1，如果插入或者删除一个结点使得高度之差大于1，就要进行结点之间的旋转操作，将二叉树重新维持在一个平衡状态。  
平衡二叉树是一种非常重要的树模型，因为它可以保证一些在树上的基本操作具有较好的最坏情况性能，这使它在信息查找等很多场合有着十分重要的作用。后面将会详细介绍平衡二叉树的若干特例，如红黑树、$B$树等。  
平衡二叉树的操作主要有查找、插入和删除结点等。其中插入和删除结点操作可能需要通过一次或多次旋转操作来重新平衡该树，使其满足平衡二叉树的要求。下面简要介绍有关平衡二叉树的一些基本概念和操作。  
树模型中某结点左子树的高度减去该结点右子树的高度，所形成的差值称为该结点的平衡因子，即$\mathrm{Balance~Fector(BF)=}$左子树的高度-右子树的高度。  
平衡二叉树的平衡因子为-1，0 或1。设计平衡二叉树操作算法的关键在于如何使得平衡二叉树保持平衡。以下四种情况下的插入操作可能会导致原有平衡二叉树发生不平衡:  
（1）LL：若某一节点的平衡因子为1，当在其左子树的左子树上插入一个新结点时会导致该结点的平衡因子由1 变为2。  
（2）RR：若某一节点的平衡因子为-1，当在其右子树的右子树上插入一个新结点时会导致该结点的平衡因子由-1 变为-2。  
（3）LR：若某一节点的平衡因子为1，当在其左子树的右子树上插入一个新结点时会导致该结点的平衡因子由1 变为2。  
（4）RL：若某一节点的平衡因子为-1，当在其右子树的左子树上插入一个新结点时会导致该结点的平衡因子由-1 变为-2。  
平衡二叉树有四种基本的旋转方式，分别为：左旋转，右旋转，先左后右旋转，先右后左旋转。针对上述四种情况可能导致的不平衡，可通过旋转的方式使得平衡二叉树恢复平衡，具体做法如下（箭头中数字为子树的高度，结点旁边的数字为其平衡因子）：  
![图 $9{-}30~\mathrm{LL}$  情况旋转](images/ca76734b4d3583b5c59b3d750c1c21778ffd2f87170aec4bd9132947c230f2d0.jpg)  
![图9-31RR 情况旋转 ](images/de09284418b14138ebb993596ee227f73dfbd205bc84b4dc9b8dc270f608bf3d.jpg)  
（1）LL 型调整：插入操作，当三个结点处于一条直线，并均是左结点时(导致LL 情况)需要以中间结点为旋转轴向右侧(顺时针)旋转一次。如图9-30 所示。具体步骤如下：  
步骤一：将 $𝐴$ 的左子树 $B$ 提升为新二叉树的根  
步骤二：将原来的 $𝐴$ 连同其右子树 ${\mathbf{}}A_{R}$ 向下旋转，使其成为 𝐵 的右子树  
步骤三：将$B$的原右子树${B_{R}}$作为左子树连接到𝐴上  
（2）RR 型调整：插入操作，当三个结点处于一条直线，并均是右结点时(导致RR 情况)需要以中间的结点为旋转轴向左侧(逆时针)旋转一次。如图9-31 所示。具体步骤如下：  
步骤一：将 $𝐴$ 的右子树 $B$ 提升为新二叉树的根  
步骤二：将原来的 $𝐴 $连同其左子树 ${}^{;}A_{L}$ 向下旋转，使其成为 $𝐵$ 的左子树  
步骤三：将$\cdot B$的原左子树$B_{L}$作为左子树连接到𝐴上  
（3）LR 型调整：插入操作，当三结点不在一直线且均是左结点时，需以插入结点为旋转轴向左侧(逆时针)旋转一次，然后向右侧(顺时针)旋转一次，即先做RR 操作再做一次LL 操作（在LR 情况，需要先将$B$左旋转，再将𝐴右旋转），如图9-32 所示。具体步骤如下：  
首先执行RR 旋转：  
步骤一：将 $B$ 的右子树 $C$ 提升为新二叉树的“根”  
步骤二：将原来的 $B$ 连同其左子树 ${'}B_{L}$ 向下旋转，使其成为 𝐶 的左子树  
步骤三：将$C$的原左子树$C_{L}$作为右子树连接到$B$上  
然后再执行LL 旋转：  
步骤四：将$𝐴 $的左子树 $C$ 提升为新二叉树的根  
步骤五：将原来的 $𝐴$ 连同其右子树 ${\mathbf{}}A_{R}$ 向下旋转，使其成为 $𝐶$ 的右子树  
步骤六：将𝐶的原右子树$C_{R}$作为左子树连接到𝐴上  
![图9-32 平衡二叉树插入操作LR 情况旋转](images/86ffa77dc86336b0d7814938270d287104a964c00ad6b86a183a77c341a73ccd.jpg)
![图9-33  RL 情况旋转 ](images/73d2aa49589db07f2f0cd8ac54b27db44de079203d670420e8cc6330c886ef14.jpg)  
（4）RL 型调整：插入操作，当三结点不在一直线且均是右结点时，需以插入结点为旋转轴向右侧(顺时针)旋转一次，然后向左侧(逆时针)旋转一次，即先做LL 操作再做一次RR 操作（在RL 情况，需先将$B$右旋转，再将𝐴左旋转）。如图9-33 所示。具体步骤如下：  
首先执行LL 旋转  
步骤一：将 $B$ 的左子树 $C$ 提升为新二叉树的“根”  
步骤二：将原来的 $B$ 连同其右子树 $B_{R}$ 向下旋转，使其成为 $𝐶$ 的右子树  
步骤三：将$𝐶$的原右子树$C_{R}$作为左子树连接到$B$上  
然后再执行 RR  旋转  
步骤四：将 $𝐴$ 的右子树 $C$ 提升为新二叉树的根  
步骤五：将原来的 $𝐴$ 连同其左子树 ${}^{;}A_{L}$ 向下旋转，使其成为 $𝐶$ 的左子树  
步骤六：将$𝐶$的原左子树$C_{L}$作为右子树连接到$𝐴$上 在上述四种旋转基础上，就可对平衡二叉树进行插入和删除操作，具体如下：  
（1）插入操作：插入完成后需要从插入的结点开始维护一个到根结点的路径，每经过一个结点都要维持树的平衡，需要根据高度差的特点采取不同的旋转策略进行调整，使整棵树恢复成为平衡树。  
（2）删除操作：首先定位要删除的结点，删除完成后，要从删除结点的父亲开始向上维护树的平衡一直到根结点，然后采取不同的旋转策略调整，使整棵树恢复成为平衡树。"
删除算法,算法,"['第九章  树的基本理论与算法', '§ 9.3 特殊根数与算法']","{'实体类型': '算法', '应用': '根树模型的基本操作'}",,2,根树是一类非常重要的树模型，能够对很多复杂的数据信息进行表示和处理，广泛应用于程序设计、数据结构、算法设计与分析、操作系统等多门后续课程。根树的种类很多，可以针对不同类型的问题或数据建立相应类型的根树模型。本节着重介绍三种最为典型的特殊根树模型，即平衡树模型、红黑树模型和𝐵树模型，并分析和讨论这些模型的插入、删除、更改、旋转等基本算法，旨在为后续相关专业课程的学习打下良好的基础。
判定,算法,"['第三章  命题演算与推理', '§ 3.5 命题逻辑的演绎推理', '3.5.1 永真蕴含关系与判定']","{'实体类型': '算法', '应用': '命题公式永真蕴含关系的判定'}",,3,从数理逻辑的角度看，演绎推理就是从作为前提的命题公式中推出新的命题公式作为推理结论，而且前提与结论之间具有必然联系。这种必然联系就是如果前提为真，那么结论必然为真。因此，演绎推理的本质就是揭示前提与结论之间的这种永真蕴含关系。作为命题逻辑演绎推理的基础，本小节给出命题公式永真蕴含关系及其判定的基本知识。
前束合取范式,概念,"['第四章  谓词演算与推理', '§ 4.3 谓词公式的范式', '4.3.1 等值型范式', '二、前束范式']","{'实体类型': '概念', '定义': '母式为合取范式的前束型公式'}",,4,"有了前束型公式，就不难得到前束范式。所谓前束范式，其实就是母式为析取范式或合取范式的前束型公式。前束范式的具体定义如下：  
【定义4.20】假设谓词公式$G$ 是任意一个前束型公式，即有：  
$$
G\Leftrightarrow(Q_{1}x_{1})(Q_{1}x_{2})\cdots(Q_{n}x_{n})M(x_{1},x_{2},\cdots x_{n})\tag{4-12}
$$  
其中$Q_{i}$为量词$\forall$或$∃$，$M$中不含有任何量词。如果$G$ 的母式$M$是一个析取范式，则称$G$ 是一个前束析取范式；如果$G$的母式$M$是一个合取范式，则称$G$ 是一前束合取范式。前束析取范式和前束合取范式统称为前束范式。  
例如，$(\forall x)(\exists y)(\forall z)((\lnot P(x)\lor R(x,y))\land(Q(x,y)));$就是一个前束合取范式。  
由于前束型谓词公式中的母式已不再含有量词，表达形式上类似于命题公式，因此可用类似于命题逻辑的方法将前束型公式中的母式转化为析取范式或合取范式，便可得到谓词公式的前束析取范式或者前束合取范式。  
【定理4.3】任意一个含有量词的谓词公式都分别存在与之等值的前束析取范式和前束合取范式，但范式的形式并不唯一。"
前束型公式,概念,"['第四章  谓词演算与推理', '§ 4.3 谓词公式的范式', '4.3.1 等值型范式', '一、前束型公式']","{'实体类型': '概念', '定义': '假设G是任意一个谓词公式，如果G的一切量词都位于该公式的最前端且这些量词的辖域都延伸到公式的末端，则称G是一个前束型公式', '表达形式': 'G\\Leftrightarrow(Q_{1}x_{1})(Q_{1}x_{2})\\cdots(Q_{n}x_{n})M(x_{1},x_{2},\\cdots x_{n})', '特点': 'M中不能含有任何量词，称M为谓词公式G的母式或基式'}",,4,"在对谓词公式进行演算或推理等分析处理时，经常需要添加或消除量词。为了便于处理，特别是为了便于计算机的机械化处理，在添加或删除量词之前，将通过等值变换将谓词公式中所有量词移到公式的最前端，由此得到如下前束型谓词公式的概念：  
【定义4.19】假设$G$ 是任意一个谓词公式，如果$G$ 的一切量词都位于该公式的最前端(不含否定词)且这些量词的辖域都延伸到公式的末端，则称$G$ 是一个前束型公式。换句话说，谓词公式$G$ 作为前束型公式必须满足如下表达形式：  
$$
G\Leftrightarrow(Q_{1}x_{1})(Q_{1}x_{2})\cdots(Q_{n}x_{n})M(x_{1},x_{2},\cdots x_{n})\tag{4-11}
$$  
其中$Q_{i}$为量词$\forall$或$\exists$，$M$中不能含有任何量词，称$M$为谓词公式$G$ 的母式或基式。  
例如，$\forall x\forall y(G(x)\land H(y)\rightarrow R(x,y)),\,\,\,\forall x\forall y\exists z(G(x,y)\land H(z)\rightarrow R(x,y,z))$ 等都是束型公式。而下列公式$\forall x(G(x)\rightarrow\exists y(H(y)\land R(x,y)),\,\exists x(G(x)\land\forall y(H(y)\rightarrow R(x,y))∃𝑥(𝐺(𝑥) ∧∀y(𝐻(𝑦) →𝑅(𝑥, 𝑦))$等都不是前束型公式。下列定理保证了谓词公式前束型公式的存在性，但并不能保证唯一性。  
【定理4.2】任意一个含有量词的谓词公式都可以转化为与之等值的前束型公式的形式，但是这种形式并不唯一。"
前束析取范式,概念,"['第四章  谓词演算与推理', '§ 4.3 谓词公式的范式', '4.3.1 等值型范式', '二、前束范式']","{'实体类型': '概念', '定义': '母式为析取范式的前束型公式'}",,4,"有了前束型公式，就不难得到前束范式。所谓前束范式，其实就是母式为析取范式或合取范式的前束型公式。前束范式的具体定义如下：  
【定义4.20】假设谓词公式$G$ 是任意一个前束型公式，即有：  
$$
G\Leftrightarrow(Q_{1}x_{1})(Q_{1}x_{2})\cdots(Q_{n}x_{n})M(x_{1},x_{2},\cdots x_{n})\tag{4-12}
$$  
其中$Q_{i}$为量词$\forall$或$∃$，$M$中不含有任何量词。如果$G$ 的母式$M$是一个析取范式，则称$G$ 是一个前束析取范式；如果$G$的母式$M$是一个合取范式，则称$G$ 是一前束合取范式。前束析取范式和前束合取范式统称为前束范式。  
例如，$(\forall x)(\exists y)(\forall z)((\lnot P(x)\lor R(x,y))\land(Q(x,y)));$就是一个前束合取范式。  
由于前束型谓词公式中的母式已不再含有量词，表达形式上类似于命题公式，因此可用类似于命题逻辑的方法将前束型公式中的母式转化为析取范式或合取范式，便可得到谓词公式的前束析取范式或者前束合取范式。  
【定理4.3】任意一个含有量词的谓词公式都分别存在与之等值的前束析取范式和前束合取范式，但范式的形式并不唯一。"
前束范式,概念,"['4.3.1 等值型范式', '二、前束范式', '§ 4.3 谓词公式的范式', '第四章  谓词演算与推理']","{'实体类型': '概念', '定义': ['谓词公式中所有范式中唯一满足等值性质的方式', '母式为析取范式或合取范式的前束型公式'], '特点': ['对于任意一个谓词公式，将其做规范化表示后所得到的范式与原谓词公式等值', '母式中不含有任何量词'], '分类': '前束析取范式和前束合取范式'}",,3,前束范式是谓词公式中所有范式中唯一满足等值性质的方式。所谓满足等值性质，是指对于任意一个谓词公式，将其做规范化表示后所得到的范式与原谓词公式等值。本小节主要介绍前束范式的概念与构造方法。
前缀码,概念,"['第九章  树的基本理论与算法', '§ 9.2 根树的基本知识', '9.2.3  前缀码与最优树']","{'实体类型': '概念', '定义': '设A={b1,b2,⋯,bm}是一个符号串集合，若对任意bi，bj∈A，bi≠bj，bi不是bj的前缀，bj也不是bi的前缀，则称A为前缀码。若在符号串bi(i=1,2,⋯,m)中，只出现0和1两个符号，则称A为二元前缀码', '应用': '用于二进制编码，避免混淆', '特点': '每个码字不是其他码字的前缀'}",,3,"在计算机及通信技术中，常用二进制编码来表示符号，称之为码字。例如，可用00、01、10、11 分别表示字母A、B、C、D。如果字母A、B、C、D 出现的频率是一样的，则传输100 个字母会使用200 个二进制位。但实际上字母出现的频率很不一样，比如A 出现的频率为$60\%$，B 出现的频率为$25\%$，C 出现的频率为$10\%$，D 出现的频率为$5\%$。能否用不等长的二进制序列表示字母A、B、C、D，使传输的信息的二进制位尽可能少呢？  
事实上，可用000 表示字母D，用001 表示字母C，01 表示B，1 表示A。此时，传输100 个字母所用的二进制位为：  
$$
3\times5+3\times10+2\times25+1\times60=155
$$  
这种表示比用等长的二进制序列表示法好，节省了二进制位。  
在编码时还要考虑一个问题，就是二进制序列的分词问题。例如，如果用1 表示A，用00 表示B，用001 表示C，用000 表示D 时，那么在接收到信息001000 时，则无法辨别它是CD 还是BAD。因此，在使用二进制序列表示A、B、C、D 等字母时，需要一些特定的编码策略以避免出现类似容易混淆的情况。为此引入如下前缀及前缀码的概念：  
【定义9.9】设$a_{1}a_{2}\cdots a_{n-1}a_{n}$是长度为$n$的符号串，则称其子串$a_{1},a_{1}a_{2},a_{1}a_{2}a_{3},\cdots\,,$,$a_{1}a_{2}\cdots a_{n-1}$分别为$a_{1}a_{2}\cdots a_{n-1}a_{n}$的长度为1，2，⋯，$n-1$的前缀。  
【定义9.10】设$A=\{b_{1},b_{2},\cdots,b_{m}\}$是一个符号串集合，若对任意$b_{i}$，$b_{j}\in A$，$b_{i}\neq$$b_{j}$，$b_{i}$不是$.b_{j}$的前缀，$b_{j}$也不是$b_{i}$的前缀，则称𝐴为前缀码。若在符号串$b_{i}\bigl(i=1,2,\cdots,\ \mathsf{m}\bigr)$中，只出现0 和1 两个符号，则称𝐴为二元前缀码,在不引起混淆时简称为前缀码。  
例如{1，01，001，000}是前缀码，而{1，11，001，0011}不是前缀码。那么如何产生前缀码呢？事实上，可用一棵二元树来产生一个二元前缀码：  
给定一棵有𝑡片叶二元树𝑇。设$v$是𝑇的任一分支点，则$v$至少一个儿子至多两个儿子。若𝑣有两个儿子，则在由𝑣引出的两条边上，左边的标0，右边的标1；若$v$只有一个儿子，在$v$引出的边上可标0 也可标1。设${v}_{i}$为𝑇的任意一片叶，从树根到$v_{i}$的通路上各边的标号组成的符号串放在$v_{i}$处，$t$片叶处的𝑡个符号串组成的集合为一个二元前缀码。  
由上述做法可知，$v_{i}$中符号串的前缀码均在${v}_{i}$所在通路上，因而所得集合为0 和1 组成前缀码。显然，若𝑇存在带一个儿子的分支点，则𝑇产生不唯一的前缀码， 𝑇若为二元完全树，则𝑇产生唯一的前缀码。例如，图9-26 所示二元树产生的前缀码为：  
![](images/0e364ce62d589d6e701c3aee01259a3ff2b2c5a6aebc38eaf711e5ecde762552.jpg)  
![](images/c850aef1e068c66827fea6f4c98a09846df47e5a769a3618a27f7a6bb63e479e.jpg)  
【定义9.11】设有一棵二元树𝑇，若对其所以的𝑡片叶赋以权值$w_{1},w_{2},\cdots,w_{t}$，则称之为赋权二元树；若权为$w_{i}$的叶的层数为$L(w_{i})$，则称：  
$$
w(T)=\sum_{i=1}^{t}w_{i}\times L(w_{i})
$$  
为该赋权二元树 𝑇 的权；   $w(T)$ 最小的二元树称为最优树。  
下面的定理9.7 给出了构造最优树的一个基本思路：  
【定理9.7】假设𝑇是一棵带有权值为$|w_{1}\leq w_{2}\leq\cdots\leq w_{t}$二元最优树。其中权$w_{1}$和$w_{2}$所对应叶结点必定是兄弟，并且如果将其父结点由分支结点改为带权$w_{1}+w_{2}$的叶结点，则由此得到的一棵新树$T^{\prime}$也是一棵最优树。  
根据上述定理，美国计算机科学家霍夫曼在1952 年提出一种构造最优树的算法，通常称之为霍夫曼算法。对于任意给定的权值 $w_{1}\leq w_{2}\leq\cdots\leq w_{t}$，算法的基本思路是：要画一棵带有$t$个权的最优树，则可依据定理9.7 将问题转化为要画一棵带有𝑡−1个权的最优树，依次类推.具体做法是：首先找出两个最小的权值设为$w_{1}$和$w_{2}$，然后对𝑡−1个权$w_{1}+$$w_{2},w_{3},\cdots,w_{t}$求作最优树，并将这棵最优树中权$w_{1}+w_{2}$对应的叶结点分叉出两个儿子，依次类推，直到只有一个权值的最优树的情形.具体算法过程如下：  
（1）初始：令${\cal{S}}=\{w_{1},w_{2},\cdots,\}$ ;  
（2）从𝑆中取出两个最小的权$w_{i}$和$w_{j}$，画结点$v_{i}$，带权$w_{i}$，画结点$v_{j}$，带权$w_{j}$。画$v_{i}$和$v_{j}$的父亲$v$，连接$v_{i}$和$v$，$v_{j}$和$v$，令$v$带权$.w_{i}+w_{j}$；  
（3）令$S=\left(S-\left\{w_{i},w_{j}\right\}\right)\cup\{w_{i}+w_{j}\};$  
（4）判断𝑆是否只含一个元素。若是，则停止，否则转（2）。  
从上述算法过程可以看出，霍夫曼算法采用递推的方式构造最优树，核心思想是逐步从从带权为$w_{1}+w_{2},w_{3},\cdots,w_{t}$的最优树${T^{\prime}}$中得到带权为$w_{1}$，$w_{2}$，⋯，$w_{t}$的最优树。  
下面结合具体实例介绍最优树的具体构造过程："
剩余系,概念,"['第二章  整数与算法设计基础', '§ 2.2 同余算术及其应用']","{'实体类型': '概念', '属性': '的概念与性质'}",,2,前面关于整数理论的讨论主要基于整数整除的概念与性质。由于整除是一个是整数之间一个比较强的约束关系，很多整数都不能满足，因此引入一种具有普适性的带余除法概念，将整数的整除归结为一种余数为0 的特殊带余除法。德国数学家高斯则是从带余除法的角度对整除的概念进行推广，引入同余的概念及相关算术。从带余除法的角度看，同余并非像整除那样要求余数一定为0，而只要求两个整数被某个除数做带余除法后得到的余数相等，这个约束显然比整除的约束宽松很多。同余算术是整理理论一个重要发展并构成初等数论的理论核心，它从在一种比整除约束更为宽松的条件下考察整数的运算及性质并得到很多非常精彩的数论成果，这些成果在整数加密算法设计等多个领域得到广泛应用。本节主要介绍同余算术的概念、性质与应用，具体包括同余关系及其运算、剩余系的概念与性质、同余方程与方程组的求解、若干经典的整数加密算法。
剪枝,技术,"['第二章  整数与算法设计基础', '§ 2.4 算法设计策略与应用', '2.4.3  回溯与动态规划', '一、回溯策略']","{'实体类型': '技术', '定义': '通过某种判断避免一些不必要的遍历过程，剪去解空间树中的一些不必要的枝条，从而缩小搜索规模', '策略': '一是用约束函数在扩展节点处剪去不满足约束条件的子树，二是用限界函数剪去不能得到最优解的子树'}",,4,"【定义2.23】回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。  
回溯法是一个既有系统性又有跳跃性的搜索算法，基本思路是在包含问题所有解的空间树中，按照深度优先的策略，从根节点出发搜索解的空间树。当算法搜索至某一节点时，先判断该节点是否包含问题的解，如果肯定不包含，则跳过以该节点为根的子树，逐层向其先前的节点回溯；否则，就进入该子树，继续按深度优先的策略进行搜索。回溯法的解空间为树结构，比较适合解决一些规模较大的问题。  
在用回溯法求解问题时，需要确定问题的解空间。所谓解空间，就是满足问题所有可能的解组成的集合，并且至少包含问题的一个（最优）解。  
由回溯法得到的解可以表示成$_{,n}$元向量$(X_{1},X_{2},\cdots,X_{n})$的形式。解向量一般具有显性或隐性的约束条件，在算法设计时，应该仔细分析，不能忽略。例如，当$n=3$ 时，0-1 背包问题可用一棵完全二叉树表示其解空间，如图2-14 所示。  
![](images/b415fb2b375de62d1f97720c41a6931e01b566d3978cde4ab5b4f6710e0bbacd.jpg)
图2-14  $n{=}3$ 时背包问题的解空间  
在作为解空间的树结构中，从第𝑖层到第$i{+}1$ 层边上的标号给出了变量$X_{i}$ 的值。从树根到叶的任一路径表示解的空间中的一个元素，即一个具体的解向量。例如，从根节点$A$ 到叶子节点$H$ 的路径相应于解空间中的元素（1,1,1）。  
回溯算法需要搜索整棵解空间树，当问题规模很大时，计算量比较大。此时可用剪枝的方法对搜索策略进行优化。  
【定义2.24】剪枝就是通过某种判断避免一些不必要的遍历过程，剪去解空间树中的一些不必要的枝条，从而缩小搜索规模。  
剪枝函数通常有两种策略，一是用约束函数在扩展节点处剪去不满足约束条件的子树，二是用限界函数剪去不能得到最优解的子树。对于限界函数，一般是添加一个全局变量记录当前最优解，在到达节点时计算该节点预期值并与当前最优解比较，若不好，则回溯。  
综上所述，回溯法解题一般包括三个基本步骤：(1)定义问题的解空间；(2)确定解空间结构；(3)以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。  
![](images/94c98789a7564cef4defce6c521572031ed59be149b82dc63805c35507db88a6.jpg)
图$2{\mathrm{-}}15\ 8{\times}8$ 棋盘"
割点,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.3  无向图的连通性']","{'实体类型': '概念', '定义': '点割集中只有一个结点的情况'}",,3,"前面我们学习了图的可达性概念及其判定，其描述的是图中两个结点之间是否可以通过一条或者多条通路进行联结，并从图的局部角度分别考察两个结点之间的连通关系。现在我  
们从全局性角度考察整个图中多个结点之间的连通关系，将两个结点之间的可达性概念推广到整个图中任意两个结点之间的可达性，由此得到图的连通性和连通图的相关概念。  
在图的连通性方面，无向图和有向图之间具有很大的差异。因此，我们分别讨论无向图和有向图的连通性。本小节主要介绍和讨论无向图连通性的概念与性质。首先给出无向图连通图的相关概念，具体定义如下：  
【定义8.25】设 $G=\langle V,E\rangle$ 为任一给定的无向图，对于图中的两个结点$v_{i}$ 与 $v_{j}$，如果从$\boldsymbol{v}_{i}$到$v_{j}$是可达的，则称从 $v_{i}$ 到 $v_{j}$是连通的，表示为[ $v_{i}\ \ ,v_{j}]$。规定图中任何结点与其自身是连通的。如果无向图$G$中任何两个结点之间都是连通的，则称该图为无向连通图或连通无向图，简称为连通图；否则，称$G$ 是非连通无向图，简称为非连通图。  
显然，无向图中两个结点之间的连通性是双向的，也就是说两结点之间的连通关系满足对称性，即：若有$v_{i}$ 到 $v_{j}$可达则必有$v_{j}$ 到 $v_{i}$可达。故在无向图中，也可将从${v}_{i}$ 到 $v_{j}$的连通说成$v_{i}$ 与 $v_{j}$连通。另外，注意到平凡图有且只有一个结点，根据无向图中结点连通性的规定，它是一种特殊的连通图。  
下面的定理表明，无向图模型中结点之间的连通性关系是一个等价关系：  
【定理8.7】设 $G=\langle V,E\rangle$ 为任一给定的无向图，其结点集为 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，令$R$ 是集合$\cdot V=\{v_{1},v_{2},\ldots,v_{n}\}$上结点之间的连通关系，即有：  
$R=\{\langle u,v\rangle|u,v\in V\}$, 且从$u$到𝑣连通}       （8-10）  
则$R$是集合𝑉上的一个等价关系。  
既然无向图模型中结点之间的连通性关系$R$是一个等价关系，那么就可以使用等价关系$R$ 将无向图 $G$ 的结点集合 𝑉 划分为若干互不相同的等价类，记为   $V_{1},V_{2},\ldots,V_{k}$ 。在这些等价类 中，相互连通的结点属于同一个等价类，不连通的结点属于不同的等价类。由此得到无向图模型的连通分支的概念，具体定义如下：  
【定义8.26】设 $G=\langle V,E\rangle$ 为任一给定的无向图$R$是图$G$结点集合𝑉上的连通性关系，则以关系𝑅的每个等价类为结点集的导出子图都称为图$G$的一个连通分支，并用$p(\mathbf G)$表示图𝐺的连通分支总数。  
由上述定义可知，如果无向图$G=\langle V,E\rangle$的结点连通性关系$R$作为一个等价关系，将结点集𝑉划分为$k$个不同的等价类$V_{1},V_{2},\ldots,V_{k}$，则由它们导出的子图$G(V_{1}),G(V_{2}),\cdots,G(V_{k})$均为图$G$的连通分支。因此，可以根据无向图中结点之间的连通关系实现对图模型的一个分解。显然，若   $p(G)=1$ ，则 $G$ 是连通图。若   $p(G)>1$ ，则   $G$ 是非连通图。  
【定义8.27】对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在结点集𝑉的某个子集 $V^{\prime}\subseteq$$V$ ，使得 $p(G-V^{\prime})>p(G)$ ，且对于 $V^{\prime}$的任何真子集 $V^{\prime\prime}$，有 $p(G-V^{\prime\prime})=p(G)$，则称 $V^{\prime}$为 $G$ 的点割集。如果点割集中只有一个结点 $v$ ，则称 $v$ 为割点。  
由上述定义可知，可通过删除图中适当结点以破坏图结构的方式考察图的连通程度。图中有些结点组成的集合在图的连通性中起着非常关键的作用，删除这些结点后会使得连通图变成非连通图，使得非连通图变得更加不连通，或者增加连通分支的数目。  
显然，对图中的任意一个点割集，该集合中所有结点都是由该点割集增加连通分支时必须同时删除的结点。例如在图8-40 所示的图$G_{1}$中，集合$\{v_{4}\},\{v_{1},v_{3}\}$都是点割集，但$\{v_{1},v_{3},v_{4}\}$则不是点割集，因为要增加图$G_{1}$的连通分支，不必同时删除结点$v_{1},v_{3},v_{4}$。  
需要注意的是，由于删除割点后，割点的邻接边也需要删除，因此我们用虚线表示已删除的边或者结点。同样，对下文所要介绍的边割集也做类似处理。  
同样，可以通过删除图中适当的边以破坏图结构的方式考察图模型的连通程度，由此可以得到边割集的相关概念，具体定义如下：  
【定义8.28】 对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在边集$E$的某个子集 $E^{\prime}\subseteq$$E$ ，使得 $p(G-\ E^{\prime})>p(G)$ ，且对于 $E^{\prime}$的任何真子集 $E^{\prime\prime}$，有 $p(G-\ E^{\prime\prime})=p(G)$，则称$V^{\prime}$为 $G$ 的边割集。如果点割集中只有一个条边  $e$ ，则称 $e$为割边或桥。  
![图8-42 例题8.24 图模型  ](images/6c126be3977ab4a2c63afc18255dc22be84fa010ee39891af7c0eba551970203.jpg)  
关于点割集与边割集，需要注意以下几个要点：  
（1）完全图 $K_{n}$ 无点割集，因为从 $K_{n}$ 中删除 $k\leq n-1$个顶点后，所得图仍然是连通的。  
（2）$n$ 阶零图既无点割集也无边割集。  
（3）对于连通图 $G$，$E^{\prime}$为 $G$ 的边割集，则必有 $p(G-E^{\prime})=2$ 。 因为删除一条边最多只能增加一个连通分支。  
（4）对于连通图 $G\ \ ,V^{\prime}$为 $G$ 的点割集，则 $p(G-V^{\prime})\geq2$，而且可能 $p(G-E^{\prime})>2$因为删除一个结点可能增加多个连通分支。  
从上述例题可以看出，对于任意给定的一个无向连通图，经常会有多个点割集或边割集，而且每个集合中所含元素的个数也不一样。此时，需要重点关注的应该是那些个数最小的集合。因为这些集合刻画了图连通结构中最为薄弱的环节，反映了连通图的最低连通程度。由此得到无向图连通图的点连通度与边连通度的概念，具体定义如下：  
【定义8.29】对于任意给定的一个无向连通图 $G=\langle V,E\rangle$，令：$\kappa(G){=}m i n\{|V^{\prime}||V^{\prime}$为G 的点割集}；$\lambda(\mathbf{G})=\operatorname*{min}\{|E^{\prime}||E^{\prime}$为G 的边割集} 并称 $\kappa(G)$ 为图 $G$ 的点连通度，$\lambda(G)$ 为图 $G$ 的边连通度。  
显然，点连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少结点数，边连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少边数。  
例如，对于图8-44 所示的无向连通图$G$ ，有$\kappa(G)=2$，$\lambda(G)=3$；对于图8-45 所示的彼得森图，有$\kappa(G)=\lambda(G)=3$。  
![图8-44 图的连通度  ](images/28f9ee3f26ab71faac7e5360d73417062a5a59d8421071b9feb627483727c42a.jpg)  
![图8-45  彼得森图  ](images/80ddd389b19bdc8904c989e51a73f2c183cb8c6f73b8b9c479ee3affcb66c7c0.jpg)  
关于无向连通图的点连通度$\kappa(G)$和边连通度$\lambda(\mathrm{G})$，需要注意以下几个要点：  
（1）如果 $G$是平凡图或非连通图，则规定 $\kappa(G)=\lambda(G)=0;$  
（2）如果$G$ 是完全图 $K_{n}$ ，由于 $G$ 中无点割集，当删除 $n-1$个顶点后，$G$ 为平凡图，故 $\kappa(G)=n-1$。  
（3）如果 $G$ 中存在割点，则 $\kappa(G)=1$；如果 $G$ 中存在割边，则 $\lambda(G)=1$。对于任何无向图 $G$ ，其点连通度 $\kappa$ 、边连通度 $\lambda$ 与结点最小度 δ 之间有如下关系：  
【定理8.8】对于任一无向图$G=\langle V,E\rangle$ ，均成立下列不等式：
$$
\kappa(G)\leq\lambda(G)\leq\delta\ (G)
$$"
割边,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.3  无向图的连通性']","{'实体类型': '概念', '定义': '边割集中只有一条边的情况'}",,3,"前面我们学习了图的可达性概念及其判定，其描述的是图中两个结点之间是否可以通过一条或者多条通路进行联结，并从图的局部角度分别考察两个结点之间的连通关系。现在我  
们从全局性角度考察整个图中多个结点之间的连通关系，将两个结点之间的可达性概念推广到整个图中任意两个结点之间的可达性，由此得到图的连通性和连通图的相关概念。  
在图的连通性方面，无向图和有向图之间具有很大的差异。因此，我们分别讨论无向图和有向图的连通性。本小节主要介绍和讨论无向图连通性的概念与性质。首先给出无向图连通图的相关概念，具体定义如下：  
【定义8.25】设 $G=\langle V,E\rangle$ 为任一给定的无向图，对于图中的两个结点$v_{i}$ 与 $v_{j}$，如果从$\boldsymbol{v}_{i}$到$v_{j}$是可达的，则称从 $v_{i}$ 到 $v_{j}$是连通的，表示为[ $v_{i}\ \ ,v_{j}]$。规定图中任何结点与其自身是连通的。如果无向图$G$中任何两个结点之间都是连通的，则称该图为无向连通图或连通无向图，简称为连通图；否则，称$G$ 是非连通无向图，简称为非连通图。  
显然，无向图中两个结点之间的连通性是双向的，也就是说两结点之间的连通关系满足对称性，即：若有$v_{i}$ 到 $v_{j}$可达则必有$v_{j}$ 到 $v_{i}$可达。故在无向图中，也可将从${v}_{i}$ 到 $v_{j}$的连通说成$v_{i}$ 与 $v_{j}$连通。另外，注意到平凡图有且只有一个结点，根据无向图中结点连通性的规定，它是一种特殊的连通图。  
下面的定理表明，无向图模型中结点之间的连通性关系是一个等价关系：  
【定理8.7】设 $G=\langle V,E\rangle$ 为任一给定的无向图，其结点集为 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，令$R$ 是集合$\cdot V=\{v_{1},v_{2},\ldots,v_{n}\}$上结点之间的连通关系，即有：  
$R=\{\langle u,v\rangle|u,v\in V\}$, 且从$u$到𝑣连通}       （8-10）  
则$R$是集合𝑉上的一个等价关系。  
既然无向图模型中结点之间的连通性关系$R$是一个等价关系，那么就可以使用等价关系$R$ 将无向图 $G$ 的结点集合 𝑉 划分为若干互不相同的等价类，记为   $V_{1},V_{2},\ldots,V_{k}$ 。在这些等价类 中，相互连通的结点属于同一个等价类，不连通的结点属于不同的等价类。由此得到无向图模型的连通分支的概念，具体定义如下：  
【定义8.26】设 $G=\langle V,E\rangle$ 为任一给定的无向图$R$是图$G$结点集合𝑉上的连通性关系，则以关系𝑅的每个等价类为结点集的导出子图都称为图$G$的一个连通分支，并用$p(\mathbf G)$表示图𝐺的连通分支总数。  
由上述定义可知，如果无向图$G=\langle V,E\rangle$的结点连通性关系$R$作为一个等价关系，将结点集𝑉划分为$k$个不同的等价类$V_{1},V_{2},\ldots,V_{k}$，则由它们导出的子图$G(V_{1}),G(V_{2}),\cdots,G(V_{k})$均为图$G$的连通分支。因此，可以根据无向图中结点之间的连通关系实现对图模型的一个分解。显然，若   $p(G)=1$ ，则 $G$ 是连通图。若   $p(G)>1$ ，则   $G$ 是非连通图。  
【定义8.27】对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在结点集𝑉的某个子集 $V^{\prime}\subseteq$$V$ ，使得 $p(G-V^{\prime})>p(G)$ ，且对于 $V^{\prime}$的任何真子集 $V^{\prime\prime}$，有 $p(G-V^{\prime\prime})=p(G)$，则称 $V^{\prime}$为 $G$ 的点割集。如果点割集中只有一个结点 $v$ ，则称 $v$ 为割点。  
由上述定义可知，可通过删除图中适当结点以破坏图结构的方式考察图的连通程度。图中有些结点组成的集合在图的连通性中起着非常关键的作用，删除这些结点后会使得连通图变成非连通图，使得非连通图变得更加不连通，或者增加连通分支的数目。  
显然，对图中的任意一个点割集，该集合中所有结点都是由该点割集增加连通分支时必须同时删除的结点。例如在图8-40 所示的图$G_{1}$中，集合$\{v_{4}\},\{v_{1},v_{3}\}$都是点割集，但$\{v_{1},v_{3},v_{4}\}$则不是点割集，因为要增加图$G_{1}$的连通分支，不必同时删除结点$v_{1},v_{3},v_{4}$。  
需要注意的是，由于删除割点后，割点的邻接边也需要删除，因此我们用虚线表示已删除的边或者结点。同样，对下文所要介绍的边割集也做类似处理。  
同样，可以通过删除图中适当的边以破坏图结构的方式考察图模型的连通程度，由此可以得到边割集的相关概念，具体定义如下：  
【定义8.28】 对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在边集$E$的某个子集 $E^{\prime}\subseteq$$E$ ，使得 $p(G-\ E^{\prime})>p(G)$ ，且对于 $E^{\prime}$的任何真子集 $E^{\prime\prime}$，有 $p(G-\ E^{\prime\prime})=p(G)$，则称$V^{\prime}$为 $G$ 的边割集。如果点割集中只有一个条边  $e$ ，则称 $e$为割边或桥。  
![图8-42 例题8.24 图模型  ](images/6c126be3977ab4a2c63afc18255dc22be84fa010ee39891af7c0eba551970203.jpg)  
关于点割集与边割集，需要注意以下几个要点：  
（1）完全图 $K_{n}$ 无点割集，因为从 $K_{n}$ 中删除 $k\leq n-1$个顶点后，所得图仍然是连通的。  
（2）$n$ 阶零图既无点割集也无边割集。  
（3）对于连通图 $G$，$E^{\prime}$为 $G$ 的边割集，则必有 $p(G-E^{\prime})=2$ 。 因为删除一条边最多只能增加一个连通分支。  
（4）对于连通图 $G\ \ ,V^{\prime}$为 $G$ 的点割集，则 $p(G-V^{\prime})\geq2$，而且可能 $p(G-E^{\prime})>2$因为删除一个结点可能增加多个连通分支。  
从上述例题可以看出，对于任意给定的一个无向连通图，经常会有多个点割集或边割集，而且每个集合中所含元素的个数也不一样。此时，需要重点关注的应该是那些个数最小的集合。因为这些集合刻画了图连通结构中最为薄弱的环节，反映了连通图的最低连通程度。由此得到无向图连通图的点连通度与边连通度的概念，具体定义如下：  
【定义8.29】对于任意给定的一个无向连通图 $G=\langle V,E\rangle$，令：$\kappa(G){=}m i n\{|V^{\prime}||V^{\prime}$为G 的点割集}；$\lambda(\mathbf{G})=\operatorname*{min}\{|E^{\prime}||E^{\prime}$为G 的边割集} 并称 $\kappa(G)$ 为图 $G$ 的点连通度，$\lambda(G)$ 为图 $G$ 的边连通度。  
显然，点连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少结点数，边连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少边数。  
例如，对于图8-44 所示的无向连通图$G$ ，有$\kappa(G)=2$，$\lambda(G)=3$；对于图8-45 所示的彼得森图，有$\kappa(G)=\lambda(G)=3$。  
![图8-44 图的连通度  ](images/28f9ee3f26ab71faac7e5360d73417062a5a59d8421071b9feb627483727c42a.jpg)  
![图8-45  彼得森图  ](images/80ddd389b19bdc8904c989e51a73f2c183cb8c6f73b8b9c479ee3affcb66c7c0.jpg)  
关于无向连通图的点连通度$\kappa(G)$和边连通度$\lambda(\mathrm{G})$，需要注意以下几个要点：  
（1）如果 $G$是平凡图或非连通图，则规定 $\kappa(G)=\lambda(G)=0;$  
（2）如果$G$ 是完全图 $K_{n}$ ，由于 $G$ 中无点割集，当删除 $n-1$个顶点后，$G$ 为平凡图，故 $\kappa(G)=n-1$。  
（3）如果 $G$ 中存在割点，则 $\kappa(G)=1$；如果 $G$ 中存在割边，则 $\lambda(G)=1$。对于任何无向图 $G$ ，其点连通度 $\kappa$ 、边连通度 $\lambda$ 与结点最小度 δ 之间有如下关系：  
【定理8.8】对于任一无向图$G=\langle V,E\rangle$ ，均成立下列不等式：
$$
\kappa(G)\leq\lambda(G)\leq\delta\ (G)
$$"
加新边运算,算法,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.2.1 图的基本运算', '二、图结构修改运算']","{'实体类型': '算法', '定义': '在图中添加一条新边的操作', '条件': '任意两个结点之间添加边'}",,4,"对于一个给定的图模型，有时会根据实际问题的需要对图的结构进行化简或修改，主要是添加或者删除图中的某个或某些边、将图中两个结点进行合并、删除图中的某个或某些结点等，由此得到如下四个常用的图结构修改运算或操作，即：边的添加运算（也称为加新边运算）、边的删除运算、边的收缩运算以及结点的删除运算。其具体定义如下：  
【定义8.12】设图 $G=\langle V,E\rangle$是一个任意给定的图模型（有向图或无向图），则$G=\langle V,E\rangle$的四个常用图结构修改运算定义如下：  
（1）加新边运算：设$u,v$是 图$G=\langle V,E\rangle$的任意两个结点，即 $u,v\in V$，将这两个结点构成的边$e$边添加到图 $G$ 的边集$E$中构成一个新图$G^{\prime}=\langle V,E\cup\{e\}\rangle$。  
（2）边的删除运算：设$e$是图$G=\langle V,E\rangle$的任意一条边，即 $e\in E$ ，从 $G$ 中删除边 $e$ 得到一个新图$G^{\prime}=\langle V,E-\{e\}\rangle$，记为 $G-e$ ；又$E^{\prime}$是图$G$中若干边组成的集合，即$E^{\prime}\subseteq E$从 $G$ 中删除 $\mathrm{E^{\prime}}$中所有边得到一个新图$G^{\prime}=\langle V,E-E^{\prime}\rangle$，记为 $G-E^{\prime}$ 。  
（3）边的收缩运算：设$.e$是图$G=\langle V,E\rangle$的任意一条边且该边关联的两个结点为$u,v$，从图中删除边$e$并将该边的两个端点$u,v$合并成一个新的结点$w$，使得结点$w$关联除$e$以外的$u$和$v$所关联的一切边，得到一个新图$G^{\prime}$，记为$G\backslash{\mathbf{e}}$  
（4）结点的删除运算：设$_v$是 图$G=\langle V,E\rangle$的任意一个结点，即 $v\in V$，从 $G$ 中删除 $v$及与𝑣相关联的所有边，得到一个新图$G^{\prime}$，记为 $G-v$，又设 $V^{\prime}\subseteq V$ ，从 $G$ 中删除 $V^{\prime}$中所有顶点及与这些顶点关联的所有边，得到一个新图$G^{\prime}$，记为 $G-V^{\prime}$。  
从上述定义可以看出，要删除边，则直接在图中将改变去掉即可；要删除结点，在去掉该结点的同时，还要去掉该结点关联的所有边；边的收缩实际上就是将改变的长度变为0，使其两个端点重叠，用一个新的结点𝑤代替，其它边不变，即$w$关联该边的两个端点关联的除该边外的一切边，不过，需要注意的是，边的收缩可能会产生自环或平行边；所谓加新边运算，就是在图中的两个结点之间直接拉一条边。"
加法原理,原理,"['第一章  集合与计数基础', '§ 1.3 有限集的基本计数技术', '1.3.1 加法原理与乘法原理']","{'实体类型': '原理', '定义': '对于任意一个有限集合，如果它可以看成是多个集合的并集且这多个集合之间互不相交，则有该集合的基数等于这些子集基数的总和', '应用': '用于计数独立事件发生方式的总数', '关键': '将一个有限集合适当划分为若干互不相交的子集，并计算这些子集的基数'}",,3,"加法原理和乘法原理是最基本的计数法则，其它所有计数方法或技巧都建立在这两个法则的基础之上。  
加法原理：对于任意一个有限集合$A$，如果它可以看成是多个集合的并集且这多个集合之间互不相交，即有：  
$$
A=A_{1}\cup A_{2}\cup\cdots\cup A_{n}\ \stackrel{\mathrm{~H~}}{\cdots}\ A_{i}\cap A_{j}=\varnothing\ \left(i\neq j\right)
$$  
则有：  
$$
|A|=|A_{1}|+|A_{2}|+\cdots+|A_{n}|
$$  
加法原理的另外一种说法如下：  
如果$n$ 个独立事件分别有$\cdot k_{1},k_{2},\cdots,k_{n}$种方式发生，那么这$n$ 个独立事件之一发生方式的总数$k$ 有可按下式计算：  
$$
k=k_{1}+k_{2}+\dots+k_{n}
$$  
加法原理的含义非常直观，其正确性是显然的。使用加法原理进行计数的关键在于如何将一个有限集合适当划分为若干互不相交的子集，并计算这些子集的基数。如果完成一个任务可以采用很多种不同的方法，而且每一种方法又有很多种不同的选择，那么完成该项任务的总方法数就等于这些所有选择数的总和。"
加法器,概念,"['第三章  命题演算与推理', '§ 3.6 命题逻辑的应用', '3.6.3 加法器电路设计']","{'实体类型': '概念', '定义': '产生数的和的装置', '分类': {'半加法器': {'定义': '加数和被加数作为输入，和位与进位作为输出的装置', '特点': '实现两个1位二进制数字相加，输出和位和进位', '电路设计': '和位电路用异或门连接，进位电路用与门连接'}, '全加法器': {'定义': '加数、被加数与低位的进位数为输入，和位与进位作为输出的装置', '特点': '在半加法器基础上增加进位', '电路设计': '使用多个半加法器产生输出'}}}",,3,"在逻辑电路中，加法器是产生数的和的装置。加数和被加数作为输入，和位与进位作为输出的装置称为半加法器；若加数、被加数与低位的进位数为输入，而和位与进位作为输出则称为全加法器。  
半加法器可以实现两个1 位的二进制数字 $P$ 、$Q$ 相加，并且输出和位 𝑆 和进位 𝐶 。它的真值表如表3-32 所示。  
表3-32 半加法器的输入与输出
![](images/9689097c676031a12dcdfab5a48f08fd719b8383be3b5172b102fc03f27a71e7.jpg)  
根据上表可知，当 $P$ 、 $Q$ 一个为0 一个为1 的时候 $S$为1，两个为0 或两个为1 时 $S$ 为0，故半加法器和位 $S$电路可用异或门连接；进位 $C$ 为1 当且仅当$P$ 、 $Q$均为1，故进位 $C$可用与门连接。由此得到如图3-13 所示半加法器的逻辑电路。  
![](images/8a81f68b8c44145e96e891e90743f2ca9882446c59fc73fdfee13d6f2c5f1b13.jpg)
图3-13 半加法器的电路设计  
全加法器在半加法器基础上增加了进位。全加法器的输入是两个二进制数字 $P$ 、$Q$ 以及进位 $C_{i}$ ，输出是和位 $S$与新的进位 $C_{i+1}$。其真值表如表3-33 所示。  
表3-33 全加法器的输入与输出
![](images/1ea8c2c861e85eb801e288410f57e7cba295768b5bcae6bea64e43846da2ba11.jpg)  
![](images/42947b900b463b9ae2f3888ade392740333e71f1053a92da3ad12ea4d82efdab.jpg)  
全加法器的两个输出和位 $S$ 与新的进位 $C_{i+1}$的逻辑表达式分别为  
$𝑆⇔(𝑃∧𝑄∧𝐶 𝑖 ) ∨(𝑃∧¬𝑄∧¬𝐶 𝑖 ) ∨(¬𝑃∧𝑄∧¬𝐶 𝑖 ) ∨(¬𝑃∧¬𝑄∧𝐶 𝑖 )  $  
$C_{i+1}\Leftrightarrow(P\land Q\land C_{i})\lor(P\land Q\land\lnot C_{i})\lor(P\land\lnot Q\land C_{i})\lor(\lnot P\land Q\land C_{i})$  
可以使用多个半加法器来产生全加法器输出，具体方法如图3-14 所示。  
$$
S=(P\land Q\land C i)\lor(P\land\neg Q\land\neg C i)
$$  
![](images/9df62bca098fc41c520e9ff9d6db19c4f6d68584c0507d0b3d41e80e5d278fa9.jpg)
图3-14 全加法器的电路设计  
图3-15 表示两个三位二进制整数相加的全加法器逻辑电路，一般的$n$二进制整数相加的全加法器逻辑电路与此类似，不再赘述。  
![](images/6c12fab6c51fb1324fd503ee6e6cc64b62965159f5f6a90bb7a62c5a1055cbb6.jpg)
图3-15 三位全加法器电路设计"
动态规划,算法,"['第二章  整数与算法设计基础', '§ 2.4 算法设计策略与应用', '2.4.3  回溯与动态规划', '二、动态规划策略']","{'实体类型': '算法', '定义': ['把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，通过对单阶段问题的逐个求解，实现对整个问题的求解', '通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推的方式去解决'], '应用': '最短路线、库存管理、资源分配、设备更新、排序、装载等问题求解', '特点': '将求解过程中所有子问题的解全部记录下来，以空间换取时间的策略', '依赖性质': '最优子结构性质和子问题重叠性质', '步骤': ['把所有最优化问题分成若干个阶段，找出最优解的性质，并刻画其结构特性', '将问题发展到各个阶段时所处的不同状态表示出来，确定各个阶段状态之间的递推关系，并确定初始条件', '应用递推关系求解最优值', '根据计算最优值时得到的信息，构造最优解']}",,3,回溯是一种基于解空间搜索的方法。基本思路类似于蛮力法，首先对所有的解状态进行枚举，生成解空间或状态空间，然后通过在解空间中搜索获得所需要的解。与蛮力法不同的是，这里的解空间是有结构的，换句话说，解空间以空间树的结构方式存在，由此可以根据这种特殊结构设计出很多高效的搜索方法。动态规划策略则是把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，通过对单阶段问题的逐个求解，实现对整个问题的求解，多年来，回溯和动态规划策略在最短路线、库存管理、资源分配、设备更新、排序、装载等问题求解算法中得到广泛应用。
匈牙利匹配构造算法,算法,['第十章  特殊图模型与算法'],"{'实体类型': '算法', '应用': '二分图模型中的基本算法'}",,1,"如前所述，图模型及其理论是数学家欧拉为解决哥尼斯堡七桥遍历问题而创立。事实上，图模型作为一种由结点和边组成的离散结构是一种非常强大的离散建模工具，除了能够解决哥尼斯堡七桥遍历问题之外，还可解决很多其它实际问题。例如，旅游的路径规划问题、资源分配与匹配问题、图的着色与并行流程的设计问题、最小费用流问题等等。针对不同的问题，通常需要设计出特定的图模型进行建模与求解。例如，解决哥尼斯堡七桥遍历问题需要使用欧拉图及相关理论、解决旅游的路径规划问题需要哈密顿图及相关理论、解决资源分配与匹配问题需要二分图及相关理论、解决图的着色与并行流程的设计问题需要平面图的相关理论、解决最小费用流问题需要网络流图的相关理论等等。由此产生很多种具有特殊结构和性质的图模型，每种特殊图模型都能针对性地有效地解决某一类或某几类特定问题。因此，要想高效合理地使用图模型实现对实际问题的建模与求解，除了掌握前述图模型的一般理论及算法之外，还需要进一步掌握多种特殊图模型的相关理论及算法。  
本章介绍几种重要的特殊图模型及相关算法，包括欧拉图模型的基本理论及边的遍历算法、哈密顿图的基本理论及结点的近似遍历算法、二分图模型的基本理论及匈牙利匹配构造算法、平面图的基本理论及着色算法、网络流图的基本理论及最大流算法，并结合具体实例分析和讨论这些特殊图模型的应用方法。"
匈牙利算法,算法,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.2.3 最大匹配判定与构造']","{'实体类型': '算法', '基本思路': '在当前匹配基础上寻找可增广道，通过对可增广道上所有边的匹配属性取反，得到新的更大匹配，重复此过程直到没有可增广道为止', '时间复杂度': 'O(mn)'}",,3,"对于任意给定的一个二分图，首先讨论如何判断该图中某个给定的匹配是否为最大匹配。为此，引入交错道和可增广道的概念，具体如下：  
【定义10.5】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图， $M$是图$G$的某个匹配，若从𝐺中的某个结点到另一个结点之间存在一条通路，且该通路由属于$\cdot M$和不属于$M$的边交替构成，则称此通路为 𝑴 交错道。若 $M$ 交错道的两端点均为 $M$ 非饱和点，则称其为 𝑴 可增广道。  
例如，对于图10-35（a）所示匹配，$P=y_{1}x_{2}y_{5}x_{4}y_{3}x_{1}$是一条交错道，对于图10-35（b）所示匹配，$P=y_{1}x_{2}y_{5}x_{4}y_{3}x_{1}$则是一条可增广道，具体见图10-35（b）的粗线部分。  
![图10-35  交错道与可增广道  ](images/f5e335487e12a671cc013f6ede9981700aa6193018e616b34157cc9869d086b6.jpg)  
在1957 年，法国著名数学家贝尔格给出了判定某个匹配是最大匹配的充分必要条件。这就是著名的贝尔格定理，具体如下：  
【定理10.10】（贝尔格定理）设$G=\langle X,E,Y\rangle$是任意给定的一个二分图， 𝑀是图𝐺的某个匹配，则$M$是图$G$最大匹配的充要条件是$G$中不存在$M$可增广道。  
在1965 年，匈牙利的著名数学家埃德蒙兹基于贝尔格定理提出构造二分图最大匹配的著名算法，为纪念他的祖国，将该算法命名为匈牙利算法。算法基本思路如下：  
假设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，如果对于该图的某个匹配𝑀，结点集合𝑋的每个结点都是饱和结点，则该匹配就是最大匹配。否则，任取𝑋中的某个非饱和结点为起点做匹配$M$的交错道。此时，如果该交错道最后一个结点是饱和结点，如图10-36 中$P_{1}$所示，则匹配$M$就是最大匹配。否则，如果该交错道最后一个结点也是一个非饱和结点，则得到一条可增广道，如图10-36 中$P_{2}$所示。  
![图 10-36   对可增广道的增广 ](images/18f50be9390d6af7d21020996653e950e5f8bda427f6af3f0640cd631a139c62.jpg)  
不难看出，该交错道$P_{2}$中不属于$M$的所有边数比属于属于$M$的边数多一个，而且交错道中不属于$M$的所有边数也是互不相邻的，故可由这些边构成一个新的匹配$M^{*}$。由于${\mathbf{\nabla}}^{*}$的边数比$M$的边数多一个，故称$M^{*}$是对$M$的一个增广。继续上述过程，直到图中没有可增广道路为止，此时的匹配就是所求的最大匹配。  
从上述讨论不难发现，匈牙利算法的核心思想就是首先在当前匹配基础上寻找可增广道，找到可增广道后，就通过对该可增广道上所有边的匹配属性取反，即对可增广道上所有边的集合$ E(P)$与匹配$M$做集合的对称差运算$\oplus$，由此得到新的集合就是一个规模更大的新匹配，然后在这个新匹配的基础上继续寻找新可增广道，如此下去，直到没有可增广道路为止。  
对于任意给定的二分图$G=\langle X,E,Y\rangle$，匈牙利算法的具体计算流程如下：  
（1）任给初始匹配$M$；  
（2）若𝑋中任一结点均饱和，则$M$即为所求，算法结束，否则转（3）；  
（3）在𝑋中找到一非$M$饱和点$x$，置$S=\{x\}$，$T=\varnothing$；  
（4）若$N_{G}(S)=T$，则停止，否则任选一点$y\in N_{G}(S)-T$；  
（5）若𝑦为$M$饱和点转（6），否则：求一条从$x$到𝑦的$M$可增广路$P$，置$M=M\oplus P$，转（2）  
（6）由于$ y$是$M$饱和点，故$M$中有一边 $(y,u)$，置$S=S\cup\{u\}$，$T=T\cup\{y\}$，转（4）。算法中$N_{G}(S)$表示 $G$上与$S$中任一结点相邻的所有结点组成的集合，$\oplus$表示集合的对称差运算。下面以图10-37 为例，详细介绍匈牙利算法的具体执行过程：  
![图10-37 二分图 ](images/e75e6b51eaa2d7dcbd869cabf1198a4ab254d8c498cf74b11e8db5905f80f0b4.jpg)  
![图10-38 步骤1 效果图 ](images/a85e16b732f3f408c1a3f889dd66171d41954384c66b3a6769a239cb765226ce.jpg)  
（1）首先任给一个初始匹配$M=\{(x_{1},y_{1}),\;\;(x_{3},y_{5}),\;\;(x_{5},y_{3})\}$，如图10-38 所示。  
（2）$x_{2},x_{4}$非饱和，故$X$非饱和。确定其中一个非饱和点$x_{2}$，令${S}=\{x_{2}\}$，$T=\varnothing$。  
（3）$S$邻接结点集${N}_{G}(S)=\{y_{2},y_{3}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{3}\}$，选择$y_{3}$  
（4）$y_{3}$已饱和，因$M$中有边$(y_{3},x_{5})$，故令：  
$$
S=S\cup\{x_{5}\}=\{x_{2},x_{5}\},\ T=T\cup\{y_{3}\}=\{y_{3}\}
$$  
（5）因为$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{4},y_{5}\}$，选择${{y}}_{5}$  
（6）$y_{5}$已饱和，因为$M$存在边$(y_{5},x_{3})$，故令：
$$
S=S\cup\{x_{3}\}=\{x_{2},x_{3},x_{5}\},\,\,\,T=T\cup\{y_{5}\}=\{y_{3},y_{5}\}
$$  
（7）$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{4}\},$,选择$y_{2}$  
（8）$y_{2}$不饱和，故存在从$x_{2}$到$y_{2}$的可增广道$P$。对于当前匹配$M=\{(x_{1},y_{1}),(x_{3},y_{5}),$$(x_{5},y_{3})\}$，求得可增广路$P$如图10 −39 加粗部分所示，得到$P$的边集：  
$$
E(P)=\{(x_{2},y_{3}),(y_{3},x_{5}),(x_{5},y_{5}),(y_{5},x_{3}),(x_{3},y_{2})\}
$$  
按下十重新调整匹配$M$，得到如图10 −40 所示一个新匹配$M$  
$$
M=M\oplus E(P)=\{(x_{1},y_{1}),(x_{2},y_{3}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
10-39 步骤8 过程图  
图10-40 步骤8 过程图2  
（9）在新匹配下继续查找可增广道。查看$ X$是否饱和，显然${{x}}_{4}$非饱和，选择该非饱和点$x_{4}$，并令$S=\{x_{4}\}$，$T=\varnothing$。  
（10）$N_{G}(S)=\{y_{3}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{3}\}$，选择$y_{3}$  
（11）$y_{3}$已饱和，因为匹配$M$中存在$(y_{3},x_{2})$，故令：
$$
S=S\cup\{x_{2}\}=\{x_{2},x_{4}\},\,\,\,T=T\cup\{y_{3}\}=\{y_{3}\}
$$  
（12）$N_{G}(S)=\{y_{2},y_{3}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{2}\}$，选择$y_{2}$（13）$y_{2}$已饱和，因为匹配$M$中存在$(y_{2},x_{3})$，故令：  
$$
S=S\cup\{x_{3}\}=\{x_{2},x_{3},x_{4}\},\,\,\,T=T\cup\{y_{2}\}=\{y_{2},y_{3}\}
$$  
（14）$N_{G}(S)=\{y_{2},y_{3},y_{5}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{5}\}$，选择$y_{5}$（15）$y_{5}$已饱和，因为匹配$M$中存在了$(y_{5},x_{5})$，故令：  
$$
S=S\cup\{x_{5}\}=\{x_{2},x_{3},x_{4},x_{5}\},\,\,\,T=T\cup\{y_{5}\}=\{y_{2},y_{3},y_{5}\}
$$  
（16 ）$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{4}\}$，选择${\cdot}y_{4}$（17）$y_{4}$不饱和，故可求一条从$x_{4}$到$y_{4}$的可增广路$ P$。对于当前匹配：  
$$
M=\{(x_{1},y_{1}),(x_{2},y_{3}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
求得如图10 −41 加粗部分所示的可增广道路$P$， $P$的边集为：  
$$
E(P)=\{(x_{4},y_{3}),(y_{3},x_{2}),(x_{2},y_{2}),(y_{2},x_{3}),(x_{3},y_{5}),(y_{5},x_{5}),(x_{5},y_{4})\}
$$  
按下式重新调整匹配$M$，得到如图10 −43 所示的一个新匹配  
![](images/ee96514b37bbad784ca2a76b1641bd0dbdac20d6a3f2ab76c80847e37bff2151.jpg)  
至此，集合$\cdot X$已经饱和，求得的如下最大匹配：  
$$
M=\{(x_{1},y_{1}),(x_{2},y_{2}),(x_{3},y_{5}),(x_{4},y_{3}),(x_{5},y_{4})\}
$$  
设二分图$G$有${n}$个结点$m$条边，使用匈牙利算法最大匹配时，初始匹配可以空，故算法最多找$n$条可增广道，每找一条可增广路，最多比较$m$条边。因此，匈牙利算法的最坏时间复杂度为$O(m n)$。由此可见，匈牙利算法是一个有效算法。"
匹配,概念,"['§ 10.2 二分图与匹配问题', '10.2.2 完备匹配与最大匹配', '10.2.3 最大匹配判定与构造', '第十章  特殊图模型与算法']","{'实体类型': '概念', '定义': ['二分图中互不相邻的边构成的子集', '图中一组没有公共顶点的边的集合'], '特点': '每个结点最多只能与一个异性匹配成舞伴', 'name': '匹配'}",,3,"首先考察一个有趣的问题：假设在某个小型舞会上有5 名男士和5 名女士，其中某些男士与某些女士之间相互认识，问如何安排才能使得相互认识的男生和女士人成为舞伴。  
可用如图10-30（a）所示的二分图模型$G=\langle X,E,Y\rangle$表示上述舞伴配对问题，其中结点集合$X=\{x_{1},x_{2},x_{3},x_{4},x_{5}\}$和$Y=\{y_{1},y_{2},y_{3},y_{4},y_{5}\}$分别表示5 名男士和5 名女士构成的集合，图中有无向边$(x_{i},y_{j})$当且仅当男士$x_{i}$与女士$y_{j}$相互认识。  
![图10-30  舞伴的安排问题 ](images/e92b7888a1cc6a1b77006b78c8c42919c89a7e806394091bb76e5c5538b07826.jpg)  
通过观察，不难得到如图10-30（b）中实线边所示的一种安排方案。由于每个人最多只能与一个异性匹配成舞伴，故所得到的安排方案其实就是图$G=\langle X,E,Y\rangle$中5 条不相邻边组成的$E$的子集：$M=\{(x_{1},y_{3}),(x_{2},y_{1}),(x_{3},y_{2}),(x_{4},y_{5}),(x_{5},y_{4})\}_{\circ}$。  
不难看出，上述问题其实就是在两类不同性质的对象之间寻找某种配对或者匹配的问题。事实上，日常生活和工作中的很多问题，例如学生选课、工作任务安排等等，都可以归结为这种匹配问题。对上述实例进行抽象，得到如下匹配的相关概念：  
【定义10.4】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，图中互不相邻的边构成$.E$的子集$M$称为$G$的一个匹配，$G$中与$M$中的边关联的结点称为匹配$M$的饱和结点。如果$X$中每个结点都是某个匹配的饱和结点，则称该匹配为$G$的一个$X^{.}$-完备匹配；如果𝑌中每个结点都是某个匹配的饱和结点，则称该匹配为$G$的一个𝑌-完备匹配；如果$G$的某个匹配既是$X-$完备匹配，又是𝑌-完备匹配，则称该匹配为完备匹配。$G$中基数最大的匹配称为𝐺的最大匹配，最大匹配中的边数称为$G$的匹配数，记作$\alpha^{\prime}(G)$。  
由定义10.4 可知，二分图的$X^{-}$完备匹配、$Y-$完备匹配和完备匹配肯定是最大匹配，反之不然，最大匹配不一定是$X-$完备匹配、$Y-$完备匹配或完备匹配。对于任意一个给定的二分图，其最大匹配总是存在，但其$X{-}$完备匹配、$Y-$完备匹配或完备匹配不一定存在。如果一个二分图存在完备匹配，则必有$|X|=|Y|$，反之不然。  
![图10-31  二分图及其最大匹配  ](images/426797d69400c6077f0021e199ce3acdf2169381fe7ee70516dbf26e96f0ac68.jpg)  
例如，对于图10-31（a）所示的二分图，图10-31（b）所示的全部实线边构成的集合：  
$$
M=\{(x_{1},y_{3}),(x_{2},y_{1}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
是该二分图的一个最大匹配。该匹配显然不是$X^{-}$完备匹配、$Y-$完备匹配或完备匹配，因为$x_{4}$和$y_{4}$均是其非饱和点。再如，图10-30（b）中实线边所示的匹配显然是一个完备匹配，自然也是最大匹配。  
下面考察对于一个给定的二分图$G=\langle X,E,Y\rangle$，当$G$满足什么条件时存在完备匹配。这里仅讨论$X^{-}$完备匹配的情形，至于$Y-$完备匹配和完备匹配的情况，可类似讨论。  
首先给出著名的霍尔婚姻定理，该定理给出了二分图$G=\langle X,E,Y\rangle$存在$X^{-}$完备匹配的一个充分必要条件，具体如下：  
【定理10.8】（霍尔婚姻定理）设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，则$G$存在$X^{-}$完备匹配的充分必要条件是$X$中任意$k$个结点至少与𝑌中$k$个结点相邻。具体地说，就是对于$\forall S\subseteq X$，有$|S|\leq|\mathsf{N}(\mathsf{S})|$，其中N(S)表示𝑌中所有与S中结点相邻的结点组成的集合。  
![图10-32  $X$-完备匹配存在性的判定](images/e5661ccfd2ab0df27e3feadf55016324a2bdd2f775f9de7183f592d16a209926.jpg)  
例如，图10-32（a）所示二分图满足霍尔婚姻定理的条件，故存在$X^{-}$完备匹配，图$10-$32（b）所示二分图不满足霍尔婚姻定理的条件，故不存在$X^{-}$完备匹配。  
定理10.8 中需要计算𝑋中所有子集在𝑌中邻接结点的集合，在很多情况下计算量很大，不便使用。为此，下面给出一个名为$t-$条件的充分条件，具体如下：  
【定理10.9】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，如果$G$满足：$X$中每个结点至少关联t-条边且𝑌中每个结点至多关联$t^{-}$条边，则图$G$一定存在$X^{-}$完备匹配。  
判断𝑡条件非常简单，只需计算$X$中结点最小度$\delta(X)$和$\Delta(Y)$中结点最大度$\Delta$即可。例如，对于图10-32（a）所示二分图，显然有$\delta(X)=\Delta(Y)=2=t$，故存在$X{-}$完备匹配。"
匹配问题,问题,"['第十章  特殊图模型与算法', '一、点着色与边着色', '三、结点着色算法', '10.3.3 着色问题与算法', '10.3.2 平面图的对偶图', '§ 10.2 二分图与匹配问题', '二、平面图的着色问题']","{'实体类型': ['问题', '算法'], '定义': ['与二分图具有密切联系的问题，包括完备匹配与最大匹配问题', '在图中寻找一组边，使得这些边没有公共端点，且数量最大化'], '应用': '在二分图中寻找最大匹配，即最多的边数，使得每条边连接的两个顶点不在同一个子集中'}",,2,在很多实际问题中需要表示和处理两类对象之间的联系，例如学生选课问题会涉及学生集合中元素与课程集合中元素之间的关系，工作任务安排问题会涉及员工集合中元素与任务集合中元素之间的关系，恋爱婚姻问题会涉及男性集合中元素与女性集合中元素之间的关系。可以使用一种名为二分图的特殊图模型表示和处理这类问题。二分图中的所有结点被划分为两种基本类型，同一类型的结点之间无边联结，图中每条边仅联结分属不同类型的结点，故能很好地表示和处理上述问题。本节主要介绍二分图模型的基本概念和性质，并讨论与其具有密切联系的完备匹配与最大匹配问题。
半哈密顿图,概念,"['第十章  特殊图模型与算法', '§ 10.1 欧拉图与哈密顿图', '10.1.2  哈密顿图及其性质']","{'实体类型': '概念', '定义': '存在哈密顿通路的图', '特点': '不包含哈密顿回路'}",,3,"与哥尼斯堡七桥问题类似，哈密顿图模型也是来源于一个有趣的实例。1856 年，著名的爱尔兰数学家哈密顿在给朋友的信中谈到一个关于如图10-13 所示十二面体的数学问题：把每个结点看成是一个城市，连接两个结点的边看成交通线，能否找到一条旅行线路，沿着交通线经过十二面体的全部20 个城市一次且仅一次，然后再回到原来的出发点？对于这个问题，哈密顿将如图10-13（a）所示十二面体展开成如图10-13（b）所示的图模型，并给出了如图10-12（c）所示的回路，哈密顿图和哈密顿回路由此得名。  
![图10-13 十二面体的数学问题  ](images/f9d9b1ce93d10109a19c31e0468e3a1ce9ead26e329e520a14ed719c39c74609.jpg)  
【定义10.2】经过图中每个结点一次且仅一次的通路称为哈密顿通路。经过图中每个结点一次且仅一次的回路称为哈密顿回路。存在哈密顿回路的图称为哈密顿图；存在哈密顿通路的图称为半哈密顿图。规定平凡图为哈密顿图。  
显然，哈密顿通路是经过图中所有结点的最短通路，即经过图中所有结点的基本通路。哈密顿回路是经过图中所有结点的最短回路，即经过图中所有结点的基本回路。事实上，哈密顿通路就是图中所有结点的一个全排列。  
![图 10-14  哈密顿图与非哈密顿图 ](images/428b9e316b5acee7d3001e928f0a06090173f2550480e12bbb7942d43098f612.jpg)  
例如，在图10-14 中，图$G_{1}$存在哈密顿通路，但是不存在哈密顿回路，故图$G_{1}$是半哈密顿图；图$G_{2}$存在哈密顿回路，故图$G_{2}$是哈密顿图；图$G_{3}$既不存在哈密顿通路，更不存在哈密顿回路，故图$G_{3}$既不是哈密顿图，更不是半哈密顿图。  
相比欧拉图，哈密顿图的研究要困难得多。因为对图中每个结点的遍历需要让每个结点都具有一定数量的边供遍历路径的选择，也是就说对每个结点的度有一定的数量要求，但是这种度的数量又与图模型的具体结构有非常密切且隐含关系。总的来说，就是要求图中结点的度数不能太少且分布比较均衡，但是又很难量化这种条件。因此，目前还没有找到能够直接判定一个图是哈密顿图的充分必要条件。首先给出哈密顿图的一个必要条件：  
【定理10.3】设无向图$G=\langle V,E\rangle$是哈密顿图，则对于𝑉的任意非空子集$.V_{1}$，均有：
$$
p(G-V_{1})\leq|V_{1}|
$$  
其中$p(G-V_{1})$是从图$G$中删除$\cdot V_{1}$后所得图的连通分支数。  
【推论10.2】设无向图$G=\langle V,E\rangle$是半哈密顿图，则$V_{1}$是𝑉的任意非空子集，均有：  
$$
p(G-V_{1})\leq|V_{1}|+1
$$  
定理10.3 和推论10.2 表明，在图中所有结点总度数确定的情况下，要使一个图模型为哈密顿图，就必须使得度数的分配比较均衡。因为如果图的度数集中分布到某一个或某几个结点，则删除这些结点后，会使得图中的边数大量减少，导致图的连通分支数目大量增加，即有 $p(G-V_{1})>|V_{1}|$ 或 $p(G-V_{1})>|V_{1}|+1$ ，此时就违背了上述定理或推论的条件。  
值得注意的是，定理10.3 和推论10.2 是必要而非充分条件。例如，对于图10-16 所示的彼得森图，该图显然满足定理10.3 的条件，但它不是哈密顿图。因此，定理10.3 和推论10.2 主要用于对哈密顿图的证伪。下面给出判定哈密顿图或者半哈密顿图的充分条件：  
【定理10.4】设图$G=\langle V,E\rangle$是任意给定的$n$阶无向简单图，如果对任意两个不相邻的结点$u,v\in V$，均有：  
$$
\deg(u)+\deg(v)\geq n-1
$$  
则图$G$中存在哈密顿通路。  
【定理10.5】（奥尔定理）设图$G=\langle V,E\rangle$是$n$阶无向简单图，如果对任意两个不相邻的结点$u,v\in V$，均有：  
$$
\deg(u)+\deg(v)\geq n
$$  
则图$G$中存在哈密顿回路。  
【定理10.6】（狄拉克定理）设图$G=\langle V,E\rangle$是$n$阶无向简单图，如果对于图中结点𝑣∈𝑉，均有$\deg(v)\geq n/2$ ，则图$G$中存在哈密顿回路。  
定理10.4、定理10.5 和定理10.6 给出了判定哈密顿图的充分条件，其中狄拉克定理可以看成是奥尔定理的一个推论。上述3 个定理表明，如果要使得一个图是哈密顿图，就必须保证图中有足够多的边并分布基本均衡，或者说图中每个结点都要关联足够多的边。不难看出，这些条件是比较强的或者说是比较苛刻的。事实上，这些条件并非必要条件。例如，一条具10 个结点的链显然是半哈密顿图，但该图并不满足定理10.4 的条件，将该链的首尾一条边相连构成的圈图显然是哈密顿图，但并不满足定理10.5 和定理10.6 的条件。"
半欧拉图,概念,"['第十章  特殊图模型与算法', '§ 10.1 欧拉图与哈密顿图', '10.1.1  欧拉图及其性质']","{'实体类型': '概念', '定义': '如果图中存在欧拉通路但不存在欧拉回路，则称之为半欧拉图', '判定条件': '无向图为连通图且恰有2个奇度数结点', '应用': '使用弗洛莱算法可以得到其欧拉通路'}",,3,"为更好地介绍欧拉图，有必要再回顾一下前述哥尼斯堡七桥问题：哥尼斯堡小镇有一条贯穿全市的小河，河上有两个小岛，由七座桥将这两个小岛及其与河两岸进行互联，如图$10-$1(a)所示。问题是怎样才能不重复、不遗漏地走完七座桥，并回到出发点。  
![图10-1 哥尼斯堡七桥问题 ](images/f92d2bafd1492d4ec26c4c92f27d5040f5974fc8bef369b51ff49b676bd82f86.jpg)  
瑞士著名的数学家欧拉把该问题抽象成如图10-1(b)所示的图模型，其中两岸陆地和小岛分别被抽象成了 A, B, C, D 四个结点， 每个桥分别被抽象成了连接相应结点的无向边。 于是， 哥尼斯堡七桥问题就等价于图10-1(b)中是否存在一条从图中任意结点出发，经过图中所有边一次且仅一次的回路。由此得到如下欧拉图的相关定义：  
【定义10.1】设 $G=\langle V,E\rangle$是任意给定的一个图模型，通过图𝐺中所有边一次且仅一次的通路称为欧拉通路，通过图$G$中所有边一次且仅一的回路称为欧拉回路。如果图𝐺中存在欧拉回路，则称之为欧拉图，如果$G$中存在欧拉通路但不存在欧拉回路，则称之为半欧拉图。 规定平凡图为欧拉图。  
以上定义既适合无向图也适合有向图。从定义可以看出，欧拉通路是经过图中所有边的通路中长度最短的通路；欧拉回路是经过图中所有边的回路中长度最短的回路。如果仅用边来描述，那么欧拉通路和欧拉回路其实都是图中所有边的一个全排列。  
【定理10.1】设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$是欧拉图当且仅当 $G=\langle V,E\rangle$为连通图且所有结点度数均为偶数。  
【  
【推论10.1】设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$是半欧拉图当  
且仅当 $G=\langle V,E\rangle$为连通图且恰有2 个奇度数结点。  
由推论10.1 可知，如果$G$是连通图且刚好有奇度结点，那么在$G$中存在一条欧拉道路，且一定以其中一个奇度结点为始点，以另一个奇度结点为终点。  
下面进一步给出有向欧拉图和半欧拉图的判定定理：  
【定理10.2】设 $G=\langle V,E\rangle$是任意给定的一个有向图模型，则有：$G=\langle V,E\rangle$是欧拉图当且仅当 $G=\langle V,E\rangle$为连通图且所有结点的入度等等于出度；$G=\langle V,E\rangle$是半欧拉图，当且仅当$G=\langle V,E\rangle$连通且仅有一个结点的入度比出度大1，另外一个结点的出度比入度大1，其余结点的入度等于出度。  
对于一个欧拉图或半欧拉图，可以使用弗洛莱算法自动找到其欧拉回路或欧拉通路。该算法的基本思路是首先从图中的任一点出发，随机去掉与此点相连的边，然后在保证以下两个条件的基础上，依次去掉与之相连的边：  
1）如果去掉某边后使得该边的某端点为孤立结点，则将该端点与该边一并去掉。  
2）在去掉某边后，不能造成图模型的不连通。  
当算法停止时，获得的路径$L=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\ldots e_{n}v_{n}(v_{0}=v_{n})$就是图$G=\langle V,E\rangle$的一条欧拉回路。弗洛莱算法的具体步骤如下：  
1) 首先，在结点集𝑉中任选一个结点$v_{0}$为初始结点，并设初始通路为$L_{0}=v_{0}$。 2) 设已选好的简单通路为$\boldsymbol{\cdot}L_{i}=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\ldots e_{i}v_{i}$，按照下列条件从边集合：  
$$
E-\{e_{1},e_{2},e_{3},\ldots,e_{i}\}
$$  
中选取边]${e}_{i+1}$，其中$G_{1}$是从$G$删除边集合$\{e_{1},e_{2},e_{3},\ldots,e_{i}\}.$后得到的图：  
$\bullet$ 结点$v_{i}$是边$\boldsymbol{\cdot}\boldsymbol{e}_{i+1}$的端点。  
$\bullet$ 除非无其他边可以选取，否则删除边$\boldsymbol{\cdot}\boldsymbol{e}_{i+1}$后不改变图$G_{1}$的连通性。  
3）将$e_{i+1}v_{i+1}$加入到$L_{i}$中，形成新路径$\mathopen:L_{i+1}=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\dots e_{i}v_{i}e_{i+1}v_{i+1}$，令$i=i+1$  
4）返回步骤2）重复上述过程，直到 $i=|E|$ 。  
当图模型是一个半欧拉图时候，使用上述弗洛莱算法显然也可得到其欧拉通路，请读者自己思考算法的具体步骤和要点，不再赘述。  
![图10-10 房间布局的设计图     图10-11 图模型与欧拉通路       图10-12 行走路径 ](images/1200dfbb0792a6069379408b8f0f3304dd4b6248c5b1e2f4c4917b8d0bf94d23.jpg)"
半群,概念,"['§ 12.1 半群的概念与性质', '12.1.2  方幂与循环半群', '第十二章 典型抽象代数结构', '12.1.1 半群与含幺半群']","{'实体类型': '概念', '基本知识': '半群的概念与性质', '定义': ['一种比较简单而基本的抽象代数结构，要求其载体上的二元运算满足封闭性和结合律，比广群稍微特殊一些，即在广群的基础上增加一个满足结合律的限制', '满足结合律的代数结构'], '特点': '只含一个二元运算，运算满足封闭性和结合律', '性质': '对载体集合中任意元素进行多次重复运算，结果与运算次序无关', '示例': ['⟨R, +⟩', '⟨R, ×⟩', '⟨P(A), ∪⟩', '⟨P(A), ∩⟩', '⟨A^A, ∘⟩', '⟨M_n(R), +⟩', '⟨M_n(R), ⋅⟩']}",,1,"如前所述，代数结构作为四大数学结构之一，主要研究给定集合上的运算及运算性质。现实世界中的集合和运算种类繁多，不可能通过枚举方法一一进行研究。因此，代数结构主要以抽象集合和抽象运算为其研究对象，考察抽象元素在抽象运算上的一般运算性质，即结合律、交换律、幂等律、消去律、分配律和吸收律这六大二元算律，以及幺元、零元、逆元、幂等元、消去元这五个特殊元素的存在性。当然，不同的具体代数结构对这些运算性质的满足程度也会有所差异。因此，可以这些运算性质为标准对所有的代数结构进行分类，并抽象出一些特殊的代数结构。事实上，前面我们对关系模型的研究也是这样做的：首先给出关系的自反性、反自反性、对称性、反对称性和传递性这五个基本性质，然后就以这五个基本性质为标准考察各个具体的关系模型，并抽象出一些典型的抽象关系模型，例如满足自反性、对称性和传递性的关系为等价关系，满足自反性、对称性的关系为相容关系，满足自反性、反对称性和传递性的关系为偏序关系等。同样，以二元算律和特殊元素为标准也可抽象出很多典型的抽象代数结构，如群、环、域、格等代数结构。  
对这些典型抽象代数结构的分析和讨论是抽象代数领域的主要研究内容。其中群结构由法国天才少年伽罗瓦提出的伽罗瓦群衍生而成，是最早发明也是最重要一种抽象代数结构，不仅在数字加密与编码、形式语言与自动机、组合计算与分析等领域有着非常重要的应用价值，而且关于群的研究方法和思维方式对抽象代数其它分支的研究具有非常重要的影响。如果能够较好地掌握群结构的基本理论和基本方法，则学好环、域、格等其它典型抽象代数就不是一件难事。因此，本章着重考察群结构的基本理论并给出环、域、格的基本知识，具体包括半群的概念与性质、群结构的基本知识、群的同余关系与商群、环与域基本概念与性质、格的基本概念与性质。"
单位元,概念,"['11.2.2 特殊元素', '§ 11.2 代数结构的运算性质', '12.2.1 群的基本概念', '第十二章 典型抽象代数结构', '§ 12.2 群结构的基本知识', '第十一章  抽象代数结构通论']","{'实体类型': '概念', '定义': ['与任意运算对象运算结果仍为该运算对象的元素', '在群⟨G,*⟩中，存在e∈G，使得对于∀x∈G，成立e*x=x*e=x'], '例子': '实数0（加法）、实数1（乘法）、零矩阵（矩阵加法）、单位矩阵（矩阵乘法）、全集U（集合交）、空集∅（集合并）、恒等函数（复合运算）', 'name': '单位元'}",,3,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)"
单向分图,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.4 有向图的连通性']","{'实体类型': '概念', '定义': '有向图的子图是单向连通的，并且不存在更大的单向连通子图'}",,3,"现在讨论有向图的连通性。与无向图不同的是，有向图中的每条边都具有方向性，结点之间的可达性关系不一定满足对称性。因此，有向图的连通性质比无向图更加复杂，一般要分为强连通、单向连通和弱连通这三种基本情况讨论，其具体定义如下：  
【定义8.30】假设$G=\langle V,E\rangle$任意给定的一个有向图，则有：如果图 $G$中任意两个结点之间都是相互可达的，则称 $G$ 是强连通图；如果图 $G$ 中任意两个结点中至少有一个结点到另一个结点可达，则称 $G$ 是单向连通图，简称为单连通图；对于略去图 $G$ 中各边的方向得到的无向图 $G^{\prime}$，如果 $G^{\prime}$ 是无向连通图，则称 $G$ 是弱连通图，简称为连通图。  
从上述定义可以看出，在没有特别说明的情况下，连通的有向图一般意指为弱连通的有向图。显然，如果一个有向图 $G$ 是强连通的，那么它一定是单连通的，反之不然；如果一个有向图 $G$ 是单向连通图的，那么它一定是弱连通的，反之不然。  
例如，图8-47 所示的三个图模型$G_{1}$, $G_{2}$和$G_{3}$分别是强连通图，单连通图和弱连通图。其中$G_{1}$既是强连通图也是单连通图，$G_{2}$是单连通图也是弱连通图。  
![图8-47 强连通图、单向连通图、弱连通图  ](images/bb31206be85b6681e4bfdebf210d613d4577ab233c09b6ccf50f1f6eb3389294.jpg)  
【定理8.9】（连通性定理）有向图 $G$ 是强连通图的充要条件是存在一条经过图$G$所有结点的回路；有向图 $G$ 是单连通图的充要条件是存在一条经过图𝐺所有结点的通路。  
类似于无向图的连通分支的概念，可分别根据有向图的强连通、单向连通、弱连通概念定义相应的连通分支，得到强分图、单向分图、弱分图的概念，具体定义如下：  
【定义8.31】假设$G=\langle V,E\rangle$任意给定的一个有向图，设 $G^{\prime}$是 $G$ 的一个子图，如果$G^{\prime}$是强连通的（单向连通的、弱连通的），并且对 $\forall G^{\prime\prime}\subseteq G$，若$G^{\prime}\subset G^{\prime\prime}$，则 $G^{\prime\prime}$不是强连通的（单向连通的、弱连通的），则称 $G^{\prime}$ 为 $G$ 的强连通分支（单向连通分支、弱连通分支），简称为强分图（单分图、弱分图）。  
显然，强分图、单分图、弱分图都是 $G$ 的子图，可以用结点集合𝑉的子集导出。显然，强分图是单分图和弱分图，单分图一定是弱分图，但是为了强调它们之间的差异性，一般不再将强分图称为单分图或弱分图，也不再将单分图称为弱分图。  
从上述定义及例题不难看出，可分别通过强分图、单分图、弱分图的概念对有向图中所有结点进行分组。具体地说：  
（1）对于由强连通关系产生的强分图，由于有向图结点之间的强连通关系显然满足自反性、对称性和传递性，因此这种强连通关系是一种等价关系，从而可由此等价关系实现对图中所有结点的划分。显然，每个强分图其实就是一个等价类或者划分块，图中所有的强分图就是构成了所有的划分块。 因此，有向图的任何一个结点属于且仅属于一个强分图。  
（2）对于由弱连通关系产生的弱分图，可类似于无向图的方法进行讨论。事实上，不难看出，弱分图其实就是有向图所导出无向图中的连通分支。因此，所有的弱分图也构成了有向图中所有结点的一种划分，有向图的任何一个结点属于且仅属于一个若分图。  
（3）对于由单向连通关系产生的单分图，不难证明，有向图结点之间的单连通关系满足自反性、对称性，但不满足传递性，因而是一种相容关系。可由此相容关系实现对图中所有结点的最大覆盖。显然，每个强分图其实就是一个最大相容类，图中所有的单分图就是构成了所有的最大相容类。因此，有向图的任何一个结点至少属于一个强分图。  
类似地，可分别通过强分图、单分图、弱分图的概念对有向图中所有边进行分组。 不难发现：对于任何一个给定的有向图，它的每条边至多属于一个其强分图，至少属于一个其单分图，属于且仅属于一个其弱分图。  
例如，对于例题8.30 中的强分图、单分图和弱分图，不难看出它们均满足上述所有关于结点和边分组性质。"
单向连通图,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.4 有向图的连通性']","{'实体类型': '概念', '定义': '有向图中任意两个结点中至少有一个结点到另一个结点可达的图'}",,3,"现在讨论有向图的连通性。与无向图不同的是，有向图中的每条边都具有方向性，结点之间的可达性关系不一定满足对称性。因此，有向图的连通性质比无向图更加复杂，一般要分为强连通、单向连通和弱连通这三种基本情况讨论，其具体定义如下：  
【定义8.30】假设$G=\langle V,E\rangle$任意给定的一个有向图，则有：如果图 $G$中任意两个结点之间都是相互可达的，则称 $G$ 是强连通图；如果图 $G$ 中任意两个结点中至少有一个结点到另一个结点可达，则称 $G$ 是单向连通图，简称为单连通图；对于略去图 $G$ 中各边的方向得到的无向图 $G^{\prime}$，如果 $G^{\prime}$ 是无向连通图，则称 $G$ 是弱连通图，简称为连通图。  
从上述定义可以看出，在没有特别说明的情况下，连通的有向图一般意指为弱连通的有向图。显然，如果一个有向图 $G$ 是强连通的，那么它一定是单连通的，反之不然；如果一个有向图 $G$ 是单向连通图的，那么它一定是弱连通的，反之不然。  
例如，图8-47 所示的三个图模型$G_{1}$, $G_{2}$和$G_{3}$分别是强连通图，单连通图和弱连通图。其中$G_{1}$既是强连通图也是单连通图，$G_{2}$是单连通图也是弱连通图。  
![图8-47 强连通图、单向连通图、弱连通图  ](images/bb31206be85b6681e4bfdebf210d613d4577ab233c09b6ccf50f1f6eb3389294.jpg)  
【定理8.9】（连通性定理）有向图 $G$ 是强连通图的充要条件是存在一条经过图$G$所有结点的回路；有向图 $G$ 是单连通图的充要条件是存在一条经过图𝐺所有结点的通路。  
类似于无向图的连通分支的概念，可分别根据有向图的强连通、单向连通、弱连通概念定义相应的连通分支，得到强分图、单向分图、弱分图的概念，具体定义如下：  
【定义8.31】假设$G=\langle V,E\rangle$任意给定的一个有向图，设 $G^{\prime}$是 $G$ 的一个子图，如果$G^{\prime}$是强连通的（单向连通的、弱连通的），并且对 $\forall G^{\prime\prime}\subseteq G$，若$G^{\prime}\subset G^{\prime\prime}$，则 $G^{\prime\prime}$不是强连通的（单向连通的、弱连通的），则称 $G^{\prime}$ 为 $G$ 的强连通分支（单向连通分支、弱连通分支），简称为强分图（单分图、弱分图）。  
显然，强分图、单分图、弱分图都是 $G$ 的子图，可以用结点集合𝑉的子集导出。显然，强分图是单分图和弱分图，单分图一定是弱分图，但是为了强调它们之间的差异性，一般不再将强分图称为单分图或弱分图，也不再将单分图称为弱分图。  
从上述定义及例题不难看出，可分别通过强分图、单分图、弱分图的概念对有向图中所有结点进行分组。具体地说：  
（1）对于由强连通关系产生的强分图，由于有向图结点之间的强连通关系显然满足自反性、对称性和传递性，因此这种强连通关系是一种等价关系，从而可由此等价关系实现对图中所有结点的划分。显然，每个强分图其实就是一个等价类或者划分块，图中所有的强分图就是构成了所有的划分块。 因此，有向图的任何一个结点属于且仅属于一个强分图。  
（2）对于由弱连通关系产生的弱分图，可类似于无向图的方法进行讨论。事实上，不难看出，弱分图其实就是有向图所导出无向图中的连通分支。因此，所有的弱分图也构成了有向图中所有结点的一种划分，有向图的任何一个结点属于且仅属于一个若分图。  
（3）对于由单向连通关系产生的单分图，不难证明，有向图结点之间的单连通关系满足自反性、对称性，但不满足传递性，因而是一种相容关系。可由此相容关系实现对图中所有结点的最大覆盖。显然，每个强分图其实就是一个最大相容类，图中所有的单分图就是构成了所有的最大相容类。因此，有向图的任何一个结点至少属于一个强分图。  
类似地，可分别通过强分图、单分图、弱分图的概念对有向图中所有边进行分组。 不难发现：对于任何一个给定的有向图，它的每条边至多属于一个其强分图，至少属于一个其单分图，属于且仅属于一个其弱分图。  
例如，对于例题8.30 中的强分图、单分图和弱分图，不难看出它们均满足上述所有关于结点和边分组性质。"
单射函数,概念,"['第七章 函数与特殊函数', '§ 7.1 函数的基本概念', '7.1.2 函数的基本类型']","{'实体类型': '概念', '定义': '若f的不同自变量映射到不同的像，则称f为A到B的单射函数', '条件': '对任意的x1,x2∈A，如果x1≠x2，那么f(x1)≠f(x2)'}",,3,"从本质上讲，从集合$𝐴$到集合$B$的函数描述的是$𝐴$中元素与$𝐵$中元素之间的一种特殊对应关系，这种特殊对应关系可以是一对一的也可以是多对一的，但不能是一对多或多对多的关系。这是函数对应关系与一般对应关系的主要差别。此外，函数值域可以是$B$的某个真子集，也可以是$B$自身。根据以上讨论，就可将所有函数分成如下四种不同的基本类型，即是单射但不是满射的函数、是满射但不是单射的函数、既是单射又是满射的函数、既不是单射也不是满射的函数。本节主要讨论这四种函数，首先给出单射函数和满射函数的定义：  
【定义7.5】设$f$从集合$𝐴$到集合$ B$的函数：  
（1）若$f$的不同自变量映射到不同的像，则称$f$为为$𝐴$到$B$的单射函数,简称为单射。也就是说，对任意的$x_{1},x_{2}\in A$，如果$x_{1}\neq x_{2}$，那么$f(x_{1})\neq f(x_{2})$，则称$f$为$𝐴$到$B$的单射。  
（2）如果集合$ B$中的每个元素都有原像，则称$f$为$𝐴$到$B$的满射函数，简称为满射；也就是说，如果$f$的值域等于$B$，即有$𝑟𝑎𝑛$ $f=B$，则称${f}$为$𝐴$到$B$的满射。  
（3）若$f$是满射且是单射，则称$f$为$𝐴$到$B$的双射；若$A=B$，则称${f}$为$𝐴$上的函数；当$𝐴$上的函数$f$是双射时，则称$f$为$𝐴$上的一个变换。  
可依据上述定义判断函数$f\colon A\to B$是否为满射、单射、双射。判断满射就是检查$B$中的每个元素是否都是函数值。如果在$B$中找到不是函数值的元素，那么$f$就不是满射的。判断单射的方法就是检查不同的自变量是否对应于不同的函数值。  
由定义7.2 和例7.1.7 可看出，若$ f$是从有限集$𝐴$到有限集$B$的函数，则$f$是单射的必要条件是$|A|\leq|B|$；$f$是满射的必要条件是$|A|\geq|B|$；$f$是双射的必要条件是$|A|=|B|$。此外，当$A$ 和$B$ 是基数相同的有限集合时，还有以下结论：  
【定理7.3】设$𝐴$，$B$是有限集合且$|A|=|B|$。如果$f$是一个从$A$到$B$的单射函数，则$f$必然是从𝐴到$B$的满射函数，反之亦然。"
单源最短路径算法,算法,"['8.4.3 单源最短路径', '第八章  图的基本理论与算法', '§ 8.2 图的运算与结构']","{'实体类型': '算法', '应用': '找到从一个结点到另一个结点的最短路径', '定义': '一个结点到其他所有剩余结点的最短路径算法', '代表算法': '迪杰斯特拉算法', 'name': '单源最短路径算法'}",,1,"若用点表示现实世界中事物、点之间连线表示事物之间联系，则可画出一个图来形象地表达问题模型。事实上，若将思维浓缩，图是最简洁的思维轨迹；若将思维展开，图能描述最复杂的思维蓝本。因此，人类在很久以前就开始用图的方法记忆、分析和解决问题。然而，如果只停留在对一些具体图的讨论，那么人类就永远走不出经验主义的局限。幸运的是，十八世纪著名数学家欧拉创造性地将具体问题抽象为图模型，建立一套关于图的数学理论——图论，使图模型成为一种非常有效且非常有趣的数学工具，实现了形象思维与抽象思维的完美结合、理论性与实用性的完美结合。图模型作为一种特殊的二元关系，诠释了复杂的多对多关系，揭示了各结点之间错综复杂的网状拓扑结构，具有强大的知识表达能力。正是这种强大的表达能力使得图模型在解决诸多复杂问题中发挥至关重要、不可替代的作用。在计算机诞生之前，图模型主要用于解决一些游戏问题，例如迷宫问题、博弈问题、棋盘马经问题等等。随着计算机的诞生与兴起，图模型作为一种最基本的离散数学结构在计算机各个领域得到广泛应用，例如计算机网络路由问题、送快递最短路径问题、网站之间链接模型问题、工程预算关键路径问题、软件代码复杂度计算问题等等，都需要使用图论知识进行问题表示和求解。目前，图论及其算法已经成为计算机专业人员必须熟练掌握的一项基本知识。  
对于图这种基于连接策略的模型，自然会让人产生很多疑问，例如如何在计算机中实现这些图模型的表示和运算、沿着这些连接如何自动找到合适的路径从一个结点到达另外一个结点、能否自动计算出符合要求路径的个数、能否自动找到结点之间最短的连接路径、如何对图的结点或边进行自动遍历、如何通过图模型对实际问题建模等等。本章目标主要是通过系统地介绍和讨论图模型及其算法设计的基本知识，使得读者不仅能够找到上述问题的答案，而且能够较好地掌握图的基本理论及相关算法设计技术。本节首先学习图的概念与表示、图的运算与性质以及图的连通性质；然后介绍若干经典的图模型算法，包括图的遍历算法、单源和多源最短路径算法等；最后介绍图模型的应用。"
博弈,概念,"['第九章  树的基本理论与算法', '§ 9.4 树模型的应用', '9.4.2 轮流摸牌问题']","{'实体类型': '概念', '定义': '一类竞争性的活动，对垒的双方轮流采取行动，结果有胜、败、平局', '特点': '双方了解当前格局及历史，进行得失分析，选取有利对策'}",,3,"生活中，下棋、打牌、竞技等一类竞争性的活动称为博弈。对垒的双方轮流采取行动，博弈的结果仅有三种：胜、败、平局。在对垒过程中，任何一方都了解当前的格局及过去的历史。任何一方在采取行动前都要根据当前的实际情况，进行得失分析，选取对自己有利而对对方最为不利的对策，不存在掷骰子之类的破运气因素，双方必须很明智的决定自己的行为。轮流摸牌问题，作为一种经典的博奕类游戏，问题的具体描述如下：  
桌上有𝑀堆扑克牌，每堆牌的数量分别为$N_{i}(i=1,2,\dots,M)$。现有两个选手，分别记为先手和后手，轮流进行摸牌，每一次摸牌可以任意选择一堆并取走其中的任意张牌，规定每次至少取一张，多者不限；桌上的扑克牌全部取光，则游戏结束，那么最后一次摸牌的选手即为胜者。现在问题如下：先手如果想赢，第一步有几种选择?  
轮流摸牌问题可以采用博弈树解决。博弈树是一种特殊的树模型，它的每个结点表示游戏进行时的一种局面，用每条边表示这些局面之间合乎规则的演变或移动。博弈树通常比较庞大，通常需要对其进行化简才能高效地使用。  
图9-58 所示为初始的三堆扑克牌数量。第一堆和第二堆的扑克牌数量都为3 张，第三 堆扑克牌的数量为1 张，组成了初始状态(3，3，1)。  
![图9-57  大小排序决策树 ](images/f1b07d5e01fd3916fd51d458c21160476d888d5cdc01f2f4b52f54e88d66df57.jpg)  
![图9-58 三堆扑克牌  ](images/785c75f0b4653bbc64b450a41c28647f0642a850ef357c53771601a74297ee17.jpg)  
图9-58 所示的博弈树表示轮流摸扑克牌游戏在给定初始状态（3，3，1）扩展下的所 有对弈策略。用不同堆中扑克牌数组成的无序序列表示每个局面（堆的顺序无关紧要）。先手第一次可以从有3 张扑克牌的堆中摸1 张牌（剩下包含3 张、2 张、1 张扑克牌的3堆）；也可以从有3 张扑克牌的堆中取3 张（剩下包含3 张、1 张扑克牌的2 堆）；也可以从有1 张扑克牌的堆中取1 张（剩下包含3 张扑克牌的2 堆）。当扑克牌被最后一个选手取完了，下一个选手就无法再继续摸牌，这样的局面就是终局。轮流摸扑克牌游戏是非胜即负的游戏，规定用$F$ 标记表示先手获胜，用$L$ 标记表示后手获胜。  
![图9-59 轮流取扑克牌游戏的博弈树 ](images/3e2c6b2d2a79242f7f10f5a0e2d1714f56d6c5d793d99a4f5932038bcf4cd8fa.jpg)  
根据图9-59，我们可以发现，先手如果想必赢，第一步只有一种选择，即只能从有1 张扑克牌的堆中取1 张，而不能从其它堆中摸扑克牌。  
进一步对图9-59 进行分析，可知：  
1）状态（3，3，1）必胜点，那么先手取完棋子后，后手必落在必败点；  
2）若初始状态下，只有一堆扑克牌，先手必胜； 3）若有$𝑀$堆扑克牌，每堆只有一张扑克牌，$M$为奇数时，先手必胜；  
4）若有𝑀堆扑克牌，每堆只有$k$张扑克牌，$M$为奇数时，先手必胜；  
5）先手摸𝑘张扑克牌，轮到对手时，若对手取$𝑘$张，则先手也取$𝑘$张；若对手取$x<k$张，则先手也取另外一堆的$𝑥$张。因为剩下的是偶数堆，则先手也取$𝑘$张扑克牌，总能将剩下的堆变成若干个两两相等的堆。只要始终保持这种取法，先手总能取到最后的扑克牌。  
可以将上述局面推广至一般：若某个初始局面为先手必胜，那么每走一步都必须使后首落在必败点。因此对于每一个局面，要么为胜局面，要么为负局面。用非0 表示表示胜局面，0 表示负局面。对于某一个局面，若为非0 局面，它的任务就是要寻找某一种取法，使局面变为 0  局面。那么其对手无论怎么取，都会使局面又变为 0  局面。  
那么这种对弈有什么规律呢？  
如果一个局面为先手必胜，就称这为$N$局面；反之称之为$ P$局面。对于一个局面，令$S=$$P_{1}\oplus P_{2}\oplus\ldots\oplus P_{n}$。若$S=0$则为$ P$局面，否则就为$ N$局面（⊕为异或）。  
对于图9-4-5，我们将3 堆扑克牌数异或，即$3{\oplus}3{\oplus}1{=}011{\oplus}011{\oplus}001{=}1$，异或结果为非0，那么先手将赢得这局游戏。因此先手第一步需要从第三堆中摸一张扑克牌。  
下面我们考虑下4 堆扑克牌对弈策略。其中各堆的大小分别为4，5，9，15。用二进制表示各数分别为0100，0101，1001，1111。表4-1 为各堆数量对应的二进制数。  
将这四堆扑克牌数进行异或，得到0100⊕0101⊕1001⊕1111=0111。结果非0，那么先手会赢。因此先手可以从大小为4 的堆中取走1 张牌剩下3 张，后者从大小为5 的堆中取走 3  张牌剩下 2  张，再或者从大小为 15  的堆中取走 7  张牌剩下 8  张。  
轮流摸扑克牌游戏为典型的尼姆博弈问题。尼姆博弈的关键在于游戏开始时游戏处于何种状态（平衡或非平衡）和先手是否能够按照取子游戏的获胜策略来进行游戏。  
![表9-1  各堆数量对应的二进制数 ](images/621116a8789d5d8ecab422f6290df5764c10b51f7ad37caba7ad4b05a6de41e9.jpg)  
实际生活中还有许多有益的博弈，比如一字棋、国际象棋和方棋格等等。此外，这种博弈的方法已经应用到很多的计算机程序研究中。某些博弈程序都能做到与人类选手进行对决，比如国际象棋等，可以看到如何将树应用到博弈策略的研究中具有重要的现实意义.有关博弈策略的更多内容，读者可以查阅相关资料进一步学习，这里不再赘述。"
博弈树,应用实例,"['第九章  树的基本理论与算法', '§ 9.4 树模型的应用', '9.4.2 轮流摸牌问题']","{'实体类型': ['应用实例', '模型'], '相关模型': '树模型的应用', '定义': '表示游戏局面的特殊树模型，节点表示局面，边表示局面间的演变', '应用': '分析博弈策略，化简后高效使用', 'name': '博弈树'}",,1,"树是大家非常熟悉的一类植物。通过对树的观察，不难发现自然界中的树总是有根、枝和叶，且具有这样一些特点：从根上可以长出枝来，从树杈上可以长出枝或叶，叶梢不长在一起，根、枝、叶之间总是畅通的，但它们之间不能构成圈。从结构上看，树是所有连通无向图中边数最少的图模型，同时也是所有无环无向图中边数最多的图模型。我们不得不惊叹大自然的神奇，竟然创造出如此高效而又和谐的离散结构。对自然界中树的这种特殊离散结构进行抽象，就可得到一种特殊的图模型，即树模型。在所有的图模型中，树模型是一种最简洁的连通无环结构，其中各结点之间有着最直接、最必要的联结关系。这种最简洁的连通结构决定了树在图模型知识体系中占有特别重要的地位。目前，树作为一种特殊图模型已被广泛应用于计算机各个领域，例如操作系统采用树结构来组织文件数据，编译程序采用树表示源程序的语法结构，在数据库系统中树被用来组织信息等等。  
本章主要介绍树模型基本理论及其算法设计的基本知识，首先介绍树模型的基本概念与性质、生成树与最小生成树等关于树模型的基本理论，然后具体讨论根树的概念与算法，包括树的递归遍历算法、森林与树的转换算法、最优树的构造与编码算法等，并在此基础上进一步学习若干典型特殊树模型及其基本算法，包括平衡树、红黑树、$B$树等，最后给出树模型的若干应用实例，包括决策树、博弈树等。"
原子,概念,"['第十二章 典型抽象代数结构', '§ 12.6 布尔代数基础', '12.6.2 布尔同态与同构']","{'实体类型': '概念', '定义': '在布尔代数中，非零元素a若满足对任意x，x*a=a或x*a=0，则称a为原子或极小元', '特点': '除去最小元0外，不会有任何一个元素比原子小'}",,3,"将代数系统中同态和同构的概念应用于布尔代数，可定义如下布尔同态与同构：  
【定义12.36】设$\langle B_{1},*,\oplus,^{-},0,1\rangle$和$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$是任意给定的两个布尔代数，如果存在一个从$B_{1}$到$B_{2}$的映射$\psi$: $B_{1}\rightarrow B_{2}$，对$\forall a,b\in L,$，$\psi$满足：  
$\begin{aligned}\psi(a*b)&=\psi(a)\circ\psi(b); \psi(a\oplus b)=\psi(a)\circledast\psi(b);\\\psi(\bar{a})&=\triangle \psi(a); \psi(0)=\alpha; \psi(1)=\beta\end{aligned}$  
则称映射$\psi$是从$\langle B_{1},*,\oplus, ^{-},0,1\rangle$到$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$的一个同态映射，并称$\langle B_{1},*,\oplus, ^{-},0,1\rangle$与$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$为布尔同态。若$\psi$是双射，则称$\psi$是从$\langle B_{1},*,\oplus, ^{-},0,1\rangle$到$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$的一个同构映射，并称$\langle B_{1},*,\oplus, ^{-},0,1\rangle$与$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$为布尔同构。  
有时难以直接讨论或研究某个比较复杂或抽象的布尔代数系统，若能找到一个与之同构的具体布尔代数系统进行研究，就会带来很多方便，例如，如果某个布尔代数和集合代数同构，则可将集合代数作为具体研究对象，从而大大简化对该布尔代数的研究。  
为了给出一个比较重要的关于布尔同构的定理，下面定义一个所谓原子的概念：  
【定义12.37】设$\langle B,*,\oplus, ^{-},0,1\rangle$是任意给定的一个布尔代数，对于$\forall a\in B$且$a\neq0$，如果对于$\forall x\in B$，满足$x*a=a$或$x*a=0$，则称$^{}a$是$\langle B,*,\oplus, ^{-},0,1\rangle$的一个原子或极小元。  
在定义中$a\neq0$表示$a$不是$B$中的最小元，而且对$B$中任一元素${x}$，要么$x$比$a$大，要么$x$和$a$不可比。简言之，除去最小元0 外，不会有任何一个元素$x$比$a$小。下面的例题12.6.7 表明，对于任意给定的一个布尔代数，可能会有多个原子。  
例如，在图12-12（a）中，$b$是最小元，唯一的原子是$a$，同时也是最大元。在图12-12（b）中，$a_{4}$是最小元，$a_{2}$和$a_{3}$都是原子，$a_{1}$是最大元但不是原子。在图12-12（c）中，$b_{8}$是最小元，$b_{5}$，$b_{6}$，$b_{7}$是原子，而$b_{1}$，$b_{2}$，$b_{3}$，$b_{4}$都不是原子。  
![](images/543436e369e6162cc7d12db06777b18d401f37573a58bcd4b6f824c830035b69.jpg)  
图12-12  布尔代数的原子  
基于原子的概念，可以得到如下关于布尔同构的斯通定理：  
【定理12.41】（斯通定理）设$\langle B,*,\oplus,^{-},0,1\rangle$是有限布尔代数，集合$𝑆$是$B$中所有原子构成的集合，那么$\langle B,*,\oplus,^{-},0,1\rangle$和$\langle P(S),\subseteq,\cap,\cup,^{-},\emptyset,S\rangle$同构。"
原子命题,概念,"['第三章  命题演算与推理', '§ 3.1 命题的概念与运算', '3.1.2  命题的基本概念']","{'实体类型': '概念', '定义': '不能再分解为更加简单的陈述句的命题'}",,3,"命题逻辑以命题作为最基本的处理对象。因此，学习命题逻辑首先必须掌握命题的基本概念。事实上，命题的概念与集合的概念一样，是一个没有严格定义的原始概念，其内涵是不言自明的。我们只能对命题的概念进行描述或解释：  
所谓命题，就是具有确切真假含义且能做出判断的陈述句。当判断正确或者符合客观实际时，命题表达的内容为真或者说命题的取值为真，并称该命题为真命题；否则命题表达的内容为假或者说命题的取值为假，并称该命题为假命题。命题或真或假的取值，称为命题的真值。通常用 $T$或1 表示取值为真的真值，用 $F$ 或0 表示取值为假的真值。  
根据上述关于命题概念的解释，可以看出：  
（1）命题主要用于逻辑思维中的是非判断，因此必须是陈述语句。其它类型的语句，例如感叹句、祈使句、疑问句等，都不能用于是非判断，故不能作为命题。  
（2）对于任何一个给定的命题，必有唯一确定的真值，要么取真、要么取假，不能既真又假，也不能既不真也不假。因此，具有二义性的陈述句不能作为命题。  
【定义3.1】对于任意一个给定的命题，当它不能再分解为更加简单的陈述句时，则称该命题为原子命题；否则，称之为复合命题。  
由上述定义可知，所有命题分为原子命题和复合命题这两种基本类型。例如，命题“合肥是安徽的省会”就是一个不能再分解的原子命题，而命题“安徽不是一个国家”则是一个复合命题，由“安徽是一个国家”这个原子命题生成。  
通常用带下标或不带下标的大写英文字母 $A,B,C,\ldots,P,Q,R,\ldots$… 表示命题，并称之为命题标识符。在命题逻辑系统中，对命题标识符的解释不允许有二义性。也就是说，对于任一确定的具体场合，各个标识符所表达的含义是唯一确定的。"
原子谓词公式,概念,"['第四章  谓词演算与推理', '§ 4.2  谓词公式与等值演算', '4.2.1 谓词公式的概念']","{'实体类型': '概念', '定义': '设P(x1, x2, ..., xn)是n元谓词公式，t1, t2, ..., tn是个体项，则称P(t1, t2, ..., tn)为谓词演算的原子公式'}",,3,"类似于命题逻辑，谓词逻辑采用谓词公式的方式实现对谓词符号的表达。但谓词公式的定义比命题公式更加复杂，因为谓词公式的表达要深入到概念层次，需要用到更多种类的特殊符号来表达命题在概念层次上的各种组件。具体地说，除了前述两种量词符号之外，还有四种特殊符号，即：表示个体的个体常量符号、个体变量符号、个体函数符号，以及表示谓词的谓词符号。这四种符号的表达方式如下：  
（1）个体常量符号：用带或不带下标的小写英文字母$a,b,c,\cdots$表示个体常量。  
（2）个体变量符号：用带或不带下标的小写英文字母$x,y,z,$…表示个体变量。  
（3）个体函数符号：用带或不带下标的小写英文字母$f,\,g,\,h,\cdots$表示个体函数。所谓个体函数，就是个体与个体之间的映射关系。  
（4）谓词符号：用带或不带下标的大写英文字母$P,Q,R,\cdots$表示谓词。  
个体函数表示谓词逻辑中个体与个体之间的映射关系。例如，对于命题：小张的爸爸是教授。如果设立如下谓词和个体函数：  
$P(x)$:$x$是教授；$f(x)$:$x$的爸爸  
则该命题的谓词式可表示为：$P(f(x))$  
个体函数的使用为谓词逻辑中个体之间映射关系的表达带来了很大的方便，大大提升了谓词逻辑符号系统的表达能力。基于个体函数，可按如下方式定义一个称之为个体项的概念来专门表达谓词逻辑中的个体之间复杂的映射关系：  
【定义4.9】谓词逻辑中的个体项，被递归地定义为：  
（1）个体常量符号是个体项；  
（2）个体变量符号是个体项；  
（3）若$f(x_{1}\,,\ x_{2}\,,\ \ \dots\,,\ x_{n})$是$.n$元函数，$t_{1}$，$t_{2}$，… ，$t_{n}$是个体项，则$f(t_{1}\,,\,\,\,t_{2}\,,\,\,\,\dots\,,\,\,\,t_{n})$是个体项；  
（4）所有个体项都是有限次使用(1)，(2)，(3)生成的符号串。  
由定义可知，个体项具有非常强大的表达能力，能有效地表达个体以及个体之间的复杂的映射关系，谓词中的个体常量、个体变量和个体函数都可以统一用个体项的概念进行表达。例如复合函数$f(g(x,y),\ h(a,g(x,y),z))$都是个体项；再如，令$f(x)$表示“$x$ 的叔叔”；$P(x)$表示“$x$ 是医生”；$c$ 表示“周红”，则$f(c)$是一个体项，此时$P(f(c))$表示命题“周红的叔叔是医生”。有了个体项的概念，就可在$n$元谓词的基础上得到如下原子谓词公式的定义：  
【定义4.10】设$P(x_{1}\,,\ x_{2}\,,\ \ \dots\,,\ x_{n})$是$n$元谓词公式，$t_{1}\,,\,\,\,t_{2}\,,\,\,\,\dots\,,\,\,\,t_{n}$是个体项，则称$P(t_{1},\ t_{2},\ \dots,\ t_{n})$为谓词演算的原子公式，简称为原子谓词公式。  
可原子谓词公式的基础上进一步得到如下谓词合式公式的定义：  
【定义4.11】谓词合式公式亦称为谓词公式，它按下列递归方式定义：  
（1）原子谓词公式是谓词公式；  
（2）若$G$，$H$是谓词公式，则$(\neg G)$$),\;(G\!\!\lor \!\!H),\;(G\!\!\ \ \wedge  H),\;(G\!\!\to\!\!H),\;$$(G{\leftrightarrow}H)$是合式公式；  
（3）若$G$ 是谓词公式，$x$是$G$ 中的自由变量，则$\forall x G$，$\exists x G$都是谓词公式；  
（4）所有谓词公式都是有限次使用（1），（2），（3）生成的符号串。  
由上述定义可知，谓词公式是原子谓词公式、联结词、量词、圆括号和逗号按上述规则组成的符号串，且命题公式是谓词公式的一个特例。为方便起见，谓词公式中的括号可以像命题公式那样省略最外层括号。  
例如：$(\forall x)(\forall y)(P(x,y)\rightarrow(Q(x,y)\vee\neg R(x,a,f(z)))), (\forall x)(P(x)\vee(\exists y)R(x,y))$等都是谓词公式；$(\forall x)(P(x)\to R(x),\ (\exists y)(\forall x)(\lor P(x,y))$等则都不是公式，前者括号不配对，后者联结词无联结对象。"
双射,概念,"['第七章 函数与特殊函数', '§ 7.1 函数的基本概念', '7.1.2 函数的基本类型']","{'实体类型': '概念', '定义': '若f是满射且是单射，则称f为A到B的双射', '条件': 'A=B时，称f为A上的函数；当A上的函数f是双射时，称f为A上的一个变换'}",,3,"从本质上讲，从集合$𝐴$到集合$B$的函数描述的是$𝐴$中元素与$𝐵$中元素之间的一种特殊对应关系，这种特殊对应关系可以是一对一的也可以是多对一的，但不能是一对多或多对多的关系。这是函数对应关系与一般对应关系的主要差别。此外，函数值域可以是$B$的某个真子集，也可以是$B$自身。根据以上讨论，就可将所有函数分成如下四种不同的基本类型，即是单射但不是满射的函数、是满射但不是单射的函数、既是单射又是满射的函数、既不是单射也不是满射的函数。本节主要讨论这四种函数，首先给出单射函数和满射函数的定义：  
【定义7.5】设$f$从集合$𝐴$到集合$ B$的函数：  
（1）若$f$的不同自变量映射到不同的像，则称$f$为为$𝐴$到$B$的单射函数,简称为单射。也就是说，对任意的$x_{1},x_{2}\in A$，如果$x_{1}\neq x_{2}$，那么$f(x_{1})\neq f(x_{2})$，则称$f$为$𝐴$到$B$的单射。  
（2）如果集合$ B$中的每个元素都有原像，则称$f$为$𝐴$到$B$的满射函数，简称为满射；也就是说，如果$f$的值域等于$B$，即有$𝑟𝑎𝑛$ $f=B$，则称${f}$为$𝐴$到$B$的满射。  
（3）若$f$是满射且是单射，则称$f$为$𝐴$到$B$的双射；若$A=B$，则称${f}$为$𝐴$上的函数；当$𝐴$上的函数$f$是双射时，则称$f$为$𝐴$上的一个变换。  
可依据上述定义判断函数$f\colon A\to B$是否为满射、单射、双射。判断满射就是检查$B$中的每个元素是否都是函数值。如果在$B$中找到不是函数值的元素，那么$f$就不是满射的。判断单射的方法就是检查不同的自变量是否对应于不同的函数值。  
由定义7.2 和例7.1.7 可看出，若$ f$是从有限集$𝐴$到有限集$B$的函数，则$f$是单射的必要条件是$|A|\leq|B|$；$f$是满射的必要条件是$|A|\geq|B|$；$f$是双射的必要条件是$|A|=|B|$。此外，当$A$ 和$B$ 是基数相同的有限集合时，还有以下结论：  
【定理7.3】设$𝐴$，$B$是有限集合且$|A|=|B|$。如果$f$是一个从$A$到$B$的单射函数，则$f$必然是从𝐴到$B$的满射函数，反之亦然。"
双射函数,概念,"['第七章 函数与特殊函数', '§ 7.4 有限集的置换函数']","{'实体类型': '概念', '定义': '有限集上的函数，每个元素都有唯一的对应元素', '特点': '有限集上的单射必是满射，满射也必是单射'}",,2,有限集上的函数是一类很特别的函数，具有很多非常重要而有趣的性质。如前所述，有限集$𝐴$上的单射必是满射，满射也必是单射。因此，有限集$𝐴$上的函数只有两种基本类型，一 种是双射函数，另外一种则为既非单射也非满射的函数。不难看出，有限集$𝐴$上双射函数其实就是$𝐴$上所有元素的一个全排列，因此，有限集$𝐴$上双射函数也称为置换函数。本节主要讨论有限集$𝐴$上双射函数的概念与关系运算性质，包括置换函数的基本概念、置换函数的运算性质、置换函数的轮换分解。
双射函数集,概念,"['第七章 函数与特殊函数', '§ 7.4 有限集的置换函数', '7.4.1  置换函数的概念']","{'实体类型': '概念', '定义': '设A是一个有穷集合，A上所有的双射函数构成的集合称为A上的双射函数集或可逆函数集', '性质': ['forall f, g in F_A => f ∘ g in F_A ∧ g ∘ f in F_A', 'forall f, g, h in F_A => (f ∘ g) ∘ h = f ∘ (g ∘ h)', 'forall f in F_A => f ∘ I_A = I_A ∘ f = f', 'forall f in F_A => f^(-1) in F_A']}",,3,"设$𝐴$是一个任意给定的非空有限集，由函数计数原理知，$𝐴$上所有不同双射函数个数也是有限的。因此，可将这些所有不同双射函数放在一起组成一个集合，并将该集合作为分析讨论𝐴上双射函数性质的背景或载体。为此，下面给出双射函数集的概念：  
【定义7.11】设$A=\{x_{1},x_{2},\cdots,x_{n}\}$是一个有穷集合， $𝐴$上所有的双射函数构成的集合称为𝐴上的双射函数集或可逆函数集。记为$F_{A}$。  
对于双射函数集$F_{A}$，显然有如下性质：  
$( 1) \forall f, g\in F_A\Rightarrow f\circ g\in F_A\wedge$ $g\circ f\in F_A。 ( 2)$ $\forall f, g, h\in F_A$ $\Rightarrow ( f\circ g) \circ h= f\circ ( g\circ$  
$h)$。  
(3) $\forall f\in F_{A}\Rightarrow f\circ I_{A}= I_{A}\circ f= f$。  
(4) $\forall f\in F_{A}$ $\Rightarrow f^{- 1}\in F_{A}$  
【定义7.12】设$ A=\{x_{1},x_{2},\cdots,x_{n}\}$是一个有限集合，从$𝐴$到$𝐴$的双射函数称为$𝐴$上的一个置换函数，简称为置换或排列，记为$P{\mathrel{:}}A\to A$，$A$的基数$n$称为置换的阶。  
由于置换函数表示的是有限集合上元素的全排列，故通常使用字母$P$或$\pi$作为置换函数的函数名，即有：  
$P=\begin{pmatrix}x_1&x_2&x_3&&\cdots&x_n\\P(x_1)&P(x_2)&P(x_3)&&\cdots&P(x_n)\end{pmatrix}\quad(7-7)$  
上式其中第一行是集合$ A$的元素按顺序列出，第二行元素是$A$中元素对应的函数值。显然序列$P(a_{1}),P(a_{2}),\cdots,P(a_{n})$是$𝐴$中元素的重排，恰好对应一个$ N=\{1,2,\cdots,n\}$全排列。  
显然有$F_{A}=\left\{f\middle|f\right.$是𝐴中的置换}，即可逆函数集是$𝐴$中所有置换的集合。由于 $n$元有限集中共有$n\,!$个不同的置换函数，故有$|F_{A}|=n!$，因此，有时亦将$𝐴$的可逆函数集记为𝐴！。"
双重否定律,性质,"['第一章  集合与计数基础', '§ 1.1 集合的基本知识', '1.1.3 集合的基本运算', '二、差运算与补运算']","{'实体类型': '性质', '条件': '对于任意给定的集合A', '结论': 'A=A'}",,4,"对于任意给定的两个集合$A$ 和$B$，有时需要将属于$A$ 但不属于$B$ 的所有元素取出来构成一个新的集合，由此得到如下集合差运算的概念：  
【定义1.12】对于任意给定的两个集合$A$ 和$B$，集合$\cdot A-B=\{x|x\in A$并且$x\notin B\}$称为$A$ 与$B$ 的差集，$A-B$亦称为集合𝐴与$B$的差运算；令$U$表示全集，则${\bar{A}}=U-A=\{x|x\in$$U$且$x\notin A\}$称为$A$ 的补集，亦称$\bar{A}$为对集合$A$ 的补运算。  
一般来说，所谓两个对象互补，是指这两个对象之间无共同部分并且若将两者合并则构成一个完整的整体。如果将全集𝑈看成是一个完整的整体，那么任何一个集合与它的补集显然构成一种互补关系。图1-3 为集合差运算和补运算的文氏图。  
![](images/3dd3ff26327d44646f11d3b3940708dbd5563cf42578e139e0a56534e35c5eff.jpg)
图1-3 差、补运算的文氏图  
不难看出，集合的差运算和补运算其实就是实数减法运算在集合论中的推广。根据集合差运算与补运算的定义，不难证明它们满足如下基本运算性质：  
(1) 矛盾律：对于任意给定的集合$A$，有：$A\cap{\bar{A}}=\emptyset$；(2) 排中律：对于任意给定的集合$A$，有：$A\cup\bar{A}=U$  
(3) 双重否定律：对于任意给定的集合$A$，有：$\bar{\bar{A}}=A$  
(4) 德摩根律：对于任意给定的两个集合$A$ 和$B$，有： $\overline{{A\cup B}}=\bar{A}\cap\bar{B},\,\,\,\overline{{A\cap B}}=\bar{A}\cup\bar{B}$  
(5) 对于任意给定的三个集合$A$、$B$ 和$C$，有：  
$A\cup(B\cup C)=(A\cup B)\cup C;\;A\cap(B\cap C)=(A\cap B)\cap C\circ$ $A\cap(B\cup C)=(A\cap B)\cup(A\cap C);\;A\cup(B\cap C)=(A\cup B)\cap(A\cup C)\,.$ $A\cap(A\cup B)=A;\,\,\,A\cup(A\cap B)=A\,.$  
现仅以德摩根律为例给出上述运算性质的证明，读者可自行给出其余证明。【例题1.22】对于任意给定的两个集合$A$ 和$B$，证明如下德摩根律：  
$$
{\overline{{A\cup B}}}={\bar{A}}\cap{\overline{{B}}}\,;\;{\overline{{A\cap B}}}={\bar{A}}\cup{\bar{B}}
$$"
双量词式,概念,"['第四章  谓词演算与推理', '§ 4.2  谓词公式与等值演算', '4.2.4 谓词公式的等值与蕴含', '三、双量词式的等值与蕴含']","{'实体类型': '概念', '定义': '包含两个量词的谓词公式', '特点': '量词的顺序不同，公式的含义不同', '结论': '可以通过等值演算简化复杂公式'}",,4,"不失一般性，这只讨论两个量词的情况，更多量词的使用方法与此类似。因为对于含两个量词的谓词公式$(\forall x)(\forall y)B(x,y)$，若将其中$(\forall y)B(x,y)$视为$A(x)$，则$(\forall x)(\forall y)B(x,y)$便可视为$(\forall x)A(x)$。依此类推，含$n$个量词的谓词公式可依照含两个量词谓词公式的处理方法进行讨论。两个量词的谓词共有如下8 种排列情况，分别表示不同的含义：  
$(\ 1\ )(\exists x)(\exists y)A(x,y);~(\,2\,)~(\exists y)(\exists x)A(x,y);~(\,3\,)~(\forall x)(\exists y)A(x,y);~(\,4\,)~(\forall y)(\exists x)A(x,y)$  
$(\ 3\ )\exists x)(\forall y)A(x,y);\ \ \ (6)\ (\exists y)(\forall x)A(x,y);\ (7)\ (\forall x)(\forall y)A(x,y);\ (8)\ (\forall y)(\forall x)A(x,y)$"
反对称关系,概念,"['第五章 关系模型与理论', '§ 5.3 关系的基本性质', '5.3.2 关系的对称与反对称']","{'实体类型': '概念', '定义': '设R是集合A上的关系，若对任意x,y∈A，满足⟨x,y⟩∈R且⟨y,x⟩∈R则有a=b，则称关系R是反对称关系，或称R具有反对称性', '特点': '关系图中任何一对结点之间至多有一条边；关系矩阵为反对称矩阵，即对称的两个元素中最多有一个等于1'}",,3,"有很多关系具有一些对称的性质，例如对于同学关系，如果张三是李四的同学，那么李四必然是张三的同学，还有很多其它关系，例如两条直线之间的平行关系、兄弟关系、实数的相等关系等等，也都具有这种对称性质。关系对称性的具体定义如下：  
【定义5.19】设$R$ 是集合$A$ 上的关系，对任意$x,y\in A$，若$\langle x,y\rangle\in R$，则有$\langle y,x\rangle\in R$，则称关系$R$ 是对称关系，或称关系$R$ 具有对称性。即有：  
$(\forall x)(\forall y)(x\in A\land y\in A\land\langle x,y\rangle\in R\rightarrow\langle y,x\rangle\in R)\Leftrightarrow R$为对称关系；$\quad\text{(5-12)}$  
还有一些集合上的关系，集合中的所有元素与其自身之外任何元素之间的关系都不具有对称性，例如正整数的整除关系，对于任意两个正整数，除非这两个整数相等，否则它们之间不可能相互整除，也就是说，对于任意两个正整数$a$和$b$，如果$a|b$且$b|a$，则必有$a=b$。关系的这种性质称为反对称性，具体定义如下：  
【定义5.20】设$R$ 是集合$A$ 上的关系，若对任意$x,y\in A$，满足$\langle x,y\rangle\in R$且$\langle y,x\rangle\in R$  
则有$a=b$，则称关系$R$ 是反对称关系，或称$R$ 具有反对称性。即有：$(\forall x)(\forall y)(x\in A\land y\in A\land\langle x,y\rangle\in R\land\langle y,x\rangle\in R\to x=y)\Leftrightarrow R$为反对称关系  （5-13）【例题5.29】设$A=\{a,b,c\}$， $R_{1}$，$R_{2}$，$R_{3}$，$R_{4}$是$A$ 上的关系，其中：
$$
R_{1}=\{\langle a,a\rangle,\langle b,b\rangle,\langle c,c\rangle\};\,\,\,R_{2}=\{\langle a,a\rangle,\langle b,c\rangle,\langle c,b\rangle\}
$$  
$$
R_{3}=\{\langle a,b\rangle,\langle a,c\rangle\};\,\,\,R_{4}=\{\langle a,b\rangle,\langle b,c\rangle,\langle c,a\rangle\}
$$
判断$R_{1}$，$R_{2}$，$R_{3}$，$R_{4}$是否具有对称性或反对称性。  
通过上述例题，不难得出如下结论：  
（1）存在既不是对称也不是反对称的关系，也存在既是对称也是反对称的关系。  
（2）关系$R$ 是对称的当且仅当关系图中任何一对结点之间，要么存在方向相反的两条边，要么无任何边；关系$R$ 是反对称的当且仅当关系图中任何一对结点之间至多有一条边。  
（3）关系$R$ 是对称的当且仅当$R$的关系矩阵为对称矩阵；关系$R$ 是反对称的当且仅当$R$ 的关系矩阵为反对称矩阵，即对称的两个元素中最多有一个等于1。"
反对称性,性质,"['5.3.4 关系性质的判定', '第五章 关系模型与理论', '第六章 特殊关系模型', '§ 5.3 关系的基本性质']","{'实体类型': '性质', '定义': '如果关系中的元素a与元素b相关联，且元素b与元素a相关联，则元素a和元素b是同一个元素', '判定条件': 'R 是反对称的当且仅当 R 与 R 的逆关系的交集包含于 I_A'}",,2,现实世界中的关系错综复杂、种类繁多，这给我们使用关系的数学模型表示和解决关系问题带来一定的困难。因此，为了比较方便地研究和使用关系的数学模型，本节建立考察关系特性的若干标准并将这些标准看成是关系的基本性质。对于任意给定的一个关系，就可以使用这些标准来考察或评判该关系满足或不满足这几个标准中的哪几条，换句话说，就是考察该或评判该关系具有哪些基本性质。这样就可以依据这些标准将所有的关系划分为若干类型进行分门别类的研究。关系的这些考察标准或基本性质一共有五个，即自反性、反自反性、对称性、反对称性和传递性，本节具体介绍这些基本性质的概念及判定方法。
反自反关系,性质,"['第五章 关系模型与理论', '§ 5.3 关系的基本性质', '5.3.1 关系的自反与反自反']","{'实体类型': '性质', '定义': '设R是集合A上的关系，若对任意x属于A，都有<x,x>不属于R，则称R在A上是反自反关系，或称R具有反自反性', '特点': '每个元素都不可能与其自身之间具有这种关系', '结论': '如果关系R是反自反的，那么该关系一定不是自反的；关系R是反自反的，当且仅当图中每个结点都没有自环；关系R是反自反的，当且仅当其关系矩阵的主对角线上全为0'}",,3,"日常生活和工作中的很多关系，如同学关系、实数的相等关系、正整数的整除关系等，每个元素都与其自身之间具有这种关系，此时称这些关系具有自反性质。具体定义如下：  
【定义5.17】设$R$ 是集合$A$ 上的关系，若对$\forall x\in A$，都有$\langle x,x\rangle\in R$，则称$R$ 在$A$ 上是自反关系，或称$R$ 具有自反性。即：  
$(\forall x)(x\in A\to\langle x,x\rangle\in R)\Leftrightarrow R\text{为自反关系}\quad\text{(5-10)} $  
与之相反的是，对于有些关系，例如父子关系、实数的小于关系、夫妻关系等，每个元素都不可能与其自身之间具有这种关系，此时称这些关系具有反自反性质。具体定义如下：  
【定义5.18】设$R$ 是集合$A$ 上的关系，若对$\forall x\in A$，都有$\langle x,x\rangle\notin R$，则称$R$ 在$A$ 上是反自反关系，或称$R$ 具有反自反性。即：  
通过上述例题，不难得出如下结论：  
（1）如果关系$R$ 是自反的，那么该关系一定不是反自反的；关系$R$ 是反自反的，则该关系一定不是自反的。  
（2）存在既不是自反也不是反自反的关系；  
（3）关系$R$ 是自反的，当且仅当系图中每个结点都有一个自环；关系$R$ 是反自反的，当且仅当图中每个结点都没有自环；  
（4）关系$R$ 是自反的，当且仅当其关系矩阵的主对角线上全为1；关系$R$ 是反自反的，当且仅当其关系矩阵的主对角线上全为0。"
反自反性,性质,"['5.3.4 关系性质的判定', '第五章 关系模型与理论', '§ 5.3 关系的基本性质']","{'实体类型': '性质', '定义': '关系中的每个元素都不与其自身相关联', '判定条件': 'R 是反自反的当且仅当 R 与 I_A 的交集为空', 'name': '反自反性'}",,2,现实世界中的关系错综复杂、种类繁多，这给我们使用关系的数学模型表示和解决关系问题带来一定的困难。因此，为了比较方便地研究和使用关系的数学模型，本节建立考察关系特性的若干标准并将这些标准看成是关系的基本性质。对于任意给定的一个关系，就可以使用这些标准来考察或评判该关系满足或不满足这几个标准中的哪几条，换句话说，就是考察该或评判该关系具有哪些基本性质。这样就可以依据这些标准将所有的关系划分为若干类型进行分门别类的研究。关系的这些考察标准或基本性质一共有五个，即自反性、反自反性、对称性、反对称性和传递性，本节具体介绍这些基本性质的概念及判定方法。
反证法,定理,"['第三章  命题演算与推理', '§ 3.5 命题逻辑的演绎推理', '3.5.3 命题推证的基本策略', '三、间接证明法']","{'实体类型': '定理', '条件': '命题公式集合{G1,G2,...,Gn}是相容的', '结论': '从前提集合{G1,G2,...,Gn}可以逻辑推出公式H的充要条件是从前提集合{G1,G2,...,Gn,¬H}出发，可以逻辑推出一个矛盾（永假）式来'}",,4,"间接证明法不仅使用$P$规则，$T$规则，还使用反证法或$C P$规则的推理方法。在引入间接证明法之前，首先给出公式组相容概念：  
【定义3.30】假设$G_{1},G_{2},\cdots,G_{n}$是一组命题公式，$P_{1},P_{2},\cdots,P_{n}$是出现在$G_{1},G_{2},\cdots,G_{n}$中的一切命题变元，若有解释I使$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}$取值为“真”，则称公式$G_{1},G_{2},\cdots,G_{n}$是一致的或相容的，否则称公式$G_{1},G_{2},\cdots,G_{n}$为不一致的，或者说$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}$是一个矛盾式。  
利用矛盾式的概念，可以给出一种推导过程，这个过程通常称为矛盾法或间接证明法，常被称为反证法。下面给出反证法的证明。  
【定理3.15】如果命题公式集合$\{G_{1},G_{2},\cdots,G_{n}\}$是相容的，那么从前提集合$\{G_{1},G_{2},\cdots,G_{n}\}$可以逻辑推出公式$\cdot H$，即$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\Rightarrow H$，的充要条件是从前提集合$\{G_{1},G_{2},\cdots,G_{n},\lnot H\}$出发，可以逻辑推出一个矛盾（永假）式来，即$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\wedge\neg H\Rightarrow F_{\circ}$。"
反链,概念,"['第六章 特殊关系模型', '§ 6.3 偏序关系与元素比较', '6.3.3  全序与良序']","{'实体类型': '概念', '定义': '偏序集的子集，其中任意两个元素都是不可比的', '特点': '表达了一种并行执行结构'}",,3,"前述集合$𝐴$上偏序关系并不保证$𝐴$上的任何两个元素之间都是可比的，也是就是说并不保证任何两个元素之间都存在序关系。然而，在很多场合我们都需要对所关心的所有对象排个次序，例如体育比赛中的种子选手排名、全国各高校的综合排名、大会嘉宾代表的入场次序等等，都需要对所有对象进行排序。现有偏序关系模型显然不能正确表示和处理这类问题。故须加强偏序关系约束条件，在偏序关系基础上引入全序关系，其具体定义如下：  
【定义6.14】对于偏序集$\langle A,\preccurlyeq\rangle$，如果$𝐴$中任意两个元素${x}$和$\boldsymbol{y}$都是可比的，即$x\preccurlyeq y$或者$y\preccurlyeq x$，则称该偏序关系为全序关系或线序关系，简称为全序或线序。并称$\langle A,\preccurlyeq\rangle$为全序集或线序集，也可称为集合$𝐴$的链。  
由上述定义可知，全序关系必定是偏序关系，偏序关系则不一定是全序关系。  
可用全序的概念定义偏序集$\langle A,\preccurlyeq\rangle$的一些特殊子集合，具体定义如下：  
【定义6.15】设$\langle A,\preccurlyeq\rangle$是一个偏序集，$B$是$𝐴$的任一子集，如果$𝐵$中任意两个元素都是可比的，则称$B$是$𝐴$的一条链，$B$中元素的个数称为该链的长度；反之，如果$B$中任意两个元素都是不可比的，则称 $B$是$𝐴$的一条反链，$B$中元素的个数称为该反链的长度。对于$𝐴$中由单个元素组成的集合，规定它既是链也是反链。  
例如，在偏序集〈{1,2,3,4,5,6,7,8,9}, |〉中，{1,2,4,8}是一条长度为4 的链，{2,4}是一条长度为2 的链，{2,3}则是一条长度为2 的反链。  
偏序集中的链表达了偏序集中部分元素之间存在全序关系，反链则表达了偏序集中部分元素相互之间不存在任何序关系。显然，链表达的是一种串行执行结构，反链表达的是一种并行执行结构。因此，可以使用偏序集中链和反链的概念优化实际问题求解的业务流程，有效提高问题求解的工作效率。  
![](images/18f7caa4d0b707d1ff49eb6f7a547c82b50926bf7ba3ab409aa786a7fcff2f4c.jpg)
图6-22 保险索赔业务流程  
例如，图6-22 是一个关于保险索赔的流程图。图中方框代表处理流程中业务，圆圈代表某种分支选择。将流程中循环抽象成一个单一的结点，如用单个结点𝑇代替流程图中业务$T_{7}$、$T_{8}$及其后的分支结点。由此得到的所有结点构成集合$𝐴$，在该集合元素之间定义如下偏序关系≼：对$\forall x,y\in A$，当且仅当$x=y$或者$𝑦$必须在$x$完成后才能开始时，成立$x\preccurlyeq y$。如此，集合$𝐴$与其上的偏序关系$\preccurlyeq$便构成一个偏序集$\langle A,\preccurlyeq\rangle$，  
图6.23 为其哈斯图。  
考虑偏序集中的链，最长链有4 条，其中2 条分别是：  
$\{T_1,T_2,T_3,S_1,T_6,,S_2,T,T_{10}\}; \{T_1,T_2,T_3,S_1,T_6,,S_2,T_9,T_{10}\}$  
长度都是8。显然，最长链的长度代表了整个流程中必须顺序执行的任务最多有多少个。如果完成每项任务的时间差距不大，那么这种最长链就反映了完成整个任务的最少时间。  
![](images/598fd43b47030dd50e3aa3bc789da0841fc0eb2b823d2c8cd7d0b88fecfb1eab.jpg)
图6-23 业务关系哈斯图  
并行执行业务是提供效率的一种有效途径。在一个偏序集中，如果能够将业务按照不相交的链进行分解，那么这些不相交的链就可在一定程度上并行执行。另一方面，如果把偏序集分解成不相交的反链，那么最长的反链长度则代表了在某个时间区间极大可并行的任务数。下面定理刻画了偏序集的分解与反链之间的关系：  
【定义6.16】设$\langle A,\preccurlyeq\rangle$为偏序集，如果$𝐴$中最长的链长度为$n$，则该偏序集可以分解为$𝑛$条不相交的反链。  
我们知道，对于一个偏序集合$\langle A,\preccurlyeq\rangle$，其任何子集${B}$上的最大值和最小值不一定存在或者不一定都存在。如果我们把偏序集合$\langle A,\preccurlyeq\rangle$的约束条件加强，要求$𝐴$的任何子集$𝐵$上的必须存在最小值，则得到如下良序关系的概念：  
【定义6.17】对于偏序集$\langle A,\preccurlyeq\rangle$，如果$𝐴$的任意一个非空子集$B$中都含有最小元素，则称该偏序关系为良序关系，简称为良序。称$\langle A,\preccurlyeq\rangle$为良序集。  
由上述定义可知，良序关系一定是偏序关系和全序关系，但偏序关系和全序关系不一定是良序关系。例如，实数集合上的小于等于关系显然是全序关系，但不是良序关系，因为开区间(0,1)没有最小值。不过有限的全序集一定是良序集。对于任何一个有限偏序集，可以通过适当排序将其改造成为一个全序集，从而使其成为良序集。"
变换群,概念,"['第十二章 典型抽象代数结构', '§ 12.2 群结构的基本知识', '12.2.3 循环群与置换群']","{'实体类型': '概念', '定义': '集合上的全体一一变换与其乘法运算构成的群', '特点': '可以是有限群也可以是无限群', '关系': '对称群是特殊的变换群，置换群是变换群的子群'}",,3,"本节主要介绍两种重要的特殊群结构，即循环群和置换群。循环群是以某个元素的全部方幂载体集合的群，是目前研究最彻底的一种群。基于普通加法的整数加群$\langle Z,+\rangle$和基于模加运算的剩余类加群$\langle\underline{{n}},+_{n}\rangle$都是循环群。事实上，从同构角度看，循环群也只有$\langle Z,+\rangle$。和$\langle\underline{{n}},+_{n}\rangle$这两种不同的群。置换群则是有限集上置换函数集合与函数复合运算构成的群，是以置换函数及其运算为研究对象的群。置换群的重要性主要在于任何一个有限群都与一个置换群同构，换句话说，从同构的角度看，所有的有限群都是置换群。此外，循环群和置换群的实用性都非常强，是很多理论问题证明和求解的重要工具，在信息压缩与编码、形式语言自动机、几何变换与图形算法设计等多个领域具有重要的实用价值。  
一、循环群  
前面我们已经学过循环半群和循环含幺半群，现将其直接推广到群结构，由此得到循环群的概念，具体如下：  
【定义12.13】设$\langle G,*\rangle$是任意给定的群，若存在$a\in G$ 使得  
$$
G=\{a^{k}\big|k\in Z\}=\langle a\rangle
$$  
则称 $\langle G,*\rangle$ 为循环群，记作 $\langle\langle a\rangle_{*}\rangle$ ，并称 $a$ 是 $G$ 的生成元。此时，若 $|a|=n$ ，则称 $\langle\langle a\rangle{,*}\rangle$ 为 ${n}$ 阶 循环群，若$|a|$为无穷大，则称$\langle\langle a\rangle{,*}\rangle$为无限阶循环群。  
【定理12.15】假设$\langle G,*\rangle$是任意给定的一个循环群，则该群一定是交换群。  
【定理12.17】设$\langle G,*\rangle$是以$a$为生成元的循环群，即$G=\langle a\rangle$，则  
（1）若$G$是无限群，则$G$与整数加法群$\langle Z,+\rangle$同构；  
（2）若$G$是无限群是有限群且$|G|=n$，则$G$与$n$阶剩余类加群$\langle n,+_{n}\rangle$同构。  
二、 置换群  
在前面我们已经学习置换函数及其乘法的有关知识，现在从群的角度来考察置换函数及其乘法的运算性质。我们知道，置换函数其实就是有限集合上的的双射函数。为了能够更为一般的概念和性质，现从更为一般的角度考察双射函数，即一般集合上的双射函数及其乘法运算，由此得到如下变换及变换乘法的概念：  
【定义12.14】设$𝐴$是任意给定的一个非空集合，$A$集合上的映射$ f$：$A\rightarrow A$称为$𝐴$的一个变换。若该映射$f$是双射，则称$f$为$𝐴$上的一个一一变换。  
例如$f$：$Z\rightarrow Z$，$f(x)=x$和$g$：$Z\rightarrow Z$，$f(x)=-x$都是𝑍上的一一变换。  
【定义12.15】设$f,g$是𝐴上的变换，$f$和$g$的复合称为$f$与$g$的乘积，记作$f\circ g$  。  
不难证明，$f\circ g$也是$𝐴$上的一个变换。如果$f$和$g$都是$𝐴$上的一一变换，则乘积$f\circ g$也是$𝐴$上的一个一一变换。  
下面的定理12.18 表明：以给定集合上全体一一变换集合为载体、以变换乘法∘为运算构成的二元代数结构是一个群，由此可以从群的角度考察一一变换及其乘法运算性质。  
【定理12.18】假设$𝐴$是任意给定的一个非空集合，$E(A)$是$𝐴$上的全体一一变换构成的集合，则$E(A)$与其上一一变换的乘法运算∘构成的二元代数结构$\langle E(A),\circ\rangle$是一个群。  
【定义12.16】假设$𝐴$是任意给定的一个非空集合，$E(A)$是𝐴上的全体一一变换构成的集合，则$E(A)$与其上一一变换的乘法运算∘构成的群$\langle E(A),\circ\rangle$称为变换群，当$𝐴$是有限集合时，称变换群$\langle E(A),\circ\rangle$为对称群，对称群的任何一个子群称为置换群。  
从上述定义可以看出，变换群的载体集合$ E(A)$可以是有限集合也可以是无限集合，或者说变换群可以是有限群也可以是无限群。对称群则是一种特殊的变换群，要求变换群的载体集合必须是有限集合，因此，对称群一定是有限群。置换群则是变换群的子群，当然对称群作为其自身的平凡子群是一种特殊的置换群，但置换群不一定是对称群。因此，置换群比对称群具有更加广泛的含义，一般主要考察置换群。  
我们知道，对于任意给定的一个有限集合$𝐴$，该集合上的一一变换称为$𝐴$上的置换。当$|A|=n$时称$𝐴$上的置换为${n}$元置换。为了叙述上的方便，常将$A$记作$\{1,2,\cdots,n\}$，这样就可以将$𝐴$上的$n$元置换$p$记作：  
$$
\pi={\binom{a_{1},\ldots a_{n}}{b_{1},\ldots b_{n}}}\,,b_{i}=\sigma(a_{i}),\qquad\qquad\qquad i=1,2,\cdots,n
$$  
易见$.\pi(1)\,\,\,\pi(2)\,\,\,\,\,\cdots\pi(n)$恰恰为${1,\,,2,\cdots,n}$的一个排列。在$𝐴$上的所有置换和$𝐴$的所有排列之间存在着一一对应，$n$元集有$n!$个排列，故有${n}$!个$n$ 元置换。所有这些置换的集合记作$S_{n}$，则$\langle S_{n},\circ\rangle$就是一个对称群。  
具体地说，设$A=\{1,\!2\}$，那么$𝐴$上有两个置换：  
$$
p_1=\binom{1\quad2}{1\quad2},\quad p_2=\binom{1\quad2}{2\quad1}
$$  
当$A=\{1,\!2,\!3\}$时，$A$上有6 个置换：  
$$
\pi_1=\begin{pmatrix}1&2&3\\1&2&3\end{pmatrix},\pi_2=\begin{pmatrix}1&2&3\\2&1&3\end{pmatrix},\pi_3=\begin{pmatrix}1&2&3\\3&2&1\end{pmatrix}
$$  
$$
\pi_1=\begin{pmatrix}1&2&3\\1&3&2\end{pmatrix},\pi_2=\begin{pmatrix}1&2&3\\2&3&1\end{pmatrix},\pi_3=\begin{pmatrix}1&2&3\\3&1&2\end{pmatrix}
$$  
一般地，$A=\{a_{1},a_{2},\dots a_{n}\}$时，$A$上有$n!$个置换。如有$\pi(a_{i})=a_{j_{i}}$时，则$\pi$可表示为：  
$$
\pi={\binom{a_{1},\,\dots\,a_{n}}{a_{j_{1}},\,\dots\,a_{j_{n}}}}
$$  
置换乘法运算或者复合运算通常用∘表示，置换乘法可以像计算两个关系的合成那样进行。需要特别注意的是，置换乘法或复合运算与通常函数的复合运算次序相反。例如：  
$$
\pi_6\circ\pi_4=\begin{pmatrix}1&2&3\\3&1&2\end{pmatrix}\cdot\begin{pmatrix}1&2&3\\1&3&2\end{pmatrix}=\begin{pmatrix}1&2&3\\2&1&3\end{pmatrix}
$$  
即有：$(\pi_{6}\circ\pi_{4})(x)=\pi_{4}(\pi_{6}(x))$  。  
下面考察置换群的几何意义，首先考察三元对称群：  
设$A=\{1,\!2,\!3\}$，则$A$上的6 个置换$S_{3}=\{\pi_{1},\pi_{2},\pi_{3},\pi_{4},\pi_{5},\pi_{6}\}$关于其乘法运算∘构成一个群$\langle S_{3},\circ\rangle$，并称之为三次对称群。其中$\pi_{1}$是恒等置换为群中的单位元，且有：  
$$
{p_{2}}^{-1}=p_{2};~~{p_{3}}^{-1}=p_{3};~~{p_{4}}^{-1}=p_{5};~~{p_{5}}^{-1}=p_{4};~~{p_{6}}^{-1}=p_{6}
$$  
其实，还可以从另一个角度也可得到这个群：用数字1,2,3 标记正三角形的三个顶点，如图12-3 所示。现将三角形以其中心O 为中心轴分别旋转$\sigma_{0},\sigma_{1},\sigma_{2}$（旋转$\cdot0^{\circ},120^{\circ},240^{\circ})$），或分别按直线$l_{1}l_{2}l_{3}$位对称轴进行翻转$(\sigma_{3},\sigma_{4},\sigma_{5})$，则每次旋转或翻转显然都都对应于三角形顶点数字的的一个置换，具体对应关系如下：  
$\sigma_{0}$（旋转$0^{\circ}$）        $p_1=\begin{pmatrix}1&2&3\\1&2&3\end{pmatrix};\quad\sigma_1\bigl(\text{旋转}120^\circ\bigr)\quad p_2=\bigl(\begin{matrix}1&2&3\\2&1&3\end{matrix}\bigr)$  
$\sigma_2\bigl(\text{旋转 240°}\bigr)\quad p_3=\bigl(\begin{matrix}1&2&3\\3&2&1\end{matrix}\bigr);\quad\sigma_3\bigl(\text{绕}l_3\text{翻转}\bigr)$$\quad\quad\quad p_4=\begin{pmatrix}1&2&3\\1&3&2\end{pmatrix}$  
$\sigma_4\big(\text{绕}l_2\text{翻转}\big)\quad p_5=\big(\begin{matrix}1&2&3\\2&3&1\end{matrix}\big);\quad\sigma_5\big(\text{绕}l_1\text{翻转}\big)\quad p_6=(\begin{matrix}1&2&3\\3&1&2\end{matrix})$  
不难看出：$\langle\{\sigma_{0},\sigma_{1},\sigma_{2},\sigma_{3},\sigma_{4},\sigma_{5}\},\circledast\rangle$构成一个群，其中$\circledast$表示旋转或翻转的操作的复合操作，并且与群$\langle\{\pi_{1},\pi_{2},\pi_{3},\pi_{4},\pi_{5},\pi_{6}\},\circ\rangle$同构。  
![](images/e6cbfb18c66c7d99640531f391a63f4a34c10b210258fb0a56bb479a832c31f2.jpg)  
图12-3 三角形的对称轴和对称中心  
![](images/c11de4754b3535d3b87f562740b93b202d5ef5e49fd3a0cb5d9d33538b6831cb.jpg)  
图12-4正方形的对称轴和对称中心  
下面进一步考察四元对称群的几何意义：令$A=\{1,\!2,\!3,\!4\}$，$S_{4}=\{p|p$为A 上的置换}，因此，$\langle S_{4},\circ\rangle$为四元对称群。现用数字1,2,3,4 分别标记正方形的4 个顶点，如图12-4 所示，$\sigma_{0},\sigma_{1},\sigma_{2},\sigma_{3},\sigma_{4},\sigma_{5},\sigma_{6},\sigma_{7}$分别表示正方形以其中心为中心轴进行旋转或按对称轴进行翻转，则它们分别对应与A 上的一个置换，具体如下：  
$ \sigma_0\big(\text{旋转 }0^\circ\big)\quad p_1=\begin{pmatrix}1&2&3&4\\1&2&3&4\end{pmatrix};\quad\sigma_1\big(\text{旋转 }90^\circ\big)\quad p_2=\begin{pmatrix}1&2&3&4\\2&3&4&1\end{pmatrix}$  
$\sigma_2\big(\text{旋转 180°}\big)\quad p_3=\begin{pmatrix}1&2&3&4\\3&4&1&2\end{pmatrix};\quad\sigma_3\big(\text{旋转 270°}\big)\quad p_4=(\begin{matrix}1&2&3&4\\4&1&2&3\end{matrix})$  
$\sigma_4(\text{绕}l_1\text{翻转})\quad p_5=\begin{pmatrix}1&2&3&4\\4&3&2&1\end{pmatrix};\quad\sigma_5(\text{绕}l_2\text{翻转})\quad p_6=(\begin{matrix}1&2&3&4\\1&4&3&2\end{matrix})$  
$\sigma_6(\text{绕}l_3\text{翻转})\quad p_7=\begin{pmatrix}1&2&3&4\\1&4&3&2\end{pmatrix};\quad\sigma_7(\text{绕}l_4\text{翻转})\quad p_8=(\begin{matrix}1&2&3&4\\1&4&3&2\end{matrix})$  
不难看出：$\langle\{\sigma_{0},\sigma_{1},\sigma_{2},\sigma_{3},\sigma_{4},\sigma_{5},\sigma_{6},\sigma_{7}\},\circledast\rangle$构成一个群，其中$\circledast$表示旋转或翻转的操作的复合操作，具体定义如表12-1 所示。  
表12-1 $\circledast$的运算表
![](images/0d658bbe39ea00a7b3a2683e4707c30ed3115f5772998f1ac1c9608422308ecc.jpg)  
由于$\langle\{\sigma_{0},\sigma_{1},\cdots,\sigma_{7}\},\circledast\rangle$与$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$同构，故$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$也是群，它是$\langle S_{4},\circ\rangle$的一个真子群，因为四元对称群$\langle S_{4},\circ\rangle$有24 个置换，而$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$仅有8 个置换。也就是说，群$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$是一个8 阶4 元置换群，但不是4 元对称群。  
【定理12.19】假设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$与某个变换群同构，如果$\langle G,*\rangle$是一个有限群，则$\langle G,*\rangle$与某个置换群同构。  
上述定理12.19 表明，变换群和对称群的重要性在于其作为两种具体的特殊群与一般的抽象群有着非常密切的联系。具体地说，每个群均同构于一个变换群，特别地，每个有限群均同构于一个置换群。因此，从同构的角度看，所有的群都可以看成是变换群，所有的有限群都可以看成是置换群。"
可兼或,概念,"['第三章  命题演算与推理', '§ 3.1 命题的概念与运算', '3.1.3  命题的常用联结词', '二、合取与析取联结词']","{'实体类型': '概念', '定义': '表示两个命题中至少有一个为真的逻辑关系'}",,4,"对于任意两个命题，有时需要构造一个新的复合命题表示这两个命题同时为真的含义，相当于自然语言中“与”或“并且”的意思，由此得到的逻辑运算称为命题的“合取”运算或者“与”运算。该运算及其逻辑联结词的具体定义如下：  
【定义3.3】设 $P$ 、$Q$ 是任意两个命题，复合命题$^{\prime\prime}P$并且 $Q$ ”称为 $P$ 与 $Q$ 的合取式或与运算，记作 $P\land Q$，其中符号$\wedge$称为合取联结词(简称为合取词)。 $P\land Q$的取值为真，当且仅当 $P$ 和$Q$ 同时为真；或者说$P$ ∧𝑄 的取值为假，当且仅当 $P$ 和 $Q$ 至少有一个为假。  
例如，若令$\cdot P$表示“我喜欢唱歌”， $Q$ 表示“我喜欢跳舞”，则合取式 $P\land Q$ 就表示复合命题“我喜欢唱歌并且喜欢跳舞”。  
对于任意两个命题 $P$ 和 $Q$ ，其合取运算 $P\land Q$的真值取值规定如表3-1 第5 列所示。  
有时需要构造一个复合命题表示两个命题中至少有一个为真的含义，相当于自然语言中“可兼或”的意思，由此得到的逻辑运算称为命题的“析取”运算或者“可兼或”运算。所谓可兼或，就是可两者兼得的或。该运算及其逻辑联结词的具体定义如下：  
【定义 3.4 】设   $P、 Q$   是任意给定的两个命题，复合命题 $^{\prime\prime}P$   或 $\textit{Q}\,^{\prime\prime}$ 称为   $P$ 与   $Q$   的析取 式或者可兼或运算，有时简称为或运算，记作 $P\lor Q$ ，其中符号$\vee$称为析取联结词(简称为析取词 ) 。 $P\lor Q$   的取值为真，当且仅当   $P$   和   $Q$   中至少有一个为真；或者说 $P\lor Q$   的取值 为假，当且仅当 $P$ 和 $Q$ 都为假。  
例如，若令 $P$ 表示“我喜欢唱歌”，$Q$ 表示“我喜欢跳舞”，则析取式 $P\lor Q$ 就表示复合命题“我喜欢唱歌或者喜欢跳舞”。  
对于任意两个命题 $P$ 和 $Q$，析取运算 $P\lor Q$ 的真值取值规定如表3-1 第6 列所示。  
在实际的逻辑电路中，通常用高电位表示1 或$T$，用低电位表示0 或$F$，通过逻辑与、或、非等运算，可构造相应的与门、或门、非门，如图所示。后面将具体介绍如何使用这些门电路来构造出一些复杂的逻辑电路。  
图3-2 逻辑电路  
需要注意的是：自然语言中或的含义是有歧义的，对或的理解除了上述可兼或外，有时还可理解成不可兼或，即两者不可兼得的或，有时称之为异或。在逻辑运算中，可兼或与异或之间具有完全不同的含义，我们将在后续相关内容中具体讨论异或逻辑联结词及其逻辑运算。除非特别说明，逻辑演算中或运算含义都默认为可兼或运算，即析取运算。  
在实际应用中，应根据语句的具体内容和上下文相关信息仔细甄别其中“或”表达的是可兼或还是不可兼或。例如，语句“今天晚上我看书或者听音乐”中“或”的含义应理解为可兼或；语句”这节课是数学课或者体育课“中“或”的含义应理解为不可兼或。"
可图化序列,定义,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.2.2 图模型的度结构']","{'实体类型': '定义', '内容': '对于任意一个给定的自然数序列，如果该序列能够成为某个图的度序列，则称该序列为可图化序列'}",,3,"现在我们考察图模型的结构特征。从结构上看，对于任意给定的一个图模型，只要该图不是零图，总会有一些点与一些边相互联结。从生成子图的概念可以看出，图的结点构成了图模型的骨架或主体结构，因此，我们主要从结点出发考察每个结点所关联的边关联多少条边。为此，对于图中的每个结点，都定义一个数来描述该结点所关联边的个数，这就是结点度的概念，其具体定义如下：  
【定义8.16】假设图 $G=\langle V,E\rangle$是任意给定的一个无向图，对于$G$中任意一个结点 $v$ ，与该结点关联边的条数称为该结点的度数，简称为度，记为 ${\sf d e g}(v)$。图$G$中各个结点度数的最大值称为图$G$的最大度，记为$\Delta(G)$；图$G$中各个结点度数的最小值称为图$G$的最小度，记为$\delta(G)$ $\Delta(\mathrm{G})=\mathrm{max}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\};\,\,\,\delta(\mathrm{G})=\mathrm{min}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\}\,.$  
【定义8.17】设图 $G=\langle V,E\rangle$是任意给定的一个有向图，$v$是$G$中任一结点，则有：  
（1）以该结点为起点的有向边的条数，称为该结点的出度，记为$\deg^{+}(v)$；以该结点为终点的有向边的条数，称为该结点的入度，记为 $\deg^{-}(v)$。  
（2）该结点的出度与入度之和称为该结点的度，记为${\sf d e g}(v)$。 即有：  
$$
\deg(v)=\deg^{+}(v)+\deg^{-}(v)
$$  
（3）图$G$中各个结点出度与入度的最大值分别称为图$G$的最大出度和最大入度，分别记为$\Delta^{+}(\mathsf{G})$和 $\Delta^{-}(\mathsf{G})$；图$G$中各个结点出度与入度的最小值分别称为图$G$的最小出度和最小入度，分别记为$\Delta^{+}(\mathbf{G})$和 $\Delta^{-}(\mathsf{G})$，即有：  
$\Delta^{+}(\mathrm{G})=\operatorname*{max}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\Delta^{-}(\mathrm{G})=\operatorname*{max}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$ $\delta^{+}(\mathrm{G})=\operatorname*{min}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\delta^{-}(\mathrm{G})=\operatorname*{min}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$  
从上述定义可以看出，引入度结点度概念的目的主要是通过对图中每个结点所关联边数进行统计分析来考察图模型的结构特征。  
【定义8.18】对于任意一个给定的有向图或无向图  $G=\langle V,E\rangle$ ，图中度数为1 的结点称为该图的悬挂结点，图中以悬挂结点为端点的边称为该图的悬挂边。如果图$G$中各个结点的度数均相同，则称该图正则图，各结点度均为$\ k$的正则图称为$\pmb{k}$-正则图。  
下面我们考察图的邻接矩阵与图中结点度之间的关系。  
假设 $G=\langle V,E\rangle$是任意给定的一个有向图或无向图，其中$V=\{v_{1},v_{2},\ldots,v_{n}\}$，$E=$$\{e_{1},e_{2},\ldots,e_{m}\}$。 $G$的邻接矩阵为：  
$$
A=(a_{i j})_{n\times n}=\left(\!\!{\begin{array}{c c c c}{a_{11}}&{a_{12}}&{\ldots}&{a_{1n}}\\ {a_{21}}&{a_{22}}&{\ldots}&{a_{2n}}\\ {\vdots}&{\ddots}&{\vdots}\\ {a_{n1}}&{a_{n2}}&{\ldots}&{a_{n n}}\end{array}}\!\!\right)
$$  
则有如下结论：  
（1）如果$G$是无向图，那么邻接矩阵𝐴中第𝑖行元素之和表示结点$v_{i}$的度数，第𝑗列元素之和表示结点$v_{j}$的度数。即有：  
$$
\deg(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};~~~~\deg\bigl(v_{j}\bigr)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（2）若G是有向图，那么邻接矩阵$A$中第𝑖行元素之和表示结点$v_{i}$的出度，第$j$列元素之和表示结点$v_{j}$的入度。简单地说，就是竖入横出。即有：  
$$
\deg^{-}(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};\qquad\deg^{+}\!\left(v_{j}\right)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（3）对于有向图G，注意到：  
$$
\sum_{j=1}^{n}\;\deg^{-}\!\left(v_{j}\right)=\sum_{i=1}^{n}\sum_{j=1}^{n}a_{i j}=\sum_{i=1}^{n}\deg^{+}\!\left(v_{i}\right)
$$  
因此，有向图中所有入度之和等于所有出度之和，这个和其实就是图的边数$m$。因为有向图的每条边均产生且仅产生一个出度和一个入度。  
对于图8-19 所示图模型$G$及如下邻接矩阵$A_{G}$，容易验证，结点度与邻接矩阵之间的数量关系。例如，$A_{G}$中第三行元素之和为3，即$v_{3}$的出度为3。
$$
\begin{gathered}v_{1}\quad v_{2}\quad v_{3}\quad v_{4}\quad v_{5}\\A_{G}=\begin{matrix}v_{1}\\v_{2}\\v_{3}\\v_{4}\end{matrix}\begin{pmatrix}0&1&0&0&0\\0&1&1&0&0\\1&1&0&1&0\\0&0&0&0&0\\0&0&0&0&0\end{pmatrix}\end{gathered}
$$  
关于图中结点度数与边的关系，有如下著名的图论基本定理：  
【定理8.1】（握手定理）假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，则该图中结点度数的总和等于边数的二倍，即有：  
$$
\sum_{v\in V}\deg(v)=2|E|
$$  
【推论8.1】图中度数为奇数的结点个数必为偶数。  
从以上定理及例题可以看出，图模型中结点的度从一种定量的角度反映了图中结点与边之间的制约关系，在一定程度上刻画了图模型的结构特征。为了更加方便地描述图模型中各个结点的度结构信息，下面给出度序列的概念：  
【定义8.19】假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，图中每个结点的图构成的自然数序列称为$G$的度序列。也就是说，若 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，则称序列：  
$$
(\deg(v_{1})\,,\deg(v_{2})\,,\cdots,\deg(v_{n}))
$$  
为图 $G$ 的度数序列，简称为度序列。 此外，对于任意一个给定的自然数序列，如果该序列能够成为某个图的度序列，则称该序列为可图化序列。  
例如，对于图8-22 所示图 $G$ ，其度数序列为 (2,3,3,4)  
![图8-22 图 $G$ ](images/77ba680d9b589e032065b86071c3f75473dc0d06736af0deb36aa2115de43d51.jpg)  
由于图模型的度要满足握手定理等基本约束要求，而且对于不同类型的图，其度序列也会有一些相应的数据特征。因此，并不是任意的自然数序列都可以构成图模型的度序列。对于任意给定的自然数序列，需要通过分析其数据特征来判断其是否为可图化序列。若是可图化序列，则可依据该序列数据来分析其所对应图的结构特征。"
可增广道,概念,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.2.3 最大匹配判定与构造']","{'实体类型': '概念', '定义': '两端点均为非饱和点的交错道'}",,3,"对于任意给定的一个二分图，首先讨论如何判断该图中某个给定的匹配是否为最大匹配。为此，引入交错道和可增广道的概念，具体如下：  
【定义10.5】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图， $M$是图$G$的某个匹配，若从𝐺中的某个结点到另一个结点之间存在一条通路，且该通路由属于$\cdot M$和不属于$M$的边交替构成，则称此通路为 𝑴 交错道。若 $M$ 交错道的两端点均为 $M$ 非饱和点，则称其为 𝑴 可增广道。  
例如，对于图10-35（a）所示匹配，$P=y_{1}x_{2}y_{5}x_{4}y_{3}x_{1}$是一条交错道，对于图10-35（b）所示匹配，$P=y_{1}x_{2}y_{5}x_{4}y_{3}x_{1}$则是一条可增广道，具体见图10-35（b）的粗线部分。  
![图10-35  交错道与可增广道  ](images/f5e335487e12a671cc013f6ede9981700aa6193018e616b34157cc9869d086b6.jpg)  
在1957 年，法国著名数学家贝尔格给出了判定某个匹配是最大匹配的充分必要条件。这就是著名的贝尔格定理，具体如下：  
【定理10.10】（贝尔格定理）设$G=\langle X,E,Y\rangle$是任意给定的一个二分图， 𝑀是图𝐺的某个匹配，则$M$是图$G$最大匹配的充要条件是$G$中不存在$M$可增广道。  
在1965 年，匈牙利的著名数学家埃德蒙兹基于贝尔格定理提出构造二分图最大匹配的著名算法，为纪念他的祖国，将该算法命名为匈牙利算法。算法基本思路如下：  
假设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，如果对于该图的某个匹配𝑀，结点集合𝑋的每个结点都是饱和结点，则该匹配就是最大匹配。否则，任取𝑋中的某个非饱和结点为起点做匹配$M$的交错道。此时，如果该交错道最后一个结点是饱和结点，如图10-36 中$P_{1}$所示，则匹配$M$就是最大匹配。否则，如果该交错道最后一个结点也是一个非饱和结点，则得到一条可增广道，如图10-36 中$P_{2}$所示。  
![图 10-36   对可增广道的增广 ](images/18f50be9390d6af7d21020996653e950e5f8bda427f6af3f0640cd631a139c62.jpg)  
不难看出，该交错道$P_{2}$中不属于$M$的所有边数比属于属于$M$的边数多一个，而且交错道中不属于$M$的所有边数也是互不相邻的，故可由这些边构成一个新的匹配$M^{*}$。由于${\mathbf{\nabla}}^{*}$的边数比$M$的边数多一个，故称$M^{*}$是对$M$的一个增广。继续上述过程，直到图中没有可增广道路为止，此时的匹配就是所求的最大匹配。  
从上述讨论不难发现，匈牙利算法的核心思想就是首先在当前匹配基础上寻找可增广道，找到可增广道后，就通过对该可增广道上所有边的匹配属性取反，即对可增广道上所有边的集合$ E(P)$与匹配$M$做集合的对称差运算$\oplus$，由此得到新的集合就是一个规模更大的新匹配，然后在这个新匹配的基础上继续寻找新可增广道，如此下去，直到没有可增广道路为止。  
对于任意给定的二分图$G=\langle X,E,Y\rangle$，匈牙利算法的具体计算流程如下：  
（1）任给初始匹配$M$；  
（2）若𝑋中任一结点均饱和，则$M$即为所求，算法结束，否则转（3）；  
（3）在𝑋中找到一非$M$饱和点$x$，置$S=\{x\}$，$T=\varnothing$；  
（4）若$N_{G}(S)=T$，则停止，否则任选一点$y\in N_{G}(S)-T$；  
（5）若𝑦为$M$饱和点转（6），否则：求一条从$x$到𝑦的$M$可增广路$P$，置$M=M\oplus P$，转（2）  
（6）由于$ y$是$M$饱和点，故$M$中有一边 $(y,u)$，置$S=S\cup\{u\}$，$T=T\cup\{y\}$，转（4）。算法中$N_{G}(S)$表示 $G$上与$S$中任一结点相邻的所有结点组成的集合，$\oplus$表示集合的对称差运算。下面以图10-37 为例，详细介绍匈牙利算法的具体执行过程：  
![图10-37 二分图 ](images/e75e6b51eaa2d7dcbd869cabf1198a4ab254d8c498cf74b11e8db5905f80f0b4.jpg)  
![图10-38 步骤1 效果图 ](images/a85e16b732f3f408c1a3f889dd66171d41954384c66b3a6769a239cb765226ce.jpg)  
（1）首先任给一个初始匹配$M=\{(x_{1},y_{1}),\;\;(x_{3},y_{5}),\;\;(x_{5},y_{3})\}$，如图10-38 所示。  
（2）$x_{2},x_{4}$非饱和，故$X$非饱和。确定其中一个非饱和点$x_{2}$，令${S}=\{x_{2}\}$，$T=\varnothing$。  
（3）$S$邻接结点集${N}_{G}(S)=\{y_{2},y_{3}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{3}\}$，选择$y_{3}$  
（4）$y_{3}$已饱和，因$M$中有边$(y_{3},x_{5})$，故令：  
$$
S=S\cup\{x_{5}\}=\{x_{2},x_{5}\},\ T=T\cup\{y_{3}\}=\{y_{3}\}
$$  
（5）因为$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{4},y_{5}\}$，选择${{y}}_{5}$  
（6）$y_{5}$已饱和，因为$M$存在边$(y_{5},x_{3})$，故令：
$$
S=S\cup\{x_{3}\}=\{x_{2},x_{3},x_{5}\},\,\,\,T=T\cup\{y_{5}\}=\{y_{3},y_{5}\}
$$  
（7）$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{4}\},$,选择$y_{2}$  
（8）$y_{2}$不饱和，故存在从$x_{2}$到$y_{2}$的可增广道$P$。对于当前匹配$M=\{(x_{1},y_{1}),(x_{3},y_{5}),$$(x_{5},y_{3})\}$，求得可增广路$P$如图10 −39 加粗部分所示，得到$P$的边集：  
$$
E(P)=\{(x_{2},y_{3}),(y_{3},x_{5}),(x_{5},y_{5}),(y_{5},x_{3}),(x_{3},y_{2})\}
$$  
按下十重新调整匹配$M$，得到如图10 −40 所示一个新匹配$M$  
$$
M=M\oplus E(P)=\{(x_{1},y_{1}),(x_{2},y_{3}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
10-39 步骤8 过程图  
图10-40 步骤8 过程图2  
（9）在新匹配下继续查找可增广道。查看$ X$是否饱和，显然${{x}}_{4}$非饱和，选择该非饱和点$x_{4}$，并令$S=\{x_{4}\}$，$T=\varnothing$。  
（10）$N_{G}(S)=\{y_{3}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{3}\}$，选择$y_{3}$  
（11）$y_{3}$已饱和，因为匹配$M$中存在$(y_{3},x_{2})$，故令：
$$
S=S\cup\{x_{2}\}=\{x_{2},x_{4}\},\,\,\,T=T\cup\{y_{3}\}=\{y_{3}\}
$$  
（12）$N_{G}(S)=\{y_{2},y_{3}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{2}\}$，选择$y_{2}$（13）$y_{2}$已饱和，因为匹配$M$中存在$(y_{2},x_{3})$，故令：  
$$
S=S\cup\{x_{3}\}=\{x_{2},x_{3},x_{4}\},\,\,\,T=T\cup\{y_{2}\}=\{y_{2},y_{3}\}
$$  
（14）$N_{G}(S)=\{y_{2},y_{3},y_{5}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{5}\}$，选择$y_{5}$（15）$y_{5}$已饱和，因为匹配$M$中存在了$(y_{5},x_{5})$，故令：  
$$
S=S\cup\{x_{5}\}=\{x_{2},x_{3},x_{4},x_{5}\},\,\,\,T=T\cup\{y_{5}\}=\{y_{2},y_{3},y_{5}\}
$$  
（16 ）$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{4}\}$，选择${\cdot}y_{4}$（17）$y_{4}$不饱和，故可求一条从$x_{4}$到$y_{4}$的可增广路$ P$。对于当前匹配：  
$$
M=\{(x_{1},y_{1}),(x_{2},y_{3}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
求得如图10 −41 加粗部分所示的可增广道路$P$， $P$的边集为：  
$$
E(P)=\{(x_{4},y_{3}),(y_{3},x_{2}),(x_{2},y_{2}),(y_{2},x_{3}),(x_{3},y_{5}),(y_{5},x_{5}),(x_{5},y_{4})\}
$$  
按下式重新调整匹配$M$，得到如图10 −43 所示的一个新匹配  
![](images/ee96514b37bbad784ca2a76b1641bd0dbdac20d6a3f2ab76c80847e37bff2151.jpg)  
至此，集合$\cdot X$已经饱和，求得的如下最大匹配：  
$$
M=\{(x_{1},y_{1}),(x_{2},y_{2}),(x_{3},y_{5}),(x_{4},y_{3}),(x_{5},y_{4})\}
$$  
设二分图$G$有${n}$个结点$m$条边，使用匈牙利算法最大匹配时，初始匹配可以空，故算法最多找$n$条可增广道，每找一条可增广路，最多比较$m$条边。因此，匈牙利算法的最坏时间复杂度为$O(m n)$。由此可见，匈牙利算法是一个有效算法。"
可平面图,概念,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.3.1  平面图的概念与性质']","{'实体类型': '概念', '定义': '可以画在同一个平面上，并且所有边除在结点处之外均不交叉的图'}",,3,"所谓平面图，直观地说就是可以将该图嵌入到某个平面上。如图10-46（a）所示，图模型的边有时不仅在结点处相交，而且还在某些非结点处有交叉，这些非结点处交叉点的边重叠特征显然会导致图模型不能嵌入在同一个平面上。因此，为了将图模型嵌入平面，首先必须适当调整该图中边的走向，以保证任意两条边不会在非结点处有交叉，如图10-46（b）所示。由此得到可平面图和平面图的相关概念。  
【定义10.6】设$G=\langle V,E\rangle$是任意给定的一个图模型，如果该图中有两条边在非结点处有交叉，则称这两条边为该图的交叉边，交叉的具体位置称为交叉点。如果可将图𝐺画在同一个平面上，并且所有边除在结点处之外均不交叉，则称图𝐺可嵌入平面，或称𝐺为可平面图，否则称该图为不可平面图或非平面图。对于可平面图𝐺，将其边不交叉的画法称为𝐺的平面嵌入表示。以平面嵌入方式表示的图可平面图𝐺称为平面图。对于一个平面图𝐺，若对其再加一条边就变成不可平面图，则称𝐺为最大平面图。  
![](images/ad5984e0ab09600028eb4068193d74e75743de0f027a20b4d084511a312873d4.jpg)  
![（a）完全二分图$K_{3,3}$  （b）无法消除交叉  ](images/aa69f9dcec49f0e95a534b493200688a98dae4f4be8a347fbd35c04b8c21413b.jpg)  
例如，对于图10-46（a）所示的图，该图有三对交叉边，即$(v_{1},v_{4})$和$(v_{2},v_{3}),~(v_{1},v_{4})$和$(v_{2},v_{5})$、$(v_{1},v_{5})$和$(v_{2},v_{3})$。由于可将该图表示成图10-46（b）的形式，故该图是一个可平面图。图10-46（b）所示的图就是一个平面图。显然，如果在该平面图上增加一条边，则该图就变成一个不可平面图，故该是一个最大平面图。再如，对于图10-47（a）所示的图模型，无论怎么调整边的走向都不能将其以平面嵌入方式表示，如图10-47（b）所示。故图10-47（a）所示的图模型为不可平面图或非平面图。  
在没有特别要求的情况下，通常将可平面图与平面图不加区分地统称为平面图。与一般图模型显著不同的是，平面图模型除了具有结点和边这两个基本构件之外，还有一般图模型所没有的面的概念，并且由进一步面衍生出边界的概念。因此，平面图是一类非常重要的特殊图模型，无论在理论上还是在应用方面都具有非常重要的价值，在印刷电路板的设计、城市管网设计与规划等多个领域得到实际应用。  
图论之父欧拉对平面图有着比较深刻的研究，发现并论证了平面图的结点、边和面之间的数量关系，提出了著名的欧拉公式。下面给出平面图中面的相关概念：  
【定义10.7】设$G=\langle V,E\rangle$是任意给定的一个平面图，由𝐺中边所包围且内部不包含结点与边的区域，称为$G$的一个面。区域面积有限的面称为有限面，区域面积无限的面称为无限面。对于$G$的任意一个面$R$，包围面$R$的所有边构成的回路称为面𝑅的边界，面𝑅边界中边的个数称为面$R$的次数或度，记为${\bf d e g}(R)$。  
通俗地说，如果把一个平面图画在平面上，然后用小刀沿着图的边将平面切开，那么整个平面就被切成若干块，其中每一块就是图的一个面。或者说，平面图的一个面就是平面中一个以边为界线不能再分割的区域块。例如，对于图10-46（b）所示的平面图，一共有六个面，其中有一个面是无限面，其余五个是有限面。需要注意的是，对于任何一个平面图，该图有且仅有一个无限面。下面的定理10.11 给出了平面图中面数与边数的数量关系：  
【定理10.11】平面图中所有面的次数之和等于边数的两倍。  
下面定理10.12 是著名的欧拉公式，给出了平面图中结点、边和面之间的数量关系：  
【定理10.12】设$G=\langle V,E\rangle$是任意给定的一个连通平面图，若它有$n$个结点、$m$条边、$r$ 个面，则有  
$$
n-m+r=2\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
【定理10.13】如果平面连通图$G$每个面的次数均为$l(l\geq3)$，则有：  
$$
m=l(n-2)/(l-2)
$$  
其中$m$为$G$的边数，$n$为$G$的结点数。  
【定理10.14】设$G$是一个$(n,m)$简单连通平面图，若$m>1$，则有：  
$$
m\leq3n-6\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
由定理10.4 的逆命题不成立，也就是说满足不等式$m\leq3n-6$的简单连通图不一定是平面图。但是对于一个简单连通图，若不满足$m\leq3n-6$，则一定是非平面图。因此，可用定理10.4 的结论证明某个简单连通图不是非平面图。  
【定理10.15】设$G$为一平面连通简单图，其结点数$n\geq4$，边数为$m$，且$G$不以$K_{3}$为其子图，则有$m\leq2n-4$。  
【定义10.8】对于是任意给定的一个图模型$G=\langle V,E\rangle$  
设$e=(u,v)$是$G$的任意一条边，如果在图$G$中删除该边并新增一个结点$w$及两条边$e_{1}=$$(u,w)$、$e_{2}=(w,v)$ ，则称该操作为对图$G$的边切割操作；  
设𝑤是$G$中任意一个度数为2 的结点，且是边${e_{1}=(u,w)}$和$e_{2}=(w,v)$的公共结点，如果在图$G$中删除结点$w$及边$e_{1},\,e_{2}$，并增加边$e=(u,v)$，则称该操作为对图$G$的结点贯通操作；  
对图$G$的边切割操作和结点贯通操作统称为对图$G$的同胚操作。  
显然，边切割操作和结点贯通操作是一对互逆操作。例如，对于图10-48 所示的两个图模型，可通过对边的切割操作将$G_{1}$变成$G_{2}$，也可通过对结点做贯通操作将$G_{2}$变成$G_{1}$。  
![图10-48  图的同胚操作与同胚关系  ](images/17b45e1706460a818a5492fb4df19f0ddd6b072e9cf57afef7db0852f0c58237.jpg)  
下面在同胚操作的基础上，引入如下两个图之间的同胚关系：  
【定义10.9】设$G_{1}=\langle V_{1},E_{1}\rangle$和$G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，如果可用同胚操作将其中一个转化为另外一个，则称$G_{1}$与$G_{2}$具有同胚关系，简称为$G_{1}$与$G_{2}$同胚。  
根据上述同胚的概念，可以得到如下关于平面图判定的库拉托夫斯基定理：  
【定理10.16】（库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是$G$的任何子图都不同胚于$K_{5}$或$K_{3,3}$。  
【定理10.17】(库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是𝐺的任何子图都不能通过边的收缩得到$K_{5}$或$K_{3,3}$。  
![图10-51 彼得森图收缩为$ K_{5}$](images/b6cd48c8bf37519af48b0cc187afdf1adc13d2c5e160a08fe418ce5c94762fd6.jpg)  
库拉托夫斯基定理是一个非常著名定理，通常将$K_{5}$和$K_{3,3}$称为库拉托夫斯基图。可以使用该定理判定一个图是否为平面图。例如，对于图$10{-}51\mathrm{a}$）所示的彼得森图，收缩其边$(v_{i},u_{i})(i=1,2,3,4,5)$，则可得到图$K_{5}$，见图10-51b)。故彼得森图不是平面图。  
值得注意的是，虽然库拉托夫斯基定理给出了平面图判定的充分必要条件，但是目前还没有基于该定理得到一个有效的判定算法。因此，对于一个比较复杂的图模型，要判定其是否为平面图，有时并不是一件容易的事情。"
可数集,概念,"['1.2.2 自然数的集合定义', '§ 1.2 可数集与不可数集', '二、自然数的归纳定义', '第一章  集合与计数基础']","{'实体类型': '概念', '定义': ['基数为有限数或与自然数集基数相同的集合', '对于任意一个无限集合A，从中任取一个元素做为第一个元素，记为x1；然后再从A−{x1}中任取一个元素作为第二个元素，记为x2；如此下去。由于A是一个无限集，故此这个过程可以无限进行下去，从而得到A的一个子集合{x1,x2,...,xn,...}', '可以用自然数集的子集来一一对应的集合'], '特点': ['可以通过自然数集进行一一对应', '可以找到它的一个子集与自然数集等势']}",,2,我们知道，基数是度量集合规模大小的指标，当集合基数为有限数时，该集合为有限集，其基数就是集合中元素的个数。当集合基数为无穷大时，该集合为无限集。对于无限集，如何使用基数度量其大小规模？例如，对于自然数集与有理数集，如何比较这两个无限集的基数，对于有理数集和无理数集，又如何比较两者的基数，等等。无穷大到底有多大？是否可以对无穷大的规模进行差异性分析，将其划分为不同层次或等级？本节将通过探讨与此相关的概念和问题，使得读者能够对无限集有着比较清晰的认识和本质性把握。
可数集与不可数集,概念,"['三、自然数的归纳证明', '1.2.1 无限集的度量问题', '一、皮亚诺公理', '1.2.2 自然数的集合定义', '§ 1.2 可数集与不可数集', '第一章  集合与计数基础']","{'实体类型': '概念', '定义': ['研究集合规模的度量问题，特别是无限集的度量', '研究集合是否可以通过自然数进行一一对应的分类'], '特点': '无限集具有无限延展特性，与有限集合有本质性差异', '应用': '实现对集合规模的度量'}",,3,"现考察集合规模的度量问题。直观上看，集合中元素数目越多集合的规模就越大。关键是如何界定集合中元素数目的多少？对于有限集，这个不成问题，可通过对集合中元素进行计数的方法解决。然而，对于无限集来说，问题就没这么简单了。例如对于下列问题：  
正整数集合$\{1,2,3,\ \cdots\ \}$和正整数平方集合$\{1^{2},2^{2},3^{2},\ \cdots\ \}$，哪个集合的元素更多？  
显然，正整数平方集合是正整数集合的一个真子集，因此正整数集合似乎应该更大一些。但这两个集合元素之间又显然存在一一对应关系。从传统有限集合计数的观点看，两者的数目又必定是相等的。这似乎存在一种矛盾。事实上，早在1638 年，意大利物理学家伽利略也发现了类似于这样的问题，但是他无法解决并感到困惑，便提出了所谓的伽利略悖论。  
其实，无限集所具有的无限延展特性使其与有限集合有着本质性差异，对有限集合进行精确计数的方式不再适用于对无限集合的度量。因此，必须采用同时适合有限集与无限集的新方法来实现对集合规模的度量。由此得到如下关于集合等势的概念：  
【定义1.15】设$A$ 和$B$ 是任意两个集合，如果$A$ 和$B$ 之间存在一一对应的关系：  
$$
\psi{\colon}A\to B
$$  
则称$\pmb{A}$ 与$\pmb{B}$ 等势，记为：$A^{\circ}B$  
显然，若 $\scriptstyle A=B$ ，则 $A^{\scriptscriptstyle\frown}B$ ，反之不然。  
【定理1.5】集合的等势满足如下三条基本性质：（1）自反性：对于任意集合$A$，有$A{\sim}A$；（2）对称性：对于任意两个集合$A$ 和$B$，如果$A{\sim}B$，则有$B{\sim}A$（3）传递性：对于任意三个集合$A$、$B$ 和$C$，如果$A{\sim}B$ 且$B{\sim}C$，则有$A{\sim}C$  
上述等势概念表达的仅仅是集合在数量规模上次序比较关系，要真正实现对无限集规模的度量，还需确定一个基本的规模度量单位作为度量标准或基准。显然，任何无限集都可生成一个子集与自然数集等势，因此可将自然数集合作为无限集规模度量的一种基准。下面着重介绍自然数的基本概念与性质。"
可数集合,概念,"['第一章  集合与计数基础', '§ 1.2 可数集与不可数集', '1.2.3 无限集的基数比较']","{'实体类型': '概念', '定义': '凡是与自然数集N等势的集合都称为可数集合，该类集合的基数记为ℵ0，读作阿列夫零', '基本性质': '（1）两个有限集合等势，当且仅当它们具有相同的元素个数；（2）有限集合不可能与其任何真子集合等势；（3）可数集合可以与其可数的真子集等势'}",,3,"从前面的讨论不难看出，对于任意一个给定的自然数$n$，该自然数其实就是对所有含有$n$ 个元素集合的一种抽象。例如，自然数3 就是对所有含有3 个元素集合的抽象，或者说自然数3 就是将所有含有3 个元素的集合房子一起组成集族。因此，自然数可以根据集合中所含元素个数为标准对所有有限集进行分类，从而实现对有限集基数的度量和比较。  
对无限集基数的度量和比较则没有这么简单。如前所述，任意一个无限集合，都可以找到它的一个子集与自然数集等势。因此，自然数集应当是规模最小的一种无限集合，可用自然数集作为无限集基数的最小度量单位或者度量基准。据此得到如下定义：  
【定义1.19】凡是与自然数集$N$ 等势的集合都称为可数集合，该类集合的基数记为$\aleph_{0}$，读作阿列夫零。  
根据上述例题，可以得到关于有限集合和可数集合的如下基本性质：  
（1）两个有限集合等势，当且仅当它们具有相同的元素个数；（2）有限集合不可能与其任何真子集合等势； （3）可数集合可以与其可数的真子集等势。  
由此可知，元素个数不相等的无限集之间仍有可能存在等势关系。因此，无限集合的基数已经不能通过集合中元素的个数来度量，或者说不能用一个自然数来度量，而是需要以自然数集或其它无限集合的基数为标准进行度量。  
现在考察这样的一个问题，除了可数集合之外，还有没有其它的无限集合？或者说，是否每一个无限集合都能够与自然数集合建立一一对应的关系？事实上并非如此，例如开区间(0, 1)就不能与自然数建立等势关系，所有与开区间(0, 1)等势的集合构成了另外一类不同规模的集合，称之为不可数集合。其具体定义如下：  
【定义1.20】开区间(0, 1)称为不可数集合，其基数记为ℵ，读作阿列夫；凡是与开区间(0, 1)等势的集合都称为不可数集合。  
因此，不可数集合是比可数集合规模更大的一种无限集合类型。当然，还可以考虑不可数集合的幂集、不可数集合幂集的幂集等等，由此可以构造出很多种不同基数的无限集合。关于这些无限集合基数及其性质的讨论已经超出了离散数学的范畴，有兴趣的读者可以参阅实变函数理论中与连续统相关的内容。"
可满足公式,概念,"['第四章  谓词演算与推理', '§ 4.2  谓词公式与等值演算', '4.2.3 谓词公式的解释与分类']","{'实体类型': '概念', '定义': '不是矛盾公式的谓词公式', '关系': '有效公式的否定为矛盾公式；矛盾公式的否定为有效公式；有效公式一定为可满足公式'}",,3,"我们知道，对于一个命题公式，确定其真值取值状态是比较简单的，只需对命题公式中各个变量逐个指派真值便可得到命题公式的真值，而且在命题变量不是太多的情况下还可通过对命题变量真值指派的各种状态进行枚举的方式列出命题公式的真值表。然而，要确定一个谓词公式的真值取值状态，通常就没有这么简单了。  
例如，要确定谓词公式$(\forall x)(H(x){\rightarrow}D(x))$的真值，首先要确定其个体域，然后还要确定谓词$H(x)$和$D(x)$的具体含义。如果使用全总个体域$H(x)$表示 $x$是人$D(x)$表示 $x$会死的，则该谓词公式的取值为真，若将$D(x)$表示为 $x$是勇敢的，则谓词公式的取值为真为假。  
一般来说，对于任意给定的谓词公式，其含义与真值取值不仅依赖于个体域，依赖于公式中各个个体变量的取值状况，还依赖于对公式中谓词符号、函数符号、常量符号具体含义的确认，这些所有的依赖信息构成对谓词公式的解释。如果不对谓词公式中常量符号、变量符号、函数符号、谓词符号进行具体的解释，则公式就没有确定的含义和确定的真值取值.下面给出关于谓词公式解释的具体定义：  
【定义4.15】 谓词公式$G$的每一个解释$I$由如下四个部分组成：  
（1）确定非空的个体域集合$D$；  
（2）确定公式$G$ 中的每个常量符号的含义，即指定$D$ 中的某个特定的元素；  
（3）确定公式$G$ 中的每个$n$元函数的具体形式，即对于公式$G$ 中每个$n$元函数分别指定一个从$D^{n}$ 到$D$ 中的特定函数与之对应；  
（4）确定公式$G$ 中的每个$n$元谓词符号的具体形式，即对于公式$G$ 中每个$n$元谓词符号分别指定一个从$D^{n}$ 到$\{0,1\}$的特定函数与之对应。  
易知，对于任意一个给定的谓词公式，如果该公式是封闭公式，即不含有任何自由个体变量，则该公式在任何解释下均有确定的真值。  
由上述例题可知，与命题公式一样，有些谓词公式在有些解释下为真，在另外一些解释下为假；而有些谓词公式则在所有解释下均为真；还有一些谓词公式在所有解释下均为假。由此可以得到如下有效公式、矛盾公式和可满足公式的定义：  
【定义4.16】 对于任意一个给定的谓词公式$G$，如果$G$ 在其所有的解释$I$下的真值取值为真，则称$G$ 称为有效公式；如果$G$ 在其所有的解释$I$下的真值取值都为假，则称$G$为矛盾公式；如果$G$ 不是矛盾公式，则称其为可满足公式。  
从上述定义可知三种特殊公式之间具有如下关系：有效公式的否定为矛盾公式；矛盾公式的否定为有效公式；有效公式一定为可满足公式。"
可满足式,性质,"['第三章  命题演算与推理', '§ 3.2 命题公式与等值演算', '3.2.1 命题公式的基本知识', '三、命题公式的基本类型']","{'实体类型': '性质', '条件': '命题公式不是矛盾式', '关系': '命题公式G为可满足式，当且仅当至少存在一种解释I，使得G为真'}",,4,"如表3-7 所示，有些命题公式在任何解释下均为真，例如 $(P\land(P\rightarrow Q))\rightarrow Q$；有些命题公式则在任何解释下均为假，例如$\neg(P\to Q)\land Q$；有些命题公式则在一些解释下为真、在另一些解释下为假，例如$P\rightarrow Q$。  
表3-7   命题公式真值的基本类型
![](images/ada5d39d23c2aab3e5ff74aa9eea0cba51046190f43c79f376715f46f49cb38f.jpg)  
![](images/cd9a8308cc683710575b4eca9243b69a0a582e5f86c663d5bdcde36ca15c8940.jpg)  
由此可将命题公式分为永真、永假和可满足这三种基本类型，具体定义如下：  
【定义3.12】对于任给定的命题公式$G$  
（1）如果$G$在所有解释下的真值取值都为真，则称其为永真公式或重言式；  
（2）如果$G$在所有解释下的真值取值都为假，则称其为永假公式或矛盾式；  
（3）如果命题公式不是矛盾式，则称其为可满足式。  
根据上述定义，不难看出这三类公式之间的基本关系：  
（1）命题公式$G$为永真式，当且仅当¬G为永假式。  
（2）若命题公式$G$为永真式，则𝐺必为可满足式；反之不然。  
（3）若命题公式$G$为可满足式，当且仅当至少存在一种解释$I$，使得$G$为真。"
可行流,性质,"['第十章  特殊图模型与算法', '§ 10.4 网络流图及其优化问题', '10.4.1 流网络与切割']","{'实体类型': '性质', '定义': '满足容量限制、斜对称、流守恒的网络流', '特点': '一条边的流不能超过其容量，点间净流相反，除源汇点外结点净流和为0'}",,3,"首先介绍流网络模型的相关基本概念及其数据描述。如同每条公路有运输量、每根水管有最大流量限制一样，网络流图的每条边都有容量，或者说每条边都有一定的流量。网络流图其实就是每条边具有附带容量（可理解为权值）的有向图。其具体定义如下：  
【定义10.4.1】设有向图$G=\langle V,E\rangle$，$V$中包含一个源结点𝑠和一个汇结点$t$，且每条边$(u,v)\in E$均有一个非负容量$c(u,v)\geq0$，若$(u,v)\notin E$，则规定其容量$c(u,v)=0$，此时称有向图$G$是一个网络流图，简称为流网络或网络。源结点$s$即起点，汇结点$t$即终点。网络流是定义在网络$G$中关于边的一个实函数，用$f(u,v)$表示有向边$(u,v)\in E$上结点$ u$到结点$v$的网络流。$f(u,v)$表示$u$ 到$v$的净流。  
例如，如果$_{u}$到$v$有6 个单位的实际流，且$v$到$u$有3 个单位的实际流，那么$f(u,v)=$3，$f(v,u)=-3$，互为相反数。净流是实际通过的流量矢量和，可类比合力的概念。  
满足以下三个性质的网络流$f$称之为可行流：  
（1）容量限制：对所有的$(u,v)\in E$，都有$f(u,v)\leq c(u,\textit{}v)$。即一条边的流不能超过它的容量。这也很容易理解，如同自来水管的水流自然不会超过水管本身的容量。  
（2）斜对称：对所有$(u,v)\in E$，都有$f(u,v)=-f(v,u)$。即点$\cdot u$到$v$的净流必须与点𝑣到$u$的净流相反。可以类比物理中矢量概念，如作用力与反作用力，强调的是其方向性。  
（3）流守恒：对所有$u\in V-\{s,t\}$，都有$\textstyle\sum_{v\in V}f(u,v)=0$。即除源结点$𝑠$和汇结点$𝑡$外，其余每个结点的净流之和为0。  
![图10-68 网络及可行流  ](images/bada5974bba3db0db4c82fa8e3076a8834542abfa1641f17fac232a32e6fee29.jpg)  
例如，如图10-68 所示，网络中定义网络流$f(u,v)$是一条可行流。图中每条边所对应的序偶表示该边的容量和流量，第一个数字表示边的容量，第二个数字表示边的流量。  
下面结合图10-68 所示网络实例介绍网络流模型中与边相关的几个概念。可根据边的容量与流的大小关系对网络中的边进行分类：  
（1）满足$f(u,v)=c(u,v)$的边称为饱和边，如边(1,2)、 (2,3)  
（2）满足$f(u,v)<c(u,v)$的边称为非饱和边，如边(2,4)。  
（3）满足 $f(u,v)=0$ 的边称为零流边，如边 (3,4) ；满足 $f(u,v)>0$ 的边称为非零流 边，如边(5,4)。  
（4）既不是零流边也不是饱和边的边，称为弱流边，如边(5,6)  
如果把图10-78 看作是一个公路网，6 个结点分别表示6 座城镇，每条边上的权数表示两城镇间的距离。若现在需要从起点1 将一些物资运送到终点6，应怎样选择路线才能使总运输距离最短。我们知道，这样一类问题称为最短路径问题。类似的，如果把图10-1看作为一个输油管道网，结点1表示为发送点，结点6表示为接收点，其它点表示为中转站，各边的权数表示该段管道的最大运输油量。那么如何安排输油线路才能使从1到6的总运输量最大。这样一类问题就是最大流问题。  
最大流问题是网络优化中的一个典型的问题，简单地说，就是在满足容量约束的前提下将尽可能多的流从源结点流向汇结点。因此，最大流问题就是求流网络$G$中使其流量$f$达到最大的一个可行流，该可行流即为最大流。具体定义如下：  
【定义10.4.2】设有向图$G=\langle V,E\rangle$是任意给定的一个网络流图，若$f$是$G$ 中流量最大的的可行流，则称该可行流$f$是$G$ 的最大流，构构造网络流图$G$ 中最大流的问题，就称为网络流图的最大流问题。  
为了实现对最大流问题的求解，必须对网络流图中的增流空间进行合理的度量，通常使用一种名为残留网络的图模型实现这项工作。残留网络的具体定义如下：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图， $f$为$G$的一个流，对于$G$的任意一条边$(u,v)$，在不超过容量$c(u,v)$条件下，从$u$到$v$可压入的额外流量，称为$(u,v)$的残留容量。由$G$中所有边残留容量构成的带权有向图称为$G$的残留网络，记为$G_{f}=\langle V,E_{f}\rangle$。  
若$c_{f}(u,v)$为残留网络$G_{f}$中边$(u,v)$的残留容量，且边$(u,v)\in E$或边$(v,u)\in E$，则$(u,v)\in$$E_{f}$,$\,c_{f}(u,v)=c(u,v)-f(u,v)\,$。例如，若设$(u,v)$当前流量为(4,3)，此时$c(u,v)=4$，$f(u,v)$）$=3$，则有：$c_{f}(u,v)=1$。  
需要注意的是，残留网络具有这样的性质：假设从$_{.}u$到$v$已经有了3 个单位流量，那么从反方向上看，也就是从$v$ 到$u$ 就有了3 个单位的残留容量，这时$c_{f}(v,u)=3$。换句话说，从$u$ 到$v$ 有3 个单位流量，那么从$v$到$u$ 就有了将这3 个单位流量压回去的能力。因此，残留网络结点之间通常由双向带权边进行联结。例如，对于图10-69（a）所示的一个流网络$G$，图10-69（b）则表示该流网络𝐺的残留网络。  
![图10-69 流网络及其残留网络 ](images/d65d1c72064671125468548ae171a28ede5424f1d36d601972ed76c90131fc8c.jpg)  
对于任意给定的一个网络流图$G=\langle V,E\rangle$，可以通过其残留网络$G_{f}=\langle V,E_{f}\rangle$求得$G$的最大流。基本思路如下：首先，对所有的结点令初始状态时流的值为0，即对于$\forall u,v\in V$，有$f(u,v)=0$。然后，通过迭代方式其残留网络中不断寻找源点𝑠到汇点$t$之间的流量增广路径来增加网络流量值，直到残留网络没有这样的增广路径为止。  
因此，在残留网络$G_{f}=\langle V,E_{f}\rangle$寻找流量增广路径是最大流求解算法的关键。为正确理解该算法，现给出流网络增广路径的具体定义：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，$G_{f}=\langle V,E_{f}\rangle$为$G$在流$f$下的一个残留网络，则$G_{f}=\langle V,E_{f}\rangle$中任意一条从源点$s$到汇点$t$的简单路径$p$称为$G=\langle V,E\rangle$的一条流量增广路径，简称为增广路径。  
事实上，可将增广路径形象地理解为网络流图$G$中从源点𝑠到汇点𝑡的一条不违反流网络边容量限制的路径，并向这条路径压入一定的流量，以增加整个网络的流量值。例如，图10-69（b）所示的残留网络存在这样一条如图10-70 中加粗有向边所示的增广路径。  
![图10-70 增广路径 ](images/1e52dc98ce8f5b49283b093dbb72c0d5308ccdc9782306a98cb168474d58608f.jpg)  
![图10-71 流网络的一个切割](images/c52dd38b6f7d2bc46bb57e2440709d67355577a7b3d5fb2e920f10a5bfeb8598.jpg)  
若将图10-70 所示增广路径在流网络所对应每条边的流量增加4 个单位，得到一个新的流网络，其流量比原网络多4 个单位。然后，在新流网络所对应的残留网络中继续寻找新增广路径，直到找不到新增广路径为止。显然，现在的问题是：如果在残留网络$G_{f}=$$\langle V,E_{f}\rangle$中找不到增广路径，此时该残留网络所对应的流$f$是否就是流网络$G=\langle V,E\rangle$的最大流？要解决这个问题，必须进一步引入流网络切割的相关概念，具体如下：  
【定义10.4.4】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，如果将$G$的结点集合𝑉划分为𝑆和$T=V-S$两部分，使得源点$s\in S$且$t\in T$，则称$(S,T)$是$G=\langle V,E\rangle$的一个切割，简称为割。从集合 𝑆 到集合 𝑇 的所有有向边容量之和称为切割 $(S,T)$ 的容量，穿过切割 $(S,T)$所有边流量的代数和流量称为切割$(S,T)$的净流量，记为$f(S,T)$。  
主要注意的是，定义10.4.4 中边的流量带有正负方向，如果流从结点𝑆流向$T$，则该边的流量值为正，如果流从结点𝑇流向𝑆，则该边的流量值为负。例如，对图10-69（a）所示的流网络，可画一个如图10-71 所示的切割$(S,T)$，其容量为：  
$$
c(u,w)+c(v,x)=12+14=26
$$  
穿过该切割的净流量为：  
$$
f(u,w)+f(v,x)-f(w,v)=12+11-4=19
$$  
显然，对于任意一个切割，穿过该切割的净流量上界就是该切割的容量，即穿过切割的净流量不可能超过割的容量。由于流网络中所有切割的流都相等并且等于网络的流，因此，网络最大流必然无法超过网络的最小割。由此得到如下最大流最小割定理：  
【定理10.4.1】（最大流最小割定理）设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和$t$分别为其源点和汇点，则$G=\langle V,E\rangle$的最大流量等于其最小割切的容量。对于$G=\langle V,E\rangle$上的任意一个流$f$，以下三个结论彼此等价：  
(1) $f$是流网络$G=\langle V,E\rangle$的一个最大流；  
(2) 流网络$G=\langle V,E\rangle$的残留网络中不包括任何增广路径；  
(3) 存在流网络$G=\langle V,E\rangle$的某个切割$(S,T)$，满足：
$$
f(S,T)=c(S,T)
$$"
可达性,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.2 可达性及其判定']","{'实体类型': '概念', '定义': '对于给定的有向或无向线图，任意两个结点之间存在长度至少为1的通路则称可达，否则称不可达', '特点': '刻画图中两个结点之间的连通性关系，无向图中是双向的，有向图中不一定对称'}",,3,"如前所述，对于任意一个给定的线图模型，图中任意两个指定结点之间的通路可能有很多条，有的可能会长一些，有的可能会短一些，此时，一般关心的是哪条通路最短。还有一种情况，就是图中可能存在两个或者多个结点，它们之间根本没有通路相联结，例如，在图8。3。1 表示的城市高铁运输线路图中，北京和台北之间就没有通路联结，这也是一种比较重要的情形。 由此得到如下图中结点可达性及其短程线的相关概念  
【定义8.23】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，对于𝑉中的任意两个结点$v_{i},v_{j}$，如果从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$之间存在长度至少为1 的通路，则称从$v_{i}$到$v_{j}$可达，否则称从$v_{i}$到$v_{j}$不可达。 如果图$G$ 中从$v_{i}$到$v_{j}$可达，则从$v_{i}$到$v_{j}$长度最短的通路称为从$v_{i}$到$v_{j}$的短程线，该短线程的长度称从$\boldsymbol{v}_{i}$到$v_{j}$的距离，记为 $d\big(v_{i},v_{j}\big)$ 。如果从$\boldsymbol{v}_{i}$到$v_{j}$不可达，则记为 $d\bigl(v_{i},v_{j}\bigr)=\infty$ 。  
从上述定义可以看出，结点之间的可达性刻画的是图中两个结点之间的某种连通性关系。对于无向图来说，这种连通性关系显然是双向的，故若从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$ 可达，则从 $v_{j}$ 到 $v_{i}$ 可达，反之亦然；且有 $d\bigl(v_{i},v_{j}\bigr)=d\bigl(v_{j},v_{i}\bigr)$ 。对于有向图来说，这种连通性关系不一定满足对称性，故若从$v_{i}$到$v_{j}$ 可达，则不一定有从 $v_{j}$ 到 $v_{i}$ 可达，也不一定有 $d\big(v_{i},v_{j}\big)=$$d\big(v_{j},v_{i}\big)$ 。  
如前所述，图模型$G=\langle V,E\rangle$中结点之间的通路由该图所表示二元关系不断对其自身作复合运算产生，长度为$k$的通路其实就是二元关系$k$次幂运算的结果。因此，由图$G=\langle V,E\rangle$中结点之间可达性产生的二元关系其实就是图$G=\langle V,E\rangle$所表示二元关系的传递闭包。  
我们知道，对于有限集合$ V=\{v_{1},v_{2},\ldots,v_{n}\}$上的任意一个二元关系，构造其的传递闭包最多只需要进行$\cdot n$次方幂运算就可以了。也就是说，对于任意一个$n$结点的图模型，联结其中两个可达的结点最多只需要做$ n$次方幂运算，亦即对于图中任意两个可达结点，必然存在一条长度不大于$ n$的通路或回路联结这两个结点。  
以上是从二元关系及其传递闭包的角度对图中可达结点的联结通路或回路长度的分析，下面从图模型的角度对上述分析结论进行严格证明。  
【定理8.3】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中两个不同的结点$u$ 和 $v$，存在一条从$u$到 $v$通路，则必然存在一条长度不大于$:n-1$ 的基本通路。  
可类似证明如下基本回路存在性定理：  
【定理8.4】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中结点$v$，存在一条从$v$ 到 $v$回路，则必然存在一条长度不大于$^{\cdot n}$ 的基本回路。  
由以上两个定理可知，对于任意含有$ n$个结点的有向或无向线图$G=\langle V,E\rangle$，如果图从结点$u$ 到${v}$是可达的，那么必然存在从$u$ 到$v$且长度不超过$n$通路或回路。因此，根据通路或回路的计数方法，最多只需计算该图所对应邻接矩阵的$n$幂，即可判定图中任意两个结点之间是否可达。具体地说，假设𝐴是图$G=\langle V,E\rangle$的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则$B_{n}$中的元素为：  
$$
b_{i j}^{(n)}=a_{i j}^{(1)}+a_{i j}^{(2)}+\cdots+a_{i j}^{(n)}
$$  
显然，$b_{i j}^{(n)}$表示图$G$中从结点$v_{i}$到结点$v_{j}$的长度不超过$n$的通路总数，特别地，若$ i=j$，则$b_{i j}^{(n)}$为结点$v_{i}$到自身的长度不超过$n$的回路总数。因此，若$b_{i j}^{(n)}=0$，则结点$v_{i}$到$v_{j}$不可达，否则，结点$v_{i}$到$v_{j}$可达。由此得到有如下定理关于图模型的可达性定理：  
【定理8.5】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，$A=(a_{i j})_{n\times n}$为图 $G$ 的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则当$v_{i}\neq v_{j}$时，若${b_{i j}}^{(n)}>0$，则$v_{i}$到$v_{j}$可达，否则不可达，且有：  
$$
d\big(\boldsymbol{v}_{i},\boldsymbol{v}_{j}\big)==\begin{cases}\infty,&&\text{若}a_{ij}{}^{(1)},a_{ij}{}^{(2)},\cdots,a_{ij}{}^{(n)}\text{均为 0}\\\min\{a_{ij}^{(m)}|m=1,2,\cdots,n\},&&\text{否则}\end{cases}
$$  
在图模型的实际应用过程中，很多时候只需知道结点之间是否可达，而无需知道距离及通路数，由此得到如下可达性矩阵的定义：  
【定义8.24】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，则令$P=(p_{i j})_{n\times n}$是一个$n$阶矩阵，且满足：  
$p_{ij}=\begin{cases}1\:,~~~~~~结点从v_{i}到v_{j}至少存在一条长度不小于1的通路\\0\:,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~否则\end{cases}$    (8-8)  
称矩阵 $P$ 为图 $G$ 的可达性矩阵。  
从上述定义可以看出，可达性矩阵中的元素$\cdot p_{i j}$表示了从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$的可达性关系，表达了结点之间通过结点邻接关系的传递性得到可达性关系。因此，图中结点之间的可达性关系就是该图所表达邻接关系的传递闭包，可达性矩阵其实就是图邻接关系的传递闭包关系矩阵，即为可达性关系的关系矩阵。 显然，无向图的可达性矩阵为对称矩阵。  
若已知$B_{n}$ ，则只需将$B_{n}$中非零元素写成1，便可得到可达性矩阵 $P$，即有：  
$$
p_{i j}=\left\{\!\!\begin{array}{l l}{1,\qquad}&{b_{i j}^{\phantom{}(n)}\neq0}\\ {0,\qquad}&{b_{i j}^{\phantom{}(n)}=0}\end{array}\right.
$$  
由于可达性矩阵$P$是布尔矩阵，矩阵$P$中的元素$p_{i j}$只表示结点$v_{i}$到$v_{j}$是否可达，并不表示至于其通路数目及长度。因此，通过计算矩阵 $B_{n}$获得可达性矩阵$P$的方法效率较低。事实上，可类似于计算二元关系的闭包，使用邻接矩阵𝐴的布尔运算计算可达性矩阵$P$。  
【定理8.6】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，矩阵$A$和$P$分别是图$G$在该结点次序下的邻接矩阵和可达性矩阵，则有：  
$$
P=A^{(1)}\lor A^{(2)}\lor\cdots\lor A^{(k)}\lor\cdots\lor A^{(n)}
$$  
其中$A^{(k)}$表示进行矩阵$A$的$k$次布尔幂运算。"
可达性矩阵,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.2 可达性及其判定']","{'实体类型': '概念', '定义': '表示图中结点之间可达性关系的矩阵', '特点': '元素表示结点之间的可达性，无向图的可达性矩阵为对称矩阵'}",,3,"如前所述，对于任意一个给定的线图模型，图中任意两个指定结点之间的通路可能有很多条，有的可能会长一些，有的可能会短一些，此时，一般关心的是哪条通路最短。还有一种情况，就是图中可能存在两个或者多个结点，它们之间根本没有通路相联结，例如，在图8。3。1 表示的城市高铁运输线路图中，北京和台北之间就没有通路联结，这也是一种比较重要的情形。 由此得到如下图中结点可达性及其短程线的相关概念  
【定义8.23】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，对于𝑉中的任意两个结点$v_{i},v_{j}$，如果从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$之间存在长度至少为1 的通路，则称从$v_{i}$到$v_{j}$可达，否则称从$v_{i}$到$v_{j}$不可达。 如果图$G$ 中从$v_{i}$到$v_{j}$可达，则从$v_{i}$到$v_{j}$长度最短的通路称为从$v_{i}$到$v_{j}$的短程线，该短线程的长度称从$\boldsymbol{v}_{i}$到$v_{j}$的距离，记为 $d\big(v_{i},v_{j}\big)$ 。如果从$\boldsymbol{v}_{i}$到$v_{j}$不可达，则记为 $d\bigl(v_{i},v_{j}\bigr)=\infty$ 。  
从上述定义可以看出，结点之间的可达性刻画的是图中两个结点之间的某种连通性关系。对于无向图来说，这种连通性关系显然是双向的，故若从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$ 可达，则从 $v_{j}$ 到 $v_{i}$ 可达，反之亦然；且有 $d\bigl(v_{i},v_{j}\bigr)=d\bigl(v_{j},v_{i}\bigr)$ 。对于有向图来说，这种连通性关系不一定满足对称性，故若从$v_{i}$到$v_{j}$ 可达，则不一定有从 $v_{j}$ 到 $v_{i}$ 可达，也不一定有 $d\big(v_{i},v_{j}\big)=$$d\big(v_{j},v_{i}\big)$ 。  
如前所述，图模型$G=\langle V,E\rangle$中结点之间的通路由该图所表示二元关系不断对其自身作复合运算产生，长度为$k$的通路其实就是二元关系$k$次幂运算的结果。因此，由图$G=\langle V,E\rangle$中结点之间可达性产生的二元关系其实就是图$G=\langle V,E\rangle$所表示二元关系的传递闭包。  
我们知道，对于有限集合$ V=\{v_{1},v_{2},\ldots,v_{n}\}$上的任意一个二元关系，构造其的传递闭包最多只需要进行$\cdot n$次方幂运算就可以了。也就是说，对于任意一个$n$结点的图模型，联结其中两个可达的结点最多只需要做$ n$次方幂运算，亦即对于图中任意两个可达结点，必然存在一条长度不大于$ n$的通路或回路联结这两个结点。  
以上是从二元关系及其传递闭包的角度对图中可达结点的联结通路或回路长度的分析，下面从图模型的角度对上述分析结论进行严格证明。  
【定理8.3】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中两个不同的结点$u$ 和 $v$，存在一条从$u$到 $v$通路，则必然存在一条长度不大于$:n-1$ 的基本通路。  
可类似证明如下基本回路存在性定理：  
【定理8.4】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中结点$v$，存在一条从$v$ 到 $v$回路，则必然存在一条长度不大于$^{\cdot n}$ 的基本回路。  
由以上两个定理可知，对于任意含有$ n$个结点的有向或无向线图$G=\langle V,E\rangle$，如果图从结点$u$ 到${v}$是可达的，那么必然存在从$u$ 到$v$且长度不超过$n$通路或回路。因此，根据通路或回路的计数方法，最多只需计算该图所对应邻接矩阵的$n$幂，即可判定图中任意两个结点之间是否可达。具体地说，假设𝐴是图$G=\langle V,E\rangle$的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则$B_{n}$中的元素为：  
$$
b_{i j}^{(n)}=a_{i j}^{(1)}+a_{i j}^{(2)}+\cdots+a_{i j}^{(n)}
$$  
显然，$b_{i j}^{(n)}$表示图$G$中从结点$v_{i}$到结点$v_{j}$的长度不超过$n$的通路总数，特别地，若$ i=j$，则$b_{i j}^{(n)}$为结点$v_{i}$到自身的长度不超过$n$的回路总数。因此，若$b_{i j}^{(n)}=0$，则结点$v_{i}$到$v_{j}$不可达，否则，结点$v_{i}$到$v_{j}$可达。由此得到有如下定理关于图模型的可达性定理：  
【定理8.5】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，$A=(a_{i j})_{n\times n}$为图 $G$ 的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则当$v_{i}\neq v_{j}$时，若${b_{i j}}^{(n)}>0$，则$v_{i}$到$v_{j}$可达，否则不可达，且有：  
$$
d\big(\boldsymbol{v}_{i},\boldsymbol{v}_{j}\big)==\begin{cases}\infty,&&\text{若}a_{ij}{}^{(1)},a_{ij}{}^{(2)},\cdots,a_{ij}{}^{(n)}\text{均为 0}\\\min\{a_{ij}^{(m)}|m=1,2,\cdots,n\},&&\text{否则}\end{cases}
$$  
在图模型的实际应用过程中，很多时候只需知道结点之间是否可达，而无需知道距离及通路数，由此得到如下可达性矩阵的定义：  
【定义8.24】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，则令$P=(p_{i j})_{n\times n}$是一个$n$阶矩阵，且满足：  
$p_{ij}=\begin{cases}1\:,~~~~~~结点从v_{i}到v_{j}至少存在一条长度不小于1的通路\\0\:,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~否则\end{cases}$    (8-8)  
称矩阵 $P$ 为图 $G$ 的可达性矩阵。  
从上述定义可以看出，可达性矩阵中的元素$\cdot p_{i j}$表示了从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$的可达性关系，表达了结点之间通过结点邻接关系的传递性得到可达性关系。因此，图中结点之间的可达性关系就是该图所表达邻接关系的传递闭包，可达性矩阵其实就是图邻接关系的传递闭包关系矩阵，即为可达性关系的关系矩阵。 显然，无向图的可达性矩阵为对称矩阵。  
若已知$B_{n}$ ，则只需将$B_{n}$中非零元素写成1，便可得到可达性矩阵 $P$，即有：  
$$
p_{i j}=\left\{\!\!\begin{array}{l l}{1,\qquad}&{b_{i j}^{\phantom{}(n)}\neq0}\\ {0,\qquad}&{b_{i j}^{\phantom{}(n)}=0}\end{array}\right.
$$  
由于可达性矩阵$P$是布尔矩阵，矩阵$P$中的元素$p_{i j}$只表示结点$v_{i}$到$v_{j}$是否可达，并不表示至于其通路数目及长度。因此，通过计算矩阵 $B_{n}$获得可达性矩阵$P$的方法效率较低。事实上，可类似于计算二元关系的闭包，使用邻接矩阵𝐴的布尔运算计算可达性矩阵$P$。  
【定理8.6】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，矩阵$A$和$P$分别是图$G$在该结点次序下的邻接矩阵和可达性矩阵，则有：  
$$
P=A^{(1)}\lor A^{(2)}\lor\cdots\lor A^{(k)}\lor\cdots\lor A^{(n)}
$$  
其中$A^{(k)}$表示进行矩阵$A$的$k$次布尔幂运算。"
可重复r-组合,概念,"['第一章  集合与计数基础', '§ 1.3 有限集的基本计数技术', '1.3.3 排列计数与组合计数', '三、可重复的组合']","{'实体类型': '概念', '定义': '从给定的重集中任意取出r个元素组成的子重集', '特点': '元素可以重复'}",,4,"考察如下可重复的组合问题：从包含苹果、橙子和梨子的筐中任取4 个水果招待客人，假设筐中苹果、橙子和梨子的个数均多于4 个且不关心取水果的次序，问有多少种取法？  
可对这4 个水果的取法做如下枚举：  
4 个苹果；4 个橙子；4 个梨子；3 个苹果，1 个橙子；3 个苹果，1 个梨子；3 个橙子，1 个苹果；3 个橙子，1 个梨子；3 个梨子，1 个苹果；3 个梨子，1 个橙子；2 个橙子，2 个苹果；2 个橙子，2 个梨子；2 个梨子，2 个苹果；2 个橙子，1 个苹果，1 个梨子；2 个苹果，1 个梨子，1 个橙子；2 个梨子，1 个苹果，1 个橙子。  
由此可知取法一共有15 种。当水果种类或取出数目比较大时，这种枚举方法显然是不可行的。在这个问题中，可以将包含苹果、橙子和梨子的筐子分别看成是一个重集。由于不考虑取水果的次序，因此可将该问题看成是一种基于重集的可重复的组合数计算问题。  
下面具体介绍可重复的组合数计算问题的相关概念及解法。  
【定义1.25】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的重集，从该重集中任意取出$r$ 个元素组成一个子重集，称每一个这样的子重集为一个可重复$r\cdot$-组合，可重复$r\cdot$组合的个数称为可重复$r$-组合数。  
下面结合一个具体实例详细介绍可重复$r\cdot$-组合数的计算问题。  
【定理1.18】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的$m$ 元重集，且重集中每个元素的从数均不小于 $r$ ，则基于该重集的可重复 $r\cdot$ - 组合数为 $C(m-1+r,\ r)$ 。"
可重复r-组合数,性质,"['第一章  集合与计数基础', '§ 1.3 有限集的基本计数技术', '1.3.3 排列计数与组合计数', '三、可重复的组合']","{'实体类型': '性质', '定义': '可重复r-组合的个数', '计算方法': '基于重集的可重复r-组合数为C(m-1+r, r)'}",,4,"考察如下可重复的组合问题：从包含苹果、橙子和梨子的筐中任取4 个水果招待客人，假设筐中苹果、橙子和梨子的个数均多于4 个且不关心取水果的次序，问有多少种取法？  
可对这4 个水果的取法做如下枚举：  
4 个苹果；4 个橙子；4 个梨子；3 个苹果，1 个橙子；3 个苹果，1 个梨子；3 个橙子，1 个苹果；3 个橙子，1 个梨子；3 个梨子，1 个苹果；3 个梨子，1 个橙子；2 个橙子，2 个苹果；2 个橙子，2 个梨子；2 个梨子，2 个苹果；2 个橙子，1 个苹果，1 个梨子；2 个苹果，1 个梨子，1 个橙子；2 个梨子，1 个苹果，1 个橙子。  
由此可知取法一共有15 种。当水果种类或取出数目比较大时，这种枚举方法显然是不可行的。在这个问题中，可以将包含苹果、橙子和梨子的筐子分别看成是一个重集。由于不考虑取水果的次序，因此可将该问题看成是一种基于重集的可重复的组合数计算问题。  
下面具体介绍可重复的组合数计算问题的相关概念及解法。  
【定义1.25】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的重集，从该重集中任意取出$r$ 个元素组成一个子重集，称每一个这样的子重集为一个可重复$r\cdot$-组合，可重复$r\cdot$组合的个数称为可重复$r$-组合数。  
下面结合一个具体实例详细介绍可重复$r\cdot$-组合数的计算问题。  
【定理1.18】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的$m$ 元重集，且重集中每个元素的从数均不小于 $r$ ，则基于该重集的可重复 $r\cdot$ - 组合数为 $C(m-1+r,\ r)$ 。"
可重复排列,概念,"['第一章  集合与计数基础', '§ 1.3 有限集的基本计数技术', '1.3.3 排列计数与组合计数', '二、可重复的排列']","{'实体类型': '概念', '定义': '从重集中依次取出r个元素并将其按取出的次序排成一排，形成的有序排列', '分类': '全排列和选排列'}",,4,"现考察这样一个问题：用1、2、3 这3 个数字可以构成多少种不同的5 位数字？  
使用乘法原理不难知道该问题解为$\ 13^{5}=243$种。这显然是一个元素可以重复的排列问题，现具体讨论这类问题。我们知道，在经典集合论中，集合中元素是不可重复的。为解决集合中重复元素的表示问题，现引入重集的概念。与集合的概念一样，重集也是一个没有具体定义的原始概念，只有通过如下方式对其含义进行描述或理解：  
所谓重集，就是在指定范围内满足给定条件、且允许多个相同对象同时出现的所有对象构成的总体，重集中每个对象仍然称为该集合的元素，重集中相同元素的个数称为元素的重数。具体地说，如果一个重集中含有 $\cdot_{n_{1}}$ 个 $\cdot a_{1}$ ， $n_{2}$ 个 $a_{2}$ ， ⋯ ， $n_{m}$ 个 $a_{m}$ ，且 $n_{1}+n_{2}+\cdots+n_{m}=$ $n$，则称该重集为含有$n$个元素的$m$元重集，记为：$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}.$。  
约定：$\infty\cdot a$表示元素$a$可在重集中出现任意多次；$\{\infty\cdot a_{1},\infty\cdot a_{2},\cdots,\infty\cdot a_{m}\}$则表示重集中所有元素均可出现任意多次，称其为无穷重$\pmb{m}$ 元重集。  
事实上，可将$m$ 元重集看成是由$m$ 个容器组成的容器组，其中第一个容器可以放入（或取出）$n_{1}$个元素$a_{1}$，第二个容器可以放入（或取出）$n_{2}$个元素$a_{2}$，…，第$m$个容器可以放入（或取出）$n_{m}$个元素$a_{m}$.对于$\infty\cdot a$，则可将其理解为可以放入（或取出）无穷多个元素$a$的容器.需要注意的是，通常认为重集不是集合，但可将集合看成是重集的特例。  
显然，用1、2、3 这个数字构成5 位数字，就是一个无穷重3 元重集中取出5 个元素的排列问题。一般地，这种重集排列问题或可重复排列问题的定义如下：  
【定义1.24】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的重集，从该重集中依次取出$r$ 个元素并将其按取出的次序排成一排，由此形成的一个有序排列称之为可重复$r$-排列，可重复$r\mathbf{\cdot}$-排列的个数称为可重复$r$-排列数；令$\cdot n_{1}+n_{2}+\cdots n_{m}=n$，则称$\cdot r=n$时构成的排列称为全排列，$r<n$时构成的排列为选排列。  
通过乘法原理不难得到如下无穷重$m$ 元重集的可重复$r\mathbf{\cdot}$-排列数计算公式  
【定理1.16】假设$\{\infty\cdot a_{1},\infty\cdot a_{2},\cdots,\infty\cdot a_{m}\}$是任意一个给定的无穷重$m$ 元重集，该重集下可重复$r$-排列数为$m^{r}$。  
【证明】无穷重数$m$ 元重集$\{\infty\cdot a_{1}$，$\infty\cdot a_{2}$，⋯，$\infty\cdot a_{m}\}$ $r$-排列的每一个位置上，均有$m$  种选择方案，故而 $r$ - 排列数为 $\ \ \cdot m^{r}$ 。□  
【例题1.57】（1）用7 颗六彩珠串成长链，可串出多少种不同长链（假定六彩珠取之不尽，且不考虑链子的反转）？（2）至少用两种颜色的六彩珠串成7 珠环链，求环链的种数（假定六彩的珠子取之不尽，且不考虑链子的反转）？  
![](images/3f1e76f81dba91759e05f5e7aace97377518f23c7e8ea20e34523f4359261b28.jpg)
图1-8 4-圆排列  
有穷集$m$ 元重集上可重复$r\mathbf{\cdot}$-排列数的计算是一个比较复杂的问题，有兴趣的同学可以查阅相关资料，不再赘述。在此仅考虑如下比较简单的全排列数的计算问题：  
【定理1.17】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的含有$n$ 个元素的有限$m$元重集，从该重集中依次取出$n$ 个元素的全排列数为：  
$$
\frac{n!}{n_{1}!\cdot n_{2}!\cdot\dots\cdot n_{m}!}
$$  
【例题1.58】EXCELLENT 单词含有9 个字母，若重新排序字母顺序，请问能构成多少个不同字符串？"
可重复的组合,概念,"['第一章  集合与计数基础', '§ 1.3 有限集的基本计数技术', '1.3.3 排列计数与组合计数', '三、可重复的组合']","{'实体类型': '概念', '定义': '从包含多个相同元素的重集中任意取出一定数量的元素组成子重集，不考虑次序', '应用': '解决从多种类元素中取一定数量元素的问题'}",,4,"考察如下可重复的组合问题：从包含苹果、橙子和梨子的筐中任取4 个水果招待客人，假设筐中苹果、橙子和梨子的个数均多于4 个且不关心取水果的次序，问有多少种取法？  
可对这4 个水果的取法做如下枚举：  
4 个苹果；4 个橙子；4 个梨子；3 个苹果，1 个橙子；3 个苹果，1 个梨子；3 个橙子，1 个苹果；3 个橙子，1 个梨子；3 个梨子，1 个苹果；3 个梨子，1 个橙子；2 个橙子，2 个苹果；2 个橙子，2 个梨子；2 个梨子，2 个苹果；2 个橙子，1 个苹果，1 个梨子；2 个苹果，1 个梨子，1 个橙子；2 个梨子，1 个苹果，1 个橙子。  
由此可知取法一共有15 种。当水果种类或取出数目比较大时，这种枚举方法显然是不可行的。在这个问题中，可以将包含苹果、橙子和梨子的筐子分别看成是一个重集。由于不考虑取水果的次序，因此可将该问题看成是一种基于重集的可重复的组合数计算问题。  
下面具体介绍可重复的组合数计算问题的相关概念及解法。  
【定义1.25】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的重集，从该重集中任意取出$r$ 个元素组成一个子重集，称每一个这样的子重集为一个可重复$r\cdot$-组合，可重复$r\cdot$组合的个数称为可重复$r$-组合数。  
下面结合一个具体实例详细介绍可重复$r\cdot$-组合数的计算问题。  
【定理1.18】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的$m$ 元重集，且重集中每个元素的从数均不小于 $r$ ，则基于该重集的可重复 $r\cdot$ - 组合数为 $C(m-1+r,\ r)$ 。"
右单位元,概念,"['第十一章  抽象代数结构通论', '§ 11.2 代数结构的运算性质', '11.2.2 特殊元素']","{'实体类型': '概念', '定义': '存在元素e_r，使得对任意x，有x*e_r=x'}",,3,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)"
右逆元,概念,"['第十一章  抽象代数结构通论', '§ 11.2 代数结构的运算性质', '11.2.2 特殊元素']","{'实体类型': '概念', '定义': '存在元素y_r，使得对任意x，有x*y_r=e'}",,3,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)"
右零元,概念,"['第十一章  抽象代数结构通论', '§ 11.2 代数结构的运算性质', '11.2.2 特殊元素']","{'实体类型': '概念', '定义': '存在元素θ_r，使得对任意x，有x*θ_r=θ_r'}",,3,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)"
合取,运算,"['第三章  命题演算与推理', '§ 3.1 命题的概念与运算', '3.1.3  命题的常用联结词', '二、合取与析取联结词']","{'实体类型': '运算', '定义': '表示两个命题同时为真的逻辑运算', '特点': '记作P∧Q，当且仅当P和Q同时为真时取值为真'}",,4,"对于任意两个命题，有时需要构造一个新的复合命题表示这两个命题同时为真的含义，相当于自然语言中“与”或“并且”的意思，由此得到的逻辑运算称为命题的“合取”运算或者“与”运算。该运算及其逻辑联结词的具体定义如下：  
【定义3.3】设 $P$ 、$Q$ 是任意两个命题，复合命题$^{\prime\prime}P$并且 $Q$ ”称为 $P$ 与 $Q$ 的合取式或与运算，记作 $P\land Q$，其中符号$\wedge$称为合取联结词(简称为合取词)。 $P\land Q$的取值为真，当且仅当 $P$ 和$Q$ 同时为真；或者说$P$ ∧𝑄 的取值为假，当且仅当 $P$ 和 $Q$ 至少有一个为假。  
例如，若令$\cdot P$表示“我喜欢唱歌”， $Q$ 表示“我喜欢跳舞”，则合取式 $P\land Q$ 就表示复合命题“我喜欢唱歌并且喜欢跳舞”。  
对于任意两个命题 $P$ 和 $Q$ ，其合取运算 $P\land Q$的真值取值规定如表3-1 第5 列所示。  
有时需要构造一个复合命题表示两个命题中至少有一个为真的含义，相当于自然语言中“可兼或”的意思，由此得到的逻辑运算称为命题的“析取”运算或者“可兼或”运算。所谓可兼或，就是可两者兼得的或。该运算及其逻辑联结词的具体定义如下：  
【定义 3.4 】设   $P、 Q$   是任意给定的两个命题，复合命题 $^{\prime\prime}P$   或 $\textit{Q}\,^{\prime\prime}$ 称为   $P$ 与   $Q$   的析取 式或者可兼或运算，有时简称为或运算，记作 $P\lor Q$ ，其中符号$\vee$称为析取联结词(简称为析取词 ) 。 $P\lor Q$   的取值为真，当且仅当   $P$   和   $Q$   中至少有一个为真；或者说 $P\lor Q$   的取值 为假，当且仅当 $P$ 和 $Q$ 都为假。  
例如，若令 $P$ 表示“我喜欢唱歌”，$Q$ 表示“我喜欢跳舞”，则析取式 $P\lor Q$ 就表示复合命题“我喜欢唱歌或者喜欢跳舞”。  
对于任意两个命题 $P$ 和 $Q$，析取运算 $P\lor Q$ 的真值取值规定如表3-1 第6 列所示。  
在实际的逻辑电路中，通常用高电位表示1 或$T$，用低电位表示0 或$F$，通过逻辑与、或、非等运算，可构造相应的与门、或门、非门，如图所示。后面将具体介绍如何使用这些门电路来构造出一些复杂的逻辑电路。  
图3-2 逻辑电路  
需要注意的是：自然语言中或的含义是有歧义的，对或的理解除了上述可兼或外，有时还可理解成不可兼或，即两者不可兼得的或，有时称之为异或。在逻辑运算中，可兼或与异或之间具有完全不同的含义，我们将在后续相关内容中具体讨论异或逻辑联结词及其逻辑运算。除非特别说明，逻辑演算中或运算含义都默认为可兼或运算，即析取运算。  
在实际应用中，应根据语句的具体内容和上下文相关信息仔细甄别其中“或”表达的是可兼或还是不可兼或。例如，语句“今天晚上我看书或者听音乐”中“或”的含义应理解为可兼或；语句”这节课是数学课或者体育课“中“或”的含义应理解为不可兼或。"
合取式,概念,"['第三章  命题演算与推理', '§ 3.4 命题公式的范式', '3.4.1 范式的基本概念', '一、析取式与合取式']","{'实体类型': '概念', '定义': '有限个文字的合取称为合取式，也称为短语', '特点': '一个具有两层结构的逻辑表达式，只有否定和合取这两种联结词，内层是否定联结词，外层是合取联结词'}",,4,"在否定、合取、析取这三个联结词中，否定联结词具有最高的运算优先级，范式中用文字这个概念对其进行封装，规定范式中否定联结词只能作用于单个命题变量。这样就用文字的概念将否定运算封装命题公式范式的内层。下面给出文字概念的定义：  
【定义3.20】设𝑃是任意一个命题变量，则𝑃和$\neg P$均称为文字，且称𝑃和$\neg P$为互补对。由于合取和析取这两个联结词在运算上具有对等性质，也就是说合取运算具有析取运算的所有性质，析取运算也具有合取运算的所有性质。故有如下析取式与合取式的概念：  
【定义3.21】有限个文字的析取称为析取式，也称为子句；有限个文字的合取称为合取式，也称为短语。  
例如， $P$、 $\neg P$是文字、子句、短语； $P\lor Q\lor R$是子句； $P\land Q\land R$是短语。注意：一个命题变元或者其否定既可以是子句，也可以是短语。  
显然，析取式是一个具有两层结构的逻辑表达式，只有否定和析取这两种联结词，内层是否定联结词，外层是析取联结词；合取式也是一个具有两层结构的逻辑表达式，只有否定和合取这两种联结词，内层是否定联结词，外层是合取联结词。"
合取联结词,概念,"['第三章  命题演算与推理', '§ 3.1 命题的概念与运算', '3.1.3  命题的常用联结词', '二、合取与析取联结词']","{'实体类型': '概念', '定义': '用于表示合取运算的逻辑联结词，记作∧'}",,4,"对于任意两个命题，有时需要构造一个新的复合命题表示这两个命题同时为真的含义，相当于自然语言中“与”或“并且”的意思，由此得到的逻辑运算称为命题的“合取”运算或者“与”运算。该运算及其逻辑联结词的具体定义如下：  
【定义3.3】设 $P$ 、$Q$ 是任意两个命题，复合命题$^{\prime\prime}P$并且 $Q$ ”称为 $P$ 与 $Q$ 的合取式或与运算，记作 $P\land Q$，其中符号$\wedge$称为合取联结词(简称为合取词)。 $P\land Q$的取值为真，当且仅当 $P$ 和$Q$ 同时为真；或者说$P$ ∧𝑄 的取值为假，当且仅当 $P$ 和 $Q$ 至少有一个为假。  
例如，若令$\cdot P$表示“我喜欢唱歌”， $Q$ 表示“我喜欢跳舞”，则合取式 $P\land Q$ 就表示复合命题“我喜欢唱歌并且喜欢跳舞”。  
对于任意两个命题 $P$ 和 $Q$ ，其合取运算 $P\land Q$的真值取值规定如表3-1 第5 列所示。  
有时需要构造一个复合命题表示两个命题中至少有一个为真的含义，相当于自然语言中“可兼或”的意思，由此得到的逻辑运算称为命题的“析取”运算或者“可兼或”运算。所谓可兼或，就是可两者兼得的或。该运算及其逻辑联结词的具体定义如下：  
【定义 3.4 】设   $P、 Q$   是任意给定的两个命题，复合命题 $^{\prime\prime}P$   或 $\textit{Q}\,^{\prime\prime}$ 称为   $P$ 与   $Q$   的析取 式或者可兼或运算，有时简称为或运算，记作 $P\lor Q$ ，其中符号$\vee$称为析取联结词(简称为析取词 ) 。 $P\lor Q$   的取值为真，当且仅当   $P$   和   $Q$   中至少有一个为真；或者说 $P\lor Q$   的取值 为假，当且仅当 $P$ 和 $Q$ 都为假。  
例如，若令 $P$ 表示“我喜欢唱歌”，$Q$ 表示“我喜欢跳舞”，则析取式 $P\lor Q$ 就表示复合命题“我喜欢唱歌或者喜欢跳舞”。  
对于任意两个命题 $P$ 和 $Q$，析取运算 $P\lor Q$ 的真值取值规定如表3-1 第6 列所示。  
在实际的逻辑电路中，通常用高电位表示1 或$T$，用低电位表示0 或$F$，通过逻辑与、或、非等运算，可构造相应的与门、或门、非门，如图所示。后面将具体介绍如何使用这些门电路来构造出一些复杂的逻辑电路。  
图3-2 逻辑电路  
需要注意的是：自然语言中或的含义是有歧义的，对或的理解除了上述可兼或外，有时还可理解成不可兼或，即两者不可兼得的或，有时称之为异或。在逻辑运算中，可兼或与异或之间具有完全不同的含义，我们将在后续相关内容中具体讨论异或逻辑联结词及其逻辑运算。除非特别说明，逻辑演算中或运算含义都默认为可兼或运算，即析取运算。  
在实际应用中，应根据语句的具体内容和上下文相关信息仔细甄别其中“或”表达的是可兼或还是不可兼或。例如，语句“今天晚上我看书或者听音乐”中“或”的含义应理解为可兼或；语句”这节课是数学课或者体育课“中“或”的含义应理解为不可兼或。"
合取范式,概念,"['第三章  命题演算与推理', '§ 3.4 命题公式的范式', '3.4.1 范式的基本概念', '二、析取范式与合取范式']","{'实体类型': '概念', '定义': '有限个子句的合取式称为合取范式', '形式': '一个命题公式称为合取范式，当且仅当该命题具形式：B1∧B2∧⋯∧Bn，其中B1，B2，⋯，Bn均为由命题变元或其否定所组成的析取式', '特点': '一个命题的合取范式不唯一'}",,4,"合取式是一个只有否定层与合取运算层的两层结构表达式，如果在其外层增加一个析取运算层，则得到所谓的析取范式；同样，析取式是一个只有否定层与析取运算层的两层结构表达式，如果在其外层增加一个合取运算层，则得到所谓的合取范式。  
【定义3.22】有限个短语的析取式称为析取范式；有限个子句的合取式称为合取范式。析取范式与合取范式统称为范式。 也就是说，一个命题公式为析取范式，当且仅当它具有形式：$A_{1}\lor A_{2}\lor\ldots\lor A_{n}$。其中，$A_{1}$，$A_{2}$，… ，$A_{n}$均为由命题变元或其否定所组成的合取式。  
例如，$(P\land\neg Q\land R)\lor(\neg P\land Q)\lor\neg R$是析取范式。  
同样地，一个命题公式称为合取范式，当且仅当该命题具形式：$B_{1}\wedge B_{2}\wedge\cdots\wedge B_{n}$。其中，$B_{1}$，$B_{2}$，⋯，$B_{n}$均为由命题变元或其否定所组成的析取式。  
例如，$(P\lor\neg Q\lor R)\land(\neg P\lor Q)\land\neg R$是合取范式。  
注意：①一个命题的析取范式或合取范式不唯一；②形如$P\land\neg Q\land R$的公式既可看成是由一个合取式构成的析取范式，也可以看成是由3 个析取式构成的合取范式，但是公式$(P\land$$\neg Q\land R)$只能将其看成是析取范式；③形如$P\lor\neg Q\lor R$的公式既是合取范式，又是析取范式，但$(P\lor\neg Q\lor R)$仅是合取范式。  
对于任意一个命题公式，下面定理保证了其析取范式和合取范式的存在性：  
【定理3.8】对于任意命题公式，都存在与其等值的析取范式和合取范式。"
合式公式,概念,"['第三章  命题演算与推理', '§ 3.2 命题公式与等值演算', '3.2.1 命题公式的基本知识', '一、命题变量与命题公式']","{'实体类型': '概念', '定义': '由表示命题变量的标识符、逻辑联结词和括弧构成的字符串，按特定规则构造而成', '规则': ['单个的命题变量是一个命题公式', '若𝐺是一个命题公式，则$(\\\\neg G)$也是一个命题公式', '若𝐺, $H$是命题公式，则$(G\\\\wedge H)$、$(G\\\\lor H)$、$(G\\\\to H)$)、$(G\\\\leftrightarrow H)$)都是命题公式', '仅通过有限次使用规则（1）、（2）、（3）所得到的字符串才是命题公式']}",,4,"如前所述，可用大写英文字母作为标识符来表示命题。事实上，在具体的逻辑演算中，我们关注的重点往往是命题的真值取值状况而非命题的具体内容和含义。因此，可将作为命题标识符的字母符号取代具体的命题进行逻辑演算，由此形成一套形式化的符号逻辑代数演算系统。与初等代数中常量和变量的概念相类似，在这个系统中，对于一个给定的命题标识符，它不仅可用来特指某个具体的命题，成为命题常量，而且还可用于泛指一个任意的、没有具体内容的抽象命题，成为命题变量。命题常量和命题变量的具体定义如下：  
【定义3.7】如果一个命题标识符表示的是一个特定的、具有特定内容的具体命题，则称该标识符为命题常量；如果一个命题标识符表示的是一个泛指的、内容不确定的抽象命题，则称该标识符为命题变量。  
命题常量表示一个具体命题，其内容和真值都是确定的。因此，可将命题常量看成是一个命题。命题变量则表示任意一个命题，假定标识符𝑃是一个命题变量，则𝑃既可以表示“合肥是安徽的省会”，也可以表示“太阳从西方升起”，还可以表示其它任意命题。事实上，可以将命题变量理解成一个能够存放任意命题的空容器， 其含义随着容器中所存放具体命题的不 同而不同。因此，命题变量的真值取值是不确定的，不能将其看成命题。  
我们知道，复合命题是由原子命题经由联结词进行逻辑运算得到的命题。当复合命题中的原子命题变成命题变量时，该复合命题显然就变成了一种以这些命题变量为自变量的函数。由于这种函数的取值为或真或假的真值，故称这种函数为真值函数或命题公式。  
例如，下列表达式就是一些命题公式或真值函数：  
$$
P、 \neg(P\lor Q)、s\ (P\lor Q)\to R、\quad P\to(P\lor Q)
$$  
由此可知，命题公式或真值函数其实就是由表示命题变量的标识符和逻辑联结词构成的逻辑运算表达式。需要说明的是，命题公式之所以能够构成逻辑运算表达式，关键在于其能够根据逻辑联结词的含义进行运算，故此并不是由命题变量和标识符构成的任意字符串都能  
构成命题公式。例如，下列字符串都不是命题公式：  
$$
(P\lor Q)\to\lor\,\,(P\to Q)\to(\lor Q)\,,\,\,(P\to Q\setminus\,\,(P\to Q)\leftrightarrow
$$  
因此，必须要有一个严格的、具有可操作性的标准来区分哪些符号串是合法的命题公式，哪些字符串则不能构成命题公式。以下命题公式的归纳定义就确定了这个标准。  
【定义3.8】由表示命题变量的标识符、逻辑联结词和括弧构成的字符串称为命题演算的合式公式，又称为命题公式或真值函数，当且仅当它按下列4 条规则构造而成：  
（1）单个的命题变量是一个命题公式；  
（2）若𝐺是一个命题公式，则$(\neg G)$也是一个命题公式；  
（3）若𝐺, $H$是命题公式，则$(G\wedge H)$、$(G\lor H)$、$(G\to H)$)、$(G\leftrightarrow H)$)都是命题公式；  
（4）仅通过有限次使用规则（1）、（2）、（3）所得到的字符串才是命题公式。  
在上述定义中的四个规则确定了一个由所有命题公式为元素组成的集合，第（1）条规则决定了该集合为非空集合并确定了集合的初始元素，第（2）、（3）条规则则是根据集合中初始元素通过运算不断构造出新的元素，是集合的不断扩张的过程，第（4）条规则则是对集合的扩张进行了限制，给出了集合的边界，由此构成一个边界确定集合。这个集合就是命题函数的一种外延式定义。  
为书写简单起见，对命题公式中括弧使用和联结词运算优先级做如下约定：  
（1）命题公式中最外层的括弧可以省略；  
（2）5 种常用逻辑联结词的运算优先级从左到右按如下次序递减：
$$
\neg 、 \wedge 、 \vee 、 \rightarrow 、 \leftrightarrow
$$
例如，对于下列命题公式:
$$
(P \wedge(\neg Q)) 、(P \rightarrow Q) \rightarrow(Q \wedge(\neg R)) 、(P \vee(Q \wedge R)) \leftrightarrow(P \vee   (R \rightarrow \neg S)) 、(\neg Q) \rightarrow((P \wedge R) \rightarrow(\neg R \wedge Q))
$$
可分别将其简写为：  
$$
P\land\lnot Q\land\ {\cal P}\to Q\to Q\land\lnot R\land\ {\cal P}\lor Q\land R\leftrightarrow{\cal P}\lor(R\to\lnot S)\land\ \lnot Q\to P\land R\to\lnot R\lor Q
$$"
同余,概念,"['§ 11.3 同构、同态与同余', '第十一章  抽象代数结构通论', '11.3.2  同构与同态与性质', '11.3.1  同构与同态的概念', '11.3.3  同余的概念与性质']","{'实体类型': '概念', '定义': ['由同态映射导出的一般性等价关系', '设⟨A,*,△⟩和⟨B,∘,♢⟩是任意两个给定的代数结构，其中*和∘分别为二元运算，△和♢分别为一元运算，若存在A到B的双射函数ψ，对于∀x1,x2,x∈A，有ψ(x1*x2)=ψ(x1)∘ψ(x2)；ψ(△x)=∘ψ(x)，则称映射ψ是从⟨A,*,△⟩到⟨B,∘,♢⟩的同构映射，并称代数结构⟨A,*,△⟩与⟨B,∘,♢⟩同构，记为⟨A,*,△⟩≅⟨B,∘,♢⟩', '代数结构中的等价关系', '设⟨A,∗,△⟩是一个代数结构，∗和△分别是二元运算和一元运算，~是载体A上的等价关系，对于∀a,b,c∈A且a~b：若有△a~△b，则称~是关于运算△的同余关系；若有a*c~b*c且c*a~c*b，则称~是关于运算∗的同余关系；若~是关于△和∗的同余关系，则称~是代数结构⟨A,∗,△⟩上的同余关系，此时称等价类[x]~为同余类'], '应用': ['考察代数结构之间的关系', '简化代数结构的研究'], '特点': ['基于同态映射的等价关系', '同余关系可以用于划分代数结构'], '性质': '集合A上的等价关系R将A划分为一个一个的等价类，如果A中具有等价关系R的元素在运算∗下仍然保持等价关系R不变，那就说明，集合A在等价关系R下的划分在运算∗的映射变换下保持不变'}",,2,"前面介绍了代数结构及其运算的基本概念，并对运算律及特殊元素等基本运算性质进行讨论，主要分析考察单个代数结构的基本成分和基本特性。使用不同的集合载体和运算可以建立大量不同种类的代数结构。现在我们就来考察这些不同种类代数结构之间的区别与联系。事实上，在前述图论的有关内容中也处理过类似问题，为了考察不同图模型之间区别与联系，我们通过使用不同图模型的结点之间的双射函数来建立图模型之间的映射联系，如果这种双射函数能够保持图模型的结构不变，则认为这两个图模型具有相同的结构，即这两个图模型是同构的，并称这种双射函数为同构映射或同构函数。  
可以采用与之类似的映射方法建立和考察不同代数结构之间的联系，由此得到代数结构同构及同构映射的相关概念。由此更进一步，也可以取消同构映射中为双射的要求，将同构映射推广到一般的映射，则可由此得到代数结构同态及同态映射的相关概念。事实上，不难看出两个代数结构之间的同构映射建立了这两个代数结构载体集合之间的一种特殊等价关系，如果考察由同态映射导出的一般性等价关系，则还可得到代数结构的另外一种关系，即同余关系。 本节主要介绍代数结构之间的同构、同态和同余关系。"
同余关系,性质,"['§ 12.3 同余关系与商群', '第二章  整数与算法设计基础', '§ 2.2 同余算术及其应用', '§ 11.3 同构、同态与同余', '2.2.2 同余方程与方程组', '第十二章 典型抽象代数结构', '11.3.3  同余的概念与性质', '第十一章  抽象代数结构通论', '2.2.1 同余关系及其运算', '12.3.1 同余关系与陪集']","{'实体类型': ['性质', '概念'], '特点': ['若等价关系~在A上的所有运算下都是可保持的，则~为代数系统A上的同余关系', '能够保证其作为等价关系所对应划分在运算下保持不变', '是一个等价关系且对运算*具有保持性', '具有自反性、对称性、传递性'], '相关内容': '群的同余关系与商群', '定义': ['同一性介于相等关系与等价关系之间的一种特殊等价关系', '设⟨G,*⟩是任意给定的一个群，⟨H,*⟩是⟨G,*⟩的任一子群，对于∀a,b∈G,若有a*b^{-1}∈H，则称a与b具有模H同余关系，记为a≡b(modH)', '假设m是任一给定的正整数，对于任意两个整数a和b，它们除以m后得到的余数分别记为a(mod m)和b(mod m)，如果这两个余数相等，即有a(mod m)=b(mod m)，则称a与b具有模m同余关系，简称为a与b模m同余或同余，记为a≡b(mod m)或b≡a(mod m)；否则称a与b对于模m不同余，记为a≢b(mod m)或b≢a(mod m)'], '应用': ['在代数结构的研究中，用于考察载体集合的划分问题', '实现对整数集合的划分或分类'], '属性': '及其运算'}",,3,"在整数理论中，我们学过整数之间的同余关系。整数的模$\boldsymbol{\cdot}\boldsymbol{k}$同余关系作为一种等价关系其实是整数相等关系的一种扩展。我们知道，整数之间的相等关系是一种最强的等价关系。 由运算的单值映射性质可知，对于任意两个相等的整数进行某种运算之后仍然保持相等。 现将整数相等关系这种对运算的保持性质推广到一般的等价关系？具体地说，就是对于一个任意给定的代数结构$\langle A,\ *\rangle$，$R$是载体集合𝐴上的一个等价关系，考察在$A$中具有关系𝑅的元素经过运算后是否仍然具有等价关系$R$。由此得到如下同余关系的相关定义：  
【定义11.18】设$\langle A,\ *,\!\triangle\rangle$是一个代数结构，$*$和$\triangle$分别是二元运算和一元运算，$\sim$是载体$𝐴$上的等价关系，对于$\forall a,b,c\in A$且$a{\sim}b$：若有$\triangle\;a\!\sim\triangle\;b$，则称$\sim$是关于运算$△$的同余关系；若有 $a*c{\sim}b*c$ 且 $c*a{\sim}c*b$ ，则称 $\sim$ 是关于运算 ${\ast}$ 的同余关系；若 $\sim$ 是关于 △ 和 $*$ 的同余 关系，则称$\sim$是代数结构$\langle A,\ *,\triangle\rangle$上的同余关系，此时称等价类$[x]_{\sim}$为同余类。  
我们知道，集合𝐴上的等价关系𝑅将𝐴划分为一个一个的等价类，如果𝐴中具有等价关系$R$的元素在运算$^*$下仍然保持等价关系$R$不变，那就说明，集合𝐴在等价关系$R$下的划分在运算$^*$的映射变换下保持不变。具体地说：就是运算$^*$将𝐴中任意彼此等价的两个元素从其所处的等价类映射到另外一个等价类中，如图11.4 所示，图中每个小方格分别代表一个等价类。 此时，可以将运算$^*$看成是对集合𝐴中元素在等价类之间进行的一次置换。  
![](images/fae0b5be5e5b684797945d41e251f779b67578792deb6bd81af14b0e79ffcf00.jpg)
图11.4  同余关系与等价类  
从上述定义可以看出，若等价关系$\sim$在𝐴上的所有运算下都是可保持的，则$\sim$为代数系统$𝐴$上的同余关系。  
【定理11.11】等价关系$\sim$关于二元运算∗是一个同余关系，当且仅当$a{\sim}b$和$c{\sim}d$时，有  
$ a c\sim b d$。  
现在讨论同态和同余之间的联系，首先给出由同态映射导出的一个等价关系：  
【定理11.12】假设$\langle A,+,\ \times\rangle$和$\langle B,\,\oplus,\,\otimes\,\rangle$是任意两个同态的代数结构，$\psi$：$A\rightarrow B$是其同态映射，则集合$\cdot A$中元素在映射$\cdot\psi$下具有同像的关系$\sim$，即有：  
$$
\sim\;=\{\langle x,y\rangle|x,y\in A\land\psi(x)=\psi(y)\}\tag{11-11}
$$  
是一个等价关系，并称之为由同态映射$\cdot\psi$导出的𝐴上自然等价关系。  
【定理11.13】假设$\langle A,+,\ \times\rangle$和$\langle B,\,\oplus,\,\otimes\,\rangle$是任意两个同态的代数结构，$\psi$：$A\rightarrow B$是其同态映射，则由同态映射$\cdot\psi$导出的自然等价关系：  
$$
\sim\;=\{\langle x,y\rangle|x,y\in A\land\psi(x)=\psi(y)\}
$$  
是一个同余关系。  
事实上，对于代数结构$\langle A,+,\ \times\rangle$上的任意一个同余关系$\sim$，可以构造出一个与之相应的商代数，并且$\langle A,+,\ \times\rangle$与该商代数之间是一种满同态关系，称之为自然同态关系。因此，由同余关系也可以构造出一个与之相应的同态关系，并且该同态映射下的同态像与该商代数之间具体同构关系。具体内容可查阅商代数的相关知识，这里不再赘述。"
同余关系的保加性和保乘性,定理,"['第二章  整数与算法设计基础', '§ 2.2 同余算术及其应用', '2.2.1 同余关系及其运算']","{'实体类型': '定理', '内容': '设m是任一正整数，若整数a与b模m同余，整数c与d同余模m，则它们的和与积也分别模m同余。即：若a≡b(mod m)，c≡d(mod m)，则有a+c≡(b+d)(mod m)，ac≡bd(mod m)'}",,3,"在很多场合，我们往往只关心用某一特定正整数除以整数得到的余数。例如，星期日期就是从某个星期日开始经历的天数除以7 得到的余数，通过对天数取以7 为除数的余数，就可以用短短的7 个数字借助以7 为周期的循环机制表示无穷无尽的天数。事实上，取余数是一种以有限驾驭无限的重要智慧，对于任一给定的正整数$m$，通过考察所有整数除以$m$ 所得余数的差异，把所有具有相同余数的整数归为一类，则可将所有整数分为$m$ 个基本类型。若分别从每个类中取一个整数作为代表构成一个$m$ 元有限集，则可将这个有限集看成是对整数集的一个抽象，由此完成了整数集从无限向有限的转化。在这个分类过程中，整数之间是否具有相同余数的关系起着非常关键的作用，由此得到如下同余的概念：  
【定义2.9】假设$m$ 是任一给定的正整数，对于任意两个整数$a$和$b$，它们除以$m$ 后得到的余数分别记为$a({\bmod{\ m}})$和$b({\bmod{\ m}})$，如果这两个余数相等，即有：  
$$
a({\bmod{\ m}})=b({\bmod{\ m}})\tag{2-9}
$$  
则称$a$与$b$具有模$\pmb{m}$同余关系，简称为$a$与$b$模$\pmb{m}$同余或同余，记为$a\equiv b({\bmod{m}})$或$b\equiv$$a({\bmod{\ m}})$；否则称$a$与$b$对于模$\mathbfit{m}$不同余，记为$a\not\equiv b({\bmod{{m}}})$或$b\not\equiv a({\bmod{\ m}})$。  
根据上述定义，不难证明下面关于模$_m$同余的判定定理：  
【定理2.19】假设$m$是任一给定的正整数，任意两个整数$a$和$b$具有模$_m$同余关系，当且仅当$m$能够整除$a-b$。  
【定理2.20】假设$m$ 是任一给定的正整数，任意两个整数$a$ 和$b$ 具有模$m$同余关系，  
当且仅当存在整数$k$，使得整除$a=b+k m$  
下面定理表明了同余关系的保加性和保乘性：  
【定理2.21】设$m$ 是任一正整数，若整数$a$ 与$b$ 模$m$ 同余，整数$c$与$d$ 同余模$m$，则它们的和与积也分别模$m$ 同余。即：若$a\equiv b({\bmod{\ }}m)$，$c\equiv d({\bmod{\pmod{m}}})$，则有：  
$$
a+c\equiv(b+d)(\bmod{\ m}),\ \ a c\equiv b d(\bmod{\ m})
$$  
【定理2.22】假设$m$ 是任一给定的正整数，则对任意两个整数$a$ 和$b$，成立下面两个关于余数的计算公式：  
$$
(a+b){\bmod{\ m}}=((a{\bmod{\ m}})+(b{\bmod{\ m}})){\bmod{\ m}}\tag{2-10}
$$  
$$
ab\ {\bmod{\ m}}=((a{\bmod{\ m}})(b{\bmod{\ m}}))\ {\bmod{\ m}}\tag{2-11}
$$  
例如，对于$7\equiv2{\bmod{\mathrm{~5~}}}$和$11\equiv1{\bmod{\mathrm{~5~}}}$，由定理2.21 知：  
$$
18=7+11\equiv2+1=3({\bmod{\mathrm{~}}}5)
$$  
$$
77=7\cdot11\equiv2\cdot1=2{\pmod{5}}
$$  
再如，对于任意三个数，比如说1, 2 和5，由定理2.22 知存在如下等式：  
$$
(1+2)({\bmod{\ }}5)=((1\ \,({\bmod{\ }}5)+(2\ \,({\bmod{\ }}5))({\bmod{\ }}5)
$$  
$$
2\,\bmod\,5=\left((1\,\bmod\,5)(2\,\bmod\,5)\right)\,(\bmod\,5)
$$  
值得注意的是，同余关系在一般情况下不满足消去律，例如 $8\equiv12({\bmod{\mathrm{~}}}4)$，两边同除以4 后，$2\equiv3({\bmod{\mathrm{~}}}4)$显然是不成立的，但是存在下列性质：  
【定理2.23】若$a c\equiv b c({\bmod{\pmod{m}}})$，且$c$ 与$m$ 互素，则有：$a\equiv b({\bmod{\ }}m)$  
如前所述，使用同余可以实现对整数集合的划分或分类，现在就来讨论这个问题。由同余的定义可知，对于任意给定的正整数$m$，可依照除以$m$ 后的余数值以及模$m$ 同余关系，将所有整数划分为$m$ 个互不相交的子集合。据此，我们引入如下同余类的概念：  
【定义2.10】设$m$ 是任一给定正整数，对于每个整数$i$，$0\leq i<m$，定义如下集合：  
$$
R_{i}(m)=\{n|n\equiv i({\bmod{\pmod{\ m}}},n\in Z\}\tag{2-12}
$$  
则称每个$^{}R_{i}(m)$分别是模$m$ 的一个同余类或剩余类，在不引起混淆的情况下，通常也将$R_{i}(m)$简记为$[i]$，并记为：$Z_{m}=\{[0],[1],\cdots[m-1]\}.$。  
【定理2.24】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m),$所有模$m$ 同余类，则有下述结论成立：  
（1）每个整数$a$ 都恰好属于某个同余类，通常将这个同余类记为$[a]_{m}$或$[a]$  
（2）对于任意的两个整数$a$ 和$b$，它们属于同一个同余类的充分必要条件是：
$$
a\equiv b({\bmod{m}})
$$  
上述定理表明，每个整数必定属于且仅属于其中一个剩余类，属于同一个剩余类的任意两个整数都是模$m$ 同余的，属于不同剩余类的任意两个整数不可能是模$m$ 同余的。  
根据定理，可以在$.Z_{m}=\{[0],[1],\cdots[m-1]\}$上定义关于同余类的加法和乘法运算：  
【定义2.11】假设$m$ 是任一给定的正整数对于任意给定的两个整数$a$和$b$，定义：
$$
[a]_{m}+[b]_{m}=[a+b]_{m}
$$  
$$
[a]_{m}\cdot[b]_{m}=[a\cdot b]_{m}
$$  
【定义2.12】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m)$是所有模$m$ 同余类，如果从每个同余类$R_{i}(m)$中分别取一个整数$x_{i}$构成一个$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$，则称该有限集合为模$m$ 的一个完全剩余系，简称为完全系；称$m$ 元有限集合$\{0,\ 1,\ 2,\ \cdots\ ,$为最小非负完全剩余系。  
对于正整数$m$，假设$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$是模$m$ 的一个完全剩余系，对于其中的任意一个整数$\cdot x_{i}$，如果${\bf\nabla}_{}^{}$与$m$ 互素，则$x_{i}$所在同余类${\mathbf{}}R_{i}(m)$中每个整数$k$ 都与$m$ 互素。这是因为根据$k\equiv x_{i}({\bmod{\pmod{m}}})$，即有$\cdot_{x_{i}}=k+q m$。由此可知，如果$k$ 与$m$有大于1 的公因子，那么$x_{i}$必然与$m$ 有大于1 的公因子。类似地，如果$x_{i}$与$m$ 互素，则$x_{i}$所在同余类$R_{i}(m)$中每个整数$k$ 都与$m$ 不互素。由此得到如下简化同余类和简化剩余系的概念：  
【定义2.13】对于正整数$m$，假设$R_{i}(m)$是任意一个模$m$ 同余类，若$R_{i}(m)$中存在一个整数与 $m$  互素，则称 $\ R_{i}(m)$ 是一个模 $\pmb{m}$  简化同余类或模 $\pmb{m}$  简化剩余类。如果分别从每个模 $m$ 简化同余类中取出一个整数作为代表$x_{i}$构成一个有限集合$\{x_{0},\ x_{1},\ \cdots,x_{\varphi(m-1)}\}$，则称该集合为模$m$ 的一个简化剩余系，简称为简化系。其中$\varphi(m)$称为欧拉函数，表示模$m$ 简化剩余类的数目，亦即不超过$m$ 且与$m$ 互素的正整数个数。  
因为所有模$m$ 同余类构成整数集合的一个划分，所以每个与$m$ 互质的整数仅存在于它  所在的简化同余类中。由此可以看出，简化同余类以及欧拉函数$\varphi(m)$在整数互质性质的研究中具有非常重要的作用，后面将使用这些概念证明欧拉定理和费马小定理。这两个定理不仅是整数理论中非常著名而重要的定理，而且还是现代非对称数论加密算法的基础。"
同余方程,概念,"['第二章  整数与算法设计基础', '2.2.2 同余方程与方程组', '§ 2.2 同余算术及其应用']","{'实体类型': '概念', '相关内容': '及其解法', '属性': '与方程组的求解', '定义': '关于未知数的一次线性同余方程', '解的计数标准': '相互之间模同余的解视为同一个解'}",,1,"整数作为一种最基本的离散量和离散结构不仅是离散数学的研究对象，而且其自身也是研究其它离散结构的一项基本工具，在离散量的度量、计数和算法设计等方面发挥重要的基础性作用。整数是人类最早认识和使用的数，专门研究整数及其性质的整数理论是一个具有几千年历史的非常古老的数学分支。在很长一段时期内，整数理论被认为仅仅是思想的体操、数学思维能力的训练工具，其实用性并没有得到充分重视。著名数学家数学王子高斯就曾给出这样的评价：如果说数学是科学的皇后，那么整数理论则是皇后头上美丽的皇冠。意指其仅仅是漂亮而不够实用。直到20 世纪70 年代基于整数模余运算理论的非对称加密算法被设计出来并取得成功应用，整数理论的实用性才得到广泛重视。事实上，算法概念正是诞生于整数的算术运算，这使得整数理论与计算机算法有着一种天然的紧密联系。计算机学科的诞生与兴起让整数理论这门古老的学科重新焕发出新的生命并得到蓬勃发展。目前，整数理论已经成为算法设计与算法度量的一项基本工具，在散列函数构造、伪随机数生成、信息编码与加密等多个领域得到广泛应用。其实除整数之外，离散数学中很多其它离散结构模型，例如图模型、关系模型、群代数结构模型等，也都是通过相关算法在计算机领域发挥重要作用。因此，算法设计技术是学习与应用离散数学所必备的基本知识。  
综上所述，作为学习离散数学的另一入门基础，本章比较系统地介绍整数理论与算法设计的基本知识，具体包括整除的基本概念与运算性质、模余运算的基础知识、同余方程及其解法、非对称加密算法、算法设计的基本知识、算法设计的基本策略与应用等。"
同余方程组,概念,"['第二章  整数与算法设计基础', '§ 2.2 同余算术及其应用', '2.2.2 同余方程与方程组']","{'实体类型': '概念', '定义': '由多个以x为未知整数的同余方程联立而成的方程组'}",,3,"相等的两个整数除以某一正整数$m$ 后得到的余数自然是相等的。因此，两个整数之间的同余关系不仅可以看成是对整除关系的一种推广，而且还可以看成是对两个整数相等关系的一种推广。下面定理表明整数相等关系与同余关系自己具有共同本质属性。  
【定理2.25】假设$m$ 是任一给定的正整数，则模$m$ 同余关系满足下列性质：  
(1) 自反性：$a\equiv a({\bmod{\ m}})$，对一切整数$a$ 成立；  
(2) 对称性：若$a\equiv b({\bmod{\ }}m)$，则$b\equiv a({\bmod{\ m}}).$；  
(3) 传递性：若$a\equiv b({\bmod{\ }}m)$，$b\equiv c({{\pmod{m}}})$，则$a\equiv c({{\pmod{m}}}).$。  
我们知道，根据整数之间相等关系的制约可以列出相应的整数方程和方程组。那么，根据整数同余关系的制约是否也可以列出相应的方程和方程组呢？如果可以，那么这些方程和方程组如何求解？本节我们就来讨论这些问题。  
【定义2.14】假设$m$ 是任一给定的正整数，$a$ 和$b$ 是任意给定的两个整数，下式：  
$$
a x\equiv b({\bmod{m}})\tag{2-13}
$$  
称为关于未知数$x$ 的一次线性同余方程，简称为同余方程，其中$x$ 为未知整数。若存在一个整数$\cdot x_{0}$，当$x=x_{0}$时，成立$.a x\equiv b({\bmod{\pmod{m}}})$，则称$\cdot x_{0}$是该同余方程的一个解。  
显然，如果$x_{0}$是某个同余方程的一个解，则与$x_{0}$同余的所有整数都是该同余方程的解，这是一种平凡情形，通常将与$x_{0}$同余的所有整数与$x_{0}$一起看成是同一个解。因此，同余方程解的计数标准为：凡是相互之间模$m$ 同余的解都视为同一个解，同余方程解的个数是指它的关于模$m$ 互不同余所有解的个数，亦即在模$m$ 的一个完全剩余系中解的个数。  
下面考察一次线性同余方程解的存在性：  
【定理2.26】假设$m$ 是任一给定的正整数，$a,b$ 是任意给定的两个整数，如果$a$ 与$m$之间没有整除关系，即有$a\not\equiv0({\bmod{m}})$ ，则下列同余方程  
$$
a x\equiv b({\bmod{m}})
$$  
有解的充要条件是$a$ 与$m$ 的最大公因数能够整除$b$。若有解，则解的个数为$\operatorname*{gcd}(a,m)$。  
对于同余方程$a\cdot x \equiv 1(\mod m)$，其有解的充要条件是$a$ 与$m$ 的最大公因数能够整除1，即互素$a$ 与$m$。且有解的情况下只有唯一解。由此给出如下关于$\bar{a}$的定义：  
【定义2.15】设$m$ 是任一给定的正整数，$a$ 是任一与$m$ 互素的整数，满足$a\cdot x\equiv$1 (mod $m^{\prime}$)的最小正整数解称为整数$a$的模$\pmb{m}$ 逆，记为$\cdot\bar{a}$。  
下面定理的证明过程给出了整数$a$ 模$m$ 逆$\bar{a}$的一个具体求法：  
【定理2.27】设$m$ 和$a$ 是两个互素的整数，且$m>1$，则存在唯一一个小于$m$ 的正整数$\bar{a}$，它是$a$ 的模$m$ 逆，即有：${\bar{a}}\cdot a\equiv1({\bmod{{m}}})$。  
【定义2.16】假设$m_{1},m_{2},\cdots,m_{k}$为$k$个正整数，$a_{1},a_{2},\cdots,a_{k}$为$k$ 个整数，由下列$k$ 个以$x$ 为未知整数的同余方程联立而成的方程组，称为同余方程组：  
$$
\left\{\begin{array}{l l}{x\equiv a_{1}(\bmod~m_{1})}\\ {x\equiv a_{2}(\bmod m_{2})}\\ {\qquad\dots}\\ {x\equiv a_{k}(\bmod~m_{k})}\end{array}\right.\tag{2-14}
$$  
若存在一个整数$\cdot x_{0}$满足上述所有同余方程，则称$\cdot x_{0}$是该同余方程组的一个解。  
当以上定义的同余方程组中所有模两两互素时，方程组一定有唯一的一组解。下面的中国余数定理是整数理论中一个非常著名的定理，又称为孙子定理。该定理不仅确认了上述结论，而且其证明过程其实给出了一个具体的求解方法。  
【定理2.28】（中国余数定理）设$m_{1}$$\cdot\ \ m_{2},\ \ \cdots m_{k}$是两两互素的正整数，那么同余式组（2-14）有唯一的以$M=m_{1}m_{2}\cdots m_{k}$为模的解。"
同余方程解的存在性,定理,"['第二章  整数与算法设计基础', '§ 2.2 同余算术及其应用', '2.2.2 同余方程与方程组']","{'实体类型': '定理', '条件': 'a与m没有整除关系', '结论': '有解的充要条件是a与m的最大公因数能够整除b'}",,3,"相等的两个整数除以某一正整数$m$ 后得到的余数自然是相等的。因此，两个整数之间的同余关系不仅可以看成是对整除关系的一种推广，而且还可以看成是对两个整数相等关系的一种推广。下面定理表明整数相等关系与同余关系自己具有共同本质属性。  
【定理2.25】假设$m$ 是任一给定的正整数，则模$m$ 同余关系满足下列性质：  
(1) 自反性：$a\equiv a({\bmod{\ m}})$，对一切整数$a$ 成立；  
(2) 对称性：若$a\equiv b({\bmod{\ }}m)$，则$b\equiv a({\bmod{\ m}}).$；  
(3) 传递性：若$a\equiv b({\bmod{\ }}m)$，$b\equiv c({{\pmod{m}}})$，则$a\equiv c({{\pmod{m}}}).$。  
我们知道，根据整数之间相等关系的制约可以列出相应的整数方程和方程组。那么，根据整数同余关系的制约是否也可以列出相应的方程和方程组呢？如果可以，那么这些方程和方程组如何求解？本节我们就来讨论这些问题。  
【定义2.14】假设$m$ 是任一给定的正整数，$a$ 和$b$ 是任意给定的两个整数，下式：  
$$
a x\equiv b({\bmod{m}})\tag{2-13}
$$  
称为关于未知数$x$ 的一次线性同余方程，简称为同余方程，其中$x$ 为未知整数。若存在一个整数$\cdot x_{0}$，当$x=x_{0}$时，成立$.a x\equiv b({\bmod{\pmod{m}}})$，则称$\cdot x_{0}$是该同余方程的一个解。  
显然，如果$x_{0}$是某个同余方程的一个解，则与$x_{0}$同余的所有整数都是该同余方程的解，这是一种平凡情形，通常将与$x_{0}$同余的所有整数与$x_{0}$一起看成是同一个解。因此，同余方程解的计数标准为：凡是相互之间模$m$ 同余的解都视为同一个解，同余方程解的个数是指它的关于模$m$ 互不同余所有解的个数，亦即在模$m$ 的一个完全剩余系中解的个数。  
下面考察一次线性同余方程解的存在性：  
【定理2.26】假设$m$ 是任一给定的正整数，$a,b$ 是任意给定的两个整数，如果$a$ 与$m$之间没有整除关系，即有$a\not\equiv0({\bmod{m}})$ ，则下列同余方程  
$$
a x\equiv b({\bmod{m}})
$$  
有解的充要条件是$a$ 与$m$ 的最大公因数能够整除$b$。若有解，则解的个数为$\operatorname*{gcd}(a,m)$。  
对于同余方程$a\cdot x \equiv 1(\mod m)$，其有解的充要条件是$a$ 与$m$ 的最大公因数能够整除1，即互素$a$ 与$m$。且有解的情况下只有唯一解。由此给出如下关于$\bar{a}$的定义：  
【定义2.15】设$m$ 是任一给定的正整数，$a$ 是任一与$m$ 互素的整数，满足$a\cdot x\equiv$1 (mod $m^{\prime}$)的最小正整数解称为整数$a$的模$\pmb{m}$ 逆，记为$\cdot\bar{a}$。  
下面定理的证明过程给出了整数$a$ 模$m$ 逆$\bar{a}$的一个具体求法：  
【定理2.27】设$m$ 和$a$ 是两个互素的整数，且$m>1$，则存在唯一一个小于$m$ 的正整数$\bar{a}$，它是$a$ 的模$m$ 逆，即有：${\bar{a}}\cdot a\equiv1({\bmod{{m}}})$。  
【定义2.16】假设$m_{1},m_{2},\cdots,m_{k}$为$k$个正整数，$a_{1},a_{2},\cdots,a_{k}$为$k$ 个整数，由下列$k$ 个以$x$ 为未知整数的同余方程联立而成的方程组，称为同余方程组：  
$$
\left\{\begin{array}{l l}{x\equiv a_{1}(\bmod~m_{1})}\\ {x\equiv a_{2}(\bmod m_{2})}\\ {\qquad\dots}\\ {x\equiv a_{k}(\bmod~m_{k})}\end{array}\right.\tag{2-14}
$$  
若存在一个整数$\cdot x_{0}$满足上述所有同余方程，则称$\cdot x_{0}$是该同余方程组的一个解。  
当以上定义的同余方程组中所有模两两互素时，方程组一定有唯一的一组解。下面的中国余数定理是整数理论中一个非常著名的定理，又称为孙子定理。该定理不仅确认了上述结论，而且其证明过程其实给出了一个具体的求解方法。  
【定理2.28】（中国余数定理）设$m_{1}$$\cdot\ \ m_{2},\ \ \cdots m_{k}$是两两互素的正整数，那么同余式组（2-14）有唯一的以$M=m_{1}m_{2}\cdots m_{k}$为模的解。"
同余算术,概念,"['第二章  整数与算法设计基础', '2.2.2 同余方程与方程组', '2.2.3 整数加密算法', '§ 2.2 同余算术及其应用']","{'实体类型': '概念', '定义': ['从带余除法的角度对整除的概念进行推广，要求两个整数被某个除数做带余除法后得到的余数相等', '两个整数除以某一正整数后得到的余数相等的关系'], '特点': '比整除的约束宽松', '地位': '是整数理论的重要发展并构成初等数论的理论核心', '应用': ['在整数加密算法设计等多个领域得到广泛应用', '对整除关系和整数相等关系的推广', '用于数据加密技术']}",,2,前面关于整数理论的讨论主要基于整数整除的概念与性质。由于整除是一个是整数之间一个比较强的约束关系，很多整数都不能满足，因此引入一种具有普适性的带余除法概念，将整数的整除归结为一种余数为0 的特殊带余除法。德国数学家高斯则是从带余除法的角度对整除的概念进行推广，引入同余的概念及相关算术。从带余除法的角度看，同余并非像整除那样要求余数一定为0，而只要求两个整数被某个除数做带余除法后得到的余数相等，这个约束显然比整除的约束宽松很多。同余算术是整理理论一个重要发展并构成初等数论的理论核心，它从在一种比整除约束更为宽松的条件下考察整数的运算及性质并得到很多非常精彩的数论成果，这些成果在整数加密算法设计等多个领域得到广泛应用。本节主要介绍同余算术的概念、性质与应用，具体包括同余关系及其运算、剩余系的概念与性质、同余方程与方程组的求解、若干经典的整数加密算法。
同余类的加法和乘法运算,定义,"['第二章  整数与算法设计基础', '§ 2.2 同余算术及其应用', '2.2.1 同余关系及其运算']","{'实体类型': '定义', '内容': '假设m是任一给定的正整数对于任意给定的两个整数a和b，定义：[a]m+[b]m=[a+b]m，[a]m·[b]m=[a·b]m'}",,3,"在很多场合，我们往往只关心用某一特定正整数除以整数得到的余数。例如，星期日期就是从某个星期日开始经历的天数除以7 得到的余数，通过对天数取以7 为除数的余数，就可以用短短的7 个数字借助以7 为周期的循环机制表示无穷无尽的天数。事实上，取余数是一种以有限驾驭无限的重要智慧，对于任一给定的正整数$m$，通过考察所有整数除以$m$ 所得余数的差异，把所有具有相同余数的整数归为一类，则可将所有整数分为$m$ 个基本类型。若分别从每个类中取一个整数作为代表构成一个$m$ 元有限集，则可将这个有限集看成是对整数集的一个抽象，由此完成了整数集从无限向有限的转化。在这个分类过程中，整数之间是否具有相同余数的关系起着非常关键的作用，由此得到如下同余的概念：  
【定义2.9】假设$m$ 是任一给定的正整数，对于任意两个整数$a$和$b$，它们除以$m$ 后得到的余数分别记为$a({\bmod{\ m}})$和$b({\bmod{\ m}})$，如果这两个余数相等，即有：  
$$
a({\bmod{\ m}})=b({\bmod{\ m}})\tag{2-9}
$$  
则称$a$与$b$具有模$\pmb{m}$同余关系，简称为$a$与$b$模$\pmb{m}$同余或同余，记为$a\equiv b({\bmod{m}})$或$b\equiv$$a({\bmod{\ m}})$；否则称$a$与$b$对于模$\mathbfit{m}$不同余，记为$a\not\equiv b({\bmod{{m}}})$或$b\not\equiv a({\bmod{\ m}})$。  
根据上述定义，不难证明下面关于模$_m$同余的判定定理：  
【定理2.19】假设$m$是任一给定的正整数，任意两个整数$a$和$b$具有模$_m$同余关系，当且仅当$m$能够整除$a-b$。  
【定理2.20】假设$m$ 是任一给定的正整数，任意两个整数$a$ 和$b$ 具有模$m$同余关系，  
当且仅当存在整数$k$，使得整除$a=b+k m$  
下面定理表明了同余关系的保加性和保乘性：  
【定理2.21】设$m$ 是任一正整数，若整数$a$ 与$b$ 模$m$ 同余，整数$c$与$d$ 同余模$m$，则它们的和与积也分别模$m$ 同余。即：若$a\equiv b({\bmod{\ }}m)$，$c\equiv d({\bmod{\pmod{m}}})$，则有：  
$$
a+c\equiv(b+d)(\bmod{\ m}),\ \ a c\equiv b d(\bmod{\ m})
$$  
【定理2.22】假设$m$ 是任一给定的正整数，则对任意两个整数$a$ 和$b$，成立下面两个关于余数的计算公式：  
$$
(a+b){\bmod{\ m}}=((a{\bmod{\ m}})+(b{\bmod{\ m}})){\bmod{\ m}}\tag{2-10}
$$  
$$
ab\ {\bmod{\ m}}=((a{\bmod{\ m}})(b{\bmod{\ m}}))\ {\bmod{\ m}}\tag{2-11}
$$  
例如，对于$7\equiv2{\bmod{\mathrm{~5~}}}$和$11\equiv1{\bmod{\mathrm{~5~}}}$，由定理2.21 知：  
$$
18=7+11\equiv2+1=3({\bmod{\mathrm{~}}}5)
$$  
$$
77=7\cdot11\equiv2\cdot1=2{\pmod{5}}
$$  
再如，对于任意三个数，比如说1, 2 和5，由定理2.22 知存在如下等式：  
$$
(1+2)({\bmod{\ }}5)=((1\ \,({\bmod{\ }}5)+(2\ \,({\bmod{\ }}5))({\bmod{\ }}5)
$$  
$$
2\,\bmod\,5=\left((1\,\bmod\,5)(2\,\bmod\,5)\right)\,(\bmod\,5)
$$  
值得注意的是，同余关系在一般情况下不满足消去律，例如 $8\equiv12({\bmod{\mathrm{~}}}4)$，两边同除以4 后，$2\equiv3({\bmod{\mathrm{~}}}4)$显然是不成立的，但是存在下列性质：  
【定理2.23】若$a c\equiv b c({\bmod{\pmod{m}}})$，且$c$ 与$m$ 互素，则有：$a\equiv b({\bmod{\ }}m)$  
如前所述，使用同余可以实现对整数集合的划分或分类，现在就来讨论这个问题。由同余的定义可知，对于任意给定的正整数$m$，可依照除以$m$ 后的余数值以及模$m$ 同余关系，将所有整数划分为$m$ 个互不相交的子集合。据此，我们引入如下同余类的概念：  
【定义2.10】设$m$ 是任一给定正整数，对于每个整数$i$，$0\leq i<m$，定义如下集合：  
$$
R_{i}(m)=\{n|n\equiv i({\bmod{\pmod{\ m}}},n\in Z\}\tag{2-12}
$$  
则称每个$^{}R_{i}(m)$分别是模$m$ 的一个同余类或剩余类，在不引起混淆的情况下，通常也将$R_{i}(m)$简记为$[i]$，并记为：$Z_{m}=\{[0],[1],\cdots[m-1]\}.$。  
【定理2.24】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m),$所有模$m$ 同余类，则有下述结论成立：  
（1）每个整数$a$ 都恰好属于某个同余类，通常将这个同余类记为$[a]_{m}$或$[a]$  
（2）对于任意的两个整数$a$ 和$b$，它们属于同一个同余类的充分必要条件是：
$$
a\equiv b({\bmod{m}})
$$  
上述定理表明，每个整数必定属于且仅属于其中一个剩余类，属于同一个剩余类的任意两个整数都是模$m$ 同余的，属于不同剩余类的任意两个整数不可能是模$m$ 同余的。  
根据定理，可以在$.Z_{m}=\{[0],[1],\cdots[m-1]\}$上定义关于同余类的加法和乘法运算：  
【定义2.11】假设$m$ 是任一给定的正整数对于任意给定的两个整数$a$和$b$，定义：
$$
[a]_{m}+[b]_{m}=[a+b]_{m}
$$  
$$
[a]_{m}\cdot[b]_{m}=[a\cdot b]_{m}
$$  
【定义2.12】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m)$是所有模$m$ 同余类，如果从每个同余类$R_{i}(m)$中分别取一个整数$x_{i}$构成一个$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$，则称该有限集合为模$m$ 的一个完全剩余系，简称为完全系；称$m$ 元有限集合$\{0,\ 1,\ 2,\ \cdots\ ,$为最小非负完全剩余系。  
对于正整数$m$，假设$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$是模$m$ 的一个完全剩余系，对于其中的任意一个整数$\cdot x_{i}$，如果${\bf\nabla}_{}^{}$与$m$ 互素，则$x_{i}$所在同余类${\mathbf{}}R_{i}(m)$中每个整数$k$ 都与$m$ 互素。这是因为根据$k\equiv x_{i}({\bmod{\pmod{m}}})$，即有$\cdot_{x_{i}}=k+q m$。由此可知，如果$k$ 与$m$有大于1 的公因子，那么$x_{i}$必然与$m$ 有大于1 的公因子。类似地，如果$x_{i}$与$m$ 互素，则$x_{i}$所在同余类$R_{i}(m)$中每个整数$k$ 都与$m$ 不互素。由此得到如下简化同余类和简化剩余系的概念：  
【定义2.13】对于正整数$m$，假设$R_{i}(m)$是任意一个模$m$ 同余类，若$R_{i}(m)$中存在一个整数与 $m$  互素，则称 $\ R_{i}(m)$ 是一个模 $\pmb{m}$  简化同余类或模 $\pmb{m}$  简化剩余类。如果分别从每个模 $m$ 简化同余类中取出一个整数作为代表$x_{i}$构成一个有限集合$\{x_{0},\ x_{1},\ \cdots,x_{\varphi(m-1)}\}$，则称该集合为模$m$ 的一个简化剩余系，简称为简化系。其中$\varphi(m)$称为欧拉函数，表示模$m$ 简化剩余类的数目，亦即不超过$m$ 且与$m$ 互素的正整数个数。  
因为所有模$m$ 同余类构成整数集合的一个划分，所以每个与$m$ 互质的整数仅存在于它  所在的简化同余类中。由此可以看出，简化同余类以及欧拉函数$\varphi(m)$在整数互质性质的研究中具有非常重要的作用，后面将使用这些概念证明欧拉定理和费马小定理。这两个定理不仅是整数理论中非常著名而重要的定理，而且还是现代非对称数论加密算法的基础。"
同余类的性质,定理,"['第二章  整数与算法设计基础', '§ 2.2 同余算术及其应用', '2.2.1 同余关系及其运算']","{'实体类型': '定理', '内容': '假设m是任一给定的正整数，R0(m),R1(m),⋯,Rm-1(m)，所有模m同余类，则有下述结论成立：（1）每个整数a都恰好属于某个同余类，通常将这个同余类记为[a]m或[a]；（2）对于任意的两个整数a和b，它们属于同一个同余类的充分必要条件是a≡b(mod m)'}",,3,"在很多场合，我们往往只关心用某一特定正整数除以整数得到的余数。例如，星期日期就是从某个星期日开始经历的天数除以7 得到的余数，通过对天数取以7 为除数的余数，就可以用短短的7 个数字借助以7 为周期的循环机制表示无穷无尽的天数。事实上，取余数是一种以有限驾驭无限的重要智慧，对于任一给定的正整数$m$，通过考察所有整数除以$m$ 所得余数的差异，把所有具有相同余数的整数归为一类，则可将所有整数分为$m$ 个基本类型。若分别从每个类中取一个整数作为代表构成一个$m$ 元有限集，则可将这个有限集看成是对整数集的一个抽象，由此完成了整数集从无限向有限的转化。在这个分类过程中，整数之间是否具有相同余数的关系起着非常关键的作用，由此得到如下同余的概念：  
【定义2.9】假设$m$ 是任一给定的正整数，对于任意两个整数$a$和$b$，它们除以$m$ 后得到的余数分别记为$a({\bmod{\ m}})$和$b({\bmod{\ m}})$，如果这两个余数相等，即有：  
$$
a({\bmod{\ m}})=b({\bmod{\ m}})\tag{2-9}
$$  
则称$a$与$b$具有模$\pmb{m}$同余关系，简称为$a$与$b$模$\pmb{m}$同余或同余，记为$a\equiv b({\bmod{m}})$或$b\equiv$$a({\bmod{\ m}})$；否则称$a$与$b$对于模$\mathbfit{m}$不同余，记为$a\not\equiv b({\bmod{{m}}})$或$b\not\equiv a({\bmod{\ m}})$。  
根据上述定义，不难证明下面关于模$_m$同余的判定定理：  
【定理2.19】假设$m$是任一给定的正整数，任意两个整数$a$和$b$具有模$_m$同余关系，当且仅当$m$能够整除$a-b$。  
【定理2.20】假设$m$ 是任一给定的正整数，任意两个整数$a$ 和$b$ 具有模$m$同余关系，  
当且仅当存在整数$k$，使得整除$a=b+k m$  
下面定理表明了同余关系的保加性和保乘性：  
【定理2.21】设$m$ 是任一正整数，若整数$a$ 与$b$ 模$m$ 同余，整数$c$与$d$ 同余模$m$，则它们的和与积也分别模$m$ 同余。即：若$a\equiv b({\bmod{\ }}m)$，$c\equiv d({\bmod{\pmod{m}}})$，则有：  
$$
a+c\equiv(b+d)(\bmod{\ m}),\ \ a c\equiv b d(\bmod{\ m})
$$  
【定理2.22】假设$m$ 是任一给定的正整数，则对任意两个整数$a$ 和$b$，成立下面两个关于余数的计算公式：  
$$
(a+b){\bmod{\ m}}=((a{\bmod{\ m}})+(b{\bmod{\ m}})){\bmod{\ m}}\tag{2-10}
$$  
$$
ab\ {\bmod{\ m}}=((a{\bmod{\ m}})(b{\bmod{\ m}}))\ {\bmod{\ m}}\tag{2-11}
$$  
例如，对于$7\equiv2{\bmod{\mathrm{~5~}}}$和$11\equiv1{\bmod{\mathrm{~5~}}}$，由定理2.21 知：  
$$
18=7+11\equiv2+1=3({\bmod{\mathrm{~}}}5)
$$  
$$
77=7\cdot11\equiv2\cdot1=2{\pmod{5}}
$$  
再如，对于任意三个数，比如说1, 2 和5，由定理2.22 知存在如下等式：  
$$
(1+2)({\bmod{\ }}5)=((1\ \,({\bmod{\ }}5)+(2\ \,({\bmod{\ }}5))({\bmod{\ }}5)
$$  
$$
2\,\bmod\,5=\left((1\,\bmod\,5)(2\,\bmod\,5)\right)\,(\bmod\,5)
$$  
值得注意的是，同余关系在一般情况下不满足消去律，例如 $8\equiv12({\bmod{\mathrm{~}}}4)$，两边同除以4 后，$2\equiv3({\bmod{\mathrm{~}}}4)$显然是不成立的，但是存在下列性质：  
【定理2.23】若$a c\equiv b c({\bmod{\pmod{m}}})$，且$c$ 与$m$ 互素，则有：$a\equiv b({\bmod{\ }}m)$  
如前所述，使用同余可以实现对整数集合的划分或分类，现在就来讨论这个问题。由同余的定义可知，对于任意给定的正整数$m$，可依照除以$m$ 后的余数值以及模$m$ 同余关系，将所有整数划分为$m$ 个互不相交的子集合。据此，我们引入如下同余类的概念：  
【定义2.10】设$m$ 是任一给定正整数，对于每个整数$i$，$0\leq i<m$，定义如下集合：  
$$
R_{i}(m)=\{n|n\equiv i({\bmod{\pmod{\ m}}},n\in Z\}\tag{2-12}
$$  
则称每个$^{}R_{i}(m)$分别是模$m$ 的一个同余类或剩余类，在不引起混淆的情况下，通常也将$R_{i}(m)$简记为$[i]$，并记为：$Z_{m}=\{[0],[1],\cdots[m-1]\}.$。  
【定理2.24】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m),$所有模$m$ 同余类，则有下述结论成立：  
（1）每个整数$a$ 都恰好属于某个同余类，通常将这个同余类记为$[a]_{m}$或$[a]$  
（2）对于任意的两个整数$a$ 和$b$，它们属于同一个同余类的充分必要条件是：
$$
a\equiv b({\bmod{m}})
$$  
上述定理表明，每个整数必定属于且仅属于其中一个剩余类，属于同一个剩余类的任意两个整数都是模$m$ 同余的，属于不同剩余类的任意两个整数不可能是模$m$ 同余的。  
根据定理，可以在$.Z_{m}=\{[0],[1],\cdots[m-1]\}$上定义关于同余类的加法和乘法运算：  
【定义2.11】假设$m$ 是任一给定的正整数对于任意给定的两个整数$a$和$b$，定义：
$$
[a]_{m}+[b]_{m}=[a+b]_{m}
$$  
$$
[a]_{m}\cdot[b]_{m}=[a\cdot b]_{m}
$$  
【定义2.12】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m)$是所有模$m$ 同余类，如果从每个同余类$R_{i}(m)$中分别取一个整数$x_{i}$构成一个$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$，则称该有限集合为模$m$ 的一个完全剩余系，简称为完全系；称$m$ 元有限集合$\{0,\ 1,\ 2,\ \cdots\ ,$为最小非负完全剩余系。  
对于正整数$m$，假设$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$是模$m$ 的一个完全剩余系，对于其中的任意一个整数$\cdot x_{i}$，如果${\bf\nabla}_{}^{}$与$m$ 互素，则$x_{i}$所在同余类${\mathbf{}}R_{i}(m)$中每个整数$k$ 都与$m$ 互素。这是因为根据$k\equiv x_{i}({\bmod{\pmod{m}}})$，即有$\cdot_{x_{i}}=k+q m$。由此可知，如果$k$ 与$m$有大于1 的公因子，那么$x_{i}$必然与$m$ 有大于1 的公因子。类似地，如果$x_{i}$与$m$ 互素，则$x_{i}$所在同余类$R_{i}(m)$中每个整数$k$ 都与$m$ 不互素。由此得到如下简化同余类和简化剩余系的概念：  
【定义2.13】对于正整数$m$，假设$R_{i}(m)$是任意一个模$m$ 同余类，若$R_{i}(m)$中存在一个整数与 $m$  互素，则称 $\ R_{i}(m)$ 是一个模 $\pmb{m}$  简化同余类或模 $\pmb{m}$  简化剩余类。如果分别从每个模 $m$ 简化同余类中取出一个整数作为代表$x_{i}$构成一个有限集合$\{x_{0},\ x_{1},\ \cdots,x_{\varphi(m-1)}\}$，则称该集合为模$m$ 的一个简化剩余系，简称为简化系。其中$\varphi(m)$称为欧拉函数，表示模$m$ 简化剩余类的数目，亦即不超过$m$ 且与$m$ 互素的正整数个数。  
因为所有模$m$ 同余类构成整数集合的一个划分，所以每个与$m$ 互质的整数仅存在于它  所在的简化同余类中。由此可以看出，简化同余类以及欧拉函数$\varphi(m)$在整数互质性质的研究中具有非常重要的作用，后面将使用这些概念证明欧拉定理和费马小定理。这两个定理不仅是整数理论中非常著名而重要的定理，而且还是现代非对称数论加密算法的基础。"
同余类的概念,定义,"['第二章  整数与算法设计基础', '§ 2.2 同余算术及其应用', '2.2.1 同余关系及其运算']","{'实体类型': '定义', '内容': '设m是任一给定正整数，对于每个整数i，0≤i<m，定义如下集合：Ri(m)={n|n≡i(mod m),n∈Z}，则称每个Ri(m)分别是模m的一个同余类或剩余类，在不引起混淆的情况下，通常也将Ri(m)简记为[i]，并记为：Zm={[0],[1],⋯[m-1]}'}",,3,"在很多场合，我们往往只关心用某一特定正整数除以整数得到的余数。例如，星期日期就是从某个星期日开始经历的天数除以7 得到的余数，通过对天数取以7 为除数的余数，就可以用短短的7 个数字借助以7 为周期的循环机制表示无穷无尽的天数。事实上，取余数是一种以有限驾驭无限的重要智慧，对于任一给定的正整数$m$，通过考察所有整数除以$m$ 所得余数的差异，把所有具有相同余数的整数归为一类，则可将所有整数分为$m$ 个基本类型。若分别从每个类中取一个整数作为代表构成一个$m$ 元有限集，则可将这个有限集看成是对整数集的一个抽象，由此完成了整数集从无限向有限的转化。在这个分类过程中，整数之间是否具有相同余数的关系起着非常关键的作用，由此得到如下同余的概念：  
【定义2.9】假设$m$ 是任一给定的正整数，对于任意两个整数$a$和$b$，它们除以$m$ 后得到的余数分别记为$a({\bmod{\ m}})$和$b({\bmod{\ m}})$，如果这两个余数相等，即有：  
$$
a({\bmod{\ m}})=b({\bmod{\ m}})\tag{2-9}
$$  
则称$a$与$b$具有模$\pmb{m}$同余关系，简称为$a$与$b$模$\pmb{m}$同余或同余，记为$a\equiv b({\bmod{m}})$或$b\equiv$$a({\bmod{\ m}})$；否则称$a$与$b$对于模$\mathbfit{m}$不同余，记为$a\not\equiv b({\bmod{{m}}})$或$b\not\equiv a({\bmod{\ m}})$。  
根据上述定义，不难证明下面关于模$_m$同余的判定定理：  
【定理2.19】假设$m$是任一给定的正整数，任意两个整数$a$和$b$具有模$_m$同余关系，当且仅当$m$能够整除$a-b$。  
【定理2.20】假设$m$ 是任一给定的正整数，任意两个整数$a$ 和$b$ 具有模$m$同余关系，  
当且仅当存在整数$k$，使得整除$a=b+k m$  
下面定理表明了同余关系的保加性和保乘性：  
【定理2.21】设$m$ 是任一正整数，若整数$a$ 与$b$ 模$m$ 同余，整数$c$与$d$ 同余模$m$，则它们的和与积也分别模$m$ 同余。即：若$a\equiv b({\bmod{\ }}m)$，$c\equiv d({\bmod{\pmod{m}}})$，则有：  
$$
a+c\equiv(b+d)(\bmod{\ m}),\ \ a c\equiv b d(\bmod{\ m})
$$  
【定理2.22】假设$m$ 是任一给定的正整数，则对任意两个整数$a$ 和$b$，成立下面两个关于余数的计算公式：  
$$
(a+b){\bmod{\ m}}=((a{\bmod{\ m}})+(b{\bmod{\ m}})){\bmod{\ m}}\tag{2-10}
$$  
$$
ab\ {\bmod{\ m}}=((a{\bmod{\ m}})(b{\bmod{\ m}}))\ {\bmod{\ m}}\tag{2-11}
$$  
例如，对于$7\equiv2{\bmod{\mathrm{~5~}}}$和$11\equiv1{\bmod{\mathrm{~5~}}}$，由定理2.21 知：  
$$
18=7+11\equiv2+1=3({\bmod{\mathrm{~}}}5)
$$  
$$
77=7\cdot11\equiv2\cdot1=2{\pmod{5}}
$$  
再如，对于任意三个数，比如说1, 2 和5，由定理2.22 知存在如下等式：  
$$
(1+2)({\bmod{\ }}5)=((1\ \,({\bmod{\ }}5)+(2\ \,({\bmod{\ }}5))({\bmod{\ }}5)
$$  
$$
2\,\bmod\,5=\left((1\,\bmod\,5)(2\,\bmod\,5)\right)\,(\bmod\,5)
$$  
值得注意的是，同余关系在一般情况下不满足消去律，例如 $8\equiv12({\bmod{\mathrm{~}}}4)$，两边同除以4 后，$2\equiv3({\bmod{\mathrm{~}}}4)$显然是不成立的，但是存在下列性质：  
【定理2.23】若$a c\equiv b c({\bmod{\pmod{m}}})$，且$c$ 与$m$ 互素，则有：$a\equiv b({\bmod{\ }}m)$  
如前所述，使用同余可以实现对整数集合的划分或分类，现在就来讨论这个问题。由同余的定义可知，对于任意给定的正整数$m$，可依照除以$m$ 后的余数值以及模$m$ 同余关系，将所有整数划分为$m$ 个互不相交的子集合。据此，我们引入如下同余类的概念：  
【定义2.10】设$m$ 是任一给定正整数，对于每个整数$i$，$0\leq i<m$，定义如下集合：  
$$
R_{i}(m)=\{n|n\equiv i({\bmod{\pmod{\ m}}},n\in Z\}\tag{2-12}
$$  
则称每个$^{}R_{i}(m)$分别是模$m$ 的一个同余类或剩余类，在不引起混淆的情况下，通常也将$R_{i}(m)$简记为$[i]$，并记为：$Z_{m}=\{[0],[1],\cdots[m-1]\}.$。  
【定理2.24】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m),$所有模$m$ 同余类，则有下述结论成立：  
（1）每个整数$a$ 都恰好属于某个同余类，通常将这个同余类记为$[a]_{m}$或$[a]$  
（2）对于任意的两个整数$a$ 和$b$，它们属于同一个同余类的充分必要条件是：
$$
a\equiv b({\bmod{m}})
$$  
上述定理表明，每个整数必定属于且仅属于其中一个剩余类，属于同一个剩余类的任意两个整数都是模$m$ 同余的，属于不同剩余类的任意两个整数不可能是模$m$ 同余的。  
根据定理，可以在$.Z_{m}=\{[0],[1],\cdots[m-1]\}$上定义关于同余类的加法和乘法运算：  
【定义2.11】假设$m$ 是任一给定的正整数对于任意给定的两个整数$a$和$b$，定义：
$$
[a]_{m}+[b]_{m}=[a+b]_{m}
$$  
$$
[a]_{m}\cdot[b]_{m}=[a\cdot b]_{m}
$$  
【定义2.12】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m)$是所有模$m$ 同余类，如果从每个同余类$R_{i}(m)$中分别取一个整数$x_{i}$构成一个$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$，则称该有限集合为模$m$ 的一个完全剩余系，简称为完全系；称$m$ 元有限集合$\{0,\ 1,\ 2,\ \cdots\ ,$为最小非负完全剩余系。  
对于正整数$m$，假设$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$是模$m$ 的一个完全剩余系，对于其中的任意一个整数$\cdot x_{i}$，如果${\bf\nabla}_{}^{}$与$m$ 互素，则$x_{i}$所在同余类${\mathbf{}}R_{i}(m)$中每个整数$k$ 都与$m$ 互素。这是因为根据$k\equiv x_{i}({\bmod{\pmod{m}}})$，即有$\cdot_{x_{i}}=k+q m$。由此可知，如果$k$ 与$m$有大于1 的公因子，那么$x_{i}$必然与$m$ 有大于1 的公因子。类似地，如果$x_{i}$与$m$ 互素，则$x_{i}$所在同余类$R_{i}(m)$中每个整数$k$ 都与$m$ 不互素。由此得到如下简化同余类和简化剩余系的概念：  
【定义2.13】对于正整数$m$，假设$R_{i}(m)$是任意一个模$m$ 同余类，若$R_{i}(m)$中存在一个整数与 $m$  互素，则称 $\ R_{i}(m)$ 是一个模 $\pmb{m}$  简化同余类或模 $\pmb{m}$  简化剩余类。如果分别从每个模 $m$ 简化同余类中取出一个整数作为代表$x_{i}$构成一个有限集合$\{x_{0},\ x_{1},\ \cdots,x_{\varphi(m-1)}\}$，则称该集合为模$m$ 的一个简化剩余系，简称为简化系。其中$\varphi(m)$称为欧拉函数，表示模$m$ 简化剩余类的数目，亦即不超过$m$ 且与$m$ 互素的正整数个数。  
因为所有模$m$ 同余类构成整数集合的一个划分，所以每个与$m$ 互质的整数仅存在于它  所在的简化同余类中。由此可以看出，简化同余类以及欧拉函数$\varphi(m)$在整数互质性质的研究中具有非常重要的作用，后面将使用这些概念证明欧拉定理和费马小定理。这两个定理不仅是整数理论中非常著名而重要的定理，而且还是现代非对称数论加密算法的基础。"
同态,概念,"['§ 11.1 代数结构的基本概念', '§ 11.3 同构、同态与同余', '11.1.1 数学结构与代数结构', '第十一章  抽象代数结构通论', '11.3.2  同构与同态与性质', '11.3.1  同构与同态的概念']","{'实体类型': '概念', '定义': ['两个代数结构之间存在保运算的映射，将同构映射推广到一般映射的代数结构关系', '设⟨A,*⟩和⟨B,∘⟩是任意两个给定的二元代数结构，如果存在集合A到集合B上的函数ψ，使得对于∀x1,x2∈A，有ψ(x1*x2)=ψ(x1)∘ψ(x2)，则称ψ是从⟨A,*⟩到⟨B,∘⟩的同态映射，并称⟨A,*⟩与⟨B,∘⟩同态，记为⟨A,*⟩∼⟨B,∘⟩', '代数结构之间的映射关系，保持运算性质'], '应用': ['考察代数结构之间的联系', '通过同态关系研究代数结构的性质'], '特点': ['不要求双射', '满同态保持二元运算的分配律和吸收律'], '分类': '若ψ为单射，则称⟨A,*⟩与⟨B,∘⟩为单同态；若ψ为满射，则称⟨A,*⟩与⟨B,∘⟩为满同态；若A=B，则称⟨A,*⟩与⟨B,∘⟩为满同态'}",,3,"代数结构作为四大基本数学结构之一，它以运算作为处理机制，在整个数学理论体系和计算机数学建模中占据非常重要的作用。代数结构是一种非常古老的数学结构，具有几千年发展历程，从最初初等代数逐步发展到大代数，然后进一步发展到抽象代数，目前正朝着泛代数的方向发展。本小节主要介绍抽象代数的由来及其基本知识结构。  
用计算机解决实际问题，一般需要对问题进行抽象并建立相应的数学模型，然后在此基础上将对实际问题的求解转化为对数学模型的求解。 因此，数学模型是用计算机解决实际问题的基础。现实问题纷繁复杂、变化万千，所建立的数学模型自然也是五花八门，多种多样，让人无所适从。值得欣慰的是，尽管我们面对的数学模型复杂多样，但从结构上看，所有这些数学模型都建立在四种基本的数学结构基础之上。  
这四种基本数学结构分别为：表示元素之间空间关系的拓扑结构，如图模型、树模型就是一些拓扑结构；表示元素之间运算关系的代数结构，如初等代数、向量代数、矩阵代数、命题代数、集合代数等都是代数结构；表示元素规模度量性质的测度结构，如高等数学里函数的微分和积分都是测度结构，它们主要计算面积、体积、弧长、速度等；表示元素之间次序关系的偏序结构，如整数的整除关系、集合的包含关系等偏序关系都是偏序结构。  
任何一个数学结构都是由载体、处理机制和处理规则这三个基本要素组成：  
（1）载体集合 对于任何一个数学结构，需要定义一些抽象的元素作为处理对象，这些抽象元素组成的集合构成数学结构的载体。载体集合是数学结构存在的基础或平台。  
（2）处理机制 为了实现对数学结构载体中元素的处理，需要定义一些处理机制，不同的数学结构具有不同的处理机制。例如：偏序结构是一种关系结构，它以元素之间的次序关系或者比较关系作为处理机制；代数结构是一种运算结构，它以元素之间的运算作为处理机制；拓扑结构是一种分布结构，它以元素之间的空间分布作为处理机制；测度结构则是一种度量结构，它以元素的规模度量作为处理机制。  
（3）处理规则 为使定义出来的数学结构满足一些合理性要求以及能够在处理实际问题中发挥作用，避免出现一些矛盾或荒诞的处理结果，还必须制定一些处理规则对处理机制做一些必要的限制。在现代数学的公理化系统中，通常称这些处理规则称为公理。不同的数学结构具有不同的处理规则，例如偏序结构限制元素之间的关系必须满足自反性、反对称性和传递性，这些限制或者性质构成了偏序结构公理系统；再如代数结构则是规定元素之间的运算必须满足结合律、交换律、分配律等运算性质。  
数学运算最早起源于算术运算，即使用具体的整数或分数进行四则运算。随着科学技术的不断发展，人们逐步意识到这种方法不能满足对一般性规律的认识。因此，采用抽象的字母来代替具体的整数和分数进行运算以获得通用性结果，并称之为代数运算或简称为代数。在微积分出现之前的数千年历史中，对代数运算的研究一直占据数学研究的核心地位。那时人们普遍信奉一种所谓的万能法则，即世界上所有问题都可以转化为数学问题，所有数学问题都可以转化为代数问题，所有代数问题都可以转化为方程问题。  
因此，在很长一段历史时期内，人们对数学的研究基本上都是对代数学的研究，对代数学的研究基本上是方程或方程组解法的研究。解方程是那个时期内所有数学家的中心任务，大家都非常期望能够通过使用代数运算的方法找到方程或方程组的通用求解公式。这种努力在线性方程组领域取得了非常完美的结果，并由初等代数逐步衍生出线性代数。但是，对于一元高次方程通用求解方法的研究并不是很顺利，对于次数高于四次的一元方程始终找不到通用求解公式或求解方法。一些非常著名的数学家，例如欧拉、高斯、拉格朗日等都对此做了大量非常艰苦的研究，但均告失败。  
在寻求五次方程通用求解方法的过程中，年仅17 岁的法国天才少年伽罗瓦在1828 年提出群的概念，运用群的思想证明了五次方程通用求解公式是不存在的，并给出了五次方程系数在满足一定条件下若干特殊解法，由此一举解决了困扰数学家长达200 多年的数学问题。伽罗瓦取得成功的关键在于不仅将运算对象进行抽象化，而且对运算本身进行抽象，在抽象对象和抽象运算的基础上通过构造一些特殊抽象代数结构进行求解。这个思想在当时实在过于超前以至于没有得到柯西、傅里叶、泊松等著名数学家的认可，泊松的判词是“完全不能理解”。 1832 年5 月31 日年仅21 岁的伽罗瓦死于决斗。在决斗之前，他把关于五次方程代数求解的研究成果写成长信，留给了人类。14 年后，法国数学家刘维尔整理并发表了伽罗瓦的遗作，人们才理解并惊叹他那超越时代的天才思想和巧妙构思。  
至此以后，人们对代数的研究内容由方程或方程组的求解技巧转变为对代数运算性质和运算结构的研究，通过对运算和运算对象进行抽象的方式实现对所有运算依其运算性质进行分类或归类，并将伽罗瓦的群论迅速发展成为一门称之为抽象代数结构的崭新数学分支。 抽象代数结构的诞生，把代数学从传统的初等代数发展到现代的抽象代数，由此打开了现代代数学的大门，开创了代数学研究的新纪元。因此，抽象代数结构通常也称为近世代数以区别于之前的初等代数。若无特别说明，我们通常将抽象代数结构简称为代数结构。  
经过一百多年的发展，抽象代数结构已经形成一个如图11-1 所示的知识体系。对于一个代数系统，我们不仅可以主动设计出它的运算并考察相应的运算规则，而且还可以通过分别对其载体集合进行相关改造或运算得到相应的子代数、积代数和商代数，可以通过映射的方式考察不同代数结构之间的区别与联系，还可根据运算性质对代数结构进行分类，形成若干典型抽象代数系统，如群、环、域、格等。  
![](images/37d476cf884c29ed65924bc021cb612de43bab4df8b1196f64e96cad4f61a01f.jpg)
图11-1 抽象代数结构的知识体系  
代数结构作为一种特殊的数学结构，具有载体、处理机制和处理规则这三个基本要素。如前所述，代数结构的载体就是由一些抽象对象为元素组成的集合，并通过运算机制实现对集合中元素的处理。所谓运算，其实就是通过映射的手段从已有元素中构造出新的元素。载体和运算统称为代数结构的成分。代数结构的处理规则即为运算性质。  
既然代数结构的载体是一个集合，那么就可以考虑通过一定方式由这个集合派生出新的集合并据此构造出新的代数结构。例如，可以考察其子集以及在子集上的运算，得到子代数的概念和性质；可以对作为载体的集合做笛卡尔集构成一个新的集合，并在新集合上定义相关运算，得到积代数的概念和性质；可以通过构造等价关系的方法实现对集合载体的划分，构成一个以等价类为元素的商集，并在这个商集上定义相关运算，得到商代数的概念和性质。子代数、积代数和商代数是构造和研究代数结构的基本方法论。  
当然，还可以考察两个代数结构之间的相似性与差异性。对于任意两个代数系统，可以在这两个代数结构的载体(集合)上建立一种保运算的映射，由此考察代数结构之间的联系。如果存在这种保运算映射，则称这两个代数系统同态。如果这种保运算的映射还是双射，则称这两个代数系统同构。同态和同构是考察代数结构之间联系的基本工具。  
依据代数结构的运算性质，可以将各种具体代数结构划分为若干抽象类型。典型的抽象代数结构类型主要有仅含一个二元运算的半群与群、含有两个二元运算的环与域，以及格与布尔代数。这些典型抽象代数结构构成代数结构知识体系的主要内容。"
同态映射,概念,"['第十二章 典型抽象代数结构', '§ 12.1 半群的概念与性质', '12.1.1 半群与含幺半群']","{'实体类型': '概念', '定义': '假设⟨G, *⟩和⟨H, ∘⟩是任意给定的两个半群，如果存在从G到H的保运算映射ψ，即对于∀x,y∈G，满足ψ(x*y)=ψ(x)∘ψ(y)', '分类': '单同态、满同态、同构映射'}",,3,"半群是一种比较简单而基本的抽象代数结构，要求其载体上的二元运算满足封闭性和结合律。半群的具体定义如下：  
【定义12.1】假设$G$是任意给定的一个非空集合，$*$为$G$上的一个二元运算且满足结合律，即对于$\forall $$\mathrm x,\mathrm{y,z\in~}G$，成立：  
$$
(x\circ y)\circ z=x\circ(y\circ z)\quad\text{(12-1)}
$$  
则称由𝐴和*组成的二元代数结构$\langle G,\ *\rangle$是一个半群。  
半群是一种非常常见的抽象代数结构，例如$\langle R, +\rangle_、\ \langle R,\ \times\rangle_、\ \langle P(A),\ \cup\rangle_、\ \langle P(A),\ \cap\rangle_、$$\langle A^{A},\ \circ\rangle$、$\langle M_{n}(R),\ +\rangle$、$\langle M_{n}(R)$, ⋅〉等，都是半群。  
在上述定义中，由于运算$*$为集合$G$上的二元运算，故对$G$满足运算的封闭性。因此，运算满足封闭性和结合律是半群的两个基本特征。另外，一般习惯上使用字母$G$表示群代数结构的载体集合，我们一般遵循这种习惯并总是假定$G$为非空集合。  
【定义12.2】假设$\langle G,\ *\rangle$是任意给定的一个半群，如果$\langle G,\ *\rangle$中含有关于运算${\ast}$的单位元𝑒，则称$\langle G,\ *\rangle$是一个含幺半群或独异点，记为$\langle G,\ *,\ e\rangle$。  
从上述定义可以看出，所谓含幺半群，其实就是一种含有幺元或单位元的特殊半群。例如$\mathsf\langle R,\ +\rangle_、\ \langle R,\ \times\rangle_、\ \langle P(A),\ \cup\rangle_、\ \langle P(A),\ \cap\rangle_、\ \langle A^{A},\ \circ\rangle_、\ \langle M_{n}(R),\ +\rangle_、\ \langle M_{n}(R),\ \cdot\}$ 等，都是含幺半群，0、1、空集$\varnothing$、全集$𝐴$、恒等映射、零矩阵、单位矩阵分别是其幺元。但是，$\langle R^{+},~+\rangle$则不是一个含幺半群，因为$R^{+}$作为正实数集合没有运算${+}$的单位元。  
【定义12.3】假设$\langle G,\ *\rangle$是一个半群，$S$是$G$的一个非空子集且运算$^*$对𝑆封闭，则称$\langle S,\ *\rangle$是$\langle G,\ *\rangle$的一个子半群；假设$\langle G,*,e\rangle$是一个含幺半群，$S$是$G$的一个非空子集且运算$^*$对𝑆封闭，则称$\langle S,*,e\rangle$是$\langle G,*,e\rangle$的一个子含幺半群。  
例如，对于含幺半群$\left<Z,\ +\right>$，令$Z_{n}=\{n x|x\in Z\}$，则对于$ n$取任何自然数，$\left\langle Z_{n},\ +\right\rangle$显然是$\left\langle Z,\ +\right\rangle$含幺子半群，且整数0 既是$\langle Z,\ +\rangle$的单位元也是$\left\langle Z_{n},\ +\right\rangle$的单位元。  
【定义12.4】假设$\langle G,*\rangle$和$\langle H,\circ\rangle$是任意给定的两个半群，如果存在从$G$到$H$的保运算映射  
$\psi$，即对于$\forall x,y\in G$，满足：  
$$
\psi(x*y)=\psi(x)\circ\psi(y)\quad\text{(12-5)}
$$  
则称$\psi$为从$\langle G,*\rangle$到$\langle H,\circ\rangle$的一个同态映射，并称$\langle G,*\rangle$与$\langle H,\circ\rangle$为同态。若$\psi$为单射，则称$\langle G,*\rangle$与$\langle H,\circ\rangle$为单同态；若$\psi$为满射，则称$\langle G,*\rangle$与$\langle H,\circ\rangle$为满同态；若$\psi$为双射，则称$\mathcal{\Psi}$为同构映射，并称$\langle G,*\rangle$与$\langle H,\circ\rangle$为同构。  
【定义12.5】假设$\langle G,*,e\rangle$和$\langle H,\circ,r\rangle$是任意给定的两个含幺半群，如果存在从$G$到$H$的保运算映射$\psi$，即对于$\forall x,y\in G$，满足：  
$$
\psi(x*y)=\psi(x)\circ\psi(y)\mathbb且\psi(e)=r
$$  
则称$\psi$为从$\langle G,*,e\rangle$到$\langle H,\circ,r\rangle$的一个同态映射，并称$\langle G,*,e\rangle$与$\langle H,\circ,r\rangle$为同态。若$\psi$为单射，则称 $\langle G,*,e\rangle$ 与 $\langle H,\circ,r\rangle$ 为单同态；若 $\psi$ 为满射，则称 $\langle G,*,e\rangle$ 与 $\langle H,\circ,r\rangle$ 为满同态；若 $\psi$ 为双射，则 称$\psi$为同构映射，并称$\langle G,*,e\rangle$与$\langle H,\circ,r\rangle$为同构。  
由于同构或同态的代数结构之间具有很多相同或相似的性质，因此，可在一般抽象代数结构与某个具体的代数结构之间建立一种同构或同态关系，通过比较直观考察具体代数结构的运算性质来研究一般抽象代数结构的运算性质，从而得到普适性的结论。这是研究和考察抽象代数结构的一种典型方法。下面结合具体实例介绍这种方法："
同构,概念,"['§ 11.1 代数结构的基本概念', '§ 11.3 同构、同态与同余', '11.3.1  同构与同态的概念', '第十二章 典型抽象代数结构', '§ 12.1 半群的概念与性质', '12.1.1 半群与含幺半群', '第十一章  抽象代数结构通论', '11.3.2  同构与同态与性质', '11.1.1 数学结构与代数结构']","{'实体类型': '概念', '定义': ['两个代数结构之间存在保运算的双射', '通过双射函数保持代数结构不变的映射', '设⟨A,*⟩和⟨B,∘⟩是任意两个给定的二元代数结构，如果存在集合A到集合B上的双射函数ψ，使得对于∀x1,x2∈A，有ψ(x1*x2)=ψ(x1)∘ψ(x2)，则称ψ是从⟨A,*⟩到⟨B,∘⟩的同构映射，并称⟨A,*⟩与⟨B,∘⟩同构，记为⟨A,*⟩≅⟨B,∘⟩', '两个代数结构之间具有完全相同的结构性质', '若ψ为双射，则称⟨G, *⟩与⟨H, ∘⟩为同构'], '特点': ['双射函数保持结构不变', '同构的两个代数结构具有完全相同的结构', '同构的两个代数系统之间的运算性质完全一样'], '应用': ['考察不同代数结构之间的区别与联系', '通过同构关系对代数系统进行分类和简化研究', '研究和考察抽象代数结构的一种典型方法']}",,3,"代数结构作为四大基本数学结构之一，它以运算作为处理机制，在整个数学理论体系和计算机数学建模中占据非常重要的作用。代数结构是一种非常古老的数学结构，具有几千年发展历程，从最初初等代数逐步发展到大代数，然后进一步发展到抽象代数，目前正朝着泛代数的方向发展。本小节主要介绍抽象代数的由来及其基本知识结构。  
用计算机解决实际问题，一般需要对问题进行抽象并建立相应的数学模型，然后在此基础上将对实际问题的求解转化为对数学模型的求解。 因此，数学模型是用计算机解决实际问题的基础。现实问题纷繁复杂、变化万千，所建立的数学模型自然也是五花八门，多种多样，让人无所适从。值得欣慰的是，尽管我们面对的数学模型复杂多样，但从结构上看，所有这些数学模型都建立在四种基本的数学结构基础之上。  
这四种基本数学结构分别为：表示元素之间空间关系的拓扑结构，如图模型、树模型就是一些拓扑结构；表示元素之间运算关系的代数结构，如初等代数、向量代数、矩阵代数、命题代数、集合代数等都是代数结构；表示元素规模度量性质的测度结构，如高等数学里函数的微分和积分都是测度结构，它们主要计算面积、体积、弧长、速度等；表示元素之间次序关系的偏序结构，如整数的整除关系、集合的包含关系等偏序关系都是偏序结构。  
任何一个数学结构都是由载体、处理机制和处理规则这三个基本要素组成：  
（1）载体集合 对于任何一个数学结构，需要定义一些抽象的元素作为处理对象，这些抽象元素组成的集合构成数学结构的载体。载体集合是数学结构存在的基础或平台。  
（2）处理机制 为了实现对数学结构载体中元素的处理，需要定义一些处理机制，不同的数学结构具有不同的处理机制。例如：偏序结构是一种关系结构，它以元素之间的次序关系或者比较关系作为处理机制；代数结构是一种运算结构，它以元素之间的运算作为处理机制；拓扑结构是一种分布结构，它以元素之间的空间分布作为处理机制；测度结构则是一种度量结构，它以元素的规模度量作为处理机制。  
（3）处理规则 为使定义出来的数学结构满足一些合理性要求以及能够在处理实际问题中发挥作用，避免出现一些矛盾或荒诞的处理结果，还必须制定一些处理规则对处理机制做一些必要的限制。在现代数学的公理化系统中，通常称这些处理规则称为公理。不同的数学结构具有不同的处理规则，例如偏序结构限制元素之间的关系必须满足自反性、反对称性和传递性，这些限制或者性质构成了偏序结构公理系统；再如代数结构则是规定元素之间的运算必须满足结合律、交换律、分配律等运算性质。  
数学运算最早起源于算术运算，即使用具体的整数或分数进行四则运算。随着科学技术的不断发展，人们逐步意识到这种方法不能满足对一般性规律的认识。因此，采用抽象的字母来代替具体的整数和分数进行运算以获得通用性结果，并称之为代数运算或简称为代数。在微积分出现之前的数千年历史中，对代数运算的研究一直占据数学研究的核心地位。那时人们普遍信奉一种所谓的万能法则，即世界上所有问题都可以转化为数学问题，所有数学问题都可以转化为代数问题，所有代数问题都可以转化为方程问题。  
因此，在很长一段历史时期内，人们对数学的研究基本上都是对代数学的研究，对代数学的研究基本上是方程或方程组解法的研究。解方程是那个时期内所有数学家的中心任务，大家都非常期望能够通过使用代数运算的方法找到方程或方程组的通用求解公式。这种努力在线性方程组领域取得了非常完美的结果，并由初等代数逐步衍生出线性代数。但是，对于一元高次方程通用求解方法的研究并不是很顺利，对于次数高于四次的一元方程始终找不到通用求解公式或求解方法。一些非常著名的数学家，例如欧拉、高斯、拉格朗日等都对此做了大量非常艰苦的研究，但均告失败。  
在寻求五次方程通用求解方法的过程中，年仅17 岁的法国天才少年伽罗瓦在1828 年提出群的概念，运用群的思想证明了五次方程通用求解公式是不存在的，并给出了五次方程系数在满足一定条件下若干特殊解法，由此一举解决了困扰数学家长达200 多年的数学问题。伽罗瓦取得成功的关键在于不仅将运算对象进行抽象化，而且对运算本身进行抽象，在抽象对象和抽象运算的基础上通过构造一些特殊抽象代数结构进行求解。这个思想在当时实在过于超前以至于没有得到柯西、傅里叶、泊松等著名数学家的认可，泊松的判词是“完全不能理解”。 1832 年5 月31 日年仅21 岁的伽罗瓦死于决斗。在决斗之前，他把关于五次方程代数求解的研究成果写成长信，留给了人类。14 年后，法国数学家刘维尔整理并发表了伽罗瓦的遗作，人们才理解并惊叹他那超越时代的天才思想和巧妙构思。  
至此以后，人们对代数的研究内容由方程或方程组的求解技巧转变为对代数运算性质和运算结构的研究，通过对运算和运算对象进行抽象的方式实现对所有运算依其运算性质进行分类或归类，并将伽罗瓦的群论迅速发展成为一门称之为抽象代数结构的崭新数学分支。 抽象代数结构的诞生，把代数学从传统的初等代数发展到现代的抽象代数，由此打开了现代代数学的大门，开创了代数学研究的新纪元。因此，抽象代数结构通常也称为近世代数以区别于之前的初等代数。若无特别说明，我们通常将抽象代数结构简称为代数结构。  
经过一百多年的发展，抽象代数结构已经形成一个如图11-1 所示的知识体系。对于一个代数系统，我们不仅可以主动设计出它的运算并考察相应的运算规则，而且还可以通过分别对其载体集合进行相关改造或运算得到相应的子代数、积代数和商代数，可以通过映射的方式考察不同代数结构之间的区别与联系，还可根据运算性质对代数结构进行分类，形成若干典型抽象代数系统，如群、环、域、格等。  
![](images/37d476cf884c29ed65924bc021cb612de43bab4df8b1196f64e96cad4f61a01f.jpg)
图11-1 抽象代数结构的知识体系  
代数结构作为一种特殊的数学结构，具有载体、处理机制和处理规则这三个基本要素。如前所述，代数结构的载体就是由一些抽象对象为元素组成的集合，并通过运算机制实现对集合中元素的处理。所谓运算，其实就是通过映射的手段从已有元素中构造出新的元素。载体和运算统称为代数结构的成分。代数结构的处理规则即为运算性质。  
既然代数结构的载体是一个集合，那么就可以考虑通过一定方式由这个集合派生出新的集合并据此构造出新的代数结构。例如，可以考察其子集以及在子集上的运算，得到子代数的概念和性质；可以对作为载体的集合做笛卡尔集构成一个新的集合，并在新集合上定义相关运算，得到积代数的概念和性质；可以通过构造等价关系的方法实现对集合载体的划分，构成一个以等价类为元素的商集，并在这个商集上定义相关运算，得到商代数的概念和性质。子代数、积代数和商代数是构造和研究代数结构的基本方法论。  
当然，还可以考察两个代数结构之间的相似性与差异性。对于任意两个代数系统，可以在这两个代数结构的载体(集合)上建立一种保运算的映射，由此考察代数结构之间的联系。如果存在这种保运算映射，则称这两个代数系统同态。如果这种保运算的映射还是双射，则称这两个代数系统同构。同态和同构是考察代数结构之间联系的基本工具。  
依据代数结构的运算性质，可以将各种具体代数结构划分为若干抽象类型。典型的抽象代数结构类型主要有仅含一个二元运算的半群与群、含有两个二元运算的环与域，以及格与布尔代数。这些典型抽象代数结构构成代数结构知识体系的主要内容。"
同胚关系,概念,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.3.1  平面图的概念与性质']","{'实体类型': '概念', '定义': '两个图模型可以通过同胚操作相互转化的关系'}",,3,"所谓平面图，直观地说就是可以将该图嵌入到某个平面上。如图10-46（a）所示，图模型的边有时不仅在结点处相交，而且还在某些非结点处有交叉，这些非结点处交叉点的边重叠特征显然会导致图模型不能嵌入在同一个平面上。因此，为了将图模型嵌入平面，首先必须适当调整该图中边的走向，以保证任意两条边不会在非结点处有交叉，如图10-46（b）所示。由此得到可平面图和平面图的相关概念。  
【定义10.6】设$G=\langle V,E\rangle$是任意给定的一个图模型，如果该图中有两条边在非结点处有交叉，则称这两条边为该图的交叉边，交叉的具体位置称为交叉点。如果可将图𝐺画在同一个平面上，并且所有边除在结点处之外均不交叉，则称图𝐺可嵌入平面，或称𝐺为可平面图，否则称该图为不可平面图或非平面图。对于可平面图𝐺，将其边不交叉的画法称为𝐺的平面嵌入表示。以平面嵌入方式表示的图可平面图𝐺称为平面图。对于一个平面图𝐺，若对其再加一条边就变成不可平面图，则称𝐺为最大平面图。  
![](images/ad5984e0ab09600028eb4068193d74e75743de0f027a20b4d084511a312873d4.jpg)  
![（a）完全二分图$K_{3,3}$  （b）无法消除交叉  ](images/aa69f9dcec49f0e95a534b493200688a98dae4f4be8a347fbd35c04b8c21413b.jpg)  
例如，对于图10-46（a）所示的图，该图有三对交叉边，即$(v_{1},v_{4})$和$(v_{2},v_{3}),~(v_{1},v_{4})$和$(v_{2},v_{5})$、$(v_{1},v_{5})$和$(v_{2},v_{3})$。由于可将该图表示成图10-46（b）的形式，故该图是一个可平面图。图10-46（b）所示的图就是一个平面图。显然，如果在该平面图上增加一条边，则该图就变成一个不可平面图，故该是一个最大平面图。再如，对于图10-47（a）所示的图模型，无论怎么调整边的走向都不能将其以平面嵌入方式表示，如图10-47（b）所示。故图10-47（a）所示的图模型为不可平面图或非平面图。  
在没有特别要求的情况下，通常将可平面图与平面图不加区分地统称为平面图。与一般图模型显著不同的是，平面图模型除了具有结点和边这两个基本构件之外，还有一般图模型所没有的面的概念，并且由进一步面衍生出边界的概念。因此，平面图是一类非常重要的特殊图模型，无论在理论上还是在应用方面都具有非常重要的价值，在印刷电路板的设计、城市管网设计与规划等多个领域得到实际应用。  
图论之父欧拉对平面图有着比较深刻的研究，发现并论证了平面图的结点、边和面之间的数量关系，提出了著名的欧拉公式。下面给出平面图中面的相关概念：  
【定义10.7】设$G=\langle V,E\rangle$是任意给定的一个平面图，由𝐺中边所包围且内部不包含结点与边的区域，称为$G$的一个面。区域面积有限的面称为有限面，区域面积无限的面称为无限面。对于$G$的任意一个面$R$，包围面$R$的所有边构成的回路称为面𝑅的边界，面𝑅边界中边的个数称为面$R$的次数或度，记为${\bf d e g}(R)$。  
通俗地说，如果把一个平面图画在平面上，然后用小刀沿着图的边将平面切开，那么整个平面就被切成若干块，其中每一块就是图的一个面。或者说，平面图的一个面就是平面中一个以边为界线不能再分割的区域块。例如，对于图10-46（b）所示的平面图，一共有六个面，其中有一个面是无限面，其余五个是有限面。需要注意的是，对于任何一个平面图，该图有且仅有一个无限面。下面的定理10.11 给出了平面图中面数与边数的数量关系：  
【定理10.11】平面图中所有面的次数之和等于边数的两倍。  
下面定理10.12 是著名的欧拉公式，给出了平面图中结点、边和面之间的数量关系：  
【定理10.12】设$G=\langle V,E\rangle$是任意给定的一个连通平面图，若它有$n$个结点、$m$条边、$r$ 个面，则有  
$$
n-m+r=2\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
【定理10.13】如果平面连通图$G$每个面的次数均为$l(l\geq3)$，则有：  
$$
m=l(n-2)/(l-2)
$$  
其中$m$为$G$的边数，$n$为$G$的结点数。  
【定理10.14】设$G$是一个$(n,m)$简单连通平面图，若$m>1$，则有：  
$$
m\leq3n-6\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
由定理10.4 的逆命题不成立，也就是说满足不等式$m\leq3n-6$的简单连通图不一定是平面图。但是对于一个简单连通图，若不满足$m\leq3n-6$，则一定是非平面图。因此，可用定理10.4 的结论证明某个简单连通图不是非平面图。  
【定理10.15】设$G$为一平面连通简单图，其结点数$n\geq4$，边数为$m$，且$G$不以$K_{3}$为其子图，则有$m\leq2n-4$。  
【定义10.8】对于是任意给定的一个图模型$G=\langle V,E\rangle$  
设$e=(u,v)$是$G$的任意一条边，如果在图$G$中删除该边并新增一个结点$w$及两条边$e_{1}=$$(u,w)$、$e_{2}=(w,v)$ ，则称该操作为对图$G$的边切割操作；  
设𝑤是$G$中任意一个度数为2 的结点，且是边${e_{1}=(u,w)}$和$e_{2}=(w,v)$的公共结点，如果在图$G$中删除结点$w$及边$e_{1},\,e_{2}$，并增加边$e=(u,v)$，则称该操作为对图$G$的结点贯通操作；  
对图$G$的边切割操作和结点贯通操作统称为对图$G$的同胚操作。  
显然，边切割操作和结点贯通操作是一对互逆操作。例如，对于图10-48 所示的两个图模型，可通过对边的切割操作将$G_{1}$变成$G_{2}$，也可通过对结点做贯通操作将$G_{2}$变成$G_{1}$。  
![图10-48  图的同胚操作与同胚关系  ](images/17b45e1706460a818a5492fb4df19f0ddd6b072e9cf57afef7db0852f0c58237.jpg)  
下面在同胚操作的基础上，引入如下两个图之间的同胚关系：  
【定义10.9】设$G_{1}=\langle V_{1},E_{1}\rangle$和$G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，如果可用同胚操作将其中一个转化为另外一个，则称$G_{1}$与$G_{2}$具有同胚关系，简称为$G_{1}$与$G_{2}$同胚。  
根据上述同胚的概念，可以得到如下关于平面图判定的库拉托夫斯基定理：  
【定理10.16】（库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是$G$的任何子图都不同胚于$K_{5}$或$K_{3,3}$。  
【定理10.17】(库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是𝐺的任何子图都不能通过边的收缩得到$K_{5}$或$K_{3,3}$。  
![图10-51 彼得森图收缩为$ K_{5}$](images/b6cd48c8bf37519af48b0cc187afdf1adc13d2c5e160a08fe418ce5c94762fd6.jpg)  
库拉托夫斯基定理是一个非常著名定理，通常将$K_{5}$和$K_{3,3}$称为库拉托夫斯基图。可以使用该定理判定一个图是否为平面图。例如，对于图$10{-}51\mathrm{a}$）所示的彼得森图，收缩其边$(v_{i},u_{i})(i=1,2,3,4,5)$，则可得到图$K_{5}$，见图10-51b)。故彼得森图不是平面图。  
值得注意的是，虽然库拉托夫斯基定理给出了平面图判定的充分必要条件，但是目前还没有基于该定理得到一个有效的判定算法。因此，对于一个比较复杂的图模型，要判定其是否为平面图，有时并不是一件容易的事情。"
同胚操作,概念,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.3.1  平面图的概念与性质']","{'实体类型': '概念', '定义': '对图进行边切割操作和结点贯通操作的总称', '特点': '边切割操作和结点贯通操作是一对互逆操作'}",,3,"所谓平面图，直观地说就是可以将该图嵌入到某个平面上。如图10-46（a）所示，图模型的边有时不仅在结点处相交，而且还在某些非结点处有交叉，这些非结点处交叉点的边重叠特征显然会导致图模型不能嵌入在同一个平面上。因此，为了将图模型嵌入平面，首先必须适当调整该图中边的走向，以保证任意两条边不会在非结点处有交叉，如图10-46（b）所示。由此得到可平面图和平面图的相关概念。  
【定义10.6】设$G=\langle V,E\rangle$是任意给定的一个图模型，如果该图中有两条边在非结点处有交叉，则称这两条边为该图的交叉边，交叉的具体位置称为交叉点。如果可将图𝐺画在同一个平面上，并且所有边除在结点处之外均不交叉，则称图𝐺可嵌入平面，或称𝐺为可平面图，否则称该图为不可平面图或非平面图。对于可平面图𝐺，将其边不交叉的画法称为𝐺的平面嵌入表示。以平面嵌入方式表示的图可平面图𝐺称为平面图。对于一个平面图𝐺，若对其再加一条边就变成不可平面图，则称𝐺为最大平面图。  
![](images/ad5984e0ab09600028eb4068193d74e75743de0f027a20b4d084511a312873d4.jpg)  
![（a）完全二分图$K_{3,3}$  （b）无法消除交叉  ](images/aa69f9dcec49f0e95a534b493200688a98dae4f4be8a347fbd35c04b8c21413b.jpg)  
例如，对于图10-46（a）所示的图，该图有三对交叉边，即$(v_{1},v_{4})$和$(v_{2},v_{3}),~(v_{1},v_{4})$和$(v_{2},v_{5})$、$(v_{1},v_{5})$和$(v_{2},v_{3})$。由于可将该图表示成图10-46（b）的形式，故该图是一个可平面图。图10-46（b）所示的图就是一个平面图。显然，如果在该平面图上增加一条边，则该图就变成一个不可平面图，故该是一个最大平面图。再如，对于图10-47（a）所示的图模型，无论怎么调整边的走向都不能将其以平面嵌入方式表示，如图10-47（b）所示。故图10-47（a）所示的图模型为不可平面图或非平面图。  
在没有特别要求的情况下，通常将可平面图与平面图不加区分地统称为平面图。与一般图模型显著不同的是，平面图模型除了具有结点和边这两个基本构件之外，还有一般图模型所没有的面的概念，并且由进一步面衍生出边界的概念。因此，平面图是一类非常重要的特殊图模型，无论在理论上还是在应用方面都具有非常重要的价值，在印刷电路板的设计、城市管网设计与规划等多个领域得到实际应用。  
图论之父欧拉对平面图有着比较深刻的研究，发现并论证了平面图的结点、边和面之间的数量关系，提出了著名的欧拉公式。下面给出平面图中面的相关概念：  
【定义10.7】设$G=\langle V,E\rangle$是任意给定的一个平面图，由𝐺中边所包围且内部不包含结点与边的区域，称为$G$的一个面。区域面积有限的面称为有限面，区域面积无限的面称为无限面。对于$G$的任意一个面$R$，包围面$R$的所有边构成的回路称为面𝑅的边界，面𝑅边界中边的个数称为面$R$的次数或度，记为${\bf d e g}(R)$。  
通俗地说，如果把一个平面图画在平面上，然后用小刀沿着图的边将平面切开，那么整个平面就被切成若干块，其中每一块就是图的一个面。或者说，平面图的一个面就是平面中一个以边为界线不能再分割的区域块。例如，对于图10-46（b）所示的平面图，一共有六个面，其中有一个面是无限面，其余五个是有限面。需要注意的是，对于任何一个平面图，该图有且仅有一个无限面。下面的定理10.11 给出了平面图中面数与边数的数量关系：  
【定理10.11】平面图中所有面的次数之和等于边数的两倍。  
下面定理10.12 是著名的欧拉公式，给出了平面图中结点、边和面之间的数量关系：  
【定理10.12】设$G=\langle V,E\rangle$是任意给定的一个连通平面图，若它有$n$个结点、$m$条边、$r$ 个面，则有  
$$
n-m+r=2\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
【定理10.13】如果平面连通图$G$每个面的次数均为$l(l\geq3)$，则有：  
$$
m=l(n-2)/(l-2)
$$  
其中$m$为$G$的边数，$n$为$G$的结点数。  
【定理10.14】设$G$是一个$(n,m)$简单连通平面图，若$m>1$，则有：  
$$
m\leq3n-6\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
由定理10.4 的逆命题不成立，也就是说满足不等式$m\leq3n-6$的简单连通图不一定是平面图。但是对于一个简单连通图，若不满足$m\leq3n-6$，则一定是非平面图。因此，可用定理10.4 的结论证明某个简单连通图不是非平面图。  
【定理10.15】设$G$为一平面连通简单图，其结点数$n\geq4$，边数为$m$，且$G$不以$K_{3}$为其子图，则有$m\leq2n-4$。  
【定义10.8】对于是任意给定的一个图模型$G=\langle V,E\rangle$  
设$e=(u,v)$是$G$的任意一条边，如果在图$G$中删除该边并新增一个结点$w$及两条边$e_{1}=$$(u,w)$、$e_{2}=(w,v)$ ，则称该操作为对图$G$的边切割操作；  
设𝑤是$G$中任意一个度数为2 的结点，且是边${e_{1}=(u,w)}$和$e_{2}=(w,v)$的公共结点，如果在图$G$中删除结点$w$及边$e_{1},\,e_{2}$，并增加边$e=(u,v)$，则称该操作为对图$G$的结点贯通操作；  
对图$G$的边切割操作和结点贯通操作统称为对图$G$的同胚操作。  
显然，边切割操作和结点贯通操作是一对互逆操作。例如，对于图10-48 所示的两个图模型，可通过对边的切割操作将$G_{1}$变成$G_{2}$，也可通过对结点做贯通操作将$G_{2}$变成$G_{1}$。  
![图10-48  图的同胚操作与同胚关系  ](images/17b45e1706460a818a5492fb4df19f0ddd6b072e9cf57afef7db0852f0c58237.jpg)  
下面在同胚操作的基础上，引入如下两个图之间的同胚关系：  
【定义10.9】设$G_{1}=\langle V_{1},E_{1}\rangle$和$G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，如果可用同胚操作将其中一个转化为另外一个，则称$G_{1}$与$G_{2}$具有同胚关系，简称为$G_{1}$与$G_{2}$同胚。  
根据上述同胚的概念，可以得到如下关于平面图判定的库拉托夫斯基定理：  
【定理10.16】（库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是$G$的任何子图都不同胚于$K_{5}$或$K_{3,3}$。  
【定理10.17】(库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是𝐺的任何子图都不能通过边的收缩得到$K_{5}$或$K_{3,3}$。  
![图10-51 彼得森图收缩为$ K_{5}$](images/b6cd48c8bf37519af48b0cc187afdf1adc13d2c5e160a08fe418ce5c94762fd6.jpg)  
库拉托夫斯基定理是一个非常著名定理，通常将$K_{5}$和$K_{3,3}$称为库拉托夫斯基图。可以使用该定理判定一个图是否为平面图。例如，对于图$10{-}51\mathrm{a}$）所示的彼得森图，收缩其边$(v_{i},u_{i})(i=1,2,3,4,5)$，则可得到图$K_{5}$，见图10-51b)。故彼得森图不是平面图。  
值得注意的是，虽然库拉托夫斯基定理给出了平面图判定的充分必要条件，但是目前还没有基于该定理得到一个有效的判定算法。因此，对于一个比较复杂的图模型，要判定其是否为平面图，有时并不是一件容易的事情。"
后根遍历算法,算法,"['第九章  树的基本理论与算法', '§ 9.2 根树的基本知识', '9.2.2 根树的基本算法']","{'实体类型': '算法', '步骤': '首先递归访问根的左子树，然后递归访问根的右子树，最后递归访问根结点'}",,3,"对于根树，一个十分重要的问题是要找到一些方法能系统地访问树的结点，使得每个结点恰好访问一次，这就是根树的遍历问题。由于二元树在计算机中最易处理且任意根树都可转化为二元树，因此在$k$元树中，应用得最广泛的是二元树。下面先介绍二元树的三种常用的遍历方法，然后介绍如何将任意根树转化为二元树。  
二元树的遍历算法主要有先根遍历算法、中根遍历算法和后根次序遍历算法，这三种算法都是采用递归的方式进行：  
先根遍历算法，顾名思义就是首先递归访问根结点；然后递归访问根的左子树，最后，就递归访问根的右子树；中根遍历算法，首先递归访问根的左子树；然后递归访问根结点；最后递归访问根的右子树；后根遍历算法，首先递归访问根的左子树；然后递归访问根的右子树；最后递归访问根结点。"
否定联结词,概念,"['第三章  命题演算与推理', '§ 3.1 命题的概念与运算', '3.1.3  命题的常用联结词', '一、否定联结词']","{'实体类型': '概念', '定义': '符号$\\neg$称为否定联结词(简称为否定词)', '作用': '用于构成命题的否定式'}",,4,"对于任意一个给定的命题，可以通过对其含义取反或者进行否定来得到一个新的命题。新命题的含义与真值与原命题完全相反，由此得到的逻辑运算称为命题的“非”运算或“否定”运算。该运算及其逻辑联结词具体定义如下：  
【定义3.2】设 $P$ 是任一命题，复合命题“非 $P$ ”称为 $P$ 的否定式或非运算，记作 $\lnot\ P$ ，其中符号$\neg$称为否定联结词(简称为否定词)。$\lnot\ P$ 的真值为真，当且仅当 $P$ 的真值为假，或者说：$\lnot\ P$ 的真值为假，当且仅当 $P$ 的真值为真。  
$\lnot\ P$ 是一个由命题$P$衍生而来的复合命题，其真值取值状况与 $P$ 完全相反。例如，若令 $P$ 表示命题“我喜欢唱歌”，则 $\lnot\ P$ 就表示命题“我不喜欢唱歌”。  
对于任意一个命题 $P$，它其否定命题¬ $P$ 之间的真值关系如表3-1 第3 列所示：  
表$^{3\cdot1}\ \neg,\ \wedge,$ ∨的运算表
![](images/b0b4f79b14e0e83d1cdd7d9bbd1f3b9956a6520b82a62886b519b2594f4eadae.jpg)"
含幺交换环,概念,"['第十二章 典型抽象代数结构', '§ 12.4 环和域的基本知识', '12.4.1  环的概念与性质']","{'实体类型': '概念', '定义': '环结构中乘法是含幺交换半群的环'}",,3,"我们知道，整数集合𝑍上具有加法$+$和乘法$\times$这两种运算，并且$\langle Z,+\rangle$是一个交换群、$\langle Z,\times\rangle$是一个半群，并且乘法对加法满足左、右分配律，即有：  
$$
a\times(b+c)=a\times b+a\times c;\ (b+c)\times a=b\times a+c a\times
$$  
由此可见，整数运算系统主要由两个运算子系统构成，即由一个基于加法运算的交换群和一个基于乘法运算的半群构成，并且乘法对加法满足分配律。  
将整数运算系统的上述性质进行抽象，就得到如果环代数结构的定义：  
【定义12.22】如果$\langle G,+,\times\rangle$是具有两个二元运算的代数系统，且满足：（1）$\langle G,+\rangle$是交换群；（2）$\langle G,\times\rangle$是半群；（3）$G$中的$\times$对$+$满足分配律。则称$\langle G,+,\times\rangle$是环代数结构或环代数系统，通常简称为环结构、环系统或环，并称$+$和$\times$分别为环中的加法和乘法。  
由上述定义可知，环结构由加法交换群和乘法半群这两个子结构组成，且满足乘法对加法的分配律。显然，代数系统$\langle Z,+,\times\rangle$就是一个环结构。  
此外，$\langle Q,+,\times\rangle,~\langle R,+,\times\rangle,~\langle C,+,\times\rangle$也都是环结构，其中$Q$是有理数集，$R$是实数集，$C$是复数集，分别称作整数环，有理数环，实数环和复数环。  
可根据构成环的群子结构或半群子结构的特点，对环结构做进一步的分类：  
【定义12.23】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果$\langle G,\times\rangle$是一个含幺半群，则称$\langle G,+,\times\rangle$是一个含幺环，如果$\langle G,\times\rangle$是一个交换半群，则称$\langle G,+,\times\rangle$是一个交换环，如果$\langle G,\times\rangle$是一个含幺交换半群，则称$\langle G,+,\times\rangle$是一个含幺交换环。  
为了叙述上的方便，通常将环中加法的单位元记作0，而将环中元素$x$关于加法的逆元称作$x$的负元，记作$-x$。如果环中乘法有单位元，就把这个单位元记作1，而将$ x$关于乘法的逆元（若存在的话）称为$x$的逆元，记作$:\!x^{-1}$。类似地，可用$x-y,$表示$ x+(-y)$，分别用$n x$和$x^{n}$表示$x$的加法和乘法$ n$次幂，即有：  
$$
n x=\underbrace{x+x+\cdots+x}_{n^{}个};\,\,\,x^{n}=\underbrace{x x\cdots x}_{n^{}个}
$$  
下面讨论环的基本性质。由环的定义可知，环中加法满足交换律、结合律，有单位元0  ，  
每个元素都有负元，环中乘法适合结合律，乘法对加法适合分配律。除此之外，我们进一步考察环的其它一些性质。首先考察环结构中加法逆元的性质：  
【定理12.28】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a,b\in G$，有：  
$$
-(a\times b)=a\times(-b)=(-a)\times b\quad\text{(12-20)}
$$  
下面考察环结构中加法单位元的性质：  
【定理12.29】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a\in G$，有：  
$$
a\times0=0\times a=0\quad\text{(12-21)}
$$  
上述定理12.29 表明，环结构中加法运算的单位元是乘法运算的零元，并且环中任二元素相乘，若其中至少有一个为零元，则乘积必为零元。但反之不然，因为在环中，两个非零元的乘积可能为零元，由此引出如下环结构中零因子的概念：  
【定义12.24】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果存在$G$中两个非零元素满足$a\cdot b=0$ ，称该环为含零因子环，元素 $a$ 和 $b$ 是其零因子，否则称该环为无零因子环。  
【定理12.30】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则$\langle G,+,\times\rangle$是无零因子环当且仅当于$\langle G,\times\rangle$满足消去律。  
由于环是由群和半群这两个子结构构成，故与群结构类似，环结构也存在子环、环同态的相关概念和理论。事实上，子环和环同态的概念和性质完全可以使用与群类似的思路进行讨论，这里不再赘述，读者可自行查阅环结构的相关资料深入学习。"
含幺半群,概念,"['§ 12.1 半群的概念与性质', '12.1.2  方幂与循环半群', '第十二章 典型抽象代数结构', '12.1.1 半群与含幺半群']","{'实体类型': '概念', '定义': ['在半群的基础上再增加存在单位元的限制，一种含有幺元或单位元的特殊半群', '具有单位元素的半群'], '特点': '只含一个二元运算，含有关于运算的单位元', '示例': ['⟨R, +⟩', '⟨R, ×⟩', '⟨P(A), ∪⟩', '⟨P(A), ∩⟩', '⟨A^A, ∘⟩', '⟨M_n(R), +⟩', '⟨M_n(R), ⋅⟩'], '非示例': '⟨R^+, +⟩（正实数集合没有运算+的单位元）', '性质': '单位元素e的定义为a^0=e'}",,2,"与群相关的抽象代数结构有很多个，其共同特征是只含一个二元运算，具体包括广群、半群、含幺半群、群、交换群等。如图12-1 所示，这些抽象代数结构按照由一般到特殊的次序逐步递进。其中：广群是最具一般性，只需满足运算的封闭性即可，其实就是一般的只含一个二元运算的代数结构或代数系统；半群则比广群稍微特殊一些，即在广群的基础上增加一个满足结合律的限制；含幺半群则是在半群的基础上再增加存在单位元的限制；群则是在含幺半群的基础上再增加存在逆元的限制，即要求半群不仅含有单位元，而且还必须保证载体集合中每个元素都必须含有逆元；交换群则是一种满足交换律的特殊群。  
![](images/c6e03e109e469ca83f4980264e0b87779198ee1bcaf3a206ea39fe5f280b87e9.jpg)
图12-1 与群相关的抽象代数结构  
我们将按照图12-1-1 所示次序展开讨论，其中广群作为最一般的代数结构在前面第十一章已做介绍。因此，本节着重介绍半群的基本理论，主要包括半群、含幺半群、元素方幂、循环半群的基本概念与性质。"
含幺环,概念,"['第十二章 典型抽象代数结构', '§ 12.4 环和域的基本知识', '12.4.1  环的概念与性质']","{'实体类型': '概念', '定义': '环结构中乘法是含幺半群的环'}",,3,"我们知道，整数集合𝑍上具有加法$+$和乘法$\times$这两种运算，并且$\langle Z,+\rangle$是一个交换群、$\langle Z,\times\rangle$是一个半群，并且乘法对加法满足左、右分配律，即有：  
$$
a\times(b+c)=a\times b+a\times c;\ (b+c)\times a=b\times a+c a\times
$$  
由此可见，整数运算系统主要由两个运算子系统构成，即由一个基于加法运算的交换群和一个基于乘法运算的半群构成，并且乘法对加法满足分配律。  
将整数运算系统的上述性质进行抽象，就得到如果环代数结构的定义：  
【定义12.22】如果$\langle G,+,\times\rangle$是具有两个二元运算的代数系统，且满足：（1）$\langle G,+\rangle$是交换群；（2）$\langle G,\times\rangle$是半群；（3）$G$中的$\times$对$+$满足分配律。则称$\langle G,+,\times\rangle$是环代数结构或环代数系统，通常简称为环结构、环系统或环，并称$+$和$\times$分别为环中的加法和乘法。  
由上述定义可知，环结构由加法交换群和乘法半群这两个子结构组成，且满足乘法对加法的分配律。显然，代数系统$\langle Z,+,\times\rangle$就是一个环结构。  
此外，$\langle Q,+,\times\rangle,~\langle R,+,\times\rangle,~\langle C,+,\times\rangle$也都是环结构，其中$Q$是有理数集，$R$是实数集，$C$是复数集，分别称作整数环，有理数环，实数环和复数环。  
可根据构成环的群子结构或半群子结构的特点，对环结构做进一步的分类：  
【定义12.23】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果$\langle G,\times\rangle$是一个含幺半群，则称$\langle G,+,\times\rangle$是一个含幺环，如果$\langle G,\times\rangle$是一个交换半群，则称$\langle G,+,\times\rangle$是一个交换环，如果$\langle G,\times\rangle$是一个含幺交换半群，则称$\langle G,+,\times\rangle$是一个含幺交换环。  
为了叙述上的方便，通常将环中加法的单位元记作0，而将环中元素$x$关于加法的逆元称作$x$的负元，记作$-x$。如果环中乘法有单位元，就把这个单位元记作1，而将$ x$关于乘法的逆元（若存在的话）称为$x$的逆元，记作$:\!x^{-1}$。类似地，可用$x-y,$表示$ x+(-y)$，分别用$n x$和$x^{n}$表示$x$的加法和乘法$ n$次幂，即有：  
$$
n x=\underbrace{x+x+\cdots+x}_{n^{}个};\,\,\,x^{n}=\underbrace{x x\cdots x}_{n^{}个}
$$  
下面讨论环的基本性质。由环的定义可知，环中加法满足交换律、结合律，有单位元0  ，  
每个元素都有负元，环中乘法适合结合律，乘法对加法适合分配律。除此之外，我们进一步考察环的其它一些性质。首先考察环结构中加法逆元的性质：  
【定理12.28】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a,b\in G$，有：  
$$
-(a\times b)=a\times(-b)=(-a)\times b\quad\text{(12-20)}
$$  
下面考察环结构中加法单位元的性质：  
【定理12.29】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a\in G$，有：  
$$
a\times0=0\times a=0\quad\text{(12-21)}
$$  
上述定理12.29 表明，环结构中加法运算的单位元是乘法运算的零元，并且环中任二元素相乘，若其中至少有一个为零元，则乘积必为零元。但反之不然，因为在环中，两个非零元的乘积可能为零元，由此引出如下环结构中零因子的概念：  
【定义12.24】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果存在$G$中两个非零元素满足$a\cdot b=0$ ，称该环为含零因子环，元素 $a$ 和 $b$ 是其零因子，否则称该环为无零因子环。  
【定理12.30】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则$\langle G,+,\times\rangle$是无零因子环当且仅当于$\langle G,\times\rangle$满足消去律。  
由于环是由群和半群这两个子结构构成，故与群结构类似，环结构也存在子环、环同态的相关概念和理论。事实上，子环和环同态的概念和性质完全可以使用与群类似的思路进行讨论，这里不再赘述，读者可自行查阅环结构的相关资料深入学习。"
吸收律,性质,"['第十一章  抽象代数结构通论', '§ 11.2 代数结构的运算性质', '11.2.1  二元算律']","{'实体类型': '性质', '定义': '在二元代数结构中，对于任意元素x,y，成立x*(yΔz)=x且xΔ(y*z)=x', '应用': '一般运算对象和一般运算'}",,3,"现在我们介绍和讨论二元运算律。一共有六个二元运算律，即结合律、交换律、幂等律、消去律、分配律和吸收率。其中前面四个基于单个二元运算，后面两个基于两个二元运算。下面分别讨论这些运算律，首先讨论结合律。  
结合律是大家非常熟悉也是非常重要的一个二元运算律，实数加法与乘法运算、矩阵的加法与乘法运算、关系与函数的复合运算、整数集合上的模余运算、幂集合的交运算与并运算等都满足结合律。结合律的具体定义如下：  
【定义11.5】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由$𝐴$和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$，成立$(x*y)*z=x*(y*z)$，则称$\langle A,*\rangle$的运算 $^*$ 在 𝐴 上是可结合的，或者说 $\langle A,*\rangle$ 的运算 $^*$ 在 𝐴 上满足结合律。  
对于任意给定的集合𝐴，由于𝐴上的二元运算${\ast}$满足封闭性，故对于$\forall x,y,z\in A$，有${x\ *}$$y\in A$且$y*z\in A$。因此，$(x*y)*z$和$x*(y*z)$都是有意义的算式，如果$*$满足结合律，则表达式$x*y*z$就有一个确定的计算结果，即有：  
$$
x*y*z=(x*y)*z=x*(y*z)
$$  
如果 $*$ 不满足结合律，则有可能有 $(x*y)*z\neq x*(y*z).$ 。   此时，表达式 $x*y*z$ 的含义就有歧义。因此，只有当某个运算$*$满足结合律时，才能定义其方幂运算。在后续半群与群中元素方幂的的定义中，其元素运算的结合律起着基础性的支撑作用。  
下面考察运算的交换律，首先给出交换律的定义，具体如下：  
【定义11.6】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y\in A$，成立$x*y=y*x$，则称$\langle A,\ *\rangle$的运算$^*$在𝐴上是可交换的，或者说$\langle A,\ *\rangle$的运算$^*$在𝐴上满足交换律。  
交换律表示代数结构载体集合中的任意两个元素在运算时都可以交换次序。 例如，实数加法与乘法运算、矩阵的加法、整数集合上的模余运算、幂集合的交运算与并运算等都满足交换律。 但是，矩阵的乘法运算、关系与函数的复合运算等都不满足交换律。  
【定义11.7】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，若存在某个元素$a\in A$，满足 a$*$$a=a$，则称$a$是$\langle A,\ *\rangle$的一个幂等元。 如果𝐴中的每个元素都是$\langle A,\ *\rangle$的幂等元，则称$\langle A,\ *\rangle$的运算$*$在𝐴上满足幂等律。  
从上述定义可以看出，所谓幂等元，就是该元素与其自身运算之后仍然等于其自身。例如，对于某个幂集合上的交运算和并运算，幂集合中每个元素显然都是幂等元，因此，幂集合上的交运算和并运算均满足幂等性。但是，对于整数上的加法运算，除了整数0 之外，其余整数显然都不是幂等元，因此,整数上的加法运算不满足幂等律。  
【定义11.8】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$：  
（1）若$z*y=z*x$，有$y=x$，则称运算$*$在𝐴上是可左消去的，或者说运算$∗$在𝐴上满足左消去律，并称$\cdot z$是$A$中关于运算$^*$的左可消去元；  
（2）若$y*z=x*z$，有$y=x$，则称运算$^*$在𝐴上是可右消去的，或者说运算$^*$在𝐴上满足右消去律，并称𝑧是$A$中关于运算$^*$的右可消去元。  
（3）若上述两种情况均满足，则称运算$*$在𝐴上满足消去律，并称$z$是𝐴中关于运算$*$的可消去元。  
下面介绍基于两个二元运算的运算律，即分配律和吸收律。首先给出分配律的定义：  
【定义11.9】假设𝐴是任意给定的一个非空集合，$^*$和$\Delta$均为𝐴上的二元运算，在由$𝐴$、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y,z\in A$：  
若有$x*(y\Delta z)=(x*y)\Delta(x*z)$，则称运算$*$对$\Delta$在𝐴上满足左分配律。  
若有$(y\Delta z)*x=(y*x)\Delta(z*x)$，则称运算$*$对$\Delta$在𝐴上满足右分配律。  
若运算$*$对$\Delta$在𝐴上同时满足左右分配律，则称运算$*$对$\Delta$在𝐴上满足分配律。  
例如，实数集合上的普通乘法对加法满足分配律，$M_{n}(R)$上的矩阵乘法对加法满足分配律，幂集$P(B)$上的集合交运算对并运算满足分配律，并且并运算对交运算也满足分配律。  
将上述关于集合的吸收律推广到一般运算对象和一般运算，得到一个新的运算律，即吸收律。其具体定义如下：  
【定义11.10】设𝐴是任意给定的一个非空集合，$*$和$\Delta$均为为𝐴上二元运算，在由𝐴、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y\in A$，成立：  
$$
x*(y\Delta z)=x,\;\;x\Delta(y*z)=x
$$  
则称 $*$ 和 $\Delta$ 在 A  上满足吸收律。"
周期,概念,"['第十二章 典型抽象代数结构', '§ 12.2 群结构的基本知识', '12.2.1 群的基本概念']","{'实体类型': '概念', '定义': '设⟨G,*⟩是任意给定的一个群，e是该群的单位元，对于G中任意给定的某个元素a，如果存在正整数n，满足a^n=e，则其中最小的正整数称为元素a的周期或阶'}",,3,"如前所述，群代数结构是对幺半群结构在逆元方面的进一步扩充，其具体定义如下：  
【定义12.8】假设$\langle G,*\rangle$是任意给定的一个二元代数结构，如果$\langle G,*\rangle$满足如下性质：  
（1）结合律：对于$\forall x,y,z\in G$，成立：$(x\ \ *y)*z=x\ \ *(y*z)$；  
（2）含单位元：$\exists e\in G$，使得对于$\forall x\in G$，成立$\,\!e*x=x*e=x$；  
（3）运算$*$可逆：对于$\forall x\in G$，都存在$x^{-1}\in G$，使得$x^{-1}*x=x*x^{-1}=e$。  
则称$\langle G,*\rangle$是一个群代数结构，简称为群结构或群。  
从上述定义可知，对于任意给定的非空集合 $G$ 以及该集合上某个二元运算 $*$ ，$\langle G,*\rangle$ 能够 形成一个群结构的充分必要条件是$\langle G,*\rangle$必须满足封闭性、结合律、含幺性和可逆性这四个基本运算性质。例如，对于实数集合及其上的普通加法运算构成的代数结构$\langle R,+\rangle$，显然满足群的四条基本性质，其中0 是其单位元，对于$\forall x\in R$，$-x$是$x$的逆元。但是，对于实数集合及其上的普通乘法运算构成的代数结构$\langle R,\times\rangle$则不是一个群，因为在$\langle R,\times\rangle$中0 没有逆元素。不难发现，对于任意给定的集合$𝐴$，$\langle{ P}(A),\cup\rangle$和$\langle{ P}(A),\cap\rangle$都不能构成群结构，因为在$\langle{ P}(A),\cup\rangle$中$𝐴$没有逆元，在$\langle{P}(A),\cap\rangle$中$\varnothing$没有逆元。  
【定义12.9】设$\langle G,*\rangle$是任意给定的一个群，称$|G|$为$\langle G,*\rangle$的阶，如果$|G|$为有限数，则称  
$\langle G,*\rangle$为有限群，否则$\langle G,*\rangle$为无限群。如果运算$^*$满足交换律，即对于$\forall x,y\in G$，有$x*y=y*$$x$则称群$\langle G,*\rangle$是一个交换群或阿贝尔群。  
【定理12.3】设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$的单位元是$\langle G,*\rangle$中唯一的一个幂等元，若$|G|>1$，则$\langle G,*\rangle$中无零元且满足消去律。  
下面的定理12.2.2 给出了群中逆元素的基本性质：  
【定理12.4】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，有：  
$$
(a^{-1})^{-1}=a\,\exists(a*b)^{-1}=b^{-1}*a^{-1}
$$  
下面的定理12.5 给出了群与方程可解性之间的关系：  
【定理12.5】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，方程$a\circ x=b$和$y\circ a=$$b$在$\langle G,*\rangle$中有且仅有唯一解。  
由于群结构满足结合律，故可类似于半群和含幺半群定义元素的方幂：  
【定义12.10】设$\langle G,*\rangle$是任意给定的一个群，对于$\forall a\in G$和正整数$ n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$ a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个a}
$$  
定义$a^{0}=e$且$a^{-n}=(a^{-1})^{n}$  
从上述定义可以看出，对于一个群结构$\langle G,*\rangle$可以定义其任意整数的方幂运算，包括负指数方幂。因此，对于$G$中的任何一个元素$a$，均可以通过其正方幂、零方幂和负方幂构成一个向胜负两端无限延伸的序列，具体如下：  
$$
\cdots,a^{-n},\cdots,a^{-2},a^{-1},a^{0}\ \ ,a^{1},a^{2},\cdots,a^{n},\cdots
$$  
这些序列显然满足幂的运算法则，即对于任意整数$n$和$m$，有：  
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
如果$\langle G,*\rangle$是一个有限群$\langle G,*\rangle$，则根据运算的封闭性和鸽笼原理易知，在$G$中任意一个元素的无穷多个方幂中，必然至少有两个是相等的。具体地说，对于任意给定的$G$中某个元素$a$，必然存在两个不相等的整数$m$和$|n$，不妨设$m<n$，满足：  
$$
a^n=a^m\text{或}a^{n-m}=e
$$  
此时，可将正整数$n-m$看成是元素$a$方幂变化的一个周期。一般地，有如下定义：  
【定义12.11】设$\langle G,*\rangle$是任意给定的一个群，$e$是该群的单位元，对于$G$中任意给定的某个元素$a$，如果存在正整数$n$，满足$a^{n}=e$，则其中最小的正整数称为元素$a$的周期或阶，记为$|a|$，否则称元素$a$的周期为无限大或元素$a$的阶为无限大。  
例如，对于群$\langle\underline{{6}},+_{6}\rangle$，元素1 的阶为6，元素2 的阶为3，元素3 的阶为2，元素4 的阶为3，元素5 的阶为6，元素0 的阶为1。对于整数集合上的加法群$\langle Z,+\rangle$，显然，除了元素0 的周期为1 之外，其余任一非零元素的周期均为无穷大。事实上，不难看出，对于任何一个群，有且只有其单位元的阶为1。  
下面给出关于元素阶的两个重要性质：  
【定理12.6】有限群$\langle G,*\rangle$的每个元素都有有限阶，且其阶数不超过群的阶数|G|。  
【定理12.7】设$\langle G,*\rangle$为群，$G$中元素$a$的阶为$ k$，那么$a^{n}=e$当且仅当$k$整除$ n$  。"
命题,概念,"['3.1.1  逻辑与命题逻辑', '3.1.2  命题的基本概念', '三、蕴含与等价联结词', '3.1.3  命题的常用联结词', '第三章  命题演算与推理', '§ 3.1 命题的概念与运算', '二、合取与析取联结词']","{'实体类型': '概念', '作用': '在形式逻辑系统中起着承上启下的枢纽作用', '载体': '以命题为载体实现其逻辑演算与推理的功能', '定义': ['作为基本处理单元的逻辑表达', '具有确切真假含义且能做出判断的陈述句', '可以判断真假的陈述句'], '应用': ['用于布尔代数系统和命题逻辑', '主要用于逻辑思维中的是非判断'], '真值': '命题或真或假的取值，称为命题的真值', '特点': '对于任何一个给定的命题，必有唯一确定的真值，要么取真、要么取假'}",,2,逻辑主要分为辩证逻辑与形式逻辑这两大类。辩证逻辑主要研究人类思维中的辩证法，属于哲学范畴。离散数学领域的逻辑通常是指形式逻辑，主要研究人类思维的基本形式、基本规则和基本规律，由概念、判断、推理这三个逐步递进的基本构件组成，通过概念形成判断，再通过判断形成推理。其中判断在整个形式逻辑系统中起着承上启下的枢纽作用，它以命题为载体实现其逻辑演算与推理的功能。因此，命题逻辑不仅是数理逻辑学中最为基础的内容，而且在整个逻辑学的学科体系占有十分重要的地位。学习命题逻辑一般需要从命题的概念和运算开始，本节主要介绍命题的基本概念和基本运算，包括命题逻辑的由来、命题的基本概念、命题的基本运算和常用联结词、命题的符号化与应用等。
命题代数,概念,"['§ 11.1 代数结构的基本概念', '第三章  命题演算与推理', '第十一章  抽象代数结构通论', '§ 3.2 命题公式与等值演算']","{'实体类型': '概念', '运算': '与、或、非运算', '定义': '将命题逻辑进行抽象符号运算的数学体系', '特点': '系统地介绍命题公式的基本理论和等值关系'}",,2,抽象代数结构的基本思想是以主动的方式定义一个由若干抽象对象为元素构成的集合，并在这个集合上定义一个或多个抽象运算，由此形成一个抽象的代数运算系统，然后通过研究和讨论这个代数运算系统的运算性质获得该运算系统的结构。相对于传统的初等代数，这是一种全新的思维方式和观察问题的角度。从这个角度看过去，会得到很多令人惊讶的新认识。例如，集合代数有交、并、补运算，命题代数有与、或、非运算，从抽象代数结构上看，两者的运算性质完全相同，或者说两者是同一抽象代数不同表现形式；再如，实数集合上的加法和正实数上的乘法也是本质相同外表不同，加法中的0 其实就是乘法中的1。
命题公式,概念,"['二、命题公式的解释与真值表', '§ 3.4 命题公式的范式', '3.4.2 主析取范式', '3.2.3 公式的内否与对偶', '§ 3.2 命题公式与等值演算', '一、命题变量与命题公式', '三、命题公式的等值演算', '第三章  命题演算与推理', '3.2.2 等值关系与等值演算', '三、主析取范式构造举例', '二、基本等值关系', '3.2.1 命题公式的基本知识', '三、命题公式的基本类型']","{'实体类型': '概念', '定义': ['用数学符号进行形式化描述和处理的命题逻辑表达式', '命题代数中的运算表达式，相当于初等代数中的多项式', '由表示命题变量的标识符和逻辑联结词构成的逻辑运算表达式', '由命题变量组成，没有确定真值的抽象命题', '对于任给定的命题公式G，（1）如果G在所有解释下的真值取值都为真，则称其为永真公式或重言式；（2）如果G在所有解释下的真值取值都为假，则称其为永假公式或矛盾式；（3）如果命题公式不是矛盾式，则称其为可满足式', '通过真值表证明一些基本的等值关系式，将这些基本等值关系式作为已知工具直接在命题公式等值演算中使用，达到简化演算过程的效果', '通过基本等值关系以及代入定理和替换定理进行演算的公式', '由命题变量、命题常量以及命题联结词构成的公式'], '应用': '应用于计算机系统的设计与开发', '特点': ['能够像代数一样进行抽象的符号运算', '取值为或真或假的真值，是一种真值函数', '通过指定命题变量的真值，变成具有确定真值的复合命题'], '内容': '包括命题公式的概念及其归纳定义、命题公式的解释与真值表、命题公式的基本类型', '条件': '必须按特定规则构造而成', '基本类型': '永真公式、永假公式、可满足式', '目的': ['判定命题公式的基本类型', '证明两个命题公式之间具有等值关系', '对复杂的命题公式进行化简'], '主析取范式构造方法': '真值表法和等值演算法'}",,2,前面我们学习了命题的基本概念及其若干常用的逻辑运算，要将这些概念和运算应用到计算机系统的设计与开发，必须对其用数学符号的方式进行形式化描述和处理，形成命题演算的数学表达式，使得命题逻辑能够像代数一样进行抽象的符号运算，建立一种命题代数。本节比较系统地介绍这种命题代数的基本理论，包括命题公式的基本概念、命题公式的解释与分类、命题公式的等值关系与等值演算、命题公式的内否式与对偶式等。
命题公式推演系统,算法,"['第三章  命题演算与推理', '§ 3.5 命题逻辑的演绎推理', '3.5.2 命题公式推演系统']","{'实体类型': '算法', '定义': '在少量基本等值关系式和永真蕴含关系式的基础上，通过建立若干推理规则进行演绎推证的方式实现命题逻辑的有效推理', '组成': '包括事实库、公理库和推理规则这三个基本模块', '公理库': '包含已被证明为正确的24个基本等值式和15个基本永真蕴含式', '事实库': '由具体命题推理实例的所有前提条件以及推理过程中产生的有效中间结论组成', '推理规则': '主要由P规则、T规则和CP规则这三个基本规则组成'}",,3,"现在我们学习命题的数理逻辑推理。首先给出如下有效推理的概念：  
【定义3.28】设$G_{1},G_{2}\cdots G_{n}$，$H$是一些命题公式，如果它们满足下列性质：对于这些公式的任意一个解释𝐼，$G_{1},G_{2}\cdots G_{n}$在该解释下同时为真的情况下$\cdot_{H}$在该解释下也为真，则称命题公式$G_{1},G_{2}\cdots G_{n}$可有效推出公式$\cdot H$，或称由$G_{1},G_{2}\cdots G_{n}$得到$H$的逻辑推理为有效推理，记为$G_{1},G_{2}\cdots G_{n}\Rightarrow H$，并称$G_{1},G_{2}\cdots G_{n}$为推理前提，$H$为$G_{1},G_{2}\cdots G_{n}$的逻辑结论。  
从上述定义不难看出，有效推理其实就是把永真蕴含关系由两个命题公式之间的关系推广到多个命题公式之间的关系，即由一组命题公式构成的永真蕴含前件与一个永真蕴含后件之间的关系。下面定理表明有效推理的过程其实就是证明逻辑蕴含式的过程。  
【定理3.14】命题公式$H$是命题公式$G_{1},G_{2},\cdots,G_{n}$的逻辑结论，即$G_{1},G_{2},\cdots,G_{n}\Rightarrow H$，当且仅当$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\to H$为永真公式。  
从理论上讲，利用真值表技术完全可以在有限的步骤内完成对任意含有限个命题变量的永真蕴含关系进行判定或者说进行有效的命题逻辑推理。但是，在针对具体问题的命题逻辑推理时，推理的前提条件一般包含很多个命题公式，有时会涉及大量的命题变量，此时真值表方法就出现组合爆炸问题而变的不可行。因此，需要建立一种命题公式推演系统，在少量基本等值关系式和永真蕴含关系式的基础上，通过建立若干推理规则进行演绎推证的方式实现命题逻辑的有效推理。人们提出了很多各具特色的推演系统，对这系统的详细讨论已经超出了本课程的学习范畴，有兴趣的读者可以查阅相关资料。我们主要介绍一种最基本的推演系统，下图3-9 表示系统的基本结构。  
![](images/9e9fac00c2d40b2f3ec288b2f0ea17c474bc9160a1447874b9a37744cd5272d2.jpg)
图3-9 推演系统的基本结构  
上图表示的推演系统中包括事实库、公理库和推理规则这三个基本模块，公理库和事实库构成命题推理的基本依据。公理库包含已被证明为正确的24 个基本等值式和15 个基本永真蕴含式，这些基本关系式构成推演系统的基础知识资源，事实库由具体命题推理实例的所有前提条件以及推理过程中产生的有效中间结论组成；推理规则是命题逻辑推理的核心机制，主要由$P$规则、$T$规则和$C P$规则这三个基本规则组成。  
（1）$P$规则（前提引用规则）：推导过程中可随时引入前提集合中的任意一个前提。  
（2）$T$规则（逻辑结果引用规则）推导的过程中可随时引入公式𝑆，该公式𝑆是由其前的一个或多个公式推导出来的逻辑结果。  
（3）$C P$规则（附加前提规则）如果能从给定的前提集合$\Gamma$与公式$P$推导出𝑆，则能从此前提集合$\Gamma$ 推导出$P\rightarrow S$。  
注意：$C P$规则适用于结论为条件式的有效推理。使用𝐶𝑃规则就是把结论中的前件作为附加前提加入前提集合，共同去推出结论的后件。  
根据上述命题演算推理系统，就可进行有效的命题逻辑推理。通过有效推理，就可证明命题逻辑中所有定理。所谓证明，就是有效推理的具体推演过程，具体定义如下：  
【定义3.29】从前提集合Г 推出结论$\cdot H$的一个演绎或形式证明，就是构造一个命题公式的有限序列：$H_{1},H_{2},H_{3},\ldots,H_{n}$。其中：$H_{i}$或者是Г 中的某个前提，或者是前面的某些${\cdot}H_{j}(j{<}i)$的有效结论，并且${\cal H}_{n}$就是$H$。此时称$H$为该演绎的有效结论。"
命题公式的范式,概念,"['§ 3.4 命题公式的范式', '3.4.2 主析取范式', '3.4.3 主合取范式', '第三章  命题演算与推理', '三、主合取范式构造举例', '3.4.1 范式的基本概念']","{'实体类型': '概念', '定义': ['将彼此等值的命题公式视为同一种类型，制定一个统一规范的标准形式，使得每种命题公式都分别具有唯一一个与之相对应的标准命题公式', '由若干析取式通过合取运算组合而成', '命题公式的一种标准形式'], '作用': '在命题演算与推理中具有极其重要的作用，例如判断任意两个命题公式是否等值、判断命题公式的类型，还可以用于电路设计', '基本概念': '仅使用否定、合取、析取三个逻辑运算联结词', '核心思想': '将命题公式的运算分成内、中、外三个基本层次，将否定运算在公式的内层，将合取和析取中的一个统一放在中层，另外一个统一放在外层', '特点': ['形成一种比较规整的具有三层结构的表达形式', '表达形式不唯一', '基本构件种类多且存在冗余']}",,2,如前所述，虽然可以构造出无穷多个命题公式，但是这些命题公式中有很多是彼此等值的，将彼此等值的命题公式视为同一种类型，便可实现对所有命题公式的分类。属于同一种类型的命题公式除了在表现形式上有所差异之外，其它性质完全相同。因此，可以对命题公式的表达制定一个统一规范的标准形式，使得每种命题公式都分别具有唯一一个与之相对应的标准命题公式，并将这个标准命题公式作为其所属公式类型中所有命题公式的代表，或者说作为其所属公式类型中所有命题公式的范式。范式为千变万化的命题公式确定了一个统一的表达形式，在命题演算与推理中具有极其重要的作用，例如可以使用范式判断任意两个命题公式是否等值、判断命题公式的类型，还可以使用范式进行电路设计等等。
命题公式等值关系,概念,"['第三章  命题演算与推理', '§ 3.2 命题公式与等值演算', '3.2.2 等值关系与等值演算']","{'实体类型': '概念', '定义': '命题公式的值在变量的任何赋值情况下始终保持一致', '应用': '用于命题公式的演算和推理'}",,3,"在中学学习多项式的时候，多项式的恒等是一个非常重要的概念。所谓两个多项式恒等，就是这两个多项式的值在变量的任何赋值情况下始终保持一致。在初等代数中，通常利用多项式恒等的概念进行恒等变形或代数演算。在命题逻辑中，同样需要一种类似于命题公式恒  
等的概念进行命题公式的演算和推理，这就是命题公式的等值关系。"
命题函数,概念,"['二、个体变量与命题函数', '三、谓词与谓词填式', '一、含变量的语句', '第四章  谓词演算与推理', '§ 4.1 个体词、谓词与量词', '4.1.2  命题函数与谓词']","{'实体类型': '概念', '定义': ['有变量的语句看成是一种命题函数，其真值依赖于变量的取值', '设$x_{1},x_{2},\\\\cdots x_{n}$为$n$个个体变量，其个体域均为非空集合$D$，则定义在$D^{n}$上取值于$\\\\{0,1\\\\}$的$n$元函数称为$n$元简单命题函数', '通过将原子命题中的个体常量泛化为个体变量的方式实现对命题结构的分解和对命题含义的抽象'], '特点': ['谓词刻画了变量的性质和变量之间的联系，反映了命题函数的本质内涵并构成命题函数的主体内容；当变量未赋值时，真值不确定；当变量赋值后，成为具体命题', '含有变元的简单命题函数其实就是含有变元的谓词'], '示例': '表示“$x$ 是大学生”的式子“$P(x)$”，以及“$x>5$”、“$x+y=10$”、“$x+y<z$”，都是简单命题函数'}",,3,谓词逻辑通过对原子命题中的主语和宾语指代对象进行抽象和泛化，形成一种含有变量的语句来表示一类命题，并随着变量的不同指派得到各自相应的具体命题，因而可将这种有变量的语句看成是一种命题函数。在这个抽象过程中，原子命题中的谓语部分则不做任何抽象或改变而直接继承到命题函数之中，并称其为谓词。在命题函数中，谓词刻画了变量的性质和变量之间的联系，反映了命题函数的本质内涵并构成命题函数的主体内容。事实上，也可以进一步对命题中的谓语部分进行抽象形成谓词变量，但是这种更高层次的抽象已经超出了我们的讨论范畴，不再赘述。
命题变量,概念,"['第三章  命题演算与推理', '§ 3.2 命题公式与等值演算', '3.2.1 命题公式的基本知识', '一、命题变量与命题公式']","{'实体类型': '概念', '定义': '表示一个泛指的、内容不确定的抽象命题的标识符', '特点': '真值取值不确定，不能看成命题'}",,4,"如前所述，可用大写英文字母作为标识符来表示命题。事实上，在具体的逻辑演算中，我们关注的重点往往是命题的真值取值状况而非命题的具体内容和含义。因此，可将作为命题标识符的字母符号取代具体的命题进行逻辑演算，由此形成一套形式化的符号逻辑代数演算系统。与初等代数中常量和变量的概念相类似，在这个系统中，对于一个给定的命题标识符，它不仅可用来特指某个具体的命题，成为命题常量，而且还可用于泛指一个任意的、没有具体内容的抽象命题，成为命题变量。命题常量和命题变量的具体定义如下：  
【定义3.7】如果一个命题标识符表示的是一个特定的、具有特定内容的具体命题，则称该标识符为命题常量；如果一个命题标识符表示的是一个泛指的、内容不确定的抽象命题，则称该标识符为命题变量。  
命题常量表示一个具体命题，其内容和真值都是确定的。因此，可将命题常量看成是一个命题。命题变量则表示任意一个命题，假定标识符𝑃是一个命题变量，则𝑃既可以表示“合肥是安徽的省会”，也可以表示“太阳从西方升起”，还可以表示其它任意命题。事实上，可以将命题变量理解成一个能够存放任意命题的空容器， 其含义随着容器中所存放具体命题的不 同而不同。因此，命题变量的真值取值是不确定的，不能将其看成命题。  
我们知道，复合命题是由原子命题经由联结词进行逻辑运算得到的命题。当复合命题中的原子命题变成命题变量时，该复合命题显然就变成了一种以这些命题变量为自变量的函数。由于这种函数的取值为或真或假的真值，故称这种函数为真值函数或命题公式。  
例如，下列表达式就是一些命题公式或真值函数：  
$$
P、 \neg(P\lor Q)、s\ (P\lor Q)\to R、\quad P\to(P\lor Q)
$$  
由此可知，命题公式或真值函数其实就是由表示命题变量的标识符和逻辑联结词构成的逻辑运算表达式。需要说明的是，命题公式之所以能够构成逻辑运算表达式，关键在于其能够根据逻辑联结词的含义进行运算，故此并不是由命题变量和标识符构成的任意字符串都能  
构成命题公式。例如，下列字符串都不是命题公式：  
$$
(P\lor Q)\to\lor\,\,(P\to Q)\to(\lor Q)\,,\,\,(P\to Q\setminus\,\,(P\to Q)\leftrightarrow
$$  
因此，必须要有一个严格的、具有可操作性的标准来区分哪些符号串是合法的命题公式，哪些字符串则不能构成命题公式。以下命题公式的归纳定义就确定了这个标准。  
【定义3.8】由表示命题变量的标识符、逻辑联结词和括弧构成的字符串称为命题演算的合式公式，又称为命题公式或真值函数，当且仅当它按下列4 条规则构造而成：  
（1）单个的命题变量是一个命题公式；  
（2）若𝐺是一个命题公式，则$(\neg G)$也是一个命题公式；  
（3）若𝐺, $H$是命题公式，则$(G\wedge H)$、$(G\lor H)$、$(G\to H)$)、$(G\leftrightarrow H)$)都是命题公式；  
（4）仅通过有限次使用规则（1）、（2）、（3）所得到的字符串才是命题公式。  
在上述定义中的四个规则确定了一个由所有命题公式为元素组成的集合，第（1）条规则决定了该集合为非空集合并确定了集合的初始元素，第（2）、（3）条规则则是根据集合中初始元素通过运算不断构造出新的元素，是集合的不断扩张的过程，第（4）条规则则是对集合的扩张进行了限制，给出了集合的边界，由此构成一个边界确定集合。这个集合就是命题函数的一种外延式定义。  
为书写简单起见，对命题公式中括弧使用和联结词运算优先级做如下约定：  
（1）命题公式中最外层的括弧可以省略；  
（2）5 种常用逻辑联结词的运算优先级从左到右按如下次序递减：
$$
\neg 、 \wedge 、 \vee 、 \rightarrow 、 \leftrightarrow
$$
例如，对于下列命题公式:
$$
(P \wedge(\neg Q)) 、(P \rightarrow Q) \rightarrow(Q \wedge(\neg R)) 、(P \vee(Q \wedge R)) \leftrightarrow(P \vee   (R \rightarrow \neg S)) 、(\neg Q) \rightarrow((P \wedge R) \rightarrow(\neg R \wedge Q))
$$
可分别将其简写为：  
$$
P\land\lnot Q\land\ {\cal P}\to Q\to Q\land\lnot R\land\ {\cal P}\lor Q\land R\leftrightarrow{\cal P}\lor(R\to\lnot S)\land\ \lnot Q\to P\land R\to\lnot R\lor Q
$$"
命题常量,概念,"['第三章  命题演算与推理', '§ 3.2 命题公式与等值演算', '3.2.1 命题公式的基本知识', '一、命题变量与命题公式']","{'实体类型': '概念', '定义': '表示一个特定的、具有特定内容的具体命题的标识符', '特点': '内容和真值都是确定的，可看成是一个命题'}",,4,"如前所述，可用大写英文字母作为标识符来表示命题。事实上，在具体的逻辑演算中，我们关注的重点往往是命题的真值取值状况而非命题的具体内容和含义。因此，可将作为命题标识符的字母符号取代具体的命题进行逻辑演算，由此形成一套形式化的符号逻辑代数演算系统。与初等代数中常量和变量的概念相类似，在这个系统中，对于一个给定的命题标识符，它不仅可用来特指某个具体的命题，成为命题常量，而且还可用于泛指一个任意的、没有具体内容的抽象命题，成为命题变量。命题常量和命题变量的具体定义如下：  
【定义3.7】如果一个命题标识符表示的是一个特定的、具有特定内容的具体命题，则称该标识符为命题常量；如果一个命题标识符表示的是一个泛指的、内容不确定的抽象命题，则称该标识符为命题变量。  
命题常量表示一个具体命题，其内容和真值都是确定的。因此，可将命题常量看成是一个命题。命题变量则表示任意一个命题，假定标识符𝑃是一个命题变量，则𝑃既可以表示“合肥是安徽的省会”，也可以表示“太阳从西方升起”，还可以表示其它任意命题。事实上，可以将命题变量理解成一个能够存放任意命题的空容器， 其含义随着容器中所存放具体命题的不 同而不同。因此，命题变量的真值取值是不确定的，不能将其看成命题。  
我们知道，复合命题是由原子命题经由联结词进行逻辑运算得到的命题。当复合命题中的原子命题变成命题变量时，该复合命题显然就变成了一种以这些命题变量为自变量的函数。由于这种函数的取值为或真或假的真值，故称这种函数为真值函数或命题公式。  
例如，下列表达式就是一些命题公式或真值函数：  
$$
P、 \neg(P\lor Q)、s\ (P\lor Q)\to R、\quad P\to(P\lor Q)
$$  
由此可知，命题公式或真值函数其实就是由表示命题变量的标识符和逻辑联结词构成的逻辑运算表达式。需要说明的是，命题公式之所以能够构成逻辑运算表达式，关键在于其能够根据逻辑联结词的含义进行运算，故此并不是由命题变量和标识符构成的任意字符串都能  
构成命题公式。例如，下列字符串都不是命题公式：  
$$
(P\lor Q)\to\lor\,\,(P\to Q)\to(\lor Q)\,,\,\,(P\to Q\setminus\,\,(P\to Q)\leftrightarrow
$$  
因此，必须要有一个严格的、具有可操作性的标准来区分哪些符号串是合法的命题公式，哪些字符串则不能构成命题公式。以下命题公式的归纳定义就确定了这个标准。  
【定义3.8】由表示命题变量的标识符、逻辑联结词和括弧构成的字符串称为命题演算的合式公式，又称为命题公式或真值函数，当且仅当它按下列4 条规则构造而成：  
（1）单个的命题变量是一个命题公式；  
（2）若𝐺是一个命题公式，则$(\neg G)$也是一个命题公式；  
（3）若𝐺, $H$是命题公式，则$(G\wedge H)$、$(G\lor H)$、$(G\to H)$)、$(G\leftrightarrow H)$)都是命题公式；  
（4）仅通过有限次使用规则（1）、（2）、（3）所得到的字符串才是命题公式。  
在上述定义中的四个规则确定了一个由所有命题公式为元素组成的集合，第（1）条规则决定了该集合为非空集合并确定了集合的初始元素，第（2）、（3）条规则则是根据集合中初始元素通过运算不断构造出新的元素，是集合的不断扩张的过程，第（4）条规则则是对集合的扩张进行了限制，给出了集合的边界，由此构成一个边界确定集合。这个集合就是命题函数的一种外延式定义。  
为书写简单起见，对命题公式中括弧使用和联结词运算优先级做如下约定：  
（1）命题公式中最外层的括弧可以省略；  
（2）5 种常用逻辑联结词的运算优先级从左到右按如下次序递减：
$$
\neg 、 \wedge 、 \vee 、 \rightarrow 、 \leftrightarrow
$$
例如，对于下列命题公式:
$$
(P \wedge(\neg Q)) 、(P \rightarrow Q) \rightarrow(Q \wedge(\neg R)) 、(P \vee(Q \wedge R)) \leftrightarrow(P \vee   (R \rightarrow \neg S)) 、(\neg Q) \rightarrow((P \wedge R) \rightarrow(\neg R \wedge Q))
$$
可分别将其简写为：  
$$
P\land\lnot Q\land\ {\cal P}\to Q\to Q\land\lnot R\land\ {\cal P}\lor Q\land R\leftrightarrow{\cal P}\lor(R\to\lnot S)\land\ \lnot Q\to P\land R\to\lnot R\lor Q
$$"
命题推证的基本策略,概念,"['3.5.3 命题推证的基本策略', '第三章  命题演算与推理', '一、真值表法', '§ 3.5 命题逻辑的演绎推理']","{'实体类型': '概念', '类型': '真值表法、直接证明法和间接证明法', '定义': '在命题逻辑中进行推理的基本方法', 'name': '命题推证的基本策略'}",,3,如前所述，有效推理的过程其实就是证明逻辑蕴含式的过程。因此，命题推证的基本策略主要有真值表法、直接证明法和间接证明法这三种基本类型。
命题标识符,概念,"['第三章  命题演算与推理', '§ 3.1 命题的概念与运算', '3.1.2  命题的基本概念']","{'实体类型': '概念', '定义': '用带下标或不带下标的大写英文字母表示命题', '特点': '在命题逻辑系统中，对命题标识符的解释不允许有二义性'}",,3,"命题逻辑以命题作为最基本的处理对象。因此，学习命题逻辑首先必须掌握命题的基本概念。事实上，命题的概念与集合的概念一样，是一个没有严格定义的原始概念，其内涵是不言自明的。我们只能对命题的概念进行描述或解释：  
所谓命题，就是具有确切真假含义且能做出判断的陈述句。当判断正确或者符合客观实际时，命题表达的内容为真或者说命题的取值为真，并称该命题为真命题；否则命题表达的内容为假或者说命题的取值为假，并称该命题为假命题。命题或真或假的取值，称为命题的真值。通常用 $T$或1 表示取值为真的真值，用 $F$ 或0 表示取值为假的真值。  
根据上述关于命题概念的解释，可以看出：  
（1）命题主要用于逻辑思维中的是非判断，因此必须是陈述语句。其它类型的语句，例如感叹句、祈使句、疑问句等，都不能用于是非判断，故不能作为命题。  
（2）对于任何一个给定的命题，必有唯一确定的真值，要么取真、要么取假，不能既真又假，也不能既不真也不假。因此，具有二义性的陈述句不能作为命题。  
【定义3.1】对于任意一个给定的命题，当它不能再分解为更加简单的陈述句时，则称该命题为原子命题；否则，称之为复合命题。  
由上述定义可知，所有命题分为原子命题和复合命题这两种基本类型。例如，命题“合肥是安徽的省会”就是一个不能再分解的原子命题，而命题“安徽不是一个国家”则是一个复合命题，由“安徽是一个国家”这个原子命题生成。  
通常用带下标或不带下标的大写英文字母 $A,B,C,\ldots,P,Q,R,\ldots$… 表示命题，并称之为命题标识符。在命题逻辑系统中，对命题标识符的解释不允许有二义性。也就是说，对于任一确定的具体场合，各个标识符所表达的含义是唯一确定的。"
命题演算与推理,概念,"['三、蕴含与等价联结词', '3.1.3  命题的常用联结词', '§ 3.1 命题的概念与运算', '第三章  命题演算与推理', '二、合取与析取联结词']","{'实体类型': '概念', '定义': ['通过联结词和标点符号将原子命题联结成复合命题的运算机制', '研究命题的逻辑运算及其推理规则']}",,3,"可以通过一些联结词和标点符号将若干原子命题联结起来构成复合命题，由此形成命题的运算机制。为了能够使用数学方法表示、分析和处理这种命题运算机制，精确研究命题之间的逻辑关系，需要引入一套抽象数学符号来表示这些联结词。最常用的逻辑联结词主要有如下五种：“或者”、 “并且”、“不是”、“如果…, 那么…”、“当且仅当”。下面分别介绍这些逻辑联结词的具体逻辑含义及其数学符号。"
命题的否定,概念,"['第三章  命题演算与推理', '§ 3.1 命题的概念与运算', '3.1.3  命题的常用联结词', '一、否定联结词']","{'实体类型': '概念', '定义': '对于任意一个给定的命题，可以通过对其含义取反或者进行否定来得到一个新的命题', '特点': '新命题的含义与真值与原命题完全相反', '运算': '命题的“非”运算或“否定”运算'}",,4,"对于任意一个给定的命题，可以通过对其含义取反或者进行否定来得到一个新的命题。新命题的含义与真值与原命题完全相反，由此得到的逻辑运算称为命题的“非”运算或“否定”运算。该运算及其逻辑联结词具体定义如下：  
【定义3.2】设 $P$ 是任一命题，复合命题“非 $P$ ”称为 $P$ 的否定式或非运算，记作 $\lnot\ P$ ，其中符号$\neg$称为否定联结词(简称为否定词)。$\lnot\ P$ 的真值为真，当且仅当 $P$ 的真值为假，或者说：$\lnot\ P$ 的真值为假，当且仅当 $P$ 的真值为真。  
$\lnot\ P$ 是一个由命题$P$衍生而来的复合命题，其真值取值状况与 $P$ 完全相反。例如，若令 $P$ 表示命题“我喜欢唱歌”，则 $\lnot\ P$ 就表示命题“我不喜欢唱歌”。  
对于任意一个命题 $P$，它其否定命题¬ $P$ 之间的真值关系如表3-1 第3 列所示：  
表$^{3\cdot1}\ \neg,\ \wedge,$ ∨的运算表
![](images/b0b4f79b14e0e83d1cdd7d9bbd1f3b9956a6520b82a62886b519b2594f4eadae.jpg)"
命题的常用联结词,概念,"['§ 3.1 命题的概念与运算', '第三章  命题演算与推理', '3.1.3  命题的常用联结词', '三、蕴含与等价联结词']","{'实体类型': '概念', '定义': '用于构成复合命题的逻辑联结词', '种类': '或者、并且、不是、如果…, 那么…、当且仅当', '作用': '表示命题之间的逻辑关系'}",,3,"可以通过一些联结词和标点符号将若干原子命题联结起来构成复合命题，由此形成命题的运算机制。为了能够使用数学方法表示、分析和处理这种命题运算机制，精确研究命题之间的逻辑关系，需要引入一套抽象数学符号来表示这些联结词。最常用的逻辑联结词主要有如下五种：“或者”、 “并且”、“不是”、“如果…, 那么…”、“当且仅当”。下面分别介绍这些逻辑联结词的具体逻辑含义及其数学符号。"
命题的概念与运算,概念,"['第三章  命题演算与推理', '§ 3.1 命题的概念与运算']","{'实体类型': '概念', '内容': '包括命题逻辑的由来、命题的基本概念、命题的基本运算和常用联结词、命题的符号化与应用'}",,2,逻辑主要分为辩证逻辑与形式逻辑这两大类。辩证逻辑主要研究人类思维中的辩证法，属于哲学范畴。离散数学领域的逻辑通常是指形式逻辑，主要研究人类思维的基本形式、基本规则和基本规律，由概念、判断、推理这三个逐步递进的基本构件组成，通过概念形成判断，再通过判断形成推理。其中判断在整个形式逻辑系统中起着承上启下的枢纽作用，它以命题为载体实现其逻辑演算与推理的功能。因此，命题逻辑不仅是数理逻辑学中最为基础的内容，而且在整个逻辑学的学科体系占有十分重要的地位。学习命题逻辑一般需要从命题的概念和运算开始，本节主要介绍命题的基本概念和基本运算，包括命题逻辑的由来、命题的基本概念、命题的基本运算和常用联结词、命题的符号化与应用等。
命题联结词,概念,"['第三章  命题演算与推理', '§ 3.1 命题的概念与运算', '3.1.3  命题的常用联结词', '四、命题联结词小结']","{'实体类型': '概念', '定义': '用于构成命题运算的符号', '常用联结词': '否定、合取、析取、蕴涵、等价', '应用': '用数学符号表示复杂的复合命题'}",,4,"目前，我们学习了“否定”、 “合取”、 “析取”、 “蕴涵”和“等价”这5 个常用命题联结词，它们分别构成5 种不同的命题运算，其基本要点如表3-3 所示：  
表3-3  5 个常用命题联结词
![](images/cd7370ae4f3f6617837e091acd224e6d77723e30dcb7dd8be5213aea796aabec.jpg)  
![](images/8b3f0acea45c0f824a0da51d8118e72c060c29e3e9151811464ac93e02e86b47.jpg)  
通过这些命题运算联结词，就可用数学符号表示一些比较复杂的复合命题。例如，对于如下某计算机机房的一项规定：“凡进入机房者，必须换拖鞋、穿工作服，否则罚款人民币100 元。”可将其翻译成符号化的复合命题。  
为此，令$P$表示“某人进入机房”、 $Q$表示“某人换拖鞋、$R$表示“某人穿工作服”、 $S$表示“某人必须罚款100 元”，则此机房规则可表示为：$\neg(P\to(Q\land R))\ \to S$。"
命题运算,原理,"['第三章  命题演算与推理', '§ 3.1 命题的概念与运算', '3.1.3  命题的常用联结词', '四、命题联结词小结']","{'实体类型': '原理', '定义': '通过命题联结词进行的逻辑运算', '特点': '可用数学符号表示复合命题'}",,4,"目前，我们学习了“否定”、 “合取”、 “析取”、 “蕴涵”和“等价”这5 个常用命题联结词，它们分别构成5 种不同的命题运算，其基本要点如表3-3 所示：  
表3-3  5 个常用命题联结词
![](images/cd7370ae4f3f6617837e091acd224e6d77723e30dcb7dd8be5213aea796aabec.jpg)  
![](images/8b3f0acea45c0f824a0da51d8118e72c060c29e3e9151811464ac93e02e86b47.jpg)  
通过这些命题运算联结词，就可用数学符号表示一些比较复杂的复合命题。例如，对于如下某计算机机房的一项规定：“凡进入机房者，必须换拖鞋、穿工作服，否则罚款人民币100 元。”可将其翻译成符号化的复合命题。  
为此，令$P$表示“某人进入机房”、 $Q$表示“某人换拖鞋、$R$表示“某人穿工作服”、 $S$表示“某人必须罚款100 元”，则此机房规则可表示为：$\neg(P\to(Q\land R))\ \to S$。"
命题逻辑,概念,"['3.1.1  逻辑与命题逻辑', '§ 3.6 命题逻辑的应用', '3.6.3 加法器电路设计', '第三章  命题演算与推理', '§ 3.1 命题的概念与运算', '§ 4.1 个体词、谓词与量词', '4.1.1  逻辑与谓词逻辑', '3.6.2 组合逻辑电路设计', '第四章  谓词演算与推理']","{'实体类型': ['概念', '原理'], '地位': '数理逻辑知识体系中最经典、最基础的部分, 在整个逻辑学的学科体系占有十分重要的地位', '内容': '包括命题的基本概念与运算性质、命题公式与等值演算、真值函数与联结词的完备集、命题公式的范式、命题逻辑的推理系统与方法', '定义': '数理逻辑学中最为基础的内容, 以命题为基本处理单元的逻辑系统, 以原子命题为基本单元研究命题的性质和逻辑推演', '组成': '由概念、判断、推理这三个逐步递进的基本构件组成', '功能': '通过概念形成判断，再通过判断形成推理', '发展者': '布尔和德摩根', '应用': ['案件侦破、电路设计', '组合逻辑电路设计的理论基础和基本工具', '逻辑电路设计'], '实际应用价值': '培养逻辑思维能力、自动推理、组合电路设计、计算机加法器电路设计', '特点': '以命题为基本单位考察命题之间的逻辑关系，不能深入到命题内部从概念层次上进行逻辑演算与推理', '局限': '无法揭示命题之间在概念层次上的共同特征与逻辑联系, 无法表达命题内部成分之间的联系，无法解决苏格拉底三段论推理问题'}",,1,"计算机是处理数据并将其转化为有用信息的电子设备，其中央处理器主要由算术逻辑计算单元构成，通过数值与逻辑运算实现对信息的表示和处理。因此，逻辑运算作为计算机信息处理的两大基本方式之一，在计算机软件与硬件设计中具有非常重要的作用。在现实社会中，人们通常使用自然语言表达和处理逻辑问题。然而，计算机还远未实现对自然语言的正确理解，不能有效解决自然语言与生俱来的概念歧义问题，因此需要通过引入一套抽象数学符号来实现逻辑的表达和运算。这种基于数学符号表达和运算的形式化逻辑，称之为数理逻辑。数理逻辑最初主要由命题逻辑构成，后来由命题逻辑逐步发展到谓词逻辑，并进一步衍生出证明论、模型论、递归论等多个分支。数理逻辑严密无歧义的符号化表达和处理方式非常契合计算机信息处理的特点和机器思维的需求。计算机通过将数理逻辑中的数学符号转化成物理量实现其非凡的逻辑处理能力，学习和研发计算机系统必须借助数理逻辑中数学符号的演算规律去思考、表达和解决问题，善于通过数学符号的逻辑演算来驱动计算机实现信息的表示和处理。因此，数理逻辑在计算机与人工智能的各个领域都发挥着基础性的支撑作用，是计算机相关专业人员必须牢固掌握的基础知识。  
通过学习数理逻辑，读者不仅可以较好地掌握形式化表达和处理信息的基本方法，满足后续专业课在数理逻辑方面的知识需求，更为重要的是能够养成抽象严谨的逻辑思维，充分提高分析问题和解决问题的能力。命题逻辑是整个数理逻辑知识体系中最经典、最基础的部分，要掌握数理逻辑基本理论和应用技术，首先必须学好命题逻辑。本章比较系统地介绍命题逻辑的基本理论与应用，包括命题的基本概念与运算性质、命题公式与等值演算、真值函数与联结词的完备集、命题公式的范式、命题逻辑的推理系统与方法等。"
命题逻辑推理,算法,"['第三章  命题演算与推理', '§ 3.6 命题逻辑的应用', '3.6.1 刑侦推断问题']","{'实体类型': '算法', '应用': '案件侦破等领域', '前提条件': '现有案件线索', '结论': '有价值的推理结论供案件侦破人员参考'}",,3,命题逻辑推理在案件侦破等领域具有十分重要的作用，可以现有案件线索作为命题逻辑的推理的前提条件进行有效推理，得到有价值的推理结论供案件侦破人员参考。
命题逻辑的演绎推理,概念,"['3.5.3 命题推证的基本策略', '（1）真值表法', '二、基本永真蕴含关系', '一、真值表法', '§ 3.5 命题逻辑的演绎推理', '（2）公式演算法', '第三章  命题演算与推理', '三、永真蕴含关系判定法', '3.5.1 永真蕴含关系与判定']","{'实体类型': ['概念', '原理'], '定义': ['由已知命题得到新命题的思维过程', '通过已知命题和逻辑规则推导出新命题的过程', '基于命题逻辑的推理方法', '基于命题逻辑进行的推理过程', '基于命题逻辑进行的演绎推理过程', '有效推理的过程是证明逻辑蕴含式的过程'], '条件': '前提与结论之间具有必然的联系', '类型': '演绎推理和归纳推理', '研究对象': '演绎推理', '研究方法': '用数学的方法研究推理', '研究内容': '推理的形式结构', '应用': '用于从前提推导出结论'}",,2,作为研究人类思维基本形式、基本规则和基本规律的逻辑科学，主要包括概念、判断、推理这三个层次内容，由概念形成判断，再由判断形成推理。人们总是将推理作为学习和研究逻辑学的主要任务和主要目的。因此，通常直接将逻辑学定义为研究推理的学科。所谓推理，其实就是由已知命题得到新命题的思维过程。已知的命题称为推理的条件或前提，推得的新命题称为推理的结论。推理一般分为演绎推理和归纳推理这两种基本类型。对于任意一个推理，如果其前提与结论之间具有必然的联系，则称该推理为演绎推理，否则称之为归纳推理。数理逻辑的研究对象为主要是演绎推理，除非特别说明，我们所说的推理均为演绎推理。数理逻辑主要是用数学的方法来研究推理，也就是说通过引入一套数学符号的方法来研究推理。因此，数理逻辑主要研究推理的形式结构，或者说研究采用什么样的形式结构进行推理是有效的，研究采用什么样的形式结构进行推理是无效的。本节主要学习命题逻辑推理的基本知识，包括命题推理的基本概念、命题公式永真蕴含关系与判定、命题推演系统的构成以及命题推证的基本策略。
哈密顿图,概念,"['第十章  特殊图模型与算法', '10.5.3 最优路线问题', '§ 10.4 网络流图及其优化问题', '10.1.2  哈密顿图及其性质', '§ 10.1 欧拉图与哈密顿图']","{'实体类型': '概念', '应用': ['解决旅游的路径规划问题', '讨论与之相关的应用问题', '图论中的路径问题', '求解最优路线问题'], '相关理论': '哈密顿图及相关理论', '定义': ['对图中所有结点的唯一性遍历问题', '存在哈密顿回路的图', '包含哈密顿回路的图'], '特点': ['困难得多，所需边数与图模型的具体结构有复杂联系', '经过图中每个结点一次且仅一次的回路'], '必要条件': '对于任意非空子集V1，均有p(G-V1)≤|V1|', '充分条件': '对任意两个不相邻的结点u,v，均有deg(u)+deg(v)≥n'}",,1,"如前所述，图模型及其理论是数学家欧拉为解决哥尼斯堡七桥遍历问题而创立。事实上，图模型作为一种由结点和边组成的离散结构是一种非常强大的离散建模工具，除了能够解决哥尼斯堡七桥遍历问题之外，还可解决很多其它实际问题。例如，旅游的路径规划问题、资源分配与匹配问题、图的着色与并行流程的设计问题、最小费用流问题等等。针对不同的问题，通常需要设计出特定的图模型进行建模与求解。例如，解决哥尼斯堡七桥遍历问题需要使用欧拉图及相关理论、解决旅游的路径规划问题需要哈密顿图及相关理论、解决资源分配与匹配问题需要二分图及相关理论、解决图的着色与并行流程的设计问题需要平面图的相关理论、解决最小费用流问题需要网络流图的相关理论等等。由此产生很多种具有特殊结构和性质的图模型，每种特殊图模型都能针对性地有效地解决某一类或某几类特定问题。因此，要想高效合理地使用图模型实现对实际问题的建模与求解，除了掌握前述图模型的一般理论及算法之外，还需要进一步掌握多种特殊图模型的相关理论及算法。  
本章介绍几种重要的特殊图模型及相关算法，包括欧拉图模型的基本理论及边的遍历算法、哈密顿图的基本理论及结点的近似遍历算法、二分图模型的基本理论及匈牙利匹配构造算法、平面图的基本理论及着色算法、网络流图的基本理论及最大流算法，并结合具体实例分析和讨论这些特殊图模型的应用方法。"
哈密顿通路,概念,"['第十章  特殊图模型与算法', '§ 10.1 欧拉图与哈密顿图', '10.1.2  哈密顿图及其性质']","{'实体类型': '概念', '定义': '经过图中每个结点一次且仅一次的通路', '特点': '图中所有结点的一个全排列'}",,3,"与哥尼斯堡七桥问题类似，哈密顿图模型也是来源于一个有趣的实例。1856 年，著名的爱尔兰数学家哈密顿在给朋友的信中谈到一个关于如图10-13 所示十二面体的数学问题：把每个结点看成是一个城市，连接两个结点的边看成交通线，能否找到一条旅行线路，沿着交通线经过十二面体的全部20 个城市一次且仅一次，然后再回到原来的出发点？对于这个问题，哈密顿将如图10-13（a）所示十二面体展开成如图10-13（b）所示的图模型，并给出了如图10-12（c）所示的回路，哈密顿图和哈密顿回路由此得名。  
![图10-13 十二面体的数学问题  ](images/f9d9b1ce93d10109a19c31e0468e3a1ce9ead26e329e520a14ed719c39c74609.jpg)  
【定义10.2】经过图中每个结点一次且仅一次的通路称为哈密顿通路。经过图中每个结点一次且仅一次的回路称为哈密顿回路。存在哈密顿回路的图称为哈密顿图；存在哈密顿通路的图称为半哈密顿图。规定平凡图为哈密顿图。  
显然，哈密顿通路是经过图中所有结点的最短通路，即经过图中所有结点的基本通路。哈密顿回路是经过图中所有结点的最短回路，即经过图中所有结点的基本回路。事实上，哈密顿通路就是图中所有结点的一个全排列。  
![图 10-14  哈密顿图与非哈密顿图 ](images/428b9e316b5acee7d3001e928f0a06090173f2550480e12bbb7942d43098f612.jpg)  
例如，在图10-14 中，图$G_{1}$存在哈密顿通路，但是不存在哈密顿回路，故图$G_{1}$是半哈密顿图；图$G_{2}$存在哈密顿回路，故图$G_{2}$是哈密顿图；图$G_{3}$既不存在哈密顿通路，更不存在哈密顿回路，故图$G_{3}$既不是哈密顿图，更不是半哈密顿图。  
相比欧拉图，哈密顿图的研究要困难得多。因为对图中每个结点的遍历需要让每个结点都具有一定数量的边供遍历路径的选择，也是就说对每个结点的度有一定的数量要求，但是这种度的数量又与图模型的具体结构有非常密切且隐含关系。总的来说，就是要求图中结点的度数不能太少且分布比较均衡，但是又很难量化这种条件。因此，目前还没有找到能够直接判定一个图是哈密顿图的充分必要条件。首先给出哈密顿图的一个必要条件：  
【定理10.3】设无向图$G=\langle V,E\rangle$是哈密顿图，则对于𝑉的任意非空子集$.V_{1}$，均有：
$$
p(G-V_{1})\leq|V_{1}|
$$  
其中$p(G-V_{1})$是从图$G$中删除$\cdot V_{1}$后所得图的连通分支数。  
【推论10.2】设无向图$G=\langle V,E\rangle$是半哈密顿图，则$V_{1}$是𝑉的任意非空子集，均有：  
$$
p(G-V_{1})\leq|V_{1}|+1
$$  
定理10.3 和推论10.2 表明，在图中所有结点总度数确定的情况下，要使一个图模型为哈密顿图，就必须使得度数的分配比较均衡。因为如果图的度数集中分布到某一个或某几个结点，则删除这些结点后，会使得图中的边数大量减少，导致图的连通分支数目大量增加，即有 $p(G-V_{1})>|V_{1}|$ 或 $p(G-V_{1})>|V_{1}|+1$ ，此时就违背了上述定理或推论的条件。  
值得注意的是，定理10.3 和推论10.2 是必要而非充分条件。例如，对于图10-16 所示的彼得森图，该图显然满足定理10.3 的条件，但它不是哈密顿图。因此，定理10.3 和推论10.2 主要用于对哈密顿图的证伪。下面给出判定哈密顿图或者半哈密顿图的充分条件：  
【定理10.4】设图$G=\langle V,E\rangle$是任意给定的$n$阶无向简单图，如果对任意两个不相邻的结点$u,v\in V$，均有：  
$$
\deg(u)+\deg(v)\geq n-1
$$  
则图$G$中存在哈密顿通路。  
【定理10.5】（奥尔定理）设图$G=\langle V,E\rangle$是$n$阶无向简单图，如果对任意两个不相邻的结点$u,v\in V$，均有：  
$$
\deg(u)+\deg(v)\geq n
$$  
则图$G$中存在哈密顿回路。  
【定理10.6】（狄拉克定理）设图$G=\langle V,E\rangle$是$n$阶无向简单图，如果对于图中结点𝑣∈𝑉，均有$\deg(v)\geq n/2$ ，则图$G$中存在哈密顿回路。  
定理10.4、定理10.5 和定理10.6 给出了判定哈密顿图的充分条件，其中狄拉克定理可以看成是奥尔定理的一个推论。上述3 个定理表明，如果要使得一个图是哈密顿图，就必须保证图中有足够多的边并分布基本均衡，或者说图中每个结点都要关联足够多的边。不难看出，这些条件是比较强的或者说是比较苛刻的。事实上，这些条件并非必要条件。例如，一条具10 个结点的链显然是半哈密顿图，但该图并不满足定理10.4 的条件，将该链的首尾一条边相连构成的圈图显然是哈密顿图，但并不满足定理10.5 和定理10.6 的条件。"
哈希函数,概念,"['第七章 函数与特殊函数', '§ 7.4 有限集的置换函数', '7.5.1 哈希查找问题']","{'实体类型': '概念', '定义': '关于存储位置和数据关键字的对应关系', '应用': '实现快速定位查找', '特点': '将任意长度的字符串映射为固定长度的字符串', '条件': '可能出现不同的关键字映射到同一地址的情况，即冲突'}",,3,"在计算机系统中，数据的存放位置和时间都不能完全确定，此时需要一种有效的方法在有限的存储空间中合理存放数据并且能够实现快速定位查找。此时，如果建立一个关于存储位置和数据关键字的对应关系$f$，就能找给定值$k e y$的像$f(k e y)$。这里的对应关系$f$通常称为哈希函数，这种数据查找方法称为哈希查找。  
例如，如果要建立一张学生成绩表，最简单的方法是以学生的学号作为关键字，1 号学生的记录位置放在第一条，10 号学生的记录位置放在第10 条，以此类推。此时，如果要查看的学号为5 的学生的成绩，则只要取出第5 条记录就可以了.这样建立的表实际上就是一张简单的哈希表，其哈希函数为$f(k e y){=}\ k e y$。然而很多情况下的哈希函数并不如此简单。为了查看的方便，可能会以学生的名字作为关键字。此时，为了能够根据学生的名字直接定位出相应记录所在的位置，需要将这些名字转化为数字，构造出相应的哈希函数，下面给出两个不同的哈希函数：  
（1）考察学生名字的汉语拼音，将其中第一个字母在英语字母表中的序号作为哈希函数值。例如：“蔡军”的汉语拼音第一个字母为字母$C$，因此取03 作为其哈希值。  
（2）考察学生名字的汉语拼音，将其中第一个字母和最后一个字母在英语字母表中的序号之和作为哈希函数值。例如，“蔡军”的汉语拼音第一个字母和最后一个字母分别为$𝐶$和$N$，因此取17 作为其哈希值。  
分别应用这两个哈希函数，成绩表中部分学生名字不同的哈希函数值如表7-7 所示。  
表 7-7
![](images/a45025876fc98ab470bf113421a83e13ab1997baea6e789cdbd16990f25f7ba0.jpg)  
![](images/0f18f81e6e78fd7fb2b0f104794c8a798e21b0531706abe9d65a4f9970f2f012.jpg)  
在哈希表的构造过程中，可能会出现不同的关键字映射到同一地址的情况，即$k e y_{1}\neq$$k e y_{2}$，但$f(k e y_{1})=f(k e y_{2})$，也将这种现象称为冲突和碰撞。实际上，由于哈希函数是把任意长度的字符串映射为固定长度的字符串，冲突必然存在，只能尽可能减少。常见的构造哈希函数的方法有以下几种：  
（1）数字分析法。数字分析法适合于关键字由若干数码组成，同时各数码的分布规律事先知道的情况。具体方法是：分析关键字集合中每个关键字中的每一位数码的分布情况，找出数码分布均匀的若干位作为关键字的存储地址。例如，一个由80 个结点组成的结构，其关键字为6 位十进制数。选择哈希表长度为100，则可取关键字中的两位十进制数作为结点的存储地址。具体采用哪两位数码，需要用数字分析法对关键字中的数码分布情况进行分析。假设结点中有一部分关键字如下：  
$k e y_{1}=301514\;\;;\;\;\;k e y_{2}=303027;\;\;k e y_{3}=301103;\;\;\;k e y_{4}=308329;$ $k e y_{5}=300287;\;\;k e y_{6}=305939;\;\;k e y_{7}=300792;\;\;k e y_{8}=300463\circ878.$  
对上述关键字分析可以发现，关键字的第一位均是3，第二位均是0，分布集中，不适合作为存储地址。而第4 位和第5 位分布均匀，所以该哈希函数可以构造为取第4,5 位作为结点的存储地址。上述8 个节点的散列地址为：  
$f(k e y_{1})=51~~~~f(k e y_{2})=02~~~~f(k e y_{3})=10~~~~f(k e y_{4})=32$ $f(k e y_{5})=28\;\;\;\;\;f(k e y_{6})=93\;\;\;\;\;f(k e y_{7})=79\;\;\;\;\;f(k e y_{8})=46$  
（2）平方取中法。平方取中法是一种比较常用的构造哈希函数的方法，具体是：将关键字求平方后，取其中间的几位数字作为散列地址。由于关键字平方后的中间几位数字和组成关键字的每一位数字都有关，因此产生冲突的可能性较小，最后究竟取几位数字作为散列地址需要由散列表的长度决定。例如，若结构的存储地址范围是1\~999，则取平方值的中间三位，如表7-8 所示。  
表7-8  平方取中法
![](images/3bce2eeb41624a2b374dfdbdb4f5d0a22039c970673844c48a904ace588c42b7.jpg)  
（3）除留余数法。除留余数法取关键字被某个不大于哈希表表长$m$的数$ p$除后所得余数为哈希地址，即$f(k e y)=k e y({\bmod{\ p}})$，其中$p\leq m$。这是一种最简单也是最常用的构造哈希函数的方法。它不仅可以对关键字直接取模（mod），也可在平方取中等运算之后取模。值得注意的是，在使用除留余数法时，对$ p$的选择很重要。若$p$选的不好，容易产生同义词。由经验得知：一般情况下可以选$p$为质数或不包含小于20 的质因素的合数。  
哈希函数中会不可避免的存在冲突。因此，在建造哈希函数时不仅要设定一个“好”的哈希函数，而且要设定一种处理冲突的方法。假设哈希表地址集为$\!\sim\!(n-1)$，冲突是指由关键字得到的哈希地址为𝑗$(0\leq j\leq n-1)$的位置上已有记录，则“处理冲突”就是为该关键字的记录找到另一个“空”的哈希地址。  
在处理冲突的过程中可能得到一个地址序列$h_{i}$，其中，$h_{i}\in[0,\mathfrak{n}-1],\mathrm{i}=1,2,\cdots,\mathtt{k}$。即  
在处理哈希地址的冲突时，若得到的另一个哈希地址${\bf h}_{1}$ 仍然发生冲突，则再求下一个地址$h_{2}$，若$ h_{2}$仍然冲突，再求得$h_{3}$，依此类推，直至$h_{k}$不发生冲突为止，则$h_{k}$为记录在表中的地址。处理冲突的具体方法通常有开放定址法、再哈希法和拉链法，这里不再赘述。"
哈希查找,算法,"['第七章 函数与特殊函数', '§ 7.4 有限集的置换函数', '7.5.1 哈希查找问题']","{'实体类型': '算法', '定义': '利用哈希函数进行数据查找的方法', '应用': '在有限的存储空间中合理存放数据并且能够实现快速定位查找'}",,3,"在计算机系统中，数据的存放位置和时间都不能完全确定，此时需要一种有效的方法在有限的存储空间中合理存放数据并且能够实现快速定位查找。此时，如果建立一个关于存储位置和数据关键字的对应关系$f$，就能找给定值$k e y$的像$f(k e y)$。这里的对应关系$f$通常称为哈希函数，这种数据查找方法称为哈希查找。  
例如，如果要建立一张学生成绩表，最简单的方法是以学生的学号作为关键字，1 号学生的记录位置放在第一条，10 号学生的记录位置放在第10 条，以此类推。此时，如果要查看的学号为5 的学生的成绩，则只要取出第5 条记录就可以了.这样建立的表实际上就是一张简单的哈希表，其哈希函数为$f(k e y){=}\ k e y$。然而很多情况下的哈希函数并不如此简单。为了查看的方便，可能会以学生的名字作为关键字。此时，为了能够根据学生的名字直接定位出相应记录所在的位置，需要将这些名字转化为数字，构造出相应的哈希函数，下面给出两个不同的哈希函数：  
（1）考察学生名字的汉语拼音，将其中第一个字母在英语字母表中的序号作为哈希函数值。例如：“蔡军”的汉语拼音第一个字母为字母$C$，因此取03 作为其哈希值。  
（2）考察学生名字的汉语拼音，将其中第一个字母和最后一个字母在英语字母表中的序号之和作为哈希函数值。例如，“蔡军”的汉语拼音第一个字母和最后一个字母分别为$𝐶$和$N$，因此取17 作为其哈希值。  
分别应用这两个哈希函数，成绩表中部分学生名字不同的哈希函数值如表7-7 所示。  
表 7-7
![](images/a45025876fc98ab470bf113421a83e13ab1997baea6e789cdbd16990f25f7ba0.jpg)  
![](images/0f18f81e6e78fd7fb2b0f104794c8a798e21b0531706abe9d65a4f9970f2f012.jpg)  
在哈希表的构造过程中，可能会出现不同的关键字映射到同一地址的情况，即$k e y_{1}\neq$$k e y_{2}$，但$f(k e y_{1})=f(k e y_{2})$，也将这种现象称为冲突和碰撞。实际上，由于哈希函数是把任意长度的字符串映射为固定长度的字符串，冲突必然存在，只能尽可能减少。常见的构造哈希函数的方法有以下几种：  
（1）数字分析法。数字分析法适合于关键字由若干数码组成，同时各数码的分布规律事先知道的情况。具体方法是：分析关键字集合中每个关键字中的每一位数码的分布情况，找出数码分布均匀的若干位作为关键字的存储地址。例如，一个由80 个结点组成的结构，其关键字为6 位十进制数。选择哈希表长度为100，则可取关键字中的两位十进制数作为结点的存储地址。具体采用哪两位数码，需要用数字分析法对关键字中的数码分布情况进行分析。假设结点中有一部分关键字如下：  
$k e y_{1}=301514\;\;;\;\;\;k e y_{2}=303027;\;\;k e y_{3}=301103;\;\;\;k e y_{4}=308329;$ $k e y_{5}=300287;\;\;k e y_{6}=305939;\;\;k e y_{7}=300792;\;\;k e y_{8}=300463\circ878.$  
对上述关键字分析可以发现，关键字的第一位均是3，第二位均是0，分布集中，不适合作为存储地址。而第4 位和第5 位分布均匀，所以该哈希函数可以构造为取第4,5 位作为结点的存储地址。上述8 个节点的散列地址为：  
$f(k e y_{1})=51~~~~f(k e y_{2})=02~~~~f(k e y_{3})=10~~~~f(k e y_{4})=32$ $f(k e y_{5})=28\;\;\;\;\;f(k e y_{6})=93\;\;\;\;\;f(k e y_{7})=79\;\;\;\;\;f(k e y_{8})=46$  
（2）平方取中法。平方取中法是一种比较常用的构造哈希函数的方法，具体是：将关键字求平方后，取其中间的几位数字作为散列地址。由于关键字平方后的中间几位数字和组成关键字的每一位数字都有关，因此产生冲突的可能性较小，最后究竟取几位数字作为散列地址需要由散列表的长度决定。例如，若结构的存储地址范围是1\~999，则取平方值的中间三位，如表7-8 所示。  
表7-8  平方取中法
![](images/3bce2eeb41624a2b374dfdbdb4f5d0a22039c970673844c48a904ace588c42b7.jpg)  
（3）除留余数法。除留余数法取关键字被某个不大于哈希表表长$m$的数$ p$除后所得余数为哈希地址，即$f(k e y)=k e y({\bmod{\ p}})$，其中$p\leq m$。这是一种最简单也是最常用的构造哈希函数的方法。它不仅可以对关键字直接取模（mod），也可在平方取中等运算之后取模。值得注意的是，在使用除留余数法时，对$ p$的选择很重要。若$p$选的不好，容易产生同义词。由经验得知：一般情况下可以选$p$为质数或不包含小于20 的质因素的合数。  
哈希函数中会不可避免的存在冲突。因此，在建造哈希函数时不仅要设定一个“好”的哈希函数，而且要设定一种处理冲突的方法。假设哈希表地址集为$\!\sim\!(n-1)$，冲突是指由关键字得到的哈希地址为𝑗$(0\leq j\leq n-1)$的位置上已有记录，则“处理冲突”就是为该关键字的记录找到另一个“空”的哈希地址。  
在处理冲突的过程中可能得到一个地址序列$h_{i}$，其中，$h_{i}\in[0,\mathfrak{n}-1],\mathrm{i}=1,2,\cdots,\mathtt{k}$。即  
在处理哈希地址的冲突时，若得到的另一个哈希地址${\bf h}_{1}$ 仍然发生冲突，则再求下一个地址$h_{2}$，若$ h_{2}$仍然冲突，再求得$h_{3}$，依此类推，直至$h_{k}$不发生冲突为止，则$h_{k}$为记录在表中的地址。处理冲突的具体方法通常有开放定址法、再哈希法和拉链法，这里不再赘述。"
哥尼斯堡七桥问题,问题,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.1  图模型的由来']","{'实体类型': '问题', '背景': '十八世纪哥尼斯堡小镇的七座桥', '解决者': '欧拉', '解决方法': '将陆地抽象成结点，桥抽象成边，转化为一笔画问题'}",,3,"俄罗斯加里宁格勒州的首府加里宁格勒，原名为哥尼斯堡，是一个具有悠久历史的小镇。有一条名为普雷格尔的小河横穿这个小镇，并且在河中间形成两个小岛。在十八世纪的时候，人们在这条河上建有七座桥，将河中两个岛与河的两岸联结起来，建成一个如图8-1 (a)所示的公园。人们闲暇时常在这个公园里散步，有一天其中有个人突发奇想，提出一个问题：一 个步行者怎样才能不重复、不遗漏地一次走完七座桥，最后回到出发点。问题提出后，很多人对此很感兴趣，纷纷进行试验，但始终未能解决。  
![图8-1 哥尼斯堡七桥问题 ](images/ec575bdd4dc2973aa10919a05915ce2521c1b0a0f2f8089a7104e2a805855033.jpg)  
1735 年，有几名大学生写信给当时正在俄罗斯的彼得斯堡科学院任职的瑞士天才数学家欧拉，请他帮忙解决这一问题。欧拉在亲自观察了哥尼斯堡七桥，在经过为期一年的研究之后，29 岁的欧拉在1736 年提交了名为《哥尼斯堡七桥》的论文，圆满解决了这一问题。在论文中，欧拉将两个小岛和两岸构成的四块陆地分别抽象成结点，然后将连接这四块陆地的七座小桥分别抽象成连接这四个结点的边，如图8-1 (b)所示。这样遍历哥尼斯堡七桥问题就转化为遍历图8-1 (b)的七条边的问题或者说是对图8-1 (b)的一笔画问题。  
我们知道，对于任意一个结点，如果它是出发结点，那么它必然要关联一条边使得散步者能够回到这个结点，如果这个结点不是出发点，那么这个结点必须要关联偶数条边以保证散步者能够进出这个结点，因为每条边只能通过一次，进出一次这个结点需要关联两条不同的边。根据以上思路，不难得到如下三条关于一笔画结论：  
1.如果一个连通图的每个结点都关联偶数条边，那么可以任一结点为起点，用一笔画完此图并该结点为终点；  
2.如果一个连通图只有两个结点关联奇数条边，其余结点均关联偶数条边，那么该图一定可以用一笔画成，此时，关联奇数条边的两个结点分别为起点和终点；  
3.不满足前两个条件的图都不能用一笔画出，此时将关联奇数条边的结点数除以二便可得到该图需用几笔才能画成。  
现在考察哥尼斯堡七桥问题，图中每个结点均关联奇数条边，因而无解。  
欧拉解决哥尼斯堡七桥问题的思路非常巧妙，是一种全新的建模方式。在完美解决哥尼斯堡七桥问题之后，欧拉对这种模型的性质以及相关的建模方式做了深入系统的研究并由此创立了一套新的数学理论——图论。因此，欧拉被誉为图论之父。  
除欧拉之外，还有很多数学家对图论的研究做出重要成果，例如霍尔基夫基于图论的电路网络分析、麦比乌斯的四色猜想问题及解法、哈密尔顿的结点遍历问题及解法，等等。直至1936 年，匈牙利的数学家哥尼格出版了第一本图论专著《有限图与无限图的理论》，标志着图论从此成为一门相对独立完备的数学分支。"
商代数,概念,"['第十一章  抽象代数结构通论', '§ 11.1 代数结构的基本概念', '11.1.1 数学结构与代数结构']","{'实体类型': '概念', '定义': '由代数结构的商集及其上的运算构成的代数结构'}",,3,"代数结构作为四大基本数学结构之一，它以运算作为处理机制，在整个数学理论体系和计算机数学建模中占据非常重要的作用。代数结构是一种非常古老的数学结构，具有几千年发展历程，从最初初等代数逐步发展到大代数，然后进一步发展到抽象代数，目前正朝着泛代数的方向发展。本小节主要介绍抽象代数的由来及其基本知识结构。  
用计算机解决实际问题，一般需要对问题进行抽象并建立相应的数学模型，然后在此基础上将对实际问题的求解转化为对数学模型的求解。 因此，数学模型是用计算机解决实际问题的基础。现实问题纷繁复杂、变化万千，所建立的数学模型自然也是五花八门，多种多样，让人无所适从。值得欣慰的是，尽管我们面对的数学模型复杂多样，但从结构上看，所有这些数学模型都建立在四种基本的数学结构基础之上。  
这四种基本数学结构分别为：表示元素之间空间关系的拓扑结构，如图模型、树模型就是一些拓扑结构；表示元素之间运算关系的代数结构，如初等代数、向量代数、矩阵代数、命题代数、集合代数等都是代数结构；表示元素规模度量性质的测度结构，如高等数学里函数的微分和积分都是测度结构，它们主要计算面积、体积、弧长、速度等；表示元素之间次序关系的偏序结构，如整数的整除关系、集合的包含关系等偏序关系都是偏序结构。  
任何一个数学结构都是由载体、处理机制和处理规则这三个基本要素组成：  
（1）载体集合 对于任何一个数学结构，需要定义一些抽象的元素作为处理对象，这些抽象元素组成的集合构成数学结构的载体。载体集合是数学结构存在的基础或平台。  
（2）处理机制 为了实现对数学结构载体中元素的处理，需要定义一些处理机制，不同的数学结构具有不同的处理机制。例如：偏序结构是一种关系结构，它以元素之间的次序关系或者比较关系作为处理机制；代数结构是一种运算结构，它以元素之间的运算作为处理机制；拓扑结构是一种分布结构，它以元素之间的空间分布作为处理机制；测度结构则是一种度量结构，它以元素的规模度量作为处理机制。  
（3）处理规则 为使定义出来的数学结构满足一些合理性要求以及能够在处理实际问题中发挥作用，避免出现一些矛盾或荒诞的处理结果，还必须制定一些处理规则对处理机制做一些必要的限制。在现代数学的公理化系统中，通常称这些处理规则称为公理。不同的数学结构具有不同的处理规则，例如偏序结构限制元素之间的关系必须满足自反性、反对称性和传递性，这些限制或者性质构成了偏序结构公理系统；再如代数结构则是规定元素之间的运算必须满足结合律、交换律、分配律等运算性质。  
数学运算最早起源于算术运算，即使用具体的整数或分数进行四则运算。随着科学技术的不断发展，人们逐步意识到这种方法不能满足对一般性规律的认识。因此，采用抽象的字母来代替具体的整数和分数进行运算以获得通用性结果，并称之为代数运算或简称为代数。在微积分出现之前的数千年历史中，对代数运算的研究一直占据数学研究的核心地位。那时人们普遍信奉一种所谓的万能法则，即世界上所有问题都可以转化为数学问题，所有数学问题都可以转化为代数问题，所有代数问题都可以转化为方程问题。  
因此，在很长一段历史时期内，人们对数学的研究基本上都是对代数学的研究，对代数学的研究基本上是方程或方程组解法的研究。解方程是那个时期内所有数学家的中心任务，大家都非常期望能够通过使用代数运算的方法找到方程或方程组的通用求解公式。这种努力在线性方程组领域取得了非常完美的结果，并由初等代数逐步衍生出线性代数。但是，对于一元高次方程通用求解方法的研究并不是很顺利，对于次数高于四次的一元方程始终找不到通用求解公式或求解方法。一些非常著名的数学家，例如欧拉、高斯、拉格朗日等都对此做了大量非常艰苦的研究，但均告失败。  
在寻求五次方程通用求解方法的过程中，年仅17 岁的法国天才少年伽罗瓦在1828 年提出群的概念，运用群的思想证明了五次方程通用求解公式是不存在的，并给出了五次方程系数在满足一定条件下若干特殊解法，由此一举解决了困扰数学家长达200 多年的数学问题。伽罗瓦取得成功的关键在于不仅将运算对象进行抽象化，而且对运算本身进行抽象，在抽象对象和抽象运算的基础上通过构造一些特殊抽象代数结构进行求解。这个思想在当时实在过于超前以至于没有得到柯西、傅里叶、泊松等著名数学家的认可，泊松的判词是“完全不能理解”。 1832 年5 月31 日年仅21 岁的伽罗瓦死于决斗。在决斗之前，他把关于五次方程代数求解的研究成果写成长信，留给了人类。14 年后，法国数学家刘维尔整理并发表了伽罗瓦的遗作，人们才理解并惊叹他那超越时代的天才思想和巧妙构思。  
至此以后，人们对代数的研究内容由方程或方程组的求解技巧转变为对代数运算性质和运算结构的研究，通过对运算和运算对象进行抽象的方式实现对所有运算依其运算性质进行分类或归类，并将伽罗瓦的群论迅速发展成为一门称之为抽象代数结构的崭新数学分支。 抽象代数结构的诞生，把代数学从传统的初等代数发展到现代的抽象代数，由此打开了现代代数学的大门，开创了代数学研究的新纪元。因此，抽象代数结构通常也称为近世代数以区别于之前的初等代数。若无特别说明，我们通常将抽象代数结构简称为代数结构。  
经过一百多年的发展，抽象代数结构已经形成一个如图11-1 所示的知识体系。对于一个代数系统，我们不仅可以主动设计出它的运算并考察相应的运算规则，而且还可以通过分别对其载体集合进行相关改造或运算得到相应的子代数、积代数和商代数，可以通过映射的方式考察不同代数结构之间的区别与联系，还可根据运算性质对代数结构进行分类，形成若干典型抽象代数系统，如群、环、域、格等。  
![](images/37d476cf884c29ed65924bc021cb612de43bab4df8b1196f64e96cad4f61a01f.jpg)
图11-1 抽象代数结构的知识体系  
代数结构作为一种特殊的数学结构，具有载体、处理机制和处理规则这三个基本要素。如前所述，代数结构的载体就是由一些抽象对象为元素组成的集合，并通过运算机制实现对集合中元素的处理。所谓运算，其实就是通过映射的手段从已有元素中构造出新的元素。载体和运算统称为代数结构的成分。代数结构的处理规则即为运算性质。  
既然代数结构的载体是一个集合，那么就可以考虑通过一定方式由这个集合派生出新的集合并据此构造出新的代数结构。例如，可以考察其子集以及在子集上的运算，得到子代数的概念和性质；可以对作为载体的集合做笛卡尔集构成一个新的集合，并在新集合上定义相关运算，得到积代数的概念和性质；可以通过构造等价关系的方法实现对集合载体的划分，构成一个以等价类为元素的商集，并在这个商集上定义相关运算，得到商代数的概念和性质。子代数、积代数和商代数是构造和研究代数结构的基本方法论。  
当然，还可以考察两个代数结构之间的相似性与差异性。对于任意两个代数系统，可以在这两个代数结构的载体(集合)上建立一种保运算的映射，由此考察代数结构之间的联系。如果存在这种保运算映射，则称这两个代数系统同态。如果这种保运算的映射还是双射，则称这两个代数系统同构。同态和同构是考察代数结构之间联系的基本工具。  
依据代数结构的运算性质，可以将各种具体代数结构划分为若干抽象类型。典型的抽象代数结构类型主要有仅含一个二元运算的半群与群、含有两个二元运算的环与域，以及格与布尔代数。这些典型抽象代数结构构成代数结构知识体系的主要内容。"
商群,概念,"['第十二章 典型抽象代数结构', '§ 12.3 同余关系与商群']","{'实体类型': '概念', '定义': '由同余关系考察群的子群结构划分问题得到的概念', '相关内容': '包括同余关系与陪集、拉格朗日定理、正规子群与商群的基本知识'}",,2,我们知道，集合上的任何一个等价关系都对应该集合上的一个划分，反之亦然。但是，如果对该集合进行某种运算或映射，等价关系则不能保证其所对应的划分在运算或映射下保持不变，这给使用等价关系考察代数结构的研究带来困难。同余关系则是同一性介于相等关系与等价关系之间的一种特殊等价关系，能够保证其作为等价关系所对应划分在运算下保持不变。也就是说，同余关系其实就是能够保运算的一类特殊等价关系。因此，在代数结构的研究中，通常使用同余关系而不是一般等价关系来考察载体集合的划分问题。本节以同余关系为基本工具考察群的子群结构划分问题并由此得到商群的概念与性质，主要包括同余关系与陪集、拉格朗日定理、正规子群与商群的基本知识。
商集,概念,"['§ 6.1 等价关系与元素分类', '6.1.2 集合的划分与商集', '第六章 特殊关系模型']","{'实体类型': '概念', '相关概念': '等价关系', '定义': '等价关系所有等价类组成的集族', '特点': '构成集合的划分', '示例': '完全关系的商集是单元素集合，恒等关系的商集是单元素集合的集合', 'name': '商集'}",,2,等价关系，顾名思义就是表示相同、相等、平等、一致等含义的关系，刻画的是对象之间在某个方面的无差异性。可用等价关系将集合中元素进行分类，使得属于同一类的元素彼此之间具有等价关系，而分属不同类型的元素之间不具有等价关系。属于同一类的元素因其相互之间满足等价关系而可将它们看成是一些无差异的个体，进而将这些无差异个体抽象成一个个体或代表元，由此实现对集合的化简。目前，等价关系可以有效地实现对数据的抽象和化简，已在计算机及相关信息领域得到广泛应用。本节具体介绍等价关系的基本知识，主要包括等价关系与等价类的概念和性质、集合划分与商集的相关知识。
四色定理,定理,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.3.3 着色问题与算法', '二、平面图的着色问题']","{'实体类型': '定理', '内容': '连通简单平面图的色数不超过4', '证明': '1976年由阿佩尔和海肯通过计算机验证'}",,4,"如前所述，图的着色问题起源于对地图中每个国家领土的着色问题。例如，对于如图$10-$62 所示的地图，显然可以用4 种颜色对该地图中每个国家的领土进行标定。不难看出，该地图其实是一种连通无桥平面图，每个国家的领土范围对应于该平面图的一个面。因此，对地图中每个国家领土的着色问题，可转化为对这种特殊平面图中面的着色问题。  
![10-62 平面图的着色问题  ](images/0f1d899dc5071bbbd74c74607374e17794ff18cb387057f7c4c58b59ecbd991c.jpg)  
下面考察基于这种特殊平面图的面着色问题，首先给出面着色的相关定义：  
【定义10.13】连通无桥平面图及其所有有限面称为地图。地图中每有限面分别称为一个国家，若两个国家至少有一条公共边，则称这两个国家相邻。如果对给定地图$G$上每个国家涂上或标注一种颜色，使得相邻的国家具有不同的颜色，则称这种操作是对图$G$的面着色。若可用$k$种颜色就可完成对地图$G$的面着色，则称$G$是$k{-}$面可着色的。若$G$是$k{-}$面可着色的，但不是$(k-1){-}$面可着色的，则称$G$是${k}$-色地图，称$ k$为$G$的面色数，记为$\chi^{*}(G)$。  
事实上，对地图的面着色可以通过平面图的结点着色来研究。这是因为平面图$G$的对偶图$G^{*}$也是一个平面图，并且图$G$的每个面与图$G^{*}$的每个结点之间具有一一对应的关系。例如，对10-62（a）所示的面着色问题，可以转化为10-62（b）所示的结点着色问题。下面的定理10.22 揭示了作为地图的一种特殊平面图与其对偶图之间的色数关系：  
【定理10.22】地图$G$是$k^{-}$面可着色图，当且仅当它的对偶图$G^{*}$是$k^{-}$可着色图。  
【定理10.23】设$G=\langle V,E\rangle$是简单平面图，则$G$中至少存在一个度数不超过5 的结点。  
下面给出关于平面图结点着色的五色定理：  
【定理10.24】（五色定理）设$G=\langle V,E\rangle$是任意给定的一个连通简单平面图，则$G$的点色数为5。  
上述五色定理是数学家赫伍德在研究四色猜想时给出的一个重要结论，可以说是四色猜想研究历史上的一个重大突破。四色猜想是一个与哥德巴赫猜想、黎曼猜想同样著名的数学猜想。该猜想最初由英国青年佛朗西斯·格里斯在1852 年提出：  
四色猜想：连通简单平面图的色数不超过4。  
公元1852 年，毕业于英国伦敦大学并从事地图着色工作的佛朗西斯·格里斯，发现了一个奇怪的现象：无论多么复杂的地图，只要用四种颜色，就可以区分有公共边界的国家和地区。佛朗西斯觉得这中间一定有什么奥妙，便求教著名的英国数学家摩根。摩根对此苦苦思索了几个昼夜后还是不得其解，便写信给著名数学家哈密顿，希望哈密尔顿要么能证明这个问题，要么构造出一个需要五种或更多种颜色的图来。然而，智慧超人的哈密尔顿耗费了整整13 年心血，终于一筹莫展，抱恨逝去！  
哈密尔顿死后，又过了13 年，英国数学家凯莱在一次数学年会上把这个问题归纳为四色猜想，并于公元1879 年在英国皇家地理会刊的创刊号上，公开征求对四色猜想的解答。在征解消息发出的同年，一位半路出家的数学家肯普，发表了一个关于四色定理的证明。人们普遍以为四色猜想已经成为历史。不料过了11 年，即公元1890 年，一个名叫赫伍德的青年，指出了肯普在证明中的错误。与此同时，赫伍德匠心独运，利用肯普提供的方法，成功地证明了上述五色定理。由于存在不可3-着色的平面图$K_{4}$，故四色定理若得到证明，将是平面图色数问题的最佳结果。  
1976 年6 月，美国两位著名数学家阿佩尔和海肯通过计算机计算了1200 小时，通过数组计算的方法验证了四色猜想的正确性。据此，人们将四色猜想改名为四色定理。但是，四色定理并没有得到所以数学家的认可，因为目前还没理论上严谨的数学证明。"
四色猜想,猜想,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.3.3 着色问题与算法', '二、平面图的着色问题']","{'实体类型': '猜想', '内容': '连通简单平面图的色数不超过4'}",,4,"如前所述，图的着色问题起源于对地图中每个国家领土的着色问题。例如，对于如图$10-$62 所示的地图，显然可以用4 种颜色对该地图中每个国家的领土进行标定。不难看出，该地图其实是一种连通无桥平面图，每个国家的领土范围对应于该平面图的一个面。因此，对地图中每个国家领土的着色问题，可转化为对这种特殊平面图中面的着色问题。  
![10-62 平面图的着色问题  ](images/0f1d899dc5071bbbd74c74607374e17794ff18cb387057f7c4c58b59ecbd991c.jpg)  
下面考察基于这种特殊平面图的面着色问题，首先给出面着色的相关定义：  
【定义10.13】连通无桥平面图及其所有有限面称为地图。地图中每有限面分别称为一个国家，若两个国家至少有一条公共边，则称这两个国家相邻。如果对给定地图$G$上每个国家涂上或标注一种颜色，使得相邻的国家具有不同的颜色，则称这种操作是对图$G$的面着色。若可用$k$种颜色就可完成对地图$G$的面着色，则称$G$是$k{-}$面可着色的。若$G$是$k{-}$面可着色的，但不是$(k-1){-}$面可着色的，则称$G$是${k}$-色地图，称$ k$为$G$的面色数，记为$\chi^{*}(G)$。  
事实上，对地图的面着色可以通过平面图的结点着色来研究。这是因为平面图$G$的对偶图$G^{*}$也是一个平面图，并且图$G$的每个面与图$G^{*}$的每个结点之间具有一一对应的关系。例如，对10-62（a）所示的面着色问题，可以转化为10-62（b）所示的结点着色问题。下面的定理10.22 揭示了作为地图的一种特殊平面图与其对偶图之间的色数关系：  
【定理10.22】地图$G$是$k^{-}$面可着色图，当且仅当它的对偶图$G^{*}$是$k^{-}$可着色图。  
【定理10.23】设$G=\langle V,E\rangle$是简单平面图，则$G$中至少存在一个度数不超过5 的结点。  
下面给出关于平面图结点着色的五色定理：  
【定理10.24】（五色定理）设$G=\langle V,E\rangle$是任意给定的一个连通简单平面图，则$G$的点色数为5。  
上述五色定理是数学家赫伍德在研究四色猜想时给出的一个重要结论，可以说是四色猜想研究历史上的一个重大突破。四色猜想是一个与哥德巴赫猜想、黎曼猜想同样著名的数学猜想。该猜想最初由英国青年佛朗西斯·格里斯在1852 年提出：  
四色猜想：连通简单平面图的色数不超过4。  
公元1852 年，毕业于英国伦敦大学并从事地图着色工作的佛朗西斯·格里斯，发现了一个奇怪的现象：无论多么复杂的地图，只要用四种颜色，就可以区分有公共边界的国家和地区。佛朗西斯觉得这中间一定有什么奥妙，便求教著名的英国数学家摩根。摩根对此苦苦思索了几个昼夜后还是不得其解，便写信给著名数学家哈密顿，希望哈密尔顿要么能证明这个问题，要么构造出一个需要五种或更多种颜色的图来。然而，智慧超人的哈密尔顿耗费了整整13 年心血，终于一筹莫展，抱恨逝去！  
哈密尔顿死后，又过了13 年，英国数学家凯莱在一次数学年会上把这个问题归纳为四色猜想，并于公元1879 年在英国皇家地理会刊的创刊号上，公开征求对四色猜想的解答。在征解消息发出的同年，一位半路出家的数学家肯普，发表了一个关于四色定理的证明。人们普遍以为四色猜想已经成为历史。不料过了11 年，即公元1890 年，一个名叫赫伍德的青年，指出了肯普在证明中的错误。与此同时，赫伍德匠心独运，利用肯普提供的方法，成功地证明了上述五色定理。由于存在不可3-着色的平面图$K_{4}$，故四色定理若得到证明，将是平面图色数问题的最佳结果。  
1976 年6 月，美国两位著名数学家阿佩尔和海肯通过计算机计算了1200 小时，通过数组计算的方法验证了四色猜想的正确性。据此，人们将四色猜想改名为四色定理。但是，四色定理并没有得到所以数学家的认可，因为目前还没理论上严谨的数学证明。"
回溯,算法,"['第二章  整数与算法设计基础', '§ 2.4 算法设计策略与应用', '2.4.3  回溯与动态规划']","{'实体类型': '算法', '定义': '基于解空间搜索的方法', '基本思路': '对所有的解状态进行枚举，生成解空间或状态空间，通过在解空间中搜索获得所需要的解', '特点': '解空间有结构，以空间树的结构方式存在', '应用': '最短路线、库存管理、资源分配、设备更新、排序、装载等问题求解'}",,3,回溯是一种基于解空间搜索的方法。基本思路类似于蛮力法，首先对所有的解状态进行枚举，生成解空间或状态空间，然后通过在解空间中搜索获得所需要的解。与蛮力法不同的是，这里的解空间是有结构的，换句话说，解空间以空间树的结构方式存在，由此可以根据这种特殊结构设计出很多高效的搜索方法。动态规划策略则是把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，通过对单阶段问题的逐个求解，实现对整个问题的求解，多年来，回溯和动态规划策略在最短路线、库存管理、资源分配、设备更新、排序、装载等问题求解算法中得到广泛应用。
回溯与动态规划策略,算法,"['第二章  整数与算法设计基础', '§ 2.4 算法设计策略与应用']","{'实体类型': '算法', '应用': '算法设计的基本策略之一'}",,2,计算机问题求解算法虽然千差万别，但都遵循一些基本的设计策略。这些策略蕴含着很多非常深刻而又普适的求解智慧。例如，分治策略把一个问题分解为若干规模较小的子问题，然后以递归的方式求解它们并通过合并它们的解来实现对原问题的求解，而回溯策略则认为对未知世界的探索是一个试错的过程，并给出具体的试错方案，这恰恰是对人类生活经验的一种抽象和总结。不断学习、领会和掌握这些智慧，就可逐步形成良好的算法思维，从而能够更加透彻地从本质上理解算法设计的精髓，为设计出高水平算法打下坚实的基础。本章主要结合具体应用实例介绍和分析算法设计的若干基本策略，包括蛮力与贪心策略、递归与分治策略、回溯与动态规划策略。
回溯法,算法,"['第二章  整数与算法设计基础', '§ 2.4 算法设计策略与应用', '2.4.3  回溯与动态规划', '一、回溯策略']","{'实体类型': '算法', '定义': '一种选优搜索法，按选优条件向前搜索，以达到目标。当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”', '特点': '既有系统性又有跳跃性的搜索算法，基本思路是在包含问题所有解的空间树中，按照深度优先的策略，从根节点出发搜索解的空间树', '应用': '适合解决一些规模较大的问题', '解空间': '满足问题所有可能的解组成的集合，并且至少包含问题的一个（最优）解', '解向量': '可以表示成$_{,n}$元向量$(X_{1},X_{2},\\\\cdots,X_{n})$的形式，具有显性或隐性的约束条件', '步骤': '(1)定义问题的解空间；(2)确定解空间结构；(3)以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索'}",,4,"【定义2.23】回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。  
回溯法是一个既有系统性又有跳跃性的搜索算法，基本思路是在包含问题所有解的空间树中，按照深度优先的策略，从根节点出发搜索解的空间树。当算法搜索至某一节点时，先判断该节点是否包含问题的解，如果肯定不包含，则跳过以该节点为根的子树，逐层向其先前的节点回溯；否则，就进入该子树，继续按深度优先的策略进行搜索。回溯法的解空间为树结构，比较适合解决一些规模较大的问题。  
在用回溯法求解问题时，需要确定问题的解空间。所谓解空间，就是满足问题所有可能的解组成的集合，并且至少包含问题的一个（最优）解。  
由回溯法得到的解可以表示成$_{,n}$元向量$(X_{1},X_{2},\cdots,X_{n})$的形式。解向量一般具有显性或隐性的约束条件，在算法设计时，应该仔细分析，不能忽略。例如，当$n=3$ 时，0-1 背包问题可用一棵完全二叉树表示其解空间，如图2-14 所示。  
![](images/b415fb2b375de62d1f97720c41a6931e01b566d3978cde4ab5b4f6710e0bbacd.jpg)
图2-14  $n{=}3$ 时背包问题的解空间  
在作为解空间的树结构中，从第𝑖层到第$i{+}1$ 层边上的标号给出了变量$X_{i}$ 的值。从树根到叶的任一路径表示解的空间中的一个元素，即一个具体的解向量。例如，从根节点$A$ 到叶子节点$H$ 的路径相应于解空间中的元素（1,1,1）。  
回溯算法需要搜索整棵解空间树，当问题规模很大时，计算量比较大。此时可用剪枝的方法对搜索策略进行优化。  
【定义2.24】剪枝就是通过某种判断避免一些不必要的遍历过程，剪去解空间树中的一些不必要的枝条，从而缩小搜索规模。  
剪枝函数通常有两种策略，一是用约束函数在扩展节点处剪去不满足约束条件的子树，二是用限界函数剪去不能得到最优解的子树。对于限界函数，一般是添加一个全局变量记录当前最优解，在到达节点时计算该节点预期值并与当前最优解比较，若不好，则回溯。  
综上所述，回溯法解题一般包括三个基本步骤：(1)定义问题的解空间；(2)确定解空间结构；(3)以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。  
![](images/94c98789a7564cef4defce6c521572031ed59be149b82dc63805c35507db88a6.jpg)
图$2{\mathrm{-}}15\ 8{\times}8$ 棋盘"
回溯策略,算法,"['第二章  整数与算法设计基础', '§ 2.4 算法设计策略与应用']","{'实体类型': '算法', '定义': '对未知世界的探索是一个试错过程，给出具体试错方案', '特点': '对人类生活经验的抽象和总结'}",,2,计算机问题求解算法虽然千差万别，但都遵循一些基本的设计策略。这些策略蕴含着很多非常深刻而又普适的求解智慧。例如，分治策略把一个问题分解为若干规模较小的子问题，然后以递归的方式求解它们并通过合并它们的解来实现对原问题的求解，而回溯策略则认为对未知世界的探索是一个试错的过程，并给出具体的试错方案，这恰恰是对人类生活经验的一种抽象和总结。不断学习、领会和掌握这些智慧，就可逐步形成良好的算法思维，从而能够更加透彻地从本质上理解算法设计的精髓，为设计出高水平算法打下坚实的基础。本章主要结合具体应用实例介绍和分析算法设计的若干基本策略，包括蛮力与贪心策略、递归与分治策略、回溯与动态规划策略。
回路,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.1 通路的概念与计数']","{'实体类型': '概念', '定义': '起点等于终点的通路', '特点': '是通路的一种特殊类型', '分类': '简单回路、基本回路、复杂回路'}",,3,"前面我们讨论的图模型结构主要是图中结点与边的性质与联系，考察结点之间是否有边联结，换句话说，就是考察图中结点与结点之间的直接联系或直接关系。事实上，在很多情况下，图中结点之间的存在一些以其它一些中间结点为传递媒介的间接联系或间接关系。 例如，在现实世界中，常常考虑这样的问题：一个旅客如何乘高铁从一个城市经过若干个城市到达另一个目的地城市。 将这类问题进行抽象就成为如图8-28 所示图模型的问题，即如何从图中的一个给定结点开始，沿着多个边和结点连续移动到另一个指定的结点。  
![图8-28 部分城市高铁连接图  ](images/696b1dc16cae3150101fa23827543d58e80eb5b132e5b733a120daf06e5316d0.jpg)  
由以上分析可知，图模型中结点之间存在着经由多个边和多个结点的间接联系。对于存在间接联系的两个结点，可以从其中的一个结点出发，沿着作为其联系媒介的多个边和多个结点之间移动，就可达到另外一个结点。显然，这些边和结点构成了联结这两个结点的一个通路。由此得到图模型中通路的相关概念，具体定义如下：  
【定义8.21】设$G=\langle V,E\rangle$ 是任意给定的一个有向图或者无向图，$\boldsymbol{T}$为图$G$ 中顶点和边的相继交替出现的序列，即$\varGamma=v_{0}e_{1}v_{1}e_{2}v_{2}\ldots e_{k}v_{k}\,$。如果对于$i=1,2,\cdots,k$，均有${v_{i-1}}$ 和 $v_{i}$ 是 $e_{i}$ 的两个端点（当 $G$ 为有向图时，要求 $v_{i-1}$ 为 $e_{i}$ 的始点，${v}_{i}$ 为 $e_{i}$ 的终点），则称 $\varGamma$为结点 $v_{0}$ 到结点 $v_{k}$ 的一条通路，$v_{0}$ 和 $v_{l}$ 分别称为该通路的始点和终点，统称为通路的端点。通路$T$ 中所含边的数目 $k$称为$ T$ 的长度。当 $v_{0}=v_{k}$ 时，称该通路称为回路。  
![图8-29 图模型的通路  ](images/1d1c6154df6373d2cdb3faac71f53b624b61d1aa104aceed6cc19294e272f07e.jpg)  
例如，对于如图8-29 (a)所示的无向图，$v_{1}e_{1}v_{2}e_{2}v_{5}e_{6}v_{3}$便是一条通路$\Gamma$，$v_{1}$ 是该通路$\Gamma$的始点$v_{3}$ 是该通路$\Gamma$的终点$v_{1}$ 和 $v_{3}$ 都称为通路$\Gamma$的端点。其中通路$\Gamma$的长度为3。 特别地，对于通路$\ v_{1}e_{1}v_{2}e_{2}v_{5}e_{6}v_{3}e_{3}v_{1}$，则是回路。  
同样，对于如图8-29 (b)所示的有向图，$v_{1}e_{3}v_{2}e_{4}v_{5}e_{8}v_{4}e_{10}v_{3}e_{6}v_{6}$便是一条通路$\Gamma$，$v_{1}$ 是该通路$\Gamma$的始点，$v_{6}$ 是该通路$\Gamma$的终点，$v_{1}$ 和 $v_{6}$ 都称为通路$\Gamma$的端点。其中通路$\Gamma$的长度为5。 特别地，对于通路$\cdot v_{5}e_{9}v_{4}e_{10}v_{3}e_{5}v_{5}$，则是回路。  
在上述定义中，回路是一种特殊的通路，即起点等于终点的通路。但是，在习惯上我们所说的通路一般都不包含回路，也就是说不是回路的通路。因此，以后除非特别说明，我们所说的通路均是指不是回路的通路。  
下面定义通路和回路的各种类型：  
【定义8.22】设$G=\langle V,E\rangle$ 是任意给定的一个有向图或者无向图，$\boldsymbol{T}$为图$G$ 中分别以$v_{0}$和$v_{k}$为起点和终点的通路，即$\varGamma=v_{0}e_{1}v_{1}e_{2}v_{2}\ldots e_{k}v_{k}$，则有：  
（1）若 $\Gamma$ 中所有边各异，则称 $\Gamma$为简单通路或简单路径；若 $$\Gamma$$ 中所有边各异且$\boldsymbol{v}_{0}=$$\boldsymbol{v}_{k}$ 时，称 $$\Gamma$$为简单回路。  
（2）若 $\Gamma$中除 $v_{0},v_{k}$ 以外的所有结点各异（从而所有边也各异），则称 $$\Gamma$$  为基本通路或者基本路径。若 $v_{0}=v_{k}$ 且除 $v_{0},v_{k}$ 以外的所有结点各异，则称 $$\Gamma$$  为基本回路或者圈。  
（3）若 $\Gamma$  中有边重复出现，则称其为复杂通路，若还有 $v_{0}=v_{k}$ ，则称其为复杂回路。  
显然，基本通路必定是简单通路，基本回路必定是简单回路，反之不然。  
![图8-30 例图8.17 图模型  ](images/dd241eacc3384b3e855e4a8d2722d1e202b87f4bc0f4c935a9dc90df2ad5dde3.jpg)  
![图8-31 例8-18 图模型](images/9bbcb6a24cd69b076108d52999957fe02f755ca4cbb4868bf787f729d7371e2f.jpg)  
类似地，不难发现邻接矩阵𝐴的 $m$次方幂$A^{m}$在图模型中表示的含义。具体地说，就是$A^{m}$中元素$a_{i j}^{(m)}$的含义就是图中从$\boldsymbol{v}_{i}$出发到$v_{j}$且长度为$m$的路径数目。由此得到如下关于图模型中路径计数的基本定理：  
【定理8.2】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或者无向线图，并且其结点集合为  
$V=\{v_{1},v_{2},\ldots,v_{n}\}$，矩阵$A=(a_{i j})_{n\times n}$是图 $G$ 的邻接矩阵，则对于$A$的$m$次幂$A^{m}=$$({a_{i j}}^{})_{n\times n},m=1,2,\cdots,n,$，其元素 ${a_{i j}}^{(m)}$ 表示从结点 $v_{i}$ 到 $v_{j}$ 且长度为 $m$ 的通路数目；  
${a_{i i}}^{(m)}$表示从结点 $v_{i}$ 到其自身长度为 $m$ 的回路数目；$\begin{array}{r}{\sum_{i=1}^{n}\sum_{j=1}^{n}{a_{i j}}^{(m)}}\end{array}$为图G中长度为 $m$ 的通路（包括回路）总数。  
根据以上分析和讨论，我们可以得出这样的结论：对于任意一个有向或者无向的线图，都根据其邻接矩阵的方幂运算获得任意两个结点在任意指定长度下的通路和回路的数目。因此，关于线图模型的通路计数问题得到了很好的解决。"
图同构,概念,"['8.2.3 图同构及其判定', '第八章  图的基本理论与算法', '§ 8.2 图的运算与结构']","{'实体类型': '概念', '定义': ""两个图模型在结构上的等价关系，假设G和G'是任意给定的两个简单无向图或有向图，若存在双射函数g: V -> V'，使得G与G'之间具有同构关系，简称为G与G'同构，记为G ≅ G'。此时，映射g: V -> V'称为G与G'之间同构映射。"", '判定方法': '通过图同构映射的机制考察和处理，寻找同构图之间的不变量，例如结点数相同、边数相同、度数相同的结点个数相同、同构映射对应点的度相同、同构映射对应点的所有邻接点分别具有相同的度等。', '特点': '同构的图模型具有完全相同的结构性质，两个图模型的结点之间存在一种双射关系，图的结构在这种双射关系下保持不变。', '性质': '满足自反性、对称性和传递性，因而是一种等价关系。', '应用': '可以根据图的同构关系对图进行分类，将彼此同构的图模型归为一类。', '现状': '到目前为止，还没有找到判定两个图是否同构的有效方法，只能对一些简单图根据定义进行判别。', 'name': '图同构'}",,2,本节在前述图模型基本概念基础上介绍关于图模型处理的基本知识和方法，包括图模型的集合运算、图模型的度结构性质、图同构的概念及判定方法。对于图模型，可对其定义一些相关运算与操作产生新的图模型并据此实现对问题的分析和求解。此外，结构性质是对图模型进行理解和处理的基本依据，图中结点与边之间显然存在一些基本约束，例如一条边关联且仅关联两个结点，这些约束使得图模型在结构上必须满足一定数量关系，如握手定理，它们构成了图模型最基本的结构性质。最后，本节通过图同构映射的机制考察和处理两个图模型之间在结构上等价关系，同构的图模型具有完全相同的结构性质。
图形表示法,方法,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.3 图的表示方法']","{'实体类型': '方法', '特点': '形象直观，但结点和边数目较大时不方便甚至不可行'}",,3,"如前所述，图模型其实就是一种特殊的二元关系。因此，图模型作为一种二元关系，一般来说具有三种基本的表示方法，即集合表示法、图形表示法和矩阵表示法。对于一个图模型G，若将其记为 $G=\langle V,E\rangle$ ，并枚举集合 $V$ 和 $E$ 中所有元素，则称这种表示方法为图的集合表示法。若画出$G$ 的图形，用小圆圈表示 $V$中的结点，用由 $u$ 指向 $v$ 的有向线段或曲线表示有向边 $\langle u,v\rangle$ ，无向线段或曲线表示无向边 $(\mathrm{u},\mathrm{v})$ ，则称该方法为图的图形表示法。  
![图8-8 图模型G的图形表示法 ](images/42c40d1dbd600657cf3b9d4593b6b7c38007adbf1cf3dec9952b6b75bb10d397.jpg)  
对于图8-8 所示的图$G$ ，可用集合为 $G=\langle V,E\rangle$ ，其顶点集 $V=\{v_{1},v_{2},v_{3},v_{4}\}$，其边集$E=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{2},v_{3}\rangle,\langle v_{2},v_{4}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$ 。 若用图形表示，则其本身就是图形表示。  
集合表示法比较精确，但抽象且不易理解；图形表示法形象直观，但是当图中的结点和边的数目较大时，这种表示法很不方便甚至不可行。事实上，可以通过矩阵将图模型的逻辑结构转变成可在计算机中存储和运算的形式，并可设计一定的存储结构满足计算机处理的需要。因此，计算机系统通常使用矩阵实现对图的表示和处理。本节着重介绍图的矩阵表示法，具体包括邻接矩阵表示法、关联矩阵表示法、邻接表表示法等几种类型。"
图模型,概念,"['8.1.3 图的表示方法', '第十章  特殊图模型与算法', '§ 8.1 图的概念与表示', '8.1.2 图的定义与分类', '8.5.3 机器学习问题', '§ 8.5 图模型的应用', '8.5.1 交通灯相位问题', '第八章  图的基本理论与算法']","{'实体类型': '概念', '定义': ['由结点和边组成的离散结构，用点表示事物、点之间连线表示事物之间联系的模型', '由非空有限集合V和有限多重集E组成的二元组G=<V,E>称为图模型，简称为图', '一种特殊的二元关系', '实现了形象思维与抽象思维的完美结合的数学模型和工具'], '应用': ['解决实际问题如路径规划、资源分配、图着色、最小费用流等', '解决游戏问题、计算机网络问题等', '广泛用于对现实问题的建模和求解', '解决计算机网络路由问题、送快递的最短路径问题、网站之间的链接模型问题、工程预算的关键路径问题、软件代码复杂度计算问题等复杂问题', '解决交通灯相位问题', '用于浅层学习和深度学习中的模型结构'], '特点': ['需要设计特定图模型进行建模与求解，诠释复杂的多对多关系，揭示结点之间的网状拓扑结构，只考虑点和线之间的结构信息，不考虑位置信息', '用于表示一组对象以及这组对象之间的某种二元关系'], '分类': '无向图、有向图、混合图、多重图、线图、简单图、赋权图、无权图', '表示方法': '集合表示法、图形表示法、矩阵表示法', '作用': '发挥至关重要、不可替代的作用', '例子': 'BP神经网络模型、支持向量机模型'}",,1,"如前所述，图模型及其理论是数学家欧拉为解决哥尼斯堡七桥遍历问题而创立。事实上，图模型作为一种由结点和边组成的离散结构是一种非常强大的离散建模工具，除了能够解决哥尼斯堡七桥遍历问题之外，还可解决很多其它实际问题。例如，旅游的路径规划问题、资源分配与匹配问题、图的着色与并行流程的设计问题、最小费用流问题等等。针对不同的问题，通常需要设计出特定的图模型进行建模与求解。例如，解决哥尼斯堡七桥遍历问题需要使用欧拉图及相关理论、解决旅游的路径规划问题需要哈密顿图及相关理论、解决资源分配与匹配问题需要二分图及相关理论、解决图的着色与并行流程的设计问题需要平面图的相关理论、解决最小费用流问题需要网络流图的相关理论等等。由此产生很多种具有特殊结构和性质的图模型，每种特殊图模型都能针对性地有效地解决某一类或某几类特定问题。因此，要想高效合理地使用图模型实现对实际问题的建模与求解，除了掌握前述图模型的一般理论及算法之外，还需要进一步掌握多种特殊图模型的相关理论及算法。  
本章介绍几种重要的特殊图模型及相关算法，包括欧拉图模型的基本理论及边的遍历算法、哈密顿图的基本理论及结点的近似遍历算法、二分图模型的基本理论及匈牙利匹配构造算法、平面图的基本理论及着色算法、网络流图的基本理论及最大流算法，并结合具体实例分析和讨论这些特殊图模型的应用方法。"
图模型度结构性质,性质,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构']","{'实体类型': '性质', '定义': '图中结点与边之间的基本约束和数量关系', '特点': '构成图模型最基本的结构性质'}",,2,本节在前述图模型基本概念基础上介绍关于图模型处理的基本知识和方法，包括图模型的集合运算、图模型的度结构性质、图同构的概念及判定方法。对于图模型，可对其定义一些相关运算与操作产生新的图模型并据此实现对问题的分析和求解。此外，结构性质是对图模型进行理解和处理的基本依据，图中结点与边之间显然存在一些基本约束，例如一条边关联且仅关联两个结点，这些约束使得图模型在结构上必须满足一定数量关系，如握手定理，它们构成了图模型最基本的结构性质。最后，本节通过图同构映射的机制考察和处理两个图模型之间在结构上等价关系，同构的图模型具有完全相同的结构性质。
图模型集合运算,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构']","{'实体类型': '概念', '定义': '对图模型进行的相关运算与操作', '应用': '产生新的图模型，实现对问题的分析和求解'}",,2,本节在前述图模型基本概念基础上介绍关于图模型处理的基本知识和方法，包括图模型的集合运算、图模型的度结构性质、图同构的概念及判定方法。对于图模型，可对其定义一些相关运算与操作产生新的图模型并据此实现对问题的分析和求解。此外，结构性质是对图模型进行理解和处理的基本依据，图中结点与边之间显然存在一些基本约束，例如一条边关联且仅关联两个结点，这些约束使得图模型在结构上必须满足一定数量关系，如握手定理，它们构成了图模型最基本的结构性质。最后，本节通过图同构映射的机制考察和处理两个图模型之间在结构上等价关系，同构的图模型具有完全相同的结构性质。
图的基本运算,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.2.1 图的基本运算', '二、图结构修改运算']","{'实体类型': '概念', '定义': '对图的结构进行化简或修改的运算', '应用': '根据实际问题的需要对图的结构进行修改', '特点': '包括添加或删除边、合并结点、删除结点等操作'}",,4,"对于一个给定的图模型，有时会根据实际问题的需要对图的结构进行化简或修改，主要是添加或者删除图中的某个或某些边、将图中两个结点进行合并、删除图中的某个或某些结点等，由此得到如下四个常用的图结构修改运算或操作，即：边的添加运算（也称为加新边运算）、边的删除运算、边的收缩运算以及结点的删除运算。其具体定义如下：  
【定义8.12】设图 $G=\langle V,E\rangle$是一个任意给定的图模型（有向图或无向图），则$G=\langle V,E\rangle$的四个常用图结构修改运算定义如下：  
（1）加新边运算：设$u,v$是 图$G=\langle V,E\rangle$的任意两个结点，即 $u,v\in V$，将这两个结点构成的边$e$边添加到图 $G$ 的边集$E$中构成一个新图$G^{\prime}=\langle V,E\cup\{e\}\rangle$。  
（2）边的删除运算：设$e$是图$G=\langle V,E\rangle$的任意一条边，即 $e\in E$ ，从 $G$ 中删除边 $e$ 得到一个新图$G^{\prime}=\langle V,E-\{e\}\rangle$，记为 $G-e$ ；又$E^{\prime}$是图$G$中若干边组成的集合，即$E^{\prime}\subseteq E$从 $G$ 中删除 $\mathrm{E^{\prime}}$中所有边得到一个新图$G^{\prime}=\langle V,E-E^{\prime}\rangle$，记为 $G-E^{\prime}$ 。  
（3）边的收缩运算：设$.e$是图$G=\langle V,E\rangle$的任意一条边且该边关联的两个结点为$u,v$，从图中删除边$e$并将该边的两个端点$u,v$合并成一个新的结点$w$，使得结点$w$关联除$e$以外的$u$和$v$所关联的一切边，得到一个新图$G^{\prime}$，记为$G\backslash{\mathbf{e}}$  
（4）结点的删除运算：设$_v$是 图$G=\langle V,E\rangle$的任意一个结点，即 $v\in V$，从 $G$ 中删除 $v$及与𝑣相关联的所有边，得到一个新图$G^{\prime}$，记为 $G-v$，又设 $V^{\prime}\subseteq V$ ，从 $G$ 中删除 $V^{\prime}$中所有顶点及与这些顶点关联的所有边，得到一个新图$G^{\prime}$，记为 $G-V^{\prime}$。  
从上述定义可以看出，要删除边，则直接在图中将改变去掉即可；要删除结点，在去掉该结点的同时，还要去掉该结点关联的所有边；边的收缩实际上就是将改变的长度变为0，使其两个端点重叠，用一个新的结点𝑤代替，其它边不变，即$w$关联该边的两个端点关联的除该边外的一切边，不过，需要注意的是，边的收缩可能会产生自环或平行边；所谓加新边运算，就是在图中的两个结点之间直接拉一条边。"
图的概念,概念,"['8.1.3 图的表示方法', '§ 8.1 图的概念与表示', '三、邻接表表示法', '二、关联矩阵表示法', '第八章  图的基本理论与算法']","{'实体类型': '概念', '内容': '包括图的由来、基本概念以及表示方法', '定义': ['研究图中结点与边之间的相关关系', '图模型G由顶点集V和边集E组成'], 'name': '图的概念'}",,2,前述关系理论涉及一种称之为图的几何模型，如关系图、哈斯图等。这种图模型由一些点和连接两点的线组成，主要用于表示事物之间一对多、多对多的复杂关系。与传统几何模型不同，对于图模型，我们感兴趣的只是其中有多少个点以及哪些点之间有线连接，至于线的长短曲直以及点的位置都无关紧要，即只考虑点和线之间的结构信息，不考虑点和线之间的位置信息。图模型作为对离散对象及其联系的一种直观抽象表示形式，广泛用于对现实问题的建模和求解。本节主要介绍图模型的由来、基本概念以及表示方法。
图的着色问题,问题,"['第八章  图的基本理论与算法', '§ 8.5 图模型的应用', '8.5.1 交通灯相位问题']","{'实体类型': '问题', '应用': '解决交通灯相位问题、空调管道设计问题、考试安排问题、排课表问题'}",,3,"现实生活中，为了避免不同方向交通流之间的相互冲突，可以通过在时间上给各个方向交通流分配相应的通行权。例如，为了放行东西向的直行车流且同时避免南北向的直行、左转车流与其发生冲突，可以通过启亮东西向的绿色直行箭头灯将路口的通行权赋予东西向的直行车流，启亮南北向的红灯消除南北向直行、左转车流对东西向直行车流通行的影响。  
对于一组互不冲突的交通流同时获得通行权所对应的信号显示状态，我们将其称之为信号相位，简称为相位。可以看出，交通灯信号相位是根据交叉口通行权在一个周期内的更迭来划分的。一个红绿灯信号控制方案在一个周期内有几个信号相位。图8-65 所示就是一个采用4 相位信号控制的控制方案。一个路口采用几相位的信号控制应由该路口的实际交通流状况决定，十字路口通常采用2 到4 个相位。如果相位数设计的太少，则不能有效的分配好路口通行权，路口很容易出现交通混乱，交通安全下降；如果相位数设计的太多，虽然路口的交通次序与安全性得到了改善，但由于相位之间进行转换时都会损失一部分通行时间，过多的相位数会导致路口的通行能力下降，延长司机在路口的等待时间。  
因此合理地设置交通灯相位数目，对于改善道路交通状况，有着非常重要的现实意义。那么如何去设置交通灯相位数目呢？其实交通灯相位问题，可以看成是图的着色问题，因而运用图论相关知识，可以有效地解决这一问题。关于图的着色问题，本书第十章-特殊图部分将会详细介绍，本小节不在赘述。另外，图的着色问题在实际生活中应用十分广泛，比如空调管道设计问题、考试安排问题、排课表问题等，有兴趣的读者可以作进一步了解。  
![图8-65  交通灯相位 ](images/0ec4bd3e4d43385c2caf5ee668ee55d5cf1941926e063b0c9b7c9bdaa556d346.jpg)"
图的表示方法,概念,"['8.1.3 图的表示方法', '§ 8.1 图的概念与表示', '三、邻接表表示法', '二、关联矩阵表示法', '第八章  图的基本理论与算法']","{'实体类型': '概念', '定义': '用关联矩阵表示图中每个结点与每条边之间的相关关系', '特点': '用于表示图模型的不同方式', '应用条件': '边数多时使用邻接矩阵和关联矩阵，边数少时使用邻接表'}",,4,"除了邻接矩阵外，还可以用关联矩阵表示图。关联矩阵主要表示图中每个结点与每条边之间的相关关系。对于任意给定的一个图模型$G$，其关联矩阵$M(G)$中元素$m_{i j}$的含义是图中结点$v_{i}$是否关联边$e_{j}$，如果$v_{i}$不关联$e_{j}$，则$m_{i j}=0$，如果$v_{i}$关联$e_{j}$，则用某个非零数字表示$m_{i j}$，具体数字依据图模型的类型和点边关联方式确定。  
与邻接矩阵一样，要确定一个图的关联矩阵，首先应对图中的所有结点进行编号，不同的结点编号对应于不同的关联矩阵，结点编号次序的交换对应于关联矩阵中行的交换。  
首先给出无向图关联矩阵的定义：  
【定义8.8】设$G=\langle V,E\rangle$是无向图 ，其中$\ V=\{v_{1},v_{2},\ldots,v_{n}\}$，$E=\{e_{1},e_{2},\dots,e_{m}\}$ ，则将$n\times m$阶矩阵$(m_{i j})_{n\times m}$称为 $G$ 的关联矩阵，记为 $M(G)$ 。其中元素$m_{i j}$ 表示图中结点 $v_{i}$ 与边 $e_{j}$ 的关联次数，具体定义如下：
$$
m_{ij}=\begin{cases}2,v_i的自环是e_j\\[2ex]1,v_i关联e_j且e_j不是自环\\[2ex]0,v_{i}不关联e_{j}\end{cases}
(i=1,2,\cdots,n,\quad j=1,\:2,\:...,\:m)(8-2)
$$  
从上述定义可以看出，无向图的关联矩阵用数字2 表示结点与边的自环关系，因为自环须与其关联结点关联 2  次。  
下面给出有向图关联矩阵的定义：  
【定义8.9】设 $D=\langle V,E\rangle$是有向图，其中 $V=\{v_{1},v_{2},\ldots,v_{n}\}$ ，$E=\{e_{1},e_{2},\dots,e_{m}\}$ ，则将${}n\times m$阶矩阵$(m_{i j})_{n\times m}$称为有向图 $D$ 的关联矩阵，记作 $M(D)$ 。 其中元素 $m_{i j}$ 表示图中结点 $v_{i}$ 与边 $e_{j}$ 的关联情况，具体定义如下：  
$$
m_{ij}=\begin{cases}-2,&v_i\text{为其关联自环}e_j\text{的起点和终点}\\1,&v_i\text{为其关联边}e_j\text{的起点但不是终点}\\-1,&v_i\text{为其关联边}e_j\text{的终点但不是起点}\\0,&v_i\text{不关联边}e_j\end{cases}
$$  
从上述定义可以看出，有向图的关联矩阵用数字−2表示结点与边的自环关系。事实上，有时候也可以用2 表示。因为有向图的自环是有方向的，即顺时针或逆时针方向。习惯上，用正数表示逆时针方向，负数表示顺时针方向。图中的自环默认为顺时针方向，故一般用−2表示结点与边的自环关系。  
对于无向图及其关联矩阵，由于每条非自环边关联2 个结点，故矩阵中每列元素之和必为2。而对于有向图及其关联矩阵，由于每条非自环有向边关联2 个结点，且一个为起点一个为终点，故图中每个非自环边在关联矩阵中所对应列元素之和必为0。  
因此，可以通过分析关联矩阵的数据特征分析来分析图中结点与边之间的结构信息。例如，对于任意一个关联矩阵，如果某行元素全为零，当且仅当该行所对应的结点为孤立结点。 再如，如果第 $j$列与第 $k$列相同，当且仅当 $e_{j}$ 与 $e_{k}$ 是平行边，或者说重边对应的列完全相同。 后面将经常使用关联矩阵分析图模型的各种结构特征。"
图的连通性,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.3  无向图的连通性']","{'实体类型': '概念', '定义': '描述图中任意两个结点之间是否可以通过一条或多条通路进行联结', '特点': '无向图中两个结点之间的连通性是双向的，满足对称性'}",,3,"前面我们学习了图的可达性概念及其判定，其描述的是图中两个结点之间是否可以通过一条或者多条通路进行联结，并从图的局部角度分别考察两个结点之间的连通关系。现在我  
们从全局性角度考察整个图中多个结点之间的连通关系，将两个结点之间的可达性概念推广到整个图中任意两个结点之间的可达性，由此得到图的连通性和连通图的相关概念。  
在图的连通性方面，无向图和有向图之间具有很大的差异。因此，我们分别讨论无向图和有向图的连通性。本小节主要介绍和讨论无向图连通性的概念与性质。首先给出无向图连通图的相关概念，具体定义如下：  
【定义8.25】设 $G=\langle V,E\rangle$ 为任一给定的无向图，对于图中的两个结点$v_{i}$ 与 $v_{j}$，如果从$\boldsymbol{v}_{i}$到$v_{j}$是可达的，则称从 $v_{i}$ 到 $v_{j}$是连通的，表示为[ $v_{i}\ \ ,v_{j}]$。规定图中任何结点与其自身是连通的。如果无向图$G$中任何两个结点之间都是连通的，则称该图为无向连通图或连通无向图，简称为连通图；否则，称$G$ 是非连通无向图，简称为非连通图。  
显然，无向图中两个结点之间的连通性是双向的，也就是说两结点之间的连通关系满足对称性，即：若有$v_{i}$ 到 $v_{j}$可达则必有$v_{j}$ 到 $v_{i}$可达。故在无向图中，也可将从${v}_{i}$ 到 $v_{j}$的连通说成$v_{i}$ 与 $v_{j}$连通。另外，注意到平凡图有且只有一个结点，根据无向图中结点连通性的规定，它是一种特殊的连通图。  
下面的定理表明，无向图模型中结点之间的连通性关系是一个等价关系：  
【定理8.7】设 $G=\langle V,E\rangle$ 为任一给定的无向图，其结点集为 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，令$R$ 是集合$\cdot V=\{v_{1},v_{2},\ldots,v_{n}\}$上结点之间的连通关系，即有：  
$R=\{\langle u,v\rangle|u,v\in V\}$, 且从$u$到𝑣连通}       （8-10）  
则$R$是集合𝑉上的一个等价关系。  
既然无向图模型中结点之间的连通性关系$R$是一个等价关系，那么就可以使用等价关系$R$ 将无向图 $G$ 的结点集合 𝑉 划分为若干互不相同的等价类，记为   $V_{1},V_{2},\ldots,V_{k}$ 。在这些等价类 中，相互连通的结点属于同一个等价类，不连通的结点属于不同的等价类。由此得到无向图模型的连通分支的概念，具体定义如下：  
【定义8.26】设 $G=\langle V,E\rangle$ 为任一给定的无向图$R$是图$G$结点集合𝑉上的连通性关系，则以关系𝑅的每个等价类为结点集的导出子图都称为图$G$的一个连通分支，并用$p(\mathbf G)$表示图𝐺的连通分支总数。  
由上述定义可知，如果无向图$G=\langle V,E\rangle$的结点连通性关系$R$作为一个等价关系，将结点集𝑉划分为$k$个不同的等价类$V_{1},V_{2},\ldots,V_{k}$，则由它们导出的子图$G(V_{1}),G(V_{2}),\cdots,G(V_{k})$均为图$G$的连通分支。因此，可以根据无向图中结点之间的连通关系实现对图模型的一个分解。显然，若   $p(G)=1$ ，则 $G$ 是连通图。若   $p(G)>1$ ，则   $G$ 是非连通图。  
【定义8.27】对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在结点集𝑉的某个子集 $V^{\prime}\subseteq$$V$ ，使得 $p(G-V^{\prime})>p(G)$ ，且对于 $V^{\prime}$的任何真子集 $V^{\prime\prime}$，有 $p(G-V^{\prime\prime})=p(G)$，则称 $V^{\prime}$为 $G$ 的点割集。如果点割集中只有一个结点 $v$ ，则称 $v$ 为割点。  
由上述定义可知，可通过删除图中适当结点以破坏图结构的方式考察图的连通程度。图中有些结点组成的集合在图的连通性中起着非常关键的作用，删除这些结点后会使得连通图变成非连通图，使得非连通图变得更加不连通，或者增加连通分支的数目。  
显然，对图中的任意一个点割集，该集合中所有结点都是由该点割集增加连通分支时必须同时删除的结点。例如在图8-40 所示的图$G_{1}$中，集合$\{v_{4}\},\{v_{1},v_{3}\}$都是点割集，但$\{v_{1},v_{3},v_{4}\}$则不是点割集，因为要增加图$G_{1}$的连通分支，不必同时删除结点$v_{1},v_{3},v_{4}$。  
需要注意的是，由于删除割点后，割点的邻接边也需要删除，因此我们用虚线表示已删除的边或者结点。同样，对下文所要介绍的边割集也做类似处理。  
同样，可以通过删除图中适当的边以破坏图结构的方式考察图模型的连通程度，由此可以得到边割集的相关概念，具体定义如下：  
【定义8.28】 对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在边集$E$的某个子集 $E^{\prime}\subseteq$$E$ ，使得 $p(G-\ E^{\prime})>p(G)$ ，且对于 $E^{\prime}$的任何真子集 $E^{\prime\prime}$，有 $p(G-\ E^{\prime\prime})=p(G)$，则称$V^{\prime}$为 $G$ 的边割集。如果点割集中只有一个条边  $e$ ，则称 $e$为割边或桥。  
![图8-42 例题8.24 图模型  ](images/6c126be3977ab4a2c63afc18255dc22be84fa010ee39891af7c0eba551970203.jpg)  
关于点割集与边割集，需要注意以下几个要点：  
（1）完全图 $K_{n}$ 无点割集，因为从 $K_{n}$ 中删除 $k\leq n-1$个顶点后，所得图仍然是连通的。  
（2）$n$ 阶零图既无点割集也无边割集。  
（3）对于连通图 $G$，$E^{\prime}$为 $G$ 的边割集，则必有 $p(G-E^{\prime})=2$ 。 因为删除一条边最多只能增加一个连通分支。  
（4）对于连通图 $G\ \ ,V^{\prime}$为 $G$ 的点割集，则 $p(G-V^{\prime})\geq2$，而且可能 $p(G-E^{\prime})>2$因为删除一个结点可能增加多个连通分支。  
从上述例题可以看出，对于任意给定的一个无向连通图，经常会有多个点割集或边割集，而且每个集合中所含元素的个数也不一样。此时，需要重点关注的应该是那些个数最小的集合。因为这些集合刻画了图连通结构中最为薄弱的环节，反映了连通图的最低连通程度。由此得到无向图连通图的点连通度与边连通度的概念，具体定义如下：  
【定义8.29】对于任意给定的一个无向连通图 $G=\langle V,E\rangle$，令：$\kappa(G){=}m i n\{|V^{\prime}||V^{\prime}$为G 的点割集}；$\lambda(\mathbf{G})=\operatorname*{min}\{|E^{\prime}||E^{\prime}$为G 的边割集} 并称 $\kappa(G)$ 为图 $G$ 的点连通度，$\lambda(G)$ 为图 $G$ 的边连通度。  
显然，点连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少结点数，边连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少边数。  
例如，对于图8-44 所示的无向连通图$G$ ，有$\kappa(G)=2$，$\lambda(G)=3$；对于图8-45 所示的彼得森图，有$\kappa(G)=\lambda(G)=3$。  
![图8-44 图的连通度  ](images/28f9ee3f26ab71faac7e5360d73417062a5a59d8421071b9feb627483727c42a.jpg)  
![图8-45  彼得森图  ](images/80ddd389b19bdc8904c989e51a73f2c183cb8c6f73b8b9c479ee3affcb66c7c0.jpg)  
关于无向连通图的点连通度$\kappa(G)$和边连通度$\lambda(\mathrm{G})$，需要注意以下几个要点：  
（1）如果 $G$是平凡图或非连通图，则规定 $\kappa(G)=\lambda(G)=0;$  
（2）如果$G$ 是完全图 $K_{n}$ ，由于 $G$ 中无点割集，当删除 $n-1$个顶点后，$G$ 为平凡图，故 $\kappa(G)=n-1$。  
（3）如果 $G$ 中存在割点，则 $\kappa(G)=1$；如果 $G$ 中存在割边，则 $\lambda(G)=1$。对于任何无向图 $G$ ，其点连通度 $\kappa$ 、边连通度 $\lambda$ 与结点最小度 δ 之间有如下关系：  
【定理8.8】对于任一无向图$G=\langle V,E\rangle$ ，均成立下列不等式：
$$
\kappa(G)\leq\lambda(G)\leq\delta\ (G)
$$"
图的遍历,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.4.1  深度优先搜索']","{'实体类型': '概念', '定义': '从图中的任一结点出发，按照一定的搜索方式对图中的所有结点进行访问，每个结点访问一次且仅一次', '特点': '是关于图的一种最基本的操作，图的许多其他操作都是建立在图的遍历基础之上'}",,3,"图的遍历是指从图中的任一结点出发，按照一定的搜索方式对图中的所有结点进行访问，每个结点访问一次且仅一次。图的遍历是关于图的一种最基本的操作，图的许多其他操作都是建立在图的遍历基础之上。一般来讲，根据搜索路径的不同，图的遍历算法有两种基本类型，即深度优先搜索遍历和广度优先搜索遍历。  
深度优先搜索是按照深度方向进行搜索，对于一个给定的连通图$G=\langle V,E\rangle$，首先确定一个遍历的出发点$v_{i}$ ,将其标记为已访问之后，再次选择与点$v_{i}$相邻并且尚未访问过的结点$v_{j}$作为新的遍历；同样地，标记$v_{j}$为已访问之后，再次选择与点$v_{j}$相邻并且尚未访问过的新结点$v_{k}$作为遍历点，以此类推，直到图中所有的结点全部被访问，搜索过程完成为止。  
如果在遍历过程中，遇到了与当前遍历点相邻但已访问的结点，则直接跳过该点，再次选择匹配与当前遍历点相邻的其他点，直到找到未被访问的点进行下一次的深度遍历为止，在此过程中，如果已搜索完与当前遍历点所有的邻接点都没有找到未被访问的结点，则此层遍历结束，算法返回上一层遍历点继续深度搜索，以此类推，直到搜索过程完成为止。这个过程称为连通图的深度优先搜索，简称为 DFS。  
上述算法讲述了对于连通图$G=(V,E)$的深度优先遍历过程，下面对其进行整理并拓广为非连通图的情况下的算法整理如下：  
（1）首先确定一个出发点$v_{i}$，访问并将其标记为已访问。  
（2）找出与结点$v_{i}$相邻且未被访问的邻接点$v_{j}$，访问并标记其为已访问，再以$v_{j}$作为当前遍历点继续访问与$v_{j}$相邻切未被访问的邻接点。递归重复本过程，直到当前遍历点的所有邻接点都被访问为止。  
（3）返回上一层访问过的遍历点，若此遍历点仍没有尚未被访问的邻接点，则继续返回上一层直到找到尚有未被访问的邻接点的遍历点，继续执行步骤（2），否则执行步骤（4）  
（4）若此时图中还有顶点未被访问，则继续选择图中一个未被访问的顶点作为起始点，重复上述描述过程，直至图中所有顶点均被访问过为止。  
在对图进行深度优先遍历时，按照结点的先后的被访问次序所组成的序列，称为深度优先搜索序列，简称𝑫𝑭𝑺序列。对于一个连通图，由深度优先搜索算法进行遍历得到的结点次序（𝐷𝐹𝑆序列），以及相应结点之间的边所构成的图称为深度优先生成树。对于一个非连通图，由深度优先搜索算法进行遍历得到的结点次序（𝐷𝐹𝑆序列），以及相应结点之间的边所构成的图称为深度优先生成森林。"
图的遍历算法,算法,['第八章  图的基本理论与算法'],"{'实体类型': '算法', '应用': '对图的结点或边进行自动遍历'}",,1,"若用点表示现实世界中事物、点之间连线表示事物之间联系，则可画出一个图来形象地表达问题模型。事实上，若将思维浓缩，图是最简洁的思维轨迹；若将思维展开，图能描述最复杂的思维蓝本。因此，人类在很久以前就开始用图的方法记忆、分析和解决问题。然而，如果只停留在对一些具体图的讨论，那么人类就永远走不出经验主义的局限。幸运的是，十八世纪著名数学家欧拉创造性地将具体问题抽象为图模型，建立一套关于图的数学理论——图论，使图模型成为一种非常有效且非常有趣的数学工具，实现了形象思维与抽象思维的完美结合、理论性与实用性的完美结合。图模型作为一种特殊的二元关系，诠释了复杂的多对多关系，揭示了各结点之间错综复杂的网状拓扑结构，具有强大的知识表达能力。正是这种强大的表达能力使得图模型在解决诸多复杂问题中发挥至关重要、不可替代的作用。在计算机诞生之前，图模型主要用于解决一些游戏问题，例如迷宫问题、博弈问题、棋盘马经问题等等。随着计算机的诞生与兴起，图模型作为一种最基本的离散数学结构在计算机各个领域得到广泛应用，例如计算机网络路由问题、送快递最短路径问题、网站之间链接模型问题、工程预算关键路径问题、软件代码复杂度计算问题等等，都需要使用图论知识进行问题表示和求解。目前，图论及其算法已经成为计算机专业人员必须熟练掌握的一项基本知识。  
对于图这种基于连接策略的模型，自然会让人产生很多疑问，例如如何在计算机中实现这些图模型的表示和运算、沿着这些连接如何自动找到合适的路径从一个结点到达另外一个结点、能否自动计算出符合要求路径的个数、能否自动找到结点之间最短的连接路径、如何对图的结点或边进行自动遍历、如何通过图模型对实际问题建模等等。本章目标主要是通过系统地介绍和讨论图模型及其算法设计的基本知识，使得读者不仅能够找到上述问题的答案，而且能够较好地掌握图的基本理论及相关算法设计技术。本节首先学习图的概念与表示、图的运算与性质以及图的连通性质；然后介绍若干经典的图模型算法，包括图的遍历算法、单源和多源最短路径算法等；最后介绍图模型的应用。"
图的集合运算,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.2.1 图的基本运算', '一、图的集合运算']","{'实体类型': '概念', '定义': '图模型作为一种特殊的集合具有并、交、差、补、环和等集合运算', '相关性质': '包括不交、不重的定义及其运算结果'}",,4,"图模型作为一种特殊的集合具有并、交、差、补、环和等集合运算，下面分别介绍这些集合运算及其相关性质。 首先给出两个图不交、不重的定义：  
【定义8.10】假设 $G_{1}=\langle V_{1},E_{1}\rangle$和 $G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，则有：  
（1）如果 $V_{1}\cap V_{2}=\varnothing$，则称 $G_{1}$ 与 $G_{2}$ 是不交的；  
（2）如果 $E_{1}\cap E_{2}=\varnothing$ ，则称 $G_{1}$ 与 $G_{2}$ 是边不交的，或者说是不重的。  
显然，对于任意两个不交的图它们必然是不重的，反之不然。  
下面给出图模型基本集合运算的定义：  
【定义 8.11 】假设   $G_{1}=\langle V_{1},E_{1}\rangle$ 和   $G_{2}=\langle V_{2},E_{2}\rangle$ 分别为不含孤立结点的图模型（它们 同为无向图或者同为有向图）。  
（1）令图 $G_{1}\cup G_{2}=\left\langle V,E\right\rangle$，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的并图，其中：$V=V_{1}\cup V_{2},\;\;E=E_{1}\cup E_{2}$  
当 $G_{1}$ 与 $G_{2}$ 不存在公共的边时，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$  的不重并。  
（2）设图 $G_{1}\cap G_{2}=\langle V,E\rangle$，称 $G_{1}\cap G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的交图，其中：$V=V_{1}\cap V_{2},\,\,\,E=E_{1}\cap E_{2}$  
$G_{1}\cap G_{2}$是由 $G_{1},G_{2}$ 中所有公共的边组成的图。  
（3）设图 $G_{1}-G_{2}=\langle V,E\rangle$，称 $G_{1}-G_{2}$ 为 $G_{1}$ 减 $G_{2}$ 的差图，其中：
$$
V=V_{1},\,\,\,E=E_{1}-E_{2}
$$  
$G_{1}-G_{2}$ 是在图 $G_{1}$ 中减去属于 $G_{2}$ 的边后所剩余的部分组成的图。  
（4）环和图 $G_{1}\oplus G_{2}$ 是由 $G_{1}$ 与 $G_{2}$ 的并图减去 $G_{1}$ 与 $G_{2}$ 的交图后得到的图。
$$
G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})
$$  
从上述定义可以看出，图模型的并、交、差、环和等集合运算其实就是普通集合运算的延伸。 需要注意的是：  
（1）若   $G_{1}=G_{2}$   ，则 $G_{1}\cup G_{2}=G_{1}\cap G_{2}=G_{1}(G_{2}),~~~~~G_{1}-G_{2}=G_{2}-G_{1}=\varnothing\,。$  
（2）$G_{1}$ 与 $G_{2}$ 不重时，$G_{1}\cap G_{2}=\varnothing$，$G_{1}-G_{2}=G_{1}$，  $G_2-G_1=G_2, G_1\oplus G_2=G_1\cup $$G_{2}$。  
（3）两个图的环和可用并、差、交给出，$G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})\,.$"
图论,概念,"['8.1.1  图模型的由来', '§ 8.1 图的概念与表示', '第八章  图的基本理论与算法', '第一章  集合与计数基础']","{'实体类型': '概念', '地位': '离散数学的分支之一', '定义': ['关于图的数学理论', '研究图及其相关性质的数学理论'], '特点': ['形象思维与抽象思维的完美结合', '理论性与实用性的完美结合'], '应用': ['计算机网络路由问题', '送快递最短路径问题', '网站之间链接模型问题', '工程预算关键路径问题', '软件代码复杂度计算问题', '电路网络分析', '四色猜想问题', '结点遍历问题'], '创立者': '欧拉', '发展': '1936年哥尼格出版第一本图论专著，标志着图论成为独立完备的数学分支'}",,1,离散数学以各种离散量的概念、关系、结构和运算性质为研究对象，以充分满足计算机相关学科对离散量进行表示和处理的数学需求。正如微积分支撑了作为近代工业文明基础的物理学，离散数学支撑了作为现代信息社会基础的计算机科学。事实上，离散数学是一门综合的数学学科，由多个数学分支组成，包括集合论、数理逻辑、图论、数论、组合分析、代数结构等，分别从不同角度出发研究各种离散量之间数与形的关系。本章比较系统地介绍集合论与计数的基础知识， 它们是学习各个离散数学分支所必备的入门基础。 尽管读者可能已 经从其它途径获悉其中某些概念，但是要想掌握作为支撑整个计算机学科基石的离散数学，就必须重新审视和系统地学习这些入门知识。
图运算,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.2.1 图的基本运算']","{'实体类型': '概念', '定义': '以图作为运算对象进行的运算', '应用': '根据图模型特点和问题求解的需要定义各种图运算以产生新的图模型', '具体包括': '图的集合运算、边点修改运算以及子图与补图运算'}",,3,以图作为运算对象进行的运算称为图运算。在对图的实际应用中，可以根据图模型特点和问题求解的需要来定义各种图运算以产生新的图模型。本节主要介绍图的基本运算，具体包括图的集合运算、边点修改运算以及子图与补图运算等。
域,概念,"['§ 11.1 代数结构的基本概念', '第五章 关系模型与理论', '§ 5.1 关系的数学模型', '第十二章 典型抽象代数结构', '第十一章  抽象代数结构通论', '12.4.2  域的概念与性质', '5.1.2  关系的概念', '11.1.1 数学结构与代数结构', '§ 12.4 环和域的基本知识']","{'实体类型': '概念', '定义': ['含有两个二元运算的抽象代数结构，具有两个二元运算的典型代数结构', '具有两个二元运算的代数系统，满足加法是交换群，去除0元素的乘法是交换群，且乘法对加法满足分配律', '称fld𝑅=dom𝑅∪ran𝑅为𝑅的域'], '基本知识': '域的基本概念与性质', '特点': ['同时具有加法和乘法两个运算', '对环结构施加进一步限制，要求去除0元素的乘法是可交换群'], '相关概念': '子域、商域、域同态'}",,3,"代数结构作为四大基本数学结构之一，它以运算作为处理机制，在整个数学理论体系和计算机数学建模中占据非常重要的作用。代数结构是一种非常古老的数学结构，具有几千年发展历程，从最初初等代数逐步发展到大代数，然后进一步发展到抽象代数，目前正朝着泛代数的方向发展。本小节主要介绍抽象代数的由来及其基本知识结构。  
用计算机解决实际问题，一般需要对问题进行抽象并建立相应的数学模型，然后在此基础上将对实际问题的求解转化为对数学模型的求解。 因此，数学模型是用计算机解决实际问题的基础。现实问题纷繁复杂、变化万千，所建立的数学模型自然也是五花八门，多种多样，让人无所适从。值得欣慰的是，尽管我们面对的数学模型复杂多样，但从结构上看，所有这些数学模型都建立在四种基本的数学结构基础之上。  
这四种基本数学结构分别为：表示元素之间空间关系的拓扑结构，如图模型、树模型就是一些拓扑结构；表示元素之间运算关系的代数结构，如初等代数、向量代数、矩阵代数、命题代数、集合代数等都是代数结构；表示元素规模度量性质的测度结构，如高等数学里函数的微分和积分都是测度结构，它们主要计算面积、体积、弧长、速度等；表示元素之间次序关系的偏序结构，如整数的整除关系、集合的包含关系等偏序关系都是偏序结构。  
任何一个数学结构都是由载体、处理机制和处理规则这三个基本要素组成：  
（1）载体集合 对于任何一个数学结构，需要定义一些抽象的元素作为处理对象，这些抽象元素组成的集合构成数学结构的载体。载体集合是数学结构存在的基础或平台。  
（2）处理机制 为了实现对数学结构载体中元素的处理，需要定义一些处理机制，不同的数学结构具有不同的处理机制。例如：偏序结构是一种关系结构，它以元素之间的次序关系或者比较关系作为处理机制；代数结构是一种运算结构，它以元素之间的运算作为处理机制；拓扑结构是一种分布结构，它以元素之间的空间分布作为处理机制；测度结构则是一种度量结构，它以元素的规模度量作为处理机制。  
（3）处理规则 为使定义出来的数学结构满足一些合理性要求以及能够在处理实际问题中发挥作用，避免出现一些矛盾或荒诞的处理结果，还必须制定一些处理规则对处理机制做一些必要的限制。在现代数学的公理化系统中，通常称这些处理规则称为公理。不同的数学结构具有不同的处理规则，例如偏序结构限制元素之间的关系必须满足自反性、反对称性和传递性，这些限制或者性质构成了偏序结构公理系统；再如代数结构则是规定元素之间的运算必须满足结合律、交换律、分配律等运算性质。  
数学运算最早起源于算术运算，即使用具体的整数或分数进行四则运算。随着科学技术的不断发展，人们逐步意识到这种方法不能满足对一般性规律的认识。因此，采用抽象的字母来代替具体的整数和分数进行运算以获得通用性结果，并称之为代数运算或简称为代数。在微积分出现之前的数千年历史中，对代数运算的研究一直占据数学研究的核心地位。那时人们普遍信奉一种所谓的万能法则，即世界上所有问题都可以转化为数学问题，所有数学问题都可以转化为代数问题，所有代数问题都可以转化为方程问题。  
因此，在很长一段历史时期内，人们对数学的研究基本上都是对代数学的研究，对代数学的研究基本上是方程或方程组解法的研究。解方程是那个时期内所有数学家的中心任务，大家都非常期望能够通过使用代数运算的方法找到方程或方程组的通用求解公式。这种努力在线性方程组领域取得了非常完美的结果，并由初等代数逐步衍生出线性代数。但是，对于一元高次方程通用求解方法的研究并不是很顺利，对于次数高于四次的一元方程始终找不到通用求解公式或求解方法。一些非常著名的数学家，例如欧拉、高斯、拉格朗日等都对此做了大量非常艰苦的研究，但均告失败。  
在寻求五次方程通用求解方法的过程中，年仅17 岁的法国天才少年伽罗瓦在1828 年提出群的概念，运用群的思想证明了五次方程通用求解公式是不存在的，并给出了五次方程系数在满足一定条件下若干特殊解法，由此一举解决了困扰数学家长达200 多年的数学问题。伽罗瓦取得成功的关键在于不仅将运算对象进行抽象化，而且对运算本身进行抽象，在抽象对象和抽象运算的基础上通过构造一些特殊抽象代数结构进行求解。这个思想在当时实在过于超前以至于没有得到柯西、傅里叶、泊松等著名数学家的认可，泊松的判词是“完全不能理解”。 1832 年5 月31 日年仅21 岁的伽罗瓦死于决斗。在决斗之前，他把关于五次方程代数求解的研究成果写成长信，留给了人类。14 年后，法国数学家刘维尔整理并发表了伽罗瓦的遗作，人们才理解并惊叹他那超越时代的天才思想和巧妙构思。  
至此以后，人们对代数的研究内容由方程或方程组的求解技巧转变为对代数运算性质和运算结构的研究，通过对运算和运算对象进行抽象的方式实现对所有运算依其运算性质进行分类或归类，并将伽罗瓦的群论迅速发展成为一门称之为抽象代数结构的崭新数学分支。 抽象代数结构的诞生，把代数学从传统的初等代数发展到现代的抽象代数，由此打开了现代代数学的大门，开创了代数学研究的新纪元。因此，抽象代数结构通常也称为近世代数以区别于之前的初等代数。若无特别说明，我们通常将抽象代数结构简称为代数结构。  
经过一百多年的发展，抽象代数结构已经形成一个如图11-1 所示的知识体系。对于一个代数系统，我们不仅可以主动设计出它的运算并考察相应的运算规则，而且还可以通过分别对其载体集合进行相关改造或运算得到相应的子代数、积代数和商代数，可以通过映射的方式考察不同代数结构之间的区别与联系，还可根据运算性质对代数结构进行分类，形成若干典型抽象代数系统，如群、环、域、格等。  
![](images/37d476cf884c29ed65924bc021cb612de43bab4df8b1196f64e96cad4f61a01f.jpg)
图11-1 抽象代数结构的知识体系  
代数结构作为一种特殊的数学结构，具有载体、处理机制和处理规则这三个基本要素。如前所述，代数结构的载体就是由一些抽象对象为元素组成的集合，并通过运算机制实现对集合中元素的处理。所谓运算，其实就是通过映射的手段从已有元素中构造出新的元素。载体和运算统称为代数结构的成分。代数结构的处理规则即为运算性质。  
既然代数结构的载体是一个集合，那么就可以考虑通过一定方式由这个集合派生出新的集合并据此构造出新的代数结构。例如，可以考察其子集以及在子集上的运算，得到子代数的概念和性质；可以对作为载体的集合做笛卡尔集构成一个新的集合，并在新集合上定义相关运算，得到积代数的概念和性质；可以通过构造等价关系的方法实现对集合载体的划分，构成一个以等价类为元素的商集，并在这个商集上定义相关运算，得到商代数的概念和性质。子代数、积代数和商代数是构造和研究代数结构的基本方法论。  
当然，还可以考察两个代数结构之间的相似性与差异性。对于任意两个代数系统，可以在这两个代数结构的载体(集合)上建立一种保运算的映射，由此考察代数结构之间的联系。如果存在这种保运算映射，则称这两个代数系统同态。如果这种保运算的映射还是双射，则称这两个代数系统同构。同态和同构是考察代数结构之间联系的基本工具。  
依据代数结构的运算性质，可以将各种具体代数结构划分为若干抽象类型。典型的抽象代数结构类型主要有仅含一个二元运算的半群与群、含有两个二元运算的环与域，以及格与布尔代数。这些典型抽象代数结构构成代数结构知识体系的主要内容。"
基数,概念,"['第一章  集合与计数基础', '§ 1.2 可数集与不可数集']","{'实体类型': '概念', '定义': '度量集合规模大小的指标', '应用': '用于比较不同集合的大小'}",,2,我们知道，基数是度量集合规模大小的指标，当集合基数为有限数时，该集合为有限集，其基数就是集合中元素的个数。当集合基数为无穷大时，该集合为无限集。对于无限集，如何使用基数度量其大小规模？例如，对于自然数集与有理数集，如何比较这两个无限集的基数，对于有理数集和无理数集，又如何比较两者的基数，等等。无穷大到底有多大？是否可以对无穷大的规模进行差异性分析，将其划分为不同层次或等级？本节将通过探讨与此相关的概念和问题，使得读者能够对无限集有着比较清晰的认识和本质性把握。
基本回路,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.2 可达性及其判定']","{'实体类型': '概念', '定义': '图中结点v到自身的长度不大于n的回路', '相关定理': '定理8.4'}",,3,"如前所述，对于任意一个给定的线图模型，图中任意两个指定结点之间的通路可能有很多条，有的可能会长一些，有的可能会短一些，此时，一般关心的是哪条通路最短。还有一种情况，就是图中可能存在两个或者多个结点，它们之间根本没有通路相联结，例如，在图8。3。1 表示的城市高铁运输线路图中，北京和台北之间就没有通路联结，这也是一种比较重要的情形。 由此得到如下图中结点可达性及其短程线的相关概念  
【定义8.23】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，对于𝑉中的任意两个结点$v_{i},v_{j}$，如果从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$之间存在长度至少为1 的通路，则称从$v_{i}$到$v_{j}$可达，否则称从$v_{i}$到$v_{j}$不可达。 如果图$G$ 中从$v_{i}$到$v_{j}$可达，则从$v_{i}$到$v_{j}$长度最短的通路称为从$v_{i}$到$v_{j}$的短程线，该短线程的长度称从$\boldsymbol{v}_{i}$到$v_{j}$的距离，记为 $d\big(v_{i},v_{j}\big)$ 。如果从$\boldsymbol{v}_{i}$到$v_{j}$不可达，则记为 $d\bigl(v_{i},v_{j}\bigr)=\infty$ 。  
从上述定义可以看出，结点之间的可达性刻画的是图中两个结点之间的某种连通性关系。对于无向图来说，这种连通性关系显然是双向的，故若从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$ 可达，则从 $v_{j}$ 到 $v_{i}$ 可达，反之亦然；且有 $d\bigl(v_{i},v_{j}\bigr)=d\bigl(v_{j},v_{i}\bigr)$ 。对于有向图来说，这种连通性关系不一定满足对称性，故若从$v_{i}$到$v_{j}$ 可达，则不一定有从 $v_{j}$ 到 $v_{i}$ 可达，也不一定有 $d\big(v_{i},v_{j}\big)=$$d\big(v_{j},v_{i}\big)$ 。  
如前所述，图模型$G=\langle V,E\rangle$中结点之间的通路由该图所表示二元关系不断对其自身作复合运算产生，长度为$k$的通路其实就是二元关系$k$次幂运算的结果。因此，由图$G=\langle V,E\rangle$中结点之间可达性产生的二元关系其实就是图$G=\langle V,E\rangle$所表示二元关系的传递闭包。  
我们知道，对于有限集合$ V=\{v_{1},v_{2},\ldots,v_{n}\}$上的任意一个二元关系，构造其的传递闭包最多只需要进行$\cdot n$次方幂运算就可以了。也就是说，对于任意一个$n$结点的图模型，联结其中两个可达的结点最多只需要做$ n$次方幂运算，亦即对于图中任意两个可达结点，必然存在一条长度不大于$ n$的通路或回路联结这两个结点。  
以上是从二元关系及其传递闭包的角度对图中可达结点的联结通路或回路长度的分析，下面从图模型的角度对上述分析结论进行严格证明。  
【定理8.3】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中两个不同的结点$u$ 和 $v$，存在一条从$u$到 $v$通路，则必然存在一条长度不大于$:n-1$ 的基本通路。  
可类似证明如下基本回路存在性定理：  
【定理8.4】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中结点$v$，存在一条从$v$ 到 $v$回路，则必然存在一条长度不大于$^{\cdot n}$ 的基本回路。  
由以上两个定理可知，对于任意含有$ n$个结点的有向或无向线图$G=\langle V,E\rangle$，如果图从结点$u$ 到${v}$是可达的，那么必然存在从$u$ 到$v$且长度不超过$n$通路或回路。因此，根据通路或回路的计数方法，最多只需计算该图所对应邻接矩阵的$n$幂，即可判定图中任意两个结点之间是否可达。具体地说，假设𝐴是图$G=\langle V,E\rangle$的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则$B_{n}$中的元素为：  
$$
b_{i j}^{(n)}=a_{i j}^{(1)}+a_{i j}^{(2)}+\cdots+a_{i j}^{(n)}
$$  
显然，$b_{i j}^{(n)}$表示图$G$中从结点$v_{i}$到结点$v_{j}$的长度不超过$n$的通路总数，特别地，若$ i=j$，则$b_{i j}^{(n)}$为结点$v_{i}$到自身的长度不超过$n$的回路总数。因此，若$b_{i j}^{(n)}=0$，则结点$v_{i}$到$v_{j}$不可达，否则，结点$v_{i}$到$v_{j}$可达。由此得到有如下定理关于图模型的可达性定理：  
【定理8.5】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，$A=(a_{i j})_{n\times n}$为图 $G$ 的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则当$v_{i}\neq v_{j}$时，若${b_{i j}}^{(n)}>0$，则$v_{i}$到$v_{j}$可达，否则不可达，且有：  
$$
d\big(\boldsymbol{v}_{i},\boldsymbol{v}_{j}\big)==\begin{cases}\infty,&&\text{若}a_{ij}{}^{(1)},a_{ij}{}^{(2)},\cdots,a_{ij}{}^{(n)}\text{均为 0}\\\min\{a_{ij}^{(m)}|m=1,2,\cdots,n\},&&\text{否则}\end{cases}
$$  
在图模型的实际应用过程中，很多时候只需知道结点之间是否可达，而无需知道距离及通路数，由此得到如下可达性矩阵的定义：  
【定义8.24】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，则令$P=(p_{i j})_{n\times n}$是一个$n$阶矩阵，且满足：  
$p_{ij}=\begin{cases}1\:,~~~~~~结点从v_{i}到v_{j}至少存在一条长度不小于1的通路\\0\:,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~否则\end{cases}$    (8-8)  
称矩阵 $P$ 为图 $G$ 的可达性矩阵。  
从上述定义可以看出，可达性矩阵中的元素$\cdot p_{i j}$表示了从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$的可达性关系，表达了结点之间通过结点邻接关系的传递性得到可达性关系。因此，图中结点之间的可达性关系就是该图所表达邻接关系的传递闭包，可达性矩阵其实就是图邻接关系的传递闭包关系矩阵，即为可达性关系的关系矩阵。 显然，无向图的可达性矩阵为对称矩阵。  
若已知$B_{n}$ ，则只需将$B_{n}$中非零元素写成1，便可得到可达性矩阵 $P$，即有：  
$$
p_{i j}=\left\{\!\!\begin{array}{l l}{1,\qquad}&{b_{i j}^{\phantom{}(n)}\neq0}\\ {0,\qquad}&{b_{i j}^{\phantom{}(n)}=0}\end{array}\right.
$$  
由于可达性矩阵$P$是布尔矩阵，矩阵$P$中的元素$p_{i j}$只表示结点$v_{i}$到$v_{j}$是否可达，并不表示至于其通路数目及长度。因此，通过计算矩阵 $B_{n}$获得可达性矩阵$P$的方法效率较低。事实上，可类似于计算二元关系的闭包，使用邻接矩阵𝐴的布尔运算计算可达性矩阵$P$。  
【定理8.6】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，矩阵$A$和$P$分别是图$G$在该结点次序下的邻接矩阵和可达性矩阵，则有：  
$$
P=A^{(1)}\lor A^{(2)}\lor\cdots\lor A^{(k)}\lor\cdots\lor A^{(n)}
$$  
其中$A^{(k)}$表示进行矩阵$A$的$k$次布尔幂运算。"
基本增长类型,概念,"['第二章  整数与算法设计基础', '§ 2.3 算法设计的基本知识', '2.3.2 算法效率的度量']","{'实体类型': '概念', '定义': '常用函数增长类型，如常数级、对数级、多项式级、指数级、阶乘级', '意义': '对算法设计具有指导意义'}",,3,"从实际应用考虑，如果一个算法的运行时间过久，比如需要长达数年的时间，那么该算法就不适合用来解决问题。同样，一个算法如果需要占用很大的内存开销，导致系统无法为其它程序提供必须的内存资源，那么这也是不能够接受的。因此，对于设计出来的算法，需要对其利用时间和内存空间的效率进行分析，这就是算法的效率分析。无论是时间效率还是空间效率上看，算法的效率都是问题规模的某个函数，并且函数值随着问题规模的增长而增长。如果函数值随问题规模的增长而增长得很快，则说明算法效率很低，反之，如果函数值随问题规模的增长而增长得很慢，则说明算法效率很高。  
因此，为了更好地分析算法的效率，需要一些合适的方法来描述或度量函数值随自变量增长而增长的速度，如果不能精确地算出函数增长的速度，那么至少也要针对函数增长的不同速度划分出若干性质不同的等级，这就是函数增长的阶。当输入规模足够大时，精确表示的运行时间函数中的常系数和低阶项会被输入规模所掩盖。此时，只需要考虑高阶项即可。比如若复杂度为多项式$x^{2+}\!x$，$x$的复杂度会被$x^{2}$的复杂所吸收，因此只需考虑最高阶。  
事实上，在分析和度量算法效率的时候，重点考虑的是当问题规模充分大时的函数值增长的情况。因此，分析和度量算法效率时，一般都使用渐近效率的概念，即从极限的角度考虑运行时间如何随输入规模的增长而增长。为了更加准确地阐释和度量算法复杂度随问题规模增长而增长的速度，计算机科学家在算法领域引入了一些函数增长符号，其中时间复杂度常用大𝑂符号表述，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。使用这种方式时，时间复杂度可被称为是渐近的，它主要考察当输入值充分大时的情况。  
对于绝大多数算法来说，其复杂度的增长速度还可以使用基本或常用函数增长类型通过示例性的方法来描述或表示，如常数级、对数级、多项式级、指数级、阶乘级增长速度，等等。这些常用函数的增长速度非常直观，以它们增长速度为标准对算法的计算复杂度进行度量，会使得算法复杂度分析变得易于理解。因此，掌握这些常用函数的基本增长类型对算法设计具有非常重要的指导意义，下面对其做简要介绍：  
（1）$\mathrm{O}(1)$：复杂度为常数级，例如从一个数据集中取出第一个元素；  
（2）$\mathrm{O}(\lg n)$：该类型常见于将一个数据集分成两半，然后将其中每一半再分成两半，以此类推。例如对有序数组进行二分查找，其时间复杂度就是$\mathrm{O}(\lg n)$；  
（3）$\mathrm{O}(n)$：该类型常见于数据集中的遍历，例如在线性结构中顺序查找某个元素的算法，其时间复杂度就是$\mathrm{O}(n)$；  
（4）$\mathrm{O}(n\lg n)$：该类型与前面所述的$\mathbf O(1g\ n)$有点类似，常见于将一个数据集分成两半，然后将每一半再分成两半，并且对每一半数据进行遍历，以此类推，例如归并排序时间复杂度就是$\mathrm{O}(n\,1\mathrm{g}\,n)$；  
（5）${\mathrm{O}}(n^{2})$：常见于两重嵌套循环的算法之中，也就是说在遍历一个数据集中的每一个元素的时候同时遍历另一个数量级相同的数据集，基本排序算法（如冒泡排序、直接插入排序、直接选择排序等）的时间复杂度是${\mathrm{O}}(n^{2})$；  
（6）${\mathrm{O}}(n^{3})$：该类型常见于三重嵌套循环的算法之中，在线性代数中，两个$n$阶方阵相乘的时间复杂度就是${\mathrm{O}}(n^{3})$，著名求解最短路径Floyd 算法的时间复杂度也是${\mathrm{O}}(n^{3})$；  
（7）$\mathrm{O}(2^{n})$：为一个数据集生成所有的子集，这种数量级的算法可以说是很低效的，在规模较大的时候是不可行的；  
（8）$\mathrm{O}(n!)$：对具有$n$ 个元素的集合进行全排列时就是该类型的典型例子，这种数量级的算法基本上是不可行的。"
基本永真蕴含关系,性质,"['第三章  命题演算与推理', '§ 3.5 命题逻辑的演绎推理', '3.5.1 永真蕴含关系与判定', '二、基本永真蕴含关系']","{'实体类型': '性质', '内容': '包括基本化简律、基本附加律、变形化简律、变形附加律、假言推理、拒取式、选言三段论、假言三段论、构造性二难推论、构造性特殊二难推论、破坏性二难推论等15个关系式'}",,4,"命题公式的等值演算常常借助一些已经证明为正确的等值式来简化演算过程，例如使用等值蕴含式构造范式。在永真蕴含关系演算中，也可这样做。具体地说，就是首先通过真值表证明一些基本的永真蕴含关系式，然后将这些关系式作为已知工具直接使用，达到简化演算过程的效果。这些关系式一共有15 个，具体如下：  
基本化简律：$I_{1}\colon G\wedge H\Rightarrow G;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {I_{2}\colon G\wedge H\Rightarrow H;}$  
基本附加律：$I_{3}\colon G\Rightarrow G\vee H;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ {I_{4}\colon H\Rightarrow G\vee H;}$  
变形化简律：$I_{5}\colon\neg G\Rightarrow G\to H;\ \ \ \ \ \ \ \ \  \ \ \ \ {I_{6}\colon H\Rightarrow G\rightarrow H;}$  
变形附加律：$I_{7}\colon\neg(G\to H)\Rightarrow G;\ \ \ \ \ \ \ \ \ {I_{8}\colon\neg(G\rightarrow H)\Rightarrow\neg H;}$  
假言推理：$I_{9}\colon G\wedge(G\to H)\Rightarrow H$  ;  
拒取式：$I_{10}\colon(G\to H)\wedge\neg H\Rightarrow\neg G$  ;  
选言三段论： $I_{11}\colon(G\vee H)\wedge\neg H\Rightarrow G$  ;  
假言三段论： $I_{12}\colon(G\to H)\wedge(H\to R)\Rightarrow(G\to R)$  ;  
构造性二难推论：$I_{13}\colon(G\to H)\wedge(R\to J)\wedge(G\vee R)\ \ \Rightarrow(H\vee J)$;  
构造性特殊二难推论： $I_{14}\colon(G\to H)\wedge(\neg G\to H)\Rightarrow H$ ;  
破坏性二难推论：   $I_{15}$ :   $(G\to H)\land(R\to J)\land(\neg H\lor\neg J)\ \ \Rightarrow(\neg G\lor\neg R)$  。"
基本等值关系,性质,"['第三章  命题演算与推理', '§ 3.2 命题公式与等值演算', '3.2.2 等值关系与等值演算', '二、基本等值关系']","{'实体类型': '性质', '特点': '包括幂等律、交换律、结合律、同一律、零律、分配律、吸收律、矛盾律与排中律、双从否定律、德摩根律、等值蕴含与假言易位、等价与等价否定、归谬论等24个基本等值关系式'}",,4,"在初等代数中，我们常常借助一些已经证明为正确的恒等式，例如平方差公式等进行代数式的恒等变形或演算。在命题逻辑中，也可以这样做。具体地说，就是首先通过真值表证  
明一些基本的等值关系式，然后将这些基本等值关系式作为已知工具直接在命题公式等值演算中使用，达到简化演算过程的效果。这些基本等值关系式一共有24 个，具体如下：  
幂等律：$E_{1}\colon G\vee G\Leftrightarrow G$；                    $E_{2}\colon G\wedge G\Leftrightarrow G$；  
交换律：$E_{3}\colon G\vee H\Leftrightarrow H\vee G$；                 $E_{4}\colon G\wedge H=H\wedge\mathsf{G}$；  
结合律：$E_{5}\colon G\vee(H\vee S)\Leftrightarrow(G\vee H)\vee S \ \  \ \ E_{6}\colon G\wedge(H\wedge S)\Leftrightarrow(G\wedge H)\wedge S$  
同一律：$E_{7}\colon G\vee0\Leftrightarrow G$；                     $E_{8}\colon G\wedge1\Leftrightarrow G$；  
零  律： $E_{9}\colon G\vee1\Leftrightarrow1$；                     $𝐸_{10}: 𝐺∧0 ⇔0$；  
分配律：$E_{11}\colon G\vee(H\wedge S)\Leftrightarrow(G\vee H)\wedge(G\vee S)$$ 𝐸_{12}: 𝐺∧(𝐻∨𝑆) ⇔(𝐺∧𝐻) ∨(𝐺∧𝐻)；$  
吸收律：$E_{13}\colon G\vee(G\wedge H)\Leftrightarrow G$；               $𝐸_{14}: 𝐺∧(𝐺∨𝐻) ⇔𝐺； $  
矛盾律与排中律：$E_{15}{\colon G\wedge\neg G\Leftrightarrow0}$；            $E_{16}\colon G\vee\neg G\Leftrightarrow1;$；  
双从否定律：$E_{17}\colon\neg(\neg G)\Leftrightarrow G$  
德摩根律：$E_{18}\colon\neg(G\vee H)\Leftrightarrow\neg G\wedge\neg H$；         $E_{19}\colon\neg(G\wedge H)\Leftrightarrow\neg H\vee\neg G$  
等值蕴含与假言易位： $E_{20}\colon G\to H\Leftrightarrow\lnot G\vee H$ ； $E_{21}\colon G\to H=\neg H\to\neg G\colon$  
等价与等价否定：$E_{22}\colon G\leftrightarrow H\Leftrightarrow(\neg G\lor H)\land(\neg H\lor G);\quad $  
$E_{23}\colon G\leftrightarrow H\Leftrightarrow\neg G\leftrightarrow\neg H;$  
归谬论：$E_{24}\colon(G\to H)\wedge(G\to\lnot H)\Leftrightarrow\lnot G$。  
除了上述24 个基本等值关系之外，命题公式的等值演算还经常用到两个著名的定理，  
即代入定理和替换定理。  
对于任意一个永真式或永假式，其真值与公式中命题变元的取值状态无关。因此，用任意公式取代永真式或永假式中的变元，都不会改变其取值的永真性或永假性。下列代入定理正是表达了这个含义：  
【定理3.3**]**（代入定理）设$G(P_{1},P_{2},\cdots P_{n})$是一个命题公式，其中$P_{1},P_{2},\cdots P_{n}$是$G$中的$n$个命题变元，$G_{1}(P_{1},P_{2},\cdots P_{n})$，$G_{2}(P_{1},P_{2},\cdots P_{n})$，⋯，$G_{n}(P_{1},P_{2},\cdots P_{n})$为任意命题公式，此时若$G$为永真公式或永假公式，则用$G_{1}$取代$P_{1}$，用$G_{2}$取代$P_{2}$，⋯，用$G_{n}$取代$P_{n}$后得到的新的命题公式： $\mathsf{G}(G_{1},G_{2},\cdots G_{n})\,\Leftrightarrow\,G^{\prime}(P_{1},P_{2},\cdots P_{n})$也是一个永真公式或者永假公式。  
【定理3.4】（替换定理）设${\mathcal{G}}_{1}$是$G$的子公式，$H_{1}$是任一命题公式，在$G$中凡出现$G_{1}$处都以$H_{1}$替换后得到新的命题公式$\mathsf{H}$，若$G_{1}\Leftrightarrow H_{1}$，则$G\Leftrightarrow H$。"
基本运算性质,性质,"['第十一章  抽象代数结构通论', '§ 11.2 代数结构的运算性质']","{'实体类型': '性质', '组成': '若干二元运算律与特殊元素', '作用': '以这些基本运算性质为标准考察和分析各种各样的具体代数结构'}",,2,具体的代数结构种类繁多、不胜枚举，逐个分析和探讨每个代数结构的性质显然是不可行的。因此，必须通过建立一些标准实现对这些代数结构进行分类，以便进行分门别类的考察和研究，揭示这些代数结构共性和差异。这种做法有点类似前面对二元关系模型的研究，首先总结出二元关系的五个基本性质，即自反性、反自反性、对称性、反对称性和传递性，然后以这五个基本性质为标准来区分各种各样的关系，例如，满足自反性、对称性和传递性的关系为等价关系、满足自反性、反对称性和传递性的关系为偏序关系等等。对于代数结构的研究思路也是如此，首先要考察代数结构的基本运算性质，然后以这些基本运算性质为标准考察和分析各种各样的具体代数结构。这些基本性质主要由若干二元运算律与特殊元素组成，本节比较系统地介绍些二元运算律与特殊元素。
基本通路,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.2 可达性及其判定']","{'实体类型': '概念', '定义': '图中两个不同结点之间存在的一条长度不大于n-1的通路', '相关定理': '定理8.3'}",,3,"如前所述，对于任意一个给定的线图模型，图中任意两个指定结点之间的通路可能有很多条，有的可能会长一些，有的可能会短一些，此时，一般关心的是哪条通路最短。还有一种情况，就是图中可能存在两个或者多个结点，它们之间根本没有通路相联结，例如，在图8。3。1 表示的城市高铁运输线路图中，北京和台北之间就没有通路联结，这也是一种比较重要的情形。 由此得到如下图中结点可达性及其短程线的相关概念  
【定义8.23】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，对于𝑉中的任意两个结点$v_{i},v_{j}$，如果从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$之间存在长度至少为1 的通路，则称从$v_{i}$到$v_{j}$可达，否则称从$v_{i}$到$v_{j}$不可达。 如果图$G$ 中从$v_{i}$到$v_{j}$可达，则从$v_{i}$到$v_{j}$长度最短的通路称为从$v_{i}$到$v_{j}$的短程线，该短线程的长度称从$\boldsymbol{v}_{i}$到$v_{j}$的距离，记为 $d\big(v_{i},v_{j}\big)$ 。如果从$\boldsymbol{v}_{i}$到$v_{j}$不可达，则记为 $d\bigl(v_{i},v_{j}\bigr)=\infty$ 。  
从上述定义可以看出，结点之间的可达性刻画的是图中两个结点之间的某种连通性关系。对于无向图来说，这种连通性关系显然是双向的，故若从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$ 可达，则从 $v_{j}$ 到 $v_{i}$ 可达，反之亦然；且有 $d\bigl(v_{i},v_{j}\bigr)=d\bigl(v_{j},v_{i}\bigr)$ 。对于有向图来说，这种连通性关系不一定满足对称性，故若从$v_{i}$到$v_{j}$ 可达，则不一定有从 $v_{j}$ 到 $v_{i}$ 可达，也不一定有 $d\big(v_{i},v_{j}\big)=$$d\big(v_{j},v_{i}\big)$ 。  
如前所述，图模型$G=\langle V,E\rangle$中结点之间的通路由该图所表示二元关系不断对其自身作复合运算产生，长度为$k$的通路其实就是二元关系$k$次幂运算的结果。因此，由图$G=\langle V,E\rangle$中结点之间可达性产生的二元关系其实就是图$G=\langle V,E\rangle$所表示二元关系的传递闭包。  
我们知道，对于有限集合$ V=\{v_{1},v_{2},\ldots,v_{n}\}$上的任意一个二元关系，构造其的传递闭包最多只需要进行$\cdot n$次方幂运算就可以了。也就是说，对于任意一个$n$结点的图模型，联结其中两个可达的结点最多只需要做$ n$次方幂运算，亦即对于图中任意两个可达结点，必然存在一条长度不大于$ n$的通路或回路联结这两个结点。  
以上是从二元关系及其传递闭包的角度对图中可达结点的联结通路或回路长度的分析，下面从图模型的角度对上述分析结论进行严格证明。  
【定理8.3】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中两个不同的结点$u$ 和 $v$，存在一条从$u$到 $v$通路，则必然存在一条长度不大于$:n-1$ 的基本通路。  
可类似证明如下基本回路存在性定理：  
【定理8.4】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中结点$v$，存在一条从$v$ 到 $v$回路，则必然存在一条长度不大于$^{\cdot n}$ 的基本回路。  
由以上两个定理可知，对于任意含有$ n$个结点的有向或无向线图$G=\langle V,E\rangle$，如果图从结点$u$ 到${v}$是可达的，那么必然存在从$u$ 到$v$且长度不超过$n$通路或回路。因此，根据通路或回路的计数方法，最多只需计算该图所对应邻接矩阵的$n$幂，即可判定图中任意两个结点之间是否可达。具体地说，假设𝐴是图$G=\langle V,E\rangle$的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则$B_{n}$中的元素为：  
$$
b_{i j}^{(n)}=a_{i j}^{(1)}+a_{i j}^{(2)}+\cdots+a_{i j}^{(n)}
$$  
显然，$b_{i j}^{(n)}$表示图$G$中从结点$v_{i}$到结点$v_{j}$的长度不超过$n$的通路总数，特别地，若$ i=j$，则$b_{i j}^{(n)}$为结点$v_{i}$到自身的长度不超过$n$的回路总数。因此，若$b_{i j}^{(n)}=0$，则结点$v_{i}$到$v_{j}$不可达，否则，结点$v_{i}$到$v_{j}$可达。由此得到有如下定理关于图模型的可达性定理：  
【定理8.5】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，$A=(a_{i j})_{n\times n}$为图 $G$ 的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则当$v_{i}\neq v_{j}$时，若${b_{i j}}^{(n)}>0$，则$v_{i}$到$v_{j}$可达，否则不可达，且有：  
$$
d\big(\boldsymbol{v}_{i},\boldsymbol{v}_{j}\big)==\begin{cases}\infty,&&\text{若}a_{ij}{}^{(1)},a_{ij}{}^{(2)},\cdots,a_{ij}{}^{(n)}\text{均为 0}\\\min\{a_{ij}^{(m)}|m=1,2,\cdots,n\},&&\text{否则}\end{cases}
$$  
在图模型的实际应用过程中，很多时候只需知道结点之间是否可达，而无需知道距离及通路数，由此得到如下可达性矩阵的定义：  
【定义8.24】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，则令$P=(p_{i j})_{n\times n}$是一个$n$阶矩阵，且满足：  
$p_{ij}=\begin{cases}1\:,~~~~~~结点从v_{i}到v_{j}至少存在一条长度不小于1的通路\\0\:,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~否则\end{cases}$    (8-8)  
称矩阵 $P$ 为图 $G$ 的可达性矩阵。  
从上述定义可以看出，可达性矩阵中的元素$\cdot p_{i j}$表示了从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$的可达性关系，表达了结点之间通过结点邻接关系的传递性得到可达性关系。因此，图中结点之间的可达性关系就是该图所表达邻接关系的传递闭包，可达性矩阵其实就是图邻接关系的传递闭包关系矩阵，即为可达性关系的关系矩阵。 显然，无向图的可达性矩阵为对称矩阵。  
若已知$B_{n}$ ，则只需将$B_{n}$中非零元素写成1，便可得到可达性矩阵 $P$，即有：  
$$
p_{i j}=\left\{\!\!\begin{array}{l l}{1,\qquad}&{b_{i j}^{\phantom{}(n)}\neq0}\\ {0,\qquad}&{b_{i j}^{\phantom{}(n)}=0}\end{array}\right.
$$  
由于可达性矩阵$P$是布尔矩阵，矩阵$P$中的元素$p_{i j}$只表示结点$v_{i}$到$v_{j}$是否可达，并不表示至于其通路数目及长度。因此，通过计算矩阵 $B_{n}$获得可达性矩阵$P$的方法效率较低。事实上，可类似于计算二元关系的闭包，使用邻接矩阵𝐴的布尔运算计算可达性矩阵$P$。  
【定理8.6】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，矩阵$A$和$P$分别是图$G$在该结点次序下的邻接矩阵和可达性矩阵，则有：  
$$
P=A^{(1)}\lor A^{(2)}\lor\cdots\lor A^{(k)}\lor\cdots\lor A^{(n)}
$$  
其中$A^{(k)}$表示进行矩阵$A$的$k$次布尔幂运算。"
基本逻辑蕴含式,概念,"['第四章  谓词演算与推理', '§ 4.2  谓词公式与等值演算', '4.2.4 谓词公式的等值与蕴含', '二、谓词公式的蕴含关系']","{'实体类型': '概念', '来源': '命题逻辑中基本永真蕴含式的谓词公式代换实例'}",,4,"如同多项式演算不仅要用到恒等式，还经常用到不等式，谓词公式的逻辑演算与推理也是不仅要用到谓词公式之间的等值关系，而且还需要用到谓词公式之间的蕴含关系。谓词公式之间的蕴含关系如同多项式代数系统中多项式之间的小于或等于关系， 具体地说， 所谓两 个谓词公式之间存在蕴含关系，其实就是两个谓词公式在任何解释下，其中一个谓词公式的真值永远不会大于另外一个谓词公式的真值。下面借助有效公式的概念给出具体定义：  
【定义4.18】假设$G$和$H$是任意两个谓词公式，如果谓词公式$G\rightarrow H$是有效公式，则称谓词公式$\pmb{G}$逻辑蕴含谓词公式$\pmb{H}$，亦称$G$ 与$H$之间具有逻辑蕴含关系，通常简称为蕴含关系，记作$G\Rightarrow H$，并称该式为谓词公式的逻辑蕴含式，通常简称为蕴含式。  
由上述定义可知，判断两个谓词公式$G$ 和$H$ 是否具有逻辑蕴含关系，关键在于证明谓词公式$G\rightarrow H$为有效公式，这种思路与证明命题公式永真蕴含关系的基本思路是一致的。类似于命题公式的永真蕴含演算系统，在谓词公式的逻辑蕴含演算系统中，通常也是先证明出一些重要的谓词公式蕴含式，然后将这些重要谓词蕴含式作为基本蕴含式进一步推演出更多的谓词公式蕴含式，这种推演过程构成了谓词公式蕴含演算的主要内容。下面不加证明地给出这些重要而基本的谓词公式蕴含式，读者可自行给出证明。  
由于谓词公式的逻辑蕴含式依据谓词公式的有效公式定义，而命题公式中永真公式的谓词公式代换实例显然是有效谓词公式，因此与前述谓词公式的等值式类似，前述命题逻辑中15 个基本永真蕴含式经过谓词公式代换后，就可以得到相应的谓词公式基本逻辑蕴含式。当然，由前述每组谓词公式基本等值式显然都可以得到两组相应的基本逻辑蕴含式，这里不再一一赘述。这里主要介绍如下与量词有关的逻辑蕴含式。  
【定理4.1】假设$G(x)$和$H(x)$是任意两个谓词公式，则存在如下逻辑蕴含关系：  
$$
\forall x G(x)\lor\forall x H(x)\Rightarrow\forall x(G(x)\lor H(x))\tag{4-7}
$$  
$$
\exists x(G(x)\land H(x))\Rightarrow\exists x G(x)\land\exists x H(x)\tag{4-8}
$$  
不难看出，上述定理的两个式子仅仅是蕴含式而不是等值式。例如对于（1）式如下解释，由这些人都跳舞或这些人都唱歌，可以推出这些人都跳舞或唱歌。但是反之不然，由这些人都跳舞或唱歌不能推出这些人都跳舞或这些人都唱歌。（2）式可做类似理解。"
复合关系,概念,"['第五章 关系模型与理论', '§ 5.2 关系的基本运算', '5.2.2 关系的复合运算']","{'实体类型': '概念', '定义': '由两个关系R和S通过复合运算得到的新关系R∘S'}",,3,"日常生活和工作中很多关系问题仅用关系的集合运算不能得到有效的解决。例如：假设集合$𝐴$表示某家族的全部成员构成的集合，在$𝐴$上定义如下两个关系$R$和$𝑆$：  
$R$表示$A$上的兄弟关系，$\langle x,y\rangle\in R$,当且仅当$x$是$y$的兄弟;  
$S$表示 $A$ 上的父子关系，$\langle y,z\rangle\in S$,当且仅当$y$ 是$z$ 的父亲。  
则可通过元素$y$的中间媒介或传递作用，在$x$与$z$之间产生一个新的关系，即叔侄关系。换句话说，叔侄关系是由兄弟关系和父子关系的合成。  
![](images/8ed5b0cc3c8222133404e26aeb757d647b1fb51cdae3d0c7fbf0c3754976758e.jpg)
图5-7 叔侄关系图  
例如，假设在小说《红楼梦》中人物的兄弟关系为𝑅、父子关系为𝑆，则有：
$$
\begin{aligned}&R=\left\{\langle\text{贾宝玉},\text{贾环}\rangle,\langle\text{贾政},\textbf{贾赦}\rangle,\cdots\right\};\\&S=\left\{\langle\text{贾政},\text{贾宝玉}\rangle,\langle\text{贾政},\text{贾环}\rangle,\langle\textbf{贾赦 贾琏}\rangle,\cdots\right\}\end{aligned}
$$
如图5-7 所示，在上述$R$和$𝑆$这两个二元关系中，贾政和贾琏之间通过贾赦的中间媒介或传递作用建立了叔侄关系。一般地，将关系这种合成机制进行抽象，用数学语言进行表达，就得到如下关系复合运算的定义：  
【定义5.14】假设$A$、$B$、$C$ 是三个非空集合，$R$ 是从$A$ 到$B$ 的关系，$S$ 是从$B$ 到$C$的关系，则$R$ 与$S$ 的复合关系$R\circ S$定义为如下从$A$ 到$C$的关系：  
$$R\circ S=\{\langle x,z\rangle|x\in A\land z\in C\land(\exists y)(y\in B\land x R y\land y S z)\quad\text{(5-5)}$$  
运算“ ∘”称为复合运算。  
从上述定义可知：不是任意两个关系都能进行复合运算，当且仅当$R$ 的后域是$S$的前域时，$R$ 和$S$ 才可复合；$R\circ S$的前域是$R$ 的前域$A$，$R\circ S$的后域是$S$ 的后域$C$。  
任何一个关系都有集合、关系图和矩阵这三种表现形式，复合运算在这三种不同表现形式下分别具有相应的具体计算方法，下面分别介绍这三种复合计算方法。  
令$A=\{a_1,a_2,\cdots,a_m\},B=\{b_1,b_2,\cdots,b_n\},C=\{c_1,c_2,\cdots,c_t\},R$ 是$A$ 到$B$ 的关系，$S$ 是$B$ 到 $C$ 的关系，即有$R$$\subseteq{A}\times{B}$, $S$$\subseteq{B}\times{C}$, 则$R\circ S$可按下列方法进行计算.  
1 ．集合法    由复合运算的定义可知，对于任意的 $a_{i}\in A,c_{j}\in C$ ，若 $\langle a_{i},c_{j}\rangle\in R\circ S$ ，则 必然存在某个$b_{k}\in B$，使得$\langle a_{i},b_{k}\rangle\in R$并且$\langle b_{k},c_{j}\rangle\in S$。故对于$R$中每个给定的序偶$\langle a_{i},b_{k}\rangle$，要在$S$中寻遍第一元素为$b_{k}$的序偶$\langle b_{k},c_{j}\rangle$，若存在$\langle b_{k},c_{j}\rangle\in S$，则取$R$中$\langle a_{i},b_{k}\rangle$的第一元素，以及$S$中对应序偶$\langle b_{k},c_{j}\rangle$的第二元素，形成一个新的序偶$\langle a_{i},c_{j}\rangle$，该序偶即为$R\circ S$中的一个元素。同理可找出$R\circ S$中的所有元素。  
2. 关系图法  由复合运算的定义可知，对于分别属于关系$R$ 和$S$的两个序偶，它们之间能够复合的关键在于能够在这两个序偶之间找到一个桥梁$b_{k}$，使得$b_{k}$既是前一个序偶($R$中序偶)的第二元素，同时又是后一个序偶(S 中序偶)的第一元素。因此，在画复合关系的关系图时，首先应该在$R$ 和$S$ 这两个关系的关系图中搭起这个桥梁，然后拆掉中间的桥梁，直接联结经过该桥梁的两个结点，便可得到$R\circ S$的关系图。  
3.关系矩阵法  将$R$ 和$S$ 的关系矩阵做布尔积运算$\odot$，即可得到$\mathrm{~\tt~R~o~}S$的关系矩阵，然后根据该矩阵写出$R\circ S$中元素即可。也就是说，令$R$ 和$S$ 的关系矩阵分别为：
$$
M_{R}=\begin{pmatrix}\langle a_1,b_1\rangle&\langle a_1,b_2\rangle&\cdots\langle a_1,b_n\rangle\\\langle a_2,b_1\rangle&\langle a_2,b_2\rangle&\cdots\langle a_2,b_n\rangle\\\vdots\\\langle a_m,b_1\rangle\langle a_m,b_2\rangle&\cdots\langle a_m,b_n\rangle\end{pmatrix};\quad M_{S}=\begin{pmatrix}\langle b_1,c_1\rangle&\langle b_1,c_2\rangle&\cdots&\langle b_1,c_t\rangle\\\langle b_2,c_1\rangle&\langle b_2,c_2\rangle&\cdots&\langle b_2,c_t\rangle\\\vdots\\\langle b_n,b_1\rangle\langle b_n,c_2\rangle&\cdots\langle b_n,c_t\rangle\end{pmatrix}
$$
则有：
$$
M_{R\circ S}=M_{R}\odot M_{S}=\left(\begin{array}{c}{{\langle a_{1},c_{1}\rangle\ \langle a_{1},c_{2}\rangle\ \cdots\ \langle a_{1},c_{t}\rangle}}\\ {{\langle a_{2}.\,c_{1}\rangle\ \langle a_{2},c_{2}\rangle\ \cdots\ \langle a_{2},c_{t}\rangle}}\\ {{\vdots}}\\ {{\langle a_{m},c_{1}\rangle\langle a_{m},c_{2}\rangle\cdots\langle a_{m},c_{t}\rangle}}\end{array}\right)
$$  
【定理5.5】设$A$、$B$、$C$ 和$D$ 是任意四个集合，$R$、$S$和$T$ 分别是从$A$ 到$B,\ B$到$C$和$C$ 到$D$ 的二元关系，$I_{A}$和$I_{B}$分别是$A$ 和$B$ 上恒等关系，则有：
$$
(1) (R\circ S)\circ T=R\circ(S\circ T);\quad(2) I_A\circ R=R\circ I_B=R
$$  
下面的定理给出了关系的集合运算与复合运算之间的关系：复合运算对并运算具有完全的分配律，而复合运算对交运算只有有半分配律。  
【定理5.6】设$A$、$B$、$C$和$D$ 是任意四个集合，$R$ 是$A$ 到$B$ 的关系，$S_{1},\ S_{2}$是从$B$ 到$C$的关系，$T$是从$C$ 到$D$ 的关系，则有：  
（1）$R\circ(S_{1}\cup S_{2})=(R\circ S_{1})\cup(R\circ S_{2});\,\,\,(2)\,\,\,R\circ(S_{1}\cap S_{2})\subseteq(R\circ S_{1})\cap(R\circ S_{2});$ （3）$(S_{1}\cup S_{2})\circ T=(S_{1}\circ T)\cup(S_{2}\circ T);\ \ (4)\ \ (S_{1}\cap S_{2})\circ T\subseteq(S_{1}\circ T)\cap(S_{2}\circ T)。$  
上述定理和例题表明，复合运算对并运算具有完全的分配律，即分配律是以集合相等的方式出现，但复合运算对交运算不具备完全分配律，只有半分配律，也就是说，分配律是以集合包含的方式出现。如果要将关系的这些运算与数的相关运算做一些类比的话，那么关系的复合运算就比较类似于数或矩阵的乘法运算，而关系的并运算就比较类似于数或矩阵的加法运算。事实上，从复合运算和并运算的关系矩阵运算特点上，就可看出它们与数乘、数加以及矩阵乘、矩阵加的类似之处。"
复合关系的逆关系,定理,"['第五章 关系模型与理论', '§ 5.2 关系的基本运算', '5.2.3 幂关系与逆关系']","{'实体类型': '定理', '内容': '设A, B和C是任意三个集合，R, S分别是从A到B和B到C的二元关系，则有(R∘S)^{-1}=S^{-1}∘R^{-1}', '注意': '复合关系的逆关系等于它们逆关系的反复合，(R∘S)^{-1}≠R^{-1}∘S^{-1}'}",,3,"如前所述，关系的复合运算满足结合律。也就是说，如果有多个关系进行复合运算，只要不交换它们的运算次序，不管哪个先参与合成，最后结果都一样。由此可见，对于某个集合上的一个二元关系，如果它可以不断地与自己做复合运算，那么运算结果只与该关系以及复合运算次数有关，而与复合的次序无光。由此可得如下关系方幂运算的概念：  
【定义5.15】设$R$ 是集合$A$ 上的关系，则可归纳定义$R$ 的$n$次方幂${R^{n}}$运算如下：  
$（1）R^{0}=I_{A}=\left\{\langle a,\ a\rangle\big|a\in A\right\};\quad(\,2\,)\,\ R^{1}=R;\ (\,3\,)\,\ R^{n+1}=R^{n}\circ R=R\circ R^{n}\circ R.$    方幂运算的结果也显然也是$A$ 上的二元关系，即对于任何自然数$k$，有$R^{k}\subseteq A\times A$。通常称为$R$的方幂关系或幂关系，不难证明方幂运算满足如下运算法则：
$$
R^{m}\circ R^{n}=R^{m+n};\,\,\,(R^{m})^{n}=R^{m n}
$$  
由上述例题可以看出：  
（1）幂集$R^{n}$的基数$\vert{R}^{n}\vert$并非随着$n$ 的增加而增加，而是呈递减趋势；  
（2）当$n\geq|A|$时，则$R^{n}$出现循环取值或退化为空关系。 下面的定理给出了上述结论的一个解释：  
【定理5.7】设𝐴是一个具有${n}$个元素的有限集合，$R$ 是$𝐴$上的二元关系，则必存在自然数$s$ 和$t$，使得$R^{s}=R^{t}$，$0\leq s<t\leq2^{n^{2}}$。  
上述定理表明，对于任意一个有限集合，该集合上的二元关系总共只有有限多个，而对于该集合上的二元关系，其方幂运算则可以无限地进行下去且运算结果均为该集合上的二元关系。因此，在一定次数的方幂运算之后，后续的方幂运算结果自然是以某种循环的方式出现，或者以恒等于某个特定关系的方式出现。  
【定义5.16】设$A,\ B$ 是任意两个集合，$R$ 是$A$ 到$B$ 的关系，则从$B$ 到$A$ 的关系：
$$
R^{-1}=\{\langle b,a\rangle|\langle a,b\rangle\in R\}\quad\text{(5-9)}
$$
称为$R$ 的逆关系，运算“-1”称为关系的逆运算。  
关于逆关系概念的理解，需要注意如下几个要点：（1）关系是序偶的集合，逆关系也是序偶的集合；（2）如果$R$ 是一个关系，则其逆关系$R^{-1}$和补关系$\bar{R}$都是关系，但是两者是完全不同的两个关系，千万不要混淆；（3）显然有$(R^{-1})^{-1}=R$，$\varnothing^{-1}=\varnothing$。  
【定理5.8】设$A$，$B$ 和$C$是任意三个集合，$R$，$S$ 分别是从$A$ 到$B$ 和$B$ 到$C$的二元关系，则有：$(R\circ S)^{-1}=S^{-1}\circ R^{-1}$  
可以看出，复合关系的逆关系等于它们逆关系的反复合。要注意$(R\circ S)^{-1}\neq R^{-1}\circ S^{-1}$，因为$R^{-1}$是从$B$ 到$A$ 的关系，而$S^{-1}$是从$C$ 到$B$ 的关系，因此$S^{-1}$与$R^{-1}$之间是可复合的，而$R^{-1}$与$S^{-1}$之间是不可复合的。  
下面定理给出了关系逆运算与关系集合运算之间的分配运算律：  
【定理5.9】设$R,\ S$是从集合$A$ 到集合$B$ 的关系，则有如下分配律：
$$
(R\cup S)^{-1}=R^{-1}\cup S^{-1};\;\;(R\cup S)^{-1}=R^{-1}\cup S^{-1};\;\;(R-S)^{-1}=R^{-1}-S^{-1}
$$  
对于任意给定的集合𝐴和$B$，目前所讨论的二元关系有两种基本类型，一种是集合$𝐴$到集合$ B$上的二元关系，另外一种是集合𝐴上的二元关系。事实上，这两种关系没有本质上的区别，因为若令$C=A\cup B$，则集合$𝐴$到集合$B$上的二元关系就可以看成是$C\times C$的几个子集合，或者说是$C$上的二元关系。因此，在后续内容中所说的关系，若非特别说明，均为某个集合上的关系而不是从某个集合到另外一个集合上的关系。"
复合命题,概念,"['第三章  命题演算与推理', '§ 3.1 命题的概念与运算', '3.1.2  命题的基本概念']","{'实体类型': '概念', '定义': '可以分解为更加简单的陈述句的命题'}",,3,"命题逻辑以命题作为最基本的处理对象。因此，学习命题逻辑首先必须掌握命题的基本概念。事实上，命题的概念与集合的概念一样，是一个没有严格定义的原始概念，其内涵是不言自明的。我们只能对命题的概念进行描述或解释：  
所谓命题，就是具有确切真假含义且能做出判断的陈述句。当判断正确或者符合客观实际时，命题表达的内容为真或者说命题的取值为真，并称该命题为真命题；否则命题表达的内容为假或者说命题的取值为假，并称该命题为假命题。命题或真或假的取值，称为命题的真值。通常用 $T$或1 表示取值为真的真值，用 $F$ 或0 表示取值为假的真值。  
根据上述关于命题概念的解释，可以看出：  
（1）命题主要用于逻辑思维中的是非判断，因此必须是陈述语句。其它类型的语句，例如感叹句、祈使句、疑问句等，都不能用于是非判断，故不能作为命题。  
（2）对于任何一个给定的命题，必有唯一确定的真值，要么取真、要么取假，不能既真又假，也不能既不真也不假。因此，具有二义性的陈述句不能作为命题。  
【定义3.1】对于任意一个给定的命题，当它不能再分解为更加简单的陈述句时，则称该命题为原子命题；否则，称之为复合命题。  
由上述定义可知，所有命题分为原子命题和复合命题这两种基本类型。例如，命题“合肥是安徽的省会”就是一个不能再分解的原子命题，而命题“安徽不是一个国家”则是一个复合命题，由“安徽是一个国家”这个原子命题生成。  
通常用带下标或不带下标的大写英文字母 $A,B,C,\ldots,P,Q,R,\ldots$… 表示命题，并称之为命题标识符。在命题逻辑系统中，对命题标识符的解释不允许有二义性。也就是说，对于任一确定的具体场合，各个标识符所表达的含义是唯一确定的。"
复合命题函数,概念,"['第四章  谓词演算与推理', '§ 4.1 个体词、谓词与量词', '4.1.2  命题函数与谓词', '二、个体变量与命题函数']","{'实体类型': '概念', '定义': '简单命题函数通过“$\\neg$”、“$\\land$”、“$\\lor$”、“$\\rightarrow$”、“$\\leftrightarrow$”等联结词进行逻辑演算得到的逻辑表达式', '示例': '对于简单命题函数$A(x)\\colon x\\text{身体好};B(x)\\colon x\\text{学习好};C(x)\\colon x\\text{工作好}$，复合命题函数$\\neg A(x)\\to(\\neg B(x)\\land\\neg C(x))$表示如果$x$身体不好，那么学习和工作都不会好'}",,4,"对于任一给定的原子命题，其主语或宾语是一种可以独立存在的确定对象，我们称之为个体常量，将个体常量抽象成含义不确定的变量后，则称之为个体变量。相关定义如下：  
【定义4.1】客观世界中可以独立存在的具体或抽象对象称为个体，表示个体的词称为个体词。若个体词以常量的方式表示特定个体，则称之为个体常量；若个体词以变量的方式泛指不确定的个体，则称之为个体变量。  
例如，前述原子命题“小张是大学生”中的个体为“小张”。再如，命题“电子计算机是科学技术的工具”中的个体为“电子计算机”；命题“张三比李四高”中的个体为：“张三”、“李四”.可用个体常量表示这些确定的个体。  
对于个体常量，通常用带下标或不带下标的英文字母$a$，$b$，$c$，…表示。例如，可用$a$和$b$ 分别表示前述个体“小张”和“电子计算机”。  
对于前述含变量的语句“$x$是大学生”、“$x>5$”、“$x+y=10$”、“$x+y<z$”，其中的x，y，$z$均表示泛指的不确定个体，因而它们都是个体变量。  
对于个体变量，通常用带下标或不带下标的英文字母$x$，y，$z$，…表示。  
个体变量的取值应有一个明确范围，故有如下个体域的概念：  
【定义4.2】个体变量的取值范围称为个体域或论域。宇宙间所有的个体域聚集在一起构成的个体域，称为全总个体域。  
个体变量的个体域可根据问题的实际状况或需要来确定。例如，对于含变量语句“$\cdot_{x}$ 是大学生”，其中个体变量$x$ 的变化范围，可以确定为全体人类，也可以确定为某单位的全体职工，还可以确定为某个大学的全班同学或者某个中学的全班同学，等等。显然，个体变量的个体域的不同，其相应含变量语句的含义也会有所不同。  
现在个体变量与个体域概念基础上，给出命题函数的定义：  
【定义4.3】设$x_{1},x_{2},\cdots x_{n}$为$n$个个体变量，其个体域均为非空集合$D$，则定义在$D^{n}$上取值于$\{0,1\}$的$n$元函数称为$^n$元简单命题函数，记为$P(x_{1},x_{2},\cdots x_{n})$。  
例如，前述表示“$x$ 是大学生”的式子”$P(x)$“，以及“$x>5$”、“$x+y=10$”、“$x+y<z$”，都是简单命题函数。其中”$P(x)$“和“$x>5$”为一元简单命题函数，“$x+y=10$”和“$x+y<z$”分别是二元和三元简单命题函数。  
如同原子命题可以通过联结词进行逻辑演算得到复合命题一样，简单命题函数也可通过联结词的逻辑演算，得到一种更为复杂的表达式，即复合命题函数。其具体定义如下：  
【定义4.4】简单命题函数通过“$\neg$”、“$\land$”、“$\lor$”、“$\rightarrow$”、“$\leftrightarrow$”等联结词进行逻辑演算得到的逻辑表达式，称为复合命题函数。  
例如，对于如下给定的简单命题函数：  
${A(x)\colon x\text{身体好};B(x)\colon x\text{学习好};C(x)\colon x\text{工作好}}$  
复合命题函数：  
$$
\neg A(x)\to(\neg B(x)\land\neg C(x))
$$  
表示如果$x$身体不好，那么学习和工作都不会好。"
外延性原理,定理,"['第一章  集合与计数基础', '§ 1.1 集合的基本知识', '1.1.2 集合的概念与表示', '三、集合与集合的关系']","{'实体类型': '定理', '内容': '对于任意的集合A和集合B，A与B相等当且仅当两者具有相同元素；或者说，A与B相等当且仅当A中每个元素都属于B且B中每个元素都属于A'}",,4,"如前所述，集合中凡是相同的元素都看成是同一个元素，而且集合中元素之间的排列次序也不加区分，或者说是无序的。如此一来，集合就完全取决于集合中的元素。换句话说，对于任意两个集合，如果这两个集合中具有完全相同的元素，那么这两个集合就是完全一样的。或者说，这两个集合是相等的。于是得到如下关于集合相等的外延性原理：  
【定理1.1】（外延性原理）对于任意的集合$A$ 和集合$B$，$\pmb{A}$ 与$\pmb{B}$ 相等当且仅当两者具有相同元素；或者说，$\pmb{A}$ 与$\pmb{B}$ 相等当且仅当$A$ 中每个元素都属于$B$ 且$B$ 中每个元素都属于$A$。如果集合$A$ 与$B$ 相等，则记为$A=B$；否则，如果$A$ 与$B$ 不相等，则记为$A\ne B$。  
【定理1.2】集合的相等关系具有如下三条基本性质： （1）自反性：对于任意给定的集合$A$，成立$A{=}A$； （2）对称性：对于任意给定的两个集合$A$ 和$B$，若有$A{=}B$，则有$B{=}A$；  
（3）传递性：对于任意三个集合$A$、$B$、$C$，若有$A{=}B$ 且$B{=}C$，则有$_{A=C}$  
由【例题1.9】可以看出，集合$C$ 中的每个元素都是集合$A$ 中的元素，此时$A$ 完全包含了$C$，可将$C$ 看成是$A$ 的一个部分，由此得到如下集合的包含关系和子集的概念：  
【定义1.2】对于任意两个集合$A$ 和$B$，若$B$ 中的每个元素都是$A$ 中的元素，则称$\pmb{B}$ 包含于$\pmb{A}$（或$\pmb{A}$ 包含$\pmb{B}$），记为$B\subseteq A$，亦称$\pmb{B}$ 是$\pmb{A}$ 的子集，称符号$\subseteq$为集合之间的包含关系。如果$B$ 不能被$A$ 所包含，则称$\pmb{B}$ 不是$\pmb{A}$ 的子集，记为$B\nsubseteq A$。  
【定理1.3】集合的包含关系具有如下三条基本性质：（1）自反性：对于任意给定的集合$A$，都成立$A\subseteq A$  
（2）反对称性：对于任意两个集合$A$ 和$B$，$A{=}B$当且仅当$A\subseteq B$且$B\subseteq A$（3）传递性：对于任意三个集合$A$、$B$、$C$，若$A\subseteq B$且$B\subseteq C$，则$A\subseteq C$  
【定义1.3】对于任意两个集合$A$ 和$B$，如果$B\subseteq A$且$A\neq B$，则称$B$ 是$A$ 的真子集，记为$\mathrm{B}\subset\mathrm{A}$，并称符号$\subset$为集合之间的真包含关系。"
多元运算,概念,"['第十一章  抽象代数结构通论', '§ 11.1 代数结构的基本概念', '11.1.2 运算的定义与表示']","{'实体类型': '概念', '定义': '从集合$A_{1}\\\\times A_{2}\\\\times\\\\cdots\\\\times A_{n}$到集合$A$的映射$f$称为一个从集合$A_{1}\\\\times A_{2}\\\\times\\\\cdots\\\\times A_{n}$到集合𝐴的$n$元运算', '特点': '当$n=1$时，称$f$：$A\\\\rightarrow A$为集合𝑨上的一元运算', '应用': '在关系数据库的多元关系演算等领域具有重要的应用价值'}",,3,"所以代数结构，本质上就是由一个运算对象的集合和若干运算构成的系统。要学好代数结构，首先必须掌握运算的概念和性质。  
对于运算这个概念，其实我们并不陌生。例如实数的加、减、乘、除等二元运算。这些二元运算通过某种机制由两个运算对象构造出一个确定的新的对象，或者说按照某种既定的规则根据两个输入得到一个唯一确定的输出。因此，二元运算可以看成是一种特殊的二元映射或二元函数，具体定义如下：  
【定义11.1】假设$𝐴,B,C$任意给定的三个非空集合，则从$A\times B$到$C$上的二元映射$f$，称为一个从$A\times B$到$C$的二元运算，即有$f：A\times B\to C$。当$A=B=C$时，称$f：A\times A\to A$为$𝑨$上的二元运算。  
【定义11.2】设$A_{1},A_{2},\cdots,A_{n},A$均为一个非空集合，从集合$A_{1}\times A_{2}\times\cdots\times A_{n}$到集合$A$的映射$f$称为一个从集合$A_{1}\times A_{2}\times\cdots\times A_{n}$到集合𝐴的$\pmb{n}$元运算，即有：$f$：$A_{1}\times A_{2}\times\cdots\times$$A_{n}\to A$。若有$\  A_{1}=A_{2}=\cdots=A_{n}=A$，则称$f$：$A\times A\times\cdots\times A\to A$为集合𝑨上的一个$n$元运算。当$n=1$时，称$f$：$A\rightarrow A$为集合𝑨上的一元运算。  
从上述定义可以看出，多元运算其实就是一类特殊的多元函数。 例如，三元函数：  
$$
*\!:R^{3}\rightarrow R\,,\,\,\,*\left(x,y,z\right)=z\,,\,\,\,\forall x,y,z\in R
$$  
就是一个三元运算，该运算表示三维空间上的点$(x,y,z)$到$z$轴上的投影。  
目前，多元运算在关系数据库的多元关系演算等领域具有重要的应用价值。 不过，多元运算是对二元关系的自然推广，与二元关系没有本质上的差异。  因此，我们主要考察一元运算和二元运算的概念与性质。  例如，整数集合$Z$ 上求相反数运算、幂集合上的求补运算、实矩阵集合上的求矩阵转置运算、命题集合中的非运算等等，都是一元运算。  与二元运算的情形完全相同，可以使用运算符或运算表表示一元运算，这里不再赘述。"
多源最短路径,算法,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.4.4 多源最短路径']","{'实体类型': '算法', '定义': '求解图中任意一对结点之间最短路径的算法', '基本思想': '通过逐次增加中介结点的途径，不断优化和更新图中每对结点之间的路径长度', '步骤': ['初始化操作', '将图中每个结点分别作为中介结点，更新路径长度和路径记录矩阵', '根据最终矩阵计算任意结点之间的最短路径长度和路径序列'], '应用': '求图中任意一对结点之间的最短路径'}",,3,"迪杰斯特拉算法解决的是单源最短路径问题，只能求出单独某个源点到其它结点最短路径，然而沃舍尔∙弗洛伊德算法则是求得这个图中任意对结点之间的最短路径长度。  
沃舍尔∙弗洛伊德算法的基本思想是通过逐次增加中介结点的途径，不断优化和更新图中每对结点之间的路径长度。首先，将$v_{1}$作为中介结点，据此更新图中仅以$v_{1}$作为中介结点的路径长度以及相应的路径记录。然后在$v_{1}$的基础上，进一步引入${{v}}_{2}$作为新增的中介结点，并更新图中仅以$v_{1}v_{2}$作为中介结点的路径长度和路径记录。依次类推，在$v_{1}v_{2}v_{3}\ldots v_{k}$作为中介结点的基础上，以$v_{k}$作为新增中介结点计算并更新图中以$v_{1}v_{2}v_{3}\ldots v_{k}$为中介结点的每对结点之间路径长度和路径记录。这样当$k=n$(𝑛为结点个数)时，便可求出图中每对结点的最短路径长度及其相应的路径记录。  
从上面描述的基本思想可以知道，在整个问题解决中有两个点非常重要，一个是路径长度，一个是路径记录，为了方便叙述，我们分别定义相应的矩阵用于记录数据，$D^{(k)}(v_{i},v_{j})$表示在考虑了$v_{1}v_{2}v_{3}\ldots v_{k}$作为中介结点的基础上，结点$v_{i}$与$v_{j}$的当前最短路径长度。$R^{(k)}(v_{i},v_{j})$ 是一个包含结点元素的矩阵，表示在考虑了$v_{1}v_{2}v_{3}\ldots v_{k}$作为中介结点的基础上，结点$v_{i}$与$v_{j}$的当前最短路径长度中必经的一个中间点。  
需要注意的是，在还没有考虑中介结点的最初情况时，应该按如下方法初始化$D$和$R$矩阵元素值，对于图中任意两个相邻结点$v_{i}$和$v_{j}$，即存在一条边$(v_{i},v_{j})$，边上权值为$w(v_{i},v_{j})$，那其长度为$D^{(0)}\big(v_{i},v_{j}\big)=w(v_{i},v_{j})$，否则规定$v_{i}$与$v_{j}$存在一条假想边$(v_{i},v_{j})$，令其长度为无穷大。另外，在尚未开始算法迭代时，将$\cdot R$矩阵每行内容分别置为$v_{j}(j=1,2,3\ldots n)$。  
下面以结点$v_{i}$到$v_{j}$为代表，详细介绍具体计算过程：  
首先，将$v_{1}$作为从$v_{i}$到$v_{j}$的中介结点，进行比较路径$\left(v_{i},v_{j}\right)$和$(v_{i},v_{1},v_{j})$长度的大小，若路径$\left(v_{i},v_{j}\right)$的长度不大于$\left(v_{i},v_{1},v_{j}\right)$的长度，那么取$(v_{i},v_{j})$为从$v_{i}$到$v_{j}$的当前最短路径，即$D^{(1)}\big(v_{i},v_{j}\big)=w(v_{i},v_{j})$，此时不需要更新路径记录矩阵$R$；若是路径$\left(v_{i},v_{1},v_{j}\right)$的长度较小，则取$\left(v_{i},v_{1},v_{j}\right)$为从$v_{i}$到$v_{j}$的当前最短路径，即：  
$$
D^{(1)}\big(v_{i},v_{j}\big)=w(v_{i},v_{1})+w\big(v_{1},v_{j}\big)
$$  
并将$v_{1}$暂时作为$v_{i}$到$v_{j}$的中间点，即$R^{(1)}{\bigl(}v_{i},v_{j}{\bigr)}=v_{1}.$。需要注意的是，当前最短路径中介结点序号不大于1，即当前最短路径只可能经由中介点$v_{1}$。  
对$v_{i}$到$v_{j}$的中介结点集合，再引入结点$v_{2}$，即$v_{i}$到$v_{j}$的中介结点为${v}_{1}$和$v_{2}$。首先确定$(v_{i},\ldots,v_{2})$和$(v_{2},\ldots,v_{j})$分别是当前找到的最短路径（只可能经由中介结点$v_{1}$），则$\left(v_{i},\ldots,v_{2},\ldots,v_{j}\right)$有可能是从$v_{i}$到$v_{j}$的最短路径（只可能经由中介结点$v_{1}$和$v_{2}$）。将其与当前从$v_{i}$到$v_{j}$的最短路径$(v_{i},\ldots,v_{j})$进行比较（只可能经由中介结点$v_{1}$），从中选出从${v}_{i}$到$v_{j}$的最短路径（此时只可能经由中介结点$v_{1}$和$v_{2}$），并按照上述的原则更新相应的$D$和$R$。如此下去，直到将图中所有结点加入${v}_{i}$到$v_{j}$的中介结点集合。  
对于一般情形， $(v_{i},\ldots,v_{k})$和$(v_{k},\ldots,v_{j})$分别是从${v}_{i}$到$v_{k}$和从${{v}}_{k}$到$v_{j}$的当前最短路径(中间路径只可能经过$v_{1}v_{2}v_{3}\ldots v_{k-1})$，则将$\left(v_{i},\ldots,v_{k},\ldots,v_{j}\right)$与从$v_{i}$到$v_{j}$的当前最短路径$\left(v_{i},\ldots,v_{j}\right)$（中间路径只可能经过$v_{1}v_{2}v_{3}\ldots v_{k-1})$）进行比较，其长度较短者便是从${v}_{i}$到$v_{j}$的当前最短路径（此时引入了$v_{k}$，故中间路径可能经由$v_{1}v_{2}v_{3}\ldots v_{k})$。若$(v_{i},\ldots,v_{k})$和$(v_{k},\ldots,v_{j})$ 组合起来的路径 $\left(v_{i},\ldots,v_{k},\ldots,v_{j}\right)$ 不大于引入中介结点 $v_{k}$ 的路径长度， 则当前路径长度矩阵 $.D$ 和路径记录矩阵$R$不做任何更新。否则：$\begin{array}{r}{D^{(k)}\big(v_{i},v_{j}\big)=w(v_{i},v_{k})+w\big(v_{k},v_{j}\big),\;\;R^{(k)}\big(v_{i},v_{j}\big)=}\end{array}$$v_{k}$。  
在中介结点集合中增加所有可能的中介结点后，最后求得最短路径的必然是从${v}_{i}$到$v_{j}$的最短路径。由$v_{i}$和$v_{j}$的任意性，可求得各对结点间的最短路径。  
具体地说，沃舍尔∙弗洛伊德算法的基本步骤如下：  
（1）首先进行初始化操作。  
![](images/81a82f8a70a1c69c5768fae83738a36908b9e06f149f4c5733693401ae15cac2.jpg)  
$$
R^{(0)}\big(v_{i},v_{j}\big)=v_{j}
$$  
（2）按如下的原则，将图中的每个结点$v_{k}(k=1,\!2,\dots,n)$分别作为中介结点，更新$D$和$R$矩阵，依次获得矩阵$D^{(1)},D^{(2)},\dots,D^{(n)}$和$R^{(1)},R^{(2)},\ldots,R^{(n)}$。  
(i)若$D^{(k-1)}\big(v_{i},v_{j}\big)>D^{(k-1)}(v_{i},v_{k})+D^{(k-1)}\big(v_{k},v_{j}\big),$  则，  
$$
D^{(k)}\!\left(v_{i},v_{j}\right)\!\!=\!\!D^{(k-1)}(v_{i},v_{k})\!+\!D^{(k-1)}\!\left(v_{k},v_{j}\right)\!;\,\,\,R^{(k)}\!\left(v_{i},v_{j}\right)=v_{k}
$$  
(ii)  若 $ D^{(k-1)}\!\left(v_{i},v_{j}\right)\leq D^{(k-1)}\!\left(v_{k},v_{j}\right)\!+\!D^{(k-1)}\!\left(v_{k},v_{j}\right)$ ，则，   $D^{(k)}\!\left(v_{i},v_{j}\right)\!\!=\!\!D^{(k-1)}\!\left(v_{i},v_{j}\right)\!;\,\,\,R^{(k)}\!\left(v_{i},v_{j}\right)=R^{(k-1)}\!\left(v_{i},v_{j}\right)$  
（3）根据矩阵${ D}^{(n)}$和$R^{(n)}$，计算任意结点之间的最短路径长度和路径序列。以$v_{i}$和$v_{j}$为例计算两者的最短路径序列：若$R^{(n)}=v_{k}$，则在$v_{i}$到$v_{j}$的最短路径中必有中间结点$v_{k}$，那么根据如下规则，分别向$v_{k}$两头追溯一定可以得到$v_{i}$到$v_{j}$的最短路径：  
(i) 向点$v_{i}$方向追溯可以得到：  
$$
R^{(n)}(v_{i},v_{k})=v_{k-1},\ R(v_{i},v_{k-1})=v_{k-2},...,\ R^{(n)}(v_{i},v_{k-m})=v_{i}
$$  
(ii) 向点$v_{j}$方向追溯可以得到：  
$$
R^{(n)}\big(v_{k},v_{j}\big)=v_{k+1},\ R^{(n)}\big(v_{k+1},v_{j}\big)=v_{k+2},...,\ R^{(n)}(v_{i},v_{k+s})=v_{j}
$$  
追溯方向图，如下图8-61 所示。  
![图8-61 通过路径矩阵寻找具体的最短路径  ](images/6a3ea39179dd4fb30e351249de4e2648087eaf5e2356569531de0cb959af6180.jpg)  
由此可见，通过路径长度矩阵$D$和路径记录矩阵$R$，可以求出图中任意一对结点之间的最短路径。"
多源最短路径算法,算法,['第八章  图的基本理论与算法'],"{'实体类型': '算法', '应用': '找到多个结点之间的最短路径'}",,1,"若用点表示现实世界中事物、点之间连线表示事物之间联系，则可画出一个图来形象地表达问题模型。事实上，若将思维浓缩，图是最简洁的思维轨迹；若将思维展开，图能描述最复杂的思维蓝本。因此，人类在很久以前就开始用图的方法记忆、分析和解决问题。然而，如果只停留在对一些具体图的讨论，那么人类就永远走不出经验主义的局限。幸运的是，十八世纪著名数学家欧拉创造性地将具体问题抽象为图模型，建立一套关于图的数学理论——图论，使图模型成为一种非常有效且非常有趣的数学工具，实现了形象思维与抽象思维的完美结合、理论性与实用性的完美结合。图模型作为一种特殊的二元关系，诠释了复杂的多对多关系，揭示了各结点之间错综复杂的网状拓扑结构，具有强大的知识表达能力。正是这种强大的表达能力使得图模型在解决诸多复杂问题中发挥至关重要、不可替代的作用。在计算机诞生之前，图模型主要用于解决一些游戏问题，例如迷宫问题、博弈问题、棋盘马经问题等等。随着计算机的诞生与兴起，图模型作为一种最基本的离散数学结构在计算机各个领域得到广泛应用，例如计算机网络路由问题、送快递最短路径问题、网站之间链接模型问题、工程预算关键路径问题、软件代码复杂度计算问题等等，都需要使用图论知识进行问题表示和求解。目前，图论及其算法已经成为计算机专业人员必须熟练掌握的一项基本知识。  
对于图这种基于连接策略的模型，自然会让人产生很多疑问，例如如何在计算机中实现这些图模型的表示和运算、沿着这些连接如何自动找到合适的路径从一个结点到达另外一个结点、能否自动计算出符合要求路径的个数、能否自动找到结点之间最短的连接路径、如何对图的结点或边进行自动遍历、如何通过图模型对实际问题建模等等。本章目标主要是通过系统地介绍和讨论图模型及其算法设计的基本知识，使得读者不仅能够找到上述问题的答案，而且能够较好地掌握图的基本理论及相关算法设计技术。本节首先学习图的概念与表示、图的运算与性质以及图的连通性质；然后介绍若干经典的图模型算法，包括图的遍历算法、单源和多源最短路径算法等；最后介绍图模型的应用。"
多重图,概念,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.2 图的定义与分类']","{'实体类型': '概念', '定义': '含有平行边的图'}",,3,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)"
大项,概念,"['第三章  命题演算与推理', '§ 3.4 命题公式的范式', '3.4.3 主合取范式', '一、大项的概念与性质']","{'实体类型': '概念', '定义': '对于任意一个含有n个命题变元的析取式G(P1,P2,...Pn)，若G(P1,P2,...Pn)中每个命题变元Pi与其否定¬Pi不同时出现，但是两者之一必须出现一次且仅出现一次，而且出现次序与P1,P2,...Pn的次序保持一致，则称该G(P1,P2,...Pn)为一个大项', '特点': '在表达形式上具有特殊限制的析取式，要求析取式中的所含变量都要以一定方式出现一次且仅出现一次，对于每个变量，要么以其自身形态出现，要么以其否定形态出现', '应用': '实现对命题公式中合取运算的一种规范表达，而且很容易实现对这种规范表达形式的枚举', '数量': '含有n个命题变元的大项有且仅有2^n个', '成假赋值': '每个大项都有且仅有一个成假赋值', '命名': '若成假赋值所对应的二进制数转化为十进制数为i，就将所对应大项记作Mi', '真值特点': '任意两个不同的大项的析取式为永真式，全体大项的合取式必为永假式'}",,4,"【定义3.25】对于任意一个含有$\cdot_{n}$个命题变元的析取式$G(P_{1},P_{2},\cdots P_{n})$，若 $G(P_{1},P_{2},\cdots P_{n})$中每个命题变元$P_{i}$与其否定$\neg P_{i}$不同时出现，但是两者之一必须出现一次且仅出现一次，而且出现次序与 $P_{1},P_{2},\cdots P_{n}$ 的次序保持一致，则称该 $G(P_{1},P_{2},\cdots P_{n})$ 为一个大项。  
显然，大项是一种在表达形式上具有特殊限制的析取式，要求析取式中的所含变量都要以一定方式出现一次且仅出现一次，对于每个变量，要么以其自身形态出现，要么以其否定形态出现。通过这种限制，就可以实现对命题公式中合取运算的一种规范表达，而且很容易实现对这种规范表达形式的枚举。  
例如，（1）含有一个命题变元$P$的大项有且仅有如下2 个，即：$P$和$\neg P$（2）含有两个命题变元$P$, $Q$的大项有且仅有如下4 个，即：  
$$
P\lor Q\,,\;\,\neg P\lor Q\,,\;\,P\lor\neg Q\,,\;\,\neg P\lor\neg Q
$$  
（3）含有三个命题变元$P,~Q,~H$$R$的大项有且仅有如下8 个，即：  
$$
P\lor Q\lor R\,,\;\;P\lor Q\lor\neg R\,,\;\;P\lor\neg Q\lor R\,,\;\;P\lor\neg Q\lor\neg R\,,
$$  
$$
\neg P\lor Q\lor R\,,\;\;\neg P\lor Q\lor\neg R\,,\;\;\neg P\lor\neg Q\lor R\,,\;\;\neg P\lor Q\lor R\,,
$$  
易证：含有$\cdot_{n}$个命题变元大项有且仅有$2^{n}$个。其中每个大项都有且仅有一个成假赋值。若成假赋值所对应的二进制数转化为十进制数为𝑖，就将所对应大项记作$M_{i}$。  
对于含有两个命题变元$P$, $Q$的4 个以及含有三个命题变元$P$, $Q,\ R$的8 个大项，其按成假赋值方式的具体命名情况如表3-23 和表3-24 所示。注意大项下标：$P$、$Q\,,\ R$用0 表示；$\neg P、\,\,\neg Q、\,\,\neg R.$用1 表示。  
表3-23  二个命题变元的大项
![](images/b117159e2be17852c5b29f9e449d5deebdd08f3ecdbbe717331edc2f8ebcbe45.jpg)  
表3-24 三个命题变元的大项
![](images/9bbd0802cf95876287308868a0bba4b3a99b82a451062e84aca896f9d29d7f8b.jpg)  
由大项的真值取值特点易知，任意两个不同的大项的析取式为永真式，全体大项的合取式必为永假式，即有：$M_{i}\vee M_{j}\Leftrightarrow T(i\neq j)$；$M_{0}\wedge M_{1}\wedge\ldots\wedge M_{2^{n}-1}\Leftrightarrow F_{\circ}$。"
子代数,概念,"['第十一章  抽象代数结构通论', '§ 11.1 代数结构的基本概念', '11.1.1 数学结构与代数结构']","{'实体类型': '概念', '定义': '由代数结构的子集及其上的运算构成的代数结构'}",,3,"代数结构作为四大基本数学结构之一，它以运算作为处理机制，在整个数学理论体系和计算机数学建模中占据非常重要的作用。代数结构是一种非常古老的数学结构，具有几千年发展历程，从最初初等代数逐步发展到大代数，然后进一步发展到抽象代数，目前正朝着泛代数的方向发展。本小节主要介绍抽象代数的由来及其基本知识结构。  
用计算机解决实际问题，一般需要对问题进行抽象并建立相应的数学模型，然后在此基础上将对实际问题的求解转化为对数学模型的求解。 因此，数学模型是用计算机解决实际问题的基础。现实问题纷繁复杂、变化万千，所建立的数学模型自然也是五花八门，多种多样，让人无所适从。值得欣慰的是，尽管我们面对的数学模型复杂多样，但从结构上看，所有这些数学模型都建立在四种基本的数学结构基础之上。  
这四种基本数学结构分别为：表示元素之间空间关系的拓扑结构，如图模型、树模型就是一些拓扑结构；表示元素之间运算关系的代数结构，如初等代数、向量代数、矩阵代数、命题代数、集合代数等都是代数结构；表示元素规模度量性质的测度结构，如高等数学里函数的微分和积分都是测度结构，它们主要计算面积、体积、弧长、速度等；表示元素之间次序关系的偏序结构，如整数的整除关系、集合的包含关系等偏序关系都是偏序结构。  
任何一个数学结构都是由载体、处理机制和处理规则这三个基本要素组成：  
（1）载体集合 对于任何一个数学结构，需要定义一些抽象的元素作为处理对象，这些抽象元素组成的集合构成数学结构的载体。载体集合是数学结构存在的基础或平台。  
（2）处理机制 为了实现对数学结构载体中元素的处理，需要定义一些处理机制，不同的数学结构具有不同的处理机制。例如：偏序结构是一种关系结构，它以元素之间的次序关系或者比较关系作为处理机制；代数结构是一种运算结构，它以元素之间的运算作为处理机制；拓扑结构是一种分布结构，它以元素之间的空间分布作为处理机制；测度结构则是一种度量结构，它以元素的规模度量作为处理机制。  
（3）处理规则 为使定义出来的数学结构满足一些合理性要求以及能够在处理实际问题中发挥作用，避免出现一些矛盾或荒诞的处理结果，还必须制定一些处理规则对处理机制做一些必要的限制。在现代数学的公理化系统中，通常称这些处理规则称为公理。不同的数学结构具有不同的处理规则，例如偏序结构限制元素之间的关系必须满足自反性、反对称性和传递性，这些限制或者性质构成了偏序结构公理系统；再如代数结构则是规定元素之间的运算必须满足结合律、交换律、分配律等运算性质。  
数学运算最早起源于算术运算，即使用具体的整数或分数进行四则运算。随着科学技术的不断发展，人们逐步意识到这种方法不能满足对一般性规律的认识。因此，采用抽象的字母来代替具体的整数和分数进行运算以获得通用性结果，并称之为代数运算或简称为代数。在微积分出现之前的数千年历史中，对代数运算的研究一直占据数学研究的核心地位。那时人们普遍信奉一种所谓的万能法则，即世界上所有问题都可以转化为数学问题，所有数学问题都可以转化为代数问题，所有代数问题都可以转化为方程问题。  
因此，在很长一段历史时期内，人们对数学的研究基本上都是对代数学的研究，对代数学的研究基本上是方程或方程组解法的研究。解方程是那个时期内所有数学家的中心任务，大家都非常期望能够通过使用代数运算的方法找到方程或方程组的通用求解公式。这种努力在线性方程组领域取得了非常完美的结果，并由初等代数逐步衍生出线性代数。但是，对于一元高次方程通用求解方法的研究并不是很顺利，对于次数高于四次的一元方程始终找不到通用求解公式或求解方法。一些非常著名的数学家，例如欧拉、高斯、拉格朗日等都对此做了大量非常艰苦的研究，但均告失败。  
在寻求五次方程通用求解方法的过程中，年仅17 岁的法国天才少年伽罗瓦在1828 年提出群的概念，运用群的思想证明了五次方程通用求解公式是不存在的，并给出了五次方程系数在满足一定条件下若干特殊解法，由此一举解决了困扰数学家长达200 多年的数学问题。伽罗瓦取得成功的关键在于不仅将运算对象进行抽象化，而且对运算本身进行抽象，在抽象对象和抽象运算的基础上通过构造一些特殊抽象代数结构进行求解。这个思想在当时实在过于超前以至于没有得到柯西、傅里叶、泊松等著名数学家的认可，泊松的判词是“完全不能理解”。 1832 年5 月31 日年仅21 岁的伽罗瓦死于决斗。在决斗之前，他把关于五次方程代数求解的研究成果写成长信，留给了人类。14 年后，法国数学家刘维尔整理并发表了伽罗瓦的遗作，人们才理解并惊叹他那超越时代的天才思想和巧妙构思。  
至此以后，人们对代数的研究内容由方程或方程组的求解技巧转变为对代数运算性质和运算结构的研究，通过对运算和运算对象进行抽象的方式实现对所有运算依其运算性质进行分类或归类，并将伽罗瓦的群论迅速发展成为一门称之为抽象代数结构的崭新数学分支。 抽象代数结构的诞生，把代数学从传统的初等代数发展到现代的抽象代数，由此打开了现代代数学的大门，开创了代数学研究的新纪元。因此，抽象代数结构通常也称为近世代数以区别于之前的初等代数。若无特别说明，我们通常将抽象代数结构简称为代数结构。  
经过一百多年的发展，抽象代数结构已经形成一个如图11-1 所示的知识体系。对于一个代数系统，我们不仅可以主动设计出它的运算并考察相应的运算规则，而且还可以通过分别对其载体集合进行相关改造或运算得到相应的子代数、积代数和商代数，可以通过映射的方式考察不同代数结构之间的区别与联系，还可根据运算性质对代数结构进行分类，形成若干典型抽象代数系统，如群、环、域、格等。  
![](images/37d476cf884c29ed65924bc021cb612de43bab4df8b1196f64e96cad4f61a01f.jpg)
图11-1 抽象代数结构的知识体系  
代数结构作为一种特殊的数学结构，具有载体、处理机制和处理规则这三个基本要素。如前所述，代数结构的载体就是由一些抽象对象为元素组成的集合，并通过运算机制实现对集合中元素的处理。所谓运算，其实就是通过映射的手段从已有元素中构造出新的元素。载体和运算统称为代数结构的成分。代数结构的处理规则即为运算性质。  
既然代数结构的载体是一个集合，那么就可以考虑通过一定方式由这个集合派生出新的集合并据此构造出新的代数结构。例如，可以考察其子集以及在子集上的运算，得到子代数的概念和性质；可以对作为载体的集合做笛卡尔集构成一个新的集合，并在新集合上定义相关运算，得到积代数的概念和性质；可以通过构造等价关系的方法实现对集合载体的划分，构成一个以等价类为元素的商集，并在这个商集上定义相关运算，得到商代数的概念和性质。子代数、积代数和商代数是构造和研究代数结构的基本方法论。  
当然，还可以考察两个代数结构之间的相似性与差异性。对于任意两个代数系统，可以在这两个代数结构的载体(集合)上建立一种保运算的映射，由此考察代数结构之间的联系。如果存在这种保运算映射，则称这两个代数系统同态。如果这种保运算的映射还是双射，则称这两个代数系统同构。同态和同构是考察代数结构之间联系的基本工具。  
依据代数结构的运算性质，可以将各种具体代数结构划分为若干抽象类型。典型的抽象代数结构类型主要有仅含一个二元运算的半群与群、含有两个二元运算的环与域，以及格与布尔代数。这些典型抽象代数结构构成代数结构知识体系的主要内容。"
子代数系统,概念,"['第十一章  抽象代数结构通论', '§ 11.1 代数结构的基本概念', '11.1.3 代数结构与子代数']","{'实体类型': '概念', '产生方法': '通过载体集合子集产生', '普适性': '具有普适性的基本方法', '实例': '环代数系统产生子环、域代数系统产生子域、格代数系统产生子格'}",,3,"如前所述，代数结构由作为结构载体的集合、作为结构处理机制的运算和作为结构处理规则的运算律这三个部分组成。其中集合和运算是代数结构的构成成分，是代数结构的实体部分，而运算律则是代数结构中的公理系统或规章制度。这里着重介绍代数结构集合和运算，下一节将详细讨论代数结构的运算律。  
假设𝐴是一个任意给定的非空集合，则对于该集合上的一元运算或二运算$^{\ast}$，即：  
$*: A\to A \text{或} *: A\times A\to A$  
其运算结果并没有跑到集合𝐴之外，也就是说运算结果仍然是集合𝐴中的某个元素。这种性质通常称为运算的封闭性。由此可见，集合𝐴上的一元运算或二运算$^*$满足封闭性。  
根据以上讨论，可以得到如下关于代数结构的定义：  
【定义11.3】假设𝐴是一个任意给定的非空集合，$*_{1},*_{2},*_{3},\cdots,*_{k}$是𝐴上$k$个一元或二元运算，则集合𝐴与其上的$k$ 个运算$*_{1},*_{2},*_{3},\cdots,*_{k}$构成的整体称为一个代数结构或代数系统，简称为代数，记为$\langle A,\;\;*_{1},*_{2},*_{3},\cdots,*_{k}\rangle$。  
不难看出：$\langle N,+\rangle,\langle Z,+\rangle,\langle R,-\rangle,\langle N,+,\ \cdot\rangle,\langle R,+,\ \cdot\rangle:$都是代数结构，其中$+$，−，⋅都是普通的加法、减法和乘法；令𝑆表示所有含两个变量的命题公式组成的集合，则$\langle S,\ \wedge,\vee,\lnot\rangle$是一个代数结构，通常称之为命题代数；令𝐴表示任意一个给定的非空集合，则$\langle P(A),\;\cap,\;\cup, -\rangle$一个代数结构，通常称之为集合代数；令$M_{n}(R)$表示实数集合$R$上所有$n\times n$阶矩阵组成的集合，则$\langle M_{n}(R),+,\ \cdot\rangle$是一个代数结构，通常称之为矩阵代数。  
从上述讨论和定义可以看出，正是因为集合𝐴上的一元运算和二运算满足封闭性，才保证了集合𝐴能够成为整个代数结构的载体。由此可知，代数结构肯定也是具有封闭性的。  
例如$\langle N,+\rangle$显然是一个代数结构，而且普通‘$+$’运算在自然数N 上是具有封闭性。但是，在整数除法就不是整数集合𝑍上的二元运算，因为两个整数之商不一定是整数，不满足不封闭性，因此$ Z,+$不是代数结构。  
值得注意的是，有些离散数学书将代数结构和代数系统作为两个不同概念的进行来讨论。 具体地说，就是将运算性质的总和作为代数结构，将代数系统看成是代数结构和集合的集成。本书为了与数学结构的相关理论保持一致，默认代数结构和和代数系统是同一个概念，在后续的介绍和讨论中会不加区分地使用代数结构或代数系统这个两个名词。  
事实上，通过载体集合子集产生子代数系统是一个具有普适性的基本方法，每种具体的代数系统都可以通过这种方法产生子代数系统。例如，环代数系统可以产生各种子环、域代数系统可以产生各种子域、格代数系统可以产生各种子格等等。 其实，还可对代数系统的载 体集合做其它分析以产生新的代数系统，例如可通过集合的笛卡尔产生积代数、通过集合的上的等价关系产生商代数等，后面将会进一步讨论与此相关的内容，这里不再赘述。"
子半群,概念,"['§ 12.1 半群的概念与性质', '12.1.2  方幂与循环半群', '12.1.1 半群与含幺半群', '第十二章 典型抽象代数结构']","{'实体类型': '概念', '定义': '假设⟨G, *⟩是一个半群，S是G的一个非空子集且运算*对S封闭，则称⟨S, *⟩是⟨G, *⟩的一个子半群；半群G的子集H与运算*构成的半群', '性质': 'H是G的子集且满足半群性质', 'name': '子半群'}",,3,"半群是一种比较简单而基本的抽象代数结构，要求其载体上的二元运算满足封闭性和结合律。半群的具体定义如下：  
【定义12.1】假设$G$是任意给定的一个非空集合，$*$为$G$上的一个二元运算且满足结合律，即对于$\forall $$\mathrm x,\mathrm{y,z\in~}G$，成立：  
$$
(x\circ y)\circ z=x\circ(y\circ z)\quad\text{(12-1)}
$$  
则称由𝐴和*组成的二元代数结构$\langle G,\ *\rangle$是一个半群。  
半群是一种非常常见的抽象代数结构，例如$\langle R, +\rangle_、\ \langle R,\ \times\rangle_、\ \langle P(A),\ \cup\rangle_、\ \langle P(A),\ \cap\rangle_、$$\langle A^{A},\ \circ\rangle$、$\langle M_{n}(R),\ +\rangle$、$\langle M_{n}(R)$, ⋅〉等，都是半群。  
在上述定义中，由于运算$*$为集合$G$上的二元运算，故对$G$满足运算的封闭性。因此，运算满足封闭性和结合律是半群的两个基本特征。另外，一般习惯上使用字母$G$表示群代数结构的载体集合，我们一般遵循这种习惯并总是假定$G$为非空集合。  
【定义12.2】假设$\langle G,\ *\rangle$是任意给定的一个半群，如果$\langle G,\ *\rangle$中含有关于运算${\ast}$的单位元𝑒，则称$\langle G,\ *\rangle$是一个含幺半群或独异点，记为$\langle G,\ *,\ e\rangle$。  
从上述定义可以看出，所谓含幺半群，其实就是一种含有幺元或单位元的特殊半群。例如$\mathsf\langle R,\ +\rangle_、\ \langle R,\ \times\rangle_、\ \langle P(A),\ \cup\rangle_、\ \langle P(A),\ \cap\rangle_、\ \langle A^{A},\ \circ\rangle_、\ \langle M_{n}(R),\ +\rangle_、\ \langle M_{n}(R),\ \cdot\}$ 等，都是含幺半群，0、1、空集$\varnothing$、全集$𝐴$、恒等映射、零矩阵、单位矩阵分别是其幺元。但是，$\langle R^{+},~+\rangle$则不是一个含幺半群，因为$R^{+}$作为正实数集合没有运算${+}$的单位元。  
【定义12.3】假设$\langle G,\ *\rangle$是一个半群，$S$是$G$的一个非空子集且运算$^*$对𝑆封闭，则称$\langle S,\ *\rangle$是$\langle G,\ *\rangle$的一个子半群；假设$\langle G,*,e\rangle$是一个含幺半群，$S$是$G$的一个非空子集且运算$^*$对𝑆封闭，则称$\langle S,*,e\rangle$是$\langle G,*,e\rangle$的一个子含幺半群。  
例如，对于含幺半群$\left<Z,\ +\right>$，令$Z_{n}=\{n x|x\in Z\}$，则对于$ n$取任何自然数，$\left\langle Z_{n},\ +\right\rangle$显然是$\left\langle Z,\ +\right\rangle$含幺子半群，且整数0 既是$\langle Z,\ +\rangle$的单位元也是$\left\langle Z_{n},\ +\right\rangle$的单位元。  
【定义12.4】假设$\langle G,*\rangle$和$\langle H,\circ\rangle$是任意给定的两个半群，如果存在从$G$到$H$的保运算映射  
$\psi$，即对于$\forall x,y\in G$，满足：  
$$
\psi(x*y)=\psi(x)\circ\psi(y)\quad\text{(12-5)}
$$  
则称$\psi$为从$\langle G,*\rangle$到$\langle H,\circ\rangle$的一个同态映射，并称$\langle G,*\rangle$与$\langle H,\circ\rangle$为同态。若$\psi$为单射，则称$\langle G,*\rangle$与$\langle H,\circ\rangle$为单同态；若$\psi$为满射，则称$\langle G,*\rangle$与$\langle H,\circ\rangle$为满同态；若$\psi$为双射，则称$\mathcal{\Psi}$为同构映射，并称$\langle G,*\rangle$与$\langle H,\circ\rangle$为同构。  
【定义12.5】假设$\langle G,*,e\rangle$和$\langle H,\circ,r\rangle$是任意给定的两个含幺半群，如果存在从$G$到$H$的保运算映射$\psi$，即对于$\forall x,y\in G$，满足：  
$$
\psi(x*y)=\psi(x)\circ\psi(y)\mathbb且\psi(e)=r
$$  
则称$\psi$为从$\langle G,*,e\rangle$到$\langle H,\circ,r\rangle$的一个同态映射，并称$\langle G,*,e\rangle$与$\langle H,\circ,r\rangle$为同态。若$\psi$为单射，则称 $\langle G,*,e\rangle$ 与 $\langle H,\circ,r\rangle$ 为单同态；若 $\psi$ 为满射，则称 $\langle G,*,e\rangle$ 与 $\langle H,\circ,r\rangle$ 为满同态；若 $\psi$ 为双射，则 称$\psi$为同构映射，并称$\langle G,*,e\rangle$与$\langle H,\circ,r\rangle$为同构。  
由于同构或同态的代数结构之间具有很多相同或相似的性质，因此，可在一般抽象代数结构与某个具体的代数结构之间建立一种同构或同态关系，通过比较直观考察具体代数结构的运算性质来研究一般抽象代数结构的运算性质，从而得到普适性的结论。这是研究和考察抽象代数结构的一种典型方法。下面结合具体实例介绍这种方法："
子含幺半群,概念,"['第十二章 典型抽象代数结构', '§ 12.1 半群的概念与性质', '12.1.1 半群与含幺半群']","{'实体类型': '概念', '定义': '假设⟨G, *, e⟩是一个含幺半群，S是G的一个非空子集且运算*对S封闭，则称⟨S, *, e⟩是⟨G, *, e⟩的一个子含幺半群', '示例': '⟨Z_n, +⟩是⟨Z, +⟩的子含幺半群'}",,3,"半群是一种比较简单而基本的抽象代数结构，要求其载体上的二元运算满足封闭性和结合律。半群的具体定义如下：  
【定义12.1】假设$G$是任意给定的一个非空集合，$*$为$G$上的一个二元运算且满足结合律，即对于$\forall $$\mathrm x,\mathrm{y,z\in~}G$，成立：  
$$
(x\circ y)\circ z=x\circ(y\circ z)\quad\text{(12-1)}
$$  
则称由𝐴和*组成的二元代数结构$\langle G,\ *\rangle$是一个半群。  
半群是一种非常常见的抽象代数结构，例如$\langle R, +\rangle_、\ \langle R,\ \times\rangle_、\ \langle P(A),\ \cup\rangle_、\ \langle P(A),\ \cap\rangle_、$$\langle A^{A},\ \circ\rangle$、$\langle M_{n}(R),\ +\rangle$、$\langle M_{n}(R)$, ⋅〉等，都是半群。  
在上述定义中，由于运算$*$为集合$G$上的二元运算，故对$G$满足运算的封闭性。因此，运算满足封闭性和结合律是半群的两个基本特征。另外，一般习惯上使用字母$G$表示群代数结构的载体集合，我们一般遵循这种习惯并总是假定$G$为非空集合。  
【定义12.2】假设$\langle G,\ *\rangle$是任意给定的一个半群，如果$\langle G,\ *\rangle$中含有关于运算${\ast}$的单位元𝑒，则称$\langle G,\ *\rangle$是一个含幺半群或独异点，记为$\langle G,\ *,\ e\rangle$。  
从上述定义可以看出，所谓含幺半群，其实就是一种含有幺元或单位元的特殊半群。例如$\mathsf\langle R,\ +\rangle_、\ \langle R,\ \times\rangle_、\ \langle P(A),\ \cup\rangle_、\ \langle P(A),\ \cap\rangle_、\ \langle A^{A},\ \circ\rangle_、\ \langle M_{n}(R),\ +\rangle_、\ \langle M_{n}(R),\ \cdot\}$ 等，都是含幺半群，0、1、空集$\varnothing$、全集$𝐴$、恒等映射、零矩阵、单位矩阵分别是其幺元。但是，$\langle R^{+},~+\rangle$则不是一个含幺半群，因为$R^{+}$作为正实数集合没有运算${+}$的单位元。  
【定义12.3】假设$\langle G,\ *\rangle$是一个半群，$S$是$G$的一个非空子集且运算$^*$对𝑆封闭，则称$\langle S,\ *\rangle$是$\langle G,\ *\rangle$的一个子半群；假设$\langle G,*,e\rangle$是一个含幺半群，$S$是$G$的一个非空子集且运算$^*$对𝑆封闭，则称$\langle S,*,e\rangle$是$\langle G,*,e\rangle$的一个子含幺半群。  
例如，对于含幺半群$\left<Z,\ +\right>$，令$Z_{n}=\{n x|x\in Z\}$，则对于$ n$取任何自然数，$\left\langle Z_{n},\ +\right\rangle$显然是$\left\langle Z,\ +\right\rangle$含幺子半群，且整数0 既是$\langle Z,\ +\rangle$的单位元也是$\left\langle Z_{n},\ +\right\rangle$的单位元。  
【定义12.4】假设$\langle G,*\rangle$和$\langle H,\circ\rangle$是任意给定的两个半群，如果存在从$G$到$H$的保运算映射  
$\psi$，即对于$\forall x,y\in G$，满足：  
$$
\psi(x*y)=\psi(x)\circ\psi(y)\quad\text{(12-5)}
$$  
则称$\psi$为从$\langle G,*\rangle$到$\langle H,\circ\rangle$的一个同态映射，并称$\langle G,*\rangle$与$\langle H,\circ\rangle$为同态。若$\psi$为单射，则称$\langle G,*\rangle$与$\langle H,\circ\rangle$为单同态；若$\psi$为满射，则称$\langle G,*\rangle$与$\langle H,\circ\rangle$为满同态；若$\psi$为双射，则称$\mathcal{\Psi}$为同构映射，并称$\langle G,*\rangle$与$\langle H,\circ\rangle$为同构。  
【定义12.5】假设$\langle G,*,e\rangle$和$\langle H,\circ,r\rangle$是任意给定的两个含幺半群，如果存在从$G$到$H$的保运算映射$\psi$，即对于$\forall x,y\in G$，满足：  
$$
\psi(x*y)=\psi(x)\circ\psi(y)\mathbb且\psi(e)=r
$$  
则称$\psi$为从$\langle G,*,e\rangle$到$\langle H,\circ,r\rangle$的一个同态映射，并称$\langle G,*,e\rangle$与$\langle H,\circ,r\rangle$为同态。若$\psi$为单射，则称 $\langle G,*,e\rangle$ 与 $\langle H,\circ,r\rangle$ 为单同态；若 $\psi$ 为满射，则称 $\langle G,*,e\rangle$ 与 $\langle H,\circ,r\rangle$ 为满同态；若 $\psi$ 为双射，则 称$\psi$为同构映射，并称$\langle G,*,e\rangle$与$\langle H,\circ,r\rangle$为同构。  
由于同构或同态的代数结构之间具有很多相同或相似的性质，因此，可在一般抽象代数结构与某个具体的代数结构之间建立一种同构或同态关系，通过比较直观考察具体代数结构的运算性质来研究一般抽象代数结构的运算性质，从而得到普适性的结论。这是研究和考察抽象代数结构的一种典型方法。下面结合具体实例介绍这种方法："
子图,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.2.1 图的基本运算', '三、子图与补图运算']","{'实体类型': '概念', '定义': '设 $G=\\\\langle V,E\\\\rangle$，$G^{\\prime}=\\\\langle V^{\\prime},E^{\\prime}\\\\rangle$是两个图，若 $V^{\\prime}\\\\subseteq V$且 $E^{\\prime}\\\\subseteq E$，则称 $G^{\\prime}$是 $G$ 的子图，$G$ 是 $G^{\\prime}$的母图', '分类': '若 $G^{\\prime}\\\\subseteq\\\\mathbf{G}$且 $G^{\\prime}\\\\neq{\\\\bf G}$，则称 $G^{\\prime}$ 是 $G$ 的真子图；若 $G^{\\prime}\\\\subseteq G$且 $V^{\\prime}=V$，则称 $G^{\\prime}$是 $G$ 的生成子图'}",,4,"在使用图模型对实际问题建模和求解的过程中，经常需要分析考察图的某个特定部分的结构，将图中某个或某些特定的部分提取出来作为一个图模型进行研究，由此得到如下关于图模型的子图运算的若干概念，具体如下：  
【定义8.13】设 $G=\langle V,E\rangle$，$G^{\prime}=\langle V^{\prime},E^{\prime}\rangle$是两个图（同为无向图或者有向图），则有：  
（1）若 $V^{\prime}\subseteq V$且 $E^{\prime}\subseteq E$，则称 $G^{\prime}$是 $G$ 的子图，$G$ 是 $G^{\prime}$的母图，记为 $G^{\prime}\subseteq\mathbf{G}$ 。若 $G^{\prime}\subseteq\mathbf{G}$且 $G^{\prime}\neq{\bf G}$（即$V^{\prime}\subset V$或 $E^{\prime}\subset\mathbf{E})$），则称 $G^{\prime}$ 是 $G$ 的真子图；若 $G^{\prime}\subseteq G$且 $V^{\prime}=V$，则称 $G^{\prime}$是 $G$ 的生成子图。  
（2）设$V_{1}$是𝑉的非空子集，即 $\varnothing\neq V_{1}\subseteq V$，则以 $V_{1}$ 为结点集，以两个端点均在 $V_{1}$ 中的全体边为边集的 $G$ 的子图称为由$V_{1}$导出的导出子图，记为 $G[V_{1}]$。  
（3）设$E_{1}$是$E$的非空子集，设$\varnothing\neq E_{1}\subseteq E$，以 $E_{1}$为边集，以 $E_{1}$ 中所有边关联的全部结点为结点集的 $G$ 的子图成为由 $E_{1}$导出的导出子图，记为 $G[\ E_{1}]$。  
由上述定义可以看出，生成子图与其母图具有相同的结点集合。因此，一个图的生成子图一般是该图的主体结构。对于一个复杂的图模型，一般通过采用适当的方法构造其符合要求的生成子图实现对模型的化简和对问题的求解。  
不难看出，对于任一给定非空有限结点集合，由这些结点构成的零图和完全图分别表达了两个极端构图情形，两者之间具有互补性，相当于集合论中的空集和全集。 由此可以得到图模型补运算的概念。 首先给出如下关于完全图的定义：  
【定义8.14】假设$G=\langle V,E\rangle$是一个具有$\cdot_{n}$个结点的无向简单图，如果图中任意两个结点之间都有边相联结，则称该图为$^n$阶无向完全图，简称为完全图，记为$K_{n}$；假设$G=\langle V,E\rangle$是一个具有$\cdot_{n}$个结点的有向简单图，如果图中任意两个结点之间都有方向相反的两条边相联结，则称该图为$n$阶有向完全图，在不发生混淆的情况下也记为$K_{n}$。  
由上述定义可知，对于完全图来说，其邻接矩阵除主对角线上元素均为0 之外，其余元素均为1。显然，$n$阶无向完全图的边数为$n(n-1)/2$ ，$n$阶有向完全图的边数为$\ n(n-1)$。 图8-17 给出了无向完全图$K_{3}$，$K_{4}$，$K_{5}$和有向图$K_{3}$。  
下面给出图模型补运算的定义：  
【定义8.15】设 $G=\langle V,E\rangle$ 是 $n$ 阶简单图，以 $V$ 为顶点集，以所有能使 $G$ 成为完全图 $K_{n}$ 的新加边为边集的图称为 $G$ 相对于 $K_{n}$ 的补图，简称为 $G$ 的补图，记为$\bar{G}$。  
显然，若图$G$的邻接矩阵为$A_{G}=(a_{i j})_{n\times n}$，则其补图$\bar{G}$的邻接矩阵为$A_{\bar{G}}=(\bar{a}_{i j})_{n\times n}$为：  
$$
\\\bar{a}_{i j}=f(x)=\left\{\begin{array}{r l r}&{~~~~~~~~1-a_{i j},~i\neq j}&\\ &{0,~~~~~~~~~~~~~~~~~~i=j}&\end{array}\right.
$$  
例如，对于图8-18 所示的图 $G_{1}$和图 $G_{2}$，图 $G_{1}$ 是图 $G_{2}$ 的补图，图 $G_{2}$ 也是图 $G_{1}$的补图。显然， $K_{n}$ 的补图是 $n$ 阶零图，反之亦然。  
![图8-18 补图运算 ](images/bc253e401f30298f9209681ddc8b93ec627ca9bfb8d5b9c17929af79e1390112.jpg)"
子格,概念,"['第十二章 典型抽象代数结构', '§ 12.5 格的概念与性质', '12.5.2 格的基本性质']","{'实体类型': '概念', '定义': '设代数系统⟨L,*,⊕⟩是一个格，对于L的任意一个非空子集S，若运算*和⊕在S上满足封闭性，则称⟨S,*,⊕⟩是⟨L,*,⊕⟩的一个子格'}",,3,"对偶性是格结构最基本的特征。考察格的基本性质一般从格结构的对偶特征入手。从偏序关系的角度看，格$\langle L,\leq\rangle$结构在集合 $L$上定义的偏序关系$\leq$显然是可逆的。具体地说，对于集合$ L$上的偏序关系≤，其逆关系$\geq$也是集合$ L$上的偏序关系。由于将偏序集$\langle L,\leq\rangle$的哈斯图做一个上下翻转就得到偏序集$\langle L,\geq\rangle$的哈斯图，故对集合$L$的任意子集$𝐴$，$A$在偏序$\langle L,\leq\rangle$中的上确界是$𝐴$在偏序$\langle L,\geq\rangle$中的下确界，$A$在$\langle L,\leq\rangle$中的下确界是$𝐴$在$\langle L,\geq\rangle$的上确界。因为二元关系的逆关系保持原关系的自反性、反对称性和传递性不变，所以$\langle L,\geq\rangle$也是格。  
通常将格$\langle L,\leq\rangle$和格$\langle L,\geq\rangle$称为互为对偶的格。对偶格之间具有紧密联系，例如格$\langle L,\leq\rangle$的保交运算对应格$\langle L,\geq\rangle$的保联运算，反之亦然。假如在格$\langle L,\leq\rangle$和格$\langle L,\geq\rangle$中，$*$和$\oplus$分别代表格的下确界和上确界运算，如果在关于$\langle L,\leq\rangle$的命题中，分别用$*$、⊕、$≤$代替关于$\langle L,\geq\rangle$命题中的⊕、$∗$、$≥$，那么两个命题的真伪必定保持一致性。这就是对偶原理。  
【定理12.33】设$\langle L,\leq\rangle$是任意给定的一个格，关系“$≤$”是“$\geq\!\!$的逆关系，则对$\forall$ $a,b,c,d\in$$L$，有如下14 条基本性质：  
（1）自反性：  $a\leq a;\ \ a\geq a.$  
（2）反对称性：$a\leq b$且$b\leq a\Rightarrow a=b$；$a\geq b$且$b\geq a\Rightarrow a=b$.  
（3）传递性  $a\leq b$且$b\leq c\Rightarrow a\leq c$；$a\geq b$且$b\geq c\Rightarrow a\geq c$.  $(4)a*b\leq a;\;\;a\oplus b\geq a;\;\;a*b\leq b;\;\;a\oplus b\geq b.$  
（5）$c\leq a$且$c\leq b\Rightarrow c\leq a*b$；$c\geq a$且$c\geq b\Rightarrow c\geq a\oplus b$.  
（6）交换律：  $a*b=b*a;\ a\oplus b=b\oplus a$  
（7）结合律：  $a*(b*c)=(a*b)*c;\;\;a\oplus(b\oplus c)=(a\oplus b)\oplus c$  
（8）吸收律：  $a*(a\oplus b)=a;\ a\oplus(a*b)=a.$  
（9）幂等律：  $a*a=a;\;\;a\oplus a=a.$  
(10)  $a\leq b\Longleftrightarrow a*b=a\Longleftrightarrow a\oplus b=b\,.$  
（11）$a\leq b$且$c\leq d\Rightarrow a*c\leq b*d$；$a\leq b$且${\mathfrak{c}}\leq d\Rightarrow a\oplus c\leq b\oplus d$.  
（12）偏序对运算的保序性：  $a\leq b\Rightarrow a*c\leq b*c;\;\;a\leq b\Rightarrow a\oplus c\leq b\oplus c$  
（13）确界运算对偏序的分配不等式：
$$
a\oplus(b*c)\leq(a\oplus b)*(a\oplus c);\,\,\,a*(b\oplus c)\geq(a*b)\oplus(a*(c)
$$  
（14） 确界运算对偏序的模不等式：$a\leq c\Longleftrightarrow a\oplus(b*c)\leq(a\oplus b)*c$  
格是一个特殊的代数系统，那么是否存在子格和格同态呢，答案是肯定的。设集合$𝑆$是集合$ L$的子集，从格的定义角度出发，格要求运算必须满足交换律、结合律和吸收律，如果这些运算律在集合$L$上满足，那么在$𝑆$上也一定满足，因此只要集合$𝐴$是非空的，且运算在$𝑆$上满足封闭性，那么$𝑆$就为$L$的子格。一般地，有如下的定义：  
【定义12.28】设代数系统$\langle L,*,\oplus\rangle$是一个格，对于$L$的任意一个非空子集$𝑆$，若运算$*$和$\oplus$在$𝑆$上的满足封闭性，则称$\langle S,*,\oplus\rangle$是$\langle L,*,\oplus\rangle$的一个子格，简称$𝑆$是$L$的子格。  
上面给出了代数格的子格定义，那么对于偏序格的子格又改如何定义呢。事实上若非空集合$\textstyle S\subseteq L$，且$\langle L,\leq\rangle$是偏序格，由第六章的偏序关系知道$\langle S,\leq\rangle$一定是偏序集，甚至也可能是格，但不一定是子格，因为子格要对运算封闭。由此得到如下偏序子格的定义：  
【定义12.29】设$\langle L,\leq\rangle$是一个格，$S\subseteq L$，若𝑆满足：  
（1）$S\neq\emptyset$；（2）对$\forall\;\;a,b\in S,\;\;<L,\leq\;>$的保交和保联运算都有： $a*b=G L B\{a,b\}\in S;\;\;a\oplus b=L U B\{a,b\}\in S$  
则称$\langle S,\leq\rangle$是$\langle L,\leq\rangle$的一个子格，简称$𝑆$是$L$的子格。  
利用代数系统中的同态和同构概念，分别可以得到格的同态和同构的定义：  
【定义12.30】设$\langle L,\land,\lor\rangle$和$\langle S,*,\oplus\rangle$是两个格， $f$是从$L$到$𝑆$的映射，若对$\forall\;\;x,y\in L$，有：  
$$
f(x\wedge y)=f(x)*f(y);\ f(x\vee y)=f(x)\oplus(y)
$$  
则称 $f$ 为从格 $\langle L,\land,\lor\rangle$ 到格 $\langle S,*,\oplus\rangle$ 的格同态映射，简称格同态。如果 $f$ 分别是单射、满射和双 射，$f$分别称为单格同态、满格同态和格同构，将格$ L$到$L$的同态称为$ L $的自同态。"
子问题重叠性质,性质,"['第二章  整数与算法设计基础', '§ 2.4 算法设计策略与应用', '2.4.3  回溯与动态规划', '二、动态规划策略']","{'实体类型': '性质', '定义': '在用递归算法由自顶向下的方式对问题求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次', '应用': '当再次需要计算已经计算过的子问题时，无需再次计算，只需查表即可'}",,4,"【定义2.25】动态规划是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。  
当问题的数学模型是递推式时，按理应该使用递归算法求解。但是，递归算法有时存在大量重复计算，使得算法时间复杂度过高。实际上，不同子问题的个数往往只有多项式数量级，若将已经计算过的子问题中间数据和计算结果记录下来，需要某个子问题的解时就直接调用，则可避免大量的重复计算，甚至可以获得多项式时间的算法计算量。动态规划算法正是遵循这种思想，将求解过程中所有子问题的解全部记录下来，不管该子问题以后是否会被其它子问题用到。可以看出，动态规划采用的是以空间换取时间的策略。  
动态规划法的有效性依赖于求解问题的两个重要性质，即：最优子结构性质和子问题重叠性质。  
$\bullet$ 最优子结构性质  如果问题最优解所包含子问题的解也是最优的，则称该问题具有最优子结构性质。最优子结构性质是动态规划求解问题的必要条件。  
$\bullet$ 子问题重叠性质  子问题重叠性质是指在用递归算法由自顶向下的方式对问题求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。当再次需要计算已经计算过的子问题时，无需再次计算，只需查表即可。 当确定待解决的问题可以使用动态规划算法求解时，通常按照以下几个步骤进行：  
（1）把所有最优化问题分成若干个阶段，找出最优解的性质，并刻画其结构特性。  
（2）将问题发展到各个阶段时所处的不同状态表示出来，确定各个阶段状态之间的递推（或递归）关系，并确定初始（边界）条件。  
（3）应用递推（或递归）关系求解最优值。  
（4）根据计算最优值时得到的信息，构造最优解。  
以上（1）~（3）步是动态规划算法解决问题的基本步骤，在只需要计算最优值的问题中，完成这三个基本步骤即可。  
如果问题需要构造最优解，仍需执行第（4）步；此时，在第（3）步通常需要记录更多的信息，以便在步骤（4）中有足够信息快速地构造出最优解。"
子集,概念,"['三、集合与集合的关系', '3.有限子集与幂集', '1.1.2 集合的概念与表示', '四、常用的特殊集合', '§ 1.1 集合的基本知识', '第一章  集合与计数基础']","{'实体类型': '概念', '定义': ['对于任意两个集合A和B，若B中的每个元素都是A中的元素，则称B包含于A（或A包含B），记为B⊆A，亦称B是A的子集', '集合A的任意一个子集B，若B中含有m个元素，则称B为A的m元子集'], '特点': '具有特殊性质', 'name': '子集'}",,4,"如前所述，集合中凡是相同的元素都看成是同一个元素，而且集合中元素之间的排列次序也不加区分，或者说是无序的。如此一来，集合就完全取决于集合中的元素。换句话说，对于任意两个集合，如果这两个集合中具有完全相同的元素，那么这两个集合就是完全一样的。或者说，这两个集合是相等的。于是得到如下关于集合相等的外延性原理：  
【定理1.1】（外延性原理）对于任意的集合$A$ 和集合$B$，$\pmb{A}$ 与$\pmb{B}$ 相等当且仅当两者具有相同元素；或者说，$\pmb{A}$ 与$\pmb{B}$ 相等当且仅当$A$ 中每个元素都属于$B$ 且$B$ 中每个元素都属于$A$。如果集合$A$ 与$B$ 相等，则记为$A=B$；否则，如果$A$ 与$B$ 不相等，则记为$A\ne B$。  
【定理1.2】集合的相等关系具有如下三条基本性质： （1）自反性：对于任意给定的集合$A$，成立$A{=}A$； （2）对称性：对于任意给定的两个集合$A$ 和$B$，若有$A{=}B$，则有$B{=}A$；  
（3）传递性：对于任意三个集合$A$、$B$、$C$，若有$A{=}B$ 且$B{=}C$，则有$_{A=C}$  
由【例题1.9】可以看出，集合$C$ 中的每个元素都是集合$A$ 中的元素，此时$A$ 完全包含了$C$，可将$C$ 看成是$A$ 的一个部分，由此得到如下集合的包含关系和子集的概念：  
【定义1.2】对于任意两个集合$A$ 和$B$，若$B$ 中的每个元素都是$A$ 中的元素，则称$\pmb{B}$ 包含于$\pmb{A}$（或$\pmb{A}$ 包含$\pmb{B}$），记为$B\subseteq A$，亦称$\pmb{B}$ 是$\pmb{A}$ 的子集，称符号$\subseteq$为集合之间的包含关系。如果$B$ 不能被$A$ 所包含，则称$\pmb{B}$ 不是$\pmb{A}$ 的子集，记为$B\nsubseteq A$。  
【定理1.3】集合的包含关系具有如下三条基本性质：（1）自反性：对于任意给定的集合$A$，都成立$A\subseteq A$  
（2）反对称性：对于任意两个集合$A$ 和$B$，$A{=}B$当且仅当$A\subseteq B$且$B\subseteq A$（3）传递性：对于任意三个集合$A$、$B$、$C$，若$A\subseteq B$且$B\subseteq C$，则$A\subseteq C$  
【定义1.3】对于任意两个集合$A$ 和$B$，如果$B\subseteq A$且$A\neq B$，则称$B$ 是$A$ 的真子集，记为$\mathrm{B}\subset\mathrm{A}$，并称符号$\subset$为集合之间的真包含关系。"
子集像,定义,"['第七章 函数与特殊函数', '§ 7.1 函数的基本概念', '7.1.1 函数的集合定义']","{'实体类型': '定义', '定义': '设A和B是任意给定的两个非空集合，A1和B1分别是A和B的任意两个非空子集合，f是一个从A和B函数，令f(A1)=f(x)|x in A1，称f(A1)为|A1在f下的像；令f^-1(B1)=x|x in A Lambda f(x) in B1，称f^-1(B1)为B1在f下的完全原像'}",,3,"在初等数学或高等数学中，函数的概念从变量角度提出，而且主要局限于在实数集。计算机相关领域处理的对象除了实数之外，还有很多其它对象，例如矩阵、向量、命题等等，而且主要面对的是各种可数的离散对象。为此，需要扩展初等数学或高等数学中函数概念的含义，从集合与关系的角度给函数下一个更加本质性的定义，具体如下：  
【定义7.1】设$𝐴$和$B$是任意两个非空集合，$f$是从$𝐴$到$B$的关系。若对$\forall x\in A$都存在唯一的$y\in B$，满足$\langle x,y\rangle\in f$，则称关系$f$为从$𝐴$到$B$的函数关系，简称为函数或映射,记为 $f\!:\!A\longrightarrow$  
$B$或$y=f(x)$，并称$x$为$f$的自变量或源点，$𝑦$为$ x$在$f$下的函数值或像点。集合$𝐴$称为$𝑓$的定义域，记为$dom$ $f=A$，所有像点组成的集合称为$f$的值域或$f$的像，记为$ran $$f$或$f(A)$。  
从上述定义可以看出，函数$f$是从集合$𝐴$到$B$的一种特殊二元关系，这种二元关系所包含序偶的第一元素为自变量，第二元素为因变量或函数值。函数的定义域就是关系的前域$𝐴$，要求关系中所有序偶的第一元素互不相同并且要取遍集合$𝐴$中的每个元素。作为刻画作为函数的本质单值特征，要求对于关系中的任意两个序偶，若它们的第一元素相同，则第二元素必须相同。具体地说，如果一个从集合$𝐴$到$B$二元关系$f$，那么它必须满足如下几个性质：  
(1)$\langle x,y\rangle\in f\Leftrightarrow y=f(x);\qquad\mathrm{(2)}\ \langle x,y\rangle\in f\wedge\langle x,z\rangle\in f\Rightarrow y=z;$  
（3）$|f|=|A|$； （4）$f(x)$表示一个变值，$f$代表一个集合，故$f\neq f(x)$  
如果关系$f$具备下面两种情况之一，那么$f$就不是函数关系：  
（1）存在元素$a\in A$,在$B$中没有像；（2）存在元素$a\in A$, 在$ B$中至少有两个像。  
例如，关系$\begin{array}{r}{F_{1}=\{\langle x_{1},y_{1}\rangle,\langle x_{2},y_{1}\rangle,\langle x_{3},y_{2}\rangle,\langle x_{4},y_{3}\rangle\}}\end{array}$是函数，而如下关系：
$$
F_{2}=\{\langle x_{1},y_{1}\rangle,\langle x_{2},y_{1}\rangle,\langle x_{3},y_{2}\rangle,\langle x_{1},y_{2}\rangle\}
$$  
则不是函数，因为同时有$\langle x_{1},y_{1}\rangle\in F_{2}$和$\langle x_{1},y_{2}\rangle\in F_{2}$  
由上述例题可知，函数作为一种特殊关系或特殊集合，其集合运算的结果可能不再是函数。因此，要慎用函数的集合运算。另一方面，由于函数是一种特殊子集，因此可用集合相等的概念来定义两个函数相等，具体定义如下：  
【定义7.2】设$𝐴$和$B$是任意两个非空集合，$f,g$是两个从$A$到$B$的函数关系，如果$f$和$g$相互包含，即有$f\subseteq g\wedge g\subseteq f$，则称函数$f$和函数$g$相等，记为$f=g$。换句话说，如果$dom $$f=$$dom$ $g$且对$\forall x\in\mathsf{d o m}$ $f=\mathrm{dom}$ $g$有$f(x)=g(x)$，称$f$与$g$相等。  
从上述定义可以看出，两个函数相等不仅要求它们的对应关系相等，而且要求它们的定义域也要相同，两者缺一不可。  
现考察有限集合上函数的计数问题，即算出有限集合上有多少种不同函数。设集合$ A=$$\{a_{1},a_{2},\cdots,a_{n}\}$，$B=\{b_{1},b_{2},\cdots,b_{m}\}$，则要确定一个从$𝐴$到$B$的函数$ f$，就必须对$𝐴$中每个元素$a_{i}$，在$B$中找到一个唯一确定的元素$b_{m_{i}}$与之对应。显然，对于$𝐴$中每个元素$a_{i}$都有$|B|=m$种选择$b_{m_{i}}$的方式。而集合𝐴中共有$|A|=n$个元素，故根据乘法原理，得到所有方式的组合数为$m^{n}$或$|B|^{|A|}$种。即从$A$到$B$的不同函数一共有$|B|^{|A|}$种。由此得到如下定理：  
【定理7.1】设$𝐴$和$B$是任意两个非空有限集合，则从$A$到$B$一共有$|B|^{|A|}$种不同的函数。  
根据上述定理，可得到如下函数集定义及其表示方法：  
【定义7.3】设$𝐴$和$B$是任意两个非空集合，将从$A$到$B$的一切函数构成的集合称为从$𝐴$到$B$的函数集或函数空间，记为$B^{A}$。即有： $B^{A}=\{f|f\colon\ A\to B\}.$。  
根据上述定义，当$𝐴$和$B$是非空有限集合时，显然有：$|B^{A}|=|B|^{|A|}$  
通过以上分析不难发现，当𝐴和$B$为有限集时，函数和一般关系具有以下区别：  
（1）个数差异：从$𝐴$到$B$的不同关系有$2^{|A|\times|B|}$个，从$A$到$B$的不同函数仅有$|B|^{|A|}$个。  
（2）基数不同：每个函数基数均为$|A|$即$|f|=|A|$，关系的基数却为从0 到$\vert A\vert\times\vert B\vert$  
（3）第一元素的差别：关系的第一个元素可以相同，函数的第一个元素不能相同。  
下面进一步考察函数对定义域子集的映射性质，首先给出如下子集像的相关概念：  
【定义7.4】设$𝐴$和$B$是任意给定的两个非空集合，$A_{1}$和$B_{1}$分别是$𝐴$和$B$的任意两个非空子集合，即有$A_{1}\subseteq A,B_{1}\subseteq B$。$f$是一个从$𝐴$和$B$函数，即$f\colon A\to B$。  
（1）令$f(A_{1})=\{f(x)|x\in A_{1}\}$，称$f(A_{1})$为$|A_{1}$在$f$下的像。当$A_{1}=A$时，$f(A)$为$f$的像。  
（2）令$ f^{-1}(B_{1})=\{x|x\in A\Lambda f(x)\in B_{1}\}$，称$f^{-1}(B_{1})$为$B_{1}$在$f$下的完全原像。  
在上述定义中显然有：$f(A_{1})\subseteq B$且$f^{-1}(B_{1})\subseteq A$。  
下面定理给出了子集像的集合运算性质：  
【定理7.2】设$𝐴$和$B$是任意给定的两个非空集合，$X$和$𝑌$是集合$ A$的任意两个非空子集，即有$X\subseteq A,Y\subseteq A$。$f$是一个从$A$和$B$函数，即$f\colon A\to B$。则有：  
$$
(1)f(X\cup Y)=f(X)\cup f(Y);\ \ (2)\ \,f(X\cap Y)\subseteq f(X)\cap f(Y)
$$  
上述定理的第（2）结论等号不成立。  
事实上，设$A=\{a,b,c\}$，$B=\{1,\!2,\!3\}$，$f\colon X\to Y$为：$f(a)=1$，$f(b)=f(c)=2.$令$X=\{a,b\}$，$Y=\{c\}$，则有：$A\cap B=\emptyset$，$f(A\cap B)=\emptyset$。但是：  
$$
f(A)\ \cap f(B)=\{1,2\}\cap\{2\}\neq\emptyset
$$  
故$f(A)\ \cap f(B)\ \neq f(A\cap B)$。这表明只能成立：$f(A\cap B)\subseteq f(A)\cap f(B)\,。$  
至此，我们从二元关系的角度给了函数相关概念的本质定义，并以关系模型为基本工具分析讨论了函数的若干基本性质，为函数理论奠定了一个比较坚实的数学基础。下面就从以上函数概念及基本性质为出发点进一步介绍和讨论函数的相关理论及应用。"
存在推广规则(EG 规则),规则,"['第四章  谓词演算与推理', '§ 4.4 谓词逻辑的推理', '4.4.1 谓词公式推演系统']","{'实体类型': '规则', '基本形式': '(1)$P(y)\\\\Rightarrow\\\\ \\\\exists x\\\\ P(x);$ (2)$P(c)\\\\Rightarrow\\\\ \\\\exists x\\\\ P(x)$', '基本含义': '如果对于个体域中某个或某些指定的个体$.c$满足$P(c)$为真，那么必有 $\\\\exists x P(x)$为真'}",,3,"谓词公式的推演系统与命题公式的推演系统非常类似，主要由有效推理的基本概念、事实库、公理库和推理规则这几个部分组成。事实库和公理库构成谓词公式推理的基本依据，推理规则是谓词公式推理的核心机制。谓词公式推演系统的公理库和推理规则不仅涵盖了命题公式的推演系统的所有相关内容，而且更加丰富、复杂。  
谓词公式有效推理的概念与命题逻辑推理非常相似，具体定义如下：  
【定义4.22】设$G_{1},G_{2}\cdots G_{n}$，$\mathrm{H}$ 是一些谓词公式，如果它们满足下列性质：对于这些公式的任意一个解释I，$G_{1},G_{2}\cdots G_{n}$在该解释下同时为真的情况下$H$在该解释下也为真，则称公式$G_{1},G_{2}\cdots G_{n}$可有效推出公式$\mathrm{H}$，或称由$G_{1},G_{2}\cdots G_{n}$得到H 的逻辑推理为有效推理，记为$G_{1},G_{2}\cdots G_{n}\Rightarrow H$，并称$G_{1},G_{2}\cdots G_{n}$为推理前提，$\mathrm{H}$ 为$G_{1},G_{2}\cdots G_{n}$的逻辑结论。  
从上述定义不难看出，谓词逻辑推理的形式结构与命题逻辑推理的形式结构一致，是命题逻辑推理的自然推广。  
【定理4.6】谓词公式$H$是谓词公式$G_{1},G_{2}\cdots G_{n}$的逻辑结论，当且仅当下式：  
$$
G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\to H\tag{4-14}
$$  
为有效公式。  
上述定理表明谓词逻辑有效推理的过程就是证明谓词逻辑蕴含式的过程，这与命题逻辑的有效推理完全一致。  
谓词公式的推理依据主要是谓词公式推演系统中的事实库和公理库。事实库由具体谓词逻辑推理实例的所有前提条件以及推理过程中产生的有效中间结论组成；公理库不仅包含命题逻辑推演系统的公理库，即关于命题公式的24 个基本等值式和9 个基本永真蕴含式，而且还包含了关于谓词公式的所有基本等值式和基本逻辑蕴含式，具体可参加本章4.2.4 节中相关内容，这里不再一一罗列。  
现在着重介绍谓词公式的推理规则。由于在谓词合式公式中含有大量的量词，直接对其进行推理显然十分不便。为此，谓词公式推演系统引入一些专门处理量词的规则，以便在需要的时候可以方便地增加或消除量词。谓词逻辑中主要有全称特指、存在特指、全称推广和存在推广这四条基本的量词处理规则，其中全称特指和存在特指消除量词的规则，全称推广和存在推广则是添加量词的规则。下面具体介绍这些规则：  
1．全称特指规则(简称US 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)\forall x\ P(x)\Rightarrow\ P(y);\ (2)\forall x\ P(x){\Rightarrow}\ P(c)
$$  
US 规则的基本含义是：如果$\forall x\;\;P(x)$为真，那么对于论域中任何指定的个体$.c$，必有${P(c)}$为真。其中，$P$ 是谓词，(1)中的$y$ 是任意不在$P(x)$中约束出现的个体变量；(2)中的c为个体域中任意指定的一个个体常量。  
当谓词公式$P(x)$中不含任何量词和其它个体变量时，$US $规则显然不需要附加任何限制条件。但是，若$P(x)$中包含量词或其它个体变量时，(1)式中的约束“$y$ 是任意不在$P(x)$中约束出现的个体变量”就是必须的。例如，设$P(x)=\exists y(x<y)$，则$P(x)$在实数域上显然是真命题。但是，当$P(x)$中的$x$取𝑦时得到的$P(y)=\exists y(y<y)$显然是假命题。因此，限制引入的变量“不是在$P(x)$中约束出现的个体变量”是任何规则在引入变量时必需遵守的约定。  
2．存在特指规则(简称ES 规则)
$$
\exists x\ P(x)\Rightarrow\ P(c)
$$  
ES 规则的基本含义是：如果$\exists x$ $P(x)$为真，那么在个体域中必然至少存在某一个个体𝑐，使得$P(c)$为真。其中，$c$ 为个体域中使$P$ 成立的特定个体常量。  
当谓词公式$P(x)$中自由变量只是$x$的时候，上述规定可以保证使用ES 规则引入个体符号$c$ 的正确性。但是，如果谓词公式$P(x)$还含有其它自由个体变量，例如还有自由变量𝑦，那么使用ES 规则引入的符号c必须是以𝑦为自变量的个体函数，即$C(y)$。此外，还应当注意，在应用ES 规则时，其指定的个体$c$ 并不是任意含义下的自由变量，$c$ 的本质含义是某个或某些个体。因此，每次使用ES 规则指定的特定个体不能用之前的ES 规则或US 规则确定的个体替代，否则就会引起个体指代的混淆和错误。因为通常不能保证某次ES 指定的个体能够与其它次ES 或US 指定的个体之间具有必然的联系。  
3．全称推广规则(简称UG 规则)：  
$$
P(\boldsymbol{y})\Rightarrow\ \forall\boldsymbol{x}\ \ P(\boldsymbol{x})
$$
UG 规则的基本含义是：如果个体变量$y$在个体域内取到每一个个体时都有$P(y)$为真，那么必有$\forall x\;\;P(x)$为真。这里要求$x$既不是$P(y)$中约束变量也不是$P(y)$中的自由变量，即要求个体变量$x$不能在$P(y)$中出现。  
4．存在推广规则(简称EG 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)P(y)\Rightarrow\ \exists x\ P(x);\ (2)P(c)\Rightarrow\ \exists x\ P(x)
$$  
UG 规则的基本含义是：如果对于个体域中某个或某些指定的个体$.c$满足$P(c)$为真，那么必有 $\exists x P(x)$为真。其中，(1)式要求$P(y)$中无自由变量$x$；(2)式中要求$c$为个体域中的某个或某些个体常量。  
由以上分析可知，上述四个规则表面上看起来非常简单，但要能够做到真正理解并正确使用则不是一件容易的事情，实际使用时往往稍不注意就会出现错误。下面举例说明："
存在特指规则(ES 规则),规则,"['第四章  谓词演算与推理', '§ 4.4 谓词逻辑的推理', '4.4.1 谓词公式推演系统']","{'实体类型': '规则', '基本形式': '$\\\\exists x\\\\ P(x)\\\\Rightarrow\\\\ P(c)$', '基本含义': '如果$\\\\exists x$ $P(x)$为真，那么在个体域中必然至少存在某一个个体𝑐，使得$P(c)$为真'}",,3,"谓词公式的推演系统与命题公式的推演系统非常类似，主要由有效推理的基本概念、事实库、公理库和推理规则这几个部分组成。事实库和公理库构成谓词公式推理的基本依据，推理规则是谓词公式推理的核心机制。谓词公式推演系统的公理库和推理规则不仅涵盖了命题公式的推演系统的所有相关内容，而且更加丰富、复杂。  
谓词公式有效推理的概念与命题逻辑推理非常相似，具体定义如下：  
【定义4.22】设$G_{1},G_{2}\cdots G_{n}$，$\mathrm{H}$ 是一些谓词公式，如果它们满足下列性质：对于这些公式的任意一个解释I，$G_{1},G_{2}\cdots G_{n}$在该解释下同时为真的情况下$H$在该解释下也为真，则称公式$G_{1},G_{2}\cdots G_{n}$可有效推出公式$\mathrm{H}$，或称由$G_{1},G_{2}\cdots G_{n}$得到H 的逻辑推理为有效推理，记为$G_{1},G_{2}\cdots G_{n}\Rightarrow H$，并称$G_{1},G_{2}\cdots G_{n}$为推理前提，$\mathrm{H}$ 为$G_{1},G_{2}\cdots G_{n}$的逻辑结论。  
从上述定义不难看出，谓词逻辑推理的形式结构与命题逻辑推理的形式结构一致，是命题逻辑推理的自然推广。  
【定理4.6】谓词公式$H$是谓词公式$G_{1},G_{2}\cdots G_{n}$的逻辑结论，当且仅当下式：  
$$
G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\to H\tag{4-14}
$$  
为有效公式。  
上述定理表明谓词逻辑有效推理的过程就是证明谓词逻辑蕴含式的过程，这与命题逻辑的有效推理完全一致。  
谓词公式的推理依据主要是谓词公式推演系统中的事实库和公理库。事实库由具体谓词逻辑推理实例的所有前提条件以及推理过程中产生的有效中间结论组成；公理库不仅包含命题逻辑推演系统的公理库，即关于命题公式的24 个基本等值式和9 个基本永真蕴含式，而且还包含了关于谓词公式的所有基本等值式和基本逻辑蕴含式，具体可参加本章4.2.4 节中相关内容，这里不再一一罗列。  
现在着重介绍谓词公式的推理规则。由于在谓词合式公式中含有大量的量词，直接对其进行推理显然十分不便。为此，谓词公式推演系统引入一些专门处理量词的规则，以便在需要的时候可以方便地增加或消除量词。谓词逻辑中主要有全称特指、存在特指、全称推广和存在推广这四条基本的量词处理规则，其中全称特指和存在特指消除量词的规则，全称推广和存在推广则是添加量词的规则。下面具体介绍这些规则：  
1．全称特指规则(简称US 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)\forall x\ P(x)\Rightarrow\ P(y);\ (2)\forall x\ P(x){\Rightarrow}\ P(c)
$$  
US 规则的基本含义是：如果$\forall x\;\;P(x)$为真，那么对于论域中任何指定的个体$.c$，必有${P(c)}$为真。其中，$P$ 是谓词，(1)中的$y$ 是任意不在$P(x)$中约束出现的个体变量；(2)中的c为个体域中任意指定的一个个体常量。  
当谓词公式$P(x)$中不含任何量词和其它个体变量时，$US $规则显然不需要附加任何限制条件。但是，若$P(x)$中包含量词或其它个体变量时，(1)式中的约束“$y$ 是任意不在$P(x)$中约束出现的个体变量”就是必须的。例如，设$P(x)=\exists y(x<y)$，则$P(x)$在实数域上显然是真命题。但是，当$P(x)$中的$x$取𝑦时得到的$P(y)=\exists y(y<y)$显然是假命题。因此，限制引入的变量“不是在$P(x)$中约束出现的个体变量”是任何规则在引入变量时必需遵守的约定。  
2．存在特指规则(简称ES 规则)
$$
\exists x\ P(x)\Rightarrow\ P(c)
$$  
ES 规则的基本含义是：如果$\exists x$ $P(x)$为真，那么在个体域中必然至少存在某一个个体𝑐，使得$P(c)$为真。其中，$c$ 为个体域中使$P$ 成立的特定个体常量。  
当谓词公式$P(x)$中自由变量只是$x$的时候，上述规定可以保证使用ES 规则引入个体符号$c$ 的正确性。但是，如果谓词公式$P(x)$还含有其它自由个体变量，例如还有自由变量𝑦，那么使用ES 规则引入的符号c必须是以𝑦为自变量的个体函数，即$C(y)$。此外，还应当注意，在应用ES 规则时，其指定的个体$c$ 并不是任意含义下的自由变量，$c$ 的本质含义是某个或某些个体。因此，每次使用ES 规则指定的特定个体不能用之前的ES 规则或US 规则确定的个体替代，否则就会引起个体指代的混淆和错误。因为通常不能保证某次ES 指定的个体能够与其它次ES 或US 指定的个体之间具有必然的联系。  
3．全称推广规则(简称UG 规则)：  
$$
P(\boldsymbol{y})\Rightarrow\ \forall\boldsymbol{x}\ \ P(\boldsymbol{x})
$$
UG 规则的基本含义是：如果个体变量$y$在个体域内取到每一个个体时都有$P(y)$为真，那么必有$\forall x\;\;P(x)$为真。这里要求$x$既不是$P(y)$中约束变量也不是$P(y)$中的自由变量，即要求个体变量$x$不能在$P(y)$中出现。  
4．存在推广规则(简称EG 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)P(y)\Rightarrow\ \exists x\ P(x);\ (2)P(c)\Rightarrow\ \exists x\ P(x)
$$  
UG 规则的基本含义是：如果对于个体域中某个或某些指定的个体$.c$满足$P(c)$为真，那么必有 $\exists x P(x)$为真。其中，(1)式要求$P(y)$中无自由变量$x$；(2)式中要求$c$为个体域中的某个或某些个体常量。  
由以上分析可知，上述四个规则表面上看起来非常简单，但要能够做到真正理解并正确使用则不是一件容易的事情，实际使用时往往稍不注意就会出现错误。下面举例说明："
存在量词,概念,"['4.1.3  量词与特性谓词', '一、量词的概念', '第四章  谓词演算与推理', '§ 4.1 个体词、谓词与量词', '二、量词的展开与否定']","{'实体类型': '概念', '定义': ['量词的一种，表示变量x个体域中至少存在一个个体', '表示个体域中至少存在一个个体使得谓词为真的命题'], '记法': '∃x', '性质': '取值为真当且仅当个体域中至少存在一个个体使得谓词为真；取值为假当且仅当个体域中所有个体使得谓词为假'}",,4,"如前所述，若给谓词中每个变量分别指定确定个体，则谓词就变成谓词填式并由此成为一个具体命题。事实上，除了直接给变量赋值之外，还可通过其它方法实现对变量的限制或者约束，使得谓词具有明确具体的含义而变成命题，即具有命题谓词式的具体命题。  
例如，对于前述苏格拉底三段论中的命题“所有人都是要死的”，句中的主语“人”其实并不是一个具体的个体常量，而是一个变量，但是整个句子却是一个真命题。原因是句中的“人”受到“所有的”这个词的限定或者约束，使得整个语句具有明确的含义。  
同理，对于“所有的老虎都吃人”、“有一些自然数是素数”、“有一些动物是哺乳动物”、“所有人都长着黑头发”等等之类的陈述句，其主语尽管是变量，但是都受到“所有的”、“有一些”之类词的约束或限定，具有明确的含义和指代，因此这些陈述句都是命题。  
这些能够对谓词中变量进行约束或限定的词，我们称之为量词。其具体定义如下：  
【定义4.7】对于给定的谓词$P(x)$，若个体变量$x$在其个体域内的所有赋值都使得$P(x)$的取值为真，则称$P(x)$得到全称量化，记为：$\forall x P(x)$。其中$\forall$称为全称量词，$\forall$后面的$x$ 称为其作用变量，$\forall x$的含义为“对于变量$x$ 个体域中的每个个体…”。  
【定义4.8】对于给定的谓词$P(x)$，若个体变量$x$在其个体域内至少存在一个赋值都使得$P(x)$的谓词填式取值为真，则称$P(x)$得到存在量化，记为：$\exists x P(x)$。其中∃称为全称量词，∃后面的$x$ 称为其作用变量，$\exists x$的含义为“变量$x$ 个体域中至少存在一个个体…”。"
孤立结点,概念,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.2 图的定义与分类']","{'实体类型': '概念', '定义': '不与任何结点相邻接的结点'}",,3,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)"
安全素数,概念,"['第二章  整数与算法设计基础', '§ 2.2 同余算术及其应用', '2.2.3 整数加密算法']","{'实体类型': '概念', '定义': '满足特定条件的素数，用于RSA算法中p和q的选择', '条件': '1）p和q要足够长，在长度上应相差几位，且二者之差与p和q位数相近；2）p-1和q-1的最大公约数要尽量小；3）p-1和q-1均应至少含有一个大的素数因子'}",,3,"为防止机密信息被泄露或破坏，需采用数据加密技术对其进行保护。数据加密的基本思想是对原始数据加以伪装，使非法接入者无法理解信息的真正含义，基本过程就是对原来为明文信息或数据按某种算法进行处理，使其成为不可读的一段代码，称为密文，使其只能在输入相应密钥之后才能显示出本来内容。数据加密通常分为对称式加密和非对称式加密两大类。本节介绍两种基于整数理论的经典加密算法，一种是名为仿射加密算法的对称加密算法，另一种是名为RSA 的非对称加密算法。  
仿射加密算法又称为凯撒加密算法，是一种简单且广为人知的加密技术。它是一种替换加密技术，基本思想如下：首先使用0 到25 之间的数字表示A 到Z 这26 个字母。然后，对于每个不大于25 的非负整数$\cdot p$，定义其加密函数值$f(p)$为$\{0,1,2,\ \cdots,25\}$中某个数字。加密函数$f(p)$的有多种定义方法，例如可采用如下加密函数：  
$$
f(p)=(p+3)\;{\bmod{\,}}26
$$  
对于上述加密函数，此时用整数$(p+3)\,\mathrm{mod}\,26$代表的字母替代由整数$p$表示的字母实现加密。例如，对“WELCOME TO HEFEI”进行加密，首先用数字代替字母，然后使用加密函数$f(p)=(p+3)\mod 26$ 代替$p$，翻译成字母后，得到获得到的加密信息为：“ZHOFRPH VR KHIHL”具体过程如下：  
表2-3 凯撒密码的加密过程
![](images/168580ee1913d8c32220b048da1875515ce367981f5bce7472f95af1471231b8.jpg)  
解密则需要使用加密函数的$f(p)$反函数 $f^{-1}(p)$  
$$
f^{-1}(p)=(p-3){\bmod{\,}}26
$$  
解密时需将加密信息转换成数字，然后使用$f^{-1}(p)$把$\{0,1,2,\ \cdots,25\}$中整数$\cdot p$恢复成信息原文对应的整数，之后再将数字装换成字母获得原文。  
RSA 算法由三位数学家Rivest、Shamir 和Adleman 于1977 年共同提出，是至今最为广泛使用的非对称加密算法，特别适合于对通过互联网传送的数据进行加密，通常于数字签名等场合。RSA 算法使用整数模余运算性质生成公钥和私钥，并进行加密和解密。RSA 算法原理基于欧拉定理和费马小定理，为此首先介绍这两个定理。  
【定理2.29】（欧拉定理）设$m$ 是任一正整数，$a$ 是任一与$m$ 互素的整数，则有：  
$$
a^{\varphi(m)}\equiv1({\bmod{\ m}})\tag{2-15}
$$  
其中$\varphi(m)$是欧拉函数。  
如果上述猜想能够成立，则提供了一个非常有效的素数判定方法。但是遗憾的是，上述猜想并不成立。事实上，$p$ 为只要是素数，则其必满足上式，但反之不然。法国数学家给出了如下称之为费马小定理更一般结论：  
【定理2.30】（费马小定理）假设$p$ 是一个任意给定的素数，则对于任意整数$a$，有：  
$$
a^{p}\equiv a({\bmod{\ p}})\tag{2-16}
$$  
特别地，当$a$与$p$ 互素时，有：$a^{p-1}\equiv1({\bmod{\ p}})$。  
下面介绍RSA 算法的基本原理和具体计算过程。RSA 算法理论基础是同余算术以及欧拉定理和费马小定理，其安全性依赖于大整数素因子分解的困难性，即已知整数$n$ 是两个大素数$p$ 和$q$ 的乘积，则难以在可接受的时间范围内通过$n$ 的素因子分解方法获得$p$ 和$q$ 的取值。RSA 算法的密钥生成、加密、解密的具体过程如下：  
1） 密钥的生成  
首先生成两个互不相同的大素数$p$ 和$q$，并令$n=p\cdot q$。其中$p$ 和$q$ 是属于解密信息，不可对外公开，整数$n$ 属于加密信息，需要对外公开。  
然后，令$\varphi(n)=(p-1)(q-1)$，并任意选择一个与$\varphi(n)$互素的正整数$e$，满足：  
$2\leq e\leq\varphi(n)$  
其中$\varphi(n)$不可对外公开，$e$ 为加密密钥，需要对外公开。  
由于$p$ 和$q$ 都是素数，故小于$p$ 且与$p$ 互素的非负整数的个数为$(p-1)$个，小于$q$ 且与$q$ 互素的非负整数的个数为$(q-1)$个。注意到$n=p\cdot q$，由计数的乘法原理及素数的性质可知，小于$\cdot n$且与$n$互素的非负整数的个数为$(p-1)$ $(q-1)$个，因此，$\varphi(n)=(p-1)(q-$1)其实就是欧拉函数。  
由于$e$ 的模$\varphi(n)$互素，因此$e$ 的模$\varphi(n)$同余逆$d$存在且唯一。算出$e$ 的模$\varphi(n)$同余逆$d$，使其满足：  
$$
e d\equiv1({\bmod{\ }}\varphi(n))\tag{2-17}
$$  
整数$d$ 属于解密密钥，不可对外公开。  
由此得到RSA 加密算法中作为公钥的加密密钥$e$，作为私钥的解密密钥$d$。  
2） 加密过程  
在RSA 加密算法中，要将明文信息转化成若干组整数序列。为此，首先将每个字母翻译成相应的整数，例如可以使用前述的凯撒加密算法完成这项工作。然后，将这些由明文字母对应的整数合并成若干组，每个组分别形成一个大整数，代表一个字母段。  
RSA 加密过程其实就是每个表示明文字母段的大整数$M$逐个转化为表示密文字母段的大整数$C$，具体转化公式如下：  
$$
C=M^{e}{\pmod{n}}\tag{2-18}
$$  
在转化过程中总是假定$M<n$。如果$M\geq n$，则需要对表示明文的所有整数重新进行分组以确保每个字母段对应的大整数小于$n$。  
3） 解密过程  
由于$d$ 是$e$ 的模$\varphi(n)$逆，即是$e$ 的模$(p-1)(q-1)$逆，故有：  
$$
e d\equiv1(\bmod(p-1)(q-1))\tag{2-19}
$$  
也就是说，$_{e d}$除以$(p-1)(q-1)$的余数为1，故存在整数$k$，使得：  
$$
e d={\begin{array}{l}{(p-1)(q-1)k+1}\end{array}}
$$  
故有：  
$$
C^{d}\equiv(M^{e})^{d}\equiv M^{e d}\equiv M^{(p-1)(q-1)k+1}\,({\mathrm{mod}}\,\,n)
$$  
假定$M$与$p$ 和$q$ 均为互素，则根据费马小定理有：  
$$
M^{p-1}\equiv1(\mathrm{\;mod}\;\left(p\right))\mathcal{X}M^{p-1}\equiv1(\mathrm{\;mod}\;\,q)
$$  
从而有：  
$$
\begin{array}{r}{C^{d}\equiv M^{(p-1)(q-1)k+1}\equiv\!\!M\!\cdot\!(M^{p-1})^{k(q-1)}\!\!\equiv\!\!M\!\cdot\!1\!\equiv\!\!M\,(\mathrm{mod}\,p)}\\ {C^{d}\equiv M^{(p-1)(q-1)k+1}\equiv\!\!M\!\cdot\!(M^{q-1})^{k(p-1)}\!\!\equiv\!\!M\!\cdot\!1\!\equiv\!\!M\,(\mathrm{mod}\,q)}\end{array}
$$  
由于$p$ 与$q$ 互素，则根据中国余数定理，有：  
$$
C^{d}\equiv M\,({\sf m o d}\,\,\,p\cdot q)\mathbb{\bar{X}}C^{d}\equiv M\,({\sf m o d}\,\,\,n)
$$  
由于$M<n$，故必有：$M=C^{d}\;({\mathsf{m o d}}\;\,n)$  
因此，若已知解密密钥$d$，就可使用公式$M=C^{d}\,({\sf m o d}\,n),$对密文$C$ 进行解密。  
在RSA 加密和解密算法中，如果$p,\ q$ 被信息窃取者获得，则可算出$(p-1)(q-1).$。由于$e$ 是公开密钥，且$d$是$e$ 关于关于模$(p-1)(q-1)$的逆，则不难求出$d$，如此RSA 系统便被完全攻破，信息窃取者就会很容易获得加密的信息。  
RSA 算法中的素数都是十进制整数，怎样才能选择好的$p$ 和$q$，这是$R S A$ 加密算法最关键的问题。针对素数$p$ 和$q$ 的选择，1978 年Rivest 等人在关于RSA 公开密钥的论文中，建议对素数$p$ 和$q$ 的选择应当满足：  
1）$p$ 和$q$ 要足够长，在长度上应相差几位，且二者之差与$p$ 和$q$ 位数相近；  
2）$p{-}1$ 和$q{-}1$ 的最大公约数$\operatorname*{gcd}(p -1\,,\,\,\,q-\!\!1)$要尽量小；  
3）$p{-}1$ 和$q{-}1$ 均应至少含有一个大的素数因子。  
并把满足这些条件的素数称为安全素数。  
从实用的观点看，如果加密后的信息能够保证在足够长的时间内不能被破解，则认为这个加密方法是安全的。相对于RSA 加密算法而言，如果整数$n$ 不是足够大，例如只有10 位，那么按照计算机目前的计算能力，几乎可以立刻求出其所有素因子实现对RSA 加密算法的破解。如果计算机的计算能力得到进一步的提高，则或许能够破解200 位的整数$n$。但是，如果使用200 素数$p$ 和200 位素数$q$ 构成400 位整数$n$，则计算机无法破解由此设计的RSA加密算法。因此，就目前以及今后一段时间而言，RSA 加密算法具有较好的安全性。"
完全二分图,概念,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.2.1  二分图的概念与性质']","{'实体类型': '概念', '定义': '对于二分图G=⟨X,E,Y⟩，若X中每个结点与Y中每个结点都有且仅有一边联结，则称G为完全二分图或完全偶图，记作Ki,j，其中|X|=i，|Y|=j', '特点': '每个结点与另一集合中的每个结点都有且仅有一边联结'}",,3,"在给出二分图模型的概念之前，先考察这样一个问题：假设某单位有文秘、程序员、推销员和清洁工这四个空缺的岗位需要招聘员工，现在有甲、乙、丙三人前来应聘。其中甲能够胜任程序员、文秘、推销员岗位，乙能胜任程序员、推销员岗位，丙只能胜任清洁工岗位。则可用如图10-25 所示的图模型表示岗位和应聘者之间的关系，其中结点$A,B,C,D$分别表示程序员、文秘、推销员和清洁工这四个岗位。  
![图10-25 二分图模型  ](images/8864c10116e26697fbf05b1f18e2401c9842cde25d081b310532369c11ee7ce7.jpg)  
不难看出，可将如图10-25 所示图模型的所有结点划分为应聘者和岗位这两个不同的集合，属于同一个集合的结点之间无边联结，图中所有边的两个端点均分属两个不同的集合。具有这种特征的图模型就是二分图，其具体定义如下：  
【定义10.3】设$G=\langle V,E\rangle$是任意给定的一个无向图，若存在结点集𝑉的两个子集$X,Y$，满足$X\cap Y=\varnothing$且$X\cup Y=V$，图$G$中任何一条边的两个端点均分别属于 $X$和$𝑌$，则称$G$是一个二分图或偶图,$X$和$𝑌$称为互补结点子集，记为$G=\langle X,E,Y\rangle$。对于二分图$G=\langle X,E,Y\rangle$，若$ X$中每个结点与𝑌中每个结点都有且仅有一边联结，则称$G$为完全二分图或完全偶图，记作$K_{i,j}$，其中$|X|=i$，$|Y|=j$。平凡图和零图可看成是特殊二分图。  
![图10-26 完全二分图模型  ](images/ae1a646a89e375aa1b8c1c870d1cd9274cf83b1ce9ba6ad8326f6e1c44eef5ab.jpg)  
由定义10.3 可知，在二分图$G=\langle X,E,Y\rangle$中，没有两个端点同属𝑋或𝑌的边，故二分图没有自回路。如图10-25 表示两个为完全二分图：$K_{2,3}$，$K_{3,6}$。  
![（a）图𝐺                         （b）图$H$【例题10.8】如图10-27 所示的图$G$和$H$是否为二分图。  ](images/b80fa71a1e3c63a74ff7d12be601081cc8b875225af5fcb246ba93539d56929b.jpg)  
由于同构的图模型尽管结构相同但表现形式多种多样，故有时很难直接使用定义实现对二分图的判定。下面给出关于二分图判定的充要条件：  
【定理10.7】设$G=\langle V,E\rangle$是任意给定的一个无向图，则$G$是一个二分图当且仅当$G$中所有回路的长度均为偶数。"
完全关系,概念,"['第五章 关系模型与理论', '§ 5.1 关系的数学模型', '5.1.3 关系的表示', '3、矩阵表示法']","{'实体类型': '概念', '定义': '含有全部序偶的关系', '特点': '关系图中所有结点之间都有有向边互联，关系矩阵元素全是1'}",,4,"在使用关系的数学模型对实际问题进行建模的时候，通常需要对关系模型进行一些定量的数值计算以实现对实际问题的求解，此时无论是关系的集合表示方法和关系图法，都不方便实现对关系模型定量的数值计算。为此，我们引入二元关系的矩阵表示法。  
假设$\boldsymbol A=\{a_{1},a_{2},\cdots,a_{n}\}$, $B=\{b_{1},b_{2},\cdots,b_{m}\}$是任意给定的两个非空有限集合，$R$是$A$到$B$的一个二元关系，则按下列方式定义的$m\times n$阶矩阵$M_{R}=(r_{i j})_{m\times n}$称为$R$的关系矩阵：
$$
r_{ij}=\begin{cases}1\text{,若}\langle a_i,b_j\rangle\in R\\0\text{,若}\langle a_i,b_j\rangle\not\in R\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-3)}
$$
其中$A$中元素$a_{i\cdot}$序号对应矩阵元素的行下标，$B$中元素$b_{j}$序号对应矩阵元素的列下标。  
值得注意的是：由关系矩阵的定义可知，关系矩阵的元素有且仅有0 和1 这两种状态，这样的矩阵一般称之为布尔矩阵，主要用于一些逻辑演算，在运算规则上与普通矩阵有一些差异。为满足后续内容学习的需要，在此简要介绍布尔矩阵的若干基本运算，具体包括并运算、交运算、补运算和布尔积运算，其具体定义如下：  
【定义5.9】设$A=\left(a_{i j}\right)$和$B=\left(b_{i j}\right)$是两个$m\times n$布尔矩阵，则$𝐴$和$B$的并矩阵定义为如下$m\times n$布尔矩阵：$A\lor B=C=\left(c_{i j}\right)$，其中：  
$c_{ij}=\begin{cases}1\text{,如果}a_{ij}=1\text{ 或}b_{ij}=1\\0\text{,如果}a_{ij}=0\text{ 且}b_{ij}=0\end{cases}(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-4)}$      （5-4）  
【定义5.10】设$A=\left(a_{i j}\right)$和$B=\left(b_{i j}\right)$是两个$m\times n$布尔矩阵，则$A$和$B$的交矩阵定义为如下一个$m\times n$布尔矩阵：$A\land B=C=\left(c_{i j}\right)$，其中：
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=1\text{ 且}b_{ij}=1\\0\text{,如果}a_{ij}=0\text{ 或}b_{ij}=0\end{cases}(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-5)}
$$
【定义5.11】设$A=\left(a_{i j}\right)$任意给定的一个$m\times n$布尔矩阵，则𝐴的补矩阵定义为如下$m\times$$n$布尔矩阵：$\bar{A}=C=\left(c_{i j}\right)$，其中：
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=0\\0\text{,如果}a_{ij}=1\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-6)}
$$
【定义5.12】设$A=\left(a_{i j}\right)$是$m\times p$矩阵，$B=\left(b_{i j}\right)$是$p\times n$矩阵，则$𝐴$和$B$的布尔积矩阵定义为如下$m\times n$布尔矩阵：$A\odot B=C=\left(c_{i j}\right)$，其中：  
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=0\\0\text{,如果}a_{ij}=1\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-6)}
$$
需要注意的是：两个布尔矩阵可进行布尔或和布尔与运算的前提是这两个矩阵具有相同的行数和列数，可进行布尔积运算的前提是前一个矩阵的列数等于后一个矩阵的行数。  
在学习了二元关系的三个基本表示方法后，下面我们考察空关系、完全关系和恒等关系这三个常用特殊关系的关系矩阵和关系图各有什么特点：  
(1) 空关系$\varnothing$  因为$\emptyset\subseteq A\times B$(或$\emptyset\subseteq A\times A)$)，所以$\varnothing$也是一个从$𝐴$到$B$(或$𝐴$上)的关系，称之为空关系，即无任何元素的关系。空关系的关系图中只有结点，无任何边，且关系矩阵中的元素全是0  
(2) 完全关系（全域关系） $A\times B$或(或$A\times A)$本身也是一个从$𝐴$到$B$(或$𝐴$上)的关系，称之为完全关系，即含有全部序偶的关系。完全关系的关系图中所有结点之间都有有向边互联，关系矩阵中的元素全是1。  
(3) 恒等关系 $I_{A}$  $I_{A}\subseteq A\times A$，则$I_{A}=\{\langle x,x\rangle|x\in A\}$为$A$上的恒等关系。完全关系的关系图中所有结点都有一个有向环，不同结点之间无任何有向边联结。  
![](images/9a95167e68610708edb7fef0f0474b8284d349dcc5f3b662d3280809d00fbf1e.jpg)
图5-6 空关系、全关系与恒等关系  
设$A=\left\{1,\ 2,\ 3\right\}$，则$A$ 上的空关系∅、完全关系$A\times A$及恒等关系$I_{A}$的关系图如图5-6 所示，下面三个布尔矩阵分别是它们的关系矩阵：  
$M_{\emptyset}=\left(\begin{array}{ccc}0&0&0\\0&0&0\\0&0&0\end{array}\right)\quad M_{A\times A}=\left(\begin{array}{ccc}1&1&1\\1&1&1\\1&1&1\end{array}\right)\quad M_{I_A}=\left(\begin{array}{ccc}1&0&0\\0&1&0\\0&0&1\end{array}\right)$"
完全剩余系,定义,"['第二章  整数与算法设计基础', '§ 2.2 同余算术及其应用', '2.2.1 同余关系及其运算']","{'实体类型': '定义', '内容': '假设m是任一给定的正整数，R0(m),R1(m),⋯,Rm-1(m)是所有模m同余类，如果从每个同余类Ri(m)中分别取一个整数xi构成一个m元有限集合{xo,x1,⋯,xm-1}，则称该有限集合为模m的一个完全剩余系，简称为完全系；称m元有限集合{0,1,2,⋯,m-1}为最小非负完全剩余系'}",,3,"在很多场合，我们往往只关心用某一特定正整数除以整数得到的余数。例如，星期日期就是从某个星期日开始经历的天数除以7 得到的余数，通过对天数取以7 为除数的余数，就可以用短短的7 个数字借助以7 为周期的循环机制表示无穷无尽的天数。事实上，取余数是一种以有限驾驭无限的重要智慧，对于任一给定的正整数$m$，通过考察所有整数除以$m$ 所得余数的差异，把所有具有相同余数的整数归为一类，则可将所有整数分为$m$ 个基本类型。若分别从每个类中取一个整数作为代表构成一个$m$ 元有限集，则可将这个有限集看成是对整数集的一个抽象，由此完成了整数集从无限向有限的转化。在这个分类过程中，整数之间是否具有相同余数的关系起着非常关键的作用，由此得到如下同余的概念：  
【定义2.9】假设$m$ 是任一给定的正整数，对于任意两个整数$a$和$b$，它们除以$m$ 后得到的余数分别记为$a({\bmod{\ m}})$和$b({\bmod{\ m}})$，如果这两个余数相等，即有：  
$$
a({\bmod{\ m}})=b({\bmod{\ m}})\tag{2-9}
$$  
则称$a$与$b$具有模$\pmb{m}$同余关系，简称为$a$与$b$模$\pmb{m}$同余或同余，记为$a\equiv b({\bmod{m}})$或$b\equiv$$a({\bmod{\ m}})$；否则称$a$与$b$对于模$\mathbfit{m}$不同余，记为$a\not\equiv b({\bmod{{m}}})$或$b\not\equiv a({\bmod{\ m}})$。  
根据上述定义，不难证明下面关于模$_m$同余的判定定理：  
【定理2.19】假设$m$是任一给定的正整数，任意两个整数$a$和$b$具有模$_m$同余关系，当且仅当$m$能够整除$a-b$。  
【定理2.20】假设$m$ 是任一给定的正整数，任意两个整数$a$ 和$b$ 具有模$m$同余关系，  
当且仅当存在整数$k$，使得整除$a=b+k m$  
下面定理表明了同余关系的保加性和保乘性：  
【定理2.21】设$m$ 是任一正整数，若整数$a$ 与$b$ 模$m$ 同余，整数$c$与$d$ 同余模$m$，则它们的和与积也分别模$m$ 同余。即：若$a\equiv b({\bmod{\ }}m)$，$c\equiv d({\bmod{\pmod{m}}})$，则有：  
$$
a+c\equiv(b+d)(\bmod{\ m}),\ \ a c\equiv b d(\bmod{\ m})
$$  
【定理2.22】假设$m$ 是任一给定的正整数，则对任意两个整数$a$ 和$b$，成立下面两个关于余数的计算公式：  
$$
(a+b){\bmod{\ m}}=((a{\bmod{\ m}})+(b{\bmod{\ m}})){\bmod{\ m}}\tag{2-10}
$$  
$$
ab\ {\bmod{\ m}}=((a{\bmod{\ m}})(b{\bmod{\ m}}))\ {\bmod{\ m}}\tag{2-11}
$$  
例如，对于$7\equiv2{\bmod{\mathrm{~5~}}}$和$11\equiv1{\bmod{\mathrm{~5~}}}$，由定理2.21 知：  
$$
18=7+11\equiv2+1=3({\bmod{\mathrm{~}}}5)
$$  
$$
77=7\cdot11\equiv2\cdot1=2{\pmod{5}}
$$  
再如，对于任意三个数，比如说1, 2 和5，由定理2.22 知存在如下等式：  
$$
(1+2)({\bmod{\ }}5)=((1\ \,({\bmod{\ }}5)+(2\ \,({\bmod{\ }}5))({\bmod{\ }}5)
$$  
$$
2\,\bmod\,5=\left((1\,\bmod\,5)(2\,\bmod\,5)\right)\,(\bmod\,5)
$$  
值得注意的是，同余关系在一般情况下不满足消去律，例如 $8\equiv12({\bmod{\mathrm{~}}}4)$，两边同除以4 后，$2\equiv3({\bmod{\mathrm{~}}}4)$显然是不成立的，但是存在下列性质：  
【定理2.23】若$a c\equiv b c({\bmod{\pmod{m}}})$，且$c$ 与$m$ 互素，则有：$a\equiv b({\bmod{\ }}m)$  
如前所述，使用同余可以实现对整数集合的划分或分类，现在就来讨论这个问题。由同余的定义可知，对于任意给定的正整数$m$，可依照除以$m$ 后的余数值以及模$m$ 同余关系，将所有整数划分为$m$ 个互不相交的子集合。据此，我们引入如下同余类的概念：  
【定义2.10】设$m$ 是任一给定正整数，对于每个整数$i$，$0\leq i<m$，定义如下集合：  
$$
R_{i}(m)=\{n|n\equiv i({\bmod{\pmod{\ m}}},n\in Z\}\tag{2-12}
$$  
则称每个$^{}R_{i}(m)$分别是模$m$ 的一个同余类或剩余类，在不引起混淆的情况下，通常也将$R_{i}(m)$简记为$[i]$，并记为：$Z_{m}=\{[0],[1],\cdots[m-1]\}.$。  
【定理2.24】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m),$所有模$m$ 同余类，则有下述结论成立：  
（1）每个整数$a$ 都恰好属于某个同余类，通常将这个同余类记为$[a]_{m}$或$[a]$  
（2）对于任意的两个整数$a$ 和$b$，它们属于同一个同余类的充分必要条件是：
$$
a\equiv b({\bmod{m}})
$$  
上述定理表明，每个整数必定属于且仅属于其中一个剩余类，属于同一个剩余类的任意两个整数都是模$m$ 同余的，属于不同剩余类的任意两个整数不可能是模$m$ 同余的。  
根据定理，可以在$.Z_{m}=\{[0],[1],\cdots[m-1]\}$上定义关于同余类的加法和乘法运算：  
【定义2.11】假设$m$ 是任一给定的正整数对于任意给定的两个整数$a$和$b$，定义：
$$
[a]_{m}+[b]_{m}=[a+b]_{m}
$$  
$$
[a]_{m}\cdot[b]_{m}=[a\cdot b]_{m}
$$  
【定义2.12】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m)$是所有模$m$ 同余类，如果从每个同余类$R_{i}(m)$中分别取一个整数$x_{i}$构成一个$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$，则称该有限集合为模$m$ 的一个完全剩余系，简称为完全系；称$m$ 元有限集合$\{0,\ 1,\ 2,\ \cdots\ ,$为最小非负完全剩余系。  
对于正整数$m$，假设$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$是模$m$ 的一个完全剩余系，对于其中的任意一个整数$\cdot x_{i}$，如果${\bf\nabla}_{}^{}$与$m$ 互素，则$x_{i}$所在同余类${\mathbf{}}R_{i}(m)$中每个整数$k$ 都与$m$ 互素。这是因为根据$k\equiv x_{i}({\bmod{\pmod{m}}})$，即有$\cdot_{x_{i}}=k+q m$。由此可知，如果$k$ 与$m$有大于1 的公因子，那么$x_{i}$必然与$m$ 有大于1 的公因子。类似地，如果$x_{i}$与$m$ 互素，则$x_{i}$所在同余类$R_{i}(m)$中每个整数$k$ 都与$m$ 不互素。由此得到如下简化同余类和简化剩余系的概念：  
【定义2.13】对于正整数$m$，假设$R_{i}(m)$是任意一个模$m$ 同余类，若$R_{i}(m)$中存在一个整数与 $m$  互素，则称 $\ R_{i}(m)$ 是一个模 $\pmb{m}$  简化同余类或模 $\pmb{m}$  简化剩余类。如果分别从每个模 $m$ 简化同余类中取出一个整数作为代表$x_{i}$构成一个有限集合$\{x_{0},\ x_{1},\ \cdots,x_{\varphi(m-1)}\}$，则称该集合为模$m$ 的一个简化剩余系，简称为简化系。其中$\varphi(m)$称为欧拉函数，表示模$m$ 简化剩余类的数目，亦即不超过$m$ 且与$m$ 互素的正整数个数。  
因为所有模$m$ 同余类构成整数集合的一个划分，所以每个与$m$ 互质的整数仅存在于它  所在的简化同余类中。由此可以看出，简化同余类以及欧拉函数$\varphi(m)$在整数互质性质的研究中具有非常重要的作用，后面将使用这些概念证明欧拉定理和费马小定理。这两个定理不仅是整数理论中非常著名而重要的定理，而且还是现代非对称数论加密算法的基础。"
完全图,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.2.1 图的基本运算', '三、子图与补图运算']","{'实体类型': '概念', '定义': '假设$G=\\\\langle V,E\\\\rangle$是一个具有$n$个结点的无向简单图，如果图中任意两个结点之间都有边相联结，则称该图为$n$阶无向完全图，简称为完全图', '记法': '记为$K_{n}$', '特点': '其邻接矩阵除主对角线上元素均为0 之外，其余元素均为1'}",,4,"在使用图模型对实际问题建模和求解的过程中，经常需要分析考察图的某个特定部分的结构，将图中某个或某些特定的部分提取出来作为一个图模型进行研究，由此得到如下关于图模型的子图运算的若干概念，具体如下：  
【定义8.13】设 $G=\langle V,E\rangle$，$G^{\prime}=\langle V^{\prime},E^{\prime}\rangle$是两个图（同为无向图或者有向图），则有：  
（1）若 $V^{\prime}\subseteq V$且 $E^{\prime}\subseteq E$，则称 $G^{\prime}$是 $G$ 的子图，$G$ 是 $G^{\prime}$的母图，记为 $G^{\prime}\subseteq\mathbf{G}$ 。若 $G^{\prime}\subseteq\mathbf{G}$且 $G^{\prime}\neq{\bf G}$（即$V^{\prime}\subset V$或 $E^{\prime}\subset\mathbf{E})$），则称 $G^{\prime}$ 是 $G$ 的真子图；若 $G^{\prime}\subseteq G$且 $V^{\prime}=V$，则称 $G^{\prime}$是 $G$ 的生成子图。  
（2）设$V_{1}$是𝑉的非空子集，即 $\varnothing\neq V_{1}\subseteq V$，则以 $V_{1}$ 为结点集，以两个端点均在 $V_{1}$ 中的全体边为边集的 $G$ 的子图称为由$V_{1}$导出的导出子图，记为 $G[V_{1}]$。  
（3）设$E_{1}$是$E$的非空子集，设$\varnothing\neq E_{1}\subseteq E$，以 $E_{1}$为边集，以 $E_{1}$ 中所有边关联的全部结点为结点集的 $G$ 的子图成为由 $E_{1}$导出的导出子图，记为 $G[\ E_{1}]$。  
由上述定义可以看出，生成子图与其母图具有相同的结点集合。因此，一个图的生成子图一般是该图的主体结构。对于一个复杂的图模型，一般通过采用适当的方法构造其符合要求的生成子图实现对模型的化简和对问题的求解。  
不难看出，对于任一给定非空有限结点集合，由这些结点构成的零图和完全图分别表达了两个极端构图情形，两者之间具有互补性，相当于集合论中的空集和全集。 由此可以得到图模型补运算的概念。 首先给出如下关于完全图的定义：  
【定义8.14】假设$G=\langle V,E\rangle$是一个具有$\cdot_{n}$个结点的无向简单图，如果图中任意两个结点之间都有边相联结，则称该图为$^n$阶无向完全图，简称为完全图，记为$K_{n}$；假设$G=\langle V,E\rangle$是一个具有$\cdot_{n}$个结点的有向简单图，如果图中任意两个结点之间都有方向相反的两条边相联结，则称该图为$n$阶有向完全图，在不发生混淆的情况下也记为$K_{n}$。  
由上述定义可知，对于完全图来说，其邻接矩阵除主对角线上元素均为0 之外，其余元素均为1。显然，$n$阶无向完全图的边数为$n(n-1)/2$ ，$n$阶有向完全图的边数为$\ n(n-1)$。 图8-17 给出了无向完全图$K_{3}$，$K_{4}$，$K_{5}$和有向图$K_{3}$。  
下面给出图模型补运算的定义：  
【定义8.15】设 $G=\langle V,E\rangle$ 是 $n$ 阶简单图，以 $V$ 为顶点集，以所有能使 $G$ 成为完全图 $K_{n}$ 的新加边为边集的图称为 $G$ 相对于 $K_{n}$ 的补图，简称为 $G$ 的补图，记为$\bar{G}$。  
显然，若图$G$的邻接矩阵为$A_{G}=(a_{i j})_{n\times n}$，则其补图$\bar{G}$的邻接矩阵为$A_{\bar{G}}=(\bar{a}_{i j})_{n\times n}$为：  
$$
\\\bar{a}_{i j}=f(x)=\left\{\begin{array}{r l r}&{~~~~~~~~1-a_{i j},~i\neq j}&\\ &{0,~~~~~~~~~~~~~~~~~~i=j}&\end{array}\right.
$$  
例如，对于图8-18 所示的图 $G_{1}$和图 $G_{2}$，图 $G_{1}$ 是图 $G_{2}$ 的补图，图 $G_{2}$ 也是图 $G_{1}$的补图。显然， $K_{n}$ 的补图是 $n$ 阶零图，反之亦然。  
![图8-18 补图运算 ](images/bc253e401f30298f9209681ddc8b93ec627ca9bfb8d5b9c17929af79e1390112.jpg)"
完全覆盖,概念,"['第六章 特殊关系模型', '§ 6.2 相容关系与元素聚类', '6.2.2  集合的覆盖']","{'实体类型': '概念', '定义': '设R是非空集合A上的一个相容关系，由R所有最大相容类为元素构成的集合可以构成A的一个覆盖，称之为A的一个完全覆盖', '特点': '每个相容关系唯一确定A上的一个完全覆盖'}",,3,"我们知道，集合上的任何一个等价关系都可以确定该集合的一个划分。那么，集合上的任何一个相容关系是否也能确定该集合的一个划分呢？答案显然是否定的。因为任何一个等价关系都是相容关系，但是相容关系不一定是等价关系。既然显然关系不一定能够对集合产生一个划分，那么它对集合能产生什么另外的效果呢？现在就来考察这个问题。  
在对集合的划分过程中，要求不同划分块之间的交集为空集，也就是说不同划分块之间不能有共同部分。现在取消这个限制，由此得到如下关于集合覆盖的概念：  
【定义6.8】假设$𝐴$任一非空集合，$Q$是$𝐴$的非空子集$Q_{i}$组成的集族$\begin{array}{r}{\boldsymbol{ Q}=\{Q_{1},Q_{2},\cdots,Q_{m}\},}\end{array}$，且满足$Q_{1}\cup Q_{2}\cup\cdots\cup Q_{m}=A$，则称$ Q$是$𝐴$的一个覆盖, $Q_{1},Q_{2},\cdots,Q_{m}$分别称为覆盖$Q$的一个 覆盖块或覆盖类。  
从上述定义可以看出，划分一定是覆盖，但覆盖不一定是划分。例如，在$A=\{1,\!2,\!3\}$的如下子集中，$A_{1},A_{2},A_{3}.$,是覆盖，$A_{1},A_{2}$,是覆盖也是划分，$A_{4}$既不是覆盖也不是划分。  
$$
A_{1}=\big\{\{1\},\{2\},\{3\}\big\},A_{2}=\big\{\{1,2\},\{3\}\big\},A_{3}=\big\{\{1,2\},\{2,3\}\big\},A_{4}=\big\{\{1\},\{3\}\big\}
$$  
设$ R$是非空集合$𝐴$上的一个相容关系，下面的定理表明，以$R$的所有最大相容类为元素构成的集合可以能够构成$𝐴$的一个覆盖，并由此到完全覆盖的概念：  
【定理6.4】设$\cdot R$是非空集合𝐴上的一个相容关系，由$R$所有最大相容类为元素构成的集合可以构成𝐴的一个覆盖，并称之为𝐴的一个完全覆盖，记为$C_{R}(A)$。  
【定理6.5】设$\boldsymbol{Q}=\{\;\boldsymbol{Q}_{1},\boldsymbol{Q}_{2},\cdots,\boldsymbol{Q}_{m}\},$为集合$𝐴$的任一覆盖，则由该覆盖确定的关系：  
$$
R=(Q_{1}\times Q_{1})\cup(Q_{2}\times Q_{2})\cup\cdots\cup(Q_{m}\times Q_{m})\quad\text{(6-3)}
$$  
是$𝐴$上的相容关系，称之为由该覆盖所导出的相容关系。  
上述定理表明了对于非空集合$𝐴$上的任意一个覆盖，都可以构造出相应的一个相容关系。但是，不同的覆盖有可能产生相同的相容关系。例如，对于集合$A=\{1,\!2,\!3,\!4,\!5\}$上的两个覆盖{{1,2,3}, {3,4}}和{{1,2}, {2,3},{1,3},{3,4}}，易知它们产生的相容关系均为：  
$$
R=\{\langle1,1\rangle,\langle1,2\rangle,\langle2,1\rangle,\langle2,2\rangle,\langle2,3\rangle,\langle3,2\rangle,\langle1,3\rangle,\langle3,1\rangle,\langle3,3\rangle,\langle4,4\rangle,\langle3,4\rangle,\langle4,3\rangle\}
$$  
因此，非空集合$𝐴$上的相容关系与$𝐴$上的覆盖之间不是一一对应的关系。但是，对于$𝐴$上任意一个给定的相容关系$R$，其所有最大相容类$C_{R}$构成的集合是唯一确定的，因而由$R$所有最大相容类$C_{R}$为元素构成的𝐴最大覆盖$C_{R}(A)$也是唯一确定的。也就是说，非空集合$𝐴$上的每  
个相容关系唯一确定$𝐴$上的一个完全覆盖。"
完备匹配,概念,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.2.2 完备匹配与最大匹配']","{'实体类型': '概念', '定义': '二分图中每个结点都是某个匹配的饱和结点的匹配', '条件': '若存在完备匹配，则必有|X|=|Y|'}",,3,"首先考察一个有趣的问题：假设在某个小型舞会上有5 名男士和5 名女士，其中某些男士与某些女士之间相互认识，问如何安排才能使得相互认识的男生和女士人成为舞伴。  
可用如图10-30（a）所示的二分图模型$G=\langle X,E,Y\rangle$表示上述舞伴配对问题，其中结点集合$X=\{x_{1},x_{2},x_{3},x_{4},x_{5}\}$和$Y=\{y_{1},y_{2},y_{3},y_{4},y_{5}\}$分别表示5 名男士和5 名女士构成的集合，图中有无向边$(x_{i},y_{j})$当且仅当男士$x_{i}$与女士$y_{j}$相互认识。  
![图10-30  舞伴的安排问题 ](images/e92b7888a1cc6a1b77006b78c8c42919c89a7e806394091bb76e5c5538b07826.jpg)  
通过观察，不难得到如图10-30（b）中实线边所示的一种安排方案。由于每个人最多只能与一个异性匹配成舞伴，故所得到的安排方案其实就是图$G=\langle X,E,Y\rangle$中5 条不相邻边组成的$E$的子集：$M=\{(x_{1},y_{3}),(x_{2},y_{1}),(x_{3},y_{2}),(x_{4},y_{5}),(x_{5},y_{4})\}_{\circ}$。  
不难看出，上述问题其实就是在两类不同性质的对象之间寻找某种配对或者匹配的问题。事实上，日常生活和工作中的很多问题，例如学生选课、工作任务安排等等，都可以归结为这种匹配问题。对上述实例进行抽象，得到如下匹配的相关概念：  
【定义10.4】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，图中互不相邻的边构成$.E$的子集$M$称为$G$的一个匹配，$G$中与$M$中的边关联的结点称为匹配$M$的饱和结点。如果$X$中每个结点都是某个匹配的饱和结点，则称该匹配为$G$的一个$X^{.}$-完备匹配；如果𝑌中每个结点都是某个匹配的饱和结点，则称该匹配为$G$的一个𝑌-完备匹配；如果$G$的某个匹配既是$X-$完备匹配，又是𝑌-完备匹配，则称该匹配为完备匹配。$G$中基数最大的匹配称为𝐺的最大匹配，最大匹配中的边数称为$G$的匹配数，记作$\alpha^{\prime}(G)$。  
由定义10.4 可知，二分图的$X^{-}$完备匹配、$Y-$完备匹配和完备匹配肯定是最大匹配，反之不然，最大匹配不一定是$X-$完备匹配、$Y-$完备匹配或完备匹配。对于任意一个给定的二分图，其最大匹配总是存在，但其$X{-}$完备匹配、$Y-$完备匹配或完备匹配不一定存在。如果一个二分图存在完备匹配，则必有$|X|=|Y|$，反之不然。  
![图10-31  二分图及其最大匹配  ](images/426797d69400c6077f0021e199ce3acdf2169381fe7ee70516dbf26e96f0ac68.jpg)  
例如，对于图10-31（a）所示的二分图，图10-31（b）所示的全部实线边构成的集合：  
$$
M=\{(x_{1},y_{3}),(x_{2},y_{1}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
是该二分图的一个最大匹配。该匹配显然不是$X^{-}$完备匹配、$Y-$完备匹配或完备匹配，因为$x_{4}$和$y_{4}$均是其非饱和点。再如，图10-30（b）中实线边所示的匹配显然是一个完备匹配，自然也是最大匹配。  
下面考察对于一个给定的二分图$G=\langle X,E,Y\rangle$，当$G$满足什么条件时存在完备匹配。这里仅讨论$X^{-}$完备匹配的情形，至于$Y-$完备匹配和完备匹配的情况，可类似讨论。  
首先给出著名的霍尔婚姻定理，该定理给出了二分图$G=\langle X,E,Y\rangle$存在$X^{-}$完备匹配的一个充分必要条件，具体如下：  
【定理10.8】（霍尔婚姻定理）设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，则$G$存在$X^{-}$完备匹配的充分必要条件是$X$中任意$k$个结点至少与𝑌中$k$个结点相邻。具体地说，就是对于$\forall S\subseteq X$，有$|S|\leq|\mathsf{N}(\mathsf{S})|$，其中N(S)表示𝑌中所有与S中结点相邻的结点组成的集合。  
![图10-32  $X$-完备匹配存在性的判定](images/e5661ccfd2ab0df27e3feadf55016324a2bdd2f775f9de7183f592d16a209926.jpg)  
例如，图10-32（a）所示二分图满足霍尔婚姻定理的条件，故存在$X^{-}$完备匹配，图$10-$32（b）所示二分图不满足霍尔婚姻定理的条件，故不存在$X^{-}$完备匹配。  
定理10.8 中需要计算𝑋中所有子集在𝑌中邻接结点的集合，在很多情况下计算量很大，不便使用。为此，下面给出一个名为$t-$条件的充分条件，具体如下：  
【定理10.9】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，如果$G$满足：$X$中每个结点至少关联t-条边且𝑌中每个结点至多关联$t^{-}$条边，则图$G$一定存在$X^{-}$完备匹配。  
判断𝑡条件非常简单，只需计算$X$中结点最小度$\delta(X)$和$\Delta(Y)$中结点最大度$\Delta$即可。例如，对于图10-32（a）所示二分图，显然有$\delta(X)=\Delta(Y)=2=t$，故存在$X{-}$完备匹配。"
定义域,概念,"['第五章 关系模型与理论', '§ 5.1 关系的数学模型', '5.1.2  关系的概念']","{'实体类型': '概念', '定义': '由𝑅中所有序偶的第一元素构成的集合称为𝑅的定义域，记作dom𝑅'}",,3,"现在我们使用序偶与笛卡尔积这两个概念建立表示两个元素之间二元关系的数学模型。首先考察一个具体实例：假设某个班级正在上离散数学课，教室里有100 个座位和85 名学生，那么教室里有些座位有学生坐、有些座位没有学生坐，如果某个座位被某个学生坐了，则称这个座位与这个学生有关系，否则称这个座位与这个学生没有关系，现在考虑要用什么样的数学模型来表示或定义这种学生与座位之间的二元关系。  
令集合$A$表示该教室所有学生组成的集合，集合B表示该教室所有座位组成的集合，则根据乘法原理，$A$与$B$的笛卡尔集$A\times B$就表示将这85 名学生分布到100 个座位上所有可能发生的状态，$A\times B$中每个元素$\langle x,y\rangle$就表示学生$x$与座位𝑦之间可能发生的一种关系，即学生$x$坐在座位𝑦上的一种可能发生的状态。显然，一共有$85\times100=8500$可能的状态。但是，这些状态一般不会都发生，事实上，此时实际发生的只有85 个状态，即学生和座位之间实际发生关系的有且只有$A\times B$中的85 个元素。因此，可以将$A\times B$中这85 个实际发生的状态作为集合来表示这85 名学生和100 个座位之间的关系。换句话说，这85 名学生和100 个座位之间的二元关系其实就是$A$与$B$的笛卡尔集$A\times B$的某个子集。  
也可以从另外一个角度理解这个问题：将集合$𝐴$和$B$分别看成是学生维度和座位维度这两个一维空间，则$𝐴$与$B$的笛卡尔集$A\times B$就表示由这两个维度的元素组合而成的二维空间。现从𝐴中任选一位学生$x$，从$B$中任选一个座位𝑦，让学生$x$坐到座位𝑦上，由此形成一个序偶$\langle x,y\rangle$。这个序偶对应着$A\times B$所形成二维空间的一个点，所有这样的点或者序偶显然构成了这个二维空间的一个子集合。另外一方面，所有这样的点或序偶组成的集合完全枚举了学生与座位实际发生的关系，故可将学生与座位之间的二元关系就定义为所有这样的序偶组成的集合。因此，座位和学生之间的二元关系其实就是$𝐴$与$B$的笛卡尔集$A\times B$的某个子集。  
在实际生活中，还有很多类似的例子。再如机票和座位之间对号关系，若令$X$为机票的集合，Y 为座位号的集合， $R$ 表示对号关系，则对任意$x\in X$和$y\in Y$，$x$与$y$ 之间有对号和不对号两种状态。若将$R$ 看成是一些序偶的某个集合或$X$与$Y$ 的笛卡尔集$X\times Y$的某个子集，则对于任意一个序偶$\langle x,\ y\rangle$， $x$与$y$具有对号关系当且仅当$\langle x,y\rangle\in R$。因此，可将这里的对号关系定义为序偶的某个集合或$X\times Y$的某个子集合。  
通过以上分析发现，可用序偶的集合或者笛卡尔集的某个子集合来构造二元关系的数学模型。据此得到如下关于二元关系的定义：  
【定义5.6】设$𝐴$, $B$是任意给定的两个非空集合，$R$是$A\times B$的任何一个给定的子集合，则称$R$ 是一个从$𝐴$到$B$的二元关系，简称为关系。也就是说，若$R\subseteq A\times B$，则称$R$是$𝐴$到$B$的一个二元关系，若$\ R\subseteq A\times A$，则称$R$是$𝐴$上的一个二元关系。特别地，若$R=\emptyset$，则称$R$ 为空关系；若$R=A\times B$，则称$R$ 为全关系。  
【定义5.7】设$𝐴$, $B$是任意给定的两个非空集合，$R$是$𝐴$到$B$的一个二元关系，对于$A\times B$中的任意一个序偶$\langle x,y\rangle$，若$\langle x,y\rangle\in R$，这称集合$𝐴$中的元素$x$与集合$\ B$中的元素$𝑦$之间具有关系$R$；若$R$是$𝐴$上的一个二元关系且$\langle x,y\rangle\in R$，则称集合𝐴中的元素$x$与$𝑦$之间具有关系$R$。  
由上述两个定义可以看出，我们以集合为基本工具通过确定关系外延的方式给出关系概念的数学定义。这样就不必用数学符号来表示关系概念的内涵。事实上，对于有些关系，即使用自然语言也无法清楚表达其复杂的内涵。  
![](images/f21a296fae3e098faaa3900cc4615cee3ba4531b4f17c607a85fa8fb673d5d95.jpg)
图5-1 关系的五个域  
如图5-1 所示，集合$C$和$D$满足：$C=\{x|\langle x,y\rangle\in R\}$；$D=\{y|\langle x,y\rangle\in R\}$。此时称$C$为$R$ 的定义域，记为$C=\mathsf{d o m}R$；称$D$为$R$ 的值域，记为$D=ranR$；$A$ 为$R$ 的前域，$B$ 为$R$ 的后域，并称$\mathrm{fld}R=D\cup C$为$R$ 的域。一般地，我们有如下定义：  
【定义5.8】设$𝐴$, $B$是任意给定的两个非空集合，$R$是$𝐴$到$B$的一个二元关系，则有：称$A$是$R$的前域， $B$是$R$的后域；由$R$ 中所有序偶的第一元素构成的集合称为$R$ 的定义域，记作$dom𝑅$，即有$\mathrm{dom}R=\{x|\langle x,y\rangle\in R\}$；由$R$ 中所有序偶的第二元素构成的集合称为$R$ 的值域，记作$ran𝑅$，即有$\mathrm{ran}R=\{y|\langle x,y\rangle\in R\}$；称$\mathrm{fld}R=\mathrm{dom}R\cup\mathrm{ran}R$为$R$ 的域。"
定理1.11,定理,"['第一章  集合与计数基础', '§ 1.3 有限集的基本计数技术', '1.3.2 容斥原理与鸽笼原理', '二、鸽笼原理及其应用']","{'实体类型': '定理', '内容': '如果把多于n个的元素按任一方式分成n个集合，那么至少有一个集合中含有两个或两个以上的元素'}",,4,"鸽笼原理是数学神童狄利克雷在9 岁时提出，那时他家中有九个鸽笼十只鸽子，他观察到这样一个现象：无论怎样分配鸽笼给鸽子，必然一个鸽笼里面至少有两只鸽子，便由此提出鸽笼原理，并用该原理解决很多数学问题。鸽笼原理有时也称为抽屉法则，通俗地说，就是将5 本书放在4 个抽屉里面，必然有一个抽屉至少有两本书。  
【定理1.11】如果把多于$n$ 个的元素按任一方式分成$n$ 个集合，那么至少有一个集合中含有两个或两个以上的元素。  
【定理1.12】将$n$ 个元素以任一方式分成$m$ 个集合且$m<n$，则必然存在一个集合中至少有含有$\lfloor(n-1)/m\rfloor+1$个元素。其中$\lfloor x\rfloor$表示对实数$x$ 进行向下下取整，即取不超过$x$ 的最大整数部分。"
定理1.12,定理,"['第一章  集合与计数基础', '§ 1.3 有限集的基本计数技术', '1.3.2 容斥原理与鸽笼原理', '二、鸽笼原理及其应用']","{'实体类型': '定理', '内容': '将n个元素以任一方式分成m个集合且m<n，则必然存在一个集合中至少有含有⌊(n-1)/m⌋+1个元素'}",,4,"鸽笼原理是数学神童狄利克雷在9 岁时提出，那时他家中有九个鸽笼十只鸽子，他观察到这样一个现象：无论怎样分配鸽笼给鸽子，必然一个鸽笼里面至少有两只鸽子，便由此提出鸽笼原理，并用该原理解决很多数学问题。鸽笼原理有时也称为抽屉法则，通俗地说，就是将5 本书放在4 个抽屉里面，必然有一个抽屉至少有两本书。  
【定理1.11】如果把多于$n$ 个的元素按任一方式分成$n$ 个集合，那么至少有一个集合中含有两个或两个以上的元素。  
【定理1.12】将$n$ 个元素以任一方式分成$m$ 个集合且$m<n$，则必然存在一个集合中至少有含有$\lfloor(n-1)/m\rfloor+1$个元素。其中$\lfloor x\rfloor$表示对实数$x$ 进行向下下取整，即取不超过$x$ 的最大整数部分。"
定理1.13,定理,"['第一章  集合与计数基础', '§ 1.3 有限集的基本计数技术', '1.3.3 排列计数与组合计数', '一、不重复的排列与组合']","{'实体类型': '定理', '内容': '对于任意两个正整数n和r，且r≤n，成立如下r-排列数计算公式：P(n,r)=n(n-1)(n-2)⋯(n-r+1)=n!/(n-r)!'}",,4,"首先考察如下排列问题：  
某班有35 名同学，现从中选出15 名同学排成一排，问有多少种排列方式？  
这个问题有如下两个关键要点：第一、在排列中每位同学最多只能出现一次，也就是无重复性；第二、不同的次序构成不同的排列。由此得到如下不重复排列的概念：  
【定义1.21】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中依次取出$r$ 个不同元素并将其按取出的次序排成一排，由此形成的一个有序排列称之为不重复$r\cdot$-排列，简称为$r\cdot$-排列或排列，不重复$r\cdot$-排列的个数称为不重复$r\cdot$-排列数，简称为$r\cdot$-排列数或排列数，记为${P}_{n}^{r}$或$P(n,r)$。称$r=n$时构成的排列称为全排列，$r<n$时构成的排列为选排列。  
根据乘法原理，显然可以得到如下结论：  
【定理1.13】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r\cdot$-排列数计算公式：  
$P(n,r)=n(n-1)(n-2)\cdots(n-r+1)\ \ ={\frac{n!}{(n-r)!}}$ 其中：$n!=n(n-1)(n-2)\cdots2\cdot1$  
【定义1.22】假设$S$是由$n$ 个不同的元素组成的集合，从$S$ 中依次取出$r$ 个不同元素并将其按取出的次序排成一个圆圈，由此形成的一个有序圆排列称之为不重复$r\cdot$-圆排列，简称为$r\cdot$-圆排列或圆排列，不重复$r\cdot$圆排列的个数称为不重复$r\cdot$-圆排列数，简称为$r\cdot$-圆排列数或圆排列数，记为${\cal P}_{c}(n,r)$。  
相对于上述圆排列的概念，有时亦将$r\cdot$-排列称为$r$-线排列或线排列。由前面分析不难看出，如果将每个$r\cdot$-线排列的首尾相连构成一个$r\cdot$-圆排列，则由此构成的所有圆排列必然有$r$倍的重复数。故有如下$r\cdot$-圆排列计算公式：  
【定理1.14】对于任意给定的两个正整数$n$ 和$r$，且$r\leq n$，其$r\cdot$-圆排列数为$P_{c}(n,r)$：  
$$
P_{c}(n,r)=\frac{P(n,r)}{r}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r}=\frac{n!}{r(n-r)!}
$$  
以上例子的共有特点是所有选出的元素都有一定的次序。事实上，很多情况下并不需要选出的元素具有有次序。  
考察如下组合问题：  
某班有35 名同学，现从中任意选出15 名同学参加问卷活动，问有多少种选择方式？  
与前述$r$-排列问题不同的是，这个问题只考虑抽取的是哪15 名同学，并不考虑抽取次序以及与之相关的排列问题。由此得到如下不重复组合及相关组合数的概念：  
【定义1.23】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中任意取出$r$ 个不同元素组成一个子集合，称每一个这样的子集合为一个不重复$r$-组合，简称为$r\cdot$-组合或组合，不重复$r$-组合的个数称为不重复$r\cdot$-组合数，简称为$r\cdot$-组合数或组合数，记为$C_{n}^{r}$或$C(n,r)$。  
显然， $r$ - 组合与 $r$ - 排列的区别在于 $r\cdot$ 组合不考虑组合中元素的排列次序， $r\cdot$ - 排列必须考 虑排列中各元素的排列次序。如果两个$r\cdot$-排列所含的元素完全相同，仅仅是排列次序不同，两个$r\cdot$-排列是同一个组合，由此得到有如下组合数计算公式：  
【定理1.15】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r-$组合数计算公式：  
$$
C(n,r)=\frac{P(n,r)}{r!}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r!}=\frac{n!}{r!(n-r)!}
$$"
定理1.14,定理,"['第一章  集合与计数基础', '§ 1.3 有限集的基本计数技术', '1.3.3 排列计数与组合计数', '一、不重复的排列与组合']","{'实体类型': '定理', '内容': '对于任意给定的两个正整数n和r，且r≤n，其r-圆排列数为Pc(n,r)：Pc(n,r)=P(n,r)/r=n(n-1)(n-2)⋯(n-r+1)/r=n!/r(n-r)!'}",,4,"首先考察如下排列问题：  
某班有35 名同学，现从中选出15 名同学排成一排，问有多少种排列方式？  
这个问题有如下两个关键要点：第一、在排列中每位同学最多只能出现一次，也就是无重复性；第二、不同的次序构成不同的排列。由此得到如下不重复排列的概念：  
【定义1.21】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中依次取出$r$ 个不同元素并将其按取出的次序排成一排，由此形成的一个有序排列称之为不重复$r\cdot$-排列，简称为$r\cdot$-排列或排列，不重复$r\cdot$-排列的个数称为不重复$r\cdot$-排列数，简称为$r\cdot$-排列数或排列数，记为${P}_{n}^{r}$或$P(n,r)$。称$r=n$时构成的排列称为全排列，$r<n$时构成的排列为选排列。  
根据乘法原理，显然可以得到如下结论：  
【定理1.13】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r\cdot$-排列数计算公式：  
$P(n,r)=n(n-1)(n-2)\cdots(n-r+1)\ \ ={\frac{n!}{(n-r)!}}$ 其中：$n!=n(n-1)(n-2)\cdots2\cdot1$  
【定义1.22】假设$S$是由$n$ 个不同的元素组成的集合，从$S$ 中依次取出$r$ 个不同元素并将其按取出的次序排成一个圆圈，由此形成的一个有序圆排列称之为不重复$r\cdot$-圆排列，简称为$r\cdot$-圆排列或圆排列，不重复$r\cdot$圆排列的个数称为不重复$r\cdot$-圆排列数，简称为$r\cdot$-圆排列数或圆排列数，记为${\cal P}_{c}(n,r)$。  
相对于上述圆排列的概念，有时亦将$r\cdot$-排列称为$r$-线排列或线排列。由前面分析不难看出，如果将每个$r\cdot$-线排列的首尾相连构成一个$r\cdot$-圆排列，则由此构成的所有圆排列必然有$r$倍的重复数。故有如下$r\cdot$-圆排列计算公式：  
【定理1.14】对于任意给定的两个正整数$n$ 和$r$，且$r\leq n$，其$r\cdot$-圆排列数为$P_{c}(n,r)$：  
$$
P_{c}(n,r)=\frac{P(n,r)}{r}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r}=\frac{n!}{r(n-r)!}
$$  
以上例子的共有特点是所有选出的元素都有一定的次序。事实上，很多情况下并不需要选出的元素具有有次序。  
考察如下组合问题：  
某班有35 名同学，现从中任意选出15 名同学参加问卷活动，问有多少种选择方式？  
与前述$r$-排列问题不同的是，这个问题只考虑抽取的是哪15 名同学，并不考虑抽取次序以及与之相关的排列问题。由此得到如下不重复组合及相关组合数的概念：  
【定义1.23】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中任意取出$r$ 个不同元素组成一个子集合，称每一个这样的子集合为一个不重复$r$-组合，简称为$r\cdot$-组合或组合，不重复$r$-组合的个数称为不重复$r\cdot$-组合数，简称为$r\cdot$-组合数或组合数，记为$C_{n}^{r}$或$C(n,r)$。  
显然， $r$ - 组合与 $r$ - 排列的区别在于 $r\cdot$ 组合不考虑组合中元素的排列次序， $r\cdot$ - 排列必须考 虑排列中各元素的排列次序。如果两个$r\cdot$-排列所含的元素完全相同，仅仅是排列次序不同，两个$r\cdot$-排列是同一个组合，由此得到有如下组合数计算公式：  
【定理1.15】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r-$组合数计算公式：  
$$
C(n,r)=\frac{P(n,r)}{r!}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r!}=\frac{n!}{r!(n-r)!}
$$"
定理1.15,定理,"['第一章  集合与计数基础', '§ 1.3 有限集的基本计数技术', '1.3.3 排列计数与组合计数', '一、不重复的排列与组合']","{'实体类型': '定理', '内容': '对于任意两个正整数n和r，且r≤n，成立如下r-组合数计算公式：C(n,r)=P(n,r)/r!=n(n-1)(n-2)⋯(n-r+1)/r!=n!/(r!(n-r)!)'}",,4,"首先考察如下排列问题：  
某班有35 名同学，现从中选出15 名同学排成一排，问有多少种排列方式？  
这个问题有如下两个关键要点：第一、在排列中每位同学最多只能出现一次，也就是无重复性；第二、不同的次序构成不同的排列。由此得到如下不重复排列的概念：  
【定义1.21】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中依次取出$r$ 个不同元素并将其按取出的次序排成一排，由此形成的一个有序排列称之为不重复$r\cdot$-排列，简称为$r\cdot$-排列或排列，不重复$r\cdot$-排列的个数称为不重复$r\cdot$-排列数，简称为$r\cdot$-排列数或排列数，记为${P}_{n}^{r}$或$P(n,r)$。称$r=n$时构成的排列称为全排列，$r<n$时构成的排列为选排列。  
根据乘法原理，显然可以得到如下结论：  
【定理1.13】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r\cdot$-排列数计算公式：  
$P(n,r)=n(n-1)(n-2)\cdots(n-r+1)\ \ ={\frac{n!}{(n-r)!}}$ 其中：$n!=n(n-1)(n-2)\cdots2\cdot1$  
【定义1.22】假设$S$是由$n$ 个不同的元素组成的集合，从$S$ 中依次取出$r$ 个不同元素并将其按取出的次序排成一个圆圈，由此形成的一个有序圆排列称之为不重复$r\cdot$-圆排列，简称为$r\cdot$-圆排列或圆排列，不重复$r\cdot$圆排列的个数称为不重复$r\cdot$-圆排列数，简称为$r\cdot$-圆排列数或圆排列数，记为${\cal P}_{c}(n,r)$。  
相对于上述圆排列的概念，有时亦将$r\cdot$-排列称为$r$-线排列或线排列。由前面分析不难看出，如果将每个$r\cdot$-线排列的首尾相连构成一个$r\cdot$-圆排列，则由此构成的所有圆排列必然有$r$倍的重复数。故有如下$r\cdot$-圆排列计算公式：  
【定理1.14】对于任意给定的两个正整数$n$ 和$r$，且$r\leq n$，其$r\cdot$-圆排列数为$P_{c}(n,r)$：  
$$
P_{c}(n,r)=\frac{P(n,r)}{r}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r}=\frac{n!}{r(n-r)!}
$$  
以上例子的共有特点是所有选出的元素都有一定的次序。事实上，很多情况下并不需要选出的元素具有有次序。  
考察如下组合问题：  
某班有35 名同学，现从中任意选出15 名同学参加问卷活动，问有多少种选择方式？  
与前述$r$-排列问题不同的是，这个问题只考虑抽取的是哪15 名同学，并不考虑抽取次序以及与之相关的排列问题。由此得到如下不重复组合及相关组合数的概念：  
【定义1.23】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中任意取出$r$ 个不同元素组成一个子集合，称每一个这样的子集合为一个不重复$r$-组合，简称为$r\cdot$-组合或组合，不重复$r$-组合的个数称为不重复$r\cdot$-组合数，简称为$r\cdot$-组合数或组合数，记为$C_{n}^{r}$或$C(n,r)$。  
显然， $r$ - 组合与 $r$ - 排列的区别在于 $r\cdot$ 组合不考虑组合中元素的排列次序， $r\cdot$ - 排列必须考 虑排列中各元素的排列次序。如果两个$r\cdot$-排列所含的元素完全相同，仅仅是排列次序不同，两个$r\cdot$-排列是同一个组合，由此得到有如下组合数计算公式：  
【定理1.15】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r-$组合数计算公式：  
$$
C(n,r)=\frac{P(n,r)}{r!}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r!}=\frac{n!}{r!(n-r)!}
$$"
定理1.18,定理,"['第一章  集合与计数基础', '§ 1.3 有限集的基本计数技术', '1.3.3 排列计数与组合计数', '三、可重复的组合']","{'实体类型': '定理', '条件': '给定m元重集，每个元素的个数不小于r', '结论': '基于该重集的可重复r-组合数为C(m-1+r, r)'}",,4,"考察如下可重复的组合问题：从包含苹果、橙子和梨子的筐中任取4 个水果招待客人，假设筐中苹果、橙子和梨子的个数均多于4 个且不关心取水果的次序，问有多少种取法？  
可对这4 个水果的取法做如下枚举：  
4 个苹果；4 个橙子；4 个梨子；3 个苹果，1 个橙子；3 个苹果，1 个梨子；3 个橙子，1 个苹果；3 个橙子，1 个梨子；3 个梨子，1 个苹果；3 个梨子，1 个橙子；2 个橙子，2 个苹果；2 个橙子，2 个梨子；2 个梨子，2 个苹果；2 个橙子，1 个苹果，1 个梨子；2 个苹果，1 个梨子，1 个橙子；2 个梨子，1 个苹果，1 个橙子。  
由此可知取法一共有15 种。当水果种类或取出数目比较大时，这种枚举方法显然是不可行的。在这个问题中，可以将包含苹果、橙子和梨子的筐子分别看成是一个重集。由于不考虑取水果的次序，因此可将该问题看成是一种基于重集的可重复的组合数计算问题。  
下面具体介绍可重复的组合数计算问题的相关概念及解法。  
【定义1.25】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的重集，从该重集中任意取出$r$ 个元素组成一个子重集，称每一个这样的子重集为一个可重复$r\cdot$-组合，可重复$r\cdot$组合的个数称为可重复$r$-组合数。  
下面结合一个具体实例详细介绍可重复$r\cdot$-组合数的计算问题。  
【定理1.18】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的$m$ 元重集，且重集中每个元素的从数均不小于 $r$ ，则基于该重集的可重复 $r\cdot$ - 组合数为 $C(m-1+r,\ r)$ 。"
定理1.19,定理,"['第一章  集合与计数基础', '§ 1.4 有限集的高级计数技术', '1.4.2 递推关系的求解']","{'实体类型': '定理', '内容': '任意给出$k$个常数$b_{0}$，$b_{1}$，⋯，$b_{k-1}$，有且仅有唯一一个数列是递推关系式 (1 −17) 满足初始条件 $v_{0}=b_{0}$，$v_{1}=b_{1}$，⋯，$v_{k-1}=b_{k-1}$ 的解'}",,3,"递推关系是复杂问题和动态问题求解重要工具，要使递推关系在问题求解中发挥作用特别是在计数问题中发挥作用，有时需要实现对递推关系式的求解，也就是说要找到满足递推公式的所有数列或部分数列的显示通项表达式。对递推关系式的求解是一个非常复杂的数学问题，属于离散数学及相关学科的前沿研究课题，有兴趣的读者可以查阅相关资料做进一步深入研究。作为抛砖引玉，我们仅介绍其中两种最常用的基本解法，即针对简单递推关系的迭代求解方法和针对常系数齐次线性递推关系的特征根求解方法。  
迭代求解法是一种最基本的解法，该方法主要用于求解一些比较简单的递推关系式，由如下两个基本步骤构成：  
第一、利用递推关系式对其右边的表达式进行迭代，并推测通项的显示表达式；  
第二、用数学归纳法证明得到的公式。  
目前还没有一个一般性的方法或公式能够实现对任意递推关系式的求解，通常需要针对对递推关系式的具体特点给出相应的求解方法。常系数齐次线性递推关系是一种特殊的递推关系，针对这类递推关系有一套完备可行的求解理论和方法。这套求解理论和方法是求解其它递推关系式的基础，因为很多其它递推关系式都是通过设法将其转化为某种常系数齐次线性递推关系的途径实现求解。下面给出常系数齐次线性递推关系的定义：  
【定义1.27】设$a_{1}$，$a_{2}$，⋯，$a_{k}$是$k$个常数且$a_{k}\neq0$，则下列递推关系：  
$$
u_{n}=a_{1}u_{n-1}+a_{2}u_{n-2}+\cdots+a_{k}u_{n-k}(n\geq k)
$$  
称为$k$阶常系数线性齐次递推关系。  
如果数列 $\{b_{n}\}_{n\geq0}$ 满足 $.b_{n}=a_{1}b_{n-1}+a_{2}b_{n-2}+\cdots+a_{k}b_{n-k}(n\geq k)$ ，则称数列 $\{b_{n}\}_{n\geq O}$ 或 $u_{n}=b_{n}{\big(}n=0,~1,~2,~\cdots{\big)}$是递推关系式(1 −17)的一个解。  
问题：递推关系式(1 −17)有没有解？如果有解，有多少个解？如何求解？下面的定理表明常系数齐次线性递推关系在满足初始条件的情况下有唯一解：  
【定理1.19】任意给出$k$个常数$b_{0}\,,\;\;b_{1}\,,\;\;\cdots\,,\;\;b_{k-1}$，有且仅有唯一一个数列是递推关系式 (1 −17) 满足初始条件 $v_{0}=b_{0}$ ， $v_{1}=b_{1}$ ， ⋯ ， $v_{k-1}=b_{k-1}$ 的解。  
对于常系数齐次线性递推关系的求解，基本思路是采用一种所谓特征根的方法，通过引入特征方程和特征根的概念，巧妙地将递推关系的求解问题转化为求代数方程根的求解问题。为此，我们引入如下特征方程和特征根的定义：  
【定义1.27】如下方程：  
$$
x^{k}-a_{1}x^{k-1}-a_{2}x^{k-2}-\cdots-a_{k-1}x-a_{k}=0
$$  
称为递推关系式(1 −17)的特征方程，它的根称为递推关系式(1 −17)的特征根。  
因为$a_{k}\neq0$，所以0 不是递推关系式(1 −17)的特征根。 下面的定理非常关键，它给出了特征根与常系数齐次线性递推关系解之间的联系：  
【定理1.20】设$q$ 是非0 复数，则$u_{n}=q^{n}$是递推关系式(1 −17)的一个解当且仅当$q$是递推关系式(1 −17)的一个特征根。  
下面定理给出了常系数齐次线性递推关系解的结构特点：  
【定理1.21】设$\cdot u_{n}=g_{i}(n)(i=1,2,\cdots,s)$均为递推关系式(1 −17)的解，$c_{i}(i=1,\!2,\cdots,s)$为任意常数，则有：  
$$
=\sum_{i=1}^{s}c_{i}g_{i}(n)
$$  
也是递推关系式(1 −17)的解。  
【定理1.22】如果递推关系式(1 −17)的$k$ 个特征根$q_{1}\,,\;\;q_{2}\,,\;\;\cdots\,,\;\;q_{k}$彼此相异，则  
$$
u_{n}=c_{1}q_{1}^{n}+c_{2}q_{2}^{n}+\cdots+c_{k}q_{k}^{n}
$$  
是递推关系式(1 −17)的通解。其中$c_{1}\,,\;\;c_{2}\,,\;\;\cdots\,,\;\;c_{k}$为任意常数。"
定理1.20,定理,"['第一章  集合与计数基础', '§ 1.4 有限集的高级计数技术', '1.4.2 递推关系的求解']","{'实体类型': '定理', '内容': '设$q$ 是非0 复数，则$u_{n}=q^{n}$是递推关系式(1 −17)的一个解当且仅当$q$是递推关系式(1 −17)的一个特征根'}",,3,"递推关系是复杂问题和动态问题求解重要工具，要使递推关系在问题求解中发挥作用特别是在计数问题中发挥作用，有时需要实现对递推关系式的求解，也就是说要找到满足递推公式的所有数列或部分数列的显示通项表达式。对递推关系式的求解是一个非常复杂的数学问题，属于离散数学及相关学科的前沿研究课题，有兴趣的读者可以查阅相关资料做进一步深入研究。作为抛砖引玉，我们仅介绍其中两种最常用的基本解法，即针对简单递推关系的迭代求解方法和针对常系数齐次线性递推关系的特征根求解方法。  
迭代求解法是一种最基本的解法，该方法主要用于求解一些比较简单的递推关系式，由如下两个基本步骤构成：  
第一、利用递推关系式对其右边的表达式进行迭代，并推测通项的显示表达式；  
第二、用数学归纳法证明得到的公式。  
目前还没有一个一般性的方法或公式能够实现对任意递推关系式的求解，通常需要针对对递推关系式的具体特点给出相应的求解方法。常系数齐次线性递推关系是一种特殊的递推关系，针对这类递推关系有一套完备可行的求解理论和方法。这套求解理论和方法是求解其它递推关系式的基础，因为很多其它递推关系式都是通过设法将其转化为某种常系数齐次线性递推关系的途径实现求解。下面给出常系数齐次线性递推关系的定义：  
【定义1.27】设$a_{1}$，$a_{2}$，⋯，$a_{k}$是$k$个常数且$a_{k}\neq0$，则下列递推关系：  
$$
u_{n}=a_{1}u_{n-1}+a_{2}u_{n-2}+\cdots+a_{k}u_{n-k}(n\geq k)
$$  
称为$k$阶常系数线性齐次递推关系。  
如果数列 $\{b_{n}\}_{n\geq0}$ 满足 $.b_{n}=a_{1}b_{n-1}+a_{2}b_{n-2}+\cdots+a_{k}b_{n-k}(n\geq k)$ ，则称数列 $\{b_{n}\}_{n\geq O}$ 或 $u_{n}=b_{n}{\big(}n=0,~1,~2,~\cdots{\big)}$是递推关系式(1 −17)的一个解。  
问题：递推关系式(1 −17)有没有解？如果有解，有多少个解？如何求解？下面的定理表明常系数齐次线性递推关系在满足初始条件的情况下有唯一解：  
【定理1.19】任意给出$k$个常数$b_{0}\,,\;\;b_{1}\,,\;\;\cdots\,,\;\;b_{k-1}$，有且仅有唯一一个数列是递推关系式 (1 −17) 满足初始条件 $v_{0}=b_{0}$ ， $v_{1}=b_{1}$ ， ⋯ ， $v_{k-1}=b_{k-1}$ 的解。  
对于常系数齐次线性递推关系的求解，基本思路是采用一种所谓特征根的方法，通过引入特征方程和特征根的概念，巧妙地将递推关系的求解问题转化为求代数方程根的求解问题。为此，我们引入如下特征方程和特征根的定义：  
【定义1.27】如下方程：  
$$
x^{k}-a_{1}x^{k-1}-a_{2}x^{k-2}-\cdots-a_{k-1}x-a_{k}=0
$$  
称为递推关系式(1 −17)的特征方程，它的根称为递推关系式(1 −17)的特征根。  
因为$a_{k}\neq0$，所以0 不是递推关系式(1 −17)的特征根。 下面的定理非常关键，它给出了特征根与常系数齐次线性递推关系解之间的联系：  
【定理1.20】设$q$ 是非0 复数，则$u_{n}=q^{n}$是递推关系式(1 −17)的一个解当且仅当$q$是递推关系式(1 −17)的一个特征根。  
下面定理给出了常系数齐次线性递推关系解的结构特点：  
【定理1.21】设$\cdot u_{n}=g_{i}(n)(i=1,2,\cdots,s)$均为递推关系式(1 −17)的解，$c_{i}(i=1,\!2,\cdots,s)$为任意常数，则有：  
$$
=\sum_{i=1}^{s}c_{i}g_{i}(n)
$$  
也是递推关系式(1 −17)的解。  
【定理1.22】如果递推关系式(1 −17)的$k$ 个特征根$q_{1}\,,\;\;q_{2}\,,\;\;\cdots\,,\;\;q_{k}$彼此相异，则  
$$
u_{n}=c_{1}q_{1}^{n}+c_{2}q_{2}^{n}+\cdots+c_{k}q_{k}^{n}
$$  
是递推关系式(1 −17)的通解。其中$c_{1}\,,\;\;c_{2}\,,\;\;\cdots\,,\;\;c_{k}$为任意常数。"
定理1.21,定理,"['第一章  集合与计数基础', '§ 1.4 有限集的高级计数技术', '1.4.2 递推关系的求解']","{'实体类型': '定理', '内容': '设$u_{n}=g_{i}(n)(i=1,2,\\cdots,s)$均为递推关系式(1 −17)的解，$c_{i}(i=1,2,\\cdots,s)$为任意常数，则有：$\\sum_{i=1}^{s}c_{i}g_{i}(n)$也是递推关系式(1 −17)的解'}",,3,"递推关系是复杂问题和动态问题求解重要工具，要使递推关系在问题求解中发挥作用特别是在计数问题中发挥作用，有时需要实现对递推关系式的求解，也就是说要找到满足递推公式的所有数列或部分数列的显示通项表达式。对递推关系式的求解是一个非常复杂的数学问题，属于离散数学及相关学科的前沿研究课题，有兴趣的读者可以查阅相关资料做进一步深入研究。作为抛砖引玉，我们仅介绍其中两种最常用的基本解法，即针对简单递推关系的迭代求解方法和针对常系数齐次线性递推关系的特征根求解方法。  
迭代求解法是一种最基本的解法，该方法主要用于求解一些比较简单的递推关系式，由如下两个基本步骤构成：  
第一、利用递推关系式对其右边的表达式进行迭代，并推测通项的显示表达式；  
第二、用数学归纳法证明得到的公式。  
目前还没有一个一般性的方法或公式能够实现对任意递推关系式的求解，通常需要针对对递推关系式的具体特点给出相应的求解方法。常系数齐次线性递推关系是一种特殊的递推关系，针对这类递推关系有一套完备可行的求解理论和方法。这套求解理论和方法是求解其它递推关系式的基础，因为很多其它递推关系式都是通过设法将其转化为某种常系数齐次线性递推关系的途径实现求解。下面给出常系数齐次线性递推关系的定义：  
【定义1.27】设$a_{1}$，$a_{2}$，⋯，$a_{k}$是$k$个常数且$a_{k}\neq0$，则下列递推关系：  
$$
u_{n}=a_{1}u_{n-1}+a_{2}u_{n-2}+\cdots+a_{k}u_{n-k}(n\geq k)
$$  
称为$k$阶常系数线性齐次递推关系。  
如果数列 $\{b_{n}\}_{n\geq0}$ 满足 $.b_{n}=a_{1}b_{n-1}+a_{2}b_{n-2}+\cdots+a_{k}b_{n-k}(n\geq k)$ ，则称数列 $\{b_{n}\}_{n\geq O}$ 或 $u_{n}=b_{n}{\big(}n=0,~1,~2,~\cdots{\big)}$是递推关系式(1 −17)的一个解。  
问题：递推关系式(1 −17)有没有解？如果有解，有多少个解？如何求解？下面的定理表明常系数齐次线性递推关系在满足初始条件的情况下有唯一解：  
【定理1.19】任意给出$k$个常数$b_{0}\,,\;\;b_{1}\,,\;\;\cdots\,,\;\;b_{k-1}$，有且仅有唯一一个数列是递推关系式 (1 −17) 满足初始条件 $v_{0}=b_{0}$ ， $v_{1}=b_{1}$ ， ⋯ ， $v_{k-1}=b_{k-1}$ 的解。  
对于常系数齐次线性递推关系的求解，基本思路是采用一种所谓特征根的方法，通过引入特征方程和特征根的概念，巧妙地将递推关系的求解问题转化为求代数方程根的求解问题。为此，我们引入如下特征方程和特征根的定义：  
【定义1.27】如下方程：  
$$
x^{k}-a_{1}x^{k-1}-a_{2}x^{k-2}-\cdots-a_{k-1}x-a_{k}=0
$$  
称为递推关系式(1 −17)的特征方程，它的根称为递推关系式(1 −17)的特征根。  
因为$a_{k}\neq0$，所以0 不是递推关系式(1 −17)的特征根。 下面的定理非常关键，它给出了特征根与常系数齐次线性递推关系解之间的联系：  
【定理1.20】设$q$ 是非0 复数，则$u_{n}=q^{n}$是递推关系式(1 −17)的一个解当且仅当$q$是递推关系式(1 −17)的一个特征根。  
下面定理给出了常系数齐次线性递推关系解的结构特点：  
【定理1.21】设$\cdot u_{n}=g_{i}(n)(i=1,2,\cdots,s)$均为递推关系式(1 −17)的解，$c_{i}(i=1,\!2,\cdots,s)$为任意常数，则有：  
$$
=\sum_{i=1}^{s}c_{i}g_{i}(n)
$$  
也是递推关系式(1 −17)的解。  
【定理1.22】如果递推关系式(1 −17)的$k$ 个特征根$q_{1}\,,\;\;q_{2}\,,\;\;\cdots\,,\;\;q_{k}$彼此相异，则  
$$
u_{n}=c_{1}q_{1}^{n}+c_{2}q_{2}^{n}+\cdots+c_{k}q_{k}^{n}
$$  
是递推关系式(1 −17)的通解。其中$c_{1}\,,\;\;c_{2}\,,\;\;\cdots\,,\;\;c_{k}$为任意常数。"
定理1.22,定理,"['第一章  集合与计数基础', '§ 1.4 有限集的高级计数技术', '1.4.2 递推关系的求解']","{'实体类型': '定理', '内容': '如果递推关系式(1 −17)的$k$ 个特征根$q_{1}$，$q_{2}$，⋯，$q_{k}$彼此相异，则$u_{n}=c_{1}q_{1}^{n}+c_{2}q_{2}^{n}+\\cdots+c_{k}q_{k}^{n}$是递推关系式(1 −17)的通解。其中$c_{1}$，$c_{2}$，⋯，$c_{k}$为任意常数'}",,3,"递推关系是复杂问题和动态问题求解重要工具，要使递推关系在问题求解中发挥作用特别是在计数问题中发挥作用，有时需要实现对递推关系式的求解，也就是说要找到满足递推公式的所有数列或部分数列的显示通项表达式。对递推关系式的求解是一个非常复杂的数学问题，属于离散数学及相关学科的前沿研究课题，有兴趣的读者可以查阅相关资料做进一步深入研究。作为抛砖引玉，我们仅介绍其中两种最常用的基本解法，即针对简单递推关系的迭代求解方法和针对常系数齐次线性递推关系的特征根求解方法。  
迭代求解法是一种最基本的解法，该方法主要用于求解一些比较简单的递推关系式，由如下两个基本步骤构成：  
第一、利用递推关系式对其右边的表达式进行迭代，并推测通项的显示表达式；  
第二、用数学归纳法证明得到的公式。  
目前还没有一个一般性的方法或公式能够实现对任意递推关系式的求解，通常需要针对对递推关系式的具体特点给出相应的求解方法。常系数齐次线性递推关系是一种特殊的递推关系，针对这类递推关系有一套完备可行的求解理论和方法。这套求解理论和方法是求解其它递推关系式的基础，因为很多其它递推关系式都是通过设法将其转化为某种常系数齐次线性递推关系的途径实现求解。下面给出常系数齐次线性递推关系的定义：  
【定义1.27】设$a_{1}$，$a_{2}$，⋯，$a_{k}$是$k$个常数且$a_{k}\neq0$，则下列递推关系：  
$$
u_{n}=a_{1}u_{n-1}+a_{2}u_{n-2}+\cdots+a_{k}u_{n-k}(n\geq k)
$$  
称为$k$阶常系数线性齐次递推关系。  
如果数列 $\{b_{n}\}_{n\geq0}$ 满足 $.b_{n}=a_{1}b_{n-1}+a_{2}b_{n-2}+\cdots+a_{k}b_{n-k}(n\geq k)$ ，则称数列 $\{b_{n}\}_{n\geq O}$ 或 $u_{n}=b_{n}{\big(}n=0,~1,~2,~\cdots{\big)}$是递推关系式(1 −17)的一个解。  
问题：递推关系式(1 −17)有没有解？如果有解，有多少个解？如何求解？下面的定理表明常系数齐次线性递推关系在满足初始条件的情况下有唯一解：  
【定理1.19】任意给出$k$个常数$b_{0}\,,\;\;b_{1}\,,\;\;\cdots\,,\;\;b_{k-1}$，有且仅有唯一一个数列是递推关系式 (1 −17) 满足初始条件 $v_{0}=b_{0}$ ， $v_{1}=b_{1}$ ， ⋯ ， $v_{k-1}=b_{k-1}$ 的解。  
对于常系数齐次线性递推关系的求解，基本思路是采用一种所谓特征根的方法，通过引入特征方程和特征根的概念，巧妙地将递推关系的求解问题转化为求代数方程根的求解问题。为此，我们引入如下特征方程和特征根的定义：  
【定义1.27】如下方程：  
$$
x^{k}-a_{1}x^{k-1}-a_{2}x^{k-2}-\cdots-a_{k-1}x-a_{k}=0
$$  
称为递推关系式(1 −17)的特征方程，它的根称为递推关系式(1 −17)的特征根。  
因为$a_{k}\neq0$，所以0 不是递推关系式(1 −17)的特征根。 下面的定理非常关键，它给出了特征根与常系数齐次线性递推关系解之间的联系：  
【定理1.20】设$q$ 是非0 复数，则$u_{n}=q^{n}$是递推关系式(1 −17)的一个解当且仅当$q$是递推关系式(1 −17)的一个特征根。  
下面定理给出了常系数齐次线性递推关系解的结构特点：  
【定理1.21】设$\cdot u_{n}=g_{i}(n)(i=1,2,\cdots,s)$均为递推关系式(1 −17)的解，$c_{i}(i=1,\!2,\cdots,s)$为任意常数，则有：  
$$
=\sum_{i=1}^{s}c_{i}g_{i}(n)
$$  
也是递推关系式(1 −17)的解。  
【定理1.22】如果递推关系式(1 −17)的$k$ 个特征根$q_{1}\,,\;\;q_{2}\,,\;\;\cdots\,,\;\;q_{k}$彼此相异，则  
$$
u_{n}=c_{1}q_{1}^{n}+c_{2}q_{2}^{n}+\cdots+c_{k}q_{k}^{n}
$$  
是递推关系式(1 −17)的通解。其中$c_{1}\,,\;\;c_{2}\,,\;\;\cdots\,,\;\;c_{k}$为任意常数。"
定理10.1,定理,"['第十章  特殊图模型与算法', '§ 10.1 欧拉图与哈密顿图', '10.1.1  欧拉图及其性质']","{'实体类型': '定理', '内容': '无向图是欧拉图当且仅当为连通图且所有结点度数均为偶数'}",,3,"为更好地介绍欧拉图，有必要再回顾一下前述哥尼斯堡七桥问题：哥尼斯堡小镇有一条贯穿全市的小河，河上有两个小岛，由七座桥将这两个小岛及其与河两岸进行互联，如图$10-$1(a)所示。问题是怎样才能不重复、不遗漏地走完七座桥，并回到出发点。  
![图10-1 哥尼斯堡七桥问题 ](images/f92d2bafd1492d4ec26c4c92f27d5040f5974fc8bef369b51ff49b676bd82f86.jpg)  
瑞士著名的数学家欧拉把该问题抽象成如图10-1(b)所示的图模型，其中两岸陆地和小岛分别被抽象成了 A, B, C, D 四个结点， 每个桥分别被抽象成了连接相应结点的无向边。 于是， 哥尼斯堡七桥问题就等价于图10-1(b)中是否存在一条从图中任意结点出发，经过图中所有边一次且仅一次的回路。由此得到如下欧拉图的相关定义：  
【定义10.1】设 $G=\langle V,E\rangle$是任意给定的一个图模型，通过图𝐺中所有边一次且仅一次的通路称为欧拉通路，通过图$G$中所有边一次且仅一的回路称为欧拉回路。如果图𝐺中存在欧拉回路，则称之为欧拉图，如果$G$中存在欧拉通路但不存在欧拉回路，则称之为半欧拉图。 规定平凡图为欧拉图。  
以上定义既适合无向图也适合有向图。从定义可以看出，欧拉通路是经过图中所有边的通路中长度最短的通路；欧拉回路是经过图中所有边的回路中长度最短的回路。如果仅用边来描述，那么欧拉通路和欧拉回路其实都是图中所有边的一个全排列。  
【定理10.1】设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$是欧拉图当且仅当 $G=\langle V,E\rangle$为连通图且所有结点度数均为偶数。  
【  
【推论10.1】设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$是半欧拉图当  
且仅当 $G=\langle V,E\rangle$为连通图且恰有2 个奇度数结点。  
由推论10.1 可知，如果$G$是连通图且刚好有奇度结点，那么在$G$中存在一条欧拉道路，且一定以其中一个奇度结点为始点，以另一个奇度结点为终点。  
下面进一步给出有向欧拉图和半欧拉图的判定定理：  
【定理10.2】设 $G=\langle V,E\rangle$是任意给定的一个有向图模型，则有：$G=\langle V,E\rangle$是欧拉图当且仅当 $G=\langle V,E\rangle$为连通图且所有结点的入度等等于出度；$G=\langle V,E\rangle$是半欧拉图，当且仅当$G=\langle V,E\rangle$连通且仅有一个结点的入度比出度大1，另外一个结点的出度比入度大1，其余结点的入度等于出度。  
对于一个欧拉图或半欧拉图，可以使用弗洛莱算法自动找到其欧拉回路或欧拉通路。该算法的基本思路是首先从图中的任一点出发，随机去掉与此点相连的边，然后在保证以下两个条件的基础上，依次去掉与之相连的边：  
1）如果去掉某边后使得该边的某端点为孤立结点，则将该端点与该边一并去掉。  
2）在去掉某边后，不能造成图模型的不连通。  
当算法停止时，获得的路径$L=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\ldots e_{n}v_{n}(v_{0}=v_{n})$就是图$G=\langle V,E\rangle$的一条欧拉回路。弗洛莱算法的具体步骤如下：  
1) 首先，在结点集𝑉中任选一个结点$v_{0}$为初始结点，并设初始通路为$L_{0}=v_{0}$。 2) 设已选好的简单通路为$\boldsymbol{\cdot}L_{i}=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\ldots e_{i}v_{i}$，按照下列条件从边集合：  
$$
E-\{e_{1},e_{2},e_{3},\ldots,e_{i}\}
$$  
中选取边]${e}_{i+1}$，其中$G_{1}$是从$G$删除边集合$\{e_{1},e_{2},e_{3},\ldots,e_{i}\}.$后得到的图：  
$\bullet$ 结点$v_{i}$是边$\boldsymbol{\cdot}\boldsymbol{e}_{i+1}$的端点。  
$\bullet$ 除非无其他边可以选取，否则删除边$\boldsymbol{\cdot}\boldsymbol{e}_{i+1}$后不改变图$G_{1}$的连通性。  
3）将$e_{i+1}v_{i+1}$加入到$L_{i}$中，形成新路径$\mathopen:L_{i+1}=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\dots e_{i}v_{i}e_{i+1}v_{i+1}$，令$i=i+1$  
4）返回步骤2）重复上述过程，直到 $i=|E|$ 。  
当图模型是一个半欧拉图时候，使用上述弗洛莱算法显然也可得到其欧拉通路，请读者自己思考算法的具体步骤和要点，不再赘述。  
![图10-10 房间布局的设计图     图10-11 图模型与欧拉通路       图10-12 行走路径 ](images/1200dfbb0792a6069379408b8f0f3304dd4b6248c5b1e2f4c4917b8d0bf94d23.jpg)"
定理10.11,定理,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.3.1  平面图的概念与性质']","{'实体类型': '定理', '内容': '平面图中所有面的次数之和等于边数的两倍'}",,3,"所谓平面图，直观地说就是可以将该图嵌入到某个平面上。如图10-46（a）所示，图模型的边有时不仅在结点处相交，而且还在某些非结点处有交叉，这些非结点处交叉点的边重叠特征显然会导致图模型不能嵌入在同一个平面上。因此，为了将图模型嵌入平面，首先必须适当调整该图中边的走向，以保证任意两条边不会在非结点处有交叉，如图10-46（b）所示。由此得到可平面图和平面图的相关概念。  
【定义10.6】设$G=\langle V,E\rangle$是任意给定的一个图模型，如果该图中有两条边在非结点处有交叉，则称这两条边为该图的交叉边，交叉的具体位置称为交叉点。如果可将图𝐺画在同一个平面上，并且所有边除在结点处之外均不交叉，则称图𝐺可嵌入平面，或称𝐺为可平面图，否则称该图为不可平面图或非平面图。对于可平面图𝐺，将其边不交叉的画法称为𝐺的平面嵌入表示。以平面嵌入方式表示的图可平面图𝐺称为平面图。对于一个平面图𝐺，若对其再加一条边就变成不可平面图，则称𝐺为最大平面图。  
![](images/ad5984e0ab09600028eb4068193d74e75743de0f027a20b4d084511a312873d4.jpg)  
![（a）完全二分图$K_{3,3}$  （b）无法消除交叉  ](images/aa69f9dcec49f0e95a534b493200688a98dae4f4be8a347fbd35c04b8c21413b.jpg)  
例如，对于图10-46（a）所示的图，该图有三对交叉边，即$(v_{1},v_{4})$和$(v_{2},v_{3}),~(v_{1},v_{4})$和$(v_{2},v_{5})$、$(v_{1},v_{5})$和$(v_{2},v_{3})$。由于可将该图表示成图10-46（b）的形式，故该图是一个可平面图。图10-46（b）所示的图就是一个平面图。显然，如果在该平面图上增加一条边，则该图就变成一个不可平面图，故该是一个最大平面图。再如，对于图10-47（a）所示的图模型，无论怎么调整边的走向都不能将其以平面嵌入方式表示，如图10-47（b）所示。故图10-47（a）所示的图模型为不可平面图或非平面图。  
在没有特别要求的情况下，通常将可平面图与平面图不加区分地统称为平面图。与一般图模型显著不同的是，平面图模型除了具有结点和边这两个基本构件之外，还有一般图模型所没有的面的概念，并且由进一步面衍生出边界的概念。因此，平面图是一类非常重要的特殊图模型，无论在理论上还是在应用方面都具有非常重要的价值，在印刷电路板的设计、城市管网设计与规划等多个领域得到实际应用。  
图论之父欧拉对平面图有着比较深刻的研究，发现并论证了平面图的结点、边和面之间的数量关系，提出了著名的欧拉公式。下面给出平面图中面的相关概念：  
【定义10.7】设$G=\langle V,E\rangle$是任意给定的一个平面图，由𝐺中边所包围且内部不包含结点与边的区域，称为$G$的一个面。区域面积有限的面称为有限面，区域面积无限的面称为无限面。对于$G$的任意一个面$R$，包围面$R$的所有边构成的回路称为面𝑅的边界，面𝑅边界中边的个数称为面$R$的次数或度，记为${\bf d e g}(R)$。  
通俗地说，如果把一个平面图画在平面上，然后用小刀沿着图的边将平面切开，那么整个平面就被切成若干块，其中每一块就是图的一个面。或者说，平面图的一个面就是平面中一个以边为界线不能再分割的区域块。例如，对于图10-46（b）所示的平面图，一共有六个面，其中有一个面是无限面，其余五个是有限面。需要注意的是，对于任何一个平面图，该图有且仅有一个无限面。下面的定理10.11 给出了平面图中面数与边数的数量关系：  
【定理10.11】平面图中所有面的次数之和等于边数的两倍。  
下面定理10.12 是著名的欧拉公式，给出了平面图中结点、边和面之间的数量关系：  
【定理10.12】设$G=\langle V,E\rangle$是任意给定的一个连通平面图，若它有$n$个结点、$m$条边、$r$ 个面，则有  
$$
n-m+r=2\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
【定理10.13】如果平面连通图$G$每个面的次数均为$l(l\geq3)$，则有：  
$$
m=l(n-2)/(l-2)
$$  
其中$m$为$G$的边数，$n$为$G$的结点数。  
【定理10.14】设$G$是一个$(n,m)$简单连通平面图，若$m>1$，则有：  
$$
m\leq3n-6\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
由定理10.4 的逆命题不成立，也就是说满足不等式$m\leq3n-6$的简单连通图不一定是平面图。但是对于一个简单连通图，若不满足$m\leq3n-6$，则一定是非平面图。因此，可用定理10.4 的结论证明某个简单连通图不是非平面图。  
【定理10.15】设$G$为一平面连通简单图，其结点数$n\geq4$，边数为$m$，且$G$不以$K_{3}$为其子图，则有$m\leq2n-4$。  
【定义10.8】对于是任意给定的一个图模型$G=\langle V,E\rangle$  
设$e=(u,v)$是$G$的任意一条边，如果在图$G$中删除该边并新增一个结点$w$及两条边$e_{1}=$$(u,w)$、$e_{2}=(w,v)$ ，则称该操作为对图$G$的边切割操作；  
设𝑤是$G$中任意一个度数为2 的结点，且是边${e_{1}=(u,w)}$和$e_{2}=(w,v)$的公共结点，如果在图$G$中删除结点$w$及边$e_{1},\,e_{2}$，并增加边$e=(u,v)$，则称该操作为对图$G$的结点贯通操作；  
对图$G$的边切割操作和结点贯通操作统称为对图$G$的同胚操作。  
显然，边切割操作和结点贯通操作是一对互逆操作。例如，对于图10-48 所示的两个图模型，可通过对边的切割操作将$G_{1}$变成$G_{2}$，也可通过对结点做贯通操作将$G_{2}$变成$G_{1}$。  
![图10-48  图的同胚操作与同胚关系  ](images/17b45e1706460a818a5492fb4df19f0ddd6b072e9cf57afef7db0852f0c58237.jpg)  
下面在同胚操作的基础上，引入如下两个图之间的同胚关系：  
【定义10.9】设$G_{1}=\langle V_{1},E_{1}\rangle$和$G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，如果可用同胚操作将其中一个转化为另外一个，则称$G_{1}$与$G_{2}$具有同胚关系，简称为$G_{1}$与$G_{2}$同胚。  
根据上述同胚的概念，可以得到如下关于平面图判定的库拉托夫斯基定理：  
【定理10.16】（库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是$G$的任何子图都不同胚于$K_{5}$或$K_{3,3}$。  
【定理10.17】(库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是𝐺的任何子图都不能通过边的收缩得到$K_{5}$或$K_{3,3}$。  
![图10-51 彼得森图收缩为$ K_{5}$](images/b6cd48c8bf37519af48b0cc187afdf1adc13d2c5e160a08fe418ce5c94762fd6.jpg)  
库拉托夫斯基定理是一个非常著名定理，通常将$K_{5}$和$K_{3,3}$称为库拉托夫斯基图。可以使用该定理判定一个图是否为平面图。例如，对于图$10{-}51\mathrm{a}$）所示的彼得森图，收缩其边$(v_{i},u_{i})(i=1,2,3,4,5)$，则可得到图$K_{5}$，见图10-51b)。故彼得森图不是平面图。  
值得注意的是，虽然库拉托夫斯基定理给出了平面图判定的充分必要条件，但是目前还没有基于该定理得到一个有效的判定算法。因此，对于一个比较复杂的图模型，要判定其是否为平面图，有时并不是一件容易的事情。"
定理10.13,定理,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.3.1  平面图的概念与性质']","{'实体类型': '定理', '内容': '如果平面连通图每个面的次数均为$l(l\\geq3)$，则边数$m$和结点数$n$满足$m=l(n-2)/(l-2)$'}",,3,"所谓平面图，直观地说就是可以将该图嵌入到某个平面上。如图10-46（a）所示，图模型的边有时不仅在结点处相交，而且还在某些非结点处有交叉，这些非结点处交叉点的边重叠特征显然会导致图模型不能嵌入在同一个平面上。因此，为了将图模型嵌入平面，首先必须适当调整该图中边的走向，以保证任意两条边不会在非结点处有交叉，如图10-46（b）所示。由此得到可平面图和平面图的相关概念。  
【定义10.6】设$G=\langle V,E\rangle$是任意给定的一个图模型，如果该图中有两条边在非结点处有交叉，则称这两条边为该图的交叉边，交叉的具体位置称为交叉点。如果可将图𝐺画在同一个平面上，并且所有边除在结点处之外均不交叉，则称图𝐺可嵌入平面，或称𝐺为可平面图，否则称该图为不可平面图或非平面图。对于可平面图𝐺，将其边不交叉的画法称为𝐺的平面嵌入表示。以平面嵌入方式表示的图可平面图𝐺称为平面图。对于一个平面图𝐺，若对其再加一条边就变成不可平面图，则称𝐺为最大平面图。  
![](images/ad5984e0ab09600028eb4068193d74e75743de0f027a20b4d084511a312873d4.jpg)  
![（a）完全二分图$K_{3,3}$  （b）无法消除交叉  ](images/aa69f9dcec49f0e95a534b493200688a98dae4f4be8a347fbd35c04b8c21413b.jpg)  
例如，对于图10-46（a）所示的图，该图有三对交叉边，即$(v_{1},v_{4})$和$(v_{2},v_{3}),~(v_{1},v_{4})$和$(v_{2},v_{5})$、$(v_{1},v_{5})$和$(v_{2},v_{3})$。由于可将该图表示成图10-46（b）的形式，故该图是一个可平面图。图10-46（b）所示的图就是一个平面图。显然，如果在该平面图上增加一条边，则该图就变成一个不可平面图，故该是一个最大平面图。再如，对于图10-47（a）所示的图模型，无论怎么调整边的走向都不能将其以平面嵌入方式表示，如图10-47（b）所示。故图10-47（a）所示的图模型为不可平面图或非平面图。  
在没有特别要求的情况下，通常将可平面图与平面图不加区分地统称为平面图。与一般图模型显著不同的是，平面图模型除了具有结点和边这两个基本构件之外，还有一般图模型所没有的面的概念，并且由进一步面衍生出边界的概念。因此，平面图是一类非常重要的特殊图模型，无论在理论上还是在应用方面都具有非常重要的价值，在印刷电路板的设计、城市管网设计与规划等多个领域得到实际应用。  
图论之父欧拉对平面图有着比较深刻的研究，发现并论证了平面图的结点、边和面之间的数量关系，提出了著名的欧拉公式。下面给出平面图中面的相关概念：  
【定义10.7】设$G=\langle V,E\rangle$是任意给定的一个平面图，由𝐺中边所包围且内部不包含结点与边的区域，称为$G$的一个面。区域面积有限的面称为有限面，区域面积无限的面称为无限面。对于$G$的任意一个面$R$，包围面$R$的所有边构成的回路称为面𝑅的边界，面𝑅边界中边的个数称为面$R$的次数或度，记为${\bf d e g}(R)$。  
通俗地说，如果把一个平面图画在平面上，然后用小刀沿着图的边将平面切开，那么整个平面就被切成若干块，其中每一块就是图的一个面。或者说，平面图的一个面就是平面中一个以边为界线不能再分割的区域块。例如，对于图10-46（b）所示的平面图，一共有六个面，其中有一个面是无限面，其余五个是有限面。需要注意的是，对于任何一个平面图，该图有且仅有一个无限面。下面的定理10.11 给出了平面图中面数与边数的数量关系：  
【定理10.11】平面图中所有面的次数之和等于边数的两倍。  
下面定理10.12 是著名的欧拉公式，给出了平面图中结点、边和面之间的数量关系：  
【定理10.12】设$G=\langle V,E\rangle$是任意给定的一个连通平面图，若它有$n$个结点、$m$条边、$r$ 个面，则有  
$$
n-m+r=2\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
【定理10.13】如果平面连通图$G$每个面的次数均为$l(l\geq3)$，则有：  
$$
m=l(n-2)/(l-2)
$$  
其中$m$为$G$的边数，$n$为$G$的结点数。  
【定理10.14】设$G$是一个$(n,m)$简单连通平面图，若$m>1$，则有：  
$$
m\leq3n-6\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
由定理10.4 的逆命题不成立，也就是说满足不等式$m\leq3n-6$的简单连通图不一定是平面图。但是对于一个简单连通图，若不满足$m\leq3n-6$，则一定是非平面图。因此，可用定理10.4 的结论证明某个简单连通图不是非平面图。  
【定理10.15】设$G$为一平面连通简单图，其结点数$n\geq4$，边数为$m$，且$G$不以$K_{3}$为其子图，则有$m\leq2n-4$。  
【定义10.8】对于是任意给定的一个图模型$G=\langle V,E\rangle$  
设$e=(u,v)$是$G$的任意一条边，如果在图$G$中删除该边并新增一个结点$w$及两条边$e_{1}=$$(u,w)$、$e_{2}=(w,v)$ ，则称该操作为对图$G$的边切割操作；  
设𝑤是$G$中任意一个度数为2 的结点，且是边${e_{1}=(u,w)}$和$e_{2}=(w,v)$的公共结点，如果在图$G$中删除结点$w$及边$e_{1},\,e_{2}$，并增加边$e=(u,v)$，则称该操作为对图$G$的结点贯通操作；  
对图$G$的边切割操作和结点贯通操作统称为对图$G$的同胚操作。  
显然，边切割操作和结点贯通操作是一对互逆操作。例如，对于图10-48 所示的两个图模型，可通过对边的切割操作将$G_{1}$变成$G_{2}$，也可通过对结点做贯通操作将$G_{2}$变成$G_{1}$。  
![图10-48  图的同胚操作与同胚关系  ](images/17b45e1706460a818a5492fb4df19f0ddd6b072e9cf57afef7db0852f0c58237.jpg)  
下面在同胚操作的基础上，引入如下两个图之间的同胚关系：  
【定义10.9】设$G_{1}=\langle V_{1},E_{1}\rangle$和$G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，如果可用同胚操作将其中一个转化为另外一个，则称$G_{1}$与$G_{2}$具有同胚关系，简称为$G_{1}$与$G_{2}$同胚。  
根据上述同胚的概念，可以得到如下关于平面图判定的库拉托夫斯基定理：  
【定理10.16】（库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是$G$的任何子图都不同胚于$K_{5}$或$K_{3,3}$。  
【定理10.17】(库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是𝐺的任何子图都不能通过边的收缩得到$K_{5}$或$K_{3,3}$。  
![图10-51 彼得森图收缩为$ K_{5}$](images/b6cd48c8bf37519af48b0cc187afdf1adc13d2c5e160a08fe418ce5c94762fd6.jpg)  
库拉托夫斯基定理是一个非常著名定理，通常将$K_{5}$和$K_{3,3}$称为库拉托夫斯基图。可以使用该定理判定一个图是否为平面图。例如，对于图$10{-}51\mathrm{a}$）所示的彼得森图，收缩其边$(v_{i},u_{i})(i=1,2,3,4,5)$，则可得到图$K_{5}$，见图10-51b)。故彼得森图不是平面图。  
值得注意的是，虽然库拉托夫斯基定理给出了平面图判定的充分必要条件，但是目前还没有基于该定理得到一个有效的判定算法。因此，对于一个比较复杂的图模型，要判定其是否为平面图，有时并不是一件容易的事情。"
定理10.14,定理,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.3.1  平面图的概念与性质']","{'实体类型': '定理', '内容': '对于简单连通平面图，若边数$m>1$，则$m\\leq3n-6$'}",,3,"所谓平面图，直观地说就是可以将该图嵌入到某个平面上。如图10-46（a）所示，图模型的边有时不仅在结点处相交，而且还在某些非结点处有交叉，这些非结点处交叉点的边重叠特征显然会导致图模型不能嵌入在同一个平面上。因此，为了将图模型嵌入平面，首先必须适当调整该图中边的走向，以保证任意两条边不会在非结点处有交叉，如图10-46（b）所示。由此得到可平面图和平面图的相关概念。  
【定义10.6】设$G=\langle V,E\rangle$是任意给定的一个图模型，如果该图中有两条边在非结点处有交叉，则称这两条边为该图的交叉边，交叉的具体位置称为交叉点。如果可将图𝐺画在同一个平面上，并且所有边除在结点处之外均不交叉，则称图𝐺可嵌入平面，或称𝐺为可平面图，否则称该图为不可平面图或非平面图。对于可平面图𝐺，将其边不交叉的画法称为𝐺的平面嵌入表示。以平面嵌入方式表示的图可平面图𝐺称为平面图。对于一个平面图𝐺，若对其再加一条边就变成不可平面图，则称𝐺为最大平面图。  
![](images/ad5984e0ab09600028eb4068193d74e75743de0f027a20b4d084511a312873d4.jpg)  
![（a）完全二分图$K_{3,3}$  （b）无法消除交叉  ](images/aa69f9dcec49f0e95a534b493200688a98dae4f4be8a347fbd35c04b8c21413b.jpg)  
例如，对于图10-46（a）所示的图，该图有三对交叉边，即$(v_{1},v_{4})$和$(v_{2},v_{3}),~(v_{1},v_{4})$和$(v_{2},v_{5})$、$(v_{1},v_{5})$和$(v_{2},v_{3})$。由于可将该图表示成图10-46（b）的形式，故该图是一个可平面图。图10-46（b）所示的图就是一个平面图。显然，如果在该平面图上增加一条边，则该图就变成一个不可平面图，故该是一个最大平面图。再如，对于图10-47（a）所示的图模型，无论怎么调整边的走向都不能将其以平面嵌入方式表示，如图10-47（b）所示。故图10-47（a）所示的图模型为不可平面图或非平面图。  
在没有特别要求的情况下，通常将可平面图与平面图不加区分地统称为平面图。与一般图模型显著不同的是，平面图模型除了具有结点和边这两个基本构件之外，还有一般图模型所没有的面的概念，并且由进一步面衍生出边界的概念。因此，平面图是一类非常重要的特殊图模型，无论在理论上还是在应用方面都具有非常重要的价值，在印刷电路板的设计、城市管网设计与规划等多个领域得到实际应用。  
图论之父欧拉对平面图有着比较深刻的研究，发现并论证了平面图的结点、边和面之间的数量关系，提出了著名的欧拉公式。下面给出平面图中面的相关概念：  
【定义10.7】设$G=\langle V,E\rangle$是任意给定的一个平面图，由𝐺中边所包围且内部不包含结点与边的区域，称为$G$的一个面。区域面积有限的面称为有限面，区域面积无限的面称为无限面。对于$G$的任意一个面$R$，包围面$R$的所有边构成的回路称为面𝑅的边界，面𝑅边界中边的个数称为面$R$的次数或度，记为${\bf d e g}(R)$。  
通俗地说，如果把一个平面图画在平面上，然后用小刀沿着图的边将平面切开，那么整个平面就被切成若干块，其中每一块就是图的一个面。或者说，平面图的一个面就是平面中一个以边为界线不能再分割的区域块。例如，对于图10-46（b）所示的平面图，一共有六个面，其中有一个面是无限面，其余五个是有限面。需要注意的是，对于任何一个平面图，该图有且仅有一个无限面。下面的定理10.11 给出了平面图中面数与边数的数量关系：  
【定理10.11】平面图中所有面的次数之和等于边数的两倍。  
下面定理10.12 是著名的欧拉公式，给出了平面图中结点、边和面之间的数量关系：  
【定理10.12】设$G=\langle V,E\rangle$是任意给定的一个连通平面图，若它有$n$个结点、$m$条边、$r$ 个面，则有  
$$
n-m+r=2\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
【定理10.13】如果平面连通图$G$每个面的次数均为$l(l\geq3)$，则有：  
$$
m=l(n-2)/(l-2)
$$  
其中$m$为$G$的边数，$n$为$G$的结点数。  
【定理10.14】设$G$是一个$(n,m)$简单连通平面图，若$m>1$，则有：  
$$
m\leq3n-6\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
由定理10.4 的逆命题不成立，也就是说满足不等式$m\leq3n-6$的简单连通图不一定是平面图。但是对于一个简单连通图，若不满足$m\leq3n-6$，则一定是非平面图。因此，可用定理10.4 的结论证明某个简单连通图不是非平面图。  
【定理10.15】设$G$为一平面连通简单图，其结点数$n\geq4$，边数为$m$，且$G$不以$K_{3}$为其子图，则有$m\leq2n-4$。  
【定义10.8】对于是任意给定的一个图模型$G=\langle V,E\rangle$  
设$e=(u,v)$是$G$的任意一条边，如果在图$G$中删除该边并新增一个结点$w$及两条边$e_{1}=$$(u,w)$、$e_{2}=(w,v)$ ，则称该操作为对图$G$的边切割操作；  
设𝑤是$G$中任意一个度数为2 的结点，且是边${e_{1}=(u,w)}$和$e_{2}=(w,v)$的公共结点，如果在图$G$中删除结点$w$及边$e_{1},\,e_{2}$，并增加边$e=(u,v)$，则称该操作为对图$G$的结点贯通操作；  
对图$G$的边切割操作和结点贯通操作统称为对图$G$的同胚操作。  
显然，边切割操作和结点贯通操作是一对互逆操作。例如，对于图10-48 所示的两个图模型，可通过对边的切割操作将$G_{1}$变成$G_{2}$，也可通过对结点做贯通操作将$G_{2}$变成$G_{1}$。  
![图10-48  图的同胚操作与同胚关系  ](images/17b45e1706460a818a5492fb4df19f0ddd6b072e9cf57afef7db0852f0c58237.jpg)  
下面在同胚操作的基础上，引入如下两个图之间的同胚关系：  
【定义10.9】设$G_{1}=\langle V_{1},E_{1}\rangle$和$G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，如果可用同胚操作将其中一个转化为另外一个，则称$G_{1}$与$G_{2}$具有同胚关系，简称为$G_{1}$与$G_{2}$同胚。  
根据上述同胚的概念，可以得到如下关于平面图判定的库拉托夫斯基定理：  
【定理10.16】（库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是$G$的任何子图都不同胚于$K_{5}$或$K_{3,3}$。  
【定理10.17】(库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是𝐺的任何子图都不能通过边的收缩得到$K_{5}$或$K_{3,3}$。  
![图10-51 彼得森图收缩为$ K_{5}$](images/b6cd48c8bf37519af48b0cc187afdf1adc13d2c5e160a08fe418ce5c94762fd6.jpg)  
库拉托夫斯基定理是一个非常著名定理，通常将$K_{5}$和$K_{3,3}$称为库拉托夫斯基图。可以使用该定理判定一个图是否为平面图。例如，对于图$10{-}51\mathrm{a}$）所示的彼得森图，收缩其边$(v_{i},u_{i})(i=1,2,3,4,5)$，则可得到图$K_{5}$，见图10-51b)。故彼得森图不是平面图。  
值得注意的是，虽然库拉托夫斯基定理给出了平面图判定的充分必要条件，但是目前还没有基于该定理得到一个有效的判定算法。因此，对于一个比较复杂的图模型，要判定其是否为平面图，有时并不是一件容易的事情。"
定理10.15,定理,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.3.1  平面图的概念与性质']","{'实体类型': '定理', '内容': '对于平面连通简单图，若结点数$n\\geq4$且不以$K_3$为其子图，则边数$m\\leq2n-4'}",,3,"所谓平面图，直观地说就是可以将该图嵌入到某个平面上。如图10-46（a）所示，图模型的边有时不仅在结点处相交，而且还在某些非结点处有交叉，这些非结点处交叉点的边重叠特征显然会导致图模型不能嵌入在同一个平面上。因此，为了将图模型嵌入平面，首先必须适当调整该图中边的走向，以保证任意两条边不会在非结点处有交叉，如图10-46（b）所示。由此得到可平面图和平面图的相关概念。  
【定义10.6】设$G=\langle V,E\rangle$是任意给定的一个图模型，如果该图中有两条边在非结点处有交叉，则称这两条边为该图的交叉边，交叉的具体位置称为交叉点。如果可将图𝐺画在同一个平面上，并且所有边除在结点处之外均不交叉，则称图𝐺可嵌入平面，或称𝐺为可平面图，否则称该图为不可平面图或非平面图。对于可平面图𝐺，将其边不交叉的画法称为𝐺的平面嵌入表示。以平面嵌入方式表示的图可平面图𝐺称为平面图。对于一个平面图𝐺，若对其再加一条边就变成不可平面图，则称𝐺为最大平面图。  
![](images/ad5984e0ab09600028eb4068193d74e75743de0f027a20b4d084511a312873d4.jpg)  
![（a）完全二分图$K_{3,3}$  （b）无法消除交叉  ](images/aa69f9dcec49f0e95a534b493200688a98dae4f4be8a347fbd35c04b8c21413b.jpg)  
例如，对于图10-46（a）所示的图，该图有三对交叉边，即$(v_{1},v_{4})$和$(v_{2},v_{3}),~(v_{1},v_{4})$和$(v_{2},v_{5})$、$(v_{1},v_{5})$和$(v_{2},v_{3})$。由于可将该图表示成图10-46（b）的形式，故该图是一个可平面图。图10-46（b）所示的图就是一个平面图。显然，如果在该平面图上增加一条边，则该图就变成一个不可平面图，故该是一个最大平面图。再如，对于图10-47（a）所示的图模型，无论怎么调整边的走向都不能将其以平面嵌入方式表示，如图10-47（b）所示。故图10-47（a）所示的图模型为不可平面图或非平面图。  
在没有特别要求的情况下，通常将可平面图与平面图不加区分地统称为平面图。与一般图模型显著不同的是，平面图模型除了具有结点和边这两个基本构件之外，还有一般图模型所没有的面的概念，并且由进一步面衍生出边界的概念。因此，平面图是一类非常重要的特殊图模型，无论在理论上还是在应用方面都具有非常重要的价值，在印刷电路板的设计、城市管网设计与规划等多个领域得到实际应用。  
图论之父欧拉对平面图有着比较深刻的研究，发现并论证了平面图的结点、边和面之间的数量关系，提出了著名的欧拉公式。下面给出平面图中面的相关概念：  
【定义10.7】设$G=\langle V,E\rangle$是任意给定的一个平面图，由𝐺中边所包围且内部不包含结点与边的区域，称为$G$的一个面。区域面积有限的面称为有限面，区域面积无限的面称为无限面。对于$G$的任意一个面$R$，包围面$R$的所有边构成的回路称为面𝑅的边界，面𝑅边界中边的个数称为面$R$的次数或度，记为${\bf d e g}(R)$。  
通俗地说，如果把一个平面图画在平面上，然后用小刀沿着图的边将平面切开，那么整个平面就被切成若干块，其中每一块就是图的一个面。或者说，平面图的一个面就是平面中一个以边为界线不能再分割的区域块。例如，对于图10-46（b）所示的平面图，一共有六个面，其中有一个面是无限面，其余五个是有限面。需要注意的是，对于任何一个平面图，该图有且仅有一个无限面。下面的定理10.11 给出了平面图中面数与边数的数量关系：  
【定理10.11】平面图中所有面的次数之和等于边数的两倍。  
下面定理10.12 是著名的欧拉公式，给出了平面图中结点、边和面之间的数量关系：  
【定理10.12】设$G=\langle V,E\rangle$是任意给定的一个连通平面图，若它有$n$个结点、$m$条边、$r$ 个面，则有  
$$
n-m+r=2\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
【定理10.13】如果平面连通图$G$每个面的次数均为$l(l\geq3)$，则有：  
$$
m=l(n-2)/(l-2)
$$  
其中$m$为$G$的边数，$n$为$G$的结点数。  
【定理10.14】设$G$是一个$(n,m)$简单连通平面图，若$m>1$，则有：  
$$
m\leq3n-6\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
由定理10.4 的逆命题不成立，也就是说满足不等式$m\leq3n-6$的简单连通图不一定是平面图。但是对于一个简单连通图，若不满足$m\leq3n-6$，则一定是非平面图。因此，可用定理10.4 的结论证明某个简单连通图不是非平面图。  
【定理10.15】设$G$为一平面连通简单图，其结点数$n\geq4$，边数为$m$，且$G$不以$K_{3}$为其子图，则有$m\leq2n-4$。  
【定义10.8】对于是任意给定的一个图模型$G=\langle V,E\rangle$  
设$e=(u,v)$是$G$的任意一条边，如果在图$G$中删除该边并新增一个结点$w$及两条边$e_{1}=$$(u,w)$、$e_{2}=(w,v)$ ，则称该操作为对图$G$的边切割操作；  
设𝑤是$G$中任意一个度数为2 的结点，且是边${e_{1}=(u,w)}$和$e_{2}=(w,v)$的公共结点，如果在图$G$中删除结点$w$及边$e_{1},\,e_{2}$，并增加边$e=(u,v)$，则称该操作为对图$G$的结点贯通操作；  
对图$G$的边切割操作和结点贯通操作统称为对图$G$的同胚操作。  
显然，边切割操作和结点贯通操作是一对互逆操作。例如，对于图10-48 所示的两个图模型，可通过对边的切割操作将$G_{1}$变成$G_{2}$，也可通过对结点做贯通操作将$G_{2}$变成$G_{1}$。  
![图10-48  图的同胚操作与同胚关系  ](images/17b45e1706460a818a5492fb4df19f0ddd6b072e9cf57afef7db0852f0c58237.jpg)  
下面在同胚操作的基础上，引入如下两个图之间的同胚关系：  
【定义10.9】设$G_{1}=\langle V_{1},E_{1}\rangle$和$G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，如果可用同胚操作将其中一个转化为另外一个，则称$G_{1}$与$G_{2}$具有同胚关系，简称为$G_{1}$与$G_{2}$同胚。  
根据上述同胚的概念，可以得到如下关于平面图判定的库拉托夫斯基定理：  
【定理10.16】（库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是$G$的任何子图都不同胚于$K_{5}$或$K_{3,3}$。  
【定理10.17】(库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是𝐺的任何子图都不能通过边的收缩得到$K_{5}$或$K_{3,3}$。  
![图10-51 彼得森图收缩为$ K_{5}$](images/b6cd48c8bf37519af48b0cc187afdf1adc13d2c5e160a08fe418ce5c94762fd6.jpg)  
库拉托夫斯基定理是一个非常著名定理，通常将$K_{5}$和$K_{3,3}$称为库拉托夫斯基图。可以使用该定理判定一个图是否为平面图。例如，对于图$10{-}51\mathrm{a}$）所示的彼得森图，收缩其边$(v_{i},u_{i})(i=1,2,3,4,5)$，则可得到图$K_{5}$，见图10-51b)。故彼得森图不是平面图。  
值得注意的是，虽然库拉托夫斯基定理给出了平面图判定的充分必要条件，但是目前还没有基于该定理得到一个有效的判定算法。因此，对于一个比较复杂的图模型，要判定其是否为平面图，有时并不是一件容易的事情。"
定理10.2,定理,"['第十章  特殊图模型与算法', '§ 10.1 欧拉图与哈密顿图', '10.1.1  欧拉图及其性质']","{'实体类型': '定理', '内容': '有向图是欧拉图当且仅当为连通图且所有结点的入度等于出度；是半欧拉图当且仅当连通且仅有一个结点的入度比出度大1，另一个结点的出度比入度大1，其余结点的入度等于出度'}",,3,"为更好地介绍欧拉图，有必要再回顾一下前述哥尼斯堡七桥问题：哥尼斯堡小镇有一条贯穿全市的小河，河上有两个小岛，由七座桥将这两个小岛及其与河两岸进行互联，如图$10-$1(a)所示。问题是怎样才能不重复、不遗漏地走完七座桥，并回到出发点。  
![图10-1 哥尼斯堡七桥问题 ](images/f92d2bafd1492d4ec26c4c92f27d5040f5974fc8bef369b51ff49b676bd82f86.jpg)  
瑞士著名的数学家欧拉把该问题抽象成如图10-1(b)所示的图模型，其中两岸陆地和小岛分别被抽象成了 A, B, C, D 四个结点， 每个桥分别被抽象成了连接相应结点的无向边。 于是， 哥尼斯堡七桥问题就等价于图10-1(b)中是否存在一条从图中任意结点出发，经过图中所有边一次且仅一次的回路。由此得到如下欧拉图的相关定义：  
【定义10.1】设 $G=\langle V,E\rangle$是任意给定的一个图模型，通过图𝐺中所有边一次且仅一次的通路称为欧拉通路，通过图$G$中所有边一次且仅一的回路称为欧拉回路。如果图𝐺中存在欧拉回路，则称之为欧拉图，如果$G$中存在欧拉通路但不存在欧拉回路，则称之为半欧拉图。 规定平凡图为欧拉图。  
以上定义既适合无向图也适合有向图。从定义可以看出，欧拉通路是经过图中所有边的通路中长度最短的通路；欧拉回路是经过图中所有边的回路中长度最短的回路。如果仅用边来描述，那么欧拉通路和欧拉回路其实都是图中所有边的一个全排列。  
【定理10.1】设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$是欧拉图当且仅当 $G=\langle V,E\rangle$为连通图且所有结点度数均为偶数。  
【  
【推论10.1】设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$是半欧拉图当  
且仅当 $G=\langle V,E\rangle$为连通图且恰有2 个奇度数结点。  
由推论10.1 可知，如果$G$是连通图且刚好有奇度结点，那么在$G$中存在一条欧拉道路，且一定以其中一个奇度结点为始点，以另一个奇度结点为终点。  
下面进一步给出有向欧拉图和半欧拉图的判定定理：  
【定理10.2】设 $G=\langle V,E\rangle$是任意给定的一个有向图模型，则有：$G=\langle V,E\rangle$是欧拉图当且仅当 $G=\langle V,E\rangle$为连通图且所有结点的入度等等于出度；$G=\langle V,E\rangle$是半欧拉图，当且仅当$G=\langle V,E\rangle$连通且仅有一个结点的入度比出度大1，另外一个结点的出度比入度大1，其余结点的入度等于出度。  
对于一个欧拉图或半欧拉图，可以使用弗洛莱算法自动找到其欧拉回路或欧拉通路。该算法的基本思路是首先从图中的任一点出发，随机去掉与此点相连的边，然后在保证以下两个条件的基础上，依次去掉与之相连的边：  
1）如果去掉某边后使得该边的某端点为孤立结点，则将该端点与该边一并去掉。  
2）在去掉某边后，不能造成图模型的不连通。  
当算法停止时，获得的路径$L=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\ldots e_{n}v_{n}(v_{0}=v_{n})$就是图$G=\langle V,E\rangle$的一条欧拉回路。弗洛莱算法的具体步骤如下：  
1) 首先，在结点集𝑉中任选一个结点$v_{0}$为初始结点，并设初始通路为$L_{0}=v_{0}$。 2) 设已选好的简单通路为$\boldsymbol{\cdot}L_{i}=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\ldots e_{i}v_{i}$，按照下列条件从边集合：  
$$
E-\{e_{1},e_{2},e_{3},\ldots,e_{i}\}
$$  
中选取边]${e}_{i+1}$，其中$G_{1}$是从$G$删除边集合$\{e_{1},e_{2},e_{3},\ldots,e_{i}\}.$后得到的图：  
$\bullet$ 结点$v_{i}$是边$\boldsymbol{\cdot}\boldsymbol{e}_{i+1}$的端点。  
$\bullet$ 除非无其他边可以选取，否则删除边$\boldsymbol{\cdot}\boldsymbol{e}_{i+1}$后不改变图$G_{1}$的连通性。  
3）将$e_{i+1}v_{i+1}$加入到$L_{i}$中，形成新路径$\mathopen:L_{i+1}=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\dots e_{i}v_{i}e_{i+1}v_{i+1}$，令$i=i+1$  
4）返回步骤2）重复上述过程，直到 $i=|E|$ 。  
当图模型是一个半欧拉图时候，使用上述弗洛莱算法显然也可得到其欧拉通路，请读者自己思考算法的具体步骤和要点，不再赘述。  
![图10-10 房间布局的设计图     图10-11 图模型与欧拉通路       图10-12 行走路径 ](images/1200dfbb0792a6069379408b8f0f3304dd4b6248c5b1e2f4c4917b8d0bf94d23.jpg)"
定理10.3,定理,"['第十章  特殊图模型与算法', '§ 10.1 欧拉图与哈密顿图', '10.1.2  哈密顿图及其性质']","{'实体类型': '定理', '内容': '设无向图G是哈密顿图，则对于V的任意非空子集V1，均有p(G-V1)≤|V1|', '应用': '哈密顿图的必要条件'}",,3,"与哥尼斯堡七桥问题类似，哈密顿图模型也是来源于一个有趣的实例。1856 年，著名的爱尔兰数学家哈密顿在给朋友的信中谈到一个关于如图10-13 所示十二面体的数学问题：把每个结点看成是一个城市，连接两个结点的边看成交通线，能否找到一条旅行线路，沿着交通线经过十二面体的全部20 个城市一次且仅一次，然后再回到原来的出发点？对于这个问题，哈密顿将如图10-13（a）所示十二面体展开成如图10-13（b）所示的图模型，并给出了如图10-12（c）所示的回路，哈密顿图和哈密顿回路由此得名。  
![图10-13 十二面体的数学问题  ](images/f9d9b1ce93d10109a19c31e0468e3a1ce9ead26e329e520a14ed719c39c74609.jpg)  
【定义10.2】经过图中每个结点一次且仅一次的通路称为哈密顿通路。经过图中每个结点一次且仅一次的回路称为哈密顿回路。存在哈密顿回路的图称为哈密顿图；存在哈密顿通路的图称为半哈密顿图。规定平凡图为哈密顿图。  
显然，哈密顿通路是经过图中所有结点的最短通路，即经过图中所有结点的基本通路。哈密顿回路是经过图中所有结点的最短回路，即经过图中所有结点的基本回路。事实上，哈密顿通路就是图中所有结点的一个全排列。  
![图 10-14  哈密顿图与非哈密顿图 ](images/428b9e316b5acee7d3001e928f0a06090173f2550480e12bbb7942d43098f612.jpg)  
例如，在图10-14 中，图$G_{1}$存在哈密顿通路，但是不存在哈密顿回路，故图$G_{1}$是半哈密顿图；图$G_{2}$存在哈密顿回路，故图$G_{2}$是哈密顿图；图$G_{3}$既不存在哈密顿通路，更不存在哈密顿回路，故图$G_{3}$既不是哈密顿图，更不是半哈密顿图。  
相比欧拉图，哈密顿图的研究要困难得多。因为对图中每个结点的遍历需要让每个结点都具有一定数量的边供遍历路径的选择，也是就说对每个结点的度有一定的数量要求，但是这种度的数量又与图模型的具体结构有非常密切且隐含关系。总的来说，就是要求图中结点的度数不能太少且分布比较均衡，但是又很难量化这种条件。因此，目前还没有找到能够直接判定一个图是哈密顿图的充分必要条件。首先给出哈密顿图的一个必要条件：  
【定理10.3】设无向图$G=\langle V,E\rangle$是哈密顿图，则对于𝑉的任意非空子集$.V_{1}$，均有：
$$
p(G-V_{1})\leq|V_{1}|
$$  
其中$p(G-V_{1})$是从图$G$中删除$\cdot V_{1}$后所得图的连通分支数。  
【推论10.2】设无向图$G=\langle V,E\rangle$是半哈密顿图，则$V_{1}$是𝑉的任意非空子集，均有：  
$$
p(G-V_{1})\leq|V_{1}|+1
$$  
定理10.3 和推论10.2 表明，在图中所有结点总度数确定的情况下，要使一个图模型为哈密顿图，就必须使得度数的分配比较均衡。因为如果图的度数集中分布到某一个或某几个结点，则删除这些结点后，会使得图中的边数大量减少，导致图的连通分支数目大量增加，即有 $p(G-V_{1})>|V_{1}|$ 或 $p(G-V_{1})>|V_{1}|+1$ ，此时就违背了上述定理或推论的条件。  
值得注意的是，定理10.3 和推论10.2 是必要而非充分条件。例如，对于图10-16 所示的彼得森图，该图显然满足定理10.3 的条件，但它不是哈密顿图。因此，定理10.3 和推论10.2 主要用于对哈密顿图的证伪。下面给出判定哈密顿图或者半哈密顿图的充分条件：  
【定理10.4】设图$G=\langle V,E\rangle$是任意给定的$n$阶无向简单图，如果对任意两个不相邻的结点$u,v\in V$，均有：  
$$
\deg(u)+\deg(v)\geq n-1
$$  
则图$G$中存在哈密顿通路。  
【定理10.5】（奥尔定理）设图$G=\langle V,E\rangle$是$n$阶无向简单图，如果对任意两个不相邻的结点$u,v\in V$，均有：  
$$
\deg(u)+\deg(v)\geq n
$$  
则图$G$中存在哈密顿回路。  
【定理10.6】（狄拉克定理）设图$G=\langle V,E\rangle$是$n$阶无向简单图，如果对于图中结点𝑣∈𝑉，均有$\deg(v)\geq n/2$ ，则图$G$中存在哈密顿回路。  
定理10.4、定理10.5 和定理10.6 给出了判定哈密顿图的充分条件，其中狄拉克定理可以看成是奥尔定理的一个推论。上述3 个定理表明，如果要使得一个图是哈密顿图，就必须保证图中有足够多的边并分布基本均衡，或者说图中每个结点都要关联足够多的边。不难看出，这些条件是比较强的或者说是比较苛刻的。事实上，这些条件并非必要条件。例如，一条具10 个结点的链显然是半哈密顿图，但该图并不满足定理10.4 的条件，将该链的首尾一条边相连构成的圈图显然是哈密顿图，但并不满足定理10.5 和定理10.6 的条件。"
定理10.4,定理,"['第十章  特殊图模型与算法', '§ 10.1 欧拉图与哈密顿图', '10.1.2  哈密顿图及其性质']","{'实体类型': '定理', '内容': '设图G是n阶无向简单图，如果对任意两个不相邻的结点u,v，均有deg(u)+deg(v)≥n-1，则图G中存在哈密顿通路', '应用': '哈密顿通路的充分条件'}",,3,"与哥尼斯堡七桥问题类似，哈密顿图模型也是来源于一个有趣的实例。1856 年，著名的爱尔兰数学家哈密顿在给朋友的信中谈到一个关于如图10-13 所示十二面体的数学问题：把每个结点看成是一个城市，连接两个结点的边看成交通线，能否找到一条旅行线路，沿着交通线经过十二面体的全部20 个城市一次且仅一次，然后再回到原来的出发点？对于这个问题，哈密顿将如图10-13（a）所示十二面体展开成如图10-13（b）所示的图模型，并给出了如图10-12（c）所示的回路，哈密顿图和哈密顿回路由此得名。  
![图10-13 十二面体的数学问题  ](images/f9d9b1ce93d10109a19c31e0468e3a1ce9ead26e329e520a14ed719c39c74609.jpg)  
【定义10.2】经过图中每个结点一次且仅一次的通路称为哈密顿通路。经过图中每个结点一次且仅一次的回路称为哈密顿回路。存在哈密顿回路的图称为哈密顿图；存在哈密顿通路的图称为半哈密顿图。规定平凡图为哈密顿图。  
显然，哈密顿通路是经过图中所有结点的最短通路，即经过图中所有结点的基本通路。哈密顿回路是经过图中所有结点的最短回路，即经过图中所有结点的基本回路。事实上，哈密顿通路就是图中所有结点的一个全排列。  
![图 10-14  哈密顿图与非哈密顿图 ](images/428b9e316b5acee7d3001e928f0a06090173f2550480e12bbb7942d43098f612.jpg)  
例如，在图10-14 中，图$G_{1}$存在哈密顿通路，但是不存在哈密顿回路，故图$G_{1}$是半哈密顿图；图$G_{2}$存在哈密顿回路，故图$G_{2}$是哈密顿图；图$G_{3}$既不存在哈密顿通路，更不存在哈密顿回路，故图$G_{3}$既不是哈密顿图，更不是半哈密顿图。  
相比欧拉图，哈密顿图的研究要困难得多。因为对图中每个结点的遍历需要让每个结点都具有一定数量的边供遍历路径的选择，也是就说对每个结点的度有一定的数量要求，但是这种度的数量又与图模型的具体结构有非常密切且隐含关系。总的来说，就是要求图中结点的度数不能太少且分布比较均衡，但是又很难量化这种条件。因此，目前还没有找到能够直接判定一个图是哈密顿图的充分必要条件。首先给出哈密顿图的一个必要条件：  
【定理10.3】设无向图$G=\langle V,E\rangle$是哈密顿图，则对于𝑉的任意非空子集$.V_{1}$，均有：
$$
p(G-V_{1})\leq|V_{1}|
$$  
其中$p(G-V_{1})$是从图$G$中删除$\cdot V_{1}$后所得图的连通分支数。  
【推论10.2】设无向图$G=\langle V,E\rangle$是半哈密顿图，则$V_{1}$是𝑉的任意非空子集，均有：  
$$
p(G-V_{1})\leq|V_{1}|+1
$$  
定理10.3 和推论10.2 表明，在图中所有结点总度数确定的情况下，要使一个图模型为哈密顿图，就必须使得度数的分配比较均衡。因为如果图的度数集中分布到某一个或某几个结点，则删除这些结点后，会使得图中的边数大量减少，导致图的连通分支数目大量增加，即有 $p(G-V_{1})>|V_{1}|$ 或 $p(G-V_{1})>|V_{1}|+1$ ，此时就违背了上述定理或推论的条件。  
值得注意的是，定理10.3 和推论10.2 是必要而非充分条件。例如，对于图10-16 所示的彼得森图，该图显然满足定理10.3 的条件，但它不是哈密顿图。因此，定理10.3 和推论10.2 主要用于对哈密顿图的证伪。下面给出判定哈密顿图或者半哈密顿图的充分条件：  
【定理10.4】设图$G=\langle V,E\rangle$是任意给定的$n$阶无向简单图，如果对任意两个不相邻的结点$u,v\in V$，均有：  
$$
\deg(u)+\deg(v)\geq n-1
$$  
则图$G$中存在哈密顿通路。  
【定理10.5】（奥尔定理）设图$G=\langle V,E\rangle$是$n$阶无向简单图，如果对任意两个不相邻的结点$u,v\in V$，均有：  
$$
\deg(u)+\deg(v)\geq n
$$  
则图$G$中存在哈密顿回路。  
【定理10.6】（狄拉克定理）设图$G=\langle V,E\rangle$是$n$阶无向简单图，如果对于图中结点𝑣∈𝑉，均有$\deg(v)\geq n/2$ ，则图$G$中存在哈密顿回路。  
定理10.4、定理10.5 和定理10.6 给出了判定哈密顿图的充分条件，其中狄拉克定理可以看成是奥尔定理的一个推论。上述3 个定理表明，如果要使得一个图是哈密顿图，就必须保证图中有足够多的边并分布基本均衡，或者说图中每个结点都要关联足够多的边。不难看出，这些条件是比较强的或者说是比较苛刻的。事实上，这些条件并非必要条件。例如，一条具10 个结点的链显然是半哈密顿图，但该图并不满足定理10.4 的条件，将该链的首尾一条边相连构成的圈图显然是哈密顿图，但并不满足定理10.5 和定理10.6 的条件。"
定理10.5,定理,"['第十章  特殊图模型与算法', '§ 10.1 欧拉图与哈密顿图', '10.1.2  哈密顿图及其性质']","{'实体类型': '定理', '内容': '设图G是n阶无向简单图，如果对任意两个不相邻的结点u,v，均有deg(u)+deg(v)≥n，则图G中存在哈密顿回路', '应用': '哈密顿回路的充分条件'}",,3,"与哥尼斯堡七桥问题类似，哈密顿图模型也是来源于一个有趣的实例。1856 年，著名的爱尔兰数学家哈密顿在给朋友的信中谈到一个关于如图10-13 所示十二面体的数学问题：把每个结点看成是一个城市，连接两个结点的边看成交通线，能否找到一条旅行线路，沿着交通线经过十二面体的全部20 个城市一次且仅一次，然后再回到原来的出发点？对于这个问题，哈密顿将如图10-13（a）所示十二面体展开成如图10-13（b）所示的图模型，并给出了如图10-12（c）所示的回路，哈密顿图和哈密顿回路由此得名。  
![图10-13 十二面体的数学问题  ](images/f9d9b1ce93d10109a19c31e0468e3a1ce9ead26e329e520a14ed719c39c74609.jpg)  
【定义10.2】经过图中每个结点一次且仅一次的通路称为哈密顿通路。经过图中每个结点一次且仅一次的回路称为哈密顿回路。存在哈密顿回路的图称为哈密顿图；存在哈密顿通路的图称为半哈密顿图。规定平凡图为哈密顿图。  
显然，哈密顿通路是经过图中所有结点的最短通路，即经过图中所有结点的基本通路。哈密顿回路是经过图中所有结点的最短回路，即经过图中所有结点的基本回路。事实上，哈密顿通路就是图中所有结点的一个全排列。  
![图 10-14  哈密顿图与非哈密顿图 ](images/428b9e316b5acee7d3001e928f0a06090173f2550480e12bbb7942d43098f612.jpg)  
例如，在图10-14 中，图$G_{1}$存在哈密顿通路，但是不存在哈密顿回路，故图$G_{1}$是半哈密顿图；图$G_{2}$存在哈密顿回路，故图$G_{2}$是哈密顿图；图$G_{3}$既不存在哈密顿通路，更不存在哈密顿回路，故图$G_{3}$既不是哈密顿图，更不是半哈密顿图。  
相比欧拉图，哈密顿图的研究要困难得多。因为对图中每个结点的遍历需要让每个结点都具有一定数量的边供遍历路径的选择，也是就说对每个结点的度有一定的数量要求，但是这种度的数量又与图模型的具体结构有非常密切且隐含关系。总的来说，就是要求图中结点的度数不能太少且分布比较均衡，但是又很难量化这种条件。因此，目前还没有找到能够直接判定一个图是哈密顿图的充分必要条件。首先给出哈密顿图的一个必要条件：  
【定理10.3】设无向图$G=\langle V,E\rangle$是哈密顿图，则对于𝑉的任意非空子集$.V_{1}$，均有：
$$
p(G-V_{1})\leq|V_{1}|
$$  
其中$p(G-V_{1})$是从图$G$中删除$\cdot V_{1}$后所得图的连通分支数。  
【推论10.2】设无向图$G=\langle V,E\rangle$是半哈密顿图，则$V_{1}$是𝑉的任意非空子集，均有：  
$$
p(G-V_{1})\leq|V_{1}|+1
$$  
定理10.3 和推论10.2 表明，在图中所有结点总度数确定的情况下，要使一个图模型为哈密顿图，就必须使得度数的分配比较均衡。因为如果图的度数集中分布到某一个或某几个结点，则删除这些结点后，会使得图中的边数大量减少，导致图的连通分支数目大量增加，即有 $p(G-V_{1})>|V_{1}|$ 或 $p(G-V_{1})>|V_{1}|+1$ ，此时就违背了上述定理或推论的条件。  
值得注意的是，定理10.3 和推论10.2 是必要而非充分条件。例如，对于图10-16 所示的彼得森图，该图显然满足定理10.3 的条件，但它不是哈密顿图。因此，定理10.3 和推论10.2 主要用于对哈密顿图的证伪。下面给出判定哈密顿图或者半哈密顿图的充分条件：  
【定理10.4】设图$G=\langle V,E\rangle$是任意给定的$n$阶无向简单图，如果对任意两个不相邻的结点$u,v\in V$，均有：  
$$
\deg(u)+\deg(v)\geq n-1
$$  
则图$G$中存在哈密顿通路。  
【定理10.5】（奥尔定理）设图$G=\langle V,E\rangle$是$n$阶无向简单图，如果对任意两个不相邻的结点$u,v\in V$，均有：  
$$
\deg(u)+\deg(v)\geq n
$$  
则图$G$中存在哈密顿回路。  
【定理10.6】（狄拉克定理）设图$G=\langle V,E\rangle$是$n$阶无向简单图，如果对于图中结点𝑣∈𝑉，均有$\deg(v)\geq n/2$ ，则图$G$中存在哈密顿回路。  
定理10.4、定理10.5 和定理10.6 给出了判定哈密顿图的充分条件，其中狄拉克定理可以看成是奥尔定理的一个推论。上述3 个定理表明，如果要使得一个图是哈密顿图，就必须保证图中有足够多的边并分布基本均衡，或者说图中每个结点都要关联足够多的边。不难看出，这些条件是比较强的或者说是比较苛刻的。事实上，这些条件并非必要条件。例如，一条具10 个结点的链显然是半哈密顿图，但该图并不满足定理10.4 的条件，将该链的首尾一条边相连构成的圈图显然是哈密顿图，但并不满足定理10.5 和定理10.6 的条件。"
定理10.6,定理,"['第十章  特殊图模型与算法', '§ 10.1 欧拉图与哈密顿图', '10.1.2  哈密顿图及其性质']","{'实体类型': '定理', '内容': '设图G是n阶无向简单图，如果对于图中结点v，均有deg(v)≥n/2，则图G中存在哈密顿回路', '应用': '哈密顿回路的充分条件'}",,3,"与哥尼斯堡七桥问题类似，哈密顿图模型也是来源于一个有趣的实例。1856 年，著名的爱尔兰数学家哈密顿在给朋友的信中谈到一个关于如图10-13 所示十二面体的数学问题：把每个结点看成是一个城市，连接两个结点的边看成交通线，能否找到一条旅行线路，沿着交通线经过十二面体的全部20 个城市一次且仅一次，然后再回到原来的出发点？对于这个问题，哈密顿将如图10-13（a）所示十二面体展开成如图10-13（b）所示的图模型，并给出了如图10-12（c）所示的回路，哈密顿图和哈密顿回路由此得名。  
![图10-13 十二面体的数学问题  ](images/f9d9b1ce93d10109a19c31e0468e3a1ce9ead26e329e520a14ed719c39c74609.jpg)  
【定义10.2】经过图中每个结点一次且仅一次的通路称为哈密顿通路。经过图中每个结点一次且仅一次的回路称为哈密顿回路。存在哈密顿回路的图称为哈密顿图；存在哈密顿通路的图称为半哈密顿图。规定平凡图为哈密顿图。  
显然，哈密顿通路是经过图中所有结点的最短通路，即经过图中所有结点的基本通路。哈密顿回路是经过图中所有结点的最短回路，即经过图中所有结点的基本回路。事实上，哈密顿通路就是图中所有结点的一个全排列。  
![图 10-14  哈密顿图与非哈密顿图 ](images/428b9e316b5acee7d3001e928f0a06090173f2550480e12bbb7942d43098f612.jpg)  
例如，在图10-14 中，图$G_{1}$存在哈密顿通路，但是不存在哈密顿回路，故图$G_{1}$是半哈密顿图；图$G_{2}$存在哈密顿回路，故图$G_{2}$是哈密顿图；图$G_{3}$既不存在哈密顿通路，更不存在哈密顿回路，故图$G_{3}$既不是哈密顿图，更不是半哈密顿图。  
相比欧拉图，哈密顿图的研究要困难得多。因为对图中每个结点的遍历需要让每个结点都具有一定数量的边供遍历路径的选择，也是就说对每个结点的度有一定的数量要求，但是这种度的数量又与图模型的具体结构有非常密切且隐含关系。总的来说，就是要求图中结点的度数不能太少且分布比较均衡，但是又很难量化这种条件。因此，目前还没有找到能够直接判定一个图是哈密顿图的充分必要条件。首先给出哈密顿图的一个必要条件：  
【定理10.3】设无向图$G=\langle V,E\rangle$是哈密顿图，则对于𝑉的任意非空子集$.V_{1}$，均有：
$$
p(G-V_{1})\leq|V_{1}|
$$  
其中$p(G-V_{1})$是从图$G$中删除$\cdot V_{1}$后所得图的连通分支数。  
【推论10.2】设无向图$G=\langle V,E\rangle$是半哈密顿图，则$V_{1}$是𝑉的任意非空子集，均有：  
$$
p(G-V_{1})\leq|V_{1}|+1
$$  
定理10.3 和推论10.2 表明，在图中所有结点总度数确定的情况下，要使一个图模型为哈密顿图，就必须使得度数的分配比较均衡。因为如果图的度数集中分布到某一个或某几个结点，则删除这些结点后，会使得图中的边数大量减少，导致图的连通分支数目大量增加，即有 $p(G-V_{1})>|V_{1}|$ 或 $p(G-V_{1})>|V_{1}|+1$ ，此时就违背了上述定理或推论的条件。  
值得注意的是，定理10.3 和推论10.2 是必要而非充分条件。例如，对于图10-16 所示的彼得森图，该图显然满足定理10.3 的条件，但它不是哈密顿图。因此，定理10.3 和推论10.2 主要用于对哈密顿图的证伪。下面给出判定哈密顿图或者半哈密顿图的充分条件：  
【定理10.4】设图$G=\langle V,E\rangle$是任意给定的$n$阶无向简单图，如果对任意两个不相邻的结点$u,v\in V$，均有：  
$$
\deg(u)+\deg(v)\geq n-1
$$  
则图$G$中存在哈密顿通路。  
【定理10.5】（奥尔定理）设图$G=\langle V,E\rangle$是$n$阶无向简单图，如果对任意两个不相邻的结点$u,v\in V$，均有：  
$$
\deg(u)+\deg(v)\geq n
$$  
则图$G$中存在哈密顿回路。  
【定理10.6】（狄拉克定理）设图$G=\langle V,E\rangle$是$n$阶无向简单图，如果对于图中结点𝑣∈𝑉，均有$\deg(v)\geq n/2$ ，则图$G$中存在哈密顿回路。  
定理10.4、定理10.5 和定理10.6 给出了判定哈密顿图的充分条件，其中狄拉克定理可以看成是奥尔定理的一个推论。上述3 个定理表明，如果要使得一个图是哈密顿图，就必须保证图中有足够多的边并分布基本均衡，或者说图中每个结点都要关联足够多的边。不难看出，这些条件是比较强的或者说是比较苛刻的。事实上，这些条件并非必要条件。例如，一条具10 个结点的链显然是半哈密顿图，但该图并不满足定理10.4 的条件，将该链的首尾一条边相连构成的圈图显然是哈密顿图，但并不满足定理10.5 和定理10.6 的条件。"
定理11.1,定理,"['第十一章  抽象代数结构通论', '§ 11.2 代数结构的运算性质', '11.2.2 特殊元素']","{'实体类型': '定理', '内容': '设*$是集合A中的二元运算，⟨A,*⟩是一个代数系统。如果⟨A,*⟩存在幺元，则幺元唯一；如果⟨A,*⟩存在幺元，则该幺元一定是左、右幺元；如果⟨A,*⟩存在左、右幺元，则该左、右幺元相等，且是幺元。'}",,3,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)"
定理11.10,定理,"['第十一章  抽象代数结构通论', '§ 11.3 同构、同态与同余', '11.3.2  同构与同态与性质']","{'实体类型': '定理', '条件': '同态映射', '结论': '同态像是原代数结构的一个子代数'}",,3,"上一节我们通过类比图模型的同构关系引入代数结构之间的同构映射关系，并将代数结构的同构关系进一步推广到同态映射关系。我们知道，如果两个图模型之间具有同构关系，则说明这两个图模型的结构完全相同。 图模型作为一种拓扑数学结构，其结构一般由结点的度结构、结点与边的关联性、结点与结点之间的连接通路等性质决定。不难看出，对于同构的两个图模型，它们之间的这些结构性质均完全相同。代数结构则是一种运算结构，其结构特征主要由其运算性质决定。具体地说，就是代数结构的结构特征是由结合律、交换律、消去律、幂等律、吸收律、分配律这六个算律，以及单位元、零元和逆元等特殊元素的性质决定。下面具体考察同构的两个代数系统之间在运算性质方面有何关联。  
首先考察只有一个二元运算的代数结构：  
【定理11.5】假设$\langle A,\ *\rangle$和$\langle B,\ \circ\rangle$是任意两个同构的代数结构，$\psi\colon A\to B$是其同构映射，即对于$\forall x_{1},x_{2}\in\begin{array}{l}{A}\end{array}$，有$\psi(x_{1}*x_{2})=\psi(x_{1})\circ\psi(x_{2})$，那么：  
（1）如果运算$^*$满足结合律，那么运算$∘$也满足结合律；  
（2）如果运算$*$满足交换律，那么运算$\circ$也满足交换律:  
（3）如果运算$^*$存在单位元$e$，那么运算$∘$存在单位元$e。$，且满足：$\psi(e_{\ast})=e_{\circ}$；  
（4）如果运算$*$存在零元$\theta_{*}$，那么运算∘存在单位元$\theta_{\circ}$，且满足：$\psi({\boldsymbol{\theta}}_{*})=\theta_{\circ}$  
（5）如果对于运算$*$，集合𝐴中每个元素均可逆，即对于$\forall x\in A$，有${x}{}^{-1}\in A$，那么对于运算∘，集合$ B$中每个元素均可逆，即对于$\forall\mathbf{y}\in B$，有$y^{-1}\in B$，且$\mathbf{y}^{-1}=\mathbf{\begin{array}{l}{\psi(x^{-1})}\end{array}}$。  
现在考察含有两个二元运算的代数结构：  
【定理11.6】假设$\langle A,+,\ \times\rangle$和$\langle B,\,\oplus,\,\otimes\,\rangle$是任意两个同构的代数结构，$\psi$：$A\rightarrow B$是其同构映射，即$\psi$是从$A$到$B$的双射且对于$\forall x_{1},x_{2}\in\begin{array}{l}{A}\end{array}$，有：  
$$
\psi(x_{1}+x_{2})=\psi(x_{1})\oplus\psi(x_{2});\,\,\,\psi(x_{1}\times x_{2})=\psi(x_{1})\otimes\psi(x_{2})
$$  
那么：  
（1）如果运算$+$对运算$\times$满足分配律，那么运算⊕对运算$\otimes$也满足分配律；  
（2）如果运算$+$和运算$\times$满足吸收律，那么运算$\oplus$和运算$\otimes$也满足吸收律。  
从上述两个定理可以看出，对于同构的两个代数结构，其运算性质完全一样。事实上，下面定理11.7 表明具有两个代数结构之间的同构关系其实是一种等价关系：  
【定理11.7】代数结构之间的同构关系≅是一种等价关系，即有：  
（1）自反性：任何代数系统$\langle A,{*}\rangle,$有$\langle A,\ *\rangle\cong\langle A,\ *\rangle.$；  
（2）对称性：任何代数系统$\langle A,\ *\rangle,\,\langle B,\ \oplus\rangle$，若$\langle A,\ *\rangle\cong\langle B,\ \oplus\rangle$，则$\langle B,\ \oplus\rangle\cong\langle A,\ *\rangle$；  
（3）传递性：任何代数系统$\langle A,\ *\rangle$，$\langle B,\ \oplus\rangle$，$\langle C,\circledast\rangle$，若$\langle A,\ *\rangle\cong\langle B,\ \oplus\rangle$，$\langle B,\,\oplus\rangle\cong$$\langle C,\ \circledast\rangle$，则$\langle A,\ *\rangle\cong\langle C,\ \circledast\rangle$。  
既然代数结构之间的同构关系$\cong$是一种等价关系，那么就可以通过$\cong$对所有的代数系统组成的集合$H=\{G|G$是代数结构}进行划分，属于同一个划分块的代数结构彼此同构，由此产生集合$H$关于≅的一个商集合$H/{\cong}=\{[x]_{\cong}|x\in H\}$。由于同构关系是一种等价关系，只需在$[x]_{\cong}$中任取一个代数结构进行研究即可知道$[x]_{\cong}$中所有代数结构的性质。因此，可以将讨论$|H|$个代数结构的问题转化为讨论$|H/\cong|$个代数结构的问题，有效减少了问题的规模。  
下面考察同态代数结构的运算性质。不难发现，在前面关于同构代数结构运算性质的证明过程中，在很多场合仅用到同构映射中满射的条件，而没有涉及单射的条件。因此，同构代数结构的很多运算性质对于满同态的代数结构也成立，故有下列定理：  
【定理11.8】设$\psi$是从代数系统$\langle A,\Delta\rangle$到$\langle B,*\rangle$的满同态映射，则有：  
（1）若运算’$\Delta$‘是可交换的，则运算‘$*$’也是可交换的；  
（2）若运算‘$\Delta$’是可结合的，则运算‘$*$’也是可结合的；  
（3）若$e$是$\langle A,\Delta\rangle$的幺元，则$\psi(e)$是$\langle B,*\rangle$的幺元；  
（4）若$\theta$是$\langle A,\Delta\rangle_{1}$的零元，则$\psi(\theta)$是$\langle B,*\rangle$的零元；  
（5）若$\delta$是$\langle A,\Delta\rangle$的幂等元，则$\psi(\delta)$是$\langle B,*\rangle$的幂等元；  
（6）若$ x^{-1}$是$x$在$\langle A,\Delta\rangle$上的逆元，则$\psi(x^{-1})$是$\psi(x)$在$\langle B,*\rangle$中的逆元。  
上述性质可以看出，若$\psi$是一个满同态，则他把幺元映射成幺元，逆元映射成逆元，零元映射成零元，幂等元映射成幂等元。下面的定理11.9 表明，满同态保持二元运算的分配律和吸收律。  
【定理11.9】设$\langle A,+,\ \times\rangle$和$\langle B,\,\oplus,\,\otimes\,\rangle$是任意两个满同态代数结构，$\psi$：$A\rightarrow B$是从$\langle A,+,\ \times\rangle$到$\langle B,\,\oplus,\,\otimes\,\rangle$的满同态映射，即$\psi$是从$A$到$B$的满射且对于$\forall x_{1},x_{2}\in$$A$有：  
$$
\psi(x_{1}+x_{2})=\psi(x_{1})\oplus\psi(x_{2});\,\,\,\psi(x_{1}\times x_{2})=\psi(x_{1})\otimes\psi(x_{2})
$$  
那么：  
（1）如果运算$+$对运算$\times$满足分配律，那么运算⊕对运算$\otimes$也满足分配律；  
（2）如果运算$+$和运算$\times$满足吸收律，那么运算⊕和运算$\otimes$也满足吸收律。  
最后，我们考察同态像的性质，下面的定理11.3.10 表明同态像是一个子代数：  
【定理11.10】设$\langle A,\ *\rangle$和$\langle B,\,\circ\,\rangle$是任意两个同态的代数结构，函数$\mathcal{\psi}$是从$\langle A,\ *\rangle$到$\langle B,\,\circ\,\rangle$的同态映射，则同态像$\langle\psi(A,\,\circ\ \rangle$是$\langle B,\,\circ\,\rangle$的一个子代数结构。  
上述定理表明，同态像是$\langle\psi(A),\;\circ\rangle$是$\langle B,\,\circ\,\rangle$的一个子代数。因此，即使$\psi$不是一个满射函数，也可以通过该函数在$\langle A,\ *\rangle$与$\langle\psi(A),\;\circ\rangle$之间建立一个满同态关系。此时由定理11.3.8可知，$\langle A,\ *\rangle$与$\langle\psi(A),\ \circ\rangle$之间具体很多相同的运算性质。因此，同态像$\langle\psi(A),\ \circ\rangle$可以看成对代数结构$\langle A,\ *\rangle$的一种更加精简的浓缩。"
定理11.11,定理,"['第十一章  抽象代数结构通论', '§ 11.3 同构、同态与同余', '11.3.3  同余的概念与性质']","{'实体类型': '定理', '内容': '等价关系~关于二元运算∗是一个同余关系，当且仅当a~b和c~d时，有ac~bd'}",,3,"在整数理论中，我们学过整数之间的同余关系。整数的模$\boldsymbol{\cdot}\boldsymbol{k}$同余关系作为一种等价关系其实是整数相等关系的一种扩展。我们知道，整数之间的相等关系是一种最强的等价关系。 由运算的单值映射性质可知，对于任意两个相等的整数进行某种运算之后仍然保持相等。 现将整数相等关系这种对运算的保持性质推广到一般的等价关系？具体地说，就是对于一个任意给定的代数结构$\langle A,\ *\rangle$，$R$是载体集合𝐴上的一个等价关系，考察在$A$中具有关系𝑅的元素经过运算后是否仍然具有等价关系$R$。由此得到如下同余关系的相关定义：  
【定义11.18】设$\langle A,\ *,\!\triangle\rangle$是一个代数结构，$*$和$\triangle$分别是二元运算和一元运算，$\sim$是载体$𝐴$上的等价关系，对于$\forall a,b,c\in A$且$a{\sim}b$：若有$\triangle\;a\!\sim\triangle\;b$，则称$\sim$是关于运算$△$的同余关系；若有 $a*c{\sim}b*c$ 且 $c*a{\sim}c*b$ ，则称 $\sim$ 是关于运算 ${\ast}$ 的同余关系；若 $\sim$ 是关于 △ 和 $*$ 的同余 关系，则称$\sim$是代数结构$\langle A,\ *,\triangle\rangle$上的同余关系，此时称等价类$[x]_{\sim}$为同余类。  
我们知道，集合𝐴上的等价关系𝑅将𝐴划分为一个一个的等价类，如果𝐴中具有等价关系$R$的元素在运算$^*$下仍然保持等价关系$R$不变，那就说明，集合𝐴在等价关系$R$下的划分在运算$^*$的映射变换下保持不变。具体地说：就是运算$^*$将𝐴中任意彼此等价的两个元素从其所处的等价类映射到另外一个等价类中，如图11.4 所示，图中每个小方格分别代表一个等价类。 此时，可以将运算$^*$看成是对集合𝐴中元素在等价类之间进行的一次置换。  
![](images/fae0b5be5e5b684797945d41e251f779b67578792deb6bd81af14b0e79ffcf00.jpg)
图11.4  同余关系与等价类  
从上述定义可以看出，若等价关系$\sim$在𝐴上的所有运算下都是可保持的，则$\sim$为代数系统$𝐴$上的同余关系。  
【定理11.11】等价关系$\sim$关于二元运算∗是一个同余关系，当且仅当$a{\sim}b$和$c{\sim}d$时，有  
$ a c\sim b d$。  
现在讨论同态和同余之间的联系，首先给出由同态映射导出的一个等价关系：  
【定理11.12】假设$\langle A,+,\ \times\rangle$和$\langle B,\,\oplus,\,\otimes\,\rangle$是任意两个同态的代数结构，$\psi$：$A\rightarrow B$是其同态映射，则集合$\cdot A$中元素在映射$\cdot\psi$下具有同像的关系$\sim$，即有：  
$$
\sim\;=\{\langle x,y\rangle|x,y\in A\land\psi(x)=\psi(y)\}\tag{11-11}
$$  
是一个等价关系，并称之为由同态映射$\cdot\psi$导出的𝐴上自然等价关系。  
【定理11.13】假设$\langle A,+,\ \times\rangle$和$\langle B,\,\oplus,\,\otimes\,\rangle$是任意两个同态的代数结构，$\psi$：$A\rightarrow B$是其同态映射，则由同态映射$\cdot\psi$导出的自然等价关系：  
$$
\sim\;=\{\langle x,y\rangle|x,y\in A\land\psi(x)=\psi(y)\}
$$  
是一个同余关系。  
事实上，对于代数结构$\langle A,+,\ \times\rangle$上的任意一个同余关系$\sim$，可以构造出一个与之相应的商代数，并且$\langle A,+,\ \times\rangle$与该商代数之间是一种满同态关系，称之为自然同态关系。因此，由同余关系也可以构造出一个与之相应的同态关系，并且该同态映射下的同态像与该商代数之间具体同构关系。具体内容可查阅商代数的相关知识，这里不再赘述。"
定理11.12,定理,"['第十一章  抽象代数结构通论', '§ 11.3 同构、同态与同余', '11.3.3  同余的概念与性质']","{'实体类型': '定理', '内容': '假设⟨A,+,\\times⟩和⟨B,⊕,⊗⟩是任意两个同态的代数结构，ψ：A→B是其同态映射，则集合A中元素在映射ψ下具有同像的关系~，即有：~={⟨x,y⟩|x,y∈A∧ψ(x)=ψ(y)}是一个等价关系，并称之为由同态映射ψ导出的A上自然等价关系'}",,3,"在整数理论中，我们学过整数之间的同余关系。整数的模$\boldsymbol{\cdot}\boldsymbol{k}$同余关系作为一种等价关系其实是整数相等关系的一种扩展。我们知道，整数之间的相等关系是一种最强的等价关系。 由运算的单值映射性质可知，对于任意两个相等的整数进行某种运算之后仍然保持相等。 现将整数相等关系这种对运算的保持性质推广到一般的等价关系？具体地说，就是对于一个任意给定的代数结构$\langle A,\ *\rangle$，$R$是载体集合𝐴上的一个等价关系，考察在$A$中具有关系𝑅的元素经过运算后是否仍然具有等价关系$R$。由此得到如下同余关系的相关定义：  
【定义11.18】设$\langle A,\ *,\!\triangle\rangle$是一个代数结构，$*$和$\triangle$分别是二元运算和一元运算，$\sim$是载体$𝐴$上的等价关系，对于$\forall a,b,c\in A$且$a{\sim}b$：若有$\triangle\;a\!\sim\triangle\;b$，则称$\sim$是关于运算$△$的同余关系；若有 $a*c{\sim}b*c$ 且 $c*a{\sim}c*b$ ，则称 $\sim$ 是关于运算 ${\ast}$ 的同余关系；若 $\sim$ 是关于 △ 和 $*$ 的同余 关系，则称$\sim$是代数结构$\langle A,\ *,\triangle\rangle$上的同余关系，此时称等价类$[x]_{\sim}$为同余类。  
我们知道，集合𝐴上的等价关系𝑅将𝐴划分为一个一个的等价类，如果𝐴中具有等价关系$R$的元素在运算$^*$下仍然保持等价关系$R$不变，那就说明，集合𝐴在等价关系$R$下的划分在运算$^*$的映射变换下保持不变。具体地说：就是运算$^*$将𝐴中任意彼此等价的两个元素从其所处的等价类映射到另外一个等价类中，如图11.4 所示，图中每个小方格分别代表一个等价类。 此时，可以将运算$^*$看成是对集合𝐴中元素在等价类之间进行的一次置换。  
![](images/fae0b5be5e5b684797945d41e251f779b67578792deb6bd81af14b0e79ffcf00.jpg)
图11.4  同余关系与等价类  
从上述定义可以看出，若等价关系$\sim$在𝐴上的所有运算下都是可保持的，则$\sim$为代数系统$𝐴$上的同余关系。  
【定理11.11】等价关系$\sim$关于二元运算∗是一个同余关系，当且仅当$a{\sim}b$和$c{\sim}d$时，有  
$ a c\sim b d$。  
现在讨论同态和同余之间的联系，首先给出由同态映射导出的一个等价关系：  
【定理11.12】假设$\langle A,+,\ \times\rangle$和$\langle B,\,\oplus,\,\otimes\,\rangle$是任意两个同态的代数结构，$\psi$：$A\rightarrow B$是其同态映射，则集合$\cdot A$中元素在映射$\cdot\psi$下具有同像的关系$\sim$，即有：  
$$
\sim\;=\{\langle x,y\rangle|x,y\in A\land\psi(x)=\psi(y)\}\tag{11-11}
$$  
是一个等价关系，并称之为由同态映射$\cdot\psi$导出的𝐴上自然等价关系。  
【定理11.13】假设$\langle A,+,\ \times\rangle$和$\langle B,\,\oplus,\,\otimes\,\rangle$是任意两个同态的代数结构，$\psi$：$A\rightarrow B$是其同态映射，则由同态映射$\cdot\psi$导出的自然等价关系：  
$$
\sim\;=\{\langle x,y\rangle|x,y\in A\land\psi(x)=\psi(y)\}
$$  
是一个同余关系。  
事实上，对于代数结构$\langle A,+,\ \times\rangle$上的任意一个同余关系$\sim$，可以构造出一个与之相应的商代数，并且$\langle A,+,\ \times\rangle$与该商代数之间是一种满同态关系，称之为自然同态关系。因此，由同余关系也可以构造出一个与之相应的同态关系，并且该同态映射下的同态像与该商代数之间具体同构关系。具体内容可查阅商代数的相关知识，这里不再赘述。"
定理11.13,定理,"['第十一章  抽象代数结构通论', '§ 11.3 同构、同态与同余', '11.3.3  同余的概念与性质']","{'实体类型': '定理', '内容': '假设⟨A,+,\\times⟩和⟨B,⊕,⊗⟩是任意两个同态的代数结构，ψ：A→B是其同态映射，则由同态映射ψ导出的自然等价关系：~={⟨x,y⟩|x,y∈A∧ψ(x)=ψ(y)}是一个同余关系'}",,3,"在整数理论中，我们学过整数之间的同余关系。整数的模$\boldsymbol{\cdot}\boldsymbol{k}$同余关系作为一种等价关系其实是整数相等关系的一种扩展。我们知道，整数之间的相等关系是一种最强的等价关系。 由运算的单值映射性质可知，对于任意两个相等的整数进行某种运算之后仍然保持相等。 现将整数相等关系这种对运算的保持性质推广到一般的等价关系？具体地说，就是对于一个任意给定的代数结构$\langle A,\ *\rangle$，$R$是载体集合𝐴上的一个等价关系，考察在$A$中具有关系𝑅的元素经过运算后是否仍然具有等价关系$R$。由此得到如下同余关系的相关定义：  
【定义11.18】设$\langle A,\ *,\!\triangle\rangle$是一个代数结构，$*$和$\triangle$分别是二元运算和一元运算，$\sim$是载体$𝐴$上的等价关系，对于$\forall a,b,c\in A$且$a{\sim}b$：若有$\triangle\;a\!\sim\triangle\;b$，则称$\sim$是关于运算$△$的同余关系；若有 $a*c{\sim}b*c$ 且 $c*a{\sim}c*b$ ，则称 $\sim$ 是关于运算 ${\ast}$ 的同余关系；若 $\sim$ 是关于 △ 和 $*$ 的同余 关系，则称$\sim$是代数结构$\langle A,\ *,\triangle\rangle$上的同余关系，此时称等价类$[x]_{\sim}$为同余类。  
我们知道，集合𝐴上的等价关系𝑅将𝐴划分为一个一个的等价类，如果𝐴中具有等价关系$R$的元素在运算$^*$下仍然保持等价关系$R$不变，那就说明，集合𝐴在等价关系$R$下的划分在运算$^*$的映射变换下保持不变。具体地说：就是运算$^*$将𝐴中任意彼此等价的两个元素从其所处的等价类映射到另外一个等价类中，如图11.4 所示，图中每个小方格分别代表一个等价类。 此时，可以将运算$^*$看成是对集合𝐴中元素在等价类之间进行的一次置换。  
![](images/fae0b5be5e5b684797945d41e251f779b67578792deb6bd81af14b0e79ffcf00.jpg)
图11.4  同余关系与等价类  
从上述定义可以看出，若等价关系$\sim$在𝐴上的所有运算下都是可保持的，则$\sim$为代数系统$𝐴$上的同余关系。  
【定理11.11】等价关系$\sim$关于二元运算∗是一个同余关系，当且仅当$a{\sim}b$和$c{\sim}d$时，有  
$ a c\sim b d$。  
现在讨论同态和同余之间的联系，首先给出由同态映射导出的一个等价关系：  
【定理11.12】假设$\langle A,+,\ \times\rangle$和$\langle B,\,\oplus,\,\otimes\,\rangle$是任意两个同态的代数结构，$\psi$：$A\rightarrow B$是其同态映射，则集合$\cdot A$中元素在映射$\cdot\psi$下具有同像的关系$\sim$，即有：  
$$
\sim\;=\{\langle x,y\rangle|x,y\in A\land\psi(x)=\psi(y)\}\tag{11-11}
$$  
是一个等价关系，并称之为由同态映射$\cdot\psi$导出的𝐴上自然等价关系。  
【定理11.13】假设$\langle A,+,\ \times\rangle$和$\langle B,\,\oplus,\,\otimes\,\rangle$是任意两个同态的代数结构，$\psi$：$A\rightarrow B$是其同态映射，则由同态映射$\cdot\psi$导出的自然等价关系：  
$$
\sim\;=\{\langle x,y\rangle|x,y\in A\land\psi(x)=\psi(y)\}
$$  
是一个同余关系。  
事实上，对于代数结构$\langle A,+,\ \times\rangle$上的任意一个同余关系$\sim$，可以构造出一个与之相应的商代数，并且$\langle A,+,\ \times\rangle$与该商代数之间是一种满同态关系，称之为自然同态关系。因此，由同余关系也可以构造出一个与之相应的同态关系，并且该同态映射下的同态像与该商代数之间具体同构关系。具体内容可查阅商代数的相关知识，这里不再赘述。"
定理11.3,定理,"['第十一章  抽象代数结构通论', '§ 11.2 代数结构的运算性质', '11.2.2 特殊元素']","{'实体类型': '定理', '内容': '设⟨A,*⟩是一个代数系统，集合A上的二元运算*$满足结合律，且设e是⟨A,*⟩幺元，则对任意a∈A，如果a存在逆元，则逆元唯一；如果a存在逆元，则该逆元一定是左逆元，右逆元；如果a存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。'}",,3,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)"
定理11.4,定理,"['第十一章  抽象代数结构通论', '§ 11.2 代数结构的运算性质', '11.2.2 特殊元素']","{'实体类型': '定理', '内容': '假设⟨A,*⟩是一个代数系统，集合A上的二元运算*$满足结合律，则对于任意a,b∈A，如果a,b分别有逆元a^(-1),b^(-1)，则(a*b)^(-1)=b^(-1)*a^(-1)；如果a是左（右）可逆元，则a是左（右）可消去元；如果a是可逆元，则a是可消去元。'}",,3,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)"
定理11.5,定理,"['第十一章  抽象代数结构通论', '§ 11.3 同构、同态与同余', '11.3.2  同构与同态与性质']","{'实体类型': '定理', '条件': '两个同构的代数结构', '结论': '其运算性质（结合律、交换律、单位元、零元、逆元）相同'}",,3,"上一节我们通过类比图模型的同构关系引入代数结构之间的同构映射关系，并将代数结构的同构关系进一步推广到同态映射关系。我们知道，如果两个图模型之间具有同构关系，则说明这两个图模型的结构完全相同。 图模型作为一种拓扑数学结构，其结构一般由结点的度结构、结点与边的关联性、结点与结点之间的连接通路等性质决定。不难看出，对于同构的两个图模型，它们之间的这些结构性质均完全相同。代数结构则是一种运算结构，其结构特征主要由其运算性质决定。具体地说，就是代数结构的结构特征是由结合律、交换律、消去律、幂等律、吸收律、分配律这六个算律，以及单位元、零元和逆元等特殊元素的性质决定。下面具体考察同构的两个代数系统之间在运算性质方面有何关联。  
首先考察只有一个二元运算的代数结构：  
【定理11.5】假设$\langle A,\ *\rangle$和$\langle B,\ \circ\rangle$是任意两个同构的代数结构，$\psi\colon A\to B$是其同构映射，即对于$\forall x_{1},x_{2}\in\begin{array}{l}{A}\end{array}$，有$\psi(x_{1}*x_{2})=\psi(x_{1})\circ\psi(x_{2})$，那么：  
（1）如果运算$^*$满足结合律，那么运算$∘$也满足结合律；  
（2）如果运算$*$满足交换律，那么运算$\circ$也满足交换律:  
（3）如果运算$^*$存在单位元$e$，那么运算$∘$存在单位元$e。$，且满足：$\psi(e_{\ast})=e_{\circ}$；  
（4）如果运算$*$存在零元$\theta_{*}$，那么运算∘存在单位元$\theta_{\circ}$，且满足：$\psi({\boldsymbol{\theta}}_{*})=\theta_{\circ}$  
（5）如果对于运算$*$，集合𝐴中每个元素均可逆，即对于$\forall x\in A$，有${x}{}^{-1}\in A$，那么对于运算∘，集合$ B$中每个元素均可逆，即对于$\forall\mathbf{y}\in B$，有$y^{-1}\in B$，且$\mathbf{y}^{-1}=\mathbf{\begin{array}{l}{\psi(x^{-1})}\end{array}}$。  
现在考察含有两个二元运算的代数结构：  
【定理11.6】假设$\langle A,+,\ \times\rangle$和$\langle B,\,\oplus,\,\otimes\,\rangle$是任意两个同构的代数结构，$\psi$：$A\rightarrow B$是其同构映射，即$\psi$是从$A$到$B$的双射且对于$\forall x_{1},x_{2}\in\begin{array}{l}{A}\end{array}$，有：  
$$
\psi(x_{1}+x_{2})=\psi(x_{1})\oplus\psi(x_{2});\,\,\,\psi(x_{1}\times x_{2})=\psi(x_{1})\otimes\psi(x_{2})
$$  
那么：  
（1）如果运算$+$对运算$\times$满足分配律，那么运算⊕对运算$\otimes$也满足分配律；  
（2）如果运算$+$和运算$\times$满足吸收律，那么运算$\oplus$和运算$\otimes$也满足吸收律。  
从上述两个定理可以看出，对于同构的两个代数结构，其运算性质完全一样。事实上，下面定理11.7 表明具有两个代数结构之间的同构关系其实是一种等价关系：  
【定理11.7】代数结构之间的同构关系≅是一种等价关系，即有：  
（1）自反性：任何代数系统$\langle A,{*}\rangle,$有$\langle A,\ *\rangle\cong\langle A,\ *\rangle.$；  
（2）对称性：任何代数系统$\langle A,\ *\rangle,\,\langle B,\ \oplus\rangle$，若$\langle A,\ *\rangle\cong\langle B,\ \oplus\rangle$，则$\langle B,\ \oplus\rangle\cong\langle A,\ *\rangle$；  
（3）传递性：任何代数系统$\langle A,\ *\rangle$，$\langle B,\ \oplus\rangle$，$\langle C,\circledast\rangle$，若$\langle A,\ *\rangle\cong\langle B,\ \oplus\rangle$，$\langle B,\,\oplus\rangle\cong$$\langle C,\ \circledast\rangle$，则$\langle A,\ *\rangle\cong\langle C,\ \circledast\rangle$。  
既然代数结构之间的同构关系$\cong$是一种等价关系，那么就可以通过$\cong$对所有的代数系统组成的集合$H=\{G|G$是代数结构}进行划分，属于同一个划分块的代数结构彼此同构，由此产生集合$H$关于≅的一个商集合$H/{\cong}=\{[x]_{\cong}|x\in H\}$。由于同构关系是一种等价关系，只需在$[x]_{\cong}$中任取一个代数结构进行研究即可知道$[x]_{\cong}$中所有代数结构的性质。因此，可以将讨论$|H|$个代数结构的问题转化为讨论$|H/\cong|$个代数结构的问题，有效减少了问题的规模。  
下面考察同态代数结构的运算性质。不难发现，在前面关于同构代数结构运算性质的证明过程中，在很多场合仅用到同构映射中满射的条件，而没有涉及单射的条件。因此，同构代数结构的很多运算性质对于满同态的代数结构也成立，故有下列定理：  
【定理11.8】设$\psi$是从代数系统$\langle A,\Delta\rangle$到$\langle B,*\rangle$的满同态映射，则有：  
（1）若运算’$\Delta$‘是可交换的，则运算‘$*$’也是可交换的；  
（2）若运算‘$\Delta$’是可结合的，则运算‘$*$’也是可结合的；  
（3）若$e$是$\langle A,\Delta\rangle$的幺元，则$\psi(e)$是$\langle B,*\rangle$的幺元；  
（4）若$\theta$是$\langle A,\Delta\rangle_{1}$的零元，则$\psi(\theta)$是$\langle B,*\rangle$的零元；  
（5）若$\delta$是$\langle A,\Delta\rangle$的幂等元，则$\psi(\delta)$是$\langle B,*\rangle$的幂等元；  
（6）若$ x^{-1}$是$x$在$\langle A,\Delta\rangle$上的逆元，则$\psi(x^{-1})$是$\psi(x)$在$\langle B,*\rangle$中的逆元。  
上述性质可以看出，若$\psi$是一个满同态，则他把幺元映射成幺元，逆元映射成逆元，零元映射成零元，幂等元映射成幂等元。下面的定理11.9 表明，满同态保持二元运算的分配律和吸收律。  
【定理11.9】设$\langle A,+,\ \times\rangle$和$\langle B,\,\oplus,\,\otimes\,\rangle$是任意两个满同态代数结构，$\psi$：$A\rightarrow B$是从$\langle A,+,\ \times\rangle$到$\langle B,\,\oplus,\,\otimes\,\rangle$的满同态映射，即$\psi$是从$A$到$B$的满射且对于$\forall x_{1},x_{2}\in$$A$有：  
$$
\psi(x_{1}+x_{2})=\psi(x_{1})\oplus\psi(x_{2});\,\,\,\psi(x_{1}\times x_{2})=\psi(x_{1})\otimes\psi(x_{2})
$$  
那么：  
（1）如果运算$+$对运算$\times$满足分配律，那么运算⊕对运算$\otimes$也满足分配律；  
（2）如果运算$+$和运算$\times$满足吸收律，那么运算⊕和运算$\otimes$也满足吸收律。  
最后，我们考察同态像的性质，下面的定理11.3.10 表明同态像是一个子代数：  
【定理11.10】设$\langle A,\ *\rangle$和$\langle B,\,\circ\,\rangle$是任意两个同态的代数结构，函数$\mathcal{\psi}$是从$\langle A,\ *\rangle$到$\langle B,\,\circ\,\rangle$的同态映射，则同态像$\langle\psi(A,\,\circ\ \rangle$是$\langle B,\,\circ\,\rangle$的一个子代数结构。  
上述定理表明，同态像是$\langle\psi(A),\;\circ\rangle$是$\langle B,\,\circ\,\rangle$的一个子代数。因此，即使$\psi$不是一个满射函数，也可以通过该函数在$\langle A,\ *\rangle$与$\langle\psi(A),\;\circ\rangle$之间建立一个满同态关系。此时由定理11.3.8可知，$\langle A,\ *\rangle$与$\langle\psi(A),\ \circ\rangle$之间具体很多相同的运算性质。因此，同态像$\langle\psi(A),\ \circ\rangle$可以看成对代数结构$\langle A,\ *\rangle$的一种更加精简的浓缩。"
定理11.6,定理,"['第十一章  抽象代数结构通论', '§ 11.3 同构、同态与同余', '11.3.2  同构与同态与性质']","{'实体类型': '定理', '条件': '两个同构的代数结构', '结论': '其运算性质（分配律、吸收律）相同'}",,3,"上一节我们通过类比图模型的同构关系引入代数结构之间的同构映射关系，并将代数结构的同构关系进一步推广到同态映射关系。我们知道，如果两个图模型之间具有同构关系，则说明这两个图模型的结构完全相同。 图模型作为一种拓扑数学结构，其结构一般由结点的度结构、结点与边的关联性、结点与结点之间的连接通路等性质决定。不难看出，对于同构的两个图模型，它们之间的这些结构性质均完全相同。代数结构则是一种运算结构，其结构特征主要由其运算性质决定。具体地说，就是代数结构的结构特征是由结合律、交换律、消去律、幂等律、吸收律、分配律这六个算律，以及单位元、零元和逆元等特殊元素的性质决定。下面具体考察同构的两个代数系统之间在运算性质方面有何关联。  
首先考察只有一个二元运算的代数结构：  
【定理11.5】假设$\langle A,\ *\rangle$和$\langle B,\ \circ\rangle$是任意两个同构的代数结构，$\psi\colon A\to B$是其同构映射，即对于$\forall x_{1},x_{2}\in\begin{array}{l}{A}\end{array}$，有$\psi(x_{1}*x_{2})=\psi(x_{1})\circ\psi(x_{2})$，那么：  
（1）如果运算$^*$满足结合律，那么运算$∘$也满足结合律；  
（2）如果运算$*$满足交换律，那么运算$\circ$也满足交换律:  
（3）如果运算$^*$存在单位元$e$，那么运算$∘$存在单位元$e。$，且满足：$\psi(e_{\ast})=e_{\circ}$；  
（4）如果运算$*$存在零元$\theta_{*}$，那么运算∘存在单位元$\theta_{\circ}$，且满足：$\psi({\boldsymbol{\theta}}_{*})=\theta_{\circ}$  
（5）如果对于运算$*$，集合𝐴中每个元素均可逆，即对于$\forall x\in A$，有${x}{}^{-1}\in A$，那么对于运算∘，集合$ B$中每个元素均可逆，即对于$\forall\mathbf{y}\in B$，有$y^{-1}\in B$，且$\mathbf{y}^{-1}=\mathbf{\begin{array}{l}{\psi(x^{-1})}\end{array}}$。  
现在考察含有两个二元运算的代数结构：  
【定理11.6】假设$\langle A,+,\ \times\rangle$和$\langle B,\,\oplus,\,\otimes\,\rangle$是任意两个同构的代数结构，$\psi$：$A\rightarrow B$是其同构映射，即$\psi$是从$A$到$B$的双射且对于$\forall x_{1},x_{2}\in\begin{array}{l}{A}\end{array}$，有：  
$$
\psi(x_{1}+x_{2})=\psi(x_{1})\oplus\psi(x_{2});\,\,\,\psi(x_{1}\times x_{2})=\psi(x_{1})\otimes\psi(x_{2})
$$  
那么：  
（1）如果运算$+$对运算$\times$满足分配律，那么运算⊕对运算$\otimes$也满足分配律；  
（2）如果运算$+$和运算$\times$满足吸收律，那么运算$\oplus$和运算$\otimes$也满足吸收律。  
从上述两个定理可以看出，对于同构的两个代数结构，其运算性质完全一样。事实上，下面定理11.7 表明具有两个代数结构之间的同构关系其实是一种等价关系：  
【定理11.7】代数结构之间的同构关系≅是一种等价关系，即有：  
（1）自反性：任何代数系统$\langle A,{*}\rangle,$有$\langle A,\ *\rangle\cong\langle A,\ *\rangle.$；  
（2）对称性：任何代数系统$\langle A,\ *\rangle,\,\langle B,\ \oplus\rangle$，若$\langle A,\ *\rangle\cong\langle B,\ \oplus\rangle$，则$\langle B,\ \oplus\rangle\cong\langle A,\ *\rangle$；  
（3）传递性：任何代数系统$\langle A,\ *\rangle$，$\langle B,\ \oplus\rangle$，$\langle C,\circledast\rangle$，若$\langle A,\ *\rangle\cong\langle B,\ \oplus\rangle$，$\langle B,\,\oplus\rangle\cong$$\langle C,\ \circledast\rangle$，则$\langle A,\ *\rangle\cong\langle C,\ \circledast\rangle$。  
既然代数结构之间的同构关系$\cong$是一种等价关系，那么就可以通过$\cong$对所有的代数系统组成的集合$H=\{G|G$是代数结构}进行划分，属于同一个划分块的代数结构彼此同构，由此产生集合$H$关于≅的一个商集合$H/{\cong}=\{[x]_{\cong}|x\in H\}$。由于同构关系是一种等价关系，只需在$[x]_{\cong}$中任取一个代数结构进行研究即可知道$[x]_{\cong}$中所有代数结构的性质。因此，可以将讨论$|H|$个代数结构的问题转化为讨论$|H/\cong|$个代数结构的问题，有效减少了问题的规模。  
下面考察同态代数结构的运算性质。不难发现，在前面关于同构代数结构运算性质的证明过程中，在很多场合仅用到同构映射中满射的条件，而没有涉及单射的条件。因此，同构代数结构的很多运算性质对于满同态的代数结构也成立，故有下列定理：  
【定理11.8】设$\psi$是从代数系统$\langle A,\Delta\rangle$到$\langle B,*\rangle$的满同态映射，则有：  
（1）若运算’$\Delta$‘是可交换的，则运算‘$*$’也是可交换的；  
（2）若运算‘$\Delta$’是可结合的，则运算‘$*$’也是可结合的；  
（3）若$e$是$\langle A,\Delta\rangle$的幺元，则$\psi(e)$是$\langle B,*\rangle$的幺元；  
（4）若$\theta$是$\langle A,\Delta\rangle_{1}$的零元，则$\psi(\theta)$是$\langle B,*\rangle$的零元；  
（5）若$\delta$是$\langle A,\Delta\rangle$的幂等元，则$\psi(\delta)$是$\langle B,*\rangle$的幂等元；  
（6）若$ x^{-1}$是$x$在$\langle A,\Delta\rangle$上的逆元，则$\psi(x^{-1})$是$\psi(x)$在$\langle B,*\rangle$中的逆元。  
上述性质可以看出，若$\psi$是一个满同态，则他把幺元映射成幺元，逆元映射成逆元，零元映射成零元，幂等元映射成幂等元。下面的定理11.9 表明，满同态保持二元运算的分配律和吸收律。  
【定理11.9】设$\langle A,+,\ \times\rangle$和$\langle B,\,\oplus,\,\otimes\,\rangle$是任意两个满同态代数结构，$\psi$：$A\rightarrow B$是从$\langle A,+,\ \times\rangle$到$\langle B,\,\oplus,\,\otimes\,\rangle$的满同态映射，即$\psi$是从$A$到$B$的满射且对于$\forall x_{1},x_{2}\in$$A$有：  
$$
\psi(x_{1}+x_{2})=\psi(x_{1})\oplus\psi(x_{2});\,\,\,\psi(x_{1}\times x_{2})=\psi(x_{1})\otimes\psi(x_{2})
$$  
那么：  
（1）如果运算$+$对运算$\times$满足分配律，那么运算⊕对运算$\otimes$也满足分配律；  
（2）如果运算$+$和运算$\times$满足吸收律，那么运算⊕和运算$\otimes$也满足吸收律。  
最后，我们考察同态像的性质，下面的定理11.3.10 表明同态像是一个子代数：  
【定理11.10】设$\langle A,\ *\rangle$和$\langle B,\,\circ\,\rangle$是任意两个同态的代数结构，函数$\mathcal{\psi}$是从$\langle A,\ *\rangle$到$\langle B,\,\circ\,\rangle$的同态映射，则同态像$\langle\psi(A,\,\circ\ \rangle$是$\langle B,\,\circ\,\rangle$的一个子代数结构。  
上述定理表明，同态像是$\langle\psi(A),\;\circ\rangle$是$\langle B,\,\circ\,\rangle$的一个子代数。因此，即使$\psi$不是一个满射函数，也可以通过该函数在$\langle A,\ *\rangle$与$\langle\psi(A),\;\circ\rangle$之间建立一个满同态关系。此时由定理11.3.8可知，$\langle A,\ *\rangle$与$\langle\psi(A),\ \circ\rangle$之间具体很多相同的运算性质。因此，同态像$\langle\psi(A),\ \circ\rangle$可以看成对代数结构$\langle A,\ *\rangle$的一种更加精简的浓缩。"
定理11.7,定理,"['第十一章  抽象代数结构通论', '§ 11.3 同构、同态与同余', '11.3.2  同构与同态与性质']","{'实体类型': '定理', '条件': '代数结构之间的同构关系', '结论': '同构关系是一种等价关系（自反性、对称性、传递性）'}",,3,"上一节我们通过类比图模型的同构关系引入代数结构之间的同构映射关系，并将代数结构的同构关系进一步推广到同态映射关系。我们知道，如果两个图模型之间具有同构关系，则说明这两个图模型的结构完全相同。 图模型作为一种拓扑数学结构，其结构一般由结点的度结构、结点与边的关联性、结点与结点之间的连接通路等性质决定。不难看出，对于同构的两个图模型，它们之间的这些结构性质均完全相同。代数结构则是一种运算结构，其结构特征主要由其运算性质决定。具体地说，就是代数结构的结构特征是由结合律、交换律、消去律、幂等律、吸收律、分配律这六个算律，以及单位元、零元和逆元等特殊元素的性质决定。下面具体考察同构的两个代数系统之间在运算性质方面有何关联。  
首先考察只有一个二元运算的代数结构：  
【定理11.5】假设$\langle A,\ *\rangle$和$\langle B,\ \circ\rangle$是任意两个同构的代数结构，$\psi\colon A\to B$是其同构映射，即对于$\forall x_{1},x_{2}\in\begin{array}{l}{A}\end{array}$，有$\psi(x_{1}*x_{2})=\psi(x_{1})\circ\psi(x_{2})$，那么：  
（1）如果运算$^*$满足结合律，那么运算$∘$也满足结合律；  
（2）如果运算$*$满足交换律，那么运算$\circ$也满足交换律:  
（3）如果运算$^*$存在单位元$e$，那么运算$∘$存在单位元$e。$，且满足：$\psi(e_{\ast})=e_{\circ}$；  
（4）如果运算$*$存在零元$\theta_{*}$，那么运算∘存在单位元$\theta_{\circ}$，且满足：$\psi({\boldsymbol{\theta}}_{*})=\theta_{\circ}$  
（5）如果对于运算$*$，集合𝐴中每个元素均可逆，即对于$\forall x\in A$，有${x}{}^{-1}\in A$，那么对于运算∘，集合$ B$中每个元素均可逆，即对于$\forall\mathbf{y}\in B$，有$y^{-1}\in B$，且$\mathbf{y}^{-1}=\mathbf{\begin{array}{l}{\psi(x^{-1})}\end{array}}$。  
现在考察含有两个二元运算的代数结构：  
【定理11.6】假设$\langle A,+,\ \times\rangle$和$\langle B,\,\oplus,\,\otimes\,\rangle$是任意两个同构的代数结构，$\psi$：$A\rightarrow B$是其同构映射，即$\psi$是从$A$到$B$的双射且对于$\forall x_{1},x_{2}\in\begin{array}{l}{A}\end{array}$，有：  
$$
\psi(x_{1}+x_{2})=\psi(x_{1})\oplus\psi(x_{2});\,\,\,\psi(x_{1}\times x_{2})=\psi(x_{1})\otimes\psi(x_{2})
$$  
那么：  
（1）如果运算$+$对运算$\times$满足分配律，那么运算⊕对运算$\otimes$也满足分配律；  
（2）如果运算$+$和运算$\times$满足吸收律，那么运算$\oplus$和运算$\otimes$也满足吸收律。  
从上述两个定理可以看出，对于同构的两个代数结构，其运算性质完全一样。事实上，下面定理11.7 表明具有两个代数结构之间的同构关系其实是一种等价关系：  
【定理11.7】代数结构之间的同构关系≅是一种等价关系，即有：  
（1）自反性：任何代数系统$\langle A,{*}\rangle,$有$\langle A,\ *\rangle\cong\langle A,\ *\rangle.$；  
（2）对称性：任何代数系统$\langle A,\ *\rangle,\,\langle B,\ \oplus\rangle$，若$\langle A,\ *\rangle\cong\langle B,\ \oplus\rangle$，则$\langle B,\ \oplus\rangle\cong\langle A,\ *\rangle$；  
（3）传递性：任何代数系统$\langle A,\ *\rangle$，$\langle B,\ \oplus\rangle$，$\langle C,\circledast\rangle$，若$\langle A,\ *\rangle\cong\langle B,\ \oplus\rangle$，$\langle B,\,\oplus\rangle\cong$$\langle C,\ \circledast\rangle$，则$\langle A,\ *\rangle\cong\langle C,\ \circledast\rangle$。  
既然代数结构之间的同构关系$\cong$是一种等价关系，那么就可以通过$\cong$对所有的代数系统组成的集合$H=\{G|G$是代数结构}进行划分，属于同一个划分块的代数结构彼此同构，由此产生集合$H$关于≅的一个商集合$H/{\cong}=\{[x]_{\cong}|x\in H\}$。由于同构关系是一种等价关系，只需在$[x]_{\cong}$中任取一个代数结构进行研究即可知道$[x]_{\cong}$中所有代数结构的性质。因此，可以将讨论$|H|$个代数结构的问题转化为讨论$|H/\cong|$个代数结构的问题，有效减少了问题的规模。  
下面考察同态代数结构的运算性质。不难发现，在前面关于同构代数结构运算性质的证明过程中，在很多场合仅用到同构映射中满射的条件，而没有涉及单射的条件。因此，同构代数结构的很多运算性质对于满同态的代数结构也成立，故有下列定理：  
【定理11.8】设$\psi$是从代数系统$\langle A,\Delta\rangle$到$\langle B,*\rangle$的满同态映射，则有：  
（1）若运算’$\Delta$‘是可交换的，则运算‘$*$’也是可交换的；  
（2）若运算‘$\Delta$’是可结合的，则运算‘$*$’也是可结合的；  
（3）若$e$是$\langle A,\Delta\rangle$的幺元，则$\psi(e)$是$\langle B,*\rangle$的幺元；  
（4）若$\theta$是$\langle A,\Delta\rangle_{1}$的零元，则$\psi(\theta)$是$\langle B,*\rangle$的零元；  
（5）若$\delta$是$\langle A,\Delta\rangle$的幂等元，则$\psi(\delta)$是$\langle B,*\rangle$的幂等元；  
（6）若$ x^{-1}$是$x$在$\langle A,\Delta\rangle$上的逆元，则$\psi(x^{-1})$是$\psi(x)$在$\langle B,*\rangle$中的逆元。  
上述性质可以看出，若$\psi$是一个满同态，则他把幺元映射成幺元，逆元映射成逆元，零元映射成零元，幂等元映射成幂等元。下面的定理11.9 表明，满同态保持二元运算的分配律和吸收律。  
【定理11.9】设$\langle A,+,\ \times\rangle$和$\langle B,\,\oplus,\,\otimes\,\rangle$是任意两个满同态代数结构，$\psi$：$A\rightarrow B$是从$\langle A,+,\ \times\rangle$到$\langle B,\,\oplus,\,\otimes\,\rangle$的满同态映射，即$\psi$是从$A$到$B$的满射且对于$\forall x_{1},x_{2}\in$$A$有：  
$$
\psi(x_{1}+x_{2})=\psi(x_{1})\oplus\psi(x_{2});\,\,\,\psi(x_{1}\times x_{2})=\psi(x_{1})\otimes\psi(x_{2})
$$  
那么：  
（1）如果运算$+$对运算$\times$满足分配律，那么运算⊕对运算$\otimes$也满足分配律；  
（2）如果运算$+$和运算$\times$满足吸收律，那么运算⊕和运算$\otimes$也满足吸收律。  
最后，我们考察同态像的性质，下面的定理11.3.10 表明同态像是一个子代数：  
【定理11.10】设$\langle A,\ *\rangle$和$\langle B,\,\circ\,\rangle$是任意两个同态的代数结构，函数$\mathcal{\psi}$是从$\langle A,\ *\rangle$到$\langle B,\,\circ\,\rangle$的同态映射，则同态像$\langle\psi(A,\,\circ\ \rangle$是$\langle B,\,\circ\,\rangle$的一个子代数结构。  
上述定理表明，同态像是$\langle\psi(A),\;\circ\rangle$是$\langle B,\,\circ\,\rangle$的一个子代数。因此，即使$\psi$不是一个满射函数，也可以通过该函数在$\langle A,\ *\rangle$与$\langle\psi(A),\;\circ\rangle$之间建立一个满同态关系。此时由定理11.3.8可知，$\langle A,\ *\rangle$与$\langle\psi(A),\ \circ\rangle$之间具体很多相同的运算性质。因此，同态像$\langle\psi(A),\ \circ\rangle$可以看成对代数结构$\langle A,\ *\rangle$的一种更加精简的浓缩。"
定理11.8,定理,"['第十一章  抽象代数结构通论', '§ 11.3 同构、同态与同余', '11.3.2  同构与同态与性质']","{'实体类型': '定理', '条件': '满同态映射', '结论': '保持运算性质（交换性、结合性、幺元、零元、幂等元、逆元）'}",,3,"上一节我们通过类比图模型的同构关系引入代数结构之间的同构映射关系，并将代数结构的同构关系进一步推广到同态映射关系。我们知道，如果两个图模型之间具有同构关系，则说明这两个图模型的结构完全相同。 图模型作为一种拓扑数学结构，其结构一般由结点的度结构、结点与边的关联性、结点与结点之间的连接通路等性质决定。不难看出，对于同构的两个图模型，它们之间的这些结构性质均完全相同。代数结构则是一种运算结构，其结构特征主要由其运算性质决定。具体地说，就是代数结构的结构特征是由结合律、交换律、消去律、幂等律、吸收律、分配律这六个算律，以及单位元、零元和逆元等特殊元素的性质决定。下面具体考察同构的两个代数系统之间在运算性质方面有何关联。  
首先考察只有一个二元运算的代数结构：  
【定理11.5】假设$\langle A,\ *\rangle$和$\langle B,\ \circ\rangle$是任意两个同构的代数结构，$\psi\colon A\to B$是其同构映射，即对于$\forall x_{1},x_{2}\in\begin{array}{l}{A}\end{array}$，有$\psi(x_{1}*x_{2})=\psi(x_{1})\circ\psi(x_{2})$，那么：  
（1）如果运算$^*$满足结合律，那么运算$∘$也满足结合律；  
（2）如果运算$*$满足交换律，那么运算$\circ$也满足交换律:  
（3）如果运算$^*$存在单位元$e$，那么运算$∘$存在单位元$e。$，且满足：$\psi(e_{\ast})=e_{\circ}$；  
（4）如果运算$*$存在零元$\theta_{*}$，那么运算∘存在单位元$\theta_{\circ}$，且满足：$\psi({\boldsymbol{\theta}}_{*})=\theta_{\circ}$  
（5）如果对于运算$*$，集合𝐴中每个元素均可逆，即对于$\forall x\in A$，有${x}{}^{-1}\in A$，那么对于运算∘，集合$ B$中每个元素均可逆，即对于$\forall\mathbf{y}\in B$，有$y^{-1}\in B$，且$\mathbf{y}^{-1}=\mathbf{\begin{array}{l}{\psi(x^{-1})}\end{array}}$。  
现在考察含有两个二元运算的代数结构：  
【定理11.6】假设$\langle A,+,\ \times\rangle$和$\langle B,\,\oplus,\,\otimes\,\rangle$是任意两个同构的代数结构，$\psi$：$A\rightarrow B$是其同构映射，即$\psi$是从$A$到$B$的双射且对于$\forall x_{1},x_{2}\in\begin{array}{l}{A}\end{array}$，有：  
$$
\psi(x_{1}+x_{2})=\psi(x_{1})\oplus\psi(x_{2});\,\,\,\psi(x_{1}\times x_{2})=\psi(x_{1})\otimes\psi(x_{2})
$$  
那么：  
（1）如果运算$+$对运算$\times$满足分配律，那么运算⊕对运算$\otimes$也满足分配律；  
（2）如果运算$+$和运算$\times$满足吸收律，那么运算$\oplus$和运算$\otimes$也满足吸收律。  
从上述两个定理可以看出，对于同构的两个代数结构，其运算性质完全一样。事实上，下面定理11.7 表明具有两个代数结构之间的同构关系其实是一种等价关系：  
【定理11.7】代数结构之间的同构关系≅是一种等价关系，即有：  
（1）自反性：任何代数系统$\langle A,{*}\rangle,$有$\langle A,\ *\rangle\cong\langle A,\ *\rangle.$；  
（2）对称性：任何代数系统$\langle A,\ *\rangle,\,\langle B,\ \oplus\rangle$，若$\langle A,\ *\rangle\cong\langle B,\ \oplus\rangle$，则$\langle B,\ \oplus\rangle\cong\langle A,\ *\rangle$；  
（3）传递性：任何代数系统$\langle A,\ *\rangle$，$\langle B,\ \oplus\rangle$，$\langle C,\circledast\rangle$，若$\langle A,\ *\rangle\cong\langle B,\ \oplus\rangle$，$\langle B,\,\oplus\rangle\cong$$\langle C,\ \circledast\rangle$，则$\langle A,\ *\rangle\cong\langle C,\ \circledast\rangle$。  
既然代数结构之间的同构关系$\cong$是一种等价关系，那么就可以通过$\cong$对所有的代数系统组成的集合$H=\{G|G$是代数结构}进行划分，属于同一个划分块的代数结构彼此同构，由此产生集合$H$关于≅的一个商集合$H/{\cong}=\{[x]_{\cong}|x\in H\}$。由于同构关系是一种等价关系，只需在$[x]_{\cong}$中任取一个代数结构进行研究即可知道$[x]_{\cong}$中所有代数结构的性质。因此，可以将讨论$|H|$个代数结构的问题转化为讨论$|H/\cong|$个代数结构的问题，有效减少了问题的规模。  
下面考察同态代数结构的运算性质。不难发现，在前面关于同构代数结构运算性质的证明过程中，在很多场合仅用到同构映射中满射的条件，而没有涉及单射的条件。因此，同构代数结构的很多运算性质对于满同态的代数结构也成立，故有下列定理：  
【定理11.8】设$\psi$是从代数系统$\langle A,\Delta\rangle$到$\langle B,*\rangle$的满同态映射，则有：  
（1）若运算’$\Delta$‘是可交换的，则运算‘$*$’也是可交换的；  
（2）若运算‘$\Delta$’是可结合的，则运算‘$*$’也是可结合的；  
（3）若$e$是$\langle A,\Delta\rangle$的幺元，则$\psi(e)$是$\langle B,*\rangle$的幺元；  
（4）若$\theta$是$\langle A,\Delta\rangle_{1}$的零元，则$\psi(\theta)$是$\langle B,*\rangle$的零元；  
（5）若$\delta$是$\langle A,\Delta\rangle$的幂等元，则$\psi(\delta)$是$\langle B,*\rangle$的幂等元；  
（6）若$ x^{-1}$是$x$在$\langle A,\Delta\rangle$上的逆元，则$\psi(x^{-1})$是$\psi(x)$在$\langle B,*\rangle$中的逆元。  
上述性质可以看出，若$\psi$是一个满同态，则他把幺元映射成幺元，逆元映射成逆元，零元映射成零元，幂等元映射成幂等元。下面的定理11.9 表明，满同态保持二元运算的分配律和吸收律。  
【定理11.9】设$\langle A,+,\ \times\rangle$和$\langle B,\,\oplus,\,\otimes\,\rangle$是任意两个满同态代数结构，$\psi$：$A\rightarrow B$是从$\langle A,+,\ \times\rangle$到$\langle B,\,\oplus,\,\otimes\,\rangle$的满同态映射，即$\psi$是从$A$到$B$的满射且对于$\forall x_{1},x_{2}\in$$A$有：  
$$
\psi(x_{1}+x_{2})=\psi(x_{1})\oplus\psi(x_{2});\,\,\,\psi(x_{1}\times x_{2})=\psi(x_{1})\otimes\psi(x_{2})
$$  
那么：  
（1）如果运算$+$对运算$\times$满足分配律，那么运算⊕对运算$\otimes$也满足分配律；  
（2）如果运算$+$和运算$\times$满足吸收律，那么运算⊕和运算$\otimes$也满足吸收律。  
最后，我们考察同态像的性质，下面的定理11.3.10 表明同态像是一个子代数：  
【定理11.10】设$\langle A,\ *\rangle$和$\langle B,\,\circ\,\rangle$是任意两个同态的代数结构，函数$\mathcal{\psi}$是从$\langle A,\ *\rangle$到$\langle B,\,\circ\,\rangle$的同态映射，则同态像$\langle\psi(A,\,\circ\ \rangle$是$\langle B,\,\circ\,\rangle$的一个子代数结构。  
上述定理表明，同态像是$\langle\psi(A),\;\circ\rangle$是$\langle B,\,\circ\,\rangle$的一个子代数。因此，即使$\psi$不是一个满射函数，也可以通过该函数在$\langle A,\ *\rangle$与$\langle\psi(A),\;\circ\rangle$之间建立一个满同态关系。此时由定理11.3.8可知，$\langle A,\ *\rangle$与$\langle\psi(A),\ \circ\rangle$之间具体很多相同的运算性质。因此，同态像$\langle\psi(A),\ \circ\rangle$可以看成对代数结构$\langle A,\ *\rangle$的一种更加精简的浓缩。"
定理11.9,定理,"['第十一章  抽象代数结构通论', '§ 11.3 同构、同态与同余', '11.3.2  同构与同态与性质']","{'实体类型': '定理', '条件': '满同态代数结构', '结论': '保持二元运算的分配律和吸收律'}",,3,"上一节我们通过类比图模型的同构关系引入代数结构之间的同构映射关系，并将代数结构的同构关系进一步推广到同态映射关系。我们知道，如果两个图模型之间具有同构关系，则说明这两个图模型的结构完全相同。 图模型作为一种拓扑数学结构，其结构一般由结点的度结构、结点与边的关联性、结点与结点之间的连接通路等性质决定。不难看出，对于同构的两个图模型，它们之间的这些结构性质均完全相同。代数结构则是一种运算结构，其结构特征主要由其运算性质决定。具体地说，就是代数结构的结构特征是由结合律、交换律、消去律、幂等律、吸收律、分配律这六个算律，以及单位元、零元和逆元等特殊元素的性质决定。下面具体考察同构的两个代数系统之间在运算性质方面有何关联。  
首先考察只有一个二元运算的代数结构：  
【定理11.5】假设$\langle A,\ *\rangle$和$\langle B,\ \circ\rangle$是任意两个同构的代数结构，$\psi\colon A\to B$是其同构映射，即对于$\forall x_{1},x_{2}\in\begin{array}{l}{A}\end{array}$，有$\psi(x_{1}*x_{2})=\psi(x_{1})\circ\psi(x_{2})$，那么：  
（1）如果运算$^*$满足结合律，那么运算$∘$也满足结合律；  
（2）如果运算$*$满足交换律，那么运算$\circ$也满足交换律:  
（3）如果运算$^*$存在单位元$e$，那么运算$∘$存在单位元$e。$，且满足：$\psi(e_{\ast})=e_{\circ}$；  
（4）如果运算$*$存在零元$\theta_{*}$，那么运算∘存在单位元$\theta_{\circ}$，且满足：$\psi({\boldsymbol{\theta}}_{*})=\theta_{\circ}$  
（5）如果对于运算$*$，集合𝐴中每个元素均可逆，即对于$\forall x\in A$，有${x}{}^{-1}\in A$，那么对于运算∘，集合$ B$中每个元素均可逆，即对于$\forall\mathbf{y}\in B$，有$y^{-1}\in B$，且$\mathbf{y}^{-1}=\mathbf{\begin{array}{l}{\psi(x^{-1})}\end{array}}$。  
现在考察含有两个二元运算的代数结构：  
【定理11.6】假设$\langle A,+,\ \times\rangle$和$\langle B,\,\oplus,\,\otimes\,\rangle$是任意两个同构的代数结构，$\psi$：$A\rightarrow B$是其同构映射，即$\psi$是从$A$到$B$的双射且对于$\forall x_{1},x_{2}\in\begin{array}{l}{A}\end{array}$，有：  
$$
\psi(x_{1}+x_{2})=\psi(x_{1})\oplus\psi(x_{2});\,\,\,\psi(x_{1}\times x_{2})=\psi(x_{1})\otimes\psi(x_{2})
$$  
那么：  
（1）如果运算$+$对运算$\times$满足分配律，那么运算⊕对运算$\otimes$也满足分配律；  
（2）如果运算$+$和运算$\times$满足吸收律，那么运算$\oplus$和运算$\otimes$也满足吸收律。  
从上述两个定理可以看出，对于同构的两个代数结构，其运算性质完全一样。事实上，下面定理11.7 表明具有两个代数结构之间的同构关系其实是一种等价关系：  
【定理11.7】代数结构之间的同构关系≅是一种等价关系，即有：  
（1）自反性：任何代数系统$\langle A,{*}\rangle,$有$\langle A,\ *\rangle\cong\langle A,\ *\rangle.$；  
（2）对称性：任何代数系统$\langle A,\ *\rangle,\,\langle B,\ \oplus\rangle$，若$\langle A,\ *\rangle\cong\langle B,\ \oplus\rangle$，则$\langle B,\ \oplus\rangle\cong\langle A,\ *\rangle$；  
（3）传递性：任何代数系统$\langle A,\ *\rangle$，$\langle B,\ \oplus\rangle$，$\langle C,\circledast\rangle$，若$\langle A,\ *\rangle\cong\langle B,\ \oplus\rangle$，$\langle B,\,\oplus\rangle\cong$$\langle C,\ \circledast\rangle$，则$\langle A,\ *\rangle\cong\langle C,\ \circledast\rangle$。  
既然代数结构之间的同构关系$\cong$是一种等价关系，那么就可以通过$\cong$对所有的代数系统组成的集合$H=\{G|G$是代数结构}进行划分，属于同一个划分块的代数结构彼此同构，由此产生集合$H$关于≅的一个商集合$H/{\cong}=\{[x]_{\cong}|x\in H\}$。由于同构关系是一种等价关系，只需在$[x]_{\cong}$中任取一个代数结构进行研究即可知道$[x]_{\cong}$中所有代数结构的性质。因此，可以将讨论$|H|$个代数结构的问题转化为讨论$|H/\cong|$个代数结构的问题，有效减少了问题的规模。  
下面考察同态代数结构的运算性质。不难发现，在前面关于同构代数结构运算性质的证明过程中，在很多场合仅用到同构映射中满射的条件，而没有涉及单射的条件。因此，同构代数结构的很多运算性质对于满同态的代数结构也成立，故有下列定理：  
【定理11.8】设$\psi$是从代数系统$\langle A,\Delta\rangle$到$\langle B,*\rangle$的满同态映射，则有：  
（1）若运算’$\Delta$‘是可交换的，则运算‘$*$’也是可交换的；  
（2）若运算‘$\Delta$’是可结合的，则运算‘$*$’也是可结合的；  
（3）若$e$是$\langle A,\Delta\rangle$的幺元，则$\psi(e)$是$\langle B,*\rangle$的幺元；  
（4）若$\theta$是$\langle A,\Delta\rangle_{1}$的零元，则$\psi(\theta)$是$\langle B,*\rangle$的零元；  
（5）若$\delta$是$\langle A,\Delta\rangle$的幂等元，则$\psi(\delta)$是$\langle B,*\rangle$的幂等元；  
（6）若$ x^{-1}$是$x$在$\langle A,\Delta\rangle$上的逆元，则$\psi(x^{-1})$是$\psi(x)$在$\langle B,*\rangle$中的逆元。  
上述性质可以看出，若$\psi$是一个满同态，则他把幺元映射成幺元，逆元映射成逆元，零元映射成零元，幂等元映射成幂等元。下面的定理11.9 表明，满同态保持二元运算的分配律和吸收律。  
【定理11.9】设$\langle A,+,\ \times\rangle$和$\langle B,\,\oplus,\,\otimes\,\rangle$是任意两个满同态代数结构，$\psi$：$A\rightarrow B$是从$\langle A,+,\ \times\rangle$到$\langle B,\,\oplus,\,\otimes\,\rangle$的满同态映射，即$\psi$是从$A$到$B$的满射且对于$\forall x_{1},x_{2}\in$$A$有：  
$$
\psi(x_{1}+x_{2})=\psi(x_{1})\oplus\psi(x_{2});\,\,\,\psi(x_{1}\times x_{2})=\psi(x_{1})\otimes\psi(x_{2})
$$  
那么：  
（1）如果运算$+$对运算$\times$满足分配律，那么运算⊕对运算$\otimes$也满足分配律；  
（2）如果运算$+$和运算$\times$满足吸收律，那么运算⊕和运算$\otimes$也满足吸收律。  
最后，我们考察同态像的性质，下面的定理11.3.10 表明同态像是一个子代数：  
【定理11.10】设$\langle A,\ *\rangle$和$\langle B,\,\circ\,\rangle$是任意两个同态的代数结构，函数$\mathcal{\psi}$是从$\langle A,\ *\rangle$到$\langle B,\,\circ\,\rangle$的同态映射，则同态像$\langle\psi(A,\,\circ\ \rangle$是$\langle B,\,\circ\,\rangle$的一个子代数结构。  
上述定理表明，同态像是$\langle\psi(A),\;\circ\rangle$是$\langle B,\,\circ\,\rangle$的一个子代数。因此，即使$\psi$不是一个满射函数，也可以通过该函数在$\langle A,\ *\rangle$与$\langle\psi(A),\;\circ\rangle$之间建立一个满同态关系。此时由定理11.3.8可知，$\langle A,\ *\rangle$与$\langle\psi(A),\ \circ\rangle$之间具体很多相同的运算性质。因此，同态像$\langle\psi(A),\ \circ\rangle$可以看成对代数结构$\langle A,\ *\rangle$的一种更加精简的浓缩。"
定理12.1,定理,"['第十二章 典型抽象代数结构', '§ 12.1 半群的概念与性质', '12.1.2  方幂与循环半群']","{'实体类型': '定理', '内容': '设G是半群，H={a^n|n∈Z^+}，则H是G的子半群；若G是含幺半群，则H是G的子含幺半群'}",,3,"我们知道半群和含幺半群都满足结合律，如果对载体集合中任意给定的某个元素进行多次重复运算，那么得到的运算结果与运算次序无关。也就是说，无论以怎样的次序对该元素进行多次重复运算，其结果仅与该元素和运算次数有关。因此，可对半群和含幺半群载体集合中的任意元素定义其方幂运算，具体如下：  
【定义12.6】假设$\langle G,*\rangle$是任意给定的一个半群，对于$\forall a\in G$和正整数$n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个 a}
$$  
如果$\langle G,*\rangle$是一个含幺半群且$e$是其单位元素，则定义$a^{0}=e$。  
例如，对于实数集合上的加法运算构成的含幺半群$\langle R,+\rangle$，显然有：  
$5^{3}=5+5+5=15;\;\;1^{4}=1+1+1+1=4;\;\;5^{0}=1^{0}=0;\;\;0^{0}=0^{1}=0^{2}=0$  
根据上述定义，显然成立方幂运算法则，即对于任意非负整数$ n$和$m$，有：
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
对于任意一个给定的半群或含幺半群$\langle G,*\rangle$，既然可以对其载体中的任意一个元素构造其任何次方幂，并且根据运算$*$在载体集合$ G$上的封闭性知，该元素所有方幂组成的集合必然是$G$的一个子集，那么自然就需要考察该子集以及运算$*$在该子集上的运算性质。下面的定理12.1 表明运算$*$可以在该子集上构成子半群或子含幺半群：  
【定理 12.1 】设 $\langle G,*\rangle$ 是任一给定的半群且对 $\forall a\in G$ ，令 $H=\{a^{n}|n\in Z^{+}\}$ ，则 $\langle H,*\rangle$ 是 $\langle G,*\rangle$的子半群。此时，若$\langle G,*\rangle$是含幺半群，则$\langle H,*\rangle$是$\langle G,*\rangle$的子含幺半群。  
如果$\langle G,*\rangle$是一个含幺半群，设$e$为其单位元。由于$e=a^{0}\in H$，故$e$也是$\langle H,*\rangle$的单位元。因此，$\langle H,*\rangle$也是一个含幺半群。  
从上述定理可知，对于任一给定的半群或含幺半群$\langle G,*\rangle$，载体集合$G$中任一给定元素$a$的所有方幂组成的集合$ H$可与运算$*$一起构成一种半群或含幺半群$\langle H,*\rangle$。事实上，$\langle H,*\rangle$是一种特殊的半群或含幺半群，其特殊性在于载体集合中$H$每个元素都是给定元素$a$的某个方幂。现在考察这种特殊半群或含幺半群的基本概念和性质，首先给出如下定义：  
【定义12.7】设$\langle G,*\rangle$是任一给定的半群，如果$\exists a\in G$，使得$G$中的任意元素$x$都能够写成元素$a$的方幂形式，即对于$\forall x\in G$，$\exists n\in N$,使得$x=a^{n}$，则称$\langle G,*\rangle$是一个循环半群，并称$a$是$\langle G,*\rangle$的一个生成元，$\langle G,*\rangle$的所有生成元组成的集合$C$称为$\langle G,*\rangle$的生成集。此时，如果$\langle G,*\rangle$还是一个含幺半群，则称$\langle G,*\rangle$是一个循环含幺半群。  
【定理 12.2】每个循环半群都是可交换半群。"
定理12.2,定理,"['第十二章 典型抽象代数结构', '§ 12.1 半群的概念与性质', '12.1.2  方幂与循环半群']","{'实体类型': '定理', '内容': '每个循环半群都是可交换半群'}",,3,"我们知道半群和含幺半群都满足结合律，如果对载体集合中任意给定的某个元素进行多次重复运算，那么得到的运算结果与运算次序无关。也就是说，无论以怎样的次序对该元素进行多次重复运算，其结果仅与该元素和运算次数有关。因此，可对半群和含幺半群载体集合中的任意元素定义其方幂运算，具体如下：  
【定义12.6】假设$\langle G,*\rangle$是任意给定的一个半群，对于$\forall a\in G$和正整数$n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个 a}
$$  
如果$\langle G,*\rangle$是一个含幺半群且$e$是其单位元素，则定义$a^{0}=e$。  
例如，对于实数集合上的加法运算构成的含幺半群$\langle R,+\rangle$，显然有：  
$5^{3}=5+5+5=15;\;\;1^{4}=1+1+1+1=4;\;\;5^{0}=1^{0}=0;\;\;0^{0}=0^{1}=0^{2}=0$  
根据上述定义，显然成立方幂运算法则，即对于任意非负整数$ n$和$m$，有：
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
对于任意一个给定的半群或含幺半群$\langle G,*\rangle$，既然可以对其载体中的任意一个元素构造其任何次方幂，并且根据运算$*$在载体集合$ G$上的封闭性知，该元素所有方幂组成的集合必然是$G$的一个子集，那么自然就需要考察该子集以及运算$*$在该子集上的运算性质。下面的定理12.1 表明运算$*$可以在该子集上构成子半群或子含幺半群：  
【定理 12.1 】设 $\langle G,*\rangle$ 是任一给定的半群且对 $\forall a\in G$ ，令 $H=\{a^{n}|n\in Z^{+}\}$ ，则 $\langle H,*\rangle$ 是 $\langle G,*\rangle$的子半群。此时，若$\langle G,*\rangle$是含幺半群，则$\langle H,*\rangle$是$\langle G,*\rangle$的子含幺半群。  
如果$\langle G,*\rangle$是一个含幺半群，设$e$为其单位元。由于$e=a^{0}\in H$，故$e$也是$\langle H,*\rangle$的单位元。因此，$\langle H,*\rangle$也是一个含幺半群。  
从上述定理可知，对于任一给定的半群或含幺半群$\langle G,*\rangle$，载体集合$G$中任一给定元素$a$的所有方幂组成的集合$ H$可与运算$*$一起构成一种半群或含幺半群$\langle H,*\rangle$。事实上，$\langle H,*\rangle$是一种特殊的半群或含幺半群，其特殊性在于载体集合中$H$每个元素都是给定元素$a$的某个方幂。现在考察这种特殊半群或含幺半群的基本概念和性质，首先给出如下定义：  
【定义12.7】设$\langle G,*\rangle$是任一给定的半群，如果$\exists a\in G$，使得$G$中的任意元素$x$都能够写成元素$a$的方幂形式，即对于$\forall x\in G$，$\exists n\in N$,使得$x=a^{n}$，则称$\langle G,*\rangle$是一个循环半群，并称$a$是$\langle G,*\rangle$的一个生成元，$\langle G,*\rangle$的所有生成元组成的集合$C$称为$\langle G,*\rangle$的生成集。此时，如果$\langle G,*\rangle$还是一个含幺半群，则称$\langle G,*\rangle$是一个循环含幺半群。  
【定理 12.2】每个循环半群都是可交换半群。"
定理12.28,定理,"['第十二章 典型抽象代数结构', '§ 12.4 环和域的基本知识', '12.4.1  环的概念与性质']","{'实体类型': '定理', '内容': '对于任意环结构，有-(a×b)=a×(-b)=(-a)×b'}",,3,"我们知道，整数集合𝑍上具有加法$+$和乘法$\times$这两种运算，并且$\langle Z,+\rangle$是一个交换群、$\langle Z,\times\rangle$是一个半群，并且乘法对加法满足左、右分配律，即有：  
$$
a\times(b+c)=a\times b+a\times c;\ (b+c)\times a=b\times a+c a\times
$$  
由此可见，整数运算系统主要由两个运算子系统构成，即由一个基于加法运算的交换群和一个基于乘法运算的半群构成，并且乘法对加法满足分配律。  
将整数运算系统的上述性质进行抽象，就得到如果环代数结构的定义：  
【定义12.22】如果$\langle G,+,\times\rangle$是具有两个二元运算的代数系统，且满足：（1）$\langle G,+\rangle$是交换群；（2）$\langle G,\times\rangle$是半群；（3）$G$中的$\times$对$+$满足分配律。则称$\langle G,+,\times\rangle$是环代数结构或环代数系统，通常简称为环结构、环系统或环，并称$+$和$\times$分别为环中的加法和乘法。  
由上述定义可知，环结构由加法交换群和乘法半群这两个子结构组成，且满足乘法对加法的分配律。显然，代数系统$\langle Z,+,\times\rangle$就是一个环结构。  
此外，$\langle Q,+,\times\rangle,~\langle R,+,\times\rangle,~\langle C,+,\times\rangle$也都是环结构，其中$Q$是有理数集，$R$是实数集，$C$是复数集，分别称作整数环，有理数环，实数环和复数环。  
可根据构成环的群子结构或半群子结构的特点，对环结构做进一步的分类：  
【定义12.23】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果$\langle G,\times\rangle$是一个含幺半群，则称$\langle G,+,\times\rangle$是一个含幺环，如果$\langle G,\times\rangle$是一个交换半群，则称$\langle G,+,\times\rangle$是一个交换环，如果$\langle G,\times\rangle$是一个含幺交换半群，则称$\langle G,+,\times\rangle$是一个含幺交换环。  
为了叙述上的方便，通常将环中加法的单位元记作0，而将环中元素$x$关于加法的逆元称作$x$的负元，记作$-x$。如果环中乘法有单位元，就把这个单位元记作1，而将$ x$关于乘法的逆元（若存在的话）称为$x$的逆元，记作$:\!x^{-1}$。类似地，可用$x-y,$表示$ x+(-y)$，分别用$n x$和$x^{n}$表示$x$的加法和乘法$ n$次幂，即有：  
$$
n x=\underbrace{x+x+\cdots+x}_{n^{}个};\,\,\,x^{n}=\underbrace{x x\cdots x}_{n^{}个}
$$  
下面讨论环的基本性质。由环的定义可知，环中加法满足交换律、结合律，有单位元0  ，  
每个元素都有负元，环中乘法适合结合律，乘法对加法适合分配律。除此之外，我们进一步考察环的其它一些性质。首先考察环结构中加法逆元的性质：  
【定理12.28】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a,b\in G$，有：  
$$
-(a\times b)=a\times(-b)=(-a)\times b\quad\text{(12-20)}
$$  
下面考察环结构中加法单位元的性质：  
【定理12.29】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a\in G$，有：  
$$
a\times0=0\times a=0\quad\text{(12-21)}
$$  
上述定理12.29 表明，环结构中加法运算的单位元是乘法运算的零元，并且环中任二元素相乘，若其中至少有一个为零元，则乘积必为零元。但反之不然，因为在环中，两个非零元的乘积可能为零元，由此引出如下环结构中零因子的概念：  
【定义12.24】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果存在$G$中两个非零元素满足$a\cdot b=0$ ，称该环为含零因子环，元素 $a$ 和 $b$ 是其零因子，否则称该环为无零因子环。  
【定理12.30】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则$\langle G,+,\times\rangle$是无零因子环当且仅当于$\langle G,\times\rangle$满足消去律。  
由于环是由群和半群这两个子结构构成，故与群结构类似，环结构也存在子环、环同态的相关概念和理论。事实上，子环和环同态的概念和性质完全可以使用与群类似的思路进行讨论，这里不再赘述，读者可自行查阅环结构的相关资料深入学习。"
定理12.29,定理,"['第十二章 典型抽象代数结构', '§ 12.4 环和域的基本知识', '12.4.1  环的概念与性质']","{'实体类型': '定理', '内容': '对于任意环结构，有a×0=0×a=0'}",,3,"我们知道，整数集合𝑍上具有加法$+$和乘法$\times$这两种运算，并且$\langle Z,+\rangle$是一个交换群、$\langle Z,\times\rangle$是一个半群，并且乘法对加法满足左、右分配律，即有：  
$$
a\times(b+c)=a\times b+a\times c;\ (b+c)\times a=b\times a+c a\times
$$  
由此可见，整数运算系统主要由两个运算子系统构成，即由一个基于加法运算的交换群和一个基于乘法运算的半群构成，并且乘法对加法满足分配律。  
将整数运算系统的上述性质进行抽象，就得到如果环代数结构的定义：  
【定义12.22】如果$\langle G,+,\times\rangle$是具有两个二元运算的代数系统，且满足：（1）$\langle G,+\rangle$是交换群；（2）$\langle G,\times\rangle$是半群；（3）$G$中的$\times$对$+$满足分配律。则称$\langle G,+,\times\rangle$是环代数结构或环代数系统，通常简称为环结构、环系统或环，并称$+$和$\times$分别为环中的加法和乘法。  
由上述定义可知，环结构由加法交换群和乘法半群这两个子结构组成，且满足乘法对加法的分配律。显然，代数系统$\langle Z,+,\times\rangle$就是一个环结构。  
此外，$\langle Q,+,\times\rangle,~\langle R,+,\times\rangle,~\langle C,+,\times\rangle$也都是环结构，其中$Q$是有理数集，$R$是实数集，$C$是复数集，分别称作整数环，有理数环，实数环和复数环。  
可根据构成环的群子结构或半群子结构的特点，对环结构做进一步的分类：  
【定义12.23】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果$\langle G,\times\rangle$是一个含幺半群，则称$\langle G,+,\times\rangle$是一个含幺环，如果$\langle G,\times\rangle$是一个交换半群，则称$\langle G,+,\times\rangle$是一个交换环，如果$\langle G,\times\rangle$是一个含幺交换半群，则称$\langle G,+,\times\rangle$是一个含幺交换环。  
为了叙述上的方便，通常将环中加法的单位元记作0，而将环中元素$x$关于加法的逆元称作$x$的负元，记作$-x$。如果环中乘法有单位元，就把这个单位元记作1，而将$ x$关于乘法的逆元（若存在的话）称为$x$的逆元，记作$:\!x^{-1}$。类似地，可用$x-y,$表示$ x+(-y)$，分别用$n x$和$x^{n}$表示$x$的加法和乘法$ n$次幂，即有：  
$$
n x=\underbrace{x+x+\cdots+x}_{n^{}个};\,\,\,x^{n}=\underbrace{x x\cdots x}_{n^{}个}
$$  
下面讨论环的基本性质。由环的定义可知，环中加法满足交换律、结合律，有单位元0  ，  
每个元素都有负元，环中乘法适合结合律，乘法对加法适合分配律。除此之外，我们进一步考察环的其它一些性质。首先考察环结构中加法逆元的性质：  
【定理12.28】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a,b\in G$，有：  
$$
-(a\times b)=a\times(-b)=(-a)\times b\quad\text{(12-20)}
$$  
下面考察环结构中加法单位元的性质：  
【定理12.29】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a\in G$，有：  
$$
a\times0=0\times a=0\quad\text{(12-21)}
$$  
上述定理12.29 表明，环结构中加法运算的单位元是乘法运算的零元，并且环中任二元素相乘，若其中至少有一个为零元，则乘积必为零元。但反之不然，因为在环中，两个非零元的乘积可能为零元，由此引出如下环结构中零因子的概念：  
【定义12.24】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果存在$G$中两个非零元素满足$a\cdot b=0$ ，称该环为含零因子环，元素 $a$ 和 $b$ 是其零因子，否则称该环为无零因子环。  
【定理12.30】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则$\langle G,+,\times\rangle$是无零因子环当且仅当于$\langle G,\times\rangle$满足消去律。  
由于环是由群和半群这两个子结构构成，故与群结构类似，环结构也存在子环、环同态的相关概念和理论。事实上，子环和环同态的概念和性质完全可以使用与群类似的思路进行讨论，这里不再赘述，读者可自行查阅环结构的相关资料深入学习。"
定理12.3,定理,"['第十二章 典型抽象代数结构', '§ 12.2 群结构的基本知识', '12.2.1 群的基本概念']","{'实体类型': '定理', '内容': '设⟨G,*⟩是任意给定的一个群，则⟨G,*⟩的单位元是⟨G,*⟩中唯一的一个幂等元，若|G|>1，则⟨G,*⟩中无零元且满足消去律'}",,3,"如前所述，群代数结构是对幺半群结构在逆元方面的进一步扩充，其具体定义如下：  
【定义12.8】假设$\langle G,*\rangle$是任意给定的一个二元代数结构，如果$\langle G,*\rangle$满足如下性质：  
（1）结合律：对于$\forall x,y,z\in G$，成立：$(x\ \ *y)*z=x\ \ *(y*z)$；  
（2）含单位元：$\exists e\in G$，使得对于$\forall x\in G$，成立$\,\!e*x=x*e=x$；  
（3）运算$*$可逆：对于$\forall x\in G$，都存在$x^{-1}\in G$，使得$x^{-1}*x=x*x^{-1}=e$。  
则称$\langle G,*\rangle$是一个群代数结构，简称为群结构或群。  
从上述定义可知，对于任意给定的非空集合 $G$ 以及该集合上某个二元运算 $*$ ，$\langle G,*\rangle$ 能够 形成一个群结构的充分必要条件是$\langle G,*\rangle$必须满足封闭性、结合律、含幺性和可逆性这四个基本运算性质。例如，对于实数集合及其上的普通加法运算构成的代数结构$\langle R,+\rangle$，显然满足群的四条基本性质，其中0 是其单位元，对于$\forall x\in R$，$-x$是$x$的逆元。但是，对于实数集合及其上的普通乘法运算构成的代数结构$\langle R,\times\rangle$则不是一个群，因为在$\langle R,\times\rangle$中0 没有逆元素。不难发现，对于任意给定的集合$𝐴$，$\langle{ P}(A),\cup\rangle$和$\langle{ P}(A),\cap\rangle$都不能构成群结构，因为在$\langle{ P}(A),\cup\rangle$中$𝐴$没有逆元，在$\langle{P}(A),\cap\rangle$中$\varnothing$没有逆元。  
【定义12.9】设$\langle G,*\rangle$是任意给定的一个群，称$|G|$为$\langle G,*\rangle$的阶，如果$|G|$为有限数，则称  
$\langle G,*\rangle$为有限群，否则$\langle G,*\rangle$为无限群。如果运算$^*$满足交换律，即对于$\forall x,y\in G$，有$x*y=y*$$x$则称群$\langle G,*\rangle$是一个交换群或阿贝尔群。  
【定理12.3】设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$的单位元是$\langle G,*\rangle$中唯一的一个幂等元，若$|G|>1$，则$\langle G,*\rangle$中无零元且满足消去律。  
下面的定理12.2.2 给出了群中逆元素的基本性质：  
【定理12.4】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，有：  
$$
(a^{-1})^{-1}=a\,\exists(a*b)^{-1}=b^{-1}*a^{-1}
$$  
下面的定理12.5 给出了群与方程可解性之间的关系：  
【定理12.5】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，方程$a\circ x=b$和$y\circ a=$$b$在$\langle G,*\rangle$中有且仅有唯一解。  
由于群结构满足结合律，故可类似于半群和含幺半群定义元素的方幂：  
【定义12.10】设$\langle G,*\rangle$是任意给定的一个群，对于$\forall a\in G$和正整数$ n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$ a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个a}
$$  
定义$a^{0}=e$且$a^{-n}=(a^{-1})^{n}$  
从上述定义可以看出，对于一个群结构$\langle G,*\rangle$可以定义其任意整数的方幂运算，包括负指数方幂。因此，对于$G$中的任何一个元素$a$，均可以通过其正方幂、零方幂和负方幂构成一个向胜负两端无限延伸的序列，具体如下：  
$$
\cdots,a^{-n},\cdots,a^{-2},a^{-1},a^{0}\ \ ,a^{1},a^{2},\cdots,a^{n},\cdots
$$  
这些序列显然满足幂的运算法则，即对于任意整数$n$和$m$，有：  
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
如果$\langle G,*\rangle$是一个有限群$\langle G,*\rangle$，则根据运算的封闭性和鸽笼原理易知，在$G$中任意一个元素的无穷多个方幂中，必然至少有两个是相等的。具体地说，对于任意给定的$G$中某个元素$a$，必然存在两个不相等的整数$m$和$|n$，不妨设$m<n$，满足：  
$$
a^n=a^m\text{或}a^{n-m}=e
$$  
此时，可将正整数$n-m$看成是元素$a$方幂变化的一个周期。一般地，有如下定义：  
【定义12.11】设$\langle G,*\rangle$是任意给定的一个群，$e$是该群的单位元，对于$G$中任意给定的某个元素$a$，如果存在正整数$n$，满足$a^{n}=e$，则其中最小的正整数称为元素$a$的周期或阶，记为$|a|$，否则称元素$a$的周期为无限大或元素$a$的阶为无限大。  
例如，对于群$\langle\underline{{6}},+_{6}\rangle$，元素1 的阶为6，元素2 的阶为3，元素3 的阶为2，元素4 的阶为3，元素5 的阶为6，元素0 的阶为1。对于整数集合上的加法群$\langle Z,+\rangle$，显然，除了元素0 的周期为1 之外，其余任一非零元素的周期均为无穷大。事实上，不难看出，对于任何一个群，有且只有其单位元的阶为1。  
下面给出关于元素阶的两个重要性质：  
【定理12.6】有限群$\langle G,*\rangle$的每个元素都有有限阶，且其阶数不超过群的阶数|G|。  
【定理12.7】设$\langle G,*\rangle$为群，$G$中元素$a$的阶为$ k$，那么$a^{n}=e$当且仅当$k$整除$ n$  。"
定理12.30,定理,"['第十二章 典型抽象代数结构', '§ 12.4 环和域的基本知识', '12.4.1  环的概念与性质']","{'实体类型': '定理', '内容': '环是无零因子环当且仅当乘法满足消去律'}",,3,"我们知道，整数集合𝑍上具有加法$+$和乘法$\times$这两种运算，并且$\langle Z,+\rangle$是一个交换群、$\langle Z,\times\rangle$是一个半群，并且乘法对加法满足左、右分配律，即有：  
$$
a\times(b+c)=a\times b+a\times c;\ (b+c)\times a=b\times a+c a\times
$$  
由此可见，整数运算系统主要由两个运算子系统构成，即由一个基于加法运算的交换群和一个基于乘法运算的半群构成，并且乘法对加法满足分配律。  
将整数运算系统的上述性质进行抽象，就得到如果环代数结构的定义：  
【定义12.22】如果$\langle G,+,\times\rangle$是具有两个二元运算的代数系统，且满足：（1）$\langle G,+\rangle$是交换群；（2）$\langle G,\times\rangle$是半群；（3）$G$中的$\times$对$+$满足分配律。则称$\langle G,+,\times\rangle$是环代数结构或环代数系统，通常简称为环结构、环系统或环，并称$+$和$\times$分别为环中的加法和乘法。  
由上述定义可知，环结构由加法交换群和乘法半群这两个子结构组成，且满足乘法对加法的分配律。显然，代数系统$\langle Z,+,\times\rangle$就是一个环结构。  
此外，$\langle Q,+,\times\rangle,~\langle R,+,\times\rangle,~\langle C,+,\times\rangle$也都是环结构，其中$Q$是有理数集，$R$是实数集，$C$是复数集，分别称作整数环，有理数环，实数环和复数环。  
可根据构成环的群子结构或半群子结构的特点，对环结构做进一步的分类：  
【定义12.23】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果$\langle G,\times\rangle$是一个含幺半群，则称$\langle G,+,\times\rangle$是一个含幺环，如果$\langle G,\times\rangle$是一个交换半群，则称$\langle G,+,\times\rangle$是一个交换环，如果$\langle G,\times\rangle$是一个含幺交换半群，则称$\langle G,+,\times\rangle$是一个含幺交换环。  
为了叙述上的方便，通常将环中加法的单位元记作0，而将环中元素$x$关于加法的逆元称作$x$的负元，记作$-x$。如果环中乘法有单位元，就把这个单位元记作1，而将$ x$关于乘法的逆元（若存在的话）称为$x$的逆元，记作$:\!x^{-1}$。类似地，可用$x-y,$表示$ x+(-y)$，分别用$n x$和$x^{n}$表示$x$的加法和乘法$ n$次幂，即有：  
$$
n x=\underbrace{x+x+\cdots+x}_{n^{}个};\,\,\,x^{n}=\underbrace{x x\cdots x}_{n^{}个}
$$  
下面讨论环的基本性质。由环的定义可知，环中加法满足交换律、结合律，有单位元0  ，  
每个元素都有负元，环中乘法适合结合律，乘法对加法适合分配律。除此之外，我们进一步考察环的其它一些性质。首先考察环结构中加法逆元的性质：  
【定理12.28】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a,b\in G$，有：  
$$
-(a\times b)=a\times(-b)=(-a)\times b\quad\text{(12-20)}
$$  
下面考察环结构中加法单位元的性质：  
【定理12.29】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a\in G$，有：  
$$
a\times0=0\times a=0\quad\text{(12-21)}
$$  
上述定理12.29 表明，环结构中加法运算的单位元是乘法运算的零元，并且环中任二元素相乘，若其中至少有一个为零元，则乘积必为零元。但反之不然，因为在环中，两个非零元的乘积可能为零元，由此引出如下环结构中零因子的概念：  
【定义12.24】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果存在$G$中两个非零元素满足$a\cdot b=0$ ，称该环为含零因子环，元素 $a$ 和 $b$ 是其零因子，否则称该环为无零因子环。  
【定理12.30】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则$\langle G,+,\times\rangle$是无零因子环当且仅当于$\langle G,\times\rangle$满足消去律。  
由于环是由群和半群这两个子结构构成，故与群结构类似，环结构也存在子环、环同态的相关概念和理论。事实上，子环和环同态的概念和性质完全可以使用与群类似的思路进行讨论，这里不再赘述，读者可自行查阅环结构的相关资料深入学习。"
定理12.31,定理,"['第十二章 典型抽象代数结构', '§ 12.4 环和域的基本知识', '12.4.2  域的概念与性质']","{'实体类型': '定理', '结论': '设$\\langle G,+,\\times\\rangle$是任意给定的一个无零因子含幺交换环，且$1<|G|<n,n\\in N_{+}$则$\\langle G,+,\\times\\rangle$是域'}",,3,"从环结构的定义不难看出，构成环的两个子系统并不对等，其加法子系统是一个交换群，乘法子系统一个是半群，至多是可交换含幺半群。为何其乘法子系统不能定义成群呢？根本原因就是其乘法子系统中含有作为加法子系统单位元的零元，而零元在乘法运算下不可能有逆元，故不能直接将其乘法子系统定义为群。  
事实上，可以采用一种变通的方法定义乘法子系统的群结构，具体地说，就是在去除0元素的载体集合中定义乘法运算的群结构，由此得到如下关于域结构的定义：  
【定义12.25】如果$\langle G,+,\times\rangle$是具有两个二元运算的代数系统，且满足：（1）$\langle G,+\rangle$是交换群；（2）$\left\langle G-\{0\},\cdot\right\rangle$是交换群；（3）$G$中的$\times$对$^+$满足分配律。则称$\langle G,+,\times\rangle$是域代数结构或域代数系统，通常简称为域结构、域系统或域，并称$+$和$\times$分别为域中的加法和乘法。  
由域的定义可以看出，域结构其实是对环结构施加进一步的限制，即要求$\langle G-\{0\},\ \times\rangle$是一个可交换群。  
【定理12.31】设$\langle G,+,\times\rangle$是任意给定的一个无零因子含幺交换环，且$1<|G|<n,n\in N_{+}$则$\langle G,+,\times\rangle$是域。  
该定理表明元素大于1 的有限无零因子含幺交换环必定是域。  
由于域结构是由两个交换群子结构组成，故与群结构类似，域结构也存在子域、商域和域同态的相关概念和理论。事实上，子域、商域、域同态概念和性质完全可以使用与群类似的思路进行讨论，这里不再赘述，读者可自行查阅域结构的相关资料深入学习。"
定理12.39,定理,"['第十二章 典型抽象代数结构', '§ 12.6 布尔代数基础', '12.6.1 布尔代数与子代数']","{'实体类型': '定理', '内容': '设⟨B,*,⊕,^{-},0,1⟩是一个至少含有两个元素的代数系统，*和⊕是定义在B上的二元运算,^{-}是定义在B上的一元运算，对∀a,b,c∈B，如果满足交换律、分配律、同一律、互补律，则⟨B,*,⊕,^{-},0,1⟩是一个布尔代数'}",,3,"如前所述，有补分配格既保证了格中每个元素都存在其补元素，又保证了每个元素补元素的唯一性。显然，这其实是定义了格结构载体集合上的一元求补映射或运算。因此，有补分配格结构具有保交、保联和保补这三种运算。具体地说，有补分配格是一个包含两个二元运算$*$和⊕以及一个一元运$^{-}$所构成的特殊代数系统。这种特殊的代数系统其实就是布尔代数系统，具体定义如下，通常将用字母$B$表示布尔代数的载体集：  
【定义12.34】假设$\langle B,*,\oplus\rangle$是一个任意给定的有补分配格，则称其为布尔格或布尔代数，记为 $\langle B,*,\oplus,^{-},0,1\rangle$ 。 如果 $L$ 是有限集， 则称 $\langle B,*,\oplus,^{-},0,1\rangle$ 为有限布尔格或有限布尔代数； 如 果$L$是无限集，则称$\langle B,*,\oplus,^{-},0,1\rangle$为无限布尔格或无限布尔代数。  
显然，布尔代数的两个二元运算满足交换律、结合律、吸收律和幂等律等，然而这些定  
律并非独立的，例如幂等律可由吸收律得到。那么哪些运算律能够从本质上判定一个代数系统是否为布尔代数呢？下面的定理12.39 给出了具体答案，该定理结论也可看成是从运算性质的角度给出布尔代数系统的一个公理化定义：  
【定理12.39】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个至少含有两个元素的代数系统，$*$和⊕是定义在$𝐿$上的二元运算,$^{-}$ 是定义在$B$上的一元运算，对$\forall\ \ a,b,c\in B$，如果满足：  
（1）交换律：$a*b=b*a$，$a\oplus b=b\oplus a$  
（2）分配律：$a*(b\oplus c)=(a*b)\oplus(a*c);\,\,\,a\oplus(b*c)=(a\oplus b)*(a\oplus c)$  
（3）同一律：$a*1=a$，$a\oplus0={\mathsf{a}}$  
（4）互补律：${\bar{a}}*a=0$，${\bar{a}}\oplus a=1$  
则$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数。  
将代数系统中子代数的概念应用于布尔代数，可定义如下布尔子代数概念：  
【定义12.35】设$\langle B,*,\oplus,-,0,1\rangle $是任意给定的一个布尔代数，$S$是$B$的非空子集，若$𝑆$对运算${\ast,\oplus,^{-}}$ 都封闭且$0{,}1\in S$，则称$\langle S,*,\oplus,\stackrel{-}{\quad},0,1\rangle,$是$\langle B,*,\oplus,-,0,1\rangle $的子布尔代数。"
定理12.4,定理,"['第十二章 典型抽象代数结构', '§ 12.2 群结构的基本知识', '12.2.1 群的基本概念']","{'实体类型': '定理', '内容': '设⟨G,*⟩是任意给定的一个群，则对于∀a,b∈G，有：(a^{-1})^{-1}=a，(a*b)^{-1}=b^{-1}*a^{-1}'}",,3,"如前所述，群代数结构是对幺半群结构在逆元方面的进一步扩充，其具体定义如下：  
【定义12.8】假设$\langle G,*\rangle$是任意给定的一个二元代数结构，如果$\langle G,*\rangle$满足如下性质：  
（1）结合律：对于$\forall x,y,z\in G$，成立：$(x\ \ *y)*z=x\ \ *(y*z)$；  
（2）含单位元：$\exists e\in G$，使得对于$\forall x\in G$，成立$\,\!e*x=x*e=x$；  
（3）运算$*$可逆：对于$\forall x\in G$，都存在$x^{-1}\in G$，使得$x^{-1}*x=x*x^{-1}=e$。  
则称$\langle G,*\rangle$是一个群代数结构，简称为群结构或群。  
从上述定义可知，对于任意给定的非空集合 $G$ 以及该集合上某个二元运算 $*$ ，$\langle G,*\rangle$ 能够 形成一个群结构的充分必要条件是$\langle G,*\rangle$必须满足封闭性、结合律、含幺性和可逆性这四个基本运算性质。例如，对于实数集合及其上的普通加法运算构成的代数结构$\langle R,+\rangle$，显然满足群的四条基本性质，其中0 是其单位元，对于$\forall x\in R$，$-x$是$x$的逆元。但是，对于实数集合及其上的普通乘法运算构成的代数结构$\langle R,\times\rangle$则不是一个群，因为在$\langle R,\times\rangle$中0 没有逆元素。不难发现，对于任意给定的集合$𝐴$，$\langle{ P}(A),\cup\rangle$和$\langle{ P}(A),\cap\rangle$都不能构成群结构，因为在$\langle{ P}(A),\cup\rangle$中$𝐴$没有逆元，在$\langle{P}(A),\cap\rangle$中$\varnothing$没有逆元。  
【定义12.9】设$\langle G,*\rangle$是任意给定的一个群，称$|G|$为$\langle G,*\rangle$的阶，如果$|G|$为有限数，则称  
$\langle G,*\rangle$为有限群，否则$\langle G,*\rangle$为无限群。如果运算$^*$满足交换律，即对于$\forall x,y\in G$，有$x*y=y*$$x$则称群$\langle G,*\rangle$是一个交换群或阿贝尔群。  
【定理12.3】设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$的单位元是$\langle G,*\rangle$中唯一的一个幂等元，若$|G|>1$，则$\langle G,*\rangle$中无零元且满足消去律。  
下面的定理12.2.2 给出了群中逆元素的基本性质：  
【定理12.4】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，有：  
$$
(a^{-1})^{-1}=a\,\exists(a*b)^{-1}=b^{-1}*a^{-1}
$$  
下面的定理12.5 给出了群与方程可解性之间的关系：  
【定理12.5】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，方程$a\circ x=b$和$y\circ a=$$b$在$\langle G,*\rangle$中有且仅有唯一解。  
由于群结构满足结合律，故可类似于半群和含幺半群定义元素的方幂：  
【定义12.10】设$\langle G,*\rangle$是任意给定的一个群，对于$\forall a\in G$和正整数$ n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$ a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个a}
$$  
定义$a^{0}=e$且$a^{-n}=(a^{-1})^{n}$  
从上述定义可以看出，对于一个群结构$\langle G,*\rangle$可以定义其任意整数的方幂运算，包括负指数方幂。因此，对于$G$中的任何一个元素$a$，均可以通过其正方幂、零方幂和负方幂构成一个向胜负两端无限延伸的序列，具体如下：  
$$
\cdots,a^{-n},\cdots,a^{-2},a^{-1},a^{0}\ \ ,a^{1},a^{2},\cdots,a^{n},\cdots
$$  
这些序列显然满足幂的运算法则，即对于任意整数$n$和$m$，有：  
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
如果$\langle G,*\rangle$是一个有限群$\langle G,*\rangle$，则根据运算的封闭性和鸽笼原理易知，在$G$中任意一个元素的无穷多个方幂中，必然至少有两个是相等的。具体地说，对于任意给定的$G$中某个元素$a$，必然存在两个不相等的整数$m$和$|n$，不妨设$m<n$，满足：  
$$
a^n=a^m\text{或}a^{n-m}=e
$$  
此时，可将正整数$n-m$看成是元素$a$方幂变化的一个周期。一般地，有如下定义：  
【定义12.11】设$\langle G,*\rangle$是任意给定的一个群，$e$是该群的单位元，对于$G$中任意给定的某个元素$a$，如果存在正整数$n$，满足$a^{n}=e$，则其中最小的正整数称为元素$a$的周期或阶，记为$|a|$，否则称元素$a$的周期为无限大或元素$a$的阶为无限大。  
例如，对于群$\langle\underline{{6}},+_{6}\rangle$，元素1 的阶为6，元素2 的阶为3，元素3 的阶为2，元素4 的阶为3，元素5 的阶为6，元素0 的阶为1。对于整数集合上的加法群$\langle Z,+\rangle$，显然，除了元素0 的周期为1 之外，其余任一非零元素的周期均为无穷大。事实上，不难看出，对于任何一个群，有且只有其单位元的阶为1。  
下面给出关于元素阶的两个重要性质：  
【定理12.6】有限群$\langle G,*\rangle$的每个元素都有有限阶，且其阶数不超过群的阶数|G|。  
【定理12.7】设$\langle G,*\rangle$为群，$G$中元素$a$的阶为$ k$，那么$a^{n}=e$当且仅当$k$整除$ n$  。"
定理12.5,定理,"['第十二章 典型抽象代数结构', '§ 12.2 群结构的基本知识', '12.2.1 群的基本概念']","{'实体类型': '定理', '内容': '设⟨G,*⟩是任意给定的一个群，则对于∀a,b∈G，方程a∘x=b和y∘a=b在⟨G,*⟩中有且仅有唯一解'}",,3,"如前所述，群代数结构是对幺半群结构在逆元方面的进一步扩充，其具体定义如下：  
【定义12.8】假设$\langle G,*\rangle$是任意给定的一个二元代数结构，如果$\langle G,*\rangle$满足如下性质：  
（1）结合律：对于$\forall x,y,z\in G$，成立：$(x\ \ *y)*z=x\ \ *(y*z)$；  
（2）含单位元：$\exists e\in G$，使得对于$\forall x\in G$，成立$\,\!e*x=x*e=x$；  
（3）运算$*$可逆：对于$\forall x\in G$，都存在$x^{-1}\in G$，使得$x^{-1}*x=x*x^{-1}=e$。  
则称$\langle G,*\rangle$是一个群代数结构，简称为群结构或群。  
从上述定义可知，对于任意给定的非空集合 $G$ 以及该集合上某个二元运算 $*$ ，$\langle G,*\rangle$ 能够 形成一个群结构的充分必要条件是$\langle G,*\rangle$必须满足封闭性、结合律、含幺性和可逆性这四个基本运算性质。例如，对于实数集合及其上的普通加法运算构成的代数结构$\langle R,+\rangle$，显然满足群的四条基本性质，其中0 是其单位元，对于$\forall x\in R$，$-x$是$x$的逆元。但是，对于实数集合及其上的普通乘法运算构成的代数结构$\langle R,\times\rangle$则不是一个群，因为在$\langle R,\times\rangle$中0 没有逆元素。不难发现，对于任意给定的集合$𝐴$，$\langle{ P}(A),\cup\rangle$和$\langle{ P}(A),\cap\rangle$都不能构成群结构，因为在$\langle{ P}(A),\cup\rangle$中$𝐴$没有逆元，在$\langle{P}(A),\cap\rangle$中$\varnothing$没有逆元。  
【定义12.9】设$\langle G,*\rangle$是任意给定的一个群，称$|G|$为$\langle G,*\rangle$的阶，如果$|G|$为有限数，则称  
$\langle G,*\rangle$为有限群，否则$\langle G,*\rangle$为无限群。如果运算$^*$满足交换律，即对于$\forall x,y\in G$，有$x*y=y*$$x$则称群$\langle G,*\rangle$是一个交换群或阿贝尔群。  
【定理12.3】设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$的单位元是$\langle G,*\rangle$中唯一的一个幂等元，若$|G|>1$，则$\langle G,*\rangle$中无零元且满足消去律。  
下面的定理12.2.2 给出了群中逆元素的基本性质：  
【定理12.4】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，有：  
$$
(a^{-1})^{-1}=a\,\exists(a*b)^{-1}=b^{-1}*a^{-1}
$$  
下面的定理12.5 给出了群与方程可解性之间的关系：  
【定理12.5】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，方程$a\circ x=b$和$y\circ a=$$b$在$\langle G,*\rangle$中有且仅有唯一解。  
由于群结构满足结合律，故可类似于半群和含幺半群定义元素的方幂：  
【定义12.10】设$\langle G,*\rangle$是任意给定的一个群，对于$\forall a\in G$和正整数$ n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$ a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个a}
$$  
定义$a^{0}=e$且$a^{-n}=(a^{-1})^{n}$  
从上述定义可以看出，对于一个群结构$\langle G,*\rangle$可以定义其任意整数的方幂运算，包括负指数方幂。因此，对于$G$中的任何一个元素$a$，均可以通过其正方幂、零方幂和负方幂构成一个向胜负两端无限延伸的序列，具体如下：  
$$
\cdots,a^{-n},\cdots,a^{-2},a^{-1},a^{0}\ \ ,a^{1},a^{2},\cdots,a^{n},\cdots
$$  
这些序列显然满足幂的运算法则，即对于任意整数$n$和$m$，有：  
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
如果$\langle G,*\rangle$是一个有限群$\langle G,*\rangle$，则根据运算的封闭性和鸽笼原理易知，在$G$中任意一个元素的无穷多个方幂中，必然至少有两个是相等的。具体地说，对于任意给定的$G$中某个元素$a$，必然存在两个不相等的整数$m$和$|n$，不妨设$m<n$，满足：  
$$
a^n=a^m\text{或}a^{n-m}=e
$$  
此时，可将正整数$n-m$看成是元素$a$方幂变化的一个周期。一般地，有如下定义：  
【定义12.11】设$\langle G,*\rangle$是任意给定的一个群，$e$是该群的单位元，对于$G$中任意给定的某个元素$a$，如果存在正整数$n$，满足$a^{n}=e$，则其中最小的正整数称为元素$a$的周期或阶，记为$|a|$，否则称元素$a$的周期为无限大或元素$a$的阶为无限大。  
例如，对于群$\langle\underline{{6}},+_{6}\rangle$，元素1 的阶为6，元素2 的阶为3，元素3 的阶为2，元素4 的阶为3，元素5 的阶为6，元素0 的阶为1。对于整数集合上的加法群$\langle Z,+\rangle$，显然，除了元素0 的周期为1 之外，其余任一非零元素的周期均为无穷大。事实上，不难看出，对于任何一个群，有且只有其单位元的阶为1。  
下面给出关于元素阶的两个重要性质：  
【定理12.6】有限群$\langle G,*\rangle$的每个元素都有有限阶，且其阶数不超过群的阶数|G|。  
【定理12.7】设$\langle G,*\rangle$为群，$G$中元素$a$的阶为$ k$，那么$a^{n}=e$当且仅当$k$整除$ n$  。"
定理12.6,定理,"['第十二章 典型抽象代数结构', '§ 12.2 群结构的基本知识', '12.2.1 群的基本概念']","{'实体类型': '定理', '内容': '有限群⟨G,*⟩的每个元素都有有限阶，且其阶数不超过群的阶数|G|'}",,3,"如前所述，群代数结构是对幺半群结构在逆元方面的进一步扩充，其具体定义如下：  
【定义12.8】假设$\langle G,*\rangle$是任意给定的一个二元代数结构，如果$\langle G,*\rangle$满足如下性质：  
（1）结合律：对于$\forall x,y,z\in G$，成立：$(x\ \ *y)*z=x\ \ *(y*z)$；  
（2）含单位元：$\exists e\in G$，使得对于$\forall x\in G$，成立$\,\!e*x=x*e=x$；  
（3）运算$*$可逆：对于$\forall x\in G$，都存在$x^{-1}\in G$，使得$x^{-1}*x=x*x^{-1}=e$。  
则称$\langle G,*\rangle$是一个群代数结构，简称为群结构或群。  
从上述定义可知，对于任意给定的非空集合 $G$ 以及该集合上某个二元运算 $*$ ，$\langle G,*\rangle$ 能够 形成一个群结构的充分必要条件是$\langle G,*\rangle$必须满足封闭性、结合律、含幺性和可逆性这四个基本运算性质。例如，对于实数集合及其上的普通加法运算构成的代数结构$\langle R,+\rangle$，显然满足群的四条基本性质，其中0 是其单位元，对于$\forall x\in R$，$-x$是$x$的逆元。但是，对于实数集合及其上的普通乘法运算构成的代数结构$\langle R,\times\rangle$则不是一个群，因为在$\langle R,\times\rangle$中0 没有逆元素。不难发现，对于任意给定的集合$𝐴$，$\langle{ P}(A),\cup\rangle$和$\langle{ P}(A),\cap\rangle$都不能构成群结构，因为在$\langle{ P}(A),\cup\rangle$中$𝐴$没有逆元，在$\langle{P}(A),\cap\rangle$中$\varnothing$没有逆元。  
【定义12.9】设$\langle G,*\rangle$是任意给定的一个群，称$|G|$为$\langle G,*\rangle$的阶，如果$|G|$为有限数，则称  
$\langle G,*\rangle$为有限群，否则$\langle G,*\rangle$为无限群。如果运算$^*$满足交换律，即对于$\forall x,y\in G$，有$x*y=y*$$x$则称群$\langle G,*\rangle$是一个交换群或阿贝尔群。  
【定理12.3】设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$的单位元是$\langle G,*\rangle$中唯一的一个幂等元，若$|G|>1$，则$\langle G,*\rangle$中无零元且满足消去律。  
下面的定理12.2.2 给出了群中逆元素的基本性质：  
【定理12.4】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，有：  
$$
(a^{-1})^{-1}=a\,\exists(a*b)^{-1}=b^{-1}*a^{-1}
$$  
下面的定理12.5 给出了群与方程可解性之间的关系：  
【定理12.5】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，方程$a\circ x=b$和$y\circ a=$$b$在$\langle G,*\rangle$中有且仅有唯一解。  
由于群结构满足结合律，故可类似于半群和含幺半群定义元素的方幂：  
【定义12.10】设$\langle G,*\rangle$是任意给定的一个群，对于$\forall a\in G$和正整数$ n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$ a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个a}
$$  
定义$a^{0}=e$且$a^{-n}=(a^{-1})^{n}$  
从上述定义可以看出，对于一个群结构$\langle G,*\rangle$可以定义其任意整数的方幂运算，包括负指数方幂。因此，对于$G$中的任何一个元素$a$，均可以通过其正方幂、零方幂和负方幂构成一个向胜负两端无限延伸的序列，具体如下：  
$$
\cdots,a^{-n},\cdots,a^{-2},a^{-1},a^{0}\ \ ,a^{1},a^{2},\cdots,a^{n},\cdots
$$  
这些序列显然满足幂的运算法则，即对于任意整数$n$和$m$，有：  
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
如果$\langle G,*\rangle$是一个有限群$\langle G,*\rangle$，则根据运算的封闭性和鸽笼原理易知，在$G$中任意一个元素的无穷多个方幂中，必然至少有两个是相等的。具体地说，对于任意给定的$G$中某个元素$a$，必然存在两个不相等的整数$m$和$|n$，不妨设$m<n$，满足：  
$$
a^n=a^m\text{或}a^{n-m}=e
$$  
此时，可将正整数$n-m$看成是元素$a$方幂变化的一个周期。一般地，有如下定义：  
【定义12.11】设$\langle G,*\rangle$是任意给定的一个群，$e$是该群的单位元，对于$G$中任意给定的某个元素$a$，如果存在正整数$n$，满足$a^{n}=e$，则其中最小的正整数称为元素$a$的周期或阶，记为$|a|$，否则称元素$a$的周期为无限大或元素$a$的阶为无限大。  
例如，对于群$\langle\underline{{6}},+_{6}\rangle$，元素1 的阶为6，元素2 的阶为3，元素3 的阶为2，元素4 的阶为3，元素5 的阶为6，元素0 的阶为1。对于整数集合上的加法群$\langle Z,+\rangle$，显然，除了元素0 的周期为1 之外，其余任一非零元素的周期均为无穷大。事实上，不难看出，对于任何一个群，有且只有其单位元的阶为1。  
下面给出关于元素阶的两个重要性质：  
【定理12.6】有限群$\langle G,*\rangle$的每个元素都有有限阶，且其阶数不超过群的阶数|G|。  
【定理12.7】设$\langle G,*\rangle$为群，$G$中元素$a$的阶为$ k$，那么$a^{n}=e$当且仅当$k$整除$ n$  。"
定理12.7,定理,"['第十二章 典型抽象代数结构', '§ 12.2 群结构的基本知识', '12.2.1 群的基本概念']","{'实体类型': '定理', '内容': '设⟨G,*⟩为群，G中元素a的阶为k，那么a^n=e当且仅当k整除n'}",,3,"如前所述，群代数结构是对幺半群结构在逆元方面的进一步扩充，其具体定义如下：  
【定义12.8】假设$\langle G,*\rangle$是任意给定的一个二元代数结构，如果$\langle G,*\rangle$满足如下性质：  
（1）结合律：对于$\forall x,y,z\in G$，成立：$(x\ \ *y)*z=x\ \ *(y*z)$；  
（2）含单位元：$\exists e\in G$，使得对于$\forall x\in G$，成立$\,\!e*x=x*e=x$；  
（3）运算$*$可逆：对于$\forall x\in G$，都存在$x^{-1}\in G$，使得$x^{-1}*x=x*x^{-1}=e$。  
则称$\langle G,*\rangle$是一个群代数结构，简称为群结构或群。  
从上述定义可知，对于任意给定的非空集合 $G$ 以及该集合上某个二元运算 $*$ ，$\langle G,*\rangle$ 能够 形成一个群结构的充分必要条件是$\langle G,*\rangle$必须满足封闭性、结合律、含幺性和可逆性这四个基本运算性质。例如，对于实数集合及其上的普通加法运算构成的代数结构$\langle R,+\rangle$，显然满足群的四条基本性质，其中0 是其单位元，对于$\forall x\in R$，$-x$是$x$的逆元。但是，对于实数集合及其上的普通乘法运算构成的代数结构$\langle R,\times\rangle$则不是一个群，因为在$\langle R,\times\rangle$中0 没有逆元素。不难发现，对于任意给定的集合$𝐴$，$\langle{ P}(A),\cup\rangle$和$\langle{ P}(A),\cap\rangle$都不能构成群结构，因为在$\langle{ P}(A),\cup\rangle$中$𝐴$没有逆元，在$\langle{P}(A),\cap\rangle$中$\varnothing$没有逆元。  
【定义12.9】设$\langle G,*\rangle$是任意给定的一个群，称$|G|$为$\langle G,*\rangle$的阶，如果$|G|$为有限数，则称  
$\langle G,*\rangle$为有限群，否则$\langle G,*\rangle$为无限群。如果运算$^*$满足交换律，即对于$\forall x,y\in G$，有$x*y=y*$$x$则称群$\langle G,*\rangle$是一个交换群或阿贝尔群。  
【定理12.3】设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$的单位元是$\langle G,*\rangle$中唯一的一个幂等元，若$|G|>1$，则$\langle G,*\rangle$中无零元且满足消去律。  
下面的定理12.2.2 给出了群中逆元素的基本性质：  
【定理12.4】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，有：  
$$
(a^{-1})^{-1}=a\,\exists(a*b)^{-1}=b^{-1}*a^{-1}
$$  
下面的定理12.5 给出了群与方程可解性之间的关系：  
【定理12.5】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，方程$a\circ x=b$和$y\circ a=$$b$在$\langle G,*\rangle$中有且仅有唯一解。  
由于群结构满足结合律，故可类似于半群和含幺半群定义元素的方幂：  
【定义12.10】设$\langle G,*\rangle$是任意给定的一个群，对于$\forall a\in G$和正整数$ n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$ a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个a}
$$  
定义$a^{0}=e$且$a^{-n}=(a^{-1})^{n}$  
从上述定义可以看出，对于一个群结构$\langle G,*\rangle$可以定义其任意整数的方幂运算，包括负指数方幂。因此，对于$G$中的任何一个元素$a$，均可以通过其正方幂、零方幂和负方幂构成一个向胜负两端无限延伸的序列，具体如下：  
$$
\cdots,a^{-n},\cdots,a^{-2},a^{-1},a^{0}\ \ ,a^{1},a^{2},\cdots,a^{n},\cdots
$$  
这些序列显然满足幂的运算法则，即对于任意整数$n$和$m$，有：  
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
如果$\langle G,*\rangle$是一个有限群$\langle G,*\rangle$，则根据运算的封闭性和鸽笼原理易知，在$G$中任意一个元素的无穷多个方幂中，必然至少有两个是相等的。具体地说，对于任意给定的$G$中某个元素$a$，必然存在两个不相等的整数$m$和$|n$，不妨设$m<n$，满足：  
$$
a^n=a^m\text{或}a^{n-m}=e
$$  
此时，可将正整数$n-m$看成是元素$a$方幂变化的一个周期。一般地，有如下定义：  
【定义12.11】设$\langle G,*\rangle$是任意给定的一个群，$e$是该群的单位元，对于$G$中任意给定的某个元素$a$，如果存在正整数$n$，满足$a^{n}=e$，则其中最小的正整数称为元素$a$的周期或阶，记为$|a|$，否则称元素$a$的周期为无限大或元素$a$的阶为无限大。  
例如，对于群$\langle\underline{{6}},+_{6}\rangle$，元素1 的阶为6，元素2 的阶为3，元素3 的阶为2，元素4 的阶为3，元素5 的阶为6，元素0 的阶为1。对于整数集合上的加法群$\langle Z,+\rangle$，显然，除了元素0 的周期为1 之外，其余任一非零元素的周期均为无穷大。事实上，不难看出，对于任何一个群，有且只有其单位元的阶为1。  
下面给出关于元素阶的两个重要性质：  
【定理12.6】有限群$\langle G,*\rangle$的每个元素都有有限阶，且其阶数不超过群的阶数|G|。  
【定理12.7】设$\langle G,*\rangle$为群，$G$中元素$a$的阶为$ k$，那么$a^{n}=e$当且仅当$k$整除$ n$  。"
定理2.10,定理,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.2 整数的因数分解', '二、互素的概念与性质']","{'实体类型': '定理', '结论': ['若b|ac且gcd(a,b)=1，则有b|c', '若b|c且a|c，则有ab|c']}",,4,"从整除的角度看，两个整数的公因数表达的是这两个整数共性成分。如果两个整数的最大公因数为1，则表明这两个整数除1 之外没有任何额外的共性成分。因此，从结构上看，这两个整数之间具有很强的独立性。这种很强的独立性我们称之为互素。互素是整数理论中一个非常重要的基本概念，整数的很多性质都与互素的概念有关，其具体定义如下：  
【定义2.7】假设$a_{1},a_{2},\cdots,a_{k}$是$k$个不全为零的整数，如果有$\operatorname*{gcd}(a_{1},a_{2},\cdots,a_{k})=1$，则称这$k$ 个整数$a_{1},a_{2},\cdots,a_{k}$为互素；如果$a_{1},a_{2},\cdots,a_{k}$中任意两个整数的最大公因数均为1，则称这$k$ 个整数$a_{1},a_{2},\cdots,a_{k}$为两两互素。  
$a_{1},a_{2},\cdots,a_{k}$互素与$a_{1},a_{2},\cdots,a_{k}$两两互素是两个不同的概念，在实际使用过程中应注意加以区分，避免混淆。显然，由$a_{1},a_{2},\cdots,a_{k}$两两互素可以推出$a_{1},a_{2},\cdots,a_{k}$互素，反之不然。例如，$\operatorname*{gcd}(3,6,9,10)=1$，此时这4 个整数仅仅为互素的关系，因为其中的3, 6, 9的最大公因数并不为1，所以不符合两两互素。  
【定理2.8】设$a$，$b$ 是任意两个整数，若$\operatorname*{gcd}(a,b)=a s+b t$，则$s$ 与$t$是互素的。  
【定理2.9】如果整数$a$ 与整数$b_{1},b_{2},\cdots,b_{n}$中的每一个都互质，那么$a$ 与乘积$b_{1}b_{2}\cdots b_{n}$也互质。  
【定理2.10】对于任意的整数$a$，$b$，$c$，下面结论成立：  
（1）若$b|a c$且$\operatorname*{gcd}(a,b)=1$，则有$b|c$；  
（2）若$b|c$且$a|c$，则有$a b|c$。  
【定理 2.11 】若 $\operatorname*{gcd}(a,b)=1$ ，则 $\operatorname*{gcd}(a,b k)=\operatorname*{gcd}(a,k)\,.$"
定理2.11,定理,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.2 整数的因数分解', '二、互素的概念与性质']","{'实体类型': '定理', '条件': '若gcd(a,b)=1', '结论': '则gcd(a,bk)=gcd(a,k)'}",,4,"从整除的角度看，两个整数的公因数表达的是这两个整数共性成分。如果两个整数的最大公因数为1，则表明这两个整数除1 之外没有任何额外的共性成分。因此，从结构上看，这两个整数之间具有很强的独立性。这种很强的独立性我们称之为互素。互素是整数理论中一个非常重要的基本概念，整数的很多性质都与互素的概念有关，其具体定义如下：  
【定义2.7】假设$a_{1},a_{2},\cdots,a_{k}$是$k$个不全为零的整数，如果有$\operatorname*{gcd}(a_{1},a_{2},\cdots,a_{k})=1$，则称这$k$ 个整数$a_{1},a_{2},\cdots,a_{k}$为互素；如果$a_{1},a_{2},\cdots,a_{k}$中任意两个整数的最大公因数均为1，则称这$k$ 个整数$a_{1},a_{2},\cdots,a_{k}$为两两互素。  
$a_{1},a_{2},\cdots,a_{k}$互素与$a_{1},a_{2},\cdots,a_{k}$两两互素是两个不同的概念，在实际使用过程中应注意加以区分，避免混淆。显然，由$a_{1},a_{2},\cdots,a_{k}$两两互素可以推出$a_{1},a_{2},\cdots,a_{k}$互素，反之不然。例如，$\operatorname*{gcd}(3,6,9,10)=1$，此时这4 个整数仅仅为互素的关系，因为其中的3, 6, 9的最大公因数并不为1，所以不符合两两互素。  
【定理2.8】设$a$，$b$ 是任意两个整数，若$\operatorname*{gcd}(a,b)=a s+b t$，则$s$ 与$t$是互素的。  
【定理2.9】如果整数$a$ 与整数$b_{1},b_{2},\cdots,b_{n}$中的每一个都互质，那么$a$ 与乘积$b_{1}b_{2}\cdots b_{n}$也互质。  
【定理2.10】对于任意的整数$a$，$b$，$c$，下面结论成立：  
（1）若$b|a c$且$\operatorname*{gcd}(a,b)=1$，则有$b|c$；  
（2）若$b|c$且$a|c$，则有$a b|c$。  
【定理 2.11 】若 $\operatorname*{gcd}(a,b)=1$ ，则 $\operatorname*{gcd}(a,b k)=\operatorname*{gcd}(a,k)\,.$"
定理2.15,定理,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.3 素数的性质与查找']","{'实体类型': '定理', '内容': '假设p是任意一个给定的素数，则它与其它任意整数a之间的关系是：要么p与a互素，要么p能够整除a'}",,3,"通过算术基本定理可以看出，素数是构成所有整数的基本要素，在整个整数理论中占据非常重要的基础性地位。现在我们就来学习有关素数的基本知识，讨论素数的若干基本性质、素数的分布以及相关的查找方法。  
素数的一个非常独特性质是它与其它整数之间具有如下非常简单而直接的关系，这种简单直接的关系是使用素数考察整数性质的基础。  
【定理2.15】假设$p$ 是任意一个给定的素数，则它与其它任意整数$a$ 之间的关系是：要么$p$ 与$a$ 互素，要么$p$ 能够整除$a$。  
可以通过上述定理证明下面结论：  
【定理2.16】假设$p$ 是任意一个给定的素数，$a$ 和$b$ 是任意两个整数，如果$p$ 能整除$a$与$b$ 的乘积，则$p$ 至少能整除$a$ 与$b$ 中的一个。更一般地，假设$a_{1},a_{2},\cdots,a_{k}$是任意给出的$k$个整数，如果素数$p$ 能够整除$a_{1},a_{2},\cdots,a_{k}$，则$p$ 至少能够整除$a_{1},a_{2},\cdots,a_{k}$中的一个。  
下面讨论素数的计数问题。首先考虑在整个正整数集合中，到底有多少个素数？下面的定理给出了答案：  
【定理2.17】正整数集合中的素数有无穷多个。  
下面进一步讨论有限正整数集合中素数的计数与分布情况：  
【定理2.18】设$a$是任意大于1 的整数，则$a$除1 外的最小正因数$q$一定是素数，并且，当$a$是合数时，$q\leq{\sqrt{a}}$，亦即：若$a$ 是合数，则$a$ 必有一个小于等于$\sqrt{a}$的素因子。  
使用上述定理，可以获得一种名为爱氏筛法的素数查找方法。对于任意给定的一个正整数$N$，可以使用该方法找到所有不超过$N$的素数，具体做法如下：  
首先把所有不超过$N$的正整数按从小到大的次序排成一个队列，然后在队列中划去1以及划去一切不超过$\sqrt{N}$的素数的所有倍数，剩下的数即为所求的素数。  
由于有无穷多个素数，因此人们总是希望能够找到尽可能大的素数。300 年来人们找到的最大素数都是$2^{p}-1$这种形式的整数，其中$p$ 也是素数。我们将具有这种形式的素数称为梅森素数，目前有一个名为互联网梅森素数大搜索组织专门搜索大素数，有兴趣的读者可以查阅有关资料了解大素数查找的进展情况。"
定理2.16,定理,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.3 素数的性质与查找']","{'实体类型': '定理', '内容': '假设p是任意一个给定的素数，a和b是任意两个整数，如果p能整除a与b的乘积，则p至少能整除a与b中的一个'}",,3,"通过算术基本定理可以看出，素数是构成所有整数的基本要素，在整个整数理论中占据非常重要的基础性地位。现在我们就来学习有关素数的基本知识，讨论素数的若干基本性质、素数的分布以及相关的查找方法。  
素数的一个非常独特性质是它与其它整数之间具有如下非常简单而直接的关系，这种简单直接的关系是使用素数考察整数性质的基础。  
【定理2.15】假设$p$ 是任意一个给定的素数，则它与其它任意整数$a$ 之间的关系是：要么$p$ 与$a$ 互素，要么$p$ 能够整除$a$。  
可以通过上述定理证明下面结论：  
【定理2.16】假设$p$ 是任意一个给定的素数，$a$ 和$b$ 是任意两个整数，如果$p$ 能整除$a$与$b$ 的乘积，则$p$ 至少能整除$a$ 与$b$ 中的一个。更一般地，假设$a_{1},a_{2},\cdots,a_{k}$是任意给出的$k$个整数，如果素数$p$ 能够整除$a_{1},a_{2},\cdots,a_{k}$，则$p$ 至少能够整除$a_{1},a_{2},\cdots,a_{k}$中的一个。  
下面讨论素数的计数问题。首先考虑在整个正整数集合中，到底有多少个素数？下面的定理给出了答案：  
【定理2.17】正整数集合中的素数有无穷多个。  
下面进一步讨论有限正整数集合中素数的计数与分布情况：  
【定理2.18】设$a$是任意大于1 的整数，则$a$除1 外的最小正因数$q$一定是素数，并且，当$a$是合数时，$q\leq{\sqrt{a}}$，亦即：若$a$ 是合数，则$a$ 必有一个小于等于$\sqrt{a}$的素因子。  
使用上述定理，可以获得一种名为爱氏筛法的素数查找方法。对于任意给定的一个正整数$N$，可以使用该方法找到所有不超过$N$的素数，具体做法如下：  
首先把所有不超过$N$的正整数按从小到大的次序排成一个队列，然后在队列中划去1以及划去一切不超过$\sqrt{N}$的素数的所有倍数，剩下的数即为所求的素数。  
由于有无穷多个素数，因此人们总是希望能够找到尽可能大的素数。300 年来人们找到的最大素数都是$2^{p}-1$这种形式的整数，其中$p$ 也是素数。我们将具有这种形式的素数称为梅森素数，目前有一个名为互联网梅森素数大搜索组织专门搜索大素数，有兴趣的读者可以查阅有关资料了解大素数查找的进展情况。"
定理2.17,定理,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.3 素数的性质与查找']","{'实体类型': '定理', '内容': '正整数集合中的素数有无穷多个'}",,3,"通过算术基本定理可以看出，素数是构成所有整数的基本要素，在整个整数理论中占据非常重要的基础性地位。现在我们就来学习有关素数的基本知识，讨论素数的若干基本性质、素数的分布以及相关的查找方法。  
素数的一个非常独特性质是它与其它整数之间具有如下非常简单而直接的关系，这种简单直接的关系是使用素数考察整数性质的基础。  
【定理2.15】假设$p$ 是任意一个给定的素数，则它与其它任意整数$a$ 之间的关系是：要么$p$ 与$a$ 互素，要么$p$ 能够整除$a$。  
可以通过上述定理证明下面结论：  
【定理2.16】假设$p$ 是任意一个给定的素数，$a$ 和$b$ 是任意两个整数，如果$p$ 能整除$a$与$b$ 的乘积，则$p$ 至少能整除$a$ 与$b$ 中的一个。更一般地，假设$a_{1},a_{2},\cdots,a_{k}$是任意给出的$k$个整数，如果素数$p$ 能够整除$a_{1},a_{2},\cdots,a_{k}$，则$p$ 至少能够整除$a_{1},a_{2},\cdots,a_{k}$中的一个。  
下面讨论素数的计数问题。首先考虑在整个正整数集合中，到底有多少个素数？下面的定理给出了答案：  
【定理2.17】正整数集合中的素数有无穷多个。  
下面进一步讨论有限正整数集合中素数的计数与分布情况：  
【定理2.18】设$a$是任意大于1 的整数，则$a$除1 外的最小正因数$q$一定是素数，并且，当$a$是合数时，$q\leq{\sqrt{a}}$，亦即：若$a$ 是合数，则$a$ 必有一个小于等于$\sqrt{a}$的素因子。  
使用上述定理，可以获得一种名为爱氏筛法的素数查找方法。对于任意给定的一个正整数$N$，可以使用该方法找到所有不超过$N$的素数，具体做法如下：  
首先把所有不超过$N$的正整数按从小到大的次序排成一个队列，然后在队列中划去1以及划去一切不超过$\sqrt{N}$的素数的所有倍数，剩下的数即为所求的素数。  
由于有无穷多个素数，因此人们总是希望能够找到尽可能大的素数。300 年来人们找到的最大素数都是$2^{p}-1$这种形式的整数，其中$p$ 也是素数。我们将具有这种形式的素数称为梅森素数，目前有一个名为互联网梅森素数大搜索组织专门搜索大素数，有兴趣的读者可以查阅有关资料了解大素数查找的进展情况。"
定理2.18,定理,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.3 素数的性质与查找']","{'实体类型': '定理', '内容': '设a是任意大于1的整数，则a除1外的最小正因数q一定是素数，并且，当a是合数时，q≤√a'}",,3,"通过算术基本定理可以看出，素数是构成所有整数的基本要素，在整个整数理论中占据非常重要的基础性地位。现在我们就来学习有关素数的基本知识，讨论素数的若干基本性质、素数的分布以及相关的查找方法。  
素数的一个非常独特性质是它与其它整数之间具有如下非常简单而直接的关系，这种简单直接的关系是使用素数考察整数性质的基础。  
【定理2.15】假设$p$ 是任意一个给定的素数，则它与其它任意整数$a$ 之间的关系是：要么$p$ 与$a$ 互素，要么$p$ 能够整除$a$。  
可以通过上述定理证明下面结论：  
【定理2.16】假设$p$ 是任意一个给定的素数，$a$ 和$b$ 是任意两个整数，如果$p$ 能整除$a$与$b$ 的乘积，则$p$ 至少能整除$a$ 与$b$ 中的一个。更一般地，假设$a_{1},a_{2},\cdots,a_{k}$是任意给出的$k$个整数，如果素数$p$ 能够整除$a_{1},a_{2},\cdots,a_{k}$，则$p$ 至少能够整除$a_{1},a_{2},\cdots,a_{k}$中的一个。  
下面讨论素数的计数问题。首先考虑在整个正整数集合中，到底有多少个素数？下面的定理给出了答案：  
【定理2.17】正整数集合中的素数有无穷多个。  
下面进一步讨论有限正整数集合中素数的计数与分布情况：  
【定理2.18】设$a$是任意大于1 的整数，则$a$除1 外的最小正因数$q$一定是素数，并且，当$a$是合数时，$q\leq{\sqrt{a}}$，亦即：若$a$ 是合数，则$a$ 必有一个小于等于$\sqrt{a}$的素因子。  
使用上述定理，可以获得一种名为爱氏筛法的素数查找方法。对于任意给定的一个正整数$N$，可以使用该方法找到所有不超过$N$的素数，具体做法如下：  
首先把所有不超过$N$的正整数按从小到大的次序排成一个队列，然后在队列中划去1以及划去一切不超过$\sqrt{N}$的素数的所有倍数，剩下的数即为所求的素数。  
由于有无穷多个素数，因此人们总是希望能够找到尽可能大的素数。300 年来人们找到的最大素数都是$2^{p}-1$这种形式的整数，其中$p$ 也是素数。我们将具有这种形式的素数称为梅森素数，目前有一个名为互联网梅森素数大搜索组织专门搜索大素数，有兴趣的读者可以查阅有关资料了解大素数查找的进展情况。"
定理2.3,定理,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.2 整数的因数分解', '一、公因数与公倍数']","{'实体类型': '定理', '内容': '假设a和b是任意给定的两个整数，则有a·b=(a,b)·[a,b]'}",,4,"假设$a$ 和$b$ 是任意给定的两个整数，如果$b$ 能够整除$a$，那么$b$ 就是$a$的一个因数、$a$就是$b$ 的一个倍数，此时可分别从因数和倍数这两个角度对整数进行考察。  
具体地说，如果$b$ 也是另外一个整数$c$ 的因数，则$b$ 就反映出$a$ 和$c$ 的某种共同特征，或者说整数$a$ 和$c$ 具有一个相同的构件$b$，通常将其称为$a$ 与$c$的公因数。同样，如果整数$a$ 也是另外一个整数$s$ 的倍数，则$b$ 和$s$ 就有一个共同的倍数$a$，通常称之为公倍数。公因数和公倍数分别从两个不同角度考察任意两个整数之间的联系，具体定义如下：  
【定义2.3】假设$i$ 和$j$是任意两个整数，如果整数$b$ 能够同时整除$i$和$j$，则称$b$ 是$i$和$j$ 的一个公因数，如果$i$ 和$j$都能够整除整数$a$，则称$a$ 是$i$ 和$j$的一个公倍数。  
自然数1 可以整除任意整数，因此对于任意两个整数，它们的公因数总是存在的。公因数表达的是两个整数的共同部分，通常需要考察两个整数之间的共同部分最大值能达到多少，故有所谓最大公因数的概念。同样，对于任意两个整数，这两个整数的乘积就是它们的公倍数，因此，公倍数总是存在的，需要着重考察的通常式公倍数的最小值，因而有最小公倍数的概念。最大公因数和最小公倍数的具体定义如下：  
【定义2.4】假设$a$ 和$b$ 是任意给定的两个整数，$a$ 和$b$ 的所有公因数中最大的那个整数称为$a$ 和$b$ 的最大公因数，记为$\operatorname*{gcd}(a,b)$或$(a,b)$，$a$ 和$b$ 的所有公倍数中最小的那个整数称为$a$ 和$b$ 的最小公倍数，记为$\operatorname{lcm}(a,b)$或$[a,b]$。  
例如： $\operatorname*{gcd}(5,7)=1$$\operatorname*{gcd}(15,21)=3;\;\;\operatorname*{gcd}(132,240)=12;$； $\operatorname{lcm}(5,7)=35;\ \operatorname{lcm}(15,21)=105;\ \operatorname{lcm}(132,240)=2640$  
规定g$\mathtt{c d}(0,0)=0$。易知若$a$，$b$不全为零，则$\operatorname*{gcd}(a,\ b)>0$。  
【定理2.3】假设$a$ 和$b$ 是任意给定的两个整数，则有：  
$$
a\cdot b=\left(a,b\right)\cdot\ \left[a,b\right]\tag{2-2}
$$  
【定理2.4】假设$a$ 和$b$ 是任意给定的两个整数，如果$a$ 和$b$ 都能整除整数$k$，则其最小公倍数$[a,b]$也能整除$k$。  
显然，可以将公因数和公倍数的相关直接概念推广到如下多个整数的情形：  
【定义2.5】假设$a_{1},a_{2},\cdots,a_{k}$是$k$ 个不全为零的整数，如果$s$ 是其中每个整数的因数，则称$t$是$a_{1},a_{2},\cdots,a_{k}$的一个公因数。对于给定的整数$a_{1},a_{2},\cdots,a_{k}$，它们的公因数只有有限多个，其中最大的那个公因数称为$a_{1},a_{2},\cdots,a_{k}$的最大公因数，记为gc$\mathfrak{d}(a_{1},a_{2},\cdots,a_{k}).$。  
【定义2.6】假设$a_{1},a_{2},\cdots,a_{k}$是$k$ 个不全为零的整数，如果$t$是其中每个整数的倍数，则称$t$ 是$a_{1},a_{2},\cdots,a_{k}$的一个公倍数。$a_{1},a_{2},\cdots,a_{k}$的所有公倍数中数值最小的那个公倍数，称为$a_{1},a_{2},\cdots,a_{k}$的最小公倍数，记为$\operatorname{lcm}(a_{1},a_{2},\cdots,a_{k})$。  
下面定理是最大公因数的一个重要定理，它刻画了最大公因数在带余除法中的不变性质，为最大公因数的构造算法——辗转相除法提供了坚实的理论基础。  
【定理2.5】假设$a$ 和$b$ 是任意给定的两个整数，若有$b=a q+r$，$0\leq|r|<a$，则必有：$\operatorname*{gcd}(b,a)=\operatorname*{gcd}(a,r).$。  
【定理2.6】假设$a$ 和$b$ 是任意两个整数，则必然存在两个整数$\cdot k_{1}$和$k_{2}$，满足：
$$
\operatorname*{gcd}(b,a)=k_{1}\cdot b+k_{2}\cdot a\tag{2-3}
$$  
上述定理表明，整数$a$ 和$b$ 的最大公因数可以表示为它们的一个线性组合。这就给出了最大公因式一种具体表达形式，这种表达形式对于考察最大公因数的性质具有非常重要的作用。例如，使用上述线性组合表达式，可得到最大公因数下述性质：  
【定理2.7】假设$a$ 和$b$ 是任意给定的两个整数，如果$d$ 是$a$ 和$b$ 的任意一个公因数，则$d$一定能整除$\operatorname*{gcd}(a,b)$。"
定理2.31,定理,"['第二章  整数与算法设计基础', '§ 2.4 算法设计策略与应用', '2.4.2 递归与分治', '二、分治策略']","{'实体类型': '定理', '条件': '假设f是满足递推关系f(n)=a f(n/b)+c的增函数，其中n被b整除，a≥1，b是大于1的整数，c是一个正实数', '结论': 'f(n)={O(n^{log_b a}) 如果a>1, O(log n) 如果a=1}', '进一步结论': '当n=b^k时（k是正整数），则有f(n)=C1n^{log_b a}+C2，其中C1=f(1)+c/(a·1)且C2=-c/(a-1)'}",,4,"【定义2.21】对于一个规模为$n$ 的问题，若该问题可以容易地解决（比如说规模$n$ 较小）则直接解决，否则将其分解为$k$个规模较小的子问题，这些子问题互相独立且与原问题形式相同，求解这些子问题，然后将各子问题的解合并得到原问题的解。  
如定义所述，由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术解  决并实现分治策略提供了方便。分治法也可以看成是一种递归，因为必要时可把分解求得的子问题的解合并起来获得原问题的解。  
分治算法一般分为如下三个基本步骤：（1）将原问题分解为若干相同的子问题；（2）若子问题的规模容易解决则直接求解，否则继续分解；3）将子问题的解合并得到原问题的解，当遇到如折半查找等某些不必求出所有子问题的解的情况时，则省略合并操作。  
分治算法的计算复杂性可以通过构造递推表达式进行分析：假设一个递归算法把一个规模为$n$ 的问题分成$a$ 个子问题，其中每个子问题的规模是$n/b$（为简单起见，假设$n$是$b$的倍数），并设在把子问题解组合成原问题解的处理中需要总量为$g(n)$的额外运算。  
【定义2.22】若$f\!\!\left(n\right)$表示求解规模为$n$ 的问题所需的运算数，则$f$满足如下递推关系：  
$$
f~(n)=a f(n/b)+g(n)\tag{2-23}
$$  
上式称为分治递推关系。  
可通过上述递推关系来分析算法的复杂度。  
【定理2.31】假设$f$是满足递推关系：  
$$
f(n)=a f(n/b)+c
$$  
的增函数，其中$n$ 被$b$ 整除，$a{\geq}1$，$b$ 是大于1 的整数，$c$ 是一个正实数。则有：  
$$
f(n)={\left\{\begin{array}{l l}{O(n^{l o g_{b}\,a})}&{{如果a>1}}\\ {O(l o g\,n)}&{{如果a=1}}\end{array}\right.}\tag{2-24}
$$  
进一步，当$n=b^{k}$时（$k$ 是正整数），则有：  
$$
f(n)=C_{1}n^{l o g_{b}\,a}+C_{2}\tag{2-25}
$$  
其中$C_{1}{=}f\!\!(1){+}c/(a{\cdot}1)$且$C_{2}=-c/(a-1)$"
定理2.4,定理,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.2 整数的因数分解', '一、公因数与公倍数']","{'实体类型': '定理', '内容': '假设a和b是任意给定的两个整数，如果a和b都能整除整数k，则其最小公倍数[a,b]也能整除k'}",,4,"假设$a$ 和$b$ 是任意给定的两个整数，如果$b$ 能够整除$a$，那么$b$ 就是$a$的一个因数、$a$就是$b$ 的一个倍数，此时可分别从因数和倍数这两个角度对整数进行考察。  
具体地说，如果$b$ 也是另外一个整数$c$ 的因数，则$b$ 就反映出$a$ 和$c$ 的某种共同特征，或者说整数$a$ 和$c$ 具有一个相同的构件$b$，通常将其称为$a$ 与$c$的公因数。同样，如果整数$a$ 也是另外一个整数$s$ 的倍数，则$b$ 和$s$ 就有一个共同的倍数$a$，通常称之为公倍数。公因数和公倍数分别从两个不同角度考察任意两个整数之间的联系，具体定义如下：  
【定义2.3】假设$i$ 和$j$是任意两个整数，如果整数$b$ 能够同时整除$i$和$j$，则称$b$ 是$i$和$j$ 的一个公因数，如果$i$ 和$j$都能够整除整数$a$，则称$a$ 是$i$ 和$j$的一个公倍数。  
自然数1 可以整除任意整数，因此对于任意两个整数，它们的公因数总是存在的。公因数表达的是两个整数的共同部分，通常需要考察两个整数之间的共同部分最大值能达到多少，故有所谓最大公因数的概念。同样，对于任意两个整数，这两个整数的乘积就是它们的公倍数，因此，公倍数总是存在的，需要着重考察的通常式公倍数的最小值，因而有最小公倍数的概念。最大公因数和最小公倍数的具体定义如下：  
【定义2.4】假设$a$ 和$b$ 是任意给定的两个整数，$a$ 和$b$ 的所有公因数中最大的那个整数称为$a$ 和$b$ 的最大公因数，记为$\operatorname*{gcd}(a,b)$或$(a,b)$，$a$ 和$b$ 的所有公倍数中最小的那个整数称为$a$ 和$b$ 的最小公倍数，记为$\operatorname{lcm}(a,b)$或$[a,b]$。  
例如： $\operatorname*{gcd}(5,7)=1$$\operatorname*{gcd}(15,21)=3;\;\;\operatorname*{gcd}(132,240)=12;$； $\operatorname{lcm}(5,7)=35;\ \operatorname{lcm}(15,21)=105;\ \operatorname{lcm}(132,240)=2640$  
规定g$\mathtt{c d}(0,0)=0$。易知若$a$，$b$不全为零，则$\operatorname*{gcd}(a,\ b)>0$。  
【定理2.3】假设$a$ 和$b$ 是任意给定的两个整数，则有：  
$$
a\cdot b=\left(a,b\right)\cdot\ \left[a,b\right]\tag{2-2}
$$  
【定理2.4】假设$a$ 和$b$ 是任意给定的两个整数，如果$a$ 和$b$ 都能整除整数$k$，则其最小公倍数$[a,b]$也能整除$k$。  
显然，可以将公因数和公倍数的相关直接概念推广到如下多个整数的情形：  
【定义2.5】假设$a_{1},a_{2},\cdots,a_{k}$是$k$ 个不全为零的整数，如果$s$ 是其中每个整数的因数，则称$t$是$a_{1},a_{2},\cdots,a_{k}$的一个公因数。对于给定的整数$a_{1},a_{2},\cdots,a_{k}$，它们的公因数只有有限多个，其中最大的那个公因数称为$a_{1},a_{2},\cdots,a_{k}$的最大公因数，记为gc$\mathfrak{d}(a_{1},a_{2},\cdots,a_{k}).$。  
【定义2.6】假设$a_{1},a_{2},\cdots,a_{k}$是$k$ 个不全为零的整数，如果$t$是其中每个整数的倍数，则称$t$ 是$a_{1},a_{2},\cdots,a_{k}$的一个公倍数。$a_{1},a_{2},\cdots,a_{k}$的所有公倍数中数值最小的那个公倍数，称为$a_{1},a_{2},\cdots,a_{k}$的最小公倍数，记为$\operatorname{lcm}(a_{1},a_{2},\cdots,a_{k})$。  
下面定理是最大公因数的一个重要定理，它刻画了最大公因数在带余除法中的不变性质，为最大公因数的构造算法——辗转相除法提供了坚实的理论基础。  
【定理2.5】假设$a$ 和$b$ 是任意给定的两个整数，若有$b=a q+r$，$0\leq|r|<a$，则必有：$\operatorname*{gcd}(b,a)=\operatorname*{gcd}(a,r).$。  
【定理2.6】假设$a$ 和$b$ 是任意两个整数，则必然存在两个整数$\cdot k_{1}$和$k_{2}$，满足：
$$
\operatorname*{gcd}(b,a)=k_{1}\cdot b+k_{2}\cdot a\tag{2-3}
$$  
上述定理表明，整数$a$ 和$b$ 的最大公因数可以表示为它们的一个线性组合。这就给出了最大公因式一种具体表达形式，这种表达形式对于考察最大公因数的性质具有非常重要的作用。例如，使用上述线性组合表达式，可得到最大公因数下述性质：  
【定理2.7】假设$a$ 和$b$ 是任意给定的两个整数，如果$d$ 是$a$ 和$b$ 的任意一个公因数，则$d$一定能整除$\operatorname*{gcd}(a,b)$。"
定理2.5,定理,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.2 整数的因数分解', '一、公因数与公倍数']","{'实体类型': '定理', '内容': '假设a和b是任意给定的两个整数，若有b=aq+r，0≤|r|<a，则必有gcd(b,a)=gcd(a,r)'}",,4,"假设$a$ 和$b$ 是任意给定的两个整数，如果$b$ 能够整除$a$，那么$b$ 就是$a$的一个因数、$a$就是$b$ 的一个倍数，此时可分别从因数和倍数这两个角度对整数进行考察。  
具体地说，如果$b$ 也是另外一个整数$c$ 的因数，则$b$ 就反映出$a$ 和$c$ 的某种共同特征，或者说整数$a$ 和$c$ 具有一个相同的构件$b$，通常将其称为$a$ 与$c$的公因数。同样，如果整数$a$ 也是另外一个整数$s$ 的倍数，则$b$ 和$s$ 就有一个共同的倍数$a$，通常称之为公倍数。公因数和公倍数分别从两个不同角度考察任意两个整数之间的联系，具体定义如下：  
【定义2.3】假设$i$ 和$j$是任意两个整数，如果整数$b$ 能够同时整除$i$和$j$，则称$b$ 是$i$和$j$ 的一个公因数，如果$i$ 和$j$都能够整除整数$a$，则称$a$ 是$i$ 和$j$的一个公倍数。  
自然数1 可以整除任意整数，因此对于任意两个整数，它们的公因数总是存在的。公因数表达的是两个整数的共同部分，通常需要考察两个整数之间的共同部分最大值能达到多少，故有所谓最大公因数的概念。同样，对于任意两个整数，这两个整数的乘积就是它们的公倍数，因此，公倍数总是存在的，需要着重考察的通常式公倍数的最小值，因而有最小公倍数的概念。最大公因数和最小公倍数的具体定义如下：  
【定义2.4】假设$a$ 和$b$ 是任意给定的两个整数，$a$ 和$b$ 的所有公因数中最大的那个整数称为$a$ 和$b$ 的最大公因数，记为$\operatorname*{gcd}(a,b)$或$(a,b)$，$a$ 和$b$ 的所有公倍数中最小的那个整数称为$a$ 和$b$ 的最小公倍数，记为$\operatorname{lcm}(a,b)$或$[a,b]$。  
例如： $\operatorname*{gcd}(5,7)=1$$\operatorname*{gcd}(15,21)=3;\;\;\operatorname*{gcd}(132,240)=12;$； $\operatorname{lcm}(5,7)=35;\ \operatorname{lcm}(15,21)=105;\ \operatorname{lcm}(132,240)=2640$  
规定g$\mathtt{c d}(0,0)=0$。易知若$a$，$b$不全为零，则$\operatorname*{gcd}(a,\ b)>0$。  
【定理2.3】假设$a$ 和$b$ 是任意给定的两个整数，则有：  
$$
a\cdot b=\left(a,b\right)\cdot\ \left[a,b\right]\tag{2-2}
$$  
【定理2.4】假设$a$ 和$b$ 是任意给定的两个整数，如果$a$ 和$b$ 都能整除整数$k$，则其最小公倍数$[a,b]$也能整除$k$。  
显然，可以将公因数和公倍数的相关直接概念推广到如下多个整数的情形：  
【定义2.5】假设$a_{1},a_{2},\cdots,a_{k}$是$k$ 个不全为零的整数，如果$s$ 是其中每个整数的因数，则称$t$是$a_{1},a_{2},\cdots,a_{k}$的一个公因数。对于给定的整数$a_{1},a_{2},\cdots,a_{k}$，它们的公因数只有有限多个，其中最大的那个公因数称为$a_{1},a_{2},\cdots,a_{k}$的最大公因数，记为gc$\mathfrak{d}(a_{1},a_{2},\cdots,a_{k}).$。  
【定义2.6】假设$a_{1},a_{2},\cdots,a_{k}$是$k$ 个不全为零的整数，如果$t$是其中每个整数的倍数，则称$t$ 是$a_{1},a_{2},\cdots,a_{k}$的一个公倍数。$a_{1},a_{2},\cdots,a_{k}$的所有公倍数中数值最小的那个公倍数，称为$a_{1},a_{2},\cdots,a_{k}$的最小公倍数，记为$\operatorname{lcm}(a_{1},a_{2},\cdots,a_{k})$。  
下面定理是最大公因数的一个重要定理，它刻画了最大公因数在带余除法中的不变性质，为最大公因数的构造算法——辗转相除法提供了坚实的理论基础。  
【定理2.5】假设$a$ 和$b$ 是任意给定的两个整数，若有$b=a q+r$，$0\leq|r|<a$，则必有：$\operatorname*{gcd}(b,a)=\operatorname*{gcd}(a,r).$。  
【定理2.6】假设$a$ 和$b$ 是任意两个整数，则必然存在两个整数$\cdot k_{1}$和$k_{2}$，满足：
$$
\operatorname*{gcd}(b,a)=k_{1}\cdot b+k_{2}\cdot a\tag{2-3}
$$  
上述定理表明，整数$a$ 和$b$ 的最大公因数可以表示为它们的一个线性组合。这就给出了最大公因式一种具体表达形式，这种表达形式对于考察最大公因数的性质具有非常重要的作用。例如，使用上述线性组合表达式，可得到最大公因数下述性质：  
【定理2.7】假设$a$ 和$b$ 是任意给定的两个整数，如果$d$ 是$a$ 和$b$ 的任意一个公因数，则$d$一定能整除$\operatorname*{gcd}(a,b)$。"
定理2.6,定理,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.2 整数的因数分解', '一、公因数与公倍数']","{'实体类型': '定理', '内容': '假设a和b是任意两个整数，则必然存在两个整数k1和k2，满足gcd(b,a)=k1·b+k2·a'}",,4,"假设$a$ 和$b$ 是任意给定的两个整数，如果$b$ 能够整除$a$，那么$b$ 就是$a$的一个因数、$a$就是$b$ 的一个倍数，此时可分别从因数和倍数这两个角度对整数进行考察。  
具体地说，如果$b$ 也是另外一个整数$c$ 的因数，则$b$ 就反映出$a$ 和$c$ 的某种共同特征，或者说整数$a$ 和$c$ 具有一个相同的构件$b$，通常将其称为$a$ 与$c$的公因数。同样，如果整数$a$ 也是另外一个整数$s$ 的倍数，则$b$ 和$s$ 就有一个共同的倍数$a$，通常称之为公倍数。公因数和公倍数分别从两个不同角度考察任意两个整数之间的联系，具体定义如下：  
【定义2.3】假设$i$ 和$j$是任意两个整数，如果整数$b$ 能够同时整除$i$和$j$，则称$b$ 是$i$和$j$ 的一个公因数，如果$i$ 和$j$都能够整除整数$a$，则称$a$ 是$i$ 和$j$的一个公倍数。  
自然数1 可以整除任意整数，因此对于任意两个整数，它们的公因数总是存在的。公因数表达的是两个整数的共同部分，通常需要考察两个整数之间的共同部分最大值能达到多少，故有所谓最大公因数的概念。同样，对于任意两个整数，这两个整数的乘积就是它们的公倍数，因此，公倍数总是存在的，需要着重考察的通常式公倍数的最小值，因而有最小公倍数的概念。最大公因数和最小公倍数的具体定义如下：  
【定义2.4】假设$a$ 和$b$ 是任意给定的两个整数，$a$ 和$b$ 的所有公因数中最大的那个整数称为$a$ 和$b$ 的最大公因数，记为$\operatorname*{gcd}(a,b)$或$(a,b)$，$a$ 和$b$ 的所有公倍数中最小的那个整数称为$a$ 和$b$ 的最小公倍数，记为$\operatorname{lcm}(a,b)$或$[a,b]$。  
例如： $\operatorname*{gcd}(5,7)=1$$\operatorname*{gcd}(15,21)=3;\;\;\operatorname*{gcd}(132,240)=12;$； $\operatorname{lcm}(5,7)=35;\ \operatorname{lcm}(15,21)=105;\ \operatorname{lcm}(132,240)=2640$  
规定g$\mathtt{c d}(0,0)=0$。易知若$a$，$b$不全为零，则$\operatorname*{gcd}(a,\ b)>0$。  
【定理2.3】假设$a$ 和$b$ 是任意给定的两个整数，则有：  
$$
a\cdot b=\left(a,b\right)\cdot\ \left[a,b\right]\tag{2-2}
$$  
【定理2.4】假设$a$ 和$b$ 是任意给定的两个整数，如果$a$ 和$b$ 都能整除整数$k$，则其最小公倍数$[a,b]$也能整除$k$。  
显然，可以将公因数和公倍数的相关直接概念推广到如下多个整数的情形：  
【定义2.5】假设$a_{1},a_{2},\cdots,a_{k}$是$k$ 个不全为零的整数，如果$s$ 是其中每个整数的因数，则称$t$是$a_{1},a_{2},\cdots,a_{k}$的一个公因数。对于给定的整数$a_{1},a_{2},\cdots,a_{k}$，它们的公因数只有有限多个，其中最大的那个公因数称为$a_{1},a_{2},\cdots,a_{k}$的最大公因数，记为gc$\mathfrak{d}(a_{1},a_{2},\cdots,a_{k}).$。  
【定义2.6】假设$a_{1},a_{2},\cdots,a_{k}$是$k$ 个不全为零的整数，如果$t$是其中每个整数的倍数，则称$t$ 是$a_{1},a_{2},\cdots,a_{k}$的一个公倍数。$a_{1},a_{2},\cdots,a_{k}$的所有公倍数中数值最小的那个公倍数，称为$a_{1},a_{2},\cdots,a_{k}$的最小公倍数，记为$\operatorname{lcm}(a_{1},a_{2},\cdots,a_{k})$。  
下面定理是最大公因数的一个重要定理，它刻画了最大公因数在带余除法中的不变性质，为最大公因数的构造算法——辗转相除法提供了坚实的理论基础。  
【定理2.5】假设$a$ 和$b$ 是任意给定的两个整数，若有$b=a q+r$，$0\leq|r|<a$，则必有：$\operatorname*{gcd}(b,a)=\operatorname*{gcd}(a,r).$。  
【定理2.6】假设$a$ 和$b$ 是任意两个整数，则必然存在两个整数$\cdot k_{1}$和$k_{2}$，满足：
$$
\operatorname*{gcd}(b,a)=k_{1}\cdot b+k_{2}\cdot a\tag{2-3}
$$  
上述定理表明，整数$a$ 和$b$ 的最大公因数可以表示为它们的一个线性组合。这就给出了最大公因式一种具体表达形式，这种表达形式对于考察最大公因数的性质具有非常重要的作用。例如，使用上述线性组合表达式，可得到最大公因数下述性质：  
【定理2.7】假设$a$ 和$b$ 是任意给定的两个整数，如果$d$ 是$a$ 和$b$ 的任意一个公因数，则$d$一定能整除$\operatorname*{gcd}(a,b)$。"
定理2.7,定理,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.2 整数的因数分解', '一、公因数与公倍数']","{'实体类型': '定理', '内容': '假设a和b是任意给定的两个整数，如果d是a和b的任意一个公因数，则d一定能整除gcd(a,b)'}",,4,"假设$a$ 和$b$ 是任意给定的两个整数，如果$b$ 能够整除$a$，那么$b$ 就是$a$的一个因数、$a$就是$b$ 的一个倍数，此时可分别从因数和倍数这两个角度对整数进行考察。  
具体地说，如果$b$ 也是另外一个整数$c$ 的因数，则$b$ 就反映出$a$ 和$c$ 的某种共同特征，或者说整数$a$ 和$c$ 具有一个相同的构件$b$，通常将其称为$a$ 与$c$的公因数。同样，如果整数$a$ 也是另外一个整数$s$ 的倍数，则$b$ 和$s$ 就有一个共同的倍数$a$，通常称之为公倍数。公因数和公倍数分别从两个不同角度考察任意两个整数之间的联系，具体定义如下：  
【定义2.3】假设$i$ 和$j$是任意两个整数，如果整数$b$ 能够同时整除$i$和$j$，则称$b$ 是$i$和$j$ 的一个公因数，如果$i$ 和$j$都能够整除整数$a$，则称$a$ 是$i$ 和$j$的一个公倍数。  
自然数1 可以整除任意整数，因此对于任意两个整数，它们的公因数总是存在的。公因数表达的是两个整数的共同部分，通常需要考察两个整数之间的共同部分最大值能达到多少，故有所谓最大公因数的概念。同样，对于任意两个整数，这两个整数的乘积就是它们的公倍数，因此，公倍数总是存在的，需要着重考察的通常式公倍数的最小值，因而有最小公倍数的概念。最大公因数和最小公倍数的具体定义如下：  
【定义2.4】假设$a$ 和$b$ 是任意给定的两个整数，$a$ 和$b$ 的所有公因数中最大的那个整数称为$a$ 和$b$ 的最大公因数，记为$\operatorname*{gcd}(a,b)$或$(a,b)$，$a$ 和$b$ 的所有公倍数中最小的那个整数称为$a$ 和$b$ 的最小公倍数，记为$\operatorname{lcm}(a,b)$或$[a,b]$。  
例如： $\operatorname*{gcd}(5,7)=1$$\operatorname*{gcd}(15,21)=3;\;\;\operatorname*{gcd}(132,240)=12;$； $\operatorname{lcm}(5,7)=35;\ \operatorname{lcm}(15,21)=105;\ \operatorname{lcm}(132,240)=2640$  
规定g$\mathtt{c d}(0,0)=0$。易知若$a$，$b$不全为零，则$\operatorname*{gcd}(a,\ b)>0$。  
【定理2.3】假设$a$ 和$b$ 是任意给定的两个整数，则有：  
$$
a\cdot b=\left(a,b\right)\cdot\ \left[a,b\right]\tag{2-2}
$$  
【定理2.4】假设$a$ 和$b$ 是任意给定的两个整数，如果$a$ 和$b$ 都能整除整数$k$，则其最小公倍数$[a,b]$也能整除$k$。  
显然，可以将公因数和公倍数的相关直接概念推广到如下多个整数的情形：  
【定义2.5】假设$a_{1},a_{2},\cdots,a_{k}$是$k$ 个不全为零的整数，如果$s$ 是其中每个整数的因数，则称$t$是$a_{1},a_{2},\cdots,a_{k}$的一个公因数。对于给定的整数$a_{1},a_{2},\cdots,a_{k}$，它们的公因数只有有限多个，其中最大的那个公因数称为$a_{1},a_{2},\cdots,a_{k}$的最大公因数，记为gc$\mathfrak{d}(a_{1},a_{2},\cdots,a_{k}).$。  
【定义2.6】假设$a_{1},a_{2},\cdots,a_{k}$是$k$ 个不全为零的整数，如果$t$是其中每个整数的倍数，则称$t$ 是$a_{1},a_{2},\cdots,a_{k}$的一个公倍数。$a_{1},a_{2},\cdots,a_{k}$的所有公倍数中数值最小的那个公倍数，称为$a_{1},a_{2},\cdots,a_{k}$的最小公倍数，记为$\operatorname{lcm}(a_{1},a_{2},\cdots,a_{k})$。  
下面定理是最大公因数的一个重要定理，它刻画了最大公因数在带余除法中的不变性质，为最大公因数的构造算法——辗转相除法提供了坚实的理论基础。  
【定理2.5】假设$a$ 和$b$ 是任意给定的两个整数，若有$b=a q+r$，$0\leq|r|<a$，则必有：$\operatorname*{gcd}(b,a)=\operatorname*{gcd}(a,r).$。  
【定理2.6】假设$a$ 和$b$ 是任意两个整数，则必然存在两个整数$\cdot k_{1}$和$k_{2}$，满足：
$$
\operatorname*{gcd}(b,a)=k_{1}\cdot b+k_{2}\cdot a\tag{2-3}
$$  
上述定理表明，整数$a$ 和$b$ 的最大公因数可以表示为它们的一个线性组合。这就给出了最大公因式一种具体表达形式，这种表达形式对于考察最大公因数的性质具有非常重要的作用。例如，使用上述线性组合表达式，可得到最大公因数下述性质：  
【定理2.7】假设$a$ 和$b$ 是任意给定的两个整数，如果$d$ 是$a$ 和$b$ 的任意一个公因数，则$d$一定能整除$\operatorname*{gcd}(a,b)$。"
定理2.8,定理,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.2 整数的因数分解', '二、互素的概念与性质']","{'实体类型': '定理', '条件': '设a，b是任意两个整数，若gcd(a,b)=as+bt', '结论': '则s与t是互素的'}",,4,"从整除的角度看，两个整数的公因数表达的是这两个整数共性成分。如果两个整数的最大公因数为1，则表明这两个整数除1 之外没有任何额外的共性成分。因此，从结构上看，这两个整数之间具有很强的独立性。这种很强的独立性我们称之为互素。互素是整数理论中一个非常重要的基本概念，整数的很多性质都与互素的概念有关，其具体定义如下：  
【定义2.7】假设$a_{1},a_{2},\cdots,a_{k}$是$k$个不全为零的整数，如果有$\operatorname*{gcd}(a_{1},a_{2},\cdots,a_{k})=1$，则称这$k$ 个整数$a_{1},a_{2},\cdots,a_{k}$为互素；如果$a_{1},a_{2},\cdots,a_{k}$中任意两个整数的最大公因数均为1，则称这$k$ 个整数$a_{1},a_{2},\cdots,a_{k}$为两两互素。  
$a_{1},a_{2},\cdots,a_{k}$互素与$a_{1},a_{2},\cdots,a_{k}$两两互素是两个不同的概念，在实际使用过程中应注意加以区分，避免混淆。显然，由$a_{1},a_{2},\cdots,a_{k}$两两互素可以推出$a_{1},a_{2},\cdots,a_{k}$互素，反之不然。例如，$\operatorname*{gcd}(3,6,9,10)=1$，此时这4 个整数仅仅为互素的关系，因为其中的3, 6, 9的最大公因数并不为1，所以不符合两两互素。  
【定理2.8】设$a$，$b$ 是任意两个整数，若$\operatorname*{gcd}(a,b)=a s+b t$，则$s$ 与$t$是互素的。  
【定理2.9】如果整数$a$ 与整数$b_{1},b_{2},\cdots,b_{n}$中的每一个都互质，那么$a$ 与乘积$b_{1}b_{2}\cdots b_{n}$也互质。  
【定理2.10】对于任意的整数$a$，$b$，$c$，下面结论成立：  
（1）若$b|a c$且$\operatorname*{gcd}(a,b)=1$，则有$b|c$；  
（2）若$b|c$且$a|c$，则有$a b|c$。  
【定理 2.11 】若 $\operatorname*{gcd}(a,b)=1$ ，则 $\operatorname*{gcd}(a,b k)=\operatorname*{gcd}(a,k)\,.$"
定理2.9,定理,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.2 整数的因数分解', '二、互素的概念与性质']","{'实体类型': '定理', '条件': '如果整数a与整数b1,b2,...,bn中的每一个都互质', '结论': '那么a与乘积b1b2...bn也互质'}",,4,"从整除的角度看，两个整数的公因数表达的是这两个整数共性成分。如果两个整数的最大公因数为1，则表明这两个整数除1 之外没有任何额外的共性成分。因此，从结构上看，这两个整数之间具有很强的独立性。这种很强的独立性我们称之为互素。互素是整数理论中一个非常重要的基本概念，整数的很多性质都与互素的概念有关，其具体定义如下：  
【定义2.7】假设$a_{1},a_{2},\cdots,a_{k}$是$k$个不全为零的整数，如果有$\operatorname*{gcd}(a_{1},a_{2},\cdots,a_{k})=1$，则称这$k$ 个整数$a_{1},a_{2},\cdots,a_{k}$为互素；如果$a_{1},a_{2},\cdots,a_{k}$中任意两个整数的最大公因数均为1，则称这$k$ 个整数$a_{1},a_{2},\cdots,a_{k}$为两两互素。  
$a_{1},a_{2},\cdots,a_{k}$互素与$a_{1},a_{2},\cdots,a_{k}$两两互素是两个不同的概念，在实际使用过程中应注意加以区分，避免混淆。显然，由$a_{1},a_{2},\cdots,a_{k}$两两互素可以推出$a_{1},a_{2},\cdots,a_{k}$互素，反之不然。例如，$\operatorname*{gcd}(3,6,9,10)=1$，此时这4 个整数仅仅为互素的关系，因为其中的3, 6, 9的最大公因数并不为1，所以不符合两两互素。  
【定理2.8】设$a$，$b$ 是任意两个整数，若$\operatorname*{gcd}(a,b)=a s+b t$，则$s$ 与$t$是互素的。  
【定理2.9】如果整数$a$ 与整数$b_{1},b_{2},\cdots,b_{n}$中的每一个都互质，那么$a$ 与乘积$b_{1}b_{2}\cdots b_{n}$也互质。  
【定理2.10】对于任意的整数$a$，$b$，$c$，下面结论成立：  
（1）若$b|a c$且$\operatorname*{gcd}(a,b)=1$，则有$b|c$；  
（2）若$b|c$且$a|c$，则有$a b|c$。  
【定理 2.11 】若 $\operatorname*{gcd}(a,b)=1$ ，则 $\operatorname*{gcd}(a,b k)=\operatorname*{gcd}(a,k)\,.$"
定理3.5,定理,"['第三章  命题演算与推理', '§ 3.2 命题公式与等值演算', '3.2.3 公式的内否与对偶']","{'实体类型': '定理', '内容': '关于内否式和对偶式的基本性质和关系的一系列等值式'}",,3,"前面学习了 “否定”、 “合取”、 “析取”、 “蕴涵”和“等价”这五个常用命题联结词，其中最常用的是“否定”、 “合取”、 “析取”这三个联结词。事实上，后面将会证明仅使用这三个最常用联结词就可以任意的命题公式。本小节主要考察仅由这三个联结词构成的命题公式，首先给出如下限制性命题公式的定义：  
【定义3.14】如果一个命题公式$G$中仅出现命题变量、命题常量，以及命题联结词“$\neg$”、“ $\wedge$“、”$\lor$“，则称$G$为限制性命题公式。  
例如公式$\neg Q\lor R\,\lor\,\neg(P\lor Q)\lor(Q\lor P)\,\lor\,G\lor(H\land S)$都是限制性命题公式。  
限制性命题公式中只有“$\neg$”、“ $\wedge$“、”$\lor$“这三种运算，其中”$\neg$”为一元运算，“ $\wedge$“和“$\lor$”均为二元运算。对于任意一个限制性命题公式，可以使用规律性修改其运算联结词的方式构造出与之相对应的新的命题公式。例如，对于“$\neg$”运算，可将命题公式中所有变量取反，即由$P$ 换成$\neg\mathrm{P}$，便可得到一个新的公式。由此得到如下内否公式的定义：  
【定义3.15】设$G\Leftrightarrow G(P_{1},P_{2},\cdots P_{n})$是任一限制性命题公式，$P_{1},P_{2},\cdots P_{n}$是其所有命题变量，则称$G(\neg P_{1},\neg P_{2},\cdots\neg P_{n})$是$G(P_{1},P_{2},\cdots P_{n})$的内否公式，记为$G^{\neg}$。  
例如：若 $G=\ \lnot P\lor Q$，则$G^{\neg}=P\lor\neg Q$。  
不难看出，$\wedge$和$\lor$运算具有一定的对等性。也就是说 $\wedge$运算具有的性质，$\lor$运算也都有，反之亦然。因此，对于任意一个限制性命题公式，可将其中 $\wedge$换成$\lor$、$\lor$换成$\wedge$、$T$换成$F$、$F$换成$T$，则可得到一个与之相关的新公式。由此得到如下命题公式对偶式的概念：  
【定义3.16】对于任意一个限制性命题公式$G$，将其中 $\wedge$换成$\lor$、$\vee$换成 $\wedge$、$T$换成$F$、$F$换成$T$，得到的新公式称为$G$的对偶式，记为$G^{*}$。  
例如：
$$
(1)G\Leftrightarrow(P\land F);\quad G^{*}=P\lor T_{\circ}\;\;(\,2\,)\;\;G\Leftrightarrow(P\lor Q)\land R;\;\;G^{*}\Leftrightarrow(P\land Q)\lor R\,_{\circ}
$$  
下面两个定理分别给出了内否式和对偶式的基本性质于基本关系：  
【定理3.5】假设$G$和$H$都是限制性命题公式，则成立下列等值式：  
$\begin{aligned}&(1) (G^{*})^{*}\Leftrightarrow G, (G^{\neg})^{\neg}\Leftrightarrow G; (2) (G\vee H)^{*}\Leftrightarrow G^{*}\wedge H^{*}; (G\vee H)^{\neg}\Leftrightarrow G^{\neg}\vee H^{\neg};\\&(3) (G\wedge H)^{*}\Leftrightarrow G^{*}\vee H^{*}; (G\wedge H)^{\neg}\Leftrightarrow G^{\neg}\wedge H^{\neg}。\end{aligned}$  
【定理3.6】设$G$和$G^{*}$互为对偶式，$P_{1},P_{2},\cdots P_{n}$是出现在$G$和$G^{*}$中的全部命题变项，将$G$和$G^{*}$写成$\mathsf{n}$ 元函数形式，则有：
$$
(1)\neg G(P_{1},P_{2},\cdots,P_{n})\Leftrightarrow G^{*}(\neg P_{1},\neg P_{2},\cdots,\neg P_{n})\Leftrightarrow(G^{\neg})^{*}(P_{1},\cdots,P_{n})\tag{3-1}
$$  
$$
G^{\neg}(P_{1},P_{2},\cdots,P_{n})\Leftrightarrow G(\neg P_{1},\neg P_{2},\cdots,\neg P_{n})\Leftrightarrow\neg G^{*}(P_{1},P_{2},\cdots,P_{n})\tag{3-2}
$$  
上述定理的第（1）条表明命题公式$G$的否定与其命题变元否定的对偶式，即与该公式内否式的对偶式等值；第（2）条表明命题公式$G$的内否式与该公式对偶式的否定等值。  
【定理3.7】（对偶原理）假设$P_{1},P_{2},\cdots,P_{n}$是出现在命题公式$P$和$Q$中的所有原子变元，如果$P\Leftrightarrow Q$，那么$P^{*}\Leftrightarrow Q^{*}$。  
对偶原理表明命题公式之间所有等值关系都是成对的。也就是说，对于任意一个等值式，都可由对偶原理构造一个与之对偶的等值式。例如，对于等值式$P\to Q\Leftrightarrow\neg P\lor Q$，则可构造出其对偶等值式$\neg P\land Q\Leftrightarrow\neg(\neg P\rightarrow\neg Q)$。因为$\neg P\land Q\Leftrightarrow\neg(P\lor\neg Q)\Leftrightarrow\neg(\neg P\to\neg Q)$。"
定理3.6,定理,"['第三章  命题演算与推理', '§ 3.2 命题公式与等值演算', '3.2.3 公式的内否与对偶']","{'实体类型': '定理', '内容': '关于命题公式及其对偶式和内否式之间的等值关系'}",,3,"前面学习了 “否定”、 “合取”、 “析取”、 “蕴涵”和“等价”这五个常用命题联结词，其中最常用的是“否定”、 “合取”、 “析取”这三个联结词。事实上，后面将会证明仅使用这三个最常用联结词就可以任意的命题公式。本小节主要考察仅由这三个联结词构成的命题公式，首先给出如下限制性命题公式的定义：  
【定义3.14】如果一个命题公式$G$中仅出现命题变量、命题常量，以及命题联结词“$\neg$”、“ $\wedge$“、”$\lor$“，则称$G$为限制性命题公式。  
例如公式$\neg Q\lor R\,\lor\,\neg(P\lor Q)\lor(Q\lor P)\,\lor\,G\lor(H\land S)$都是限制性命题公式。  
限制性命题公式中只有“$\neg$”、“ $\wedge$“、”$\lor$“这三种运算，其中”$\neg$”为一元运算，“ $\wedge$“和“$\lor$”均为二元运算。对于任意一个限制性命题公式，可以使用规律性修改其运算联结词的方式构造出与之相对应的新的命题公式。例如，对于“$\neg$”运算，可将命题公式中所有变量取反，即由$P$ 换成$\neg\mathrm{P}$，便可得到一个新的公式。由此得到如下内否公式的定义：  
【定义3.15】设$G\Leftrightarrow G(P_{1},P_{2},\cdots P_{n})$是任一限制性命题公式，$P_{1},P_{2},\cdots P_{n}$是其所有命题变量，则称$G(\neg P_{1},\neg P_{2},\cdots\neg P_{n})$是$G(P_{1},P_{2},\cdots P_{n})$的内否公式，记为$G^{\neg}$。  
例如：若 $G=\ \lnot P\lor Q$，则$G^{\neg}=P\lor\neg Q$。  
不难看出，$\wedge$和$\lor$运算具有一定的对等性。也就是说 $\wedge$运算具有的性质，$\lor$运算也都有，反之亦然。因此，对于任意一个限制性命题公式，可将其中 $\wedge$换成$\lor$、$\lor$换成$\wedge$、$T$换成$F$、$F$换成$T$，则可得到一个与之相关的新公式。由此得到如下命题公式对偶式的概念：  
【定义3.16】对于任意一个限制性命题公式$G$，将其中 $\wedge$换成$\lor$、$\vee$换成 $\wedge$、$T$换成$F$、$F$换成$T$，得到的新公式称为$G$的对偶式，记为$G^{*}$。  
例如：
$$
(1)G\Leftrightarrow(P\land F);\quad G^{*}=P\lor T_{\circ}\;\;(\,2\,)\;\;G\Leftrightarrow(P\lor Q)\land R;\;\;G^{*}\Leftrightarrow(P\land Q)\lor R\,_{\circ}
$$  
下面两个定理分别给出了内否式和对偶式的基本性质于基本关系：  
【定理3.5】假设$G$和$H$都是限制性命题公式，则成立下列等值式：  
$\begin{aligned}&(1) (G^{*})^{*}\Leftrightarrow G, (G^{\neg})^{\neg}\Leftrightarrow G; (2) (G\vee H)^{*}\Leftrightarrow G^{*}\wedge H^{*}; (G\vee H)^{\neg}\Leftrightarrow G^{\neg}\vee H^{\neg};\\&(3) (G\wedge H)^{*}\Leftrightarrow G^{*}\vee H^{*}; (G\wedge H)^{\neg}\Leftrightarrow G^{\neg}\wedge H^{\neg}。\end{aligned}$  
【定理3.6】设$G$和$G^{*}$互为对偶式，$P_{1},P_{2},\cdots P_{n}$是出现在$G$和$G^{*}$中的全部命题变项，将$G$和$G^{*}$写成$\mathsf{n}$ 元函数形式，则有：
$$
(1)\neg G(P_{1},P_{2},\cdots,P_{n})\Leftrightarrow G^{*}(\neg P_{1},\neg P_{2},\cdots,\neg P_{n})\Leftrightarrow(G^{\neg})^{*}(P_{1},\cdots,P_{n})\tag{3-1}
$$  
$$
G^{\neg}(P_{1},P_{2},\cdots,P_{n})\Leftrightarrow G(\neg P_{1},\neg P_{2},\cdots,\neg P_{n})\Leftrightarrow\neg G^{*}(P_{1},P_{2},\cdots,P_{n})\tag{3-2}
$$  
上述定理的第（1）条表明命题公式$G$的否定与其命题变元否定的对偶式，即与该公式内否式的对偶式等值；第（2）条表明命题公式$G$的内否式与该公式对偶式的否定等值。  
【定理3.7】（对偶原理）假设$P_{1},P_{2},\cdots,P_{n}$是出现在命题公式$P$和$Q$中的所有原子变元，如果$P\Leftrightarrow Q$，那么$P^{*}\Leftrightarrow Q^{*}$。  
对偶原理表明命题公式之间所有等值关系都是成对的。也就是说，对于任意一个等值式，都可由对偶原理构造一个与之对偶的等值式。例如，对于等值式$P\to Q\Leftrightarrow\neg P\lor Q$，则可构造出其对偶等值式$\neg P\land Q\Leftrightarrow\neg(\neg P\rightarrow\neg Q)$。因为$\neg P\land Q\Leftrightarrow\neg(P\lor\neg Q)\Leftrightarrow\neg(\neg P\to\neg Q)$。"
定理3.8,定理,"['第三章  命题演算与推理', '§ 3.4 命题公式的范式', '3.4.1 范式的基本概念', '二、析取范式与合取范式']","{'实体类型': '定理', '内容': '对于任意命题公式，都存在与其等值的析取范式和合取范式'}",,4,"合取式是一个只有否定层与合取运算层的两层结构表达式，如果在其外层增加一个析取运算层，则得到所谓的析取范式；同样，析取式是一个只有否定层与析取运算层的两层结构表达式，如果在其外层增加一个合取运算层，则得到所谓的合取范式。  
【定义3.22】有限个短语的析取式称为析取范式；有限个子句的合取式称为合取范式。析取范式与合取范式统称为范式。 也就是说，一个命题公式为析取范式，当且仅当它具有形式：$A_{1}\lor A_{2}\lor\ldots\lor A_{n}$。其中，$A_{1}$，$A_{2}$，… ，$A_{n}$均为由命题变元或其否定所组成的合取式。  
例如，$(P\land\neg Q\land R)\lor(\neg P\land Q)\lor\neg R$是析取范式。  
同样地，一个命题公式称为合取范式，当且仅当该命题具形式：$B_{1}\wedge B_{2}\wedge\cdots\wedge B_{n}$。其中，$B_{1}$，$B_{2}$，⋯，$B_{n}$均为由命题变元或其否定所组成的析取式。  
例如，$(P\lor\neg Q\lor R)\land(\neg P\lor Q)\land\neg R$是合取范式。  
注意：①一个命题的析取范式或合取范式不唯一；②形如$P\land\neg Q\land R$的公式既可看成是由一个合取式构成的析取范式，也可以看成是由3 个析取式构成的合取范式，但是公式$(P\land$$\neg Q\land R)$只能将其看成是析取范式；③形如$P\lor\neg Q\lor R$的公式既是合取范式，又是析取范式，但$(P\lor\neg Q\lor R)$仅是合取范式。  
对于任意一个命题公式，下面定理保证了其析取范式和合取范式的存在性：  
【定理3.8】对于任意命题公式，都存在与其等值的析取范式和合取范式。"
定理3.9,定理,"['第三章  命题演算与推理', '§ 3.4 命题公式的范式', '3.4.2 主析取范式', '二、主析取范式的概念']","{'实体类型': '定理', '内容': '任何一个命题公式都有与之等价的主析取范式'}",,4,"有了小项的概念，就可以给出如下主析取范式的定义：  
【定义3.24】对于任意一个给定的析取范式$|A_{1}$ ∨$A_{2}$ $\lor\ldots\;\lor A_{\mathrm{n}}$，如果其中的每个合取  式$A_{i}$$(i=1,2,\dots,n)$都是小项，则称该析取范式为主析取范式。  
在真值表中，公式真值为𝑇的指派所对应的小项的析取，即为该公式的主析取范式。这其实给出了主析取范式的真值表构造方法。例如，根据真值表3-20 可得：  
$$
P\to Q\Leftrightarrow(\neg P\land\neg Q)\lor(\neg P\land Q)\lor(P\land Q)\;\;\Leftrightarrow m_{0}\lor m_{1}\lor m_{3}
$$  
表3-20 主析取范式真值表构造法
![](images/674fb2a5e7888d6f416454b2b1e972db70580b4f43fc62f2b0ca65f4527d906c.jpg)  
与析取范式相比，主析取范式对其析取运算形式做了进一步规范，具有更加规整的表达形式。对于任一命题公式，下述定理3.9 表明了该公式主析取范式的存在性：  
【定理3.9】任何一个命题公式都有与之等价的主析取范式。"
定理4.1,定理,"['第四章  谓词演算与推理', '§ 4.2  谓词公式与等值演算', '4.2.4 谓词公式的等值与蕴含', '二、谓词公式的蕴含关系']","{'实体类型': '定理', '内容': '假设G(x)和H(x)是任意两个谓词公式，则存在如下逻辑蕴含关系：∀x G(x)∨∀x H(x)⇒∀x(G(x)∨H(x)) 和 ∃x(G(x)∧H(x))⇒∃x G(x)∧∃x H(x)'}",,4,"如同多项式演算不仅要用到恒等式，还经常用到不等式，谓词公式的逻辑演算与推理也是不仅要用到谓词公式之间的等值关系，而且还需要用到谓词公式之间的蕴含关系。谓词公式之间的蕴含关系如同多项式代数系统中多项式之间的小于或等于关系， 具体地说， 所谓两 个谓词公式之间存在蕴含关系，其实就是两个谓词公式在任何解释下，其中一个谓词公式的真值永远不会大于另外一个谓词公式的真值。下面借助有效公式的概念给出具体定义：  
【定义4.18】假设$G$和$H$是任意两个谓词公式，如果谓词公式$G\rightarrow H$是有效公式，则称谓词公式$\pmb{G}$逻辑蕴含谓词公式$\pmb{H}$，亦称$G$ 与$H$之间具有逻辑蕴含关系，通常简称为蕴含关系，记作$G\Rightarrow H$，并称该式为谓词公式的逻辑蕴含式，通常简称为蕴含式。  
由上述定义可知，判断两个谓词公式$G$ 和$H$ 是否具有逻辑蕴含关系，关键在于证明谓词公式$G\rightarrow H$为有效公式，这种思路与证明命题公式永真蕴含关系的基本思路是一致的。类似于命题公式的永真蕴含演算系统，在谓词公式的逻辑蕴含演算系统中，通常也是先证明出一些重要的谓词公式蕴含式，然后将这些重要谓词蕴含式作为基本蕴含式进一步推演出更多的谓词公式蕴含式，这种推演过程构成了谓词公式蕴含演算的主要内容。下面不加证明地给出这些重要而基本的谓词公式蕴含式，读者可自行给出证明。  
由于谓词公式的逻辑蕴含式依据谓词公式的有效公式定义，而命题公式中永真公式的谓词公式代换实例显然是有效谓词公式，因此与前述谓词公式的等值式类似，前述命题逻辑中15 个基本永真蕴含式经过谓词公式代换后，就可以得到相应的谓词公式基本逻辑蕴含式。当然，由前述每组谓词公式基本等值式显然都可以得到两组相应的基本逻辑蕴含式，这里不再一一赘述。这里主要介绍如下与量词有关的逻辑蕴含式。  
【定理4.1】假设$G(x)$和$H(x)$是任意两个谓词公式，则存在如下逻辑蕴含关系：  
$$
\forall x G(x)\lor\forall x H(x)\Rightarrow\forall x(G(x)\lor H(x))\tag{4-7}
$$  
$$
\exists x(G(x)\land H(x))\Rightarrow\exists x G(x)\land\exists x H(x)\tag{4-8}
$$  
不难看出，上述定理的两个式子仅仅是蕴含式而不是等值式。例如对于（1）式如下解释，由这些人都跳舞或这些人都唱歌，可以推出这些人都跳舞或唱歌。但是反之不然，由这些人都跳舞或唱歌不能推出这些人都跳舞或这些人都唱歌。（2）式可做类似理解。"
定理4.2,定理,"['第四章  谓词演算与推理', '§ 4.3 谓词公式的范式', '4.3.1 等值型范式', '一、前束型公式']","{'实体类型': '定理', '内容': '任意一个含有量词的谓词公式都可以转化为与之等值的前束型公式的形式，但是这种形式并不唯一'}",,4,"在对谓词公式进行演算或推理等分析处理时，经常需要添加或消除量词。为了便于处理，特别是为了便于计算机的机械化处理，在添加或删除量词之前，将通过等值变换将谓词公式中所有量词移到公式的最前端，由此得到如下前束型谓词公式的概念：  
【定义4.19】假设$G$ 是任意一个谓词公式，如果$G$ 的一切量词都位于该公式的最前端(不含否定词)且这些量词的辖域都延伸到公式的末端，则称$G$ 是一个前束型公式。换句话说，谓词公式$G$ 作为前束型公式必须满足如下表达形式：  
$$
G\Leftrightarrow(Q_{1}x_{1})(Q_{1}x_{2})\cdots(Q_{n}x_{n})M(x_{1},x_{2},\cdots x_{n})\tag{4-11}
$$  
其中$Q_{i}$为量词$\forall$或$\exists$，$M$中不能含有任何量词，称$M$为谓词公式$G$ 的母式或基式。  
例如，$\forall x\forall y(G(x)\land H(y)\rightarrow R(x,y)),\,\,\,\forall x\forall y\exists z(G(x,y)\land H(z)\rightarrow R(x,y,z))$ 等都是束型公式。而下列公式$\forall x(G(x)\rightarrow\exists y(H(y)\land R(x,y)),\,\exists x(G(x)\land\forall y(H(y)\rightarrow R(x,y))∃𝑥(𝐺(𝑥) ∧∀y(𝐻(𝑦) →𝑅(𝑥, 𝑦))$等都不是前束型公式。下列定理保证了谓词公式前束型公式的存在性，但并不能保证唯一性。  
【定理4.2】任意一个含有量词的谓词公式都可以转化为与之等值的前束型公式的形式，但是这种形式并不唯一。"
定理4.3,定理,"['第四章  谓词演算与推理', '§ 4.3 谓词公式的范式', '4.3.1 等值型范式', '二、前束范式']","{'实体类型': '定理', '内容': '任意一个含有量词的谓词公式都分别存在与之等值的前束析取范式和前束合取范式，但范式的形式并不唯一'}",,4,"有了前束型公式，就不难得到前束范式。所谓前束范式，其实就是母式为析取范式或合取范式的前束型公式。前束范式的具体定义如下：  
【定义4.20】假设谓词公式$G$ 是任意一个前束型公式，即有：  
$$
G\Leftrightarrow(Q_{1}x_{1})(Q_{1}x_{2})\cdots(Q_{n}x_{n})M(x_{1},x_{2},\cdots x_{n})\tag{4-12}
$$  
其中$Q_{i}$为量词$\forall$或$∃$，$M$中不含有任何量词。如果$G$ 的母式$M$是一个析取范式，则称$G$ 是一个前束析取范式；如果$G$的母式$M$是一个合取范式，则称$G$ 是一前束合取范式。前束析取范式和前束合取范式统称为前束范式。  
例如，$(\forall x)(\exists y)(\forall z)((\lnot P(x)\lor R(x,y))\land(Q(x,y)));$就是一个前束合取范式。  
由于前束型谓词公式中的母式已不再含有量词，表达形式上类似于命题公式，因此可用类似于命题逻辑的方法将前束型公式中的母式转化为析取范式或合取范式，便可得到谓词公式的前束析取范式或者前束合取范式。  
【定理4.3】任意一个含有量词的谓词公式都分别存在与之等值的前束析取范式和前束合取范式，但范式的形式并不唯一。"
定理4.4,定理,"['第四章  谓词演算与推理', '§ 4.3 谓词公式的范式', '4.3.2 非等值型范式', '一、∃型前束范式']","{'实体类型': '定理', '内容': '任意谓词公式可转化为∃型前束范式，且公式有效当且仅当其∃型前束范式有效', '意义': '有效谓词公式与其∃型前束范式等值，可用于演算'}",,4,"∃型前束范式将所有存在量词排在所有全称量词的左边，具体定义如下：  
【定义4.21】假设$G$ 是任意一个谓词公式，如果$G$ 具有如下形式：
$$
G\Leftrightarrow(\exists x_{1})(\exists x_{2})\cdots(\exists x_{i})(\forall x_{i+1})\cdots(\forall x_{n})M(x_{1},x_{2},\cdots x_{n})\tag{4-13}
$$  
即所有存在量词排在所有全称量词的左边且G中至少含有一个存在量词，则称$G$ 是一个∃型前束公式，其中$M(x_{1},x_{2},\cdots x_{n})$为公式的母式，要求既不含任何量词也无任何自由变量。如果∃型前束公式的模式是一个析取范式或合取范式，则称该∃型前束公式为∃型前束范式。  
例如，谓词公式$\exists z\exists w\forall x\forall y$$(\left(\neg P(x)\land\neg R(x,w)\right)\lor\left(\neg Q(z,y)\land\;\neg\;R(x,w)\right)$就是一个∃型前束析取范式。  
下面的定理给出了∃型前束范式的存在性以及在永真性保持上的性质。  
【定理4.4】假设$G$ 是任意一个谓词公式，则可将$G$ 转化为一个∃型前束范式，并且G是有效公式当且仅当其∃型前束范式也是一个有效公式。  
该定理表明有效谓词公式与其∃型前束范式等值，当一个谓词公式为有效公式时，便可使用其∃型前束范式进行演算。不过相对于前束范式的构造，∃型前束范式的构造稍微复杂一些，对于任意一个给定的谓词公式，其∃型前束范式的构造方法如下：  
第一步 将该谓词公式转化为前束型公式。  
第二步 将前束型公式转化为∃型前束范式。对于任意一个前束型公式$G$，显然只需将其转化为∃型前束公式即可，具体转化方法需要根据以下几种情况讨论：  
（1）当$G$ 中含有自由变量时，则需要将其每个自由变量分别加上相应的全称量词，使得谓词公式不再含有自由变量，即将公式变成一个闭式；  
（2）当$G$ 中不含自由变量且不含存在量词∃时，则需在公式中引入一个新的一元谓词及相应的个体变量$Q(u)$，得到一个新的公式：$\exists u(\iff G\land(Q(u)\lor\lnot Q(u)))$。然后将$G$中量词的辖域扩大到整个公式，即将$G$中所有量词提到$(G\wedge(Q(u)\vee\neg Q(u)))$的前面；  
（3）当$G$ 中不含自由变量且含有存在量词∃时，则需要通过引入新谓词的方法逐步将存在量词∃左边的全称量词$\forall$转化为存在量词$∃$。  
经过上述过程，便可将任意一个谓词公式转化为∃型前束型公式，从而可进一步转化为∃型前束范式。"
定理4.5,定理,"['第四章  谓词演算与推理', '§ 4.3 谓词公式的范式', '4.3.2 非等值型范式', '二、无∃型前束范式']","{'实体类型': '定理', '内容': '任意谓词公式可转化为无∃型前束范式，且永假公式与其无∃型前束范式等值', '应用': '用于谓词演算和推理'}",,4,"另外一种斯科伦范式是仅保留全称量词的前束范式，称之为无∃型前束范式。对于任意一个谓词公式，可由下列方法构造其无∃型前束范式：  
第一步  将该谓词公式转化为前束型公式。  
第二步  将前束型公式转化为无$∃$型前束公式：在含有存在量词的前束型公式中，从左边数第一个存在量词开始，依次消除每个存在量词。消除的规则如下：如果存在量词$\exists x$的左边有$n$个全称量词，则任取一个新的以这些全称量词的指导变元为自变量的𝑛元个体函数取代谓词公式中的所有$x$的出现。特别地，当$n=0$时，即$\exists x$的左边无全称量词，则在消除$\exists x$后，以论域中某个未在公式中出现的个体常量取代谓词公式中的所有$\cdot_{x}$的出现。  
第三步  将无∃型前束型公式中不含量词的部分，即母式部分转化为析取范式或合取范式，便可得到所求的无∃型前束范式。  
【定理4.5】假设$G$ 是任意一个谓词公式，则可将$G$ 转化为一个无∃型前束范式，并且$G$ 是永假公式当且仅当其无∃型前束范式也是一个永假公式。  
该定理表明永假式与其无∃型前束范式等值，当一个谓词公式为永假式时，便可使用其无∃型前束范式进行谓词演算和推理。"
定理5.1,定理,"['第五章 关系模型与理论', '§ 5.1 关系的数学模型', '5.1.1  序偶与笛卡尔积']","{'实体类型': '定理', '内容': '笛卡尔积运算对集合的并运算和交运算均满足分配律'}",,3,"要用数学方式表达关系模型，首先必须建立有一种有效的数学机制将来自相同集合或不同集合的两个元素绑定在一起，以表明它们之间具体某种特定的关系。为此，下面给出二元组的相关概念来实现这种机制。  
【定义5.1】假设𝐴和$B$是任意给定的两个集合，则对于分别来自这两个集合中的元素$x$和𝑦，可将它们组合成一个整体并称之为二元组。如果这个二元组为无序二元组，则称其为无序偶对，简称为无序偶，通常记为$(x,y)$；如果这个二元组为有序二元组，则称其为有序偶对，简称为序偶，通常记为$\langle x,y\rangle$，并称$\cdot x\in A$为第一元素，$y\in B$为第二元素。  
在关系的数学理论中，通常使用序偶的概念绑定具有某种确定联系的两个元素。事实上序偶的用途非常广泛，日常生活和工作中的很多问题或概念都可用序偶表示。例如，平面上点$A$ 的横坐标是$x$，纵坐标是$y$，可用序偶表示为$\langle x,y\rangle$，$x,y\in R$；合肥是安徽的省会、南京是江苏的省会，可分别用序偶表示为〈合肥, 安徽〉，〈南京, 江苏〉；数学书在桌上、英语书在床上，可分别用序偶表示为〈数学书, 桌上〉，〈英语书,床上〉。  
由序偶的定义容易知道，序偶可以看作是具有两个元素的集合，但序偶中的两个元素是具有确定次序的，如果两个含有两个元素的集合相等，并不意味着这两个集合元素构成的序偶相等，因此即使成立$\{a,b\}=\{b,a\}$，在$a\neq b$的情况下会有：成立$\langle a,b\rangle\neq\langle b,a\rangle$。例如，对于前述的序偶〈合肥, 安徽〉，从集合的角度看，显然有{合肥, 安徽}$\}=$ {安徽,合肥}，但是序偶〈合肥, 安徽〉和〈安徽, 合肥〉显然代表的是两个不同的含义：前者表示合肥是安徽的省会，前者表示安徽是合肥的省会。因此，有：〈合肥, 安徽〉 $\neq$〈安徽,合肥〉。  
下面给出两个序偶相等的具体定义：  
【定义5.2】假设$\langle a,b\rangle$和$\langle c,d\rangle$是任意给定的两个序偶，如果$a=b$，$c=d$，那称这两个序偶相等，记为：$\langle a,b\rangle=\langle c,d\rangle$。  
从上述定义可知，两个序偶相等当且仅当这两个序偶在对应位置上的元素相等。例如，若有$\langle2x-3y,3x+2y\rangle=\langle1,3\rangle$，则有$2x-3y=1$且$3x+2y=3$；反之亦然。  
显然，可将上述序偶及其相等的相关定义自然推广到多个元素的情形。例如，对于任意给定的三个元素$x,y,z$，则可根据如下递归方式定义由这三个元素组成的有序三元组：  
$$
\langle x,y,\mathrm{z}\rangle=\langle\langle x,y\rangle,\mathrm{z}\rangle\tag{5-1}
$$  
从上式可以看出，所谓有序三元组，其实就是序偶的序偶。一般地，可得到如下关于$^{\cdot n}$元有序组的相关定义：  
【定义5.3】由$n$个元素$a_{1}$ ,$a_{2},\dotsc,a_{n}$组成 $n$元有序组由$n-1$元有序组$\langle a_{1}\;\,,a_{2},\dots,a_{n-1}\rangle$和元素$a_{n}$组成的序偶，记作$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$。即：$\langle a_{1}\;\;,a_{2},\ldots,a_{n}\rangle=\langle\langle a_{1}\;\;,a_{2},\ldots,a_{n-1}\rangle,a_{n}\rangle$。  
【定义5.4】假设$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$和$\langle b_{1},b_{2},\dots,b_{n}\rangle$是任意给定的两个$ n$元有序组，如果$a_{i}=$$b_{i}$，$i=1,2,\dots,n$，则称它们相等，记为：$\langle a_{1}\,\ ,a_{2},\ldots,a_{n}\rangle=\langle b_{1},b_{2},\ldots,b_{n}\rangle\,.$。  
【定义5.5】设$A,B$是任意给定的两个集合，用$A$中任意一个元素为第一元素、$B$中任任意一个元素为第二元素构成的所有可能的序偶组成的集合，称为$A$ 与$B$ 的笛卡尔积，亦称为$A$ 与$B$ 的直积，记为$A\times B$。即有：$A\times B=\{\langle x,y\rangle|(x\in A)\land(y\in B)\}$。  
由上述定义可知，集合$A$ 与$B$ 的笛卡尔积运算结果$A\times B$仍是一个集合，并且$A\times B$中的每个元素都是一个序偶，序偶中第一个元素取自集合$A$、第二个元素取自集合$B$。  
假设根据笛卡尔积的定义，不难证明笛卡尔积运算满足如下几条基本性质：  
（1）假设$A$,$B$是任意给定的两个集合，则有：$A\times\emptyset=B\times\emptyset=\emptyset$；  
（2）假设 $A$, $B$ 是任意给定的两个集合，则有 $A\times B=\emptyset$ ，当且仅当 $A=\emptyset$ 或 $B=\emptyset$；  
（3）当$A,B$是有限集合时，有：$|A\times B|=|B\times A|=|A||B|$  
下面定理表明笛卡尔积运算对集合的并运算和交运算均满足分配律：  
【定理5.1】设$A$、$B$、$C$ 是任意集合，则有：  
$A\times(B\cup C)=(A\times B)\cup(A\times C);\quad A\times(B\cap C)=(A\times B)\cap(A\times C);$  
$(A\cup B)\times C=(A\times C)\cup(B\times C);\quad(A\cap B)\times C=(A\cup C)\times(B\times C)\,$。  
【定理5.2】设$A$、${B}、{C}$ 是任意集合且$C\neq\emptyset$，则有：
$$
A\subseteq B\Leftrightarrow(A\times C\subseteq B\times C);\,\,\,A\subseteq B\Leftrightarrow(C\times A\subseteq C\times B)
$$  
【定理5.3】设$A、\ B、C、D$为非空集合，则有：
$$
A\subseteq C\land B\subseteq D\Leftrightarrow A\times B\subseteq C\times D
$$  
【定理5.4】假设集合$\cdot A_{1},A_{2},\cdots,A_{n}$均为有限集合，则有：
$$
|A_{1}\times A_{2}\times\cdots\times A_{n}|=|A_{1}|\times|A_{2}|\times\cdots\times|A_{n}|
$$"
定理5.10,定理,"['第五章 关系模型与理论', '§ 5.3 关系的基本性质', '5.3.4 关系性质的判定']","{'实体类型': '定理', '内容': '设 R 是集合 A 上的二元关系，则 R 的自反性、反自反性、对称性、反对称性、传递性的判定条件'}",,3,"前面学习了关系的五个基本性质，在关系图和关系矩阵上都能够找到表征这些性质的相关图特征和矩阵特征。因此，对于一个任意给定的二元关系，可以使用关系图或关系矩阵的相关特征判定该关系是否具备关系的哪些基本性质。从本质上看，关系是以序偶为元素的集合。下面介绍和讨论如何从集合的角度判定关系的基本性质。  
【定理5.10】设$R$ 是集合$A$ 上的二元关系，则有：  
（1）$R$ 是自反的$\iff I_{A}\subseteq R$；  （2）$R$ 是反自反的$\iff R\cap I_{A}=\emptyset$；  
（3）$R$ 是对称的$\Leftrightarrow R=R^{-1}$； （4）$R$ 是反对称的$\iff R\cap R^{-1}\subseteq I_{A}$  
（5）$R$ 是传递的$\Longleftrightarrow R\circ R\subseteq R$。  
下面定理表明，对于关系一些基本性质在某些运算下仍然能够保持，此时称关系性质在该运算下具有封闭性。例如，如果$A$ 上$d$ 两个关系都是对称的，那么这两个关系的并运算也是对称的。也就是说，关系的对称性质在关系并运算下是封闭的。  
【定理5.11】设$R$、$S$是定义在$A$ 上的二元关系，则：  
（1）若$R$、$S$是自反的，则$R^{-1}$，$R\cup S$，$R\cap S$，$R\circ S$也是自反的；  
（2）若$R$、$S$是反自反的，则$R^{-1}$，$R\cup S$，$R\cap S$也是反自反的；  
（3）若$R$、$S$是对称的，则$R^{-1}$，$R\cup S$，$R\cap S$也是对称的；  
（4）若$R$、$S$是反对称的，则$R^{-1}$，$R\cap S$也是反对称的；  
（5）若$R$、$S$是传递的，则$R^{-1}$，$R\cap S$也是传递的。"
定理5.11,定理,"['第五章 关系模型与理论', '§ 5.3 关系的基本性质', '5.3.4 关系性质的判定']","{'实体类型': '定理', '内容': '设 R、S 是定义在 A 上的二元关系，若 R、S 具有某种基本性质，则其逆关系、并、交、合成关系也具有该性质'}",,3,"前面学习了关系的五个基本性质，在关系图和关系矩阵上都能够找到表征这些性质的相关图特征和矩阵特征。因此，对于一个任意给定的二元关系，可以使用关系图或关系矩阵的相关特征判定该关系是否具备关系的哪些基本性质。从本质上看，关系是以序偶为元素的集合。下面介绍和讨论如何从集合的角度判定关系的基本性质。  
【定理5.10】设$R$ 是集合$A$ 上的二元关系，则有：  
（1）$R$ 是自反的$\iff I_{A}\subseteq R$；  （2）$R$ 是反自反的$\iff R\cap I_{A}=\emptyset$；  
（3）$R$ 是对称的$\Leftrightarrow R=R^{-1}$； （4）$R$ 是反对称的$\iff R\cap R^{-1}\subseteq I_{A}$  
（5）$R$ 是传递的$\Longleftrightarrow R\circ R\subseteq R$。  
下面定理表明，对于关系一些基本性质在某些运算下仍然能够保持，此时称关系性质在该运算下具有封闭性。例如，如果$A$ 上$d$ 两个关系都是对称的，那么这两个关系的并运算也是对称的。也就是说，关系的对称性质在关系并运算下是封闭的。  
【定理5.11】设$R$、$S$是定义在$A$ 上的二元关系，则：  
（1）若$R$、$S$是自反的，则$R^{-1}$，$R\cup S$，$R\cap S$，$R\circ S$也是自反的；  
（2）若$R$、$S$是反自反的，则$R^{-1}$，$R\cup S$，$R\cap S$也是反自反的；  
（3）若$R$、$S$是对称的，则$R^{-1}$，$R\cup S$，$R\cap S$也是对称的；  
（4）若$R$、$S$是反对称的，则$R^{-1}$，$R\cap S$也是反对称的；  
（5）若$R$、$S$是传递的，则$R^{-1}$，$R\cap S$也是传递的。"
定理5.12,定理,"['第五章 关系模型与理论', '§ 5.4 关系的性质闭包', '5.4.1  关系闭包的概念']","{'实体类型': '定理', '内容': '设R是非空集合A上的关系，则有r(R)=R∪R^0；s(R)=R∪R^-1'}",,3,"首先，我们考察关系的自反闭包。假设$R$ 是集合$A$ 上的二元关系，如果$R$ 不满足自反性，就说明集合$A$ 中存在某个元素$a.$,使得$\langle a,a\rangle\not\in R$，此时可以将关系R 进行调整或修改，避免这种情况的发生。具体地说，就是将序偶$\langle a,a\rangle$纳入到关系$R$ 由此产生一个新的关系$R^{\prime}$。一般地，如果对于$A$ 中的每个元素${x}$，都将$\langle x,x\rangle$纳入到关系$R$，由此产生新的关系$R^{\prime}$必然满足自反性。事实上，关系$R^{\prime}$是对关系$R$ 的一种扩充，使得扩充后的关系能够满足自反性。若能证明这种扩充是满足扩充目的最小扩充，则$R^{\prime}$就是关系$R$ 的自反闭包。  
可同理考察对称闭包。假设$R$ 是集合$A$ 上的二元关系，如果$R$ 不满足对称性，就说明集合$A$ 中存在两个元素$a$和$b$使得$\langle a,b\rangle\in R$，但$\langle b,a\rangle\not\in R$。此时，只需将$\langle b,a\rangle$纳入$R$ 中就可避免这种情况发生。因此，可以对$R$ 进行适当扩充构成其对称闭包。  
可类似考虑传递闭包的基本思想，不再赘述。下面给出这三个闭包的具体定义：  
【定义5.22】设$R$ 是集合$A$ 上的关系，若存在$A$ 上的另一个关系$R^{\prime}$，满足：  
（1）$R^{\prime}$是自反的（对称的、或传递的）  
（2）对$A$ 上任何自反（对称的、或传递）关系$R^{\prime\prime}$，如果$R\subseteq R^{\prime\prime}$，那么$R^{\prime}\subseteq R^{\prime\prime}$，则称${R^{\prime}}$为$R$的自反闭包（对称闭包或传递闭包），记为$r(R)(s(R)$或$t(R))$。  
下面定理给出了自反闭包和传递闭包的构造方法：  
【定理5.12】设$R$ 是非空集合$A$ 上的关系，则有：  
$r(R)=R\cup R^{0};\,\,\,s(R)=R\cup R^{-1}$  
由上述例题可得利用关系图求关系$R$ 闭包的方法：  
（1）检查$R$ 的关系图，在没有自环的结点处加上自环，可得$r(R)$的关系图；  
（2）检查$R$ 的关系图，将每条单向边全部改成双向边，可得$s(R)$的关系图；  
（3）检查$R$ 的关系图，从每个结点出发，找到其终点，如果该结点到其终点没有边相连，就加上此边，由此可得$t(R)$的关系图。"
定理5.2,定理,"['第五章 关系模型与理论', '§ 5.1 关系的数学模型', '5.1.1  序偶与笛卡尔积']","{'实体类型': '定理', '内容': 'A⊆B当且仅当A×C⊆B×C和C×A⊆C×B'}",,3,"要用数学方式表达关系模型，首先必须建立有一种有效的数学机制将来自相同集合或不同集合的两个元素绑定在一起，以表明它们之间具体某种特定的关系。为此，下面给出二元组的相关概念来实现这种机制。  
【定义5.1】假设𝐴和$B$是任意给定的两个集合，则对于分别来自这两个集合中的元素$x$和𝑦，可将它们组合成一个整体并称之为二元组。如果这个二元组为无序二元组，则称其为无序偶对，简称为无序偶，通常记为$(x,y)$；如果这个二元组为有序二元组，则称其为有序偶对，简称为序偶，通常记为$\langle x,y\rangle$，并称$\cdot x\in A$为第一元素，$y\in B$为第二元素。  
在关系的数学理论中，通常使用序偶的概念绑定具有某种确定联系的两个元素。事实上序偶的用途非常广泛，日常生活和工作中的很多问题或概念都可用序偶表示。例如，平面上点$A$ 的横坐标是$x$，纵坐标是$y$，可用序偶表示为$\langle x,y\rangle$，$x,y\in R$；合肥是安徽的省会、南京是江苏的省会，可分别用序偶表示为〈合肥, 安徽〉，〈南京, 江苏〉；数学书在桌上、英语书在床上，可分别用序偶表示为〈数学书, 桌上〉，〈英语书,床上〉。  
由序偶的定义容易知道，序偶可以看作是具有两个元素的集合，但序偶中的两个元素是具有确定次序的，如果两个含有两个元素的集合相等，并不意味着这两个集合元素构成的序偶相等，因此即使成立$\{a,b\}=\{b,a\}$，在$a\neq b$的情况下会有：成立$\langle a,b\rangle\neq\langle b,a\rangle$。例如，对于前述的序偶〈合肥, 安徽〉，从集合的角度看，显然有{合肥, 安徽}$\}=$ {安徽,合肥}，但是序偶〈合肥, 安徽〉和〈安徽, 合肥〉显然代表的是两个不同的含义：前者表示合肥是安徽的省会，前者表示安徽是合肥的省会。因此，有：〈合肥, 安徽〉 $\neq$〈安徽,合肥〉。  
下面给出两个序偶相等的具体定义：  
【定义5.2】假设$\langle a,b\rangle$和$\langle c,d\rangle$是任意给定的两个序偶，如果$a=b$，$c=d$，那称这两个序偶相等，记为：$\langle a,b\rangle=\langle c,d\rangle$。  
从上述定义可知，两个序偶相等当且仅当这两个序偶在对应位置上的元素相等。例如，若有$\langle2x-3y,3x+2y\rangle=\langle1,3\rangle$，则有$2x-3y=1$且$3x+2y=3$；反之亦然。  
显然，可将上述序偶及其相等的相关定义自然推广到多个元素的情形。例如，对于任意给定的三个元素$x,y,z$，则可根据如下递归方式定义由这三个元素组成的有序三元组：  
$$
\langle x,y,\mathrm{z}\rangle=\langle\langle x,y\rangle,\mathrm{z}\rangle\tag{5-1}
$$  
从上式可以看出，所谓有序三元组，其实就是序偶的序偶。一般地，可得到如下关于$^{\cdot n}$元有序组的相关定义：  
【定义5.3】由$n$个元素$a_{1}$ ,$a_{2},\dotsc,a_{n}$组成 $n$元有序组由$n-1$元有序组$\langle a_{1}\;\,,a_{2},\dots,a_{n-1}\rangle$和元素$a_{n}$组成的序偶，记作$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$。即：$\langle a_{1}\;\;,a_{2},\ldots,a_{n}\rangle=\langle\langle a_{1}\;\;,a_{2},\ldots,a_{n-1}\rangle,a_{n}\rangle$。  
【定义5.4】假设$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$和$\langle b_{1},b_{2},\dots,b_{n}\rangle$是任意给定的两个$ n$元有序组，如果$a_{i}=$$b_{i}$，$i=1,2,\dots,n$，则称它们相等，记为：$\langle a_{1}\,\ ,a_{2},\ldots,a_{n}\rangle=\langle b_{1},b_{2},\ldots,b_{n}\rangle\,.$。  
【定义5.5】设$A,B$是任意给定的两个集合，用$A$中任意一个元素为第一元素、$B$中任任意一个元素为第二元素构成的所有可能的序偶组成的集合，称为$A$ 与$B$ 的笛卡尔积，亦称为$A$ 与$B$ 的直积，记为$A\times B$。即有：$A\times B=\{\langle x,y\rangle|(x\in A)\land(y\in B)\}$。  
由上述定义可知，集合$A$ 与$B$ 的笛卡尔积运算结果$A\times B$仍是一个集合，并且$A\times B$中的每个元素都是一个序偶，序偶中第一个元素取自集合$A$、第二个元素取自集合$B$。  
假设根据笛卡尔积的定义，不难证明笛卡尔积运算满足如下几条基本性质：  
（1）假设$A$,$B$是任意给定的两个集合，则有：$A\times\emptyset=B\times\emptyset=\emptyset$；  
（2）假设 $A$, $B$ 是任意给定的两个集合，则有 $A\times B=\emptyset$ ，当且仅当 $A=\emptyset$ 或 $B=\emptyset$；  
（3）当$A,B$是有限集合时，有：$|A\times B|=|B\times A|=|A||B|$  
下面定理表明笛卡尔积运算对集合的并运算和交运算均满足分配律：  
【定理5.1】设$A$、$B$、$C$ 是任意集合，则有：  
$A\times(B\cup C)=(A\times B)\cup(A\times C);\quad A\times(B\cap C)=(A\times B)\cap(A\times C);$  
$(A\cup B)\times C=(A\times C)\cup(B\times C);\quad(A\cap B)\times C=(A\cup C)\times(B\times C)\,$。  
【定理5.2】设$A$、${B}、{C}$ 是任意集合且$C\neq\emptyset$，则有：
$$
A\subseteq B\Leftrightarrow(A\times C\subseteq B\times C);\,\,\,A\subseteq B\Leftrightarrow(C\times A\subseteq C\times B)
$$  
【定理5.3】设$A、\ B、C、D$为非空集合，则有：
$$
A\subseteq C\land B\subseteq D\Leftrightarrow A\times B\subseteq C\times D
$$  
【定理5.4】假设集合$\cdot A_{1},A_{2},\cdots,A_{n}$均为有限集合，则有：
$$
|A_{1}\times A_{2}\times\cdots\times A_{n}|=|A_{1}|\times|A_{2}|\times\cdots\times|A_{n}|
$$"
定理5.3,定理,"['第五章 关系模型与理论', '§ 5.1 关系的数学模型', '5.1.1  序偶与笛卡尔积']","{'实体类型': '定理', '内容': 'A⊆C且B⊆D当且仅当A×B⊆C×D'}",,3,"要用数学方式表达关系模型，首先必须建立有一种有效的数学机制将来自相同集合或不同集合的两个元素绑定在一起，以表明它们之间具体某种特定的关系。为此，下面给出二元组的相关概念来实现这种机制。  
【定义5.1】假设𝐴和$B$是任意给定的两个集合，则对于分别来自这两个集合中的元素$x$和𝑦，可将它们组合成一个整体并称之为二元组。如果这个二元组为无序二元组，则称其为无序偶对，简称为无序偶，通常记为$(x,y)$；如果这个二元组为有序二元组，则称其为有序偶对，简称为序偶，通常记为$\langle x,y\rangle$，并称$\cdot x\in A$为第一元素，$y\in B$为第二元素。  
在关系的数学理论中，通常使用序偶的概念绑定具有某种确定联系的两个元素。事实上序偶的用途非常广泛，日常生活和工作中的很多问题或概念都可用序偶表示。例如，平面上点$A$ 的横坐标是$x$，纵坐标是$y$，可用序偶表示为$\langle x,y\rangle$，$x,y\in R$；合肥是安徽的省会、南京是江苏的省会，可分别用序偶表示为〈合肥, 安徽〉，〈南京, 江苏〉；数学书在桌上、英语书在床上，可分别用序偶表示为〈数学书, 桌上〉，〈英语书,床上〉。  
由序偶的定义容易知道，序偶可以看作是具有两个元素的集合，但序偶中的两个元素是具有确定次序的，如果两个含有两个元素的集合相等，并不意味着这两个集合元素构成的序偶相等，因此即使成立$\{a,b\}=\{b,a\}$，在$a\neq b$的情况下会有：成立$\langle a,b\rangle\neq\langle b,a\rangle$。例如，对于前述的序偶〈合肥, 安徽〉，从集合的角度看，显然有{合肥, 安徽}$\}=$ {安徽,合肥}，但是序偶〈合肥, 安徽〉和〈安徽, 合肥〉显然代表的是两个不同的含义：前者表示合肥是安徽的省会，前者表示安徽是合肥的省会。因此，有：〈合肥, 安徽〉 $\neq$〈安徽,合肥〉。  
下面给出两个序偶相等的具体定义：  
【定义5.2】假设$\langle a,b\rangle$和$\langle c,d\rangle$是任意给定的两个序偶，如果$a=b$，$c=d$，那称这两个序偶相等，记为：$\langle a,b\rangle=\langle c,d\rangle$。  
从上述定义可知，两个序偶相等当且仅当这两个序偶在对应位置上的元素相等。例如，若有$\langle2x-3y,3x+2y\rangle=\langle1,3\rangle$，则有$2x-3y=1$且$3x+2y=3$；反之亦然。  
显然，可将上述序偶及其相等的相关定义自然推广到多个元素的情形。例如，对于任意给定的三个元素$x,y,z$，则可根据如下递归方式定义由这三个元素组成的有序三元组：  
$$
\langle x,y,\mathrm{z}\rangle=\langle\langle x,y\rangle,\mathrm{z}\rangle\tag{5-1}
$$  
从上式可以看出，所谓有序三元组，其实就是序偶的序偶。一般地，可得到如下关于$^{\cdot n}$元有序组的相关定义：  
【定义5.3】由$n$个元素$a_{1}$ ,$a_{2},\dotsc,a_{n}$组成 $n$元有序组由$n-1$元有序组$\langle a_{1}\;\,,a_{2},\dots,a_{n-1}\rangle$和元素$a_{n}$组成的序偶，记作$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$。即：$\langle a_{1}\;\;,a_{2},\ldots,a_{n}\rangle=\langle\langle a_{1}\;\;,a_{2},\ldots,a_{n-1}\rangle,a_{n}\rangle$。  
【定义5.4】假设$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$和$\langle b_{1},b_{2},\dots,b_{n}\rangle$是任意给定的两个$ n$元有序组，如果$a_{i}=$$b_{i}$，$i=1,2,\dots,n$，则称它们相等，记为：$\langle a_{1}\,\ ,a_{2},\ldots,a_{n}\rangle=\langle b_{1},b_{2},\ldots,b_{n}\rangle\,.$。  
【定义5.5】设$A,B$是任意给定的两个集合，用$A$中任意一个元素为第一元素、$B$中任任意一个元素为第二元素构成的所有可能的序偶组成的集合，称为$A$ 与$B$ 的笛卡尔积，亦称为$A$ 与$B$ 的直积，记为$A\times B$。即有：$A\times B=\{\langle x,y\rangle|(x\in A)\land(y\in B)\}$。  
由上述定义可知，集合$A$ 与$B$ 的笛卡尔积运算结果$A\times B$仍是一个集合，并且$A\times B$中的每个元素都是一个序偶，序偶中第一个元素取自集合$A$、第二个元素取自集合$B$。  
假设根据笛卡尔积的定义，不难证明笛卡尔积运算满足如下几条基本性质：  
（1）假设$A$,$B$是任意给定的两个集合，则有：$A\times\emptyset=B\times\emptyset=\emptyset$；  
（2）假设 $A$, $B$ 是任意给定的两个集合，则有 $A\times B=\emptyset$ ，当且仅当 $A=\emptyset$ 或 $B=\emptyset$；  
（3）当$A,B$是有限集合时，有：$|A\times B|=|B\times A|=|A||B|$  
下面定理表明笛卡尔积运算对集合的并运算和交运算均满足分配律：  
【定理5.1】设$A$、$B$、$C$ 是任意集合，则有：  
$A\times(B\cup C)=(A\times B)\cup(A\times C);\quad A\times(B\cap C)=(A\times B)\cap(A\times C);$  
$(A\cup B)\times C=(A\times C)\cup(B\times C);\quad(A\cap B)\times C=(A\cup C)\times(B\times C)\,$。  
【定理5.2】设$A$、${B}、{C}$ 是任意集合且$C\neq\emptyset$，则有：
$$
A\subseteq B\Leftrightarrow(A\times C\subseteq B\times C);\,\,\,A\subseteq B\Leftrightarrow(C\times A\subseteq C\times B)
$$  
【定理5.3】设$A、\ B、C、D$为非空集合，则有：
$$
A\subseteq C\land B\subseteq D\Leftrightarrow A\times B\subseteq C\times D
$$  
【定理5.4】假设集合$\cdot A_{1},A_{2},\cdots,A_{n}$均为有限集合，则有：
$$
|A_{1}\times A_{2}\times\cdots\times A_{n}|=|A_{1}|\times|A_{2}|\times\cdots\times|A_{n}|
$$"
定理5.4,定理,"['第五章 关系模型与理论', '§ 5.1 关系的数学模型', '5.1.1  序偶与笛卡尔积']","{'实体类型': '定理', '内容': '有限集合的笛卡尔积的基数等于各集合基数的乘积'}",,3,"要用数学方式表达关系模型，首先必须建立有一种有效的数学机制将来自相同集合或不同集合的两个元素绑定在一起，以表明它们之间具体某种特定的关系。为此，下面给出二元组的相关概念来实现这种机制。  
【定义5.1】假设𝐴和$B$是任意给定的两个集合，则对于分别来自这两个集合中的元素$x$和𝑦，可将它们组合成一个整体并称之为二元组。如果这个二元组为无序二元组，则称其为无序偶对，简称为无序偶，通常记为$(x,y)$；如果这个二元组为有序二元组，则称其为有序偶对，简称为序偶，通常记为$\langle x,y\rangle$，并称$\cdot x\in A$为第一元素，$y\in B$为第二元素。  
在关系的数学理论中，通常使用序偶的概念绑定具有某种确定联系的两个元素。事实上序偶的用途非常广泛，日常生活和工作中的很多问题或概念都可用序偶表示。例如，平面上点$A$ 的横坐标是$x$，纵坐标是$y$，可用序偶表示为$\langle x,y\rangle$，$x,y\in R$；合肥是安徽的省会、南京是江苏的省会，可分别用序偶表示为〈合肥, 安徽〉，〈南京, 江苏〉；数学书在桌上、英语书在床上，可分别用序偶表示为〈数学书, 桌上〉，〈英语书,床上〉。  
由序偶的定义容易知道，序偶可以看作是具有两个元素的集合，但序偶中的两个元素是具有确定次序的，如果两个含有两个元素的集合相等，并不意味着这两个集合元素构成的序偶相等，因此即使成立$\{a,b\}=\{b,a\}$，在$a\neq b$的情况下会有：成立$\langle a,b\rangle\neq\langle b,a\rangle$。例如，对于前述的序偶〈合肥, 安徽〉，从集合的角度看，显然有{合肥, 安徽}$\}=$ {安徽,合肥}，但是序偶〈合肥, 安徽〉和〈安徽, 合肥〉显然代表的是两个不同的含义：前者表示合肥是安徽的省会，前者表示安徽是合肥的省会。因此，有：〈合肥, 安徽〉 $\neq$〈安徽,合肥〉。  
下面给出两个序偶相等的具体定义：  
【定义5.2】假设$\langle a,b\rangle$和$\langle c,d\rangle$是任意给定的两个序偶，如果$a=b$，$c=d$，那称这两个序偶相等，记为：$\langle a,b\rangle=\langle c,d\rangle$。  
从上述定义可知，两个序偶相等当且仅当这两个序偶在对应位置上的元素相等。例如，若有$\langle2x-3y,3x+2y\rangle=\langle1,3\rangle$，则有$2x-3y=1$且$3x+2y=3$；反之亦然。  
显然，可将上述序偶及其相等的相关定义自然推广到多个元素的情形。例如，对于任意给定的三个元素$x,y,z$，则可根据如下递归方式定义由这三个元素组成的有序三元组：  
$$
\langle x,y,\mathrm{z}\rangle=\langle\langle x,y\rangle,\mathrm{z}\rangle\tag{5-1}
$$  
从上式可以看出，所谓有序三元组，其实就是序偶的序偶。一般地，可得到如下关于$^{\cdot n}$元有序组的相关定义：  
【定义5.3】由$n$个元素$a_{1}$ ,$a_{2},\dotsc,a_{n}$组成 $n$元有序组由$n-1$元有序组$\langle a_{1}\;\,,a_{2},\dots,a_{n-1}\rangle$和元素$a_{n}$组成的序偶，记作$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$。即：$\langle a_{1}\;\;,a_{2},\ldots,a_{n}\rangle=\langle\langle a_{1}\;\;,a_{2},\ldots,a_{n-1}\rangle,a_{n}\rangle$。  
【定义5.4】假设$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$和$\langle b_{1},b_{2},\dots,b_{n}\rangle$是任意给定的两个$ n$元有序组，如果$a_{i}=$$b_{i}$，$i=1,2,\dots,n$，则称它们相等，记为：$\langle a_{1}\,\ ,a_{2},\ldots,a_{n}\rangle=\langle b_{1},b_{2},\ldots,b_{n}\rangle\,.$。  
【定义5.5】设$A,B$是任意给定的两个集合，用$A$中任意一个元素为第一元素、$B$中任任意一个元素为第二元素构成的所有可能的序偶组成的集合，称为$A$ 与$B$ 的笛卡尔积，亦称为$A$ 与$B$ 的直积，记为$A\times B$。即有：$A\times B=\{\langle x,y\rangle|(x\in A)\land(y\in B)\}$。  
由上述定义可知，集合$A$ 与$B$ 的笛卡尔积运算结果$A\times B$仍是一个集合，并且$A\times B$中的每个元素都是一个序偶，序偶中第一个元素取自集合$A$、第二个元素取自集合$B$。  
假设根据笛卡尔积的定义，不难证明笛卡尔积运算满足如下几条基本性质：  
（1）假设$A$,$B$是任意给定的两个集合，则有：$A\times\emptyset=B\times\emptyset=\emptyset$；  
（2）假设 $A$, $B$ 是任意给定的两个集合，则有 $A\times B=\emptyset$ ，当且仅当 $A=\emptyset$ 或 $B=\emptyset$；  
（3）当$A,B$是有限集合时，有：$|A\times B|=|B\times A|=|A||B|$  
下面定理表明笛卡尔积运算对集合的并运算和交运算均满足分配律：  
【定理5.1】设$A$、$B$、$C$ 是任意集合，则有：  
$A\times(B\cup C)=(A\times B)\cup(A\times C);\quad A\times(B\cap C)=(A\times B)\cap(A\times C);$  
$(A\cup B)\times C=(A\times C)\cup(B\times C);\quad(A\cap B)\times C=(A\cup C)\times(B\times C)\,$。  
【定理5.2】设$A$、${B}、{C}$ 是任意集合且$C\neq\emptyset$，则有：
$$
A\subseteq B\Leftrightarrow(A\times C\subseteq B\times C);\,\,\,A\subseteq B\Leftrightarrow(C\times A\subseteq C\times B)
$$  
【定理5.3】设$A、\ B、C、D$为非空集合，则有：
$$
A\subseteq C\land B\subseteq D\Leftrightarrow A\times B\subseteq C\times D
$$  
【定理5.4】假设集合$\cdot A_{1},A_{2},\cdots,A_{n}$均为有限集合，则有：
$$
|A_{1}\times A_{2}\times\cdots\times A_{n}|=|A_{1}|\times|A_{2}|\times\cdots\times|A_{n}|
$$"
定理5.5,定理,"['第五章 关系模型与理论', '§ 5.2 关系的基本运算', '5.2.2 关系的复合运算']","{'实体类型': '定理', '内容': '设A、B、C和D是任意四个集合，R、S和T分别是从A到B、B到C和C到D的二元关系，I_A和I_B分别是A和B上恒等关系，则有：(1) (R∘S)∘T=R∘(S∘T); (2) I_A∘R=R∘I_B=R'}",,3,"日常生活和工作中很多关系问题仅用关系的集合运算不能得到有效的解决。例如：假设集合$𝐴$表示某家族的全部成员构成的集合，在$𝐴$上定义如下两个关系$R$和$𝑆$：  
$R$表示$A$上的兄弟关系，$\langle x,y\rangle\in R$,当且仅当$x$是$y$的兄弟;  
$S$表示 $A$ 上的父子关系，$\langle y,z\rangle\in S$,当且仅当$y$ 是$z$ 的父亲。  
则可通过元素$y$的中间媒介或传递作用，在$x$与$z$之间产生一个新的关系，即叔侄关系。换句话说，叔侄关系是由兄弟关系和父子关系的合成。  
![](images/8ed5b0cc3c8222133404e26aeb757d647b1fb51cdae3d0c7fbf0c3754976758e.jpg)
图5-7 叔侄关系图  
例如，假设在小说《红楼梦》中人物的兄弟关系为𝑅、父子关系为𝑆，则有：
$$
\begin{aligned}&R=\left\{\langle\text{贾宝玉},\text{贾环}\rangle,\langle\text{贾政},\textbf{贾赦}\rangle,\cdots\right\};\\&S=\left\{\langle\text{贾政},\text{贾宝玉}\rangle,\langle\text{贾政},\text{贾环}\rangle,\langle\textbf{贾赦 贾琏}\rangle,\cdots\right\}\end{aligned}
$$
如图5-7 所示，在上述$R$和$𝑆$这两个二元关系中，贾政和贾琏之间通过贾赦的中间媒介或传递作用建立了叔侄关系。一般地，将关系这种合成机制进行抽象，用数学语言进行表达，就得到如下关系复合运算的定义：  
【定义5.14】假设$A$、$B$、$C$ 是三个非空集合，$R$ 是从$A$ 到$B$ 的关系，$S$ 是从$B$ 到$C$的关系，则$R$ 与$S$ 的复合关系$R\circ S$定义为如下从$A$ 到$C$的关系：  
$$R\circ S=\{\langle x,z\rangle|x\in A\land z\in C\land(\exists y)(y\in B\land x R y\land y S z)\quad\text{(5-5)}$$  
运算“ ∘”称为复合运算。  
从上述定义可知：不是任意两个关系都能进行复合运算，当且仅当$R$ 的后域是$S$的前域时，$R$ 和$S$ 才可复合；$R\circ S$的前域是$R$ 的前域$A$，$R\circ S$的后域是$S$ 的后域$C$。  
任何一个关系都有集合、关系图和矩阵这三种表现形式，复合运算在这三种不同表现形式下分别具有相应的具体计算方法，下面分别介绍这三种复合计算方法。  
令$A=\{a_1,a_2,\cdots,a_m\},B=\{b_1,b_2,\cdots,b_n\},C=\{c_1,c_2,\cdots,c_t\},R$ 是$A$ 到$B$ 的关系，$S$ 是$B$ 到 $C$ 的关系，即有$R$$\subseteq{A}\times{B}$, $S$$\subseteq{B}\times{C}$, 则$R\circ S$可按下列方法进行计算.  
1 ．集合法    由复合运算的定义可知，对于任意的 $a_{i}\in A,c_{j}\in C$ ，若 $\langle a_{i},c_{j}\rangle\in R\circ S$ ，则 必然存在某个$b_{k}\in B$，使得$\langle a_{i},b_{k}\rangle\in R$并且$\langle b_{k},c_{j}\rangle\in S$。故对于$R$中每个给定的序偶$\langle a_{i},b_{k}\rangle$，要在$S$中寻遍第一元素为$b_{k}$的序偶$\langle b_{k},c_{j}\rangle$，若存在$\langle b_{k},c_{j}\rangle\in S$，则取$R$中$\langle a_{i},b_{k}\rangle$的第一元素，以及$S$中对应序偶$\langle b_{k},c_{j}\rangle$的第二元素，形成一个新的序偶$\langle a_{i},c_{j}\rangle$，该序偶即为$R\circ S$中的一个元素。同理可找出$R\circ S$中的所有元素。  
2. 关系图法  由复合运算的定义可知，对于分别属于关系$R$ 和$S$的两个序偶，它们之间能够复合的关键在于能够在这两个序偶之间找到一个桥梁$b_{k}$，使得$b_{k}$既是前一个序偶($R$中序偶)的第二元素，同时又是后一个序偶(S 中序偶)的第一元素。因此，在画复合关系的关系图时，首先应该在$R$ 和$S$ 这两个关系的关系图中搭起这个桥梁，然后拆掉中间的桥梁，直接联结经过该桥梁的两个结点，便可得到$R\circ S$的关系图。  
3.关系矩阵法  将$R$ 和$S$ 的关系矩阵做布尔积运算$\odot$，即可得到$\mathrm{~\tt~R~o~}S$的关系矩阵，然后根据该矩阵写出$R\circ S$中元素即可。也就是说，令$R$ 和$S$ 的关系矩阵分别为：
$$
M_{R}=\begin{pmatrix}\langle a_1,b_1\rangle&\langle a_1,b_2\rangle&\cdots\langle a_1,b_n\rangle\\\langle a_2,b_1\rangle&\langle a_2,b_2\rangle&\cdots\langle a_2,b_n\rangle\\\vdots\\\langle a_m,b_1\rangle\langle a_m,b_2\rangle&\cdots\langle a_m,b_n\rangle\end{pmatrix};\quad M_{S}=\begin{pmatrix}\langle b_1,c_1\rangle&\langle b_1,c_2\rangle&\cdots&\langle b_1,c_t\rangle\\\langle b_2,c_1\rangle&\langle b_2,c_2\rangle&\cdots&\langle b_2,c_t\rangle\\\vdots\\\langle b_n,b_1\rangle\langle b_n,c_2\rangle&\cdots\langle b_n,c_t\rangle\end{pmatrix}
$$
则有：
$$
M_{R\circ S}=M_{R}\odot M_{S}=\left(\begin{array}{c}{{\langle a_{1},c_{1}\rangle\ \langle a_{1},c_{2}\rangle\ \cdots\ \langle a_{1},c_{t}\rangle}}\\ {{\langle a_{2}.\,c_{1}\rangle\ \langle a_{2},c_{2}\rangle\ \cdots\ \langle a_{2},c_{t}\rangle}}\\ {{\vdots}}\\ {{\langle a_{m},c_{1}\rangle\langle a_{m},c_{2}\rangle\cdots\langle a_{m},c_{t}\rangle}}\end{array}\right)
$$  
【定理5.5】设$A$、$B$、$C$ 和$D$ 是任意四个集合，$R$、$S$和$T$ 分别是从$A$ 到$B,\ B$到$C$和$C$ 到$D$ 的二元关系，$I_{A}$和$I_{B}$分别是$A$ 和$B$ 上恒等关系，则有：
$$
(1) (R\circ S)\circ T=R\circ(S\circ T);\quad(2) I_A\circ R=R\circ I_B=R
$$  
下面的定理给出了关系的集合运算与复合运算之间的关系：复合运算对并运算具有完全的分配律，而复合运算对交运算只有有半分配律。  
【定理5.6】设$A$、$B$、$C$和$D$ 是任意四个集合，$R$ 是$A$ 到$B$ 的关系，$S_{1},\ S_{2}$是从$B$ 到$C$的关系，$T$是从$C$ 到$D$ 的关系，则有：  
（1）$R\circ(S_{1}\cup S_{2})=(R\circ S_{1})\cup(R\circ S_{2});\,\,\,(2)\,\,\,R\circ(S_{1}\cap S_{2})\subseteq(R\circ S_{1})\cap(R\circ S_{2});$ （3）$(S_{1}\cup S_{2})\circ T=(S_{1}\circ T)\cup(S_{2}\circ T);\ \ (4)\ \ (S_{1}\cap S_{2})\circ T\subseteq(S_{1}\circ T)\cap(S_{2}\circ T)。$  
上述定理和例题表明，复合运算对并运算具有完全的分配律，即分配律是以集合相等的方式出现，但复合运算对交运算不具备完全分配律，只有半分配律，也就是说，分配律是以集合包含的方式出现。如果要将关系的这些运算与数的相关运算做一些类比的话，那么关系的复合运算就比较类似于数或矩阵的乘法运算，而关系的并运算就比较类似于数或矩阵的加法运算。事实上，从复合运算和并运算的关系矩阵运算特点上，就可看出它们与数乘、数加以及矩阵乘、矩阵加的类似之处。"
定理5.6,定理,"['第五章 关系模型与理论', '§ 5.2 关系的基本运算', '5.2.2 关系的复合运算']","{'实体类型': '定理', '内容': '设A、B、C和D是任意四个集合，R是A到B的关系，S_1、S_2是从B到C的关系，T是从C到D的关系，则有：(1) R∘(S_1∪S_2)=(R∘S_1)∪(R∘S_2); (2) R∘(S_1∩S_2)⊆(R∘S_1)∩(R∘S_2); (3) (S_1∪S_2)∘T=(S_1∘T)∪(S_2∘T); (4) (S_1∩S_2)∘T⊆(S_1∘T)∩(S_2∘T)'}",,3,"日常生活和工作中很多关系问题仅用关系的集合运算不能得到有效的解决。例如：假设集合$𝐴$表示某家族的全部成员构成的集合，在$𝐴$上定义如下两个关系$R$和$𝑆$：  
$R$表示$A$上的兄弟关系，$\langle x,y\rangle\in R$,当且仅当$x$是$y$的兄弟;  
$S$表示 $A$ 上的父子关系，$\langle y,z\rangle\in S$,当且仅当$y$ 是$z$ 的父亲。  
则可通过元素$y$的中间媒介或传递作用，在$x$与$z$之间产生一个新的关系，即叔侄关系。换句话说，叔侄关系是由兄弟关系和父子关系的合成。  
![](images/8ed5b0cc3c8222133404e26aeb757d647b1fb51cdae3d0c7fbf0c3754976758e.jpg)
图5-7 叔侄关系图  
例如，假设在小说《红楼梦》中人物的兄弟关系为𝑅、父子关系为𝑆，则有：
$$
\begin{aligned}&R=\left\{\langle\text{贾宝玉},\text{贾环}\rangle,\langle\text{贾政},\textbf{贾赦}\rangle,\cdots\right\};\\&S=\left\{\langle\text{贾政},\text{贾宝玉}\rangle,\langle\text{贾政},\text{贾环}\rangle,\langle\textbf{贾赦 贾琏}\rangle,\cdots\right\}\end{aligned}
$$
如图5-7 所示，在上述$R$和$𝑆$这两个二元关系中，贾政和贾琏之间通过贾赦的中间媒介或传递作用建立了叔侄关系。一般地，将关系这种合成机制进行抽象，用数学语言进行表达，就得到如下关系复合运算的定义：  
【定义5.14】假设$A$、$B$、$C$ 是三个非空集合，$R$ 是从$A$ 到$B$ 的关系，$S$ 是从$B$ 到$C$的关系，则$R$ 与$S$ 的复合关系$R\circ S$定义为如下从$A$ 到$C$的关系：  
$$R\circ S=\{\langle x,z\rangle|x\in A\land z\in C\land(\exists y)(y\in B\land x R y\land y S z)\quad\text{(5-5)}$$  
运算“ ∘”称为复合运算。  
从上述定义可知：不是任意两个关系都能进行复合运算，当且仅当$R$ 的后域是$S$的前域时，$R$ 和$S$ 才可复合；$R\circ S$的前域是$R$ 的前域$A$，$R\circ S$的后域是$S$ 的后域$C$。  
任何一个关系都有集合、关系图和矩阵这三种表现形式，复合运算在这三种不同表现形式下分别具有相应的具体计算方法，下面分别介绍这三种复合计算方法。  
令$A=\{a_1,a_2,\cdots,a_m\},B=\{b_1,b_2,\cdots,b_n\},C=\{c_1,c_2,\cdots,c_t\},R$ 是$A$ 到$B$ 的关系，$S$ 是$B$ 到 $C$ 的关系，即有$R$$\subseteq{A}\times{B}$, $S$$\subseteq{B}\times{C}$, 则$R\circ S$可按下列方法进行计算.  
1 ．集合法    由复合运算的定义可知，对于任意的 $a_{i}\in A,c_{j}\in C$ ，若 $\langle a_{i},c_{j}\rangle\in R\circ S$ ，则 必然存在某个$b_{k}\in B$，使得$\langle a_{i},b_{k}\rangle\in R$并且$\langle b_{k},c_{j}\rangle\in S$。故对于$R$中每个给定的序偶$\langle a_{i},b_{k}\rangle$，要在$S$中寻遍第一元素为$b_{k}$的序偶$\langle b_{k},c_{j}\rangle$，若存在$\langle b_{k},c_{j}\rangle\in S$，则取$R$中$\langle a_{i},b_{k}\rangle$的第一元素，以及$S$中对应序偶$\langle b_{k},c_{j}\rangle$的第二元素，形成一个新的序偶$\langle a_{i},c_{j}\rangle$，该序偶即为$R\circ S$中的一个元素。同理可找出$R\circ S$中的所有元素。  
2. 关系图法  由复合运算的定义可知，对于分别属于关系$R$ 和$S$的两个序偶，它们之间能够复合的关键在于能够在这两个序偶之间找到一个桥梁$b_{k}$，使得$b_{k}$既是前一个序偶($R$中序偶)的第二元素，同时又是后一个序偶(S 中序偶)的第一元素。因此，在画复合关系的关系图时，首先应该在$R$ 和$S$ 这两个关系的关系图中搭起这个桥梁，然后拆掉中间的桥梁，直接联结经过该桥梁的两个结点，便可得到$R\circ S$的关系图。  
3.关系矩阵法  将$R$ 和$S$ 的关系矩阵做布尔积运算$\odot$，即可得到$\mathrm{~\tt~R~o~}S$的关系矩阵，然后根据该矩阵写出$R\circ S$中元素即可。也就是说，令$R$ 和$S$ 的关系矩阵分别为：
$$
M_{R}=\begin{pmatrix}\langle a_1,b_1\rangle&\langle a_1,b_2\rangle&\cdots\langle a_1,b_n\rangle\\\langle a_2,b_1\rangle&\langle a_2,b_2\rangle&\cdots\langle a_2,b_n\rangle\\\vdots\\\langle a_m,b_1\rangle\langle a_m,b_2\rangle&\cdots\langle a_m,b_n\rangle\end{pmatrix};\quad M_{S}=\begin{pmatrix}\langle b_1,c_1\rangle&\langle b_1,c_2\rangle&\cdots&\langle b_1,c_t\rangle\\\langle b_2,c_1\rangle&\langle b_2,c_2\rangle&\cdots&\langle b_2,c_t\rangle\\\vdots\\\langle b_n,b_1\rangle\langle b_n,c_2\rangle&\cdots\langle b_n,c_t\rangle\end{pmatrix}
$$
则有：
$$
M_{R\circ S}=M_{R}\odot M_{S}=\left(\begin{array}{c}{{\langle a_{1},c_{1}\rangle\ \langle a_{1},c_{2}\rangle\ \cdots\ \langle a_{1},c_{t}\rangle}}\\ {{\langle a_{2}.\,c_{1}\rangle\ \langle a_{2},c_{2}\rangle\ \cdots\ \langle a_{2},c_{t}\rangle}}\\ {{\vdots}}\\ {{\langle a_{m},c_{1}\rangle\langle a_{m},c_{2}\rangle\cdots\langle a_{m},c_{t}\rangle}}\end{array}\right)
$$  
【定理5.5】设$A$、$B$、$C$ 和$D$ 是任意四个集合，$R$、$S$和$T$ 分别是从$A$ 到$B,\ B$到$C$和$C$ 到$D$ 的二元关系，$I_{A}$和$I_{B}$分别是$A$ 和$B$ 上恒等关系，则有：
$$
(1) (R\circ S)\circ T=R\circ(S\circ T);\quad(2) I_A\circ R=R\circ I_B=R
$$  
下面的定理给出了关系的集合运算与复合运算之间的关系：复合运算对并运算具有完全的分配律，而复合运算对交运算只有有半分配律。  
【定理5.6】设$A$、$B$、$C$和$D$ 是任意四个集合，$R$ 是$A$ 到$B$ 的关系，$S_{1},\ S_{2}$是从$B$ 到$C$的关系，$T$是从$C$ 到$D$ 的关系，则有：  
（1）$R\circ(S_{1}\cup S_{2})=(R\circ S_{1})\cup(R\circ S_{2});\,\,\,(2)\,\,\,R\circ(S_{1}\cap S_{2})\subseteq(R\circ S_{1})\cap(R\circ S_{2});$ （3）$(S_{1}\cup S_{2})\circ T=(S_{1}\circ T)\cup(S_{2}\circ T);\ \ (4)\ \ (S_{1}\cap S_{2})\circ T\subseteq(S_{1}\circ T)\cap(S_{2}\circ T)。$  
上述定理和例题表明，复合运算对并运算具有完全的分配律，即分配律是以集合相等的方式出现，但复合运算对交运算不具备完全分配律，只有半分配律，也就是说，分配律是以集合包含的方式出现。如果要将关系的这些运算与数的相关运算做一些类比的话，那么关系的复合运算就比较类似于数或矩阵的乘法运算，而关系的并运算就比较类似于数或矩阵的加法运算。事实上，从复合运算和并运算的关系矩阵运算特点上，就可看出它们与数乘、数加以及矩阵乘、矩阵加的类似之处。"
定理6.1,定理,"['§ 6.1 等价关系与元素分类', '6.1.2 集合的划分与商集', '第六章 特殊关系模型', '6.1.1  等价关系与等价类']","{'实体类型': '定理', '内容': '设$R$是非空集合$𝐴$上的等价关系，对于任意$x,y\\\\in A$，成立：（1）$\\\\left[x\\\\right]_{R}\\\\neq\\\\emptyset$且$[x]_{R}\\\\subseteq A$；（2）若$\\\\langle x,y\\\\rangle\\\\in R$，则$[x]_{R}=[y]_{R}$；（3）若$\\\\langle x,y\\\\rangle\\\\not\\\\in R$，则$[x]_{R}\\\\cap[y]_{R}=\\\\emptyset$；（4）$\\\\mathsf{U}_{x\\\\in A}[x]_{R}=A$；等价关系的所有等价类组成的集族构成集合的划分', '结论': '等价关系与商集之间的一一对应关系', 'name': '定理6.1'}",,3,"如前所述，集合的相等关系、直线的平行关系、多边形的全等关系、学生同学关系、整数的同余关系等等，它们都满足自反性、对称性和传递性这三条基本性质。不难看出，这些关系均是表示相同、相等、平等、一致等含义的关系。据此得到等价关系的定义：  
【定义6.1】假设𝐴是任一给定的非空集合，$R$是$𝐴$上的一个二元关系，如果$𝑅$满足自反性、对称性和传递性，则称$𝑅$是一个等价关系。此时，对于$𝐴$中任意两个元素${x}$和$y$，如果$\langle x,y\rangle\in$$R$，则称$x$与𝑦等价，记为$x{\sim}y$。  
从定义可知：关系$R$是等价关系当且仅当$𝑅$同时具备自反性、对称性和传递性；关系$𝑅$不是等价关系当且仅当$𝑅$不具备自反性或对称性或传递性。因此，等价关系的定义是判断关等价关系的一个很好判据。  
显然， 上述每个等价类其实就相当于例题 6.4  中等价关系图的每个完全子图或等价关系矩阵的每个子矩阵块。据此给出如下等价类的一般定义：  
【定义6.2】设$R$是非空集合𝐴上的等价关系，对任意$x\in A$，称下列集合：  
$$
[x]_{R}=\{y|y\in A\land\langle x,y\rangle\in R\}
$$  
为$𝑥$关于$𝑅$的等价类，或称为由$x$生成的一个$R $等价类，并称$x$称$[x]_{R}$的生成元或代表元。  
由上述定义可知等价类有以下性质：  
（1）等价类产生的前提是关系$R$必须是等价关系；  
（2）$𝐴$中所有与$$x$$有关系$𝑅$的元素$𝑦$构成了$[x]_{R}$；  
（3）$𝐴$中任意一个元素一定对应一个由其生成的等价类；  
（4）$R$具有自反性意味着对任意$x\in A$，$[x]_{R}$非空。 （5）$R$具有对称性意味着对任意$x,y\in A$，若有 $y\in[x]_{R}$，则有$x\in[y]_{R}$  
从例6.1.2 知，模3 同余关系是一个等价关系，可求出$A=\{1,\!2,\!3,\!4,\!5,\!6,\!7\}$中每个元素的$[1]_{R}=[4]_{R}=[7]_{R}=\{1,4,7\};\,\,\,[2]_{R}=[5]_{R}=\{2,5\};\,\,\,[3]_{R}=\{6\}_{\circ}$  
综合以上分析，可以看出等价类具有下性质：  
【定理6.1】设$R$是非空集合$𝐴$上的等价关系，对于任意$x,y\in A$，成立：  
（1）$\left[x\right]_{R}\neq\emptyset$且$[x]_{R}\subseteq A$；           （2）若$\langle x,y\rangle\in R$，则$[x]_{R}=[y]_{R}$；  
（3）若$\langle x,y\rangle\not\in R$，则$[x]_{R}\cap[y]_{R}=\emptyset$； （4）$\mathsf{U}_{x\in A}[x]_{R}=A\,。$  
上述定理表明，对于非空集合$𝐴$上的等价关系$R$，可用$R$的所有等价类将集合$𝐴$划分成若干个互不相交的子集合，每个子集合就是一个等价类。接下来讨论这种划分问题。"
定理6.2,定理,"['第六章 特殊关系模型', '§ 6.1 等价关系与元素分类', '6.1.2 集合的划分与商集']","{'实体类型': '定理', '内容': '非空集合的任一划分可构造出相应的等价关系', '结论': '集合划分与等价关系之间的一一对应关系'}",,3,"在日常生活和工作中，我们经常将比较大的集合划分为若干比较小的集合，以便于分门别类地处理或管理，例如对于一个具有几千学生规模的学校，需将所有学生的集合划分为几十个班级，然后以每个班级为单位进行管理；再如，将中国的所有领土划分为省或直辖市等若干行政区域，这样每个中国人都可以归属到某个确定的行政区域。不难看出，对集合的一种划分其实就是实现了对集合中元素的一种分类，不同的划分构成了对集合元素的不同分类。例如，我们既可将所有人划分为男人、女人这两类，也可将所有人划分为小孩、年轻人、中年人和老年人这几类。分类是一种非常基本的问题求解策略。例如人工智能中的人脸识别、语言识别、自然语言理解、知识发现、机器博弈等很多问题都可归结为分类问题，从而将对该类问题的求解转化为对分类器的设计。设计分类器一直是科学理论与工程应用研究的热门前沿课题，例如深度学习模型中的卷积神经网络就是一个有效的分类器。下面我们从等价关系和集合划分的角度来学习集合中元素分类的基本知识。首先给出集合划分的定义：  
【定义6.3】假设$𝐴$任一非空集合，$S$是$𝐴$的非空子集$S_{i}$组成的集族$S=\{S_{1},S_{2},\cdots,S_{m}\}$，  且满足:$S_{i}\cap S_{j}=\emptyset\,\,\,{\mathrm{;}}\,\,\,S_{1}\cup S_{2}\cup\dots\cup S_{m}=\,\,\,A\,,$，则称$𝑆$是$𝐴$的一个划分, $S_{1},S_{2},\cdots,S_{m}$分别称为划分$𝑆$的一个划分块或划分类。  
设$R$是非空集合$ A$上的等价关系，则有定理6.1 知等价关系$R$的所有等价类组成的集族构成了集合$𝐴$的划分，我们称这个集族为集合$𝐴$关于$R$的商集，具体定义如下：  
【定义6.4】假设$𝐴$任一非空集合，$R$是$𝐴$上的一个等价关系，称$𝑅$的所有等价类组成的集族为集合$𝐴$关于等价关系$R$的商集，记为${A}/R$。即有：$A/R=\{[x]_{R}|x\in A\}$。  
我们知道商的概念与除法有关，比如把一块蛋糕平均分成四份，可以从不同的角度来看这件事：从算术的角度看，就是1 用4 除，得到的每份$1/4$ 就是商；集合的角度看，所谓商就是将一个大的集合分成了四个小的非空集合，这正是商集概念的含义。  
下面我们介绍两个特殊的等价关系及其商集：  
（1）非空集合𝐴上的完全关系$E_{A}$显然是$𝐴$的一个等价关系。由于对$\forall x\in A$有$[x]_{E_{A}}=A$，故$E_{A}$的商集就是以𝐴为元素的集合，即有$A/E_{A}=\{A\}$。  
（2）非空集合$𝐴$上的恒等关系$I_{A}$显然是$𝐴$的一个等价关系。由于对$\forall x\in A$有$\left[x\right]_{I_{A}}=\left\{x\right\}$，故$I_{A}$的商集就是所有以$\{x\}$为元素组成的集合，即有$A/I_{A}=\left\{\{x\}|x\in A\right\}$。  
从集合划分角度看，完全关系$E_{A}$给了集合$𝐴$的一个最粗略划分，即将整个$𝐴$作为一个划分块，而恒等关系$I_{A}$给出了$𝐴$的一个最细致划分，即分别将$𝐴$中每个元素作为一个一划分块。  
如前所述，非空集合$𝐴$上的每个等价关系$R$都会产生一个商集$A/R$，而且这个商集正好构  
成集合$𝐴$的一个划分。现在考虑一个相反的问题，非空集合$𝐴$上的任何一个划分是否能够产生一个与之相应的等价关系？下面的定理给出了肯定的回答：  
【定理6.2】 假设$\{S=\{S_{1},S_{2},\cdots,S_{m}\}$是非空集合𝐴一个划分，则如下关系  
$$
R=(S_{1}\times S_{1})\cup(S_{2}\times S_{2})\cup\cdots\cup(S_{m}\times S_{m})\quad\text{(6-2)}
$$  
是$A$上的等价关系，称之为由该划分所导出的等价关系。  
上述定理表明，对于非空集合上的任一划分，都可根据该划分构造出一个相应的等价关系，并给出了等价关系的具体构造方法。由此可知，非空集合上的划分与等价关系之间构成了一一对应的关系，即：非空集合的每一种划分都对应着该集合上的一个等价关系；反之，非空集合上每个等价关系都对应着这该集合的一个划分。因此，今后我们既可用集合划分方法解决等价关系问题，也可用等价关系方法解决集合划分问题。或者说，既可用元素分类方法解决等价关系问题，也可用等价关系方法元素分类问题。"
定理6.3,定理,"['第六章 特殊关系模型', '§ 6.2 相容关系与元素聚类', '6.2.1 相容关系与相容类']","{'实体类型': '定理', '内容': '设𝑅是非空集合𝐴上的一个相容关系，𝐶是𝑅的一个相容类，那么必存在𝑅的一个最大相容类𝐶𝑅，使得𝐶⊆𝐶𝑅'}",,3,"相容关系表示的是一种求同存异的关系，对象之间有一些共同点但不完全相同。现在我们从数学的角度来考察相容关系。如前所述，人与人之间的朋友关系、英文单词之间存在共同字母的关系等都可看成是相容关系。不难发现，这些相容关系都满足自反性和对称性，但不满足传递性。由此得到如下关于相容关系的定义：  
【定义6.5】设$𝑅$为非空集合$𝐴$上的关系，若$R$满足自反性和对称性，则称$𝑅$为$𝐴$上的一个相容关系。此时，对于$𝐴$中任意两个元素$x$和𝑦，若$\langle x,y\rangle\in R$，则称$x$与𝑦相容，记为$x\approx y$。  
根据上述定义，不难发现所有的等价关系都可以看成是一种特殊的相容关系，即满足传递性的相容关系，但相容关系不一定是等价关系。  
与等价关系中等价类的概念类似，对于非空集合$𝐴$上的相容关系$R$，将𝐴中一些彼此具有相容关系$R$的元素放在一起构成𝐴的一个子集，由此得到如下相容类的概念：  
【定义6.6】设$ R$是非空集合$𝐴$上的一个相容关系，集合$C$是$𝐴$的某个子集，若对于任意的$x,y\in C$都有$\langle x,y\rangle\in R$，则称$C$是由相容关系$R$的一个相容类。  
例如，在例题6.16 中，$\{a\},\{a,e\},\{b,c\}$等都是$R$的相容类，$\{b,c\}\cup\{d\}=\{b,c,d\}$也是𝑅的相容类，但$\{a,e\}$与任何非空集合的并集都不再是$R$的相容类，此时称$\{a,e\}$为$R$的一个最大相容类，其具体定义如下：  
【定义6.7】设$R$是非空集合$𝐴$上的一个相容关系，$C$是$R$的一个相容类，若在$C$中添加$𝐴$的任何其他元素后，就不再构成相容类，则称$C$为$R$ 的一个最大相容类，记为$C_{R}$。  
例如，在例题6.16 中，$\{a,e\}$和$\{b,c,d\}$都是$R$ 的一个最大相容类。可用相容关系的简化关系图求最大相容类，具体方法如下：  
（1）图中最大完全多边形顶点构成的集合是最大相容类。  
（2）图中每个孤立结点是构成的集合分别是一个最大相容类。  
（3）如果图中某条边不是任何一个完全多边形的边，则该边的两个端点构成的集合是一个最大相容类。  
【定理6.3】设$R$是非空集合$𝐴$上的一个相容关系， $C$是$R$的一个相容类，那么必存在𝑅的一个最大相容类$C_{R}$，使得$C\subseteq C_{R}$。"
定理6.4,定理,"['第六章 特殊关系模型', '§ 6.2 相容关系与元素聚类', '6.2.2  集合的覆盖']","{'实体类型': '定理', '内容': '设R是非空集合A上的一个相容关系，由R所有最大相容类为元素构成的集合可以构成A的一个覆盖，并称之为A的一个完全覆盖'}",,3,"我们知道，集合上的任何一个等价关系都可以确定该集合的一个划分。那么，集合上的任何一个相容关系是否也能确定该集合的一个划分呢？答案显然是否定的。因为任何一个等价关系都是相容关系，但是相容关系不一定是等价关系。既然显然关系不一定能够对集合产生一个划分，那么它对集合能产生什么另外的效果呢？现在就来考察这个问题。  
在对集合的划分过程中，要求不同划分块之间的交集为空集，也就是说不同划分块之间不能有共同部分。现在取消这个限制，由此得到如下关于集合覆盖的概念：  
【定义6.8】假设$𝐴$任一非空集合，$Q$是$𝐴$的非空子集$Q_{i}$组成的集族$\begin{array}{r}{\boldsymbol{ Q}=\{Q_{1},Q_{2},\cdots,Q_{m}\},}\end{array}$，且满足$Q_{1}\cup Q_{2}\cup\cdots\cup Q_{m}=A$，则称$ Q$是$𝐴$的一个覆盖, $Q_{1},Q_{2},\cdots,Q_{m}$分别称为覆盖$Q$的一个 覆盖块或覆盖类。  
从上述定义可以看出，划分一定是覆盖，但覆盖不一定是划分。例如，在$A=\{1,\!2,\!3\}$的如下子集中，$A_{1},A_{2},A_{3}.$,是覆盖，$A_{1},A_{2}$,是覆盖也是划分，$A_{4}$既不是覆盖也不是划分。  
$$
A_{1}=\big\{\{1\},\{2\},\{3\}\big\},A_{2}=\big\{\{1,2\},\{3\}\big\},A_{3}=\big\{\{1,2\},\{2,3\}\big\},A_{4}=\big\{\{1\},\{3\}\big\}
$$  
设$ R$是非空集合$𝐴$上的一个相容关系，下面的定理表明，以$R$的所有最大相容类为元素构成的集合可以能够构成$𝐴$的一个覆盖，并由此到完全覆盖的概念：  
【定理6.4】设$\cdot R$是非空集合𝐴上的一个相容关系，由$R$所有最大相容类为元素构成的集合可以构成𝐴的一个覆盖，并称之为𝐴的一个完全覆盖，记为$C_{R}(A)$。  
【定理6.5】设$\boldsymbol{Q}=\{\;\boldsymbol{Q}_{1},\boldsymbol{Q}_{2},\cdots,\boldsymbol{Q}_{m}\},$为集合$𝐴$的任一覆盖，则由该覆盖确定的关系：  
$$
R=(Q_{1}\times Q_{1})\cup(Q_{2}\times Q_{2})\cup\cdots\cup(Q_{m}\times Q_{m})\quad\text{(6-3)}
$$  
是$𝐴$上的相容关系，称之为由该覆盖所导出的相容关系。  
上述定理表明了对于非空集合$𝐴$上的任意一个覆盖，都可以构造出相应的一个相容关系。但是，不同的覆盖有可能产生相同的相容关系。例如，对于集合$A=\{1,\!2,\!3,\!4,\!5\}$上的两个覆盖{{1,2,3}, {3,4}}和{{1,2}, {2,3},{1,3},{3,4}}，易知它们产生的相容关系均为：  
$$
R=\{\langle1,1\rangle,\langle1,2\rangle,\langle2,1\rangle,\langle2,2\rangle,\langle2,3\rangle,\langle3,2\rangle,\langle1,3\rangle,\langle3,1\rangle,\langle3,3\rangle,\langle4,4\rangle,\langle3,4\rangle,\langle4,3\rangle\}
$$  
因此，非空集合$𝐴$上的相容关系与$𝐴$上的覆盖之间不是一一对应的关系。但是，对于$𝐴$上任意一个给定的相容关系$R$，其所有最大相容类$C_{R}$构成的集合是唯一确定的，因而由$R$所有最大相容类$C_{R}$为元素构成的𝐴最大覆盖$C_{R}(A)$也是唯一确定的。也就是说，非空集合$𝐴$上的每  
个相容关系唯一确定$𝐴$上的一个完全覆盖。"
定理6.5,定理,"['第六章 特殊关系模型', '§ 6.2 相容关系与元素聚类', '6.2.2  集合的覆盖']","{'实体类型': '定理', '内容': '设Q={Q_1, Q_2, ..., Q_m}为集合A的任一覆盖，则由该覆盖确定的关系R=(Q_1×Q_1)∪(Q_2×Q_2)∪...∪(Q_m×Q_m)是A上的相容关系，称之为由该覆盖所导出的相容关系'}",,3,"我们知道，集合上的任何一个等价关系都可以确定该集合的一个划分。那么，集合上的任何一个相容关系是否也能确定该集合的一个划分呢？答案显然是否定的。因为任何一个等价关系都是相容关系，但是相容关系不一定是等价关系。既然显然关系不一定能够对集合产生一个划分，那么它对集合能产生什么另外的效果呢？现在就来考察这个问题。  
在对集合的划分过程中，要求不同划分块之间的交集为空集，也就是说不同划分块之间不能有共同部分。现在取消这个限制，由此得到如下关于集合覆盖的概念：  
【定义6.8】假设$𝐴$任一非空集合，$Q$是$𝐴$的非空子集$Q_{i}$组成的集族$\begin{array}{r}{\boldsymbol{ Q}=\{Q_{1},Q_{2},\cdots,Q_{m}\},}\end{array}$，且满足$Q_{1}\cup Q_{2}\cup\cdots\cup Q_{m}=A$，则称$ Q$是$𝐴$的一个覆盖, $Q_{1},Q_{2},\cdots,Q_{m}$分别称为覆盖$Q$的一个 覆盖块或覆盖类。  
从上述定义可以看出，划分一定是覆盖，但覆盖不一定是划分。例如，在$A=\{1,\!2,\!3\}$的如下子集中，$A_{1},A_{2},A_{3}.$,是覆盖，$A_{1},A_{2}$,是覆盖也是划分，$A_{4}$既不是覆盖也不是划分。  
$$
A_{1}=\big\{\{1\},\{2\},\{3\}\big\},A_{2}=\big\{\{1,2\},\{3\}\big\},A_{3}=\big\{\{1,2\},\{2,3\}\big\},A_{4}=\big\{\{1\},\{3\}\big\}
$$  
设$ R$是非空集合$𝐴$上的一个相容关系，下面的定理表明，以$R$的所有最大相容类为元素构成的集合可以能够构成$𝐴$的一个覆盖，并由此到完全覆盖的概念：  
【定理6.4】设$\cdot R$是非空集合𝐴上的一个相容关系，由$R$所有最大相容类为元素构成的集合可以构成𝐴的一个覆盖，并称之为𝐴的一个完全覆盖，记为$C_{R}(A)$。  
【定理6.5】设$\boldsymbol{Q}=\{\;\boldsymbol{Q}_{1},\boldsymbol{Q}_{2},\cdots,\boldsymbol{Q}_{m}\},$为集合$𝐴$的任一覆盖，则由该覆盖确定的关系：  
$$
R=(Q_{1}\times Q_{1})\cup(Q_{2}\times Q_{2})\cup\cdots\cup(Q_{m}\times Q_{m})\quad\text{(6-3)}
$$  
是$𝐴$上的相容关系，称之为由该覆盖所导出的相容关系。  
上述定理表明了对于非空集合$𝐴$上的任意一个覆盖，都可以构造出相应的一个相容关系。但是，不同的覆盖有可能产生相同的相容关系。例如，对于集合$A=\{1,\!2,\!3,\!4,\!5\}$上的两个覆盖{{1,2,3}, {3,4}}和{{1,2}, {2,3},{1,3},{3,4}}，易知它们产生的相容关系均为：  
$$
R=\{\langle1,1\rangle,\langle1,2\rangle,\langle2,1\rangle,\langle2,2\rangle,\langle2,3\rangle,\langle3,2\rangle,\langle1,3\rangle,\langle3,1\rangle,\langle3,3\rangle,\langle4,4\rangle,\langle3,4\rangle,\langle4,3\rangle\}
$$  
因此，非空集合$𝐴$上的相容关系与$𝐴$上的覆盖之间不是一一对应的关系。但是，对于$𝐴$上任意一个给定的相容关系$R$，其所有最大相容类$C_{R}$构成的集合是唯一确定的，因而由$R$所有最大相容类$C_{R}$为元素构成的𝐴最大覆盖$C_{R}(A)$也是唯一确定的。也就是说，非空集合$𝐴$上的每  
个相容关系唯一确定$𝐴$上的一个完全覆盖。"
定理7.1,定理,"['第七章 函数与特殊函数', '§ 7.1 函数的基本概念', '7.1.1 函数的集合定义']","{'实体类型': '定理', '内容': '设A和B是任意两个非空有限集合，则从A到B一共有|B|^|A|种不同的函数'}",,3,"在初等数学或高等数学中，函数的概念从变量角度提出，而且主要局限于在实数集。计算机相关领域处理的对象除了实数之外，还有很多其它对象，例如矩阵、向量、命题等等，而且主要面对的是各种可数的离散对象。为此，需要扩展初等数学或高等数学中函数概念的含义，从集合与关系的角度给函数下一个更加本质性的定义，具体如下：  
【定义7.1】设$𝐴$和$B$是任意两个非空集合，$f$是从$𝐴$到$B$的关系。若对$\forall x\in A$都存在唯一的$y\in B$，满足$\langle x,y\rangle\in f$，则称关系$f$为从$𝐴$到$B$的函数关系，简称为函数或映射,记为 $f\!:\!A\longrightarrow$  
$B$或$y=f(x)$，并称$x$为$f$的自变量或源点，$𝑦$为$ x$在$f$下的函数值或像点。集合$𝐴$称为$𝑓$的定义域，记为$dom$ $f=A$，所有像点组成的集合称为$f$的值域或$f$的像，记为$ran $$f$或$f(A)$。  
从上述定义可以看出，函数$f$是从集合$𝐴$到$B$的一种特殊二元关系，这种二元关系所包含序偶的第一元素为自变量，第二元素为因变量或函数值。函数的定义域就是关系的前域$𝐴$，要求关系中所有序偶的第一元素互不相同并且要取遍集合$𝐴$中的每个元素。作为刻画作为函数的本质单值特征，要求对于关系中的任意两个序偶，若它们的第一元素相同，则第二元素必须相同。具体地说，如果一个从集合$𝐴$到$B$二元关系$f$，那么它必须满足如下几个性质：  
(1)$\langle x,y\rangle\in f\Leftrightarrow y=f(x);\qquad\mathrm{(2)}\ \langle x,y\rangle\in f\wedge\langle x,z\rangle\in f\Rightarrow y=z;$  
（3）$|f|=|A|$； （4）$f(x)$表示一个变值，$f$代表一个集合，故$f\neq f(x)$  
如果关系$f$具备下面两种情况之一，那么$f$就不是函数关系：  
（1）存在元素$a\in A$,在$B$中没有像；（2）存在元素$a\in A$, 在$ B$中至少有两个像。  
例如，关系$\begin{array}{r}{F_{1}=\{\langle x_{1},y_{1}\rangle,\langle x_{2},y_{1}\rangle,\langle x_{3},y_{2}\rangle,\langle x_{4},y_{3}\rangle\}}\end{array}$是函数，而如下关系：
$$
F_{2}=\{\langle x_{1},y_{1}\rangle,\langle x_{2},y_{1}\rangle,\langle x_{3},y_{2}\rangle,\langle x_{1},y_{2}\rangle\}
$$  
则不是函数，因为同时有$\langle x_{1},y_{1}\rangle\in F_{2}$和$\langle x_{1},y_{2}\rangle\in F_{2}$  
由上述例题可知，函数作为一种特殊关系或特殊集合，其集合运算的结果可能不再是函数。因此，要慎用函数的集合运算。另一方面，由于函数是一种特殊子集，因此可用集合相等的概念来定义两个函数相等，具体定义如下：  
【定义7.2】设$𝐴$和$B$是任意两个非空集合，$f,g$是两个从$A$到$B$的函数关系，如果$f$和$g$相互包含，即有$f\subseteq g\wedge g\subseteq f$，则称函数$f$和函数$g$相等，记为$f=g$。换句话说，如果$dom $$f=$$dom$ $g$且对$\forall x\in\mathsf{d o m}$ $f=\mathrm{dom}$ $g$有$f(x)=g(x)$，称$f$与$g$相等。  
从上述定义可以看出，两个函数相等不仅要求它们的对应关系相等，而且要求它们的定义域也要相同，两者缺一不可。  
现考察有限集合上函数的计数问题，即算出有限集合上有多少种不同函数。设集合$ A=$$\{a_{1},a_{2},\cdots,a_{n}\}$，$B=\{b_{1},b_{2},\cdots,b_{m}\}$，则要确定一个从$𝐴$到$B$的函数$ f$，就必须对$𝐴$中每个元素$a_{i}$，在$B$中找到一个唯一确定的元素$b_{m_{i}}$与之对应。显然，对于$𝐴$中每个元素$a_{i}$都有$|B|=m$种选择$b_{m_{i}}$的方式。而集合𝐴中共有$|A|=n$个元素，故根据乘法原理，得到所有方式的组合数为$m^{n}$或$|B|^{|A|}$种。即从$A$到$B$的不同函数一共有$|B|^{|A|}$种。由此得到如下定理：  
【定理7.1】设$𝐴$和$B$是任意两个非空有限集合，则从$A$到$B$一共有$|B|^{|A|}$种不同的函数。  
根据上述定理，可得到如下函数集定义及其表示方法：  
【定义7.3】设$𝐴$和$B$是任意两个非空集合，将从$A$到$B$的一切函数构成的集合称为从$𝐴$到$B$的函数集或函数空间，记为$B^{A}$。即有： $B^{A}=\{f|f\colon\ A\to B\}.$。  
根据上述定义，当$𝐴$和$B$是非空有限集合时，显然有：$|B^{A}|=|B|^{|A|}$  
通过以上分析不难发现，当𝐴和$B$为有限集时，函数和一般关系具有以下区别：  
（1）个数差异：从$𝐴$到$B$的不同关系有$2^{|A|\times|B|}$个，从$A$到$B$的不同函数仅有$|B|^{|A|}$个。  
（2）基数不同：每个函数基数均为$|A|$即$|f|=|A|$，关系的基数却为从0 到$\vert A\vert\times\vert B\vert$  
（3）第一元素的差别：关系的第一个元素可以相同，函数的第一个元素不能相同。  
下面进一步考察函数对定义域子集的映射性质，首先给出如下子集像的相关概念：  
【定义7.4】设$𝐴$和$B$是任意给定的两个非空集合，$A_{1}$和$B_{1}$分别是$𝐴$和$B$的任意两个非空子集合，即有$A_{1}\subseteq A,B_{1}\subseteq B$。$f$是一个从$𝐴$和$B$函数，即$f\colon A\to B$。  
（1）令$f(A_{1})=\{f(x)|x\in A_{1}\}$，称$f(A_{1})$为$|A_{1}$在$f$下的像。当$A_{1}=A$时，$f(A)$为$f$的像。  
（2）令$ f^{-1}(B_{1})=\{x|x\in A\Lambda f(x)\in B_{1}\}$，称$f^{-1}(B_{1})$为$B_{1}$在$f$下的完全原像。  
在上述定义中显然有：$f(A_{1})\subseteq B$且$f^{-1}(B_{1})\subseteq A$。  
下面定理给出了子集像的集合运算性质：  
【定理7.2】设$𝐴$和$B$是任意给定的两个非空集合，$X$和$𝑌$是集合$ A$的任意两个非空子集，即有$X\subseteq A,Y\subseteq A$。$f$是一个从$A$和$B$函数，即$f\colon A\to B$。则有：  
$$
(1)f(X\cup Y)=f(X)\cup f(Y);\ \ (2)\ \,f(X\cap Y)\subseteq f(X)\cap f(Y)
$$  
上述定理的第（2）结论等号不成立。  
事实上，设$A=\{a,b,c\}$，$B=\{1,\!2,\!3\}$，$f\colon X\to Y$为：$f(a)=1$，$f(b)=f(c)=2.$令$X=\{a,b\}$，$Y=\{c\}$，则有：$A\cap B=\emptyset$，$f(A\cap B)=\emptyset$。但是：  
$$
f(A)\ \cap f(B)=\{1,2\}\cap\{2\}\neq\emptyset
$$  
故$f(A)\ \cap f(B)\ \neq f(A\cap B)$。这表明只能成立：$f(A\cap B)\subseteq f(A)\cap f(B)\,。$  
至此，我们从二元关系的角度给了函数相关概念的本质定义，并以关系模型为基本工具分析讨论了函数的若干基本性质，为函数理论奠定了一个比较坚实的数学基础。下面就从以上函数概念及基本性质为出发点进一步介绍和讨论函数的相关理论及应用。"
定理7.2,定理,"['第七章 函数与特殊函数', '§ 7.1 函数的基本概念', '7.1.1 函数的集合定义']","{'实体类型': '定理', '内容': '设A和B是任意给定的两个非空集合，X和Y是集合A的任意两个非空子集，f是一个从A和B函数，则有：(1) f(X cup Y)=f(X) cup f(Y); (2) f(X cap Y) subseteq f(X) cap f(Y)'}",,3,"在初等数学或高等数学中，函数的概念从变量角度提出，而且主要局限于在实数集。计算机相关领域处理的对象除了实数之外，还有很多其它对象，例如矩阵、向量、命题等等，而且主要面对的是各种可数的离散对象。为此，需要扩展初等数学或高等数学中函数概念的含义，从集合与关系的角度给函数下一个更加本质性的定义，具体如下：  
【定义7.1】设$𝐴$和$B$是任意两个非空集合，$f$是从$𝐴$到$B$的关系。若对$\forall x\in A$都存在唯一的$y\in B$，满足$\langle x,y\rangle\in f$，则称关系$f$为从$𝐴$到$B$的函数关系，简称为函数或映射,记为 $f\!:\!A\longrightarrow$  
$B$或$y=f(x)$，并称$x$为$f$的自变量或源点，$𝑦$为$ x$在$f$下的函数值或像点。集合$𝐴$称为$𝑓$的定义域，记为$dom$ $f=A$，所有像点组成的集合称为$f$的值域或$f$的像，记为$ran $$f$或$f(A)$。  
从上述定义可以看出，函数$f$是从集合$𝐴$到$B$的一种特殊二元关系，这种二元关系所包含序偶的第一元素为自变量，第二元素为因变量或函数值。函数的定义域就是关系的前域$𝐴$，要求关系中所有序偶的第一元素互不相同并且要取遍集合$𝐴$中的每个元素。作为刻画作为函数的本质单值特征，要求对于关系中的任意两个序偶，若它们的第一元素相同，则第二元素必须相同。具体地说，如果一个从集合$𝐴$到$B$二元关系$f$，那么它必须满足如下几个性质：  
(1)$\langle x,y\rangle\in f\Leftrightarrow y=f(x);\qquad\mathrm{(2)}\ \langle x,y\rangle\in f\wedge\langle x,z\rangle\in f\Rightarrow y=z;$  
（3）$|f|=|A|$； （4）$f(x)$表示一个变值，$f$代表一个集合，故$f\neq f(x)$  
如果关系$f$具备下面两种情况之一，那么$f$就不是函数关系：  
（1）存在元素$a\in A$,在$B$中没有像；（2）存在元素$a\in A$, 在$ B$中至少有两个像。  
例如，关系$\begin{array}{r}{F_{1}=\{\langle x_{1},y_{1}\rangle,\langle x_{2},y_{1}\rangle,\langle x_{3},y_{2}\rangle,\langle x_{4},y_{3}\rangle\}}\end{array}$是函数，而如下关系：
$$
F_{2}=\{\langle x_{1},y_{1}\rangle,\langle x_{2},y_{1}\rangle,\langle x_{3},y_{2}\rangle,\langle x_{1},y_{2}\rangle\}
$$  
则不是函数，因为同时有$\langle x_{1},y_{1}\rangle\in F_{2}$和$\langle x_{1},y_{2}\rangle\in F_{2}$  
由上述例题可知，函数作为一种特殊关系或特殊集合，其集合运算的结果可能不再是函数。因此，要慎用函数的集合运算。另一方面，由于函数是一种特殊子集，因此可用集合相等的概念来定义两个函数相等，具体定义如下：  
【定义7.2】设$𝐴$和$B$是任意两个非空集合，$f,g$是两个从$A$到$B$的函数关系，如果$f$和$g$相互包含，即有$f\subseteq g\wedge g\subseteq f$，则称函数$f$和函数$g$相等，记为$f=g$。换句话说，如果$dom $$f=$$dom$ $g$且对$\forall x\in\mathsf{d o m}$ $f=\mathrm{dom}$ $g$有$f(x)=g(x)$，称$f$与$g$相等。  
从上述定义可以看出，两个函数相等不仅要求它们的对应关系相等，而且要求它们的定义域也要相同，两者缺一不可。  
现考察有限集合上函数的计数问题，即算出有限集合上有多少种不同函数。设集合$ A=$$\{a_{1},a_{2},\cdots,a_{n}\}$，$B=\{b_{1},b_{2},\cdots,b_{m}\}$，则要确定一个从$𝐴$到$B$的函数$ f$，就必须对$𝐴$中每个元素$a_{i}$，在$B$中找到一个唯一确定的元素$b_{m_{i}}$与之对应。显然，对于$𝐴$中每个元素$a_{i}$都有$|B|=m$种选择$b_{m_{i}}$的方式。而集合𝐴中共有$|A|=n$个元素，故根据乘法原理，得到所有方式的组合数为$m^{n}$或$|B|^{|A|}$种。即从$A$到$B$的不同函数一共有$|B|^{|A|}$种。由此得到如下定理：  
【定理7.1】设$𝐴$和$B$是任意两个非空有限集合，则从$A$到$B$一共有$|B|^{|A|}$种不同的函数。  
根据上述定理，可得到如下函数集定义及其表示方法：  
【定义7.3】设$𝐴$和$B$是任意两个非空集合，将从$A$到$B$的一切函数构成的集合称为从$𝐴$到$B$的函数集或函数空间，记为$B^{A}$。即有： $B^{A}=\{f|f\colon\ A\to B\}.$。  
根据上述定义，当$𝐴$和$B$是非空有限集合时，显然有：$|B^{A}|=|B|^{|A|}$  
通过以上分析不难发现，当𝐴和$B$为有限集时，函数和一般关系具有以下区别：  
（1）个数差异：从$𝐴$到$B$的不同关系有$2^{|A|\times|B|}$个，从$A$到$B$的不同函数仅有$|B|^{|A|}$个。  
（2）基数不同：每个函数基数均为$|A|$即$|f|=|A|$，关系的基数却为从0 到$\vert A\vert\times\vert B\vert$  
（3）第一元素的差别：关系的第一个元素可以相同，函数的第一个元素不能相同。  
下面进一步考察函数对定义域子集的映射性质，首先给出如下子集像的相关概念：  
【定义7.4】设$𝐴$和$B$是任意给定的两个非空集合，$A_{1}$和$B_{1}$分别是$𝐴$和$B$的任意两个非空子集合，即有$A_{1}\subseteq A,B_{1}\subseteq B$。$f$是一个从$𝐴$和$B$函数，即$f\colon A\to B$。  
（1）令$f(A_{1})=\{f(x)|x\in A_{1}\}$，称$f(A_{1})$为$|A_{1}$在$f$下的像。当$A_{1}=A$时，$f(A)$为$f$的像。  
（2）令$ f^{-1}(B_{1})=\{x|x\in A\Lambda f(x)\in B_{1}\}$，称$f^{-1}(B_{1})$为$B_{1}$在$f$下的完全原像。  
在上述定义中显然有：$f(A_{1})\subseteq B$且$f^{-1}(B_{1})\subseteq A$。  
下面定理给出了子集像的集合运算性质：  
【定理7.2】设$𝐴$和$B$是任意给定的两个非空集合，$X$和$𝑌$是集合$ A$的任意两个非空子集，即有$X\subseteq A,Y\subseteq A$。$f$是一个从$A$和$B$函数，即$f\colon A\to B$。则有：  
$$
(1)f(X\cup Y)=f(X)\cup f(Y);\ \ (2)\ \,f(X\cap Y)\subseteq f(X)\cap f(Y)
$$  
上述定理的第（2）结论等号不成立。  
事实上，设$A=\{a,b,c\}$，$B=\{1,\!2,\!3\}$，$f\colon X\to Y$为：$f(a)=1$，$f(b)=f(c)=2.$令$X=\{a,b\}$，$Y=\{c\}$，则有：$A\cap B=\emptyset$，$f(A\cap B)=\emptyset$。但是：  
$$
f(A)\ \cap f(B)=\{1,2\}\cap\{2\}\neq\emptyset
$$  
故$f(A)\ \cap f(B)\ \neq f(A\cap B)$。这表明只能成立：$f(A\cap B)\subseteq f(A)\cap f(B)\,。$  
至此，我们从二元关系的角度给了函数相关概念的本质定义，并以关系模型为基本工具分析讨论了函数的若干基本性质，为函数理论奠定了一个比较坚实的数学基础。下面就从以上函数概念及基本性质为出发点进一步介绍和讨论函数的相关理论及应用。"
定理7.3,定理,"['第七章 函数与特殊函数', '§ 7.1 函数的基本概念', '7.1.2 函数的基本类型']","{'实体类型': '定理', '条件': '设A，B是有限集合且|A|=|B|', '结论': '如果f是一个从A到B的单射函数，则f必然是从A到B的满射函数，反之亦然'}",,3,"从本质上讲，从集合$𝐴$到集合$B$的函数描述的是$𝐴$中元素与$𝐵$中元素之间的一种特殊对应关系，这种特殊对应关系可以是一对一的也可以是多对一的，但不能是一对多或多对多的关系。这是函数对应关系与一般对应关系的主要差别。此外，函数值域可以是$B$的某个真子集，也可以是$B$自身。根据以上讨论，就可将所有函数分成如下四种不同的基本类型，即是单射但不是满射的函数、是满射但不是单射的函数、既是单射又是满射的函数、既不是单射也不是满射的函数。本节主要讨论这四种函数，首先给出单射函数和满射函数的定义：  
【定义7.5】设$f$从集合$𝐴$到集合$ B$的函数：  
（1）若$f$的不同自变量映射到不同的像，则称$f$为为$𝐴$到$B$的单射函数,简称为单射。也就是说，对任意的$x_{1},x_{2}\in A$，如果$x_{1}\neq x_{2}$，那么$f(x_{1})\neq f(x_{2})$，则称$f$为$𝐴$到$B$的单射。  
（2）如果集合$ B$中的每个元素都有原像，则称$f$为$𝐴$到$B$的满射函数，简称为满射；也就是说，如果$f$的值域等于$B$，即有$𝑟𝑎𝑛$ $f=B$，则称${f}$为$𝐴$到$B$的满射。  
（3）若$f$是满射且是单射，则称$f$为$𝐴$到$B$的双射；若$A=B$，则称${f}$为$𝐴$上的函数；当$𝐴$上的函数$f$是双射时，则称$f$为$𝐴$上的一个变换。  
可依据上述定义判断函数$f\colon A\to B$是否为满射、单射、双射。判断满射就是检查$B$中的每个元素是否都是函数值。如果在$B$中找到不是函数值的元素，那么$f$就不是满射的。判断单射的方法就是检查不同的自变量是否对应于不同的函数值。  
由定义7.2 和例7.1.7 可看出，若$ f$是从有限集$𝐴$到有限集$B$的函数，则$f$是单射的必要条件是$|A|\leq|B|$；$f$是满射的必要条件是$|A|\geq|B|$；$f$是双射的必要条件是$|A|=|B|$。此外，当$A$ 和$B$ 是基数相同的有限集合时，还有以下结论：  
【定理7.3】设$𝐴$，$B$是有限集合且$|A|=|B|$。如果$f$是一个从$A$到$B$的单射函数，则$f$必然是从𝐴到$B$的满射函数，反之亦然。"
定理7.4,定理,"['第七章 函数与特殊函数', '§ 7.2 函数的基本运算', '7.2.1 函数的复合运算']","{'实体类型': '定理', '内容': '两个函数的复合关系是一个从A到C的函数，称为复合函数'}",,3,"前面已经学习了二元关系的复合运算，函数作为一种特殊的二元关系，也可以进行复合运算，函数的复合运算其实就是函数关系的合成，下面定理保证了两个函数关系的复合后得到的关系仍然是一个函数关系，并据此得到复合函数的定义：  
【定理7.4】设$f\colon A\to B,g\colon B\to C$是两个函数，则$f$与$g$的复合关系：  
$f\circ g=\{\langle x,z\rangle|x\in A\wedge z\in C\wedge(\exists y)(y\in B\wedge xfy\wedge ygz)\}\quad\text{(7-1)}$  
是一个从$𝐴$到$C$的函数，称之为函数$f$与$g$的复合函数，记为$f\circ g\colon A\to C$。  
根据上述定理，由于两个函数的复合运算结果仍然是一个函数，故可将函数复合运算直接推广到多个函数的情形，并且多个函数复合运算结果仍是函数。由于函数复合是关系复合的一种特殊情形，故多个函数的复合同样满足结合律。此外，从上述定理可以看出：  
（1）函数$ f$与$g$可以复合的前提条件是，前一个函数$f$的值域$ran$ $f$必须是后一个函数$g$定义域$dom$ $g$的子集合，即有：$ran $$f\subseteq\operatorname{dom}\ g=B$；  
（2）复合函数$f\circ g$的定义域$\operatorname{dom}(f\circ g)$是前一个函数$ f$的定义域$dom$ $f$，值域ran$(f\circ g)$是后一个函数$$g$$的值域，即有：$\operatorname{dom}(f\circ g)=\operatorname{dom}\ f=A,\ \operatorname{ran}(f\circ g)=r a n g;$  
（3）对$\forall x\in A$，有：$f\circ g(x)=g(f(x))。$  
下面定理给出了函数单射、满射和双射性质在复合运算下的保持性：  
【定理7.5】设$f\colon A\to B,g\colon B\to C$是两个函数。  
（1）如果函数$f$和$g$都是满射，则复合函数$f\circ g$也是从$A$到$C$满射；  
（2）如果函数$f$和$g$都是单射，则复合函数$f\circ g$也是从$𝐴$到$C$单射；  
（3）如果函数$f$和$g$都是双射，则复合函数$f\circ g$也是从𝐴到$C$双射。  
需要注意的是上述定理的逆不成立，但有以下结论：  
【定理7.6】设$f\colon A\to B,g\colon B\to C$是两个函数，则有：  
（1）如果复合函数$f\circ g$是从$𝐴$到$C$满射，则函数$g$是$B$到$C$的满射；  
（2）如果复合函数$f\circ g$是从$𝐴$到$C$单射，则函数$f$是$𝐴$是$B$的单射；  
（3）如果复合函数$f\circ g$是从$A$到$C$双射，则$f$是$A$是$B$的单射，$g$是$B$到$C$的满射。"
定理7.5,定理,"['第七章 函数与特殊函数', '§ 7.2 函数的基本运算', '7.2.1 函数的复合运算']","{'实体类型': '定理', '内容': '函数的单射、满射和双射性质在复合运算下保持'}",,3,"前面已经学习了二元关系的复合运算，函数作为一种特殊的二元关系，也可以进行复合运算，函数的复合运算其实就是函数关系的合成，下面定理保证了两个函数关系的复合后得到的关系仍然是一个函数关系，并据此得到复合函数的定义：  
【定理7.4】设$f\colon A\to B,g\colon B\to C$是两个函数，则$f$与$g$的复合关系：  
$f\circ g=\{\langle x,z\rangle|x\in A\wedge z\in C\wedge(\exists y)(y\in B\wedge xfy\wedge ygz)\}\quad\text{(7-1)}$  
是一个从$𝐴$到$C$的函数，称之为函数$f$与$g$的复合函数，记为$f\circ g\colon A\to C$。  
根据上述定理，由于两个函数的复合运算结果仍然是一个函数，故可将函数复合运算直接推广到多个函数的情形，并且多个函数复合运算结果仍是函数。由于函数复合是关系复合的一种特殊情形，故多个函数的复合同样满足结合律。此外，从上述定理可以看出：  
（1）函数$ f$与$g$可以复合的前提条件是，前一个函数$f$的值域$ran$ $f$必须是后一个函数$g$定义域$dom$ $g$的子集合，即有：$ran $$f\subseteq\operatorname{dom}\ g=B$；  
（2）复合函数$f\circ g$的定义域$\operatorname{dom}(f\circ g)$是前一个函数$ f$的定义域$dom$ $f$，值域ran$(f\circ g)$是后一个函数$$g$$的值域，即有：$\operatorname{dom}(f\circ g)=\operatorname{dom}\ f=A,\ \operatorname{ran}(f\circ g)=r a n g;$  
（3）对$\forall x\in A$，有：$f\circ g(x)=g(f(x))。$  
下面定理给出了函数单射、满射和双射性质在复合运算下的保持性：  
【定理7.5】设$f\colon A\to B,g\colon B\to C$是两个函数。  
（1）如果函数$f$和$g$都是满射，则复合函数$f\circ g$也是从$A$到$C$满射；  
（2）如果函数$f$和$g$都是单射，则复合函数$f\circ g$也是从$𝐴$到$C$单射；  
（3）如果函数$f$和$g$都是双射，则复合函数$f\circ g$也是从𝐴到$C$双射。  
需要注意的是上述定理的逆不成立，但有以下结论：  
【定理7.6】设$f\colon A\to B,g\colon B\to C$是两个函数，则有：  
（1）如果复合函数$f\circ g$是从$𝐴$到$C$满射，则函数$g$是$B$到$C$的满射；  
（2）如果复合函数$f\circ g$是从$𝐴$到$C$单射，则函数$f$是$𝐴$是$B$的单射；  
（3）如果复合函数$f\circ g$是从$A$到$C$双射，则$f$是$A$是$B$的单射，$g$是$B$到$C$的满射。"
定理7.6,定理,"['第七章 函数与特殊函数', '§ 7.2 函数的基本运算', '7.2.1 函数的复合运算']","{'实体类型': '定理', '内容': '复合函数的满射、单射和双射性质对原函数的影响'}",,3,"前面已经学习了二元关系的复合运算，函数作为一种特殊的二元关系，也可以进行复合运算，函数的复合运算其实就是函数关系的合成，下面定理保证了两个函数关系的复合后得到的关系仍然是一个函数关系，并据此得到复合函数的定义：  
【定理7.4】设$f\colon A\to B,g\colon B\to C$是两个函数，则$f$与$g$的复合关系：  
$f\circ g=\{\langle x,z\rangle|x\in A\wedge z\in C\wedge(\exists y)(y\in B\wedge xfy\wedge ygz)\}\quad\text{(7-1)}$  
是一个从$𝐴$到$C$的函数，称之为函数$f$与$g$的复合函数，记为$f\circ g\colon A\to C$。  
根据上述定理，由于两个函数的复合运算结果仍然是一个函数，故可将函数复合运算直接推广到多个函数的情形，并且多个函数复合运算结果仍是函数。由于函数复合是关系复合的一种特殊情形，故多个函数的复合同样满足结合律。此外，从上述定理可以看出：  
（1）函数$ f$与$g$可以复合的前提条件是，前一个函数$f$的值域$ran$ $f$必须是后一个函数$g$定义域$dom$ $g$的子集合，即有：$ran $$f\subseteq\operatorname{dom}\ g=B$；  
（2）复合函数$f\circ g$的定义域$\operatorname{dom}(f\circ g)$是前一个函数$ f$的定义域$dom$ $f$，值域ran$(f\circ g)$是后一个函数$$g$$的值域，即有：$\operatorname{dom}(f\circ g)=\operatorname{dom}\ f=A,\ \operatorname{ran}(f\circ g)=r a n g;$  
（3）对$\forall x\in A$，有：$f\circ g(x)=g(f(x))。$  
下面定理给出了函数单射、满射和双射性质在复合运算下的保持性：  
【定理7.5】设$f\colon A\to B,g\colon B\to C$是两个函数。  
（1）如果函数$f$和$g$都是满射，则复合函数$f\circ g$也是从$A$到$C$满射；  
（2）如果函数$f$和$g$都是单射，则复合函数$f\circ g$也是从$𝐴$到$C$单射；  
（3）如果函数$f$和$g$都是双射，则复合函数$f\circ g$也是从𝐴到$C$双射。  
需要注意的是上述定理的逆不成立，但有以下结论：  
【定理7.6】设$f\colon A\to B,g\colon B\to C$是两个函数，则有：  
（1）如果复合函数$f\circ g$是从$𝐴$到$C$满射，则函数$g$是$B$到$C$的满射；  
（2）如果复合函数$f\circ g$是从$𝐴$到$C$单射，则函数$f$是$𝐴$是$B$的单射；  
（3）如果复合函数$f\circ g$是从$A$到$C$双射，则$f$是$A$是$B$的单射，$g$是$B$到$C$的满射。"
定理7.7,定理,"['第七章 函数与特殊函数', '§ 7.2 函数的基本运算', '7.2.2 函数的逆运算']","{'实体类型': '定理', '内容': '设f:A→B的双射函数，则f的逆函数f^{-1}也是从B到A的双射函数'}",,3,"在一般关系$𝑅$的求逆运算中，任意关系都可进行求逆运算而得到其逆关系，但是对于任意一个函数$𝑓$来说，只能保证它的逆$f^{-1}$是一个二元关系，并不能保证$f^{-1}$一定是函数关系。因此，在求一个函数的逆运算时，必须对该函数做一些特殊的要求。  
【定义7.7】设$f\colon A\to B$的函数关系，如果其逆关系：  
$$
f^{-1}=\{\langle y,x\rangle|x\in A\land y\in B\land\langle x,y\rangle\in f\}\quad\text{(7-2)}
$$  
是一个从$B$到$𝐴$的函数关系，则函数$f$可逆，并称$f^{-1}$是函数$f$的逆函数或反函数。  
由上述定义可可知，如果函数$f$可逆，则$f^{-1}$作为一个从$B$到$𝐴$的函数，集合$ B$中每个元素都有$ f^{-1}$下的像，而根据逆关系的定义，$B$中每个元素在函数$f^{-1}$下的像其实就是该元素在函数$f$下的原像，故$f$是从$𝐴$到$B$的满射。另一方面，$f^{-1}$作为一个函数，集合$ B$中每个元素都有$A$中唯一的元素与之对应。从函数$ f$的角度看，就是$𝐴$中不同的元素对应不同的像，因此，函数$f$是单射。综上所述，函数$f$存在逆函数$f^{-1}$当且仅当$f$是双射。  
【定理7.7】设$f\colon A\to B$的双射函数，则$f$的逆函数$f^{-1}$也是从$B$到$𝐴$的双射函数。  
下面定理给出了任一双射函数与其函数反函数及恒等函数之间的关系：  
【定理7.8】设$𝑓$:$A\rightarrow B$的双射函数，则有：  
$$
(1)f^{-1}\circ f=I_{B};\mathrm{~(~2~)~}\,f\circ f^{-1}=I_{A};\mathrm{~(~3~)~}\,I_{A}\circ f=f\circ I_{B}=f。
$$  
其中$I_{A}$和$I_{B}$分别表示集合$𝐴$和集合 $B$上的恒等函数。"
定理7.8,定理,"['第七章 函数与特殊函数', '§ 7.2 函数的基本运算', '7.2.2 函数的逆运算']","{'实体类型': '定理', '内容': '设f:A→B的双射函数，则有：(1)f^{-1}∘f=I_B；(2)f∘f^{-1}=I_A；(3)I_A∘f=f∘I_B=f。其中I_A和I_B分别表示集合A和集合B上的恒等函数'}",,3,"在一般关系$𝑅$的求逆运算中，任意关系都可进行求逆运算而得到其逆关系，但是对于任意一个函数$𝑓$来说，只能保证它的逆$f^{-1}$是一个二元关系，并不能保证$f^{-1}$一定是函数关系。因此，在求一个函数的逆运算时，必须对该函数做一些特殊的要求。  
【定义7.7】设$f\colon A\to B$的函数关系，如果其逆关系：  
$$
f^{-1}=\{\langle y,x\rangle|x\in A\land y\in B\land\langle x,y\rangle\in f\}\quad\text{(7-2)}
$$  
是一个从$B$到$𝐴$的函数关系，则函数$f$可逆，并称$f^{-1}$是函数$f$的逆函数或反函数。  
由上述定义可可知，如果函数$f$可逆，则$f^{-1}$作为一个从$B$到$𝐴$的函数，集合$ B$中每个元素都有$ f^{-1}$下的像，而根据逆关系的定义，$B$中每个元素在函数$f^{-1}$下的像其实就是该元素在函数$f$下的原像，故$f$是从$𝐴$到$B$的满射。另一方面，$f^{-1}$作为一个函数，集合$ B$中每个元素都有$A$中唯一的元素与之对应。从函数$ f$的角度看，就是$𝐴$中不同的元素对应不同的像，因此，函数$f$是单射。综上所述，函数$f$存在逆函数$f^{-1}$当且仅当$f$是双射。  
【定理7.7】设$f\colon A\to B$的双射函数，则$f$的逆函数$f^{-1}$也是从$B$到$𝐴$的双射函数。  
下面定理给出了任一双射函数与其函数反函数及恒等函数之间的关系：  
【定理7.8】设$𝑓$:$A\rightarrow B$的双射函数，则有：  
$$
(1)f^{-1}\circ f=I_{B};\mathrm{~(~2~)~}\,f\circ f^{-1}=I_{A};\mathrm{~(~3~)~}\,I_{A}\circ f=f\circ I_{B}=f。
$$  
其中$I_{A}$和$I_{B}$分别表示集合$𝐴$和集合 $B$上的恒等函数。"
定理8.3,定理,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.2 可达性及其判定']","{'实体类型': '定理', '内容': '若图中两个不同结点存在通路，则必然存在长度不大于n-1的基本通路'}",,3,"如前所述，对于任意一个给定的线图模型，图中任意两个指定结点之间的通路可能有很多条，有的可能会长一些，有的可能会短一些，此时，一般关心的是哪条通路最短。还有一种情况，就是图中可能存在两个或者多个结点，它们之间根本没有通路相联结，例如，在图8。3。1 表示的城市高铁运输线路图中，北京和台北之间就没有通路联结，这也是一种比较重要的情形。 由此得到如下图中结点可达性及其短程线的相关概念  
【定义8.23】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，对于𝑉中的任意两个结点$v_{i},v_{j}$，如果从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$之间存在长度至少为1 的通路，则称从$v_{i}$到$v_{j}$可达，否则称从$v_{i}$到$v_{j}$不可达。 如果图$G$ 中从$v_{i}$到$v_{j}$可达，则从$v_{i}$到$v_{j}$长度最短的通路称为从$v_{i}$到$v_{j}$的短程线，该短线程的长度称从$\boldsymbol{v}_{i}$到$v_{j}$的距离，记为 $d\big(v_{i},v_{j}\big)$ 。如果从$\boldsymbol{v}_{i}$到$v_{j}$不可达，则记为 $d\bigl(v_{i},v_{j}\bigr)=\infty$ 。  
从上述定义可以看出，结点之间的可达性刻画的是图中两个结点之间的某种连通性关系。对于无向图来说，这种连通性关系显然是双向的，故若从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$ 可达，则从 $v_{j}$ 到 $v_{i}$ 可达，反之亦然；且有 $d\bigl(v_{i},v_{j}\bigr)=d\bigl(v_{j},v_{i}\bigr)$ 。对于有向图来说，这种连通性关系不一定满足对称性，故若从$v_{i}$到$v_{j}$ 可达，则不一定有从 $v_{j}$ 到 $v_{i}$ 可达，也不一定有 $d\big(v_{i},v_{j}\big)=$$d\big(v_{j},v_{i}\big)$ 。  
如前所述，图模型$G=\langle V,E\rangle$中结点之间的通路由该图所表示二元关系不断对其自身作复合运算产生，长度为$k$的通路其实就是二元关系$k$次幂运算的结果。因此，由图$G=\langle V,E\rangle$中结点之间可达性产生的二元关系其实就是图$G=\langle V,E\rangle$所表示二元关系的传递闭包。  
我们知道，对于有限集合$ V=\{v_{1},v_{2},\ldots,v_{n}\}$上的任意一个二元关系，构造其的传递闭包最多只需要进行$\cdot n$次方幂运算就可以了。也就是说，对于任意一个$n$结点的图模型，联结其中两个可达的结点最多只需要做$ n$次方幂运算，亦即对于图中任意两个可达结点，必然存在一条长度不大于$ n$的通路或回路联结这两个结点。  
以上是从二元关系及其传递闭包的角度对图中可达结点的联结通路或回路长度的分析，下面从图模型的角度对上述分析结论进行严格证明。  
【定理8.3】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中两个不同的结点$u$ 和 $v$，存在一条从$u$到 $v$通路，则必然存在一条长度不大于$:n-1$ 的基本通路。  
可类似证明如下基本回路存在性定理：  
【定理8.4】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中结点$v$，存在一条从$v$ 到 $v$回路，则必然存在一条长度不大于$^{\cdot n}$ 的基本回路。  
由以上两个定理可知，对于任意含有$ n$个结点的有向或无向线图$G=\langle V,E\rangle$，如果图从结点$u$ 到${v}$是可达的，那么必然存在从$u$ 到$v$且长度不超过$n$通路或回路。因此，根据通路或回路的计数方法，最多只需计算该图所对应邻接矩阵的$n$幂，即可判定图中任意两个结点之间是否可达。具体地说，假设𝐴是图$G=\langle V,E\rangle$的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则$B_{n}$中的元素为：  
$$
b_{i j}^{(n)}=a_{i j}^{(1)}+a_{i j}^{(2)}+\cdots+a_{i j}^{(n)}
$$  
显然，$b_{i j}^{(n)}$表示图$G$中从结点$v_{i}$到结点$v_{j}$的长度不超过$n$的通路总数，特别地，若$ i=j$，则$b_{i j}^{(n)}$为结点$v_{i}$到自身的长度不超过$n$的回路总数。因此，若$b_{i j}^{(n)}=0$，则结点$v_{i}$到$v_{j}$不可达，否则，结点$v_{i}$到$v_{j}$可达。由此得到有如下定理关于图模型的可达性定理：  
【定理8.5】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，$A=(a_{i j})_{n\times n}$为图 $G$ 的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则当$v_{i}\neq v_{j}$时，若${b_{i j}}^{(n)}>0$，则$v_{i}$到$v_{j}$可达，否则不可达，且有：  
$$
d\big(\boldsymbol{v}_{i},\boldsymbol{v}_{j}\big)==\begin{cases}\infty,&&\text{若}a_{ij}{}^{(1)},a_{ij}{}^{(2)},\cdots,a_{ij}{}^{(n)}\text{均为 0}\\\min\{a_{ij}^{(m)}|m=1,2,\cdots,n\},&&\text{否则}\end{cases}
$$  
在图模型的实际应用过程中，很多时候只需知道结点之间是否可达，而无需知道距离及通路数，由此得到如下可达性矩阵的定义：  
【定义8.24】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，则令$P=(p_{i j})_{n\times n}$是一个$n$阶矩阵，且满足：  
$p_{ij}=\begin{cases}1\:,~~~~~~结点从v_{i}到v_{j}至少存在一条长度不小于1的通路\\0\:,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~否则\end{cases}$    (8-8)  
称矩阵 $P$ 为图 $G$ 的可达性矩阵。  
从上述定义可以看出，可达性矩阵中的元素$\cdot p_{i j}$表示了从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$的可达性关系，表达了结点之间通过结点邻接关系的传递性得到可达性关系。因此，图中结点之间的可达性关系就是该图所表达邻接关系的传递闭包，可达性矩阵其实就是图邻接关系的传递闭包关系矩阵，即为可达性关系的关系矩阵。 显然，无向图的可达性矩阵为对称矩阵。  
若已知$B_{n}$ ，则只需将$B_{n}$中非零元素写成1，便可得到可达性矩阵 $P$，即有：  
$$
p_{i j}=\left\{\!\!\begin{array}{l l}{1,\qquad}&{b_{i j}^{\phantom{}(n)}\neq0}\\ {0,\qquad}&{b_{i j}^{\phantom{}(n)}=0}\end{array}\right.
$$  
由于可达性矩阵$P$是布尔矩阵，矩阵$P$中的元素$p_{i j}$只表示结点$v_{i}$到$v_{j}$是否可达，并不表示至于其通路数目及长度。因此，通过计算矩阵 $B_{n}$获得可达性矩阵$P$的方法效率较低。事实上，可类似于计算二元关系的闭包，使用邻接矩阵𝐴的布尔运算计算可达性矩阵$P$。  
【定理8.6】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，矩阵$A$和$P$分别是图$G$在该结点次序下的邻接矩阵和可达性矩阵，则有：  
$$
P=A^{(1)}\lor A^{(2)}\lor\cdots\lor A^{(k)}\lor\cdots\lor A^{(n)}
$$  
其中$A^{(k)}$表示进行矩阵$A$的$k$次布尔幂运算。"
定理8.4,定理,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.2 可达性及其判定']","{'实体类型': '定理', '内容': '若图中结点存在回路，则必然存在长度不大于n的基本回路'}",,3,"如前所述，对于任意一个给定的线图模型，图中任意两个指定结点之间的通路可能有很多条，有的可能会长一些，有的可能会短一些，此时，一般关心的是哪条通路最短。还有一种情况，就是图中可能存在两个或者多个结点，它们之间根本没有通路相联结，例如，在图8。3。1 表示的城市高铁运输线路图中，北京和台北之间就没有通路联结，这也是一种比较重要的情形。 由此得到如下图中结点可达性及其短程线的相关概念  
【定义8.23】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，对于𝑉中的任意两个结点$v_{i},v_{j}$，如果从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$之间存在长度至少为1 的通路，则称从$v_{i}$到$v_{j}$可达，否则称从$v_{i}$到$v_{j}$不可达。 如果图$G$ 中从$v_{i}$到$v_{j}$可达，则从$v_{i}$到$v_{j}$长度最短的通路称为从$v_{i}$到$v_{j}$的短程线，该短线程的长度称从$\boldsymbol{v}_{i}$到$v_{j}$的距离，记为 $d\big(v_{i},v_{j}\big)$ 。如果从$\boldsymbol{v}_{i}$到$v_{j}$不可达，则记为 $d\bigl(v_{i},v_{j}\bigr)=\infty$ 。  
从上述定义可以看出，结点之间的可达性刻画的是图中两个结点之间的某种连通性关系。对于无向图来说，这种连通性关系显然是双向的，故若从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$ 可达，则从 $v_{j}$ 到 $v_{i}$ 可达，反之亦然；且有 $d\bigl(v_{i},v_{j}\bigr)=d\bigl(v_{j},v_{i}\bigr)$ 。对于有向图来说，这种连通性关系不一定满足对称性，故若从$v_{i}$到$v_{j}$ 可达，则不一定有从 $v_{j}$ 到 $v_{i}$ 可达，也不一定有 $d\big(v_{i},v_{j}\big)=$$d\big(v_{j},v_{i}\big)$ 。  
如前所述，图模型$G=\langle V,E\rangle$中结点之间的通路由该图所表示二元关系不断对其自身作复合运算产生，长度为$k$的通路其实就是二元关系$k$次幂运算的结果。因此，由图$G=\langle V,E\rangle$中结点之间可达性产生的二元关系其实就是图$G=\langle V,E\rangle$所表示二元关系的传递闭包。  
我们知道，对于有限集合$ V=\{v_{1},v_{2},\ldots,v_{n}\}$上的任意一个二元关系，构造其的传递闭包最多只需要进行$\cdot n$次方幂运算就可以了。也就是说，对于任意一个$n$结点的图模型，联结其中两个可达的结点最多只需要做$ n$次方幂运算，亦即对于图中任意两个可达结点，必然存在一条长度不大于$ n$的通路或回路联结这两个结点。  
以上是从二元关系及其传递闭包的角度对图中可达结点的联结通路或回路长度的分析，下面从图模型的角度对上述分析结论进行严格证明。  
【定理8.3】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中两个不同的结点$u$ 和 $v$，存在一条从$u$到 $v$通路，则必然存在一条长度不大于$:n-1$ 的基本通路。  
可类似证明如下基本回路存在性定理：  
【定理8.4】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中结点$v$，存在一条从$v$ 到 $v$回路，则必然存在一条长度不大于$^{\cdot n}$ 的基本回路。  
由以上两个定理可知，对于任意含有$ n$个结点的有向或无向线图$G=\langle V,E\rangle$，如果图从结点$u$ 到${v}$是可达的，那么必然存在从$u$ 到$v$且长度不超过$n$通路或回路。因此，根据通路或回路的计数方法，最多只需计算该图所对应邻接矩阵的$n$幂，即可判定图中任意两个结点之间是否可达。具体地说，假设𝐴是图$G=\langle V,E\rangle$的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则$B_{n}$中的元素为：  
$$
b_{i j}^{(n)}=a_{i j}^{(1)}+a_{i j}^{(2)}+\cdots+a_{i j}^{(n)}
$$  
显然，$b_{i j}^{(n)}$表示图$G$中从结点$v_{i}$到结点$v_{j}$的长度不超过$n$的通路总数，特别地，若$ i=j$，则$b_{i j}^{(n)}$为结点$v_{i}$到自身的长度不超过$n$的回路总数。因此，若$b_{i j}^{(n)}=0$，则结点$v_{i}$到$v_{j}$不可达，否则，结点$v_{i}$到$v_{j}$可达。由此得到有如下定理关于图模型的可达性定理：  
【定理8.5】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，$A=(a_{i j})_{n\times n}$为图 $G$ 的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则当$v_{i}\neq v_{j}$时，若${b_{i j}}^{(n)}>0$，则$v_{i}$到$v_{j}$可达，否则不可达，且有：  
$$
d\big(\boldsymbol{v}_{i},\boldsymbol{v}_{j}\big)==\begin{cases}\infty,&&\text{若}a_{ij}{}^{(1)},a_{ij}{}^{(2)},\cdots,a_{ij}{}^{(n)}\text{均为 0}\\\min\{a_{ij}^{(m)}|m=1,2,\cdots,n\},&&\text{否则}\end{cases}
$$  
在图模型的实际应用过程中，很多时候只需知道结点之间是否可达，而无需知道距离及通路数，由此得到如下可达性矩阵的定义：  
【定义8.24】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，则令$P=(p_{i j})_{n\times n}$是一个$n$阶矩阵，且满足：  
$p_{ij}=\begin{cases}1\:,~~~~~~结点从v_{i}到v_{j}至少存在一条长度不小于1的通路\\0\:,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~否则\end{cases}$    (8-8)  
称矩阵 $P$ 为图 $G$ 的可达性矩阵。  
从上述定义可以看出，可达性矩阵中的元素$\cdot p_{i j}$表示了从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$的可达性关系，表达了结点之间通过结点邻接关系的传递性得到可达性关系。因此，图中结点之间的可达性关系就是该图所表达邻接关系的传递闭包，可达性矩阵其实就是图邻接关系的传递闭包关系矩阵，即为可达性关系的关系矩阵。 显然，无向图的可达性矩阵为对称矩阵。  
若已知$B_{n}$ ，则只需将$B_{n}$中非零元素写成1，便可得到可达性矩阵 $P$，即有：  
$$
p_{i j}=\left\{\!\!\begin{array}{l l}{1,\qquad}&{b_{i j}^{\phantom{}(n)}\neq0}\\ {0,\qquad}&{b_{i j}^{\phantom{}(n)}=0}\end{array}\right.
$$  
由于可达性矩阵$P$是布尔矩阵，矩阵$P$中的元素$p_{i j}$只表示结点$v_{i}$到$v_{j}$是否可达，并不表示至于其通路数目及长度。因此，通过计算矩阵 $B_{n}$获得可达性矩阵$P$的方法效率较低。事实上，可类似于计算二元关系的闭包，使用邻接矩阵𝐴的布尔运算计算可达性矩阵$P$。  
【定理8.6】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，矩阵$A$和$P$分别是图$G$在该结点次序下的邻接矩阵和可达性矩阵，则有：  
$$
P=A^{(1)}\lor A^{(2)}\lor\cdots\lor A^{(k)}\lor\cdots\lor A^{(n)}
$$  
其中$A^{(k)}$表示进行矩阵$A$的$k$次布尔幂运算。"
定理8.5,定理,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.2 可达性及其判定']","{'实体类型': '定理', '内容': '通过邻接矩阵的幂判定结点之间是否可达，并计算距离'}",,3,"如前所述，对于任意一个给定的线图模型，图中任意两个指定结点之间的通路可能有很多条，有的可能会长一些，有的可能会短一些，此时，一般关心的是哪条通路最短。还有一种情况，就是图中可能存在两个或者多个结点，它们之间根本没有通路相联结，例如，在图8。3。1 表示的城市高铁运输线路图中，北京和台北之间就没有通路联结，这也是一种比较重要的情形。 由此得到如下图中结点可达性及其短程线的相关概念  
【定义8.23】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，对于𝑉中的任意两个结点$v_{i},v_{j}$，如果从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$之间存在长度至少为1 的通路，则称从$v_{i}$到$v_{j}$可达，否则称从$v_{i}$到$v_{j}$不可达。 如果图$G$ 中从$v_{i}$到$v_{j}$可达，则从$v_{i}$到$v_{j}$长度最短的通路称为从$v_{i}$到$v_{j}$的短程线，该短线程的长度称从$\boldsymbol{v}_{i}$到$v_{j}$的距离，记为 $d\big(v_{i},v_{j}\big)$ 。如果从$\boldsymbol{v}_{i}$到$v_{j}$不可达，则记为 $d\bigl(v_{i},v_{j}\bigr)=\infty$ 。  
从上述定义可以看出，结点之间的可达性刻画的是图中两个结点之间的某种连通性关系。对于无向图来说，这种连通性关系显然是双向的，故若从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$ 可达，则从 $v_{j}$ 到 $v_{i}$ 可达，反之亦然；且有 $d\bigl(v_{i},v_{j}\bigr)=d\bigl(v_{j},v_{i}\bigr)$ 。对于有向图来说，这种连通性关系不一定满足对称性，故若从$v_{i}$到$v_{j}$ 可达，则不一定有从 $v_{j}$ 到 $v_{i}$ 可达，也不一定有 $d\big(v_{i},v_{j}\big)=$$d\big(v_{j},v_{i}\big)$ 。  
如前所述，图模型$G=\langle V,E\rangle$中结点之间的通路由该图所表示二元关系不断对其自身作复合运算产生，长度为$k$的通路其实就是二元关系$k$次幂运算的结果。因此，由图$G=\langle V,E\rangle$中结点之间可达性产生的二元关系其实就是图$G=\langle V,E\rangle$所表示二元关系的传递闭包。  
我们知道，对于有限集合$ V=\{v_{1},v_{2},\ldots,v_{n}\}$上的任意一个二元关系，构造其的传递闭包最多只需要进行$\cdot n$次方幂运算就可以了。也就是说，对于任意一个$n$结点的图模型，联结其中两个可达的结点最多只需要做$ n$次方幂运算，亦即对于图中任意两个可达结点，必然存在一条长度不大于$ n$的通路或回路联结这两个结点。  
以上是从二元关系及其传递闭包的角度对图中可达结点的联结通路或回路长度的分析，下面从图模型的角度对上述分析结论进行严格证明。  
【定理8.3】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中两个不同的结点$u$ 和 $v$，存在一条从$u$到 $v$通路，则必然存在一条长度不大于$:n-1$ 的基本通路。  
可类似证明如下基本回路存在性定理：  
【定理8.4】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中结点$v$，存在一条从$v$ 到 $v$回路，则必然存在一条长度不大于$^{\cdot n}$ 的基本回路。  
由以上两个定理可知，对于任意含有$ n$个结点的有向或无向线图$G=\langle V,E\rangle$，如果图从结点$u$ 到${v}$是可达的，那么必然存在从$u$ 到$v$且长度不超过$n$通路或回路。因此，根据通路或回路的计数方法，最多只需计算该图所对应邻接矩阵的$n$幂，即可判定图中任意两个结点之间是否可达。具体地说，假设𝐴是图$G=\langle V,E\rangle$的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则$B_{n}$中的元素为：  
$$
b_{i j}^{(n)}=a_{i j}^{(1)}+a_{i j}^{(2)}+\cdots+a_{i j}^{(n)}
$$  
显然，$b_{i j}^{(n)}$表示图$G$中从结点$v_{i}$到结点$v_{j}$的长度不超过$n$的通路总数，特别地，若$ i=j$，则$b_{i j}^{(n)}$为结点$v_{i}$到自身的长度不超过$n$的回路总数。因此，若$b_{i j}^{(n)}=0$，则结点$v_{i}$到$v_{j}$不可达，否则，结点$v_{i}$到$v_{j}$可达。由此得到有如下定理关于图模型的可达性定理：  
【定理8.5】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，$A=(a_{i j})_{n\times n}$为图 $G$ 的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则当$v_{i}\neq v_{j}$时，若${b_{i j}}^{(n)}>0$，则$v_{i}$到$v_{j}$可达，否则不可达，且有：  
$$
d\big(\boldsymbol{v}_{i},\boldsymbol{v}_{j}\big)==\begin{cases}\infty,&&\text{若}a_{ij}{}^{(1)},a_{ij}{}^{(2)},\cdots,a_{ij}{}^{(n)}\text{均为 0}\\\min\{a_{ij}^{(m)}|m=1,2,\cdots,n\},&&\text{否则}\end{cases}
$$  
在图模型的实际应用过程中，很多时候只需知道结点之间是否可达，而无需知道距离及通路数，由此得到如下可达性矩阵的定义：  
【定义8.24】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，则令$P=(p_{i j})_{n\times n}$是一个$n$阶矩阵，且满足：  
$p_{ij}=\begin{cases}1\:,~~~~~~结点从v_{i}到v_{j}至少存在一条长度不小于1的通路\\0\:,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~否则\end{cases}$    (8-8)  
称矩阵 $P$ 为图 $G$ 的可达性矩阵。  
从上述定义可以看出，可达性矩阵中的元素$\cdot p_{i j}$表示了从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$的可达性关系，表达了结点之间通过结点邻接关系的传递性得到可达性关系。因此，图中结点之间的可达性关系就是该图所表达邻接关系的传递闭包，可达性矩阵其实就是图邻接关系的传递闭包关系矩阵，即为可达性关系的关系矩阵。 显然，无向图的可达性矩阵为对称矩阵。  
若已知$B_{n}$ ，则只需将$B_{n}$中非零元素写成1，便可得到可达性矩阵 $P$，即有：  
$$
p_{i j}=\left\{\!\!\begin{array}{l l}{1,\qquad}&{b_{i j}^{\phantom{}(n)}\neq0}\\ {0,\qquad}&{b_{i j}^{\phantom{}(n)}=0}\end{array}\right.
$$  
由于可达性矩阵$P$是布尔矩阵，矩阵$P$中的元素$p_{i j}$只表示结点$v_{i}$到$v_{j}$是否可达，并不表示至于其通路数目及长度。因此，通过计算矩阵 $B_{n}$获得可达性矩阵$P$的方法效率较低。事实上，可类似于计算二元关系的闭包，使用邻接矩阵𝐴的布尔运算计算可达性矩阵$P$。  
【定理8.6】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，矩阵$A$和$P$分别是图$G$在该结点次序下的邻接矩阵和可达性矩阵，则有：  
$$
P=A^{(1)}\lor A^{(2)}\lor\cdots\lor A^{(k)}\lor\cdots\lor A^{(n)}
$$  
其中$A^{(k)}$表示进行矩阵$A$的$k$次布尔幂运算。"
定理8.6,定理,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.2 可达性及其判定']","{'实体类型': '定理', '内容': '通过邻接矩阵的布尔幂运算计算可达性矩阵'}",,3,"如前所述，对于任意一个给定的线图模型，图中任意两个指定结点之间的通路可能有很多条，有的可能会长一些，有的可能会短一些，此时，一般关心的是哪条通路最短。还有一种情况，就是图中可能存在两个或者多个结点，它们之间根本没有通路相联结，例如，在图8。3。1 表示的城市高铁运输线路图中，北京和台北之间就没有通路联结，这也是一种比较重要的情形。 由此得到如下图中结点可达性及其短程线的相关概念  
【定义8.23】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，对于𝑉中的任意两个结点$v_{i},v_{j}$，如果从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$之间存在长度至少为1 的通路，则称从$v_{i}$到$v_{j}$可达，否则称从$v_{i}$到$v_{j}$不可达。 如果图$G$ 中从$v_{i}$到$v_{j}$可达，则从$v_{i}$到$v_{j}$长度最短的通路称为从$v_{i}$到$v_{j}$的短程线，该短线程的长度称从$\boldsymbol{v}_{i}$到$v_{j}$的距离，记为 $d\big(v_{i},v_{j}\big)$ 。如果从$\boldsymbol{v}_{i}$到$v_{j}$不可达，则记为 $d\bigl(v_{i},v_{j}\bigr)=\infty$ 。  
从上述定义可以看出，结点之间的可达性刻画的是图中两个结点之间的某种连通性关系。对于无向图来说，这种连通性关系显然是双向的，故若从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$ 可达，则从 $v_{j}$ 到 $v_{i}$ 可达，反之亦然；且有 $d\bigl(v_{i},v_{j}\bigr)=d\bigl(v_{j},v_{i}\bigr)$ 。对于有向图来说，这种连通性关系不一定满足对称性，故若从$v_{i}$到$v_{j}$ 可达，则不一定有从 $v_{j}$ 到 $v_{i}$ 可达，也不一定有 $d\big(v_{i},v_{j}\big)=$$d\big(v_{j},v_{i}\big)$ 。  
如前所述，图模型$G=\langle V,E\rangle$中结点之间的通路由该图所表示二元关系不断对其自身作复合运算产生，长度为$k$的通路其实就是二元关系$k$次幂运算的结果。因此，由图$G=\langle V,E\rangle$中结点之间可达性产生的二元关系其实就是图$G=\langle V,E\rangle$所表示二元关系的传递闭包。  
我们知道，对于有限集合$ V=\{v_{1},v_{2},\ldots,v_{n}\}$上的任意一个二元关系，构造其的传递闭包最多只需要进行$\cdot n$次方幂运算就可以了。也就是说，对于任意一个$n$结点的图模型，联结其中两个可达的结点最多只需要做$ n$次方幂运算，亦即对于图中任意两个可达结点，必然存在一条长度不大于$ n$的通路或回路联结这两个结点。  
以上是从二元关系及其传递闭包的角度对图中可达结点的联结通路或回路长度的分析，下面从图模型的角度对上述分析结论进行严格证明。  
【定理8.3】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中两个不同的结点$u$ 和 $v$，存在一条从$u$到 $v$通路，则必然存在一条长度不大于$:n-1$ 的基本通路。  
可类似证明如下基本回路存在性定理：  
【定理8.4】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中结点$v$，存在一条从$v$ 到 $v$回路，则必然存在一条长度不大于$^{\cdot n}$ 的基本回路。  
由以上两个定理可知，对于任意含有$ n$个结点的有向或无向线图$G=\langle V,E\rangle$，如果图从结点$u$ 到${v}$是可达的，那么必然存在从$u$ 到$v$且长度不超过$n$通路或回路。因此，根据通路或回路的计数方法，最多只需计算该图所对应邻接矩阵的$n$幂，即可判定图中任意两个结点之间是否可达。具体地说，假设𝐴是图$G=\langle V,E\rangle$的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则$B_{n}$中的元素为：  
$$
b_{i j}^{(n)}=a_{i j}^{(1)}+a_{i j}^{(2)}+\cdots+a_{i j}^{(n)}
$$  
显然，$b_{i j}^{(n)}$表示图$G$中从结点$v_{i}$到结点$v_{j}$的长度不超过$n$的通路总数，特别地，若$ i=j$，则$b_{i j}^{(n)}$为结点$v_{i}$到自身的长度不超过$n$的回路总数。因此，若$b_{i j}^{(n)}=0$，则结点$v_{i}$到$v_{j}$不可达，否则，结点$v_{i}$到$v_{j}$可达。由此得到有如下定理关于图模型的可达性定理：  
【定理8.5】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，$A=(a_{i j})_{n\times n}$为图 $G$ 的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则当$v_{i}\neq v_{j}$时，若${b_{i j}}^{(n)}>0$，则$v_{i}$到$v_{j}$可达，否则不可达，且有：  
$$
d\big(\boldsymbol{v}_{i},\boldsymbol{v}_{j}\big)==\begin{cases}\infty,&&\text{若}a_{ij}{}^{(1)},a_{ij}{}^{(2)},\cdots,a_{ij}{}^{(n)}\text{均为 0}\\\min\{a_{ij}^{(m)}|m=1,2,\cdots,n\},&&\text{否则}\end{cases}
$$  
在图模型的实际应用过程中，很多时候只需知道结点之间是否可达，而无需知道距离及通路数，由此得到如下可达性矩阵的定义：  
【定义8.24】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，则令$P=(p_{i j})_{n\times n}$是一个$n$阶矩阵，且满足：  
$p_{ij}=\begin{cases}1\:,~~~~~~结点从v_{i}到v_{j}至少存在一条长度不小于1的通路\\0\:,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~否则\end{cases}$    (8-8)  
称矩阵 $P$ 为图 $G$ 的可达性矩阵。  
从上述定义可以看出，可达性矩阵中的元素$\cdot p_{i j}$表示了从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$的可达性关系，表达了结点之间通过结点邻接关系的传递性得到可达性关系。因此，图中结点之间的可达性关系就是该图所表达邻接关系的传递闭包，可达性矩阵其实就是图邻接关系的传递闭包关系矩阵，即为可达性关系的关系矩阵。 显然，无向图的可达性矩阵为对称矩阵。  
若已知$B_{n}$ ，则只需将$B_{n}$中非零元素写成1，便可得到可达性矩阵 $P$，即有：  
$$
p_{i j}=\left\{\!\!\begin{array}{l l}{1,\qquad}&{b_{i j}^{\phantom{}(n)}\neq0}\\ {0,\qquad}&{b_{i j}^{\phantom{}(n)}=0}\end{array}\right.
$$  
由于可达性矩阵$P$是布尔矩阵，矩阵$P$中的元素$p_{i j}$只表示结点$v_{i}$到$v_{j}$是否可达，并不表示至于其通路数目及长度。因此，通过计算矩阵 $B_{n}$获得可达性矩阵$P$的方法效率较低。事实上，可类似于计算二元关系的闭包，使用邻接矩阵𝐴的布尔运算计算可达性矩阵$P$。  
【定理8.6】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，矩阵$A$和$P$分别是图$G$在该结点次序下的邻接矩阵和可达性矩阵，则有：  
$$
P=A^{(1)}\lor A^{(2)}\lor\cdots\lor A^{(k)}\lor\cdots\lor A^{(n)}
$$  
其中$A^{(k)}$表示进行矩阵$A$的$k$次布尔幂运算。"
定理8.7,定理,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.3  无向图的连通性']","{'实体类型': '定理', '内容': '无向图中结点之间的连通性关系是一个等价关系'}",,3,"前面我们学习了图的可达性概念及其判定，其描述的是图中两个结点之间是否可以通过一条或者多条通路进行联结，并从图的局部角度分别考察两个结点之间的连通关系。现在我  
们从全局性角度考察整个图中多个结点之间的连通关系，将两个结点之间的可达性概念推广到整个图中任意两个结点之间的可达性，由此得到图的连通性和连通图的相关概念。  
在图的连通性方面，无向图和有向图之间具有很大的差异。因此，我们分别讨论无向图和有向图的连通性。本小节主要介绍和讨论无向图连通性的概念与性质。首先给出无向图连通图的相关概念，具体定义如下：  
【定义8.25】设 $G=\langle V,E\rangle$ 为任一给定的无向图，对于图中的两个结点$v_{i}$ 与 $v_{j}$，如果从$\boldsymbol{v}_{i}$到$v_{j}$是可达的，则称从 $v_{i}$ 到 $v_{j}$是连通的，表示为[ $v_{i}\ \ ,v_{j}]$。规定图中任何结点与其自身是连通的。如果无向图$G$中任何两个结点之间都是连通的，则称该图为无向连通图或连通无向图，简称为连通图；否则，称$G$ 是非连通无向图，简称为非连通图。  
显然，无向图中两个结点之间的连通性是双向的，也就是说两结点之间的连通关系满足对称性，即：若有$v_{i}$ 到 $v_{j}$可达则必有$v_{j}$ 到 $v_{i}$可达。故在无向图中，也可将从${v}_{i}$ 到 $v_{j}$的连通说成$v_{i}$ 与 $v_{j}$连通。另外，注意到平凡图有且只有一个结点，根据无向图中结点连通性的规定，它是一种特殊的连通图。  
下面的定理表明，无向图模型中结点之间的连通性关系是一个等价关系：  
【定理8.7】设 $G=\langle V,E\rangle$ 为任一给定的无向图，其结点集为 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，令$R$ 是集合$\cdot V=\{v_{1},v_{2},\ldots,v_{n}\}$上结点之间的连通关系，即有：  
$R=\{\langle u,v\rangle|u,v\in V\}$, 且从$u$到𝑣连通}       （8-10）  
则$R$是集合𝑉上的一个等价关系。  
既然无向图模型中结点之间的连通性关系$R$是一个等价关系，那么就可以使用等价关系$R$ 将无向图 $G$ 的结点集合 𝑉 划分为若干互不相同的等价类，记为   $V_{1},V_{2},\ldots,V_{k}$ 。在这些等价类 中，相互连通的结点属于同一个等价类，不连通的结点属于不同的等价类。由此得到无向图模型的连通分支的概念，具体定义如下：  
【定义8.26】设 $G=\langle V,E\rangle$ 为任一给定的无向图$R$是图$G$结点集合𝑉上的连通性关系，则以关系𝑅的每个等价类为结点集的导出子图都称为图$G$的一个连通分支，并用$p(\mathbf G)$表示图𝐺的连通分支总数。  
由上述定义可知，如果无向图$G=\langle V,E\rangle$的结点连通性关系$R$作为一个等价关系，将结点集𝑉划分为$k$个不同的等价类$V_{1},V_{2},\ldots,V_{k}$，则由它们导出的子图$G(V_{1}),G(V_{2}),\cdots,G(V_{k})$均为图$G$的连通分支。因此，可以根据无向图中结点之间的连通关系实现对图模型的一个分解。显然，若   $p(G)=1$ ，则 $G$ 是连通图。若   $p(G)>1$ ，则   $G$ 是非连通图。  
【定义8.27】对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在结点集𝑉的某个子集 $V^{\prime}\subseteq$$V$ ，使得 $p(G-V^{\prime})>p(G)$ ，且对于 $V^{\prime}$的任何真子集 $V^{\prime\prime}$，有 $p(G-V^{\prime\prime})=p(G)$，则称 $V^{\prime}$为 $G$ 的点割集。如果点割集中只有一个结点 $v$ ，则称 $v$ 为割点。  
由上述定义可知，可通过删除图中适当结点以破坏图结构的方式考察图的连通程度。图中有些结点组成的集合在图的连通性中起着非常关键的作用，删除这些结点后会使得连通图变成非连通图，使得非连通图变得更加不连通，或者增加连通分支的数目。  
显然，对图中的任意一个点割集，该集合中所有结点都是由该点割集增加连通分支时必须同时删除的结点。例如在图8-40 所示的图$G_{1}$中，集合$\{v_{4}\},\{v_{1},v_{3}\}$都是点割集，但$\{v_{1},v_{3},v_{4}\}$则不是点割集，因为要增加图$G_{1}$的连通分支，不必同时删除结点$v_{1},v_{3},v_{4}$。  
需要注意的是，由于删除割点后，割点的邻接边也需要删除，因此我们用虚线表示已删除的边或者结点。同样，对下文所要介绍的边割集也做类似处理。  
同样，可以通过删除图中适当的边以破坏图结构的方式考察图模型的连通程度，由此可以得到边割集的相关概念，具体定义如下：  
【定义8.28】 对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在边集$E$的某个子集 $E^{\prime}\subseteq$$E$ ，使得 $p(G-\ E^{\prime})>p(G)$ ，且对于 $E^{\prime}$的任何真子集 $E^{\prime\prime}$，有 $p(G-\ E^{\prime\prime})=p(G)$，则称$V^{\prime}$为 $G$ 的边割集。如果点割集中只有一个条边  $e$ ，则称 $e$为割边或桥。  
![图8-42 例题8.24 图模型  ](images/6c126be3977ab4a2c63afc18255dc22be84fa010ee39891af7c0eba551970203.jpg)  
关于点割集与边割集，需要注意以下几个要点：  
（1）完全图 $K_{n}$ 无点割集，因为从 $K_{n}$ 中删除 $k\leq n-1$个顶点后，所得图仍然是连通的。  
（2）$n$ 阶零图既无点割集也无边割集。  
（3）对于连通图 $G$，$E^{\prime}$为 $G$ 的边割集，则必有 $p(G-E^{\prime})=2$ 。 因为删除一条边最多只能增加一个连通分支。  
（4）对于连通图 $G\ \ ,V^{\prime}$为 $G$ 的点割集，则 $p(G-V^{\prime})\geq2$，而且可能 $p(G-E^{\prime})>2$因为删除一个结点可能增加多个连通分支。  
从上述例题可以看出，对于任意给定的一个无向连通图，经常会有多个点割集或边割集，而且每个集合中所含元素的个数也不一样。此时，需要重点关注的应该是那些个数最小的集合。因为这些集合刻画了图连通结构中最为薄弱的环节，反映了连通图的最低连通程度。由此得到无向图连通图的点连通度与边连通度的概念，具体定义如下：  
【定义8.29】对于任意给定的一个无向连通图 $G=\langle V,E\rangle$，令：$\kappa(G){=}m i n\{|V^{\prime}||V^{\prime}$为G 的点割集}；$\lambda(\mathbf{G})=\operatorname*{min}\{|E^{\prime}||E^{\prime}$为G 的边割集} 并称 $\kappa(G)$ 为图 $G$ 的点连通度，$\lambda(G)$ 为图 $G$ 的边连通度。  
显然，点连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少结点数，边连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少边数。  
例如，对于图8-44 所示的无向连通图$G$ ，有$\kappa(G)=2$，$\lambda(G)=3$；对于图8-45 所示的彼得森图，有$\kappa(G)=\lambda(G)=3$。  
![图8-44 图的连通度  ](images/28f9ee3f26ab71faac7e5360d73417062a5a59d8421071b9feb627483727c42a.jpg)  
![图8-45  彼得森图  ](images/80ddd389b19bdc8904c989e51a73f2c183cb8c6f73b8b9c479ee3affcb66c7c0.jpg)  
关于无向连通图的点连通度$\kappa(G)$和边连通度$\lambda(\mathrm{G})$，需要注意以下几个要点：  
（1）如果 $G$是平凡图或非连通图，则规定 $\kappa(G)=\lambda(G)=0;$  
（2）如果$G$ 是完全图 $K_{n}$ ，由于 $G$ 中无点割集，当删除 $n-1$个顶点后，$G$ 为平凡图，故 $\kappa(G)=n-1$。  
（3）如果 $G$ 中存在割点，则 $\kappa(G)=1$；如果 $G$ 中存在割边，则 $\lambda(G)=1$。对于任何无向图 $G$ ，其点连通度 $\kappa$ 、边连通度 $\lambda$ 与结点最小度 δ 之间有如下关系：  
【定理8.8】对于任一无向图$G=\langle V,E\rangle$ ，均成立下列不等式：
$$
\kappa(G)\leq\lambda(G)\leq\delta\ (G)
$$"
定理8.8,定理,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.3  无向图的连通性']","{'实体类型': '定理', '内容': '对于任一无向图，点连通度小于等于边连通度小于等于结点最小度'}",,3,"前面我们学习了图的可达性概念及其判定，其描述的是图中两个结点之间是否可以通过一条或者多条通路进行联结，并从图的局部角度分别考察两个结点之间的连通关系。现在我  
们从全局性角度考察整个图中多个结点之间的连通关系，将两个结点之间的可达性概念推广到整个图中任意两个结点之间的可达性，由此得到图的连通性和连通图的相关概念。  
在图的连通性方面，无向图和有向图之间具有很大的差异。因此，我们分别讨论无向图和有向图的连通性。本小节主要介绍和讨论无向图连通性的概念与性质。首先给出无向图连通图的相关概念，具体定义如下：  
【定义8.25】设 $G=\langle V,E\rangle$ 为任一给定的无向图，对于图中的两个结点$v_{i}$ 与 $v_{j}$，如果从$\boldsymbol{v}_{i}$到$v_{j}$是可达的，则称从 $v_{i}$ 到 $v_{j}$是连通的，表示为[ $v_{i}\ \ ,v_{j}]$。规定图中任何结点与其自身是连通的。如果无向图$G$中任何两个结点之间都是连通的，则称该图为无向连通图或连通无向图，简称为连通图；否则，称$G$ 是非连通无向图，简称为非连通图。  
显然，无向图中两个结点之间的连通性是双向的，也就是说两结点之间的连通关系满足对称性，即：若有$v_{i}$ 到 $v_{j}$可达则必有$v_{j}$ 到 $v_{i}$可达。故在无向图中，也可将从${v}_{i}$ 到 $v_{j}$的连通说成$v_{i}$ 与 $v_{j}$连通。另外，注意到平凡图有且只有一个结点，根据无向图中结点连通性的规定，它是一种特殊的连通图。  
下面的定理表明，无向图模型中结点之间的连通性关系是一个等价关系：  
【定理8.7】设 $G=\langle V,E\rangle$ 为任一给定的无向图，其结点集为 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，令$R$ 是集合$\cdot V=\{v_{1},v_{2},\ldots,v_{n}\}$上结点之间的连通关系，即有：  
$R=\{\langle u,v\rangle|u,v\in V\}$, 且从$u$到𝑣连通}       （8-10）  
则$R$是集合𝑉上的一个等价关系。  
既然无向图模型中结点之间的连通性关系$R$是一个等价关系，那么就可以使用等价关系$R$ 将无向图 $G$ 的结点集合 𝑉 划分为若干互不相同的等价类，记为   $V_{1},V_{2},\ldots,V_{k}$ 。在这些等价类 中，相互连通的结点属于同一个等价类，不连通的结点属于不同的等价类。由此得到无向图模型的连通分支的概念，具体定义如下：  
【定义8.26】设 $G=\langle V,E\rangle$ 为任一给定的无向图$R$是图$G$结点集合𝑉上的连通性关系，则以关系𝑅的每个等价类为结点集的导出子图都称为图$G$的一个连通分支，并用$p(\mathbf G)$表示图𝐺的连通分支总数。  
由上述定义可知，如果无向图$G=\langle V,E\rangle$的结点连通性关系$R$作为一个等价关系，将结点集𝑉划分为$k$个不同的等价类$V_{1},V_{2},\ldots,V_{k}$，则由它们导出的子图$G(V_{1}),G(V_{2}),\cdots,G(V_{k})$均为图$G$的连通分支。因此，可以根据无向图中结点之间的连通关系实现对图模型的一个分解。显然，若   $p(G)=1$ ，则 $G$ 是连通图。若   $p(G)>1$ ，则   $G$ 是非连通图。  
【定义8.27】对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在结点集𝑉的某个子集 $V^{\prime}\subseteq$$V$ ，使得 $p(G-V^{\prime})>p(G)$ ，且对于 $V^{\prime}$的任何真子集 $V^{\prime\prime}$，有 $p(G-V^{\prime\prime})=p(G)$，则称 $V^{\prime}$为 $G$ 的点割集。如果点割集中只有一个结点 $v$ ，则称 $v$ 为割点。  
由上述定义可知，可通过删除图中适当结点以破坏图结构的方式考察图的连通程度。图中有些结点组成的集合在图的连通性中起着非常关键的作用，删除这些结点后会使得连通图变成非连通图，使得非连通图变得更加不连通，或者增加连通分支的数目。  
显然，对图中的任意一个点割集，该集合中所有结点都是由该点割集增加连通分支时必须同时删除的结点。例如在图8-40 所示的图$G_{1}$中，集合$\{v_{4}\},\{v_{1},v_{3}\}$都是点割集，但$\{v_{1},v_{3},v_{4}\}$则不是点割集，因为要增加图$G_{1}$的连通分支，不必同时删除结点$v_{1},v_{3},v_{4}$。  
需要注意的是，由于删除割点后，割点的邻接边也需要删除，因此我们用虚线表示已删除的边或者结点。同样，对下文所要介绍的边割集也做类似处理。  
同样，可以通过删除图中适当的边以破坏图结构的方式考察图模型的连通程度，由此可以得到边割集的相关概念，具体定义如下：  
【定义8.28】 对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在边集$E$的某个子集 $E^{\prime}\subseteq$$E$ ，使得 $p(G-\ E^{\prime})>p(G)$ ，且对于 $E^{\prime}$的任何真子集 $E^{\prime\prime}$，有 $p(G-\ E^{\prime\prime})=p(G)$，则称$V^{\prime}$为 $G$ 的边割集。如果点割集中只有一个条边  $e$ ，则称 $e$为割边或桥。  
![图8-42 例题8.24 图模型  ](images/6c126be3977ab4a2c63afc18255dc22be84fa010ee39891af7c0eba551970203.jpg)  
关于点割集与边割集，需要注意以下几个要点：  
（1）完全图 $K_{n}$ 无点割集，因为从 $K_{n}$ 中删除 $k\leq n-1$个顶点后，所得图仍然是连通的。  
（2）$n$ 阶零图既无点割集也无边割集。  
（3）对于连通图 $G$，$E^{\prime}$为 $G$ 的边割集，则必有 $p(G-E^{\prime})=2$ 。 因为删除一条边最多只能增加一个连通分支。  
（4）对于连通图 $G\ \ ,V^{\prime}$为 $G$ 的点割集，则 $p(G-V^{\prime})\geq2$，而且可能 $p(G-E^{\prime})>2$因为删除一个结点可能增加多个连通分支。  
从上述例题可以看出，对于任意给定的一个无向连通图，经常会有多个点割集或边割集，而且每个集合中所含元素的个数也不一样。此时，需要重点关注的应该是那些个数最小的集合。因为这些集合刻画了图连通结构中最为薄弱的环节，反映了连通图的最低连通程度。由此得到无向图连通图的点连通度与边连通度的概念，具体定义如下：  
【定义8.29】对于任意给定的一个无向连通图 $G=\langle V,E\rangle$，令：$\kappa(G){=}m i n\{|V^{\prime}||V^{\prime}$为G 的点割集}；$\lambda(\mathbf{G})=\operatorname*{min}\{|E^{\prime}||E^{\prime}$为G 的边割集} 并称 $\kappa(G)$ 为图 $G$ 的点连通度，$\lambda(G)$ 为图 $G$ 的边连通度。  
显然，点连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少结点数，边连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少边数。  
例如，对于图8-44 所示的无向连通图$G$ ，有$\kappa(G)=2$，$\lambda(G)=3$；对于图8-45 所示的彼得森图，有$\kappa(G)=\lambda(G)=3$。  
![图8-44 图的连通度  ](images/28f9ee3f26ab71faac7e5360d73417062a5a59d8421071b9feb627483727c42a.jpg)  
![图8-45  彼得森图  ](images/80ddd389b19bdc8904c989e51a73f2c183cb8c6f73b8b9c479ee3affcb66c7c0.jpg)  
关于无向连通图的点连通度$\kappa(G)$和边连通度$\lambda(\mathrm{G})$，需要注意以下几个要点：  
（1）如果 $G$是平凡图或非连通图，则规定 $\kappa(G)=\lambda(G)=0;$  
（2）如果$G$ 是完全图 $K_{n}$ ，由于 $G$ 中无点割集，当删除 $n-1$个顶点后，$G$ 为平凡图，故 $\kappa(G)=n-1$。  
（3）如果 $G$ 中存在割点，则 $\kappa(G)=1$；如果 $G$ 中存在割边，则 $\lambda(G)=1$。对于任何无向图 $G$ ，其点连通度 $\kappa$ 、边连通度 $\lambda$ 与结点最小度 δ 之间有如下关系：  
【定理8.8】对于任一无向图$G=\langle V,E\rangle$ ，均成立下列不等式：
$$
\kappa(G)\leq\lambda(G)\leq\delta\ (G)
$$"
定理9.1,定理,"['第九章  树的基本理论与算法', '§ 9.1 无向树的基本知识', '9.1.1  无向树的概念与性质']","{'实体类型': '定理', '条件': '假设G是任意给定的一个无向图模型，且|V|=n,|E|=m', '结论': '下述各个命题相互等值：（1）G连通而不含回路（即G是树）；（2）G中无回路且m=n-1；（3）G是连通的且m=n-1；（4）G中无回路，但在G中任意增加一条新边，就会得到唯一一条基本回路；（5）当n≥2时，G是连通的，但删除G中的任一条边后，便不连通；（6）当n≥2时，G中每一对结点之间都有唯一的一条基本通路'}",,3,"我们知道，自然界中任何一棵树都一个连通的整体，其根、枝、叶之间总相互畅通以保证养分能够顺利到达树的各个部分。此外，从树的结构上看，树的根、枝、叶之间没有任何回路。将树的上述两个基本特征进行抽象，就可得到树的本质结构特征：树模型其实就是一种无环的连通无向图。由此得到如下关于树的定义：  
【定义9.1】连通无回路的无向图称为树。树中悬挂结点称为树叶结点，简称为叶结点或叶，其它结点称为分支点或内点。平凡图称为空树。所有连通分支均为树的无向图称为森林，单个的树模型本身可看成是一个森林。  
【定理9.1】假设${G}=\left\langle{V},{E}\right\rangle$是任意给定的一个无向图模型，且 $\vert V\vert=n,\vert E\vert=m$，则下述各个命题相互等值：  
（1）$G$连通而不含回路（即$G$是树）；  
（2）$G$中无回路且$m=n-1$；  
（3）$G$是连通的且$m=n-1$；  
（4）$G$中无回路，但在$G$中任意增加一条新边，就会得到唯一一条基本回路；  
（5）当$n\geq2$时，$G$是连通的，但删除$G$中的任一条边后，便不连通；  （6）当$n\geq2$时，$G$中每一对结点之间都有唯一的一条基本通路。  
下面定理9.2 给出了关于树模型叶结点的一个基本性质：  
【定理 9.2】 任意非平凡树$T(n,m)$都至少有两片叶。【分析】 利用握手定理和$m=n-1$即可证明。"
定理9.2,定理,"['第九章  树的基本理论与算法', '§ 9.1 无向树的基本知识', '9.1.1  无向树的概念与性质']","{'实体类型': '定理', '结论': '任意非平凡树T(n,m)都至少有两片叶', '证明方法': '利用握手定理和m=n-1即可证明'}",,3,"我们知道，自然界中任何一棵树都一个连通的整体，其根、枝、叶之间总相互畅通以保证养分能够顺利到达树的各个部分。此外，从树的结构上看，树的根、枝、叶之间没有任何回路。将树的上述两个基本特征进行抽象，就可得到树的本质结构特征：树模型其实就是一种无环的连通无向图。由此得到如下关于树的定义：  
【定义9.1】连通无回路的无向图称为树。树中悬挂结点称为树叶结点，简称为叶结点或叶，其它结点称为分支点或内点。平凡图称为空树。所有连通分支均为树的无向图称为森林，单个的树模型本身可看成是一个森林。  
【定理9.1】假设${G}=\left\langle{V},{E}\right\rangle$是任意给定的一个无向图模型，且 $\vert V\vert=n,\vert E\vert=m$，则下述各个命题相互等值：  
（1）$G$连通而不含回路（即$G$是树）；  
（2）$G$中无回路且$m=n-1$；  
（3）$G$是连通的且$m=n-1$；  
（4）$G$中无回路，但在$G$中任意增加一条新边，就会得到唯一一条基本回路；  
（5）当$n\geq2$时，$G$是连通的，但删除$G$中的任一条边后，便不连通；  （6）当$n\geq2$时，$G$中每一对结点之间都有唯一的一条基本通路。  
下面定理9.2 给出了关于树模型叶结点的一个基本性质：  
【定理 9.2】 任意非平凡树$T(n,m)$都至少有两片叶。【分析】 利用握手定理和$m=n-1$即可证明。"
定理9.6,定理,"['第九章  树的基本理论与算法', '§ 9.2 根树的基本知识', '9.2.1  有向树与根树']","{'实体类型': '定理', '内容': '在k元完全树中，若叶为t，分支点数为i，则下式成立：(k-1)×i=t-1'}",,3,"我们知道无向树是一种由无向图构成的特殊图模型.那么如何定义和处理由有向图构成的有向树模型呢？现在就来讨论这个问题，首先给出如下有向树模型的定义：  
【定义9.4】对于任意一个给定的有向图，如果略去其所有有向边的方向而得到的无向图是一棵树，则该有向图称为一棵有向树。  
![图 9-12 有向树与非有向树  ](images/2fdb86589dcfaa78bb54f5eaf1ee2b9affe960919c61d426d8acd7eff5e51d45.jpg)  
例如，对于图9-12 所示若干有向图，略去其所有边的方向，则由图9-12(a)、（b）得到的无向图都是树，而由图9-12（c）得到的无向图有回路，由图9-12（d）得到的无向图为森林。因此，图9-12（a）、（b）均是有向树，图9-12（c）、（d）均不是有向树。  
从上述定义及例题可以看出，有向树模型的连通性与无环性是由其伴随的无向图模型决定的，或者说是略去边的方向而直接将有向树看成是无向树.这与一般有向图模型的概念和处理方式有很大差异.因此，如果在树模型的框架下讨论有向树中某条或某几条边在方向上的差异，则没有太大意义，甚至有时还会引起概念上的混淆。  
事实上，自然界中的树模型本身就蕴含着一种方向，这种方向体现在由树根、树枝和树叶结点所构成的层次结构当中，由树根、树枝和树叶结点之间在属性上的差异来刻画边的方向性，不过这种边的方向不是个别边的方向而是所有边的整体方向，即从根到叶的方向或从叶到根的方向。对自然界中树模型的上述特征进行抽象，得到如下根树的概念：  
【定义9.5】对于一棵非平凡的有向树，如果恰有一个结点的入度为0，其余所有结点的入度均为1，则称之为根树或外向树.入度为0 的结点称为根结点,简称为根；出度为0 的结点称为叶结点，简称为叶；入度为1，出度大于0 的称为内结点，简称为内点；又将内点和根统称为分支结点，简称为分支点。在根树中，从根到任一结点的通路长度，称为该结点的层数；所有结点的层数最大值称为根树的高。  
通常使用倒置法表示根树，即把根画在最上方，叶画在最下方，有向边的方向均指向下方。例如，图9-13（a）中的有向树就是一棵根树，其中$v_{1}$为根，$v_{5},v_{6},v_{8},v_{9},v_{10},v_{12},v_{13}$为叶，$v_{2},v_{3},v_{4},v_{7},v_{11}$为内点。其中，$v_{1}$处在第0 层，层数为0；$v_{2},v_{3},v_{4}$同处在第一层，层数为1；$v_{5},v_{6},v_{7},v_{8},v_{9}$同处在第二层，层数为2；$v_{10},v_{11},v_{12}$同处在第三层，层数为3；$v_{13}$处在第四层，层数为4；这棵树的高度为4。  
![图9-13 根树的方向与方向省略  ](images/f923bd763ba9a19de150bb3a9be8189594c2d07589f0b79f2493ff5c6c70768a.jpg)  
从根树的定义及上述例题不难发现，根树作为一种特殊的有向树其所有边均是朝着一个方向，即是从根结点到叶结点的方向，如图9-13（a）所示。既然如此就可以对这种特殊的有向图进行化简，即省略根树中所有边的方向将其转化为无向树，如图9-13（b）所示.由此可知，根树其实是一种具有根、枝、叶等层次结构的特殊无向树。  
![图9-14 根树的层次结构  ](images/d86c7aab6ba7ea9d62cfd7298cb652c45b9ae862b8d84a5cb286853843255862.jpg)  
如图9-14 所示，根树是一种由子树不断嵌套而产生的一种层次结构模型，故还可用如下递归的方式定义根树：  
【定义9.6】树是一个$n(n>0)$元有限集，集合中所有数据元素具有如下层次关系：当$n=0$ 时，集合为空集，称之为空树；当$n>0$ 时，集合中有且只有一个特定的结点，称之为树模型的根；当$n>1$ 时，除根以外的其余结点可分为$m(m>0)$个互不相交的有限集$T_{1},T_{2},\cdots,T_{m}$，其中每个集合本身又是一棵树，并称$T_{1},T_{2},\cdots,T_{m}$称为根的子树。  
例如，图9-15 表示一个具体的树模型结构。该树有10 个结点，其中𝐴是根结点，其余结点被分为 3  个互不相交的子集： $T_{1}=\{B,E,F\},T_{2}=\{C,G\},T_{3}=\{D,H,I,J\}$ ； $T_{1}$ ， $T_{2}$ ， $T_{3}$ 都 是 𝐴 的子树，它们本身也分别是一棵树。  
![](images/64aed744b0075ece5ec5a03893d3b845267949822e6760ad07e255b850f44d71.jpg)  
也可用家族关系表示根树中各节点间的关系。  
【定义9.7】在根树中，若从结点$v_{i}$到$v_{j}$可达，则称$v_{i}$是$v_{j}$的祖先，$v_{j}$是$v_{i}$的后代；又若 $\langle v_{i},v_{j}\rangle$是根树中的有向边，则称$v_{i}$是$v_{j}$的父亲，$v_{j}$是$v_{i}$的儿子；如果两个结点是同一个结点的儿子，则称这两个结点是兄弟。  
例如，对于图9-16 所表示的树，结点𝐴 的出度为3，结点$B$的出度为2，结点𝑀的出度为0；结点$A$的孩子为$(B,C,D)$，结点$B$的孩子为$(E,F)$；结点𝐴的层次为1，结点𝑀的层次为4 ； 叶结点有 $(K,L,F,G,M,I,J)$ ， 分枝结点有 $(A,B,C,D,E,H)$ ； 结点 𝐼 的双亲为 $D$ ， 结点 𝐿 的双亲 为$E$；结点$B,C,D$为兄弟，结点$K$，$L$为兄弟；树的高度为4；结点𝐴是结点$F$、$G$的祖先，结点$B$，$C$是结点𝐴的子孙。  
有时还会在根树的同层次的兄弟结点之间规定具体的大小排序，一般是从左到右进行排序，有时也可以用边的次序代替结点的次序。  
在根树的实际应用中，例如对目标的排序与查找等，需要经常对其中间结点的分支数进行度量、设计和分析，为此给出如下关于$\cdot k$元根树或$k$叉根树的概念：  
【定义9.8】 在根树𝑇中，若每个分支点至多有${k}$个儿子，则称𝑇为𝒌元树或𝒌叉树；若每个分支点都恰有${k}$个儿子，则称𝑇为完全$ k$元树或完全$ k$叉树；若$k$元树𝑇的兄弟结点之间有序，则称𝑇为𝒌元有序树或$k$叉有序树；若完全$ k$元树𝑇的兄弟结点之间有序，则称𝑇为有序完全𝒌元树或有序完全$k$叉树。在根树$T$中，任一结点$v$及其所有后代导出的子图$𝑇′$称为$𝑇$的以$v$为根的子树.当然$T^{\prime}$也可以有自己的子树.有序二元树的每个结点$𝑣$至多有两个儿子，分别称为 $𝑣$ 的左儿子和右儿子，至多有两棵子树，分别称为 $𝑣$ 的左子树和右子树。  
注意：以$v$为根的子树包含$𝑣$，而$𝑣$的左右子树则不包含$𝑣$  
【定理9.6】在$k$元完全树中，若叶为𝑡，分支点数为 $i$，则下式成立：  
$(k-1)\times i=t-1~~~~~~~~~~~~~~\quad(9-1)$"
定理9.7,定理,"['第九章  树的基本理论与算法', '§ 9.2 根树的基本知识', '9.2.3  前缀码与最优树']","{'实体类型': '定理', '内容': ""假设T是一棵带有权值为|w1≤w2≤⋯≤wt|二元最优树。其中权w1和w2所对应叶结点必定是兄弟，并且如果将其父结点由分支结点改为带权w1+w2的叶结点，则由此得到的一棵新树T'也是一棵最优树""}",,3,"在计算机及通信技术中，常用二进制编码来表示符号，称之为码字。例如，可用00、01、10、11 分别表示字母A、B、C、D。如果字母A、B、C、D 出现的频率是一样的，则传输100 个字母会使用200 个二进制位。但实际上字母出现的频率很不一样，比如A 出现的频率为$60\%$，B 出现的频率为$25\%$，C 出现的频率为$10\%$，D 出现的频率为$5\%$。能否用不等长的二进制序列表示字母A、B、C、D，使传输的信息的二进制位尽可能少呢？  
事实上，可用000 表示字母D，用001 表示字母C，01 表示B，1 表示A。此时，传输100 个字母所用的二进制位为：  
$$
3\times5+3\times10+2\times25+1\times60=155
$$  
这种表示比用等长的二进制序列表示法好，节省了二进制位。  
在编码时还要考虑一个问题，就是二进制序列的分词问题。例如，如果用1 表示A，用00 表示B，用001 表示C，用000 表示D 时，那么在接收到信息001000 时，则无法辨别它是CD 还是BAD。因此，在使用二进制序列表示A、B、C、D 等字母时，需要一些特定的编码策略以避免出现类似容易混淆的情况。为此引入如下前缀及前缀码的概念：  
【定义9.9】设$a_{1}a_{2}\cdots a_{n-1}a_{n}$是长度为$n$的符号串，则称其子串$a_{1},a_{1}a_{2},a_{1}a_{2}a_{3},\cdots\,,$,$a_{1}a_{2}\cdots a_{n-1}$分别为$a_{1}a_{2}\cdots a_{n-1}a_{n}$的长度为1，2，⋯，$n-1$的前缀。  
【定义9.10】设$A=\{b_{1},b_{2},\cdots,b_{m}\}$是一个符号串集合，若对任意$b_{i}$，$b_{j}\in A$，$b_{i}\neq$$b_{j}$，$b_{i}$不是$.b_{j}$的前缀，$b_{j}$也不是$b_{i}$的前缀，则称𝐴为前缀码。若在符号串$b_{i}\bigl(i=1,2,\cdots,\ \mathsf{m}\bigr)$中，只出现0 和1 两个符号，则称𝐴为二元前缀码,在不引起混淆时简称为前缀码。  
例如{1，01，001，000}是前缀码，而{1，11，001，0011}不是前缀码。那么如何产生前缀码呢？事实上，可用一棵二元树来产生一个二元前缀码：  
给定一棵有𝑡片叶二元树𝑇。设$v$是𝑇的任一分支点，则$v$至少一个儿子至多两个儿子。若𝑣有两个儿子，则在由𝑣引出的两条边上，左边的标0，右边的标1；若$v$只有一个儿子，在$v$引出的边上可标0 也可标1。设${v}_{i}$为𝑇的任意一片叶，从树根到$v_{i}$的通路上各边的标号组成的符号串放在$v_{i}$处，$t$片叶处的𝑡个符号串组成的集合为一个二元前缀码。  
由上述做法可知，$v_{i}$中符号串的前缀码均在${v}_{i}$所在通路上，因而所得集合为0 和1 组成前缀码。显然，若𝑇存在带一个儿子的分支点，则𝑇产生不唯一的前缀码， 𝑇若为二元完全树，则𝑇产生唯一的前缀码。例如，图9-26 所示二元树产生的前缀码为：  
![](images/0e364ce62d589d6e701c3aee01259a3ff2b2c5a6aebc38eaf711e5ecde762552.jpg)  
![](images/c850aef1e068c66827fea6f4c98a09846df47e5a769a3618a27f7a6bb63e479e.jpg)  
【定义9.11】设有一棵二元树𝑇，若对其所以的𝑡片叶赋以权值$w_{1},w_{2},\cdots,w_{t}$，则称之为赋权二元树；若权为$w_{i}$的叶的层数为$L(w_{i})$，则称：  
$$
w(T)=\sum_{i=1}^{t}w_{i}\times L(w_{i})
$$  
为该赋权二元树 𝑇 的权；   $w(T)$ 最小的二元树称为最优树。  
下面的定理9.7 给出了构造最优树的一个基本思路：  
【定理9.7】假设𝑇是一棵带有权值为$|w_{1}\leq w_{2}\leq\cdots\leq w_{t}$二元最优树。其中权$w_{1}$和$w_{2}$所对应叶结点必定是兄弟，并且如果将其父结点由分支结点改为带权$w_{1}+w_{2}$的叶结点，则由此得到的一棵新树$T^{\prime}$也是一棵最优树。  
根据上述定理，美国计算机科学家霍夫曼在1952 年提出一种构造最优树的算法，通常称之为霍夫曼算法。对于任意给定的权值 $w_{1}\leq w_{2}\leq\cdots\leq w_{t}$，算法的基本思路是：要画一棵带有$t$个权的最优树，则可依据定理9.7 将问题转化为要画一棵带有𝑡−1个权的最优树，依次类推.具体做法是：首先找出两个最小的权值设为$w_{1}$和$w_{2}$，然后对𝑡−1个权$w_{1}+$$w_{2},w_{3},\cdots,w_{t}$求作最优树，并将这棵最优树中权$w_{1}+w_{2}$对应的叶结点分叉出两个儿子，依次类推，直到只有一个权值的最优树的情形.具体算法过程如下：  
（1）初始：令${\cal{S}}=\{w_{1},w_{2},\cdots,\}$ ;  
（2）从𝑆中取出两个最小的权$w_{i}$和$w_{j}$，画结点$v_{i}$，带权$w_{i}$，画结点$v_{j}$，带权$w_{j}$。画$v_{i}$和$v_{j}$的父亲$v$，连接$v_{i}$和$v$，$v_{j}$和$v$，令$v$带权$.w_{i}+w_{j}$；  
（3）令$S=\left(S-\left\{w_{i},w_{j}\right\}\right)\cup\{w_{i}+w_{j}\};$  
（4）判断𝑆是否只含一个元素。若是，则停止，否则转（2）。  
从上述算法过程可以看出，霍夫曼算法采用递推的方式构造最优树，核心思想是逐步从从带权为$w_{1}+w_{2},w_{3},\cdots,w_{t}$的最优树${T^{\prime}}$中得到带权为$w_{1}$，$w_{2}$，⋯，$w_{t}$的最优树。  
下面结合具体实例介绍最优树的具体构造过程："
实数集合上的加法,性质,"['第十一章  抽象代数结构通论', '§ 11.1 代数结构的基本概念']","{'实体类型': '性质', '本质相同对象': '正实数上的乘法', '对应关系': '加法中的0其实就是乘法中的1'}",,2,抽象代数结构的基本思想是以主动的方式定义一个由若干抽象对象为元素构成的集合，并在这个集合上定义一个或多个抽象运算，由此形成一个抽象的代数运算系统，然后通过研究和讨论这个代数运算系统的运算性质获得该运算系统的结构。相对于传统的初等代数，这是一种全新的思维方式和观察问题的角度。从这个角度看过去，会得到很多令人惊讶的新认识。例如，集合代数有交、并、补运算，命题代数有与、或、非运算，从抽象代数结构上看，两者的运算性质完全相同，或者说两者是同一抽象代数不同表现形式；再如，实数集合上的加法和正实数上的乘法也是本质相同外表不同，加法中的0 其实就是乘法中的1。
容斥原理,原理,"['一、容斥原理及其应用', '1.3.2 容斥原理与鸽笼原理', '§ 1.3 有限集的基本计数技术', '第一章  集合与计数基础']","{'实体类型': '原理', '定义': ['将加法原理中多个集合互不相交的条件去掉后得到的原理', '对于任意给定的两个有限集合，成立如下的容斥原理'], '特点': '是加法原理的一种推广形式', '应用': '用于计算两个集合的并集的基数', '条件': '假设A和B是任意两个有限集合', '结论': '|A∪B|=|A|+|B|-|A∩B|', 'name': '容斥原理'}",,3,在前述加法原理中，我们将某个集合看成是由多个集合的并运算而构成，并且要求参与并运算的多个集合互不相交。现在将加法原理中多个集合互不相交的条件去掉，由此便可得到容斥原理。因此，容斥原理可看成是加法原理的一种推广形式。
宽带分配问题,算法,"['第七章 函数与特殊函数', '§ 7.4 有限集的置换函数', '7.5.2 宽带分配问题']","{'实体类型': '算法', '应用': '解决互联网上语音视频业务的宽带分配', '特点': '基于优先级函数进行优化分配', '条件': '保证分配的宽带之和不超过网络总宽带', '结论': '通过递推公式计算最大优先级收益'}",,3,"随着互联网上语音视频业务的飞速增长，宽带成了影响服务质量的主要因素。一般来说，用户使用的宽带分成两部分：静态宽带和动态宽带。静态宽带是运营商承诺的最小宽带，已经预留给每个用户；动态宽带被所有的用户共享，根据需求进行分配。语音视频业务服务过程一般分成三步：建立连接、进行语音视频传输、结束服务。对于已经建立连接并正在进行传输的服务，运营商应该保证其所需要的宽带。而在连接阶段，如果所有客户申请的宽带总量超过运营商所提供的宽带时，则进行宽带分配。用户的优先级通常他可使用的最大宽带与已占有的宽带之比，需求量越大，被满足的宽带越小，则优先级越高。  
假设已知每一项业务所申请的宽带大小，在保证分配的宽带之和不超过网络总宽带的条件下，如何选择业务，以使得业务优先级收益（即所有业务的优先级之和）达到最大？  
可以用集合与函数对这个问题进行建模。设用户集合是$\{1,2,\cdots,n\}$，用户$𝑖$提出了$t_{i}$个宽带申请，其第$𝑗$个申请的宽带是$r(i,j)$，这里$i=1,\!2,\cdots,n,\:\:\:\mathrm{j}=1,\!2,\cdots,t_{i}.$。假设此刻运营商能提供的动态宽带总量是$B$用户$i$已使用的宽带为$C_{i j}$，可使用的最大宽带为，那么$C_{i j}\leq M_{i j}$。用户$i$的优先级函数记作$P(i,j)$，其中：$P(i,j)=C_{i j}/M_{i j}$。  
用函数$X(i,j)$表示对用户$i$的第𝑗个申请的分配结果$X(i,j)=1$表示分配$X(i,j)=0$表示不分配，那么问题的优化目标是使得下述函数，即优先级利益：  
$$
\sum_{i=1}^{n}\sum_{j=1}^{t_{i}}X(i,j)\cdot P(i,j)\quad\text{(7-9)}
$$  
达到最大，同时满足不超过总宽带的约束条件，即：  
$$
\sum_{i=1}^{n}\sum_{j=1}^{t_{i}}X(i,j)\cdot r(i,j)\leq B\quad\text{(7-10)}
$$  
这是个典型的组合优化问题，$n$个用户总计有$t_{1}+t_{2}+\cdots+t_{n}=m$个宽带请求，分别标号为${1,2,\cdots,m}$。在考虑前$n$项宽带请求$k=(1,\!2,\cdots,m)$，总宽带限制为$l(l=1,\!2,\cdots,B)$的情况下，设最佳分配的优先级收益为$v(k,l)$。  
如果此时把宽带分配给第$k$项业务（可能是第$𝑖$个用户的第$𝑗$个申请），该业务所需宽带是$r(k)$（在$r(k)=r(i,j)\leq l$的情况下），优先级收益是$P(k)=P(i,j)$。那么，剩下的宽带是$l-$$r(k)$。这些宽带将在${1,2,\cdots,k-1}$项业务中分配，所得到的优先级收益将是$v(k-1,l-r(k))$，因此总的优先级收益是$v(k-1,l-r(k)+P(k))\mathrm{v}$。相反，如果不把宽带分配给第$k$项业务，那么全部宽带𝑙将在${1,2,\cdots,k-1}$项业务中分配，总收益为$v(k-1,l)$为了使得优先级的总收益最大，只要在上述两个收益中选择最大的即可。  
上述分析可以总结成下面的递推公式，即$\forall k(0\leq k\leq m),\forall l(0\leq l\leq B)$，有  
$v(k,l)$  
![](images/ca1bba9e9c93f3e9595cc988da9323614b05bd9b58074b31eaf8aa4a7e6c05f3.jpg)  
根据这个公式：  
第一步先计算$k=1,\mathsf{l}=1,2,\cdots,B$的$v(1,l)$值，并把它们存到一个表中；  
第二步计算$k=2,\mathsf{l}=1,2,\cdots,B$的$v(2,l)$值，再把得到的值存到这个表中。  
每步计算若用到的较小的$v(k,l)$值，就到表中去取。照此做下去，直到计算出$k=m,l=$${1,2,\cdots,B}$的$v(m,l)$值为止，其中的$v(m,B)$就是最佳分配的优化函数值，即最大优先级收益。  
上述计算完成后，再根据$v(m,B)$的值逐步向前追溯，就可以找到最佳分配方案。先看$v(m,B)$是等于$v(m-1,B)$，还是等于$v\bigl(m-1,B-r(m)\bigr)+P(m)\,?$若等于前者，则没有选择第$m$项业务；若等于后者，则选择了第$m$项业务。然后根据剩下的部分是$v(m-1,B)$还是$v\big(m-1,B-r(m)\big)$来追溯第$m-1$项业务是否被选到。照此下去，直到$m$项业务都考察到，就得到问题的解。如果在计算每一项$v(k,l)$的时刻就把是否选择第$k$项业务记录下来，则就可以省略追溯过程，只需查一下全部记录，就能得到了问题的解。"
对偶原理,原理,"['§ 12.5 格的概念与性质', '3.2.3 公式的内否与对偶', '§ 3.2 命题公式与等值演算', '12.5.2 格的基本性质', '第十二章 典型抽象代数结构', '第三章  命题演算与推理']","{'实体类型': '原理', '描述': '在格⟨L,≤⟩和格⟨L,≥⟩中，*和⊕分别代表格的下确界和上确界运算，如果在关于⟨L,≤⟩的命题中，分别用*、⊕、≤代替关于⟨L,≥⟩命题中的⊕、*、≥，那么两个命题的真伪必定保持一致性', '定义': '如果两个命题公式等值，则它们的对偶式也等值', 'name': '对偶原理'}",,3,"对偶性是格结构最基本的特征。考察格的基本性质一般从格结构的对偶特征入手。从偏序关系的角度看，格$\langle L,\leq\rangle$结构在集合 $L$上定义的偏序关系$\leq$显然是可逆的。具体地说，对于集合$ L$上的偏序关系≤，其逆关系$\geq$也是集合$ L$上的偏序关系。由于将偏序集$\langle L,\leq\rangle$的哈斯图做一个上下翻转就得到偏序集$\langle L,\geq\rangle$的哈斯图，故对集合$L$的任意子集$𝐴$，$A$在偏序$\langle L,\leq\rangle$中的上确界是$𝐴$在偏序$\langle L,\geq\rangle$中的下确界，$A$在$\langle L,\leq\rangle$中的下确界是$𝐴$在$\langle L,\geq\rangle$的上确界。因为二元关系的逆关系保持原关系的自反性、反对称性和传递性不变，所以$\langle L,\geq\rangle$也是格。  
通常将格$\langle L,\leq\rangle$和格$\langle L,\geq\rangle$称为互为对偶的格。对偶格之间具有紧密联系，例如格$\langle L,\leq\rangle$的保交运算对应格$\langle L,\geq\rangle$的保联运算，反之亦然。假如在格$\langle L,\leq\rangle$和格$\langle L,\geq\rangle$中，$*$和$\oplus$分别代表格的下确界和上确界运算，如果在关于$\langle L,\leq\rangle$的命题中，分别用$*$、⊕、$≤$代替关于$\langle L,\geq\rangle$命题中的⊕、$∗$、$≥$，那么两个命题的真伪必定保持一致性。这就是对偶原理。  
【定理12.33】设$\langle L,\leq\rangle$是任意给定的一个格，关系“$≤$”是“$\geq\!\!$的逆关系，则对$\forall$ $a,b,c,d\in$$L$，有如下14 条基本性质：  
（1）自反性：  $a\leq a;\ \ a\geq a.$  
（2）反对称性：$a\leq b$且$b\leq a\Rightarrow a=b$；$a\geq b$且$b\geq a\Rightarrow a=b$.  
（3）传递性  $a\leq b$且$b\leq c\Rightarrow a\leq c$；$a\geq b$且$b\geq c\Rightarrow a\geq c$.  $(4)a*b\leq a;\;\;a\oplus b\geq a;\;\;a*b\leq b;\;\;a\oplus b\geq b.$  
（5）$c\leq a$且$c\leq b\Rightarrow c\leq a*b$；$c\geq a$且$c\geq b\Rightarrow c\geq a\oplus b$.  
（6）交换律：  $a*b=b*a;\ a\oplus b=b\oplus a$  
（7）结合律：  $a*(b*c)=(a*b)*c;\;\;a\oplus(b\oplus c)=(a\oplus b)\oplus c$  
（8）吸收律：  $a*(a\oplus b)=a;\ a\oplus(a*b)=a.$  
（9）幂等律：  $a*a=a;\;\;a\oplus a=a.$  
(10)  $a\leq b\Longleftrightarrow a*b=a\Longleftrightarrow a\oplus b=b\,.$  
（11）$a\leq b$且$c\leq d\Rightarrow a*c\leq b*d$；$a\leq b$且${\mathfrak{c}}\leq d\Rightarrow a\oplus c\leq b\oplus d$.  
（12）偏序对运算的保序性：  $a\leq b\Rightarrow a*c\leq b*c;\;\;a\leq b\Rightarrow a\oplus c\leq b\oplus c$  
（13）确界运算对偏序的分配不等式：
$$
a\oplus(b*c)\leq(a\oplus b)*(a\oplus c);\,\,\,a*(b\oplus c)\geq(a*b)\oplus(a*(c)
$$  
（14） 确界运算对偏序的模不等式：$a\leq c\Longleftrightarrow a\oplus(b*c)\leq(a\oplus b)*c$  
格是一个特殊的代数系统，那么是否存在子格和格同态呢，答案是肯定的。设集合$𝑆$是集合$ L$的子集，从格的定义角度出发，格要求运算必须满足交换律、结合律和吸收律，如果这些运算律在集合$L$上满足，那么在$𝑆$上也一定满足，因此只要集合$𝐴$是非空的，且运算在$𝑆$上满足封闭性，那么$𝑆$就为$L$的子格。一般地，有如下的定义：  
【定义12.28】设代数系统$\langle L,*,\oplus\rangle$是一个格，对于$L$的任意一个非空子集$𝑆$，若运算$*$和$\oplus$在$𝑆$上的满足封闭性，则称$\langle S,*,\oplus\rangle$是$\langle L,*,\oplus\rangle$的一个子格，简称$𝑆$是$L$的子格。  
上面给出了代数格的子格定义，那么对于偏序格的子格又改如何定义呢。事实上若非空集合$\textstyle S\subseteq L$，且$\langle L,\leq\rangle$是偏序格，由第六章的偏序关系知道$\langle S,\leq\rangle$一定是偏序集，甚至也可能是格，但不一定是子格，因为子格要对运算封闭。由此得到如下偏序子格的定义：  
【定义12.29】设$\langle L,\leq\rangle$是一个格，$S\subseteq L$，若𝑆满足：  
（1）$S\neq\emptyset$；（2）对$\forall\;\;a,b\in S,\;\;<L,\leq\;>$的保交和保联运算都有： $a*b=G L B\{a,b\}\in S;\;\;a\oplus b=L U B\{a,b\}\in S$  
则称$\langle S,\leq\rangle$是$\langle L,\leq\rangle$的一个子格，简称$𝑆$是$L$的子格。  
利用代数系统中的同态和同构概念，分别可以得到格的同态和同构的定义：  
【定义12.30】设$\langle L,\land,\lor\rangle$和$\langle S,*,\oplus\rangle$是两个格， $f$是从$L$到$𝑆$的映射，若对$\forall\;\;x,y\in L$，有：  
$$
f(x\wedge y)=f(x)*f(y);\ f(x\vee y)=f(x)\oplus(y)
$$  
则称 $f$ 为从格 $\langle L,\land,\lor\rangle$ 到格 $\langle S,*,\oplus\rangle$ 的格同态映射，简称格同态。如果 $f$ 分别是单射、满射和双 射，$f$分别称为单格同态、满格同态和格同构，将格$ L$到$L$的同态称为$ L $的自同态。"
对偶图,概念,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.3.3 着色问题与算法', '二、平面图的着色问题']","{'实体类型': '概念', '定义': '与原图有特定对应关系的图，原图的每个面对应对偶图的一个顶点'}",,4,"如前所述，图的着色问题起源于对地图中每个国家领土的着色问题。例如，对于如图$10-$62 所示的地图，显然可以用4 种颜色对该地图中每个国家的领土进行标定。不难看出，该地图其实是一种连通无桥平面图，每个国家的领土范围对应于该平面图的一个面。因此，对地图中每个国家领土的着色问题，可转化为对这种特殊平面图中面的着色问题。  
![10-62 平面图的着色问题  ](images/0f1d899dc5071bbbd74c74607374e17794ff18cb387057f7c4c58b59ecbd991c.jpg)  
下面考察基于这种特殊平面图的面着色问题，首先给出面着色的相关定义：  
【定义10.13】连通无桥平面图及其所有有限面称为地图。地图中每有限面分别称为一个国家，若两个国家至少有一条公共边，则称这两个国家相邻。如果对给定地图$G$上每个国家涂上或标注一种颜色，使得相邻的国家具有不同的颜色，则称这种操作是对图$G$的面着色。若可用$k$种颜色就可完成对地图$G$的面着色，则称$G$是$k{-}$面可着色的。若$G$是$k{-}$面可着色的，但不是$(k-1){-}$面可着色的，则称$G$是${k}$-色地图，称$ k$为$G$的面色数，记为$\chi^{*}(G)$。  
事实上，对地图的面着色可以通过平面图的结点着色来研究。这是因为平面图$G$的对偶图$G^{*}$也是一个平面图，并且图$G$的每个面与图$G^{*}$的每个结点之间具有一一对应的关系。例如，对10-62（a）所示的面着色问题，可以转化为10-62（b）所示的结点着色问题。下面的定理10.22 揭示了作为地图的一种特殊平面图与其对偶图之间的色数关系：  
【定理10.22】地图$G$是$k^{-}$面可着色图，当且仅当它的对偶图$G^{*}$是$k^{-}$可着色图。  
【定理10.23】设$G=\langle V,E\rangle$是简单平面图，则$G$中至少存在一个度数不超过5 的结点。  
下面给出关于平面图结点着色的五色定理：  
【定理10.24】（五色定理）设$G=\langle V,E\rangle$是任意给定的一个连通简单平面图，则$G$的点色数为5。  
上述五色定理是数学家赫伍德在研究四色猜想时给出的一个重要结论，可以说是四色猜想研究历史上的一个重大突破。四色猜想是一个与哥德巴赫猜想、黎曼猜想同样著名的数学猜想。该猜想最初由英国青年佛朗西斯·格里斯在1852 年提出：  
四色猜想：连通简单平面图的色数不超过4。  
公元1852 年，毕业于英国伦敦大学并从事地图着色工作的佛朗西斯·格里斯，发现了一个奇怪的现象：无论多么复杂的地图，只要用四种颜色，就可以区分有公共边界的国家和地区。佛朗西斯觉得这中间一定有什么奥妙，便求教著名的英国数学家摩根。摩根对此苦苦思索了几个昼夜后还是不得其解，便写信给著名数学家哈密顿，希望哈密尔顿要么能证明这个问题，要么构造出一个需要五种或更多种颜色的图来。然而，智慧超人的哈密尔顿耗费了整整13 年心血，终于一筹莫展，抱恨逝去！  
哈密尔顿死后，又过了13 年，英国数学家凯莱在一次数学年会上把这个问题归纳为四色猜想，并于公元1879 年在英国皇家地理会刊的创刊号上，公开征求对四色猜想的解答。在征解消息发出的同年，一位半路出家的数学家肯普，发表了一个关于四色定理的证明。人们普遍以为四色猜想已经成为历史。不料过了11 年，即公元1890 年，一个名叫赫伍德的青年，指出了肯普在证明中的错误。与此同时，赫伍德匠心独运，利用肯普提供的方法，成功地证明了上述五色定理。由于存在不可3-着色的平面图$K_{4}$，故四色定理若得到证明，将是平面图色数问题的最佳结果。  
1976 年6 月，美国两位著名数学家阿佩尔和海肯通过计算机计算了1200 小时，通过数组计算的方法验证了四色猜想的正确性。据此，人们将四色猜想改名为四色定理。但是，四色定理并没有得到所以数学家的认可，因为目前还没理论上严谨的数学证明。"
对偶式,概念,"['第三章  命题演算与推理', '§ 3.2 命题公式与等值演算', '3.2.3 公式的内否与对偶']","{'实体类型': '概念', '定义': '将命题公式中的“合取”换成“析取”、“析取”换成“合取”、“真”换成“假”、“假”换成“真”得到的新公式'}",,3,"前面学习了 “否定”、 “合取”、 “析取”、 “蕴涵”和“等价”这五个常用命题联结词，其中最常用的是“否定”、 “合取”、 “析取”这三个联结词。事实上，后面将会证明仅使用这三个最常用联结词就可以任意的命题公式。本小节主要考察仅由这三个联结词构成的命题公式，首先给出如下限制性命题公式的定义：  
【定义3.14】如果一个命题公式$G$中仅出现命题变量、命题常量，以及命题联结词“$\neg$”、“ $\wedge$“、”$\lor$“，则称$G$为限制性命题公式。  
例如公式$\neg Q\lor R\,\lor\,\neg(P\lor Q)\lor(Q\lor P)\,\lor\,G\lor(H\land S)$都是限制性命题公式。  
限制性命题公式中只有“$\neg$”、“ $\wedge$“、”$\lor$“这三种运算，其中”$\neg$”为一元运算，“ $\wedge$“和“$\lor$”均为二元运算。对于任意一个限制性命题公式，可以使用规律性修改其运算联结词的方式构造出与之相对应的新的命题公式。例如，对于“$\neg$”运算，可将命题公式中所有变量取反，即由$P$ 换成$\neg\mathrm{P}$，便可得到一个新的公式。由此得到如下内否公式的定义：  
【定义3.15】设$G\Leftrightarrow G(P_{1},P_{2},\cdots P_{n})$是任一限制性命题公式，$P_{1},P_{2},\cdots P_{n}$是其所有命题变量，则称$G(\neg P_{1},\neg P_{2},\cdots\neg P_{n})$是$G(P_{1},P_{2},\cdots P_{n})$的内否公式，记为$G^{\neg}$。  
例如：若 $G=\ \lnot P\lor Q$，则$G^{\neg}=P\lor\neg Q$。  
不难看出，$\wedge$和$\lor$运算具有一定的对等性。也就是说 $\wedge$运算具有的性质，$\lor$运算也都有，反之亦然。因此，对于任意一个限制性命题公式，可将其中 $\wedge$换成$\lor$、$\lor$换成$\wedge$、$T$换成$F$、$F$换成$T$，则可得到一个与之相关的新公式。由此得到如下命题公式对偶式的概念：  
【定义3.16】对于任意一个限制性命题公式$G$，将其中 $\wedge$换成$\lor$、$\vee$换成 $\wedge$、$T$换成$F$、$F$换成$T$，得到的新公式称为$G$的对偶式，记为$G^{*}$。  
例如：
$$
(1)G\Leftrightarrow(P\land F);\quad G^{*}=P\lor T_{\circ}\;\;(\,2\,)\;\;G\Leftrightarrow(P\lor Q)\land R;\;\;G^{*}\Leftrightarrow(P\land Q)\lor R\,_{\circ}
$$  
下面两个定理分别给出了内否式和对偶式的基本性质于基本关系：  
【定理3.5】假设$G$和$H$都是限制性命题公式，则成立下列等值式：  
$\begin{aligned}&(1) (G^{*})^{*}\Leftrightarrow G, (G^{\neg})^{\neg}\Leftrightarrow G; (2) (G\vee H)^{*}\Leftrightarrow G^{*}\wedge H^{*}; (G\vee H)^{\neg}\Leftrightarrow G^{\neg}\vee H^{\neg};\\&(3) (G\wedge H)^{*}\Leftrightarrow G^{*}\vee H^{*}; (G\wedge H)^{\neg}\Leftrightarrow G^{\neg}\wedge H^{\neg}。\end{aligned}$  
【定理3.6】设$G$和$G^{*}$互为对偶式，$P_{1},P_{2},\cdots P_{n}$是出现在$G$和$G^{*}$中的全部命题变项，将$G$和$G^{*}$写成$\mathsf{n}$ 元函数形式，则有：
$$
(1)\neg G(P_{1},P_{2},\cdots,P_{n})\Leftrightarrow G^{*}(\neg P_{1},\neg P_{2},\cdots,\neg P_{n})\Leftrightarrow(G^{\neg})^{*}(P_{1},\cdots,P_{n})\tag{3-1}
$$  
$$
G^{\neg}(P_{1},P_{2},\cdots,P_{n})\Leftrightarrow G(\neg P_{1},\neg P_{2},\cdots,\neg P_{n})\Leftrightarrow\neg G^{*}(P_{1},P_{2},\cdots,P_{n})\tag{3-2}
$$  
上述定理的第（1）条表明命题公式$G$的否定与其命题变元否定的对偶式，即与该公式内否式的对偶式等值；第（2）条表明命题公式$G$的内否式与该公式对偶式的否定等值。  
【定理3.7】（对偶原理）假设$P_{1},P_{2},\cdots,P_{n}$是出现在命题公式$P$和$Q$中的所有原子变元，如果$P\Leftrightarrow Q$，那么$P^{*}\Leftrightarrow Q^{*}$。  
对偶原理表明命题公式之间所有等值关系都是成对的。也就是说，对于任意一个等值式，都可由对偶原理构造一个与之对偶的等值式。例如，对于等值式$P\to Q\Leftrightarrow\neg P\lor Q$，则可构造出其对偶等值式$\neg P\land Q\Leftrightarrow\neg(\neg P\rightarrow\neg Q)$。因为$\neg P\land Q\Leftrightarrow\neg(P\lor\neg Q)\Leftrightarrow\neg(\neg P\to\neg Q)$。"
对称关系,概念,"['第五章 关系模型与理论', '§ 5.3 关系的基本性质', '5.3.2 关系的对称与反对称']","{'实体类型': '概念', '定义': '设R是集合A上的关系，对任意x,y∈A，若⟨x,y⟩∈R，则有⟨y,x⟩∈R，则称关系R是对称关系，或称关系R具有对称性', '特点': '关系图中任何一对结点之间，要么存在方向相反的两条边，要么无任何边；关系矩阵为对称矩阵'}",,3,"有很多关系具有一些对称的性质，例如对于同学关系，如果张三是李四的同学，那么李四必然是张三的同学，还有很多其它关系，例如两条直线之间的平行关系、兄弟关系、实数的相等关系等等，也都具有这种对称性质。关系对称性的具体定义如下：  
【定义5.19】设$R$ 是集合$A$ 上的关系，对任意$x,y\in A$，若$\langle x,y\rangle\in R$，则有$\langle y,x\rangle\in R$，则称关系$R$ 是对称关系，或称关系$R$ 具有对称性。即有：  
$(\forall x)(\forall y)(x\in A\land y\in A\land\langle x,y\rangle\in R\rightarrow\langle y,x\rangle\in R)\Leftrightarrow R$为对称关系；$\quad\text{(5-12)}$  
还有一些集合上的关系，集合中的所有元素与其自身之外任何元素之间的关系都不具有对称性，例如正整数的整除关系，对于任意两个正整数，除非这两个整数相等，否则它们之间不可能相互整除，也就是说，对于任意两个正整数$a$和$b$，如果$a|b$且$b|a$，则必有$a=b$。关系的这种性质称为反对称性，具体定义如下：  
【定义5.20】设$R$ 是集合$A$ 上的关系，若对任意$x,y\in A$，满足$\langle x,y\rangle\in R$且$\langle y,x\rangle\in R$  
则有$a=b$，则称关系$R$ 是反对称关系，或称$R$ 具有反对称性。即有：$(\forall x)(\forall y)(x\in A\land y\in A\land\langle x,y\rangle\in R\land\langle y,x\rangle\in R\to x=y)\Leftrightarrow R$为反对称关系  （5-13）【例题5.29】设$A=\{a,b,c\}$， $R_{1}$，$R_{2}$，$R_{3}$，$R_{4}$是$A$ 上的关系，其中：
$$
R_{1}=\{\langle a,a\rangle,\langle b,b\rangle,\langle c,c\rangle\};\,\,\,R_{2}=\{\langle a,a\rangle,\langle b,c\rangle,\langle c,b\rangle\}
$$  
$$
R_{3}=\{\langle a,b\rangle,\langle a,c\rangle\};\,\,\,R_{4}=\{\langle a,b\rangle,\langle b,c\rangle,\langle c,a\rangle\}
$$
判断$R_{1}$，$R_{2}$，$R_{3}$，$R_{4}$是否具有对称性或反对称性。  
通过上述例题，不难得出如下结论：  
（1）存在既不是对称也不是反对称的关系，也存在既是对称也是反对称的关系。  
（2）关系$R$ 是对称的当且仅当关系图中任何一对结点之间，要么存在方向相反的两条边，要么无任何边；关系$R$ 是反对称的当且仅当关系图中任何一对结点之间至多有一条边。  
（3）关系$R$ 是对称的当且仅当$R$的关系矩阵为对称矩阵；关系$R$ 是反对称的当且仅当$R$ 的关系矩阵为反对称矩阵，即对称的两个元素中最多有一个等于1。"
对称性,性质,"['§ 5.4 关系的性质闭包', '第六章 特殊关系模型', '第五章 关系模型与理论', '5.3.4 关系性质的判定', '§ 5.3 关系的基本性质']","{'实体类型': '性质', '定义': '如果关系中的元素a与元素b相关联，则元素b也与元素a相关联', '判定条件': 'R 是对称的当且仅当 R 等于 R 的逆关系', '重要性': '关系的重要性质', '应用场景': '在很多关系问题的求解过程中需要用到'}",,2,现实世界中的关系错综复杂、种类繁多，这给我们使用关系的数学模型表示和解决关系问题带来一定的困难。因此，为了比较方便地研究和使用关系的数学模型，本节建立考察关系特性的若干标准并将这些标准看成是关系的基本性质。对于任意给定的一个关系，就可以使用这些标准来考察或评判该关系满足或不满足这几个标准中的哪几条，换句话说，就是考察该或评判该关系具有哪些基本性质。这样就可以依据这些标准将所有的关系划分为若干类型进行分门别类的研究。关系的这些考察标准或基本性质一共有五个，即自反性、反自反性、对称性、反对称性和传递性，本节具体介绍这些基本性质的概念及判定方法。
对称群,概念,"['第十二章 典型抽象代数结构', '§ 12.2 群结构的基本知识', '12.2.3 循环群与置换群']","{'实体类型': '概念', '定义': '有限集合上的变换群', '特点': '一定是有限群', '关系': '是变换群的子群，置换群的特殊情况'}",,3,"本节主要介绍两种重要的特殊群结构，即循环群和置换群。循环群是以某个元素的全部方幂载体集合的群，是目前研究最彻底的一种群。基于普通加法的整数加群$\langle Z,+\rangle$和基于模加运算的剩余类加群$\langle\underline{{n}},+_{n}\rangle$都是循环群。事实上，从同构角度看，循环群也只有$\langle Z,+\rangle$。和$\langle\underline{{n}},+_{n}\rangle$这两种不同的群。置换群则是有限集上置换函数集合与函数复合运算构成的群，是以置换函数及其运算为研究对象的群。置换群的重要性主要在于任何一个有限群都与一个置换群同构，换句话说，从同构的角度看，所有的有限群都是置换群。此外，循环群和置换群的实用性都非常强，是很多理论问题证明和求解的重要工具，在信息压缩与编码、形式语言自动机、几何变换与图形算法设计等多个领域具有重要的实用价值。  
一、循环群  
前面我们已经学过循环半群和循环含幺半群，现将其直接推广到群结构，由此得到循环群的概念，具体如下：  
【定义12.13】设$\langle G,*\rangle$是任意给定的群，若存在$a\in G$ 使得  
$$
G=\{a^{k}\big|k\in Z\}=\langle a\rangle
$$  
则称 $\langle G,*\rangle$ 为循环群，记作 $\langle\langle a\rangle_{*}\rangle$ ，并称 $a$ 是 $G$ 的生成元。此时，若 $|a|=n$ ，则称 $\langle\langle a\rangle{,*}\rangle$ 为 ${n}$ 阶 循环群，若$|a|$为无穷大，则称$\langle\langle a\rangle{,*}\rangle$为无限阶循环群。  
【定理12.15】假设$\langle G,*\rangle$是任意给定的一个循环群，则该群一定是交换群。  
【定理12.17】设$\langle G,*\rangle$是以$a$为生成元的循环群，即$G=\langle a\rangle$，则  
（1）若$G$是无限群，则$G$与整数加法群$\langle Z,+\rangle$同构；  
（2）若$G$是无限群是有限群且$|G|=n$，则$G$与$n$阶剩余类加群$\langle n,+_{n}\rangle$同构。  
二、 置换群  
在前面我们已经学习置换函数及其乘法的有关知识，现在从群的角度来考察置换函数及其乘法的运算性质。我们知道，置换函数其实就是有限集合上的的双射函数。为了能够更为一般的概念和性质，现从更为一般的角度考察双射函数，即一般集合上的双射函数及其乘法运算，由此得到如下变换及变换乘法的概念：  
【定义12.14】设$𝐴$是任意给定的一个非空集合，$A$集合上的映射$ f$：$A\rightarrow A$称为$𝐴$的一个变换。若该映射$f$是双射，则称$f$为$𝐴$上的一个一一变换。  
例如$f$：$Z\rightarrow Z$，$f(x)=x$和$g$：$Z\rightarrow Z$，$f(x)=-x$都是𝑍上的一一变换。  
【定义12.15】设$f,g$是𝐴上的变换，$f$和$g$的复合称为$f$与$g$的乘积，记作$f\circ g$  。  
不难证明，$f\circ g$也是$𝐴$上的一个变换。如果$f$和$g$都是$𝐴$上的一一变换，则乘积$f\circ g$也是$𝐴$上的一个一一变换。  
下面的定理12.18 表明：以给定集合上全体一一变换集合为载体、以变换乘法∘为运算构成的二元代数结构是一个群，由此可以从群的角度考察一一变换及其乘法运算性质。  
【定理12.18】假设$𝐴$是任意给定的一个非空集合，$E(A)$是$𝐴$上的全体一一变换构成的集合，则$E(A)$与其上一一变换的乘法运算∘构成的二元代数结构$\langle E(A),\circ\rangle$是一个群。  
【定义12.16】假设$𝐴$是任意给定的一个非空集合，$E(A)$是𝐴上的全体一一变换构成的集合，则$E(A)$与其上一一变换的乘法运算∘构成的群$\langle E(A),\circ\rangle$称为变换群，当$𝐴$是有限集合时，称变换群$\langle E(A),\circ\rangle$为对称群，对称群的任何一个子群称为置换群。  
从上述定义可以看出，变换群的载体集合$ E(A)$可以是有限集合也可以是无限集合，或者说变换群可以是有限群也可以是无限群。对称群则是一种特殊的变换群，要求变换群的载体集合必须是有限集合，因此，对称群一定是有限群。置换群则是变换群的子群，当然对称群作为其自身的平凡子群是一种特殊的置换群，但置换群不一定是对称群。因此，置换群比对称群具有更加广泛的含义，一般主要考察置换群。  
我们知道，对于任意给定的一个有限集合$𝐴$，该集合上的一一变换称为$𝐴$上的置换。当$|A|=n$时称$𝐴$上的置换为${n}$元置换。为了叙述上的方便，常将$A$记作$\{1,2,\cdots,n\}$，这样就可以将$𝐴$上的$n$元置换$p$记作：  
$$
\pi={\binom{a_{1},\ldots a_{n}}{b_{1},\ldots b_{n}}}\,,b_{i}=\sigma(a_{i}),\qquad\qquad\qquad i=1,2,\cdots,n
$$  
易见$.\pi(1)\,\,\,\pi(2)\,\,\,\,\,\cdots\pi(n)$恰恰为${1,\,,2,\cdots,n}$的一个排列。在$𝐴$上的所有置换和$𝐴$的所有排列之间存在着一一对应，$n$元集有$n!$个排列，故有${n}$!个$n$ 元置换。所有这些置换的集合记作$S_{n}$，则$\langle S_{n},\circ\rangle$就是一个对称群。  
具体地说，设$A=\{1,\!2\}$，那么$𝐴$上有两个置换：  
$$
p_1=\binom{1\quad2}{1\quad2},\quad p_2=\binom{1\quad2}{2\quad1}
$$  
当$A=\{1,\!2,\!3\}$时，$A$上有6 个置换：  
$$
\pi_1=\begin{pmatrix}1&2&3\\1&2&3\end{pmatrix},\pi_2=\begin{pmatrix}1&2&3\\2&1&3\end{pmatrix},\pi_3=\begin{pmatrix}1&2&3\\3&2&1\end{pmatrix}
$$  
$$
\pi_1=\begin{pmatrix}1&2&3\\1&3&2\end{pmatrix},\pi_2=\begin{pmatrix}1&2&3\\2&3&1\end{pmatrix},\pi_3=\begin{pmatrix}1&2&3\\3&1&2\end{pmatrix}
$$  
一般地，$A=\{a_{1},a_{2},\dots a_{n}\}$时，$A$上有$n!$个置换。如有$\pi(a_{i})=a_{j_{i}}$时，则$\pi$可表示为：  
$$
\pi={\binom{a_{1},\,\dots\,a_{n}}{a_{j_{1}},\,\dots\,a_{j_{n}}}}
$$  
置换乘法运算或者复合运算通常用∘表示，置换乘法可以像计算两个关系的合成那样进行。需要特别注意的是，置换乘法或复合运算与通常函数的复合运算次序相反。例如：  
$$
\pi_6\circ\pi_4=\begin{pmatrix}1&2&3\\3&1&2\end{pmatrix}\cdot\begin{pmatrix}1&2&3\\1&3&2\end{pmatrix}=\begin{pmatrix}1&2&3\\2&1&3\end{pmatrix}
$$  
即有：$(\pi_{6}\circ\pi_{4})(x)=\pi_{4}(\pi_{6}(x))$  。  
下面考察置换群的几何意义，首先考察三元对称群：  
设$A=\{1,\!2,\!3\}$，则$A$上的6 个置换$S_{3}=\{\pi_{1},\pi_{2},\pi_{3},\pi_{4},\pi_{5},\pi_{6}\}$关于其乘法运算∘构成一个群$\langle S_{3},\circ\rangle$，并称之为三次对称群。其中$\pi_{1}$是恒等置换为群中的单位元，且有：  
$$
{p_{2}}^{-1}=p_{2};~~{p_{3}}^{-1}=p_{3};~~{p_{4}}^{-1}=p_{5};~~{p_{5}}^{-1}=p_{4};~~{p_{6}}^{-1}=p_{6}
$$  
其实，还可以从另一个角度也可得到这个群：用数字1,2,3 标记正三角形的三个顶点，如图12-3 所示。现将三角形以其中心O 为中心轴分别旋转$\sigma_{0},\sigma_{1},\sigma_{2}$（旋转$\cdot0^{\circ},120^{\circ},240^{\circ})$），或分别按直线$l_{1}l_{2}l_{3}$位对称轴进行翻转$(\sigma_{3},\sigma_{4},\sigma_{5})$，则每次旋转或翻转显然都都对应于三角形顶点数字的的一个置换，具体对应关系如下：  
$\sigma_{0}$（旋转$0^{\circ}$）        $p_1=\begin{pmatrix}1&2&3\\1&2&3\end{pmatrix};\quad\sigma_1\bigl(\text{旋转}120^\circ\bigr)\quad p_2=\bigl(\begin{matrix}1&2&3\\2&1&3\end{matrix}\bigr)$  
$\sigma_2\bigl(\text{旋转 240°}\bigr)\quad p_3=\bigl(\begin{matrix}1&2&3\\3&2&1\end{matrix}\bigr);\quad\sigma_3\bigl(\text{绕}l_3\text{翻转}\bigr)$$\quad\quad\quad p_4=\begin{pmatrix}1&2&3\\1&3&2\end{pmatrix}$  
$\sigma_4\big(\text{绕}l_2\text{翻转}\big)\quad p_5=\big(\begin{matrix}1&2&3\\2&3&1\end{matrix}\big);\quad\sigma_5\big(\text{绕}l_1\text{翻转}\big)\quad p_6=(\begin{matrix}1&2&3\\3&1&2\end{matrix})$  
不难看出：$\langle\{\sigma_{0},\sigma_{1},\sigma_{2},\sigma_{3},\sigma_{4},\sigma_{5}\},\circledast\rangle$构成一个群，其中$\circledast$表示旋转或翻转的操作的复合操作，并且与群$\langle\{\pi_{1},\pi_{2},\pi_{3},\pi_{4},\pi_{5},\pi_{6}\},\circ\rangle$同构。  
![](images/e6cbfb18c66c7d99640531f391a63f4a34c10b210258fb0a56bb479a832c31f2.jpg)  
图12-3 三角形的对称轴和对称中心  
![](images/c11de4754b3535d3b87f562740b93b202d5ef5e49fd3a0cb5d9d33538b6831cb.jpg)  
图12-4正方形的对称轴和对称中心  
下面进一步考察四元对称群的几何意义：令$A=\{1,\!2,\!3,\!4\}$，$S_{4}=\{p|p$为A 上的置换}，因此，$\langle S_{4},\circ\rangle$为四元对称群。现用数字1,2,3,4 分别标记正方形的4 个顶点，如图12-4 所示，$\sigma_{0},\sigma_{1},\sigma_{2},\sigma_{3},\sigma_{4},\sigma_{5},\sigma_{6},\sigma_{7}$分别表示正方形以其中心为中心轴进行旋转或按对称轴进行翻转，则它们分别对应与A 上的一个置换，具体如下：  
$ \sigma_0\big(\text{旋转 }0^\circ\big)\quad p_1=\begin{pmatrix}1&2&3&4\\1&2&3&4\end{pmatrix};\quad\sigma_1\big(\text{旋转 }90^\circ\big)\quad p_2=\begin{pmatrix}1&2&3&4\\2&3&4&1\end{pmatrix}$  
$\sigma_2\big(\text{旋转 180°}\big)\quad p_3=\begin{pmatrix}1&2&3&4\\3&4&1&2\end{pmatrix};\quad\sigma_3\big(\text{旋转 270°}\big)\quad p_4=(\begin{matrix}1&2&3&4\\4&1&2&3\end{matrix})$  
$\sigma_4(\text{绕}l_1\text{翻转})\quad p_5=\begin{pmatrix}1&2&3&4\\4&3&2&1\end{pmatrix};\quad\sigma_5(\text{绕}l_2\text{翻转})\quad p_6=(\begin{matrix}1&2&3&4\\1&4&3&2\end{matrix})$  
$\sigma_6(\text{绕}l_3\text{翻转})\quad p_7=\begin{pmatrix}1&2&3&4\\1&4&3&2\end{pmatrix};\quad\sigma_7(\text{绕}l_4\text{翻转})\quad p_8=(\begin{matrix}1&2&3&4\\1&4&3&2\end{matrix})$  
不难看出：$\langle\{\sigma_{0},\sigma_{1},\sigma_{2},\sigma_{3},\sigma_{4},\sigma_{5},\sigma_{6},\sigma_{7}\},\circledast\rangle$构成一个群，其中$\circledast$表示旋转或翻转的操作的复合操作，具体定义如表12-1 所示。  
表12-1 $\circledast$的运算表
![](images/0d658bbe39ea00a7b3a2683e4707c30ed3115f5772998f1ac1c9608422308ecc.jpg)  
由于$\langle\{\sigma_{0},\sigma_{1},\cdots,\sigma_{7}\},\circledast\rangle$与$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$同构，故$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$也是群，它是$\langle S_{4},\circ\rangle$的一个真子群，因为四元对称群$\langle S_{4},\circ\rangle$有24 个置换，而$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$仅有8 个置换。也就是说，群$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$是一个8 阶4 元置换群，但不是4 元对称群。  
【定理12.19】假设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$与某个变换群同构，如果$\langle G,*\rangle$是一个有限群，则$\langle G,*\rangle$与某个置换群同构。  
上述定理12.19 表明，变换群和对称群的重要性在于其作为两种具体的特殊群与一般的抽象群有着非常密切的联系。具体地说，每个群均同构于一个变换群，特别地，每个有限群均同构于一个置换群。因此，从同构的角度看，所有的群都可以看成是变换群，所有的有限群都可以看成是置换群。"
对称闭包,概念,"['第五章 关系模型与理论', '§ 5.4 关系的性质闭包', '5.4.1  关系闭包的概念']","{'实体类型': '概念', '定义': ""若存在关系R'，满足R'是对称的，且对任何对称关系R''，若R⊆R''，则R'⊆R''，则称R'为R的对称闭包"", '构造方法': 's(R)=R∪R^-1'}",,3,"首先，我们考察关系的自反闭包。假设$R$ 是集合$A$ 上的二元关系，如果$R$ 不满足自反性，就说明集合$A$ 中存在某个元素$a.$,使得$\langle a,a\rangle\not\in R$，此时可以将关系R 进行调整或修改，避免这种情况的发生。具体地说，就是将序偶$\langle a,a\rangle$纳入到关系$R$ 由此产生一个新的关系$R^{\prime}$。一般地，如果对于$A$ 中的每个元素${x}$，都将$\langle x,x\rangle$纳入到关系$R$，由此产生新的关系$R^{\prime}$必然满足自反性。事实上，关系$R^{\prime}$是对关系$R$ 的一种扩充，使得扩充后的关系能够满足自反性。若能证明这种扩充是满足扩充目的最小扩充，则$R^{\prime}$就是关系$R$ 的自反闭包。  
可同理考察对称闭包。假设$R$ 是集合$A$ 上的二元关系，如果$R$ 不满足对称性，就说明集合$A$ 中存在两个元素$a$和$b$使得$\langle a,b\rangle\in R$，但$\langle b,a\rangle\not\in R$。此时，只需将$\langle b,a\rangle$纳入$R$ 中就可避免这种情况发生。因此，可以对$R$ 进行适当扩充构成其对称闭包。  
可类似考虑传递闭包的基本思想，不再赘述。下面给出这三个闭包的具体定义：  
【定义5.22】设$R$ 是集合$A$ 上的关系，若存在$A$ 上的另一个关系$R^{\prime}$，满足：  
（1）$R^{\prime}$是自反的（对称的、或传递的）  
（2）对$A$ 上任何自反（对称的、或传递）关系$R^{\prime\prime}$，如果$R\subseteq R^{\prime\prime}$，那么$R^{\prime}\subseteq R^{\prime\prime}$，则称${R^{\prime}}$为$R$的自反闭包（对称闭包或传递闭包），记为$r(R)(s(R)$或$t(R))$。  
下面定理给出了自反闭包和传递闭包的构造方法：  
【定理5.12】设$R$ 是非空集合$A$ 上的关系，则有：  
$r(R)=R\cup R^{0};\,\,\,s(R)=R\cup R^{-1}$  
由上述例题可得利用关系图求关系$R$ 闭包的方法：  
（1）检查$R$ 的关系图，在没有自环的结点处加上自环，可得$r(R)$的关系图；  
（2）检查$R$ 的关系图，将每条单向边全部改成双向边，可得$s(R)$的关系图；  
（3）检查$R$ 的关系图，从每个结点出发，找到其终点，如果该结点到其终点没有边相连，就加上此边，由此可得$t(R)$的关系图。"
导出子图,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.2.1 图的基本运算', '三、子图与补图运算']","{'实体类型': '概念', '定义': '设$V_{1}$是𝑉的非空子集，以 $V_{1}$ 为结点集，以两个端点均在 $V_{1}$ 中的全体边为边集的 $G$ 的子图称为由$V_{1}$导出的导出子图', '记法': '记为 $G[V_{1}]$'}",,4,"在使用图模型对实际问题建模和求解的过程中，经常需要分析考察图的某个特定部分的结构，将图中某个或某些特定的部分提取出来作为一个图模型进行研究，由此得到如下关于图模型的子图运算的若干概念，具体如下：  
【定义8.13】设 $G=\langle V,E\rangle$，$G^{\prime}=\langle V^{\prime},E^{\prime}\rangle$是两个图（同为无向图或者有向图），则有：  
（1）若 $V^{\prime}\subseteq V$且 $E^{\prime}\subseteq E$，则称 $G^{\prime}$是 $G$ 的子图，$G$ 是 $G^{\prime}$的母图，记为 $G^{\prime}\subseteq\mathbf{G}$ 。若 $G^{\prime}\subseteq\mathbf{G}$且 $G^{\prime}\neq{\bf G}$（即$V^{\prime}\subset V$或 $E^{\prime}\subset\mathbf{E})$），则称 $G^{\prime}$ 是 $G$ 的真子图；若 $G^{\prime}\subseteq G$且 $V^{\prime}=V$，则称 $G^{\prime}$是 $G$ 的生成子图。  
（2）设$V_{1}$是𝑉的非空子集，即 $\varnothing\neq V_{1}\subseteq V$，则以 $V_{1}$ 为结点集，以两个端点均在 $V_{1}$ 中的全体边为边集的 $G$ 的子图称为由$V_{1}$导出的导出子图，记为 $G[V_{1}]$。  
（3）设$E_{1}$是$E$的非空子集，设$\varnothing\neq E_{1}\subseteq E$，以 $E_{1}$为边集，以 $E_{1}$ 中所有边关联的全部结点为结点集的 $G$ 的子图成为由 $E_{1}$导出的导出子图，记为 $G[\ E_{1}]$。  
由上述定义可以看出，生成子图与其母图具有相同的结点集合。因此，一个图的生成子图一般是该图的主体结构。对于一个复杂的图模型，一般通过采用适当的方法构造其符合要求的生成子图实现对模型的化简和对问题的求解。  
不难看出，对于任一给定非空有限结点集合，由这些结点构成的零图和完全图分别表达了两个极端构图情形，两者之间具有互补性，相当于集合论中的空集和全集。 由此可以得到图模型补运算的概念。 首先给出如下关于完全图的定义：  
【定义8.14】假设$G=\langle V,E\rangle$是一个具有$\cdot_{n}$个结点的无向简单图，如果图中任意两个结点之间都有边相联结，则称该图为$^n$阶无向完全图，简称为完全图，记为$K_{n}$；假设$G=\langle V,E\rangle$是一个具有$\cdot_{n}$个结点的有向简单图，如果图中任意两个结点之间都有方向相反的两条边相联结，则称该图为$n$阶有向完全图，在不发生混淆的情况下也记为$K_{n}$。  
由上述定义可知，对于完全图来说，其邻接矩阵除主对角线上元素均为0 之外，其余元素均为1。显然，$n$阶无向完全图的边数为$n(n-1)/2$ ，$n$阶有向完全图的边数为$\ n(n-1)$。 图8-17 给出了无向完全图$K_{3}$，$K_{4}$，$K_{5}$和有向图$K_{3}$。  
下面给出图模型补运算的定义：  
【定义8.15】设 $G=\langle V,E\rangle$ 是 $n$ 阶简单图，以 $V$ 为顶点集，以所有能使 $G$ 成为完全图 $K_{n}$ 的新加边为边集的图称为 $G$ 相对于 $K_{n}$ 的补图，简称为 $G$ 的补图，记为$\bar{G}$。  
显然，若图$G$的邻接矩阵为$A_{G}=(a_{i j})_{n\times n}$，则其补图$\bar{G}$的邻接矩阵为$A_{\bar{G}}=(\bar{a}_{i j})_{n\times n}$为：  
$$
\\\bar{a}_{i j}=f(x)=\left\{\begin{array}{r l r}&{~~~~~~~~1-a_{i j},~i\neq j}&\\ &{0,~~~~~~~~~~~~~~~~~~i=j}&\end{array}\right.
$$  
例如，对于图8-18 所示的图 $G_{1}$和图 $G_{2}$，图 $G_{1}$ 是图 $G_{2}$ 的补图，图 $G_{2}$ 也是图 $G_{1}$的补图。显然， $K_{n}$ 的补图是 $n$ 阶零图，反之亦然。  
![图8-18 补图运算 ](images/bc253e401f30298f9209681ddc8b93ec627ca9bfb8d5b9c17929af79e1390112.jpg)"
封闭公式,定义,"['第四章  谓词演算与推理', '§ 4.2  谓词公式与等值演算', '4.2.2 变量的自由与约束']","{'实体类型': '定义', '内容': '不含自由变量的谓词公式'}",,3,"如前所述，量词实现了对谓词中个体变量含义的约束，消除了谓词在语义上的抽象性和不确定性，对于一个$\cdot n$元谓词，如果其中每个变量都分别受到量词的约束，那么它就不再是一个命题函数而蜕化一个具体命题。因此，对于任意一个$\cdot n$元谓词，可将其中所以命题变量分为两种具体不同性质的基本类型：一种是受到量词约束的命题变量，其含义是明确具体的，不再具有自由诠释的性质；另外一种是没有受到量词约束的命题变量，是传统意义上的命题变量，其含义是泛指某个不确定的个体对象，具有自由诠释的性质。这两种变量在谓词公式及谓词演算中扮演着完全不同的角色，在具体的表示形式上必须有明确的区分。本节主要介绍具体的区分方法，首先给出量词辖域的相关概念。  
【定义4.12】假设$G(x)$是任意一个含有命题变量$x$的谓词，在公式$(\forall x)G(x)$或$(\exists x)G(x)$中，$(\forall x)$或$(\exists x)$的作用变量$x$ 在$G(x)$中存在的范围称为量词$(\forall x)$或$(\exists x)$的辖域。如果辖域不是原子谓词公式，其两侧必须有括号，否则不应有括号。  
例如：在谓词公式$\exists x(P(x,y)\rightarrow Q(x,y))\vee P(y,z)$中，$\exists x$的辖域是$(P(x,y)\to Q(x,y))$  
在谓词公式$\forall x P(x)\rightarrow Q(x)$中，$\forall x$的辖域是$P(x)$。  
一般来说，一个量词的辖域是某个谓词公式的子公式。因此，确定一个量词的辖域就是要找出位于该量词之后与之相邻接的子公式，具体方法如下：  
（1）若量词后面有括弧，则括弧内的子公式就是该量词的辖域；  
（2）若量词后面无括弧，则与该量词邻接的子公式为该量词的辖域。  
下面在量词辖域的基础上给出自由变量和约束变量的定义：  
【定义4.13】假设𝐺是任一谓词公式，$x$是𝐺的任意一个命题变量，如果$x$出现在以它为作用变量的量词辖域之内，则称$x$的出现为约束出现，称变量$x$为约束变量；如果$x$不是约束出现，则称其为自由出现，此时称$x$为自由变量。  
从上述定义不难看出，所谓约束变量，就是其含义受到量词约束的命题变量。约束变量的含义是明确具体的，不再具有自由诠释的性质。自由变量则是含义没有受到量词约束的命题变量，是传统意义上的命题变量，可以对其含义进行自由诠释。  
如果谓词公式中所有命题变量都受到量词约束，则称其为封闭公式，具体定义如下：  
【定义4.14】若谓词公式$G$ 中不含自由变量，则称该公式为封闭公式或闭式。  
例如，$(\forall x)(P(x)\rightarrow(\exists y)R(x,y))$就是一个闭式。显然，要想使得含有$n$个自由变量的谓词公式变成闭式，需要添加$|n$个量词。  
从上述例题不难看出，有时候在同一个谓词公式中同一个命题变量既可以约束出现也可以自由出现，例如对于如下谓词公式：  
$(\forall x)(P(x)\rightarrow R(x))\land(\exists y)Q(x,y)$  
该式中个体变量$\cdot x$既是约束变量又是自由变量。这很容易引起在概念理解上的歧义或混乱，需要通过一些方法对这种变量进行换名，使得同一个个体变量在同一个谓词公式中要么自由出现，要么约束出现，不能兼而有之，避免个体变量在概念理解上的歧义或混乱。下面介绍具体的个体变量改名方法。  
对于任意一个含有量词的谓词公式，以约束方式出现的个体变量到底用哪一个字母表示其实是无关紧要的。事实上，用其它任意字母表示这个约束变量都不会改变谓词公式的含义。由此可得如下约束变量的换名规则：  
（1）将量词中出现的变量以及该量词辖域中此变量的所有约束出现都替换为新的变量；  
（2）新变量名一定要有别于辖域中的所有其它变量名。  
为使一个个体变量在同一个谓词公式中只以一种方式出现，还可以使用一定的规则实现对自由变量换名。该规则称为自由变量的代入规则，具体内容如下：  
（1）将公式中出现该自由变量的每一处都用新的变量替换；  
（2）新变量不允许在原公式中以任何约束形式出现。"
小项,概念,"['第三章  命题演算与推理', '§ 3.4 命题公式的范式', '3.4.2 主析取范式', '一、小项的概念与性质']","{'实体类型': '概念', '定义': '对于任一含有n个命题变元的合取式G(P1,P2,⋯,Pn)，其中每个命题变元Pi与其否定¬Pi不同时出现，但是两者之一必须出现一次且仅出现一次，而且出现次序与P1,P2,⋯,Pn的次序保持一致，则称该G(P1,P2,⋯,Pn)为一个小项', '特点': '在表达形式上具有特殊限制的合取式，要求合取式中的所含变量都要以一定方式出现一次且仅出现一次，对于每个变量，要么以其自身形态出现，要么以其否定形态出现', '应用': '实现对命题公式中合取运算的一种规范表达，而且很容易实现对这种规范表达形式的枚举', '性质': '含有n个命题变元小项有且仅有2^n个，且其中每个小项都有且仅有一个成真赋值'}",,4,"析取范式由若干合取式通过析取运算组合而成，合取式是组成析取范式的基本构件。不难看出，造成析取范式表达形式不唯一的根本原因是其基本构件的种类太多而且存在冗余。因此，必须对作为析取范式种中合取运算的表达做进一步限定，在保证析取范式基本构件完备性的前提下消除冗余的合取式，由此得到如下小项的定义：  
【定义3.23】对于任一含有$n$个命题变元的合取式$G(P_{1},P_{2},\cdots,P_{n})$，其中每个命题变元$P_{i}$与其否定$\neg P_{i}$不同时出现，但是两者之一必须出现一次且仅出现一次，而且出现次序与$P_{1},P_{2},\cdots,P_{n}$的次序保持一致，则称该$G(P_{1},P_{2},\cdots,P_{n})$为一个小项。  
显然，小项是一种在表达形式上具有特殊限制的合取式，要求合取式中的所含变量都要以一定方式出现一次且仅出现一次，对于每个变量，要么以其自身形态出现，要么以其否定形态出现。通过这种限制，就可实现对命题公式中合取运算的一种规范表达，而且很容易实现对这种规范表达形式的枚举。  
例如，含有一个命题变元$P$的小项有且仅有如下2 个，即：$P$和$\neg P$；含有两个命题变元$P$, $Q$的小项有且仅有如下4 个，即：  
$$
P\land Q\,,\,\,\,\neg P\land Q\,,\,\,\,P\land\neg Q\,,\,\,\,\neg P\land\neg Q
$$  
含有三个命题变元$\mathsf{P},\mathsf{Q},\mathsf{R}$ 的小项有且仅有如下8 个，即：  
$$
P\wedge Q\wedge R\,,\,\,\,P\wedge Q\wedge\neg R\,,\,\,\,P\wedge\neg Q\wedge R\,,\,\,\,P\wedge\neg Q\wedge\neg R\,,
$$  
$$
\neg P\land Q\land R\,,\;\;\neg P\land Q\land\neg R\,,\;\;\neg P\land\neg Q\land R\,,\;\;\neg P\land\neg Q\land\neg R
$$  
显然，含有$n$个命题变元小项有且仅有$2^{n}$个，且其中每个小项都有且仅有一个成真赋值。故可将小项唯一的成真赋值作为其编号，例如对于含两个命题变元$P$, $Q$的小项，可令：  
$$
m_{00}\Leftrightarrow\neg P\land\neg Q\,;\quad m_{01}\Leftrightarrow\neg P\land Q\,;\quad m_{10}\Leftrightarrow P\land\neg Q\,;\quad m_{11}\Leftrightarrow P\land Q
$$  
这4 个小项的真值取值情况如表3-18 所示：  
表3-18 含两个命题变元的小项
![](images/ada1d21632fe13781e4309d6e5d3eb1731aebb768a9fcff56bfcf38f1ae3303a.jpg)  
若将成真赋值对应的二进制数转化为十进制数𝑖，就可将所对应小项记作$m_{i}$。例如，对于含有两个命题变元的4 个小项，则有：  
$m_{00}\Leftrightarrow m_0; m_{01}\Leftrightarrow m_1; m_{10}\Leftrightarrow m_2; m_{11}\Leftrightarrow m_3$  
类似地，对于含三个命题变元$P$，$Q$，$R$的8 个小项，其编号如表3-19 所示。注意小项的下标： $P$、$Q\,,\ R$用1 表示；$\lnot\ P\cdot\lnot Q\cdot\lnot R.$用0 表示。  
表3-19 含三个命题变元的小项
![](images/5b90b354ff80dbf7ca55d15009478a0665bd260c70b031534983686132d847c1.jpg)  
由小项的真值取值特点易知，任意两个不同的小项的合取式为永假式，全体小项的析取式为永真式。即有：$m_{i}\wedge m_{j}=F$ $(i\neq j)$；$m_{0}\vee m_{1}\vee\cdots\vee m_{2^{n}-1}=\mathrm{T}$"
小项与大项的关系,性质,"['第三章  命题演算与推理', '§ 3.4 命题公式的范式', '3.4.4 主范式间的联系']","{'实体类型': '性质', '定义': '小项与大项之间存在互补关系', '应用': '用于构造主范式'}",,3,"如前所述，主析取范式和主合取范式统称为主范式。在主范式的具体构造过程中，有时求主析取范式更加方便，有时求主合取范式更为方便。此时，可以利用其中的一个主范式求出另外一个主范式。为此，我们进一步考察这两种主范式之间的内在联系。  
根据小项与大项的定义，易知二者之间存在着如下关系：  
$$
m_{i}\Leftrightarrow\neg M_{i};\quad M_{i}\Leftrightarrow\neg m_{i}\;\;(i=0,1,2,3,\dotsc,2^{n}-1)
$$  
例如，对含有两个命题变元$P,~Q$的小项与大项：  
$$
m_{0}\Leftrightarrow\neg P\land\neg Q\,,\;\;M_{0}\Leftrightarrow P\lor Q;\qquad m_{1}\Leftrightarrow\neg P\land Q\,,\;\;M_{1}=P\lor\neg Q
$$  
$$
m_{2}\Leftrightarrow P\land\lnot Q\,,\;\;M_{2}\Leftrightarrow\lnot P\lor Q;\quad m_{3}\Leftrightarrow P\land Q\,,\;\;M_{3}=\lnot P\lor\lnot Q\,
$$  
显然有：$m_{i}\Leftrightarrow\lnot M_{i};\ \ \ \ \ M_{i}\Leftrightarrow\lnot m_{i}$。因此小项与大项之间存在着一种互补关系。  
由于小项与大项之间存在互补关系，而主析取范式和主合取范式又分别由小项或大项构成，因此主析取范式和主合取范式之间存在一种互补关系。下面介绍一种利用主析取范式求主合取范式以及利用主合取范式求主析取范式的方法。  
已知公式$G$的主析取范式，求出公式$G$的主合取范式的步骤如下：  
第一步：求出$\neg G$的主析取范式，即公式$G$的主析取范式中没有出现过的小项的析取；  
第二步：$G\Leftrightarrow\neg\;\left(\neg G\right)$，即公式$G$的主合取范式。 已知公式$G$的主合取范式，求出公式$G$的主析取范式的步骤如下：  
第一步：求出$\neg G$的主合取范式，即公式$G$的主合取范式中没有出现过的大项的合取；  
第二步：$G\Leftrightarrow\neg\;\left(\neg G\right)$，即公式$G$的主析取范式。  
不难看出，主范式有如下性质：  
（1）命题公式是永真公式当且仅当它的主析取范式包含所有的小项，此时无主合取范式或者说主合取范式为空；  
（2）命题公式是永假公式当且仅当它的主合取范式包含所有的大项，此时无主析取范式或者说主析取范式为空；  
（3）两个命题公式是相等的当且仅当它们所对应的主析取范式相等，或者它们的所对应的主合取范式相等。  
利用主范式的性质，可以使用主范式判断两个命题公式是否等值。  
使用主范式的性质，还可以判断命题公式的类型：设𝐴是含有$n$个命题变项的命题公式，若$𝐴$为重言式，当且仅当𝐴的主析取范式中含全部$2^{n}$个小项；若𝐴为矛盾式，当且仅当𝐴的主析取范式中不含任何小项，此时记𝐴的主析取范式为0；若𝐴为可满足式，当且仅当𝐴的主析取范式中至少含一个小项。"
尼姆博弈,问题,"['第九章  树的基本理论与算法', '§ 9.4 树模型的应用', '9.4.2 轮流摸牌问题']","{'实体类型': '问题', '关键': '游戏初始状态（平衡或非平衡）和先手获胜策略', '应用': '用于计算机程序研究，如国际象棋等'}",,3,"生活中，下棋、打牌、竞技等一类竞争性的活动称为博弈。对垒的双方轮流采取行动，博弈的结果仅有三种：胜、败、平局。在对垒过程中，任何一方都了解当前的格局及过去的历史。任何一方在采取行动前都要根据当前的实际情况，进行得失分析，选取对自己有利而对对方最为不利的对策，不存在掷骰子之类的破运气因素，双方必须很明智的决定自己的行为。轮流摸牌问题，作为一种经典的博奕类游戏，问题的具体描述如下：  
桌上有𝑀堆扑克牌，每堆牌的数量分别为$N_{i}(i=1,2,\dots,M)$。现有两个选手，分别记为先手和后手，轮流进行摸牌，每一次摸牌可以任意选择一堆并取走其中的任意张牌，规定每次至少取一张，多者不限；桌上的扑克牌全部取光，则游戏结束，那么最后一次摸牌的选手即为胜者。现在问题如下：先手如果想赢，第一步有几种选择?  
轮流摸牌问题可以采用博弈树解决。博弈树是一种特殊的树模型，它的每个结点表示游戏进行时的一种局面，用每条边表示这些局面之间合乎规则的演变或移动。博弈树通常比较庞大，通常需要对其进行化简才能高效地使用。  
图9-58 所示为初始的三堆扑克牌数量。第一堆和第二堆的扑克牌数量都为3 张，第三 堆扑克牌的数量为1 张，组成了初始状态(3，3，1)。  
![图9-57  大小排序决策树 ](images/f1b07d5e01fd3916fd51d458c21160476d888d5cdc01f2f4b52f54e88d66df57.jpg)  
![图9-58 三堆扑克牌  ](images/785c75f0b4653bbc64b450a41c28647f0642a850ef357c53771601a74297ee17.jpg)  
图9-58 所示的博弈树表示轮流摸扑克牌游戏在给定初始状态（3，3，1）扩展下的所 有对弈策略。用不同堆中扑克牌数组成的无序序列表示每个局面（堆的顺序无关紧要）。先手第一次可以从有3 张扑克牌的堆中摸1 张牌（剩下包含3 张、2 张、1 张扑克牌的3堆）；也可以从有3 张扑克牌的堆中取3 张（剩下包含3 张、1 张扑克牌的2 堆）；也可以从有1 张扑克牌的堆中取1 张（剩下包含3 张扑克牌的2 堆）。当扑克牌被最后一个选手取完了，下一个选手就无法再继续摸牌，这样的局面就是终局。轮流摸扑克牌游戏是非胜即负的游戏，规定用$F$ 标记表示先手获胜，用$L$ 标记表示后手获胜。  
![图9-59 轮流取扑克牌游戏的博弈树 ](images/3e2c6b2d2a79242f7f10f5a0e2d1714f56d6c5d793d99a4f5932038bcf4cd8fa.jpg)  
根据图9-59，我们可以发现，先手如果想必赢，第一步只有一种选择，即只能从有1 张扑克牌的堆中取1 张，而不能从其它堆中摸扑克牌。  
进一步对图9-59 进行分析，可知：  
1）状态（3，3，1）必胜点，那么先手取完棋子后，后手必落在必败点；  
2）若初始状态下，只有一堆扑克牌，先手必胜； 3）若有$𝑀$堆扑克牌，每堆只有一张扑克牌，$M$为奇数时，先手必胜；  
4）若有𝑀堆扑克牌，每堆只有$k$张扑克牌，$M$为奇数时，先手必胜；  
5）先手摸𝑘张扑克牌，轮到对手时，若对手取$𝑘$张，则先手也取$𝑘$张；若对手取$x<k$张，则先手也取另外一堆的$𝑥$张。因为剩下的是偶数堆，则先手也取$𝑘$张扑克牌，总能将剩下的堆变成若干个两两相等的堆。只要始终保持这种取法，先手总能取到最后的扑克牌。  
可以将上述局面推广至一般：若某个初始局面为先手必胜，那么每走一步都必须使后首落在必败点。因此对于每一个局面，要么为胜局面，要么为负局面。用非0 表示表示胜局面，0 表示负局面。对于某一个局面，若为非0 局面，它的任务就是要寻找某一种取法，使局面变为 0  局面。那么其对手无论怎么取，都会使局面又变为 0  局面。  
那么这种对弈有什么规律呢？  
如果一个局面为先手必胜，就称这为$N$局面；反之称之为$ P$局面。对于一个局面，令$S=$$P_{1}\oplus P_{2}\oplus\ldots\oplus P_{n}$。若$S=0$则为$ P$局面，否则就为$ N$局面（⊕为异或）。  
对于图9-4-5，我们将3 堆扑克牌数异或，即$3{\oplus}3{\oplus}1{=}011{\oplus}011{\oplus}001{=}1$，异或结果为非0，那么先手将赢得这局游戏。因此先手第一步需要从第三堆中摸一张扑克牌。  
下面我们考虑下4 堆扑克牌对弈策略。其中各堆的大小分别为4，5，9，15。用二进制表示各数分别为0100，0101，1001，1111。表4-1 为各堆数量对应的二进制数。  
将这四堆扑克牌数进行异或，得到0100⊕0101⊕1001⊕1111=0111。结果非0，那么先手会赢。因此先手可以从大小为4 的堆中取走1 张牌剩下3 张，后者从大小为5 的堆中取走 3  张牌剩下 2  张，再或者从大小为 15  的堆中取走 7  张牌剩下 8  张。  
轮流摸扑克牌游戏为典型的尼姆博弈问题。尼姆博弈的关键在于游戏开始时游戏处于何种状态（平衡或非平衡）和先手是否能够按照取子游戏的获胜策略来进行游戏。  
![表9-1  各堆数量对应的二进制数 ](images/621116a8789d5d8ecab422f6290df5764c10b51f7ad37caba7ad4b05a6de41e9.jpg)  
实际生活中还有许多有益的博弈，比如一字棋、国际象棋和方棋格等等。此外，这种博弈的方法已经应用到很多的计算机程序研究中。某些博弈程序都能做到与人类选手进行对决，比如国际象棋等，可以看到如何将树应用到博弈策略的研究中具有重要的现实意义.有关博弈策略的更多内容，读者可以查阅相关资料进一步学习，这里不再赘述。"
左单位元,概念,"['第十一章  抽象代数结构通论', '§ 11.2 代数结构的运算性质', '11.2.2 特殊元素']","{'实体类型': '概念', '定义': '存在元素e_l，使得对任意x，有e_l*x=x'}",,3,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)"
左逆元,概念,"['第十一章  抽象代数结构通论', '§ 11.2 代数结构的运算性质', '11.2.2 特殊元素']","{'实体类型': '概念', '定义': '存在元素y_l，使得对任意x，有y_l*x=e'}",,3,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)"
左零元,概念,"['第十一章  抽象代数结构通论', '§ 11.2 代数结构的运算性质', '11.2.2 特殊元素']","{'实体类型': '概念', '定义': '存在元素θ_l，使得对任意x，有θ_l*x=θ_l'}",,3,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)"
差图,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.2.1 图的基本运算', '一、图的集合运算']","{'实体类型': '概念', '定义': '从一个图模型中减去另一个图模型的边后剩余的部分组成的图'}",,4,"图模型作为一种特殊的集合具有并、交、差、补、环和等集合运算，下面分别介绍这些集合运算及其相关性质。 首先给出两个图不交、不重的定义：  
【定义8.10】假设 $G_{1}=\langle V_{1},E_{1}\rangle$和 $G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，则有：  
（1）如果 $V_{1}\cap V_{2}=\varnothing$，则称 $G_{1}$ 与 $G_{2}$ 是不交的；  
（2）如果 $E_{1}\cap E_{2}=\varnothing$ ，则称 $G_{1}$ 与 $G_{2}$ 是边不交的，或者说是不重的。  
显然，对于任意两个不交的图它们必然是不重的，反之不然。  
下面给出图模型基本集合运算的定义：  
【定义 8.11 】假设   $G_{1}=\langle V_{1},E_{1}\rangle$ 和   $G_{2}=\langle V_{2},E_{2}\rangle$ 分别为不含孤立结点的图模型（它们 同为无向图或者同为有向图）。  
（1）令图 $G_{1}\cup G_{2}=\left\langle V,E\right\rangle$，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的并图，其中：$V=V_{1}\cup V_{2},\;\;E=E_{1}\cup E_{2}$  
当 $G_{1}$ 与 $G_{2}$ 不存在公共的边时，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$  的不重并。  
（2）设图 $G_{1}\cap G_{2}=\langle V,E\rangle$，称 $G_{1}\cap G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的交图，其中：$V=V_{1}\cap V_{2},\,\,\,E=E_{1}\cap E_{2}$  
$G_{1}\cap G_{2}$是由 $G_{1},G_{2}$ 中所有公共的边组成的图。  
（3）设图 $G_{1}-G_{2}=\langle V,E\rangle$，称 $G_{1}-G_{2}$ 为 $G_{1}$ 减 $G_{2}$ 的差图，其中：
$$
V=V_{1},\,\,\,E=E_{1}-E_{2}
$$  
$G_{1}-G_{2}$ 是在图 $G_{1}$ 中减去属于 $G_{2}$ 的边后所剩余的部分组成的图。  
（4）环和图 $G_{1}\oplus G_{2}$ 是由 $G_{1}$ 与 $G_{2}$ 的并图减去 $G_{1}$ 与 $G_{2}$ 的交图后得到的图。
$$
G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})
$$  
从上述定义可以看出，图模型的并、交、差、环和等集合运算其实就是普通集合运算的延伸。 需要注意的是：  
（1）若   $G_{1}=G_{2}$   ，则 $G_{1}\cup G_{2}=G_{1}\cap G_{2}=G_{1}(G_{2}),~~~~~G_{1}-G_{2}=G_{2}-G_{1}=\varnothing\,。$  
（2）$G_{1}$ 与 $G_{2}$ 不重时，$G_{1}\cap G_{2}=\varnothing$，$G_{1}-G_{2}=G_{1}$，  $G_2-G_1=G_2, G_1\oplus G_2=G_1\cup $$G_{2}$。  
（3）两个图的环和可用并、差、交给出，$G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})\,.$"
差运算,概念,"['第一章  集合与计数基础', '§ 1.1 集合的基本知识', '1.1.3 集合的基本运算', '二、差运算与补运算']","{'实体类型': '概念', '定义': '对于任意给定的两个集合A和B，集合A-B={x|x∈A并且x∉B}称为A与B的差集，A-B亦称为集合A与B的差运算', '特点': '实数减法运算在集合论中的推广'}",,4,"对于任意给定的两个集合$A$ 和$B$，有时需要将属于$A$ 但不属于$B$ 的所有元素取出来构成一个新的集合，由此得到如下集合差运算的概念：  
【定义1.12】对于任意给定的两个集合$A$ 和$B$，集合$\cdot A-B=\{x|x\in A$并且$x\notin B\}$称为$A$ 与$B$ 的差集，$A-B$亦称为集合𝐴与$B$的差运算；令$U$表示全集，则${\bar{A}}=U-A=\{x|x\in$$U$且$x\notin A\}$称为$A$ 的补集，亦称$\bar{A}$为对集合$A$ 的补运算。  
一般来说，所谓两个对象互补，是指这两个对象之间无共同部分并且若将两者合并则构成一个完整的整体。如果将全集𝑈看成是一个完整的整体，那么任何一个集合与它的补集显然构成一种互补关系。图1-3 为集合差运算和补运算的文氏图。  
![](images/3dd3ff26327d44646f11d3b3940708dbd5563cf42578e139e0a56534e35c5eff.jpg)
图1-3 差、补运算的文氏图  
不难看出，集合的差运算和补运算其实就是实数减法运算在集合论中的推广。根据集合差运算与补运算的定义，不难证明它们满足如下基本运算性质：  
(1) 矛盾律：对于任意给定的集合$A$，有：$A\cap{\bar{A}}=\emptyset$；(2) 排中律：对于任意给定的集合$A$，有：$A\cup\bar{A}=U$  
(3) 双重否定律：对于任意给定的集合$A$，有：$\bar{\bar{A}}=A$  
(4) 德摩根律：对于任意给定的两个集合$A$ 和$B$，有： $\overline{{A\cup B}}=\bar{A}\cap\bar{B},\,\,\,\overline{{A\cap B}}=\bar{A}\cup\bar{B}$  
(5) 对于任意给定的三个集合$A$、$B$ 和$C$，有：  
$A\cup(B\cup C)=(A\cup B)\cup C;\;A\cap(B\cap C)=(A\cap B)\cap C\circ$ $A\cap(B\cup C)=(A\cap B)\cup(A\cap C);\;A\cup(B\cap C)=(A\cup B)\cap(A\cup C)\,.$ $A\cap(A\cup B)=A;\,\,\,A\cup(A\cap B)=A\,.$  
现仅以德摩根律为例给出上述运算性质的证明，读者可自行给出其余证明。【例题1.22】对于任意给定的两个集合$A$ 和$B$，证明如下德摩根律：  
$$
{\overline{{A\cup B}}}={\bar{A}}\cap{\overline{{B}}}\,;\;{\overline{{A\cap B}}}={\bar{A}}\cup{\bar{B}}
$$"
布尔代数,概念,"['12.6.3 布尔表达式与函数', '§ 12.6 布尔代数基础', '3.1.1  逻辑与命题逻辑', '§ 11.1 代数结构的基本概念', '第十二章 典型抽象代数结构', '12.6.1 布尔代数与子代数', '第三章  命题演算与推理', '§ 3.1 命题的概念与运算', '第十一章  抽象代数结构通论', '11.1.1 数学结构与代数结构']","{'实体类型': ['概念', '算法'], '定义': ['一种特殊的抽象代数结构，由英国数学家布尔提出的对逻辑思维的计算法则即命题代数', '假设⟨B,*,⊕⟩是一个任意给定的有补分配格，则称其为布尔格或布尔代数，记为⟨B,*,⊕,^{-},0,1⟩', '由集合B及其上的运算*, ⊕, ¬, 0, 1组成的代数结构', '以命题符号演算与推理为处理对象的数学系统'], '应用': ['在电子电路设计中获得大量应用', '用于抽象和统一命题代数和集合代数'], '特点': ['构成电路设计的理论基础，是多个运算系统的共同基础', '两个二元运算满足交换律、结合律、吸收律和幂等律', '亦称为命题代数或命题逻辑'], '条件': '至少含有两个元素的代数系统，满足交换律、分配律、同一律、互补律', '实例': ['集合代数', '命题代数'], '创立者': '乔治∙布尔'}",,3,"代数结构作为四大基本数学结构之一，它以运算作为处理机制，在整个数学理论体系和计算机数学建模中占据非常重要的作用。代数结构是一种非常古老的数学结构，具有几千年发展历程，从最初初等代数逐步发展到大代数，然后进一步发展到抽象代数，目前正朝着泛代数的方向发展。本小节主要介绍抽象代数的由来及其基本知识结构。  
用计算机解决实际问题，一般需要对问题进行抽象并建立相应的数学模型，然后在此基础上将对实际问题的求解转化为对数学模型的求解。 因此，数学模型是用计算机解决实际问题的基础。现实问题纷繁复杂、变化万千，所建立的数学模型自然也是五花八门，多种多样，让人无所适从。值得欣慰的是，尽管我们面对的数学模型复杂多样，但从结构上看，所有这些数学模型都建立在四种基本的数学结构基础之上。  
这四种基本数学结构分别为：表示元素之间空间关系的拓扑结构，如图模型、树模型就是一些拓扑结构；表示元素之间运算关系的代数结构，如初等代数、向量代数、矩阵代数、命题代数、集合代数等都是代数结构；表示元素规模度量性质的测度结构，如高等数学里函数的微分和积分都是测度结构，它们主要计算面积、体积、弧长、速度等；表示元素之间次序关系的偏序结构，如整数的整除关系、集合的包含关系等偏序关系都是偏序结构。  
任何一个数学结构都是由载体、处理机制和处理规则这三个基本要素组成：  
（1）载体集合 对于任何一个数学结构，需要定义一些抽象的元素作为处理对象，这些抽象元素组成的集合构成数学结构的载体。载体集合是数学结构存在的基础或平台。  
（2）处理机制 为了实现对数学结构载体中元素的处理，需要定义一些处理机制，不同的数学结构具有不同的处理机制。例如：偏序结构是一种关系结构，它以元素之间的次序关系或者比较关系作为处理机制；代数结构是一种运算结构，它以元素之间的运算作为处理机制；拓扑结构是一种分布结构，它以元素之间的空间分布作为处理机制；测度结构则是一种度量结构，它以元素的规模度量作为处理机制。  
（3）处理规则 为使定义出来的数学结构满足一些合理性要求以及能够在处理实际问题中发挥作用，避免出现一些矛盾或荒诞的处理结果，还必须制定一些处理规则对处理机制做一些必要的限制。在现代数学的公理化系统中，通常称这些处理规则称为公理。不同的数学结构具有不同的处理规则，例如偏序结构限制元素之间的关系必须满足自反性、反对称性和传递性，这些限制或者性质构成了偏序结构公理系统；再如代数结构则是规定元素之间的运算必须满足结合律、交换律、分配律等运算性质。  
数学运算最早起源于算术运算，即使用具体的整数或分数进行四则运算。随着科学技术的不断发展，人们逐步意识到这种方法不能满足对一般性规律的认识。因此，采用抽象的字母来代替具体的整数和分数进行运算以获得通用性结果，并称之为代数运算或简称为代数。在微积分出现之前的数千年历史中，对代数运算的研究一直占据数学研究的核心地位。那时人们普遍信奉一种所谓的万能法则，即世界上所有问题都可以转化为数学问题，所有数学问题都可以转化为代数问题，所有代数问题都可以转化为方程问题。  
因此，在很长一段历史时期内，人们对数学的研究基本上都是对代数学的研究，对代数学的研究基本上是方程或方程组解法的研究。解方程是那个时期内所有数学家的中心任务，大家都非常期望能够通过使用代数运算的方法找到方程或方程组的通用求解公式。这种努力在线性方程组领域取得了非常完美的结果，并由初等代数逐步衍生出线性代数。但是，对于一元高次方程通用求解方法的研究并不是很顺利，对于次数高于四次的一元方程始终找不到通用求解公式或求解方法。一些非常著名的数学家，例如欧拉、高斯、拉格朗日等都对此做了大量非常艰苦的研究，但均告失败。  
在寻求五次方程通用求解方法的过程中，年仅17 岁的法国天才少年伽罗瓦在1828 年提出群的概念，运用群的思想证明了五次方程通用求解公式是不存在的，并给出了五次方程系数在满足一定条件下若干特殊解法，由此一举解决了困扰数学家长达200 多年的数学问题。伽罗瓦取得成功的关键在于不仅将运算对象进行抽象化，而且对运算本身进行抽象，在抽象对象和抽象运算的基础上通过构造一些特殊抽象代数结构进行求解。这个思想在当时实在过于超前以至于没有得到柯西、傅里叶、泊松等著名数学家的认可，泊松的判词是“完全不能理解”。 1832 年5 月31 日年仅21 岁的伽罗瓦死于决斗。在决斗之前，他把关于五次方程代数求解的研究成果写成长信，留给了人类。14 年后，法国数学家刘维尔整理并发表了伽罗瓦的遗作，人们才理解并惊叹他那超越时代的天才思想和巧妙构思。  
至此以后，人们对代数的研究内容由方程或方程组的求解技巧转变为对代数运算性质和运算结构的研究，通过对运算和运算对象进行抽象的方式实现对所有运算依其运算性质进行分类或归类，并将伽罗瓦的群论迅速发展成为一门称之为抽象代数结构的崭新数学分支。 抽象代数结构的诞生，把代数学从传统的初等代数发展到现代的抽象代数，由此打开了现代代数学的大门，开创了代数学研究的新纪元。因此，抽象代数结构通常也称为近世代数以区别于之前的初等代数。若无特别说明，我们通常将抽象代数结构简称为代数结构。  
经过一百多年的发展，抽象代数结构已经形成一个如图11-1 所示的知识体系。对于一个代数系统，我们不仅可以主动设计出它的运算并考察相应的运算规则，而且还可以通过分别对其载体集合进行相关改造或运算得到相应的子代数、积代数和商代数，可以通过映射的方式考察不同代数结构之间的区别与联系，还可根据运算性质对代数结构进行分类，形成若干典型抽象代数系统，如群、环、域、格等。  
![](images/37d476cf884c29ed65924bc021cb612de43bab4df8b1196f64e96cad4f61a01f.jpg)
图11-1 抽象代数结构的知识体系  
代数结构作为一种特殊的数学结构，具有载体、处理机制和处理规则这三个基本要素。如前所述，代数结构的载体就是由一些抽象对象为元素组成的集合，并通过运算机制实现对集合中元素的处理。所谓运算，其实就是通过映射的手段从已有元素中构造出新的元素。载体和运算统称为代数结构的成分。代数结构的处理规则即为运算性质。  
既然代数结构的载体是一个集合，那么就可以考虑通过一定方式由这个集合派生出新的集合并据此构造出新的代数结构。例如，可以考察其子集以及在子集上的运算，得到子代数的概念和性质；可以对作为载体的集合做笛卡尔集构成一个新的集合，并在新集合上定义相关运算，得到积代数的概念和性质；可以通过构造等价关系的方法实现对集合载体的划分，构成一个以等价类为元素的商集，并在这个商集上定义相关运算，得到商代数的概念和性质。子代数、积代数和商代数是构造和研究代数结构的基本方法论。  
当然，还可以考察两个代数结构之间的相似性与差异性。对于任意两个代数系统，可以在这两个代数结构的载体(集合)上建立一种保运算的映射，由此考察代数结构之间的联系。如果存在这种保运算映射，则称这两个代数系统同态。如果这种保运算的映射还是双射，则称这两个代数系统同构。同态和同构是考察代数结构之间联系的基本工具。  
依据代数结构的运算性质，可以将各种具体代数结构划分为若干抽象类型。典型的抽象代数结构类型主要有仅含一个二元运算的半群与群、含有两个二元运算的环与域，以及格与布尔代数。这些典型抽象代数结构构成代数结构知识体系的主要内容。"
布尔函数,概念,"['§ 12.6 布尔代数基础', '12.6.3 布尔表达式与函数', '§ 7.1 函数的基本概念', '7.1.3 常用特殊函数', '第十二章 典型抽象代数结构', '第七章 函数与特殊函数']","{'实体类型': '概念', '相关内容': '布尔代数的基础知识之一', '定义': ['从B^n到B的函数，可用n元布尔表达式表示', '如果f(x)是从集合A到B=\\\\{0,1\\\\}上的函数，则称f(x)为布尔函数'], '性质': '每个布尔表达式代表一个布尔函数'}",,2,布尔代数或布尔格最初由英国数学家布尔作为对逻辑思维的计算法则即命题代数提出，1938 年，美国数学家香农发表了《继电器和开关电路的符号分析》，揭示了如何使用命题逻辑的基本规则设计电路，并将布尔的命题代数进一步抽象为二值布尔代数或开关代数，使得布尔代数在电子电路设计中获得大量应用。事实上，布尔代数不仅构成电路设计的理论基础，而且是多个运算系统的共同基础。大家熟知的集合代数、命题代数都是布尔代数，或者说它们都是有补分配格。我们知道，以集合为运算对象的集合代数是整个数学的基础，以命题为运算对象的命题代数也是整个数学的基础。那么两者之间哪个更加基础呢？根据布尔代数理论，其实并不存在这样的问题。因为从布尔同构的角度看，两者其实是同一个代数结构，或者说它们只是布尔代数中两个同构的具体实例而已。本节介绍布尔代数的基础知识，包括布尔代数与子代数、布尔同态与同构、布尔表达式与布尔函数。
布尔同态,概念,"['第十二章 典型抽象代数结构', '§ 12.6 布尔代数基础', '12.6.2 布尔同态与同构']","{'实体类型': '概念', '定义': '设两个布尔代数，存在一个映射满足特定条件，则称该映射为同态映射，两个布尔代数为布尔同态'}",,3,"将代数系统中同态和同构的概念应用于布尔代数，可定义如下布尔同态与同构：  
【定义12.36】设$\langle B_{1},*,\oplus,^{-},0,1\rangle$和$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$是任意给定的两个布尔代数，如果存在一个从$B_{1}$到$B_{2}$的映射$\psi$: $B_{1}\rightarrow B_{2}$，对$\forall a,b\in L,$，$\psi$满足：  
$\begin{aligned}\psi(a*b)&=\psi(a)\circ\psi(b); \psi(a\oplus b)=\psi(a)\circledast\psi(b);\\\psi(\bar{a})&=\triangle \psi(a); \psi(0)=\alpha; \psi(1)=\beta\end{aligned}$  
则称映射$\psi$是从$\langle B_{1},*,\oplus, ^{-},0,1\rangle$到$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$的一个同态映射，并称$\langle B_{1},*,\oplus, ^{-},0,1\rangle$与$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$为布尔同态。若$\psi$是双射，则称$\psi$是从$\langle B_{1},*,\oplus, ^{-},0,1\rangle$到$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$的一个同构映射，并称$\langle B_{1},*,\oplus, ^{-},0,1\rangle$与$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$为布尔同构。  
有时难以直接讨论或研究某个比较复杂或抽象的布尔代数系统，若能找到一个与之同构的具体布尔代数系统进行研究，就会带来很多方便，例如，如果某个布尔代数和集合代数同构，则可将集合代数作为具体研究对象，从而大大简化对该布尔代数的研究。  
为了给出一个比较重要的关于布尔同构的定理，下面定义一个所谓原子的概念：  
【定义12.37】设$\langle B,*,\oplus, ^{-},0,1\rangle$是任意给定的一个布尔代数，对于$\forall a\in B$且$a\neq0$，如果对于$\forall x\in B$，满足$x*a=a$或$x*a=0$，则称$^{}a$是$\langle B,*,\oplus, ^{-},0,1\rangle$的一个原子或极小元。  
在定义中$a\neq0$表示$a$不是$B$中的最小元，而且对$B$中任一元素${x}$，要么$x$比$a$大，要么$x$和$a$不可比。简言之，除去最小元0 外，不会有任何一个元素$x$比$a$小。下面的例题12.6.7 表明，对于任意给定的一个布尔代数，可能会有多个原子。  
例如，在图12-12（a）中，$b$是最小元，唯一的原子是$a$，同时也是最大元。在图12-12（b）中，$a_{4}$是最小元，$a_{2}$和$a_{3}$都是原子，$a_{1}$是最大元但不是原子。在图12-12（c）中，$b_{8}$是最小元，$b_{5}$，$b_{6}$，$b_{7}$是原子，而$b_{1}$，$b_{2}$，$b_{3}$，$b_{4}$都不是原子。  
![](images/543436e369e6162cc7d12db06777b18d401f37573a58bcd4b6f824c830035b69.jpg)  
图12-12  布尔代数的原子  
基于原子的概念，可以得到如下关于布尔同构的斯通定理：  
【定理12.41】（斯通定理）设$\langle B,*,\oplus,^{-},0,1\rangle$是有限布尔代数，集合$𝑆$是$B$中所有原子构成的集合，那么$\langle B,*,\oplus,^{-},0,1\rangle$和$\langle P(S),\subseteq,\cap,\cup,^{-},\emptyset,S\rangle$同构。"
布尔同构,性质,"['12.6.2 布尔同态与同构', '§ 12.6 布尔代数基础', '第十二章 典型抽象代数结构']","{'实体类型': '性质, 概念', '定义': ['布尔代数中两个同构的具体实例', '若布尔同态的映射是双射，则称该映射为同构映射，两个布尔代数为布尔同构'], '应用': '简化复杂布尔代数的研究，通过同构的具体布尔代数系统进行研究'}",,2,布尔代数或布尔格最初由英国数学家布尔作为对逻辑思维的计算法则即命题代数提出，1938 年，美国数学家香农发表了《继电器和开关电路的符号分析》，揭示了如何使用命题逻辑的基本规则设计电路，并将布尔的命题代数进一步抽象为二值布尔代数或开关代数，使得布尔代数在电子电路设计中获得大量应用。事实上，布尔代数不仅构成电路设计的理论基础，而且是多个运算系统的共同基础。大家熟知的集合代数、命题代数都是布尔代数，或者说它们都是有补分配格。我们知道，以集合为运算对象的集合代数是整个数学的基础，以命题为运算对象的命题代数也是整个数学的基础。那么两者之间哪个更加基础呢？根据布尔代数理论，其实并不存在这样的问题。因为从布尔同构的角度看，两者其实是同一个代数结构，或者说它们只是布尔代数中两个同构的具体实例而已。本节介绍布尔代数的基础知识，包括布尔代数与子代数、布尔同态与同构、布尔表达式与布尔函数。
布尔子代数,概念,"['第十二章 典型抽象代数结构', '§ 12.6 布尔代数基础', '12.6.1 布尔代数与子代数']","{'实体类型': '概念', '定义': '设⟨B,*,⊕,-,0,1⟩是任意给定的一个布尔代数，S是B的非空子集，若S对运算*,⊕,^{-}都封闭且0,1∈S，则称⟨S,*,⊕,^{-},0,1⟩是⟨B,*,⊕,-,0,1⟩的子布尔代数'}",,3,"如前所述，有补分配格既保证了格中每个元素都存在其补元素，又保证了每个元素补元素的唯一性。显然，这其实是定义了格结构载体集合上的一元求补映射或运算。因此，有补分配格结构具有保交、保联和保补这三种运算。具体地说，有补分配格是一个包含两个二元运算$*$和⊕以及一个一元运$^{-}$所构成的特殊代数系统。这种特殊的代数系统其实就是布尔代数系统，具体定义如下，通常将用字母$B$表示布尔代数的载体集：  
【定义12.34】假设$\langle B,*,\oplus\rangle$是一个任意给定的有补分配格，则称其为布尔格或布尔代数，记为 $\langle B,*,\oplus,^{-},0,1\rangle$ 。 如果 $L$ 是有限集， 则称 $\langle B,*,\oplus,^{-},0,1\rangle$ 为有限布尔格或有限布尔代数； 如 果$L$是无限集，则称$\langle B,*,\oplus,^{-},0,1\rangle$为无限布尔格或无限布尔代数。  
显然，布尔代数的两个二元运算满足交换律、结合律、吸收律和幂等律等，然而这些定  
律并非独立的，例如幂等律可由吸收律得到。那么哪些运算律能够从本质上判定一个代数系统是否为布尔代数呢？下面的定理12.39 给出了具体答案，该定理结论也可看成是从运算性质的角度给出布尔代数系统的一个公理化定义：  
【定理12.39】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个至少含有两个元素的代数系统，$*$和⊕是定义在$𝐿$上的二元运算,$^{-}$ 是定义在$B$上的一元运算，对$\forall\ \ a,b,c\in B$，如果满足：  
（1）交换律：$a*b=b*a$，$a\oplus b=b\oplus a$  
（2）分配律：$a*(b\oplus c)=(a*b)\oplus(a*c);\,\,\,a\oplus(b*c)=(a\oplus b)*(a\oplus c)$  
（3）同一律：$a*1=a$，$a\oplus0={\mathsf{a}}$  
（4）互补律：${\bar{a}}*a=0$，${\bar{a}}\oplus a=1$  
则$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数。  
将代数系统中子代数的概念应用于布尔代数，可定义如下布尔子代数概念：  
【定义12.35】设$\langle B,*,\oplus,-,0,1\rangle $是任意给定的一个布尔代数，$S$是$B$的非空子集，若$𝑆$对运算${\ast,\oplus,^{-}}$ 都封闭且$0{,}1\in S$，则称$\langle S,*,\oplus,\stackrel{-}{\quad},0,1\rangle,$是$\langle B,*,\oplus,-,0,1\rangle $的子布尔代数。"
布尔矩阵,概念,"['第五章 关系模型与理论', '§ 5.1 关系的数学模型', '5.1.3 关系的表示', '3、矩阵表示法']","{'实体类型': '概念', '定义': '元素仅有0和1的矩阵', '特点': '用于逻辑演算，运算规则与普通矩阵有差异', '基本运算': '并运算、交运算、补运算、布尔积运算'}",,4,"在使用关系的数学模型对实际问题进行建模的时候，通常需要对关系模型进行一些定量的数值计算以实现对实际问题的求解，此时无论是关系的集合表示方法和关系图法，都不方便实现对关系模型定量的数值计算。为此，我们引入二元关系的矩阵表示法。  
假设$\boldsymbol A=\{a_{1},a_{2},\cdots,a_{n}\}$, $B=\{b_{1},b_{2},\cdots,b_{m}\}$是任意给定的两个非空有限集合，$R$是$A$到$B$的一个二元关系，则按下列方式定义的$m\times n$阶矩阵$M_{R}=(r_{i j})_{m\times n}$称为$R$的关系矩阵：
$$
r_{ij}=\begin{cases}1\text{,若}\langle a_i,b_j\rangle\in R\\0\text{,若}\langle a_i,b_j\rangle\not\in R\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-3)}
$$
其中$A$中元素$a_{i\cdot}$序号对应矩阵元素的行下标，$B$中元素$b_{j}$序号对应矩阵元素的列下标。  
值得注意的是：由关系矩阵的定义可知，关系矩阵的元素有且仅有0 和1 这两种状态，这样的矩阵一般称之为布尔矩阵，主要用于一些逻辑演算，在运算规则上与普通矩阵有一些差异。为满足后续内容学习的需要，在此简要介绍布尔矩阵的若干基本运算，具体包括并运算、交运算、补运算和布尔积运算，其具体定义如下：  
【定义5.9】设$A=\left(a_{i j}\right)$和$B=\left(b_{i j}\right)$是两个$m\times n$布尔矩阵，则$𝐴$和$B$的并矩阵定义为如下$m\times n$布尔矩阵：$A\lor B=C=\left(c_{i j}\right)$，其中：  
$c_{ij}=\begin{cases}1\text{,如果}a_{ij}=1\text{ 或}b_{ij}=1\\0\text{,如果}a_{ij}=0\text{ 且}b_{ij}=0\end{cases}(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-4)}$      （5-4）  
【定义5.10】设$A=\left(a_{i j}\right)$和$B=\left(b_{i j}\right)$是两个$m\times n$布尔矩阵，则$A$和$B$的交矩阵定义为如下一个$m\times n$布尔矩阵：$A\land B=C=\left(c_{i j}\right)$，其中：
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=1\text{ 且}b_{ij}=1\\0\text{,如果}a_{ij}=0\text{ 或}b_{ij}=0\end{cases}(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-5)}
$$
【定义5.11】设$A=\left(a_{i j}\right)$任意给定的一个$m\times n$布尔矩阵，则𝐴的补矩阵定义为如下$m\times$$n$布尔矩阵：$\bar{A}=C=\left(c_{i j}\right)$，其中：
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=0\\0\text{,如果}a_{ij}=1\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-6)}
$$
【定义5.12】设$A=\left(a_{i j}\right)$是$m\times p$矩阵，$B=\left(b_{i j}\right)$是$p\times n$矩阵，则$𝐴$和$B$的布尔积矩阵定义为如下$m\times n$布尔矩阵：$A\odot B=C=\left(c_{i j}\right)$，其中：  
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=0\\0\text{,如果}a_{ij}=1\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-6)}
$$
需要注意的是：两个布尔矩阵可进行布尔或和布尔与运算的前提是这两个矩阵具有相同的行数和列数，可进行布尔积运算的前提是前一个矩阵的列数等于后一个矩阵的行数。  
在学习了二元关系的三个基本表示方法后，下面我们考察空关系、完全关系和恒等关系这三个常用特殊关系的关系矩阵和关系图各有什么特点：  
(1) 空关系$\varnothing$  因为$\emptyset\subseteq A\times B$(或$\emptyset\subseteq A\times A)$)，所以$\varnothing$也是一个从$𝐴$到$B$(或$𝐴$上)的关系，称之为空关系，即无任何元素的关系。空关系的关系图中只有结点，无任何边，且关系矩阵中的元素全是0  
(2) 完全关系（全域关系） $A\times B$或(或$A\times A)$本身也是一个从$𝐴$到$B$(或$𝐴$上)的关系，称之为完全关系，即含有全部序偶的关系。完全关系的关系图中所有结点之间都有有向边互联，关系矩阵中的元素全是1。  
(3) 恒等关系 $I_{A}$  $I_{A}\subseteq A\times A$，则$I_{A}=\{\langle x,x\rangle|x\in A\}$为$A$上的恒等关系。完全关系的关系图中所有结点都有一个有向环，不同结点之间无任何有向边联结。  
![](images/9a95167e68610708edb7fef0f0474b8284d349dcc5f3b662d3280809d00fbf1e.jpg)
图5-6 空关系、全关系与恒等关系  
设$A=\left\{1,\ 2,\ 3\right\}$，则$A$ 上的空关系∅、完全关系$A\times A$及恒等关系$I_{A}$的关系图如图5-6 所示，下面三个布尔矩阵分别是它们的关系矩阵：  
$M_{\emptyset}=\left(\begin{array}{ccc}0&0&0\\0&0&0\\0&0&0\end{array}\right)\quad M_{A\times A}=\left(\begin{array}{ccc}1&1&1\\1&1&1\\1&1&1\end{array}\right)\quad M_{I_A}=\left(\begin{array}{ccc}1&0&0\\0&1&0\\0&0&1\end{array}\right)$"
布尔表达式,概念,"['12.6.3 布尔表达式与函数', '§ 12.6 布尔代数基础', '第十二章 典型抽象代数结构']","{'实体类型': '概念', '相关内容': '布尔代数的基础知识之一', '定义': '由布尔常元、布尔变元及运算*, ⊕, ¬构成的符号串', '特点': '有限次使用运算规则构造'}",,2,布尔代数或布尔格最初由英国数学家布尔作为对逻辑思维的计算法则即命题代数提出，1938 年，美国数学家香农发表了《继电器和开关电路的符号分析》，揭示了如何使用命题逻辑的基本规则设计电路，并将布尔的命题代数进一步抽象为二值布尔代数或开关代数，使得布尔代数在电子电路设计中获得大量应用。事实上，布尔代数不仅构成电路设计的理论基础，而且是多个运算系统的共同基础。大家熟知的集合代数、命题代数都是布尔代数，或者说它们都是有补分配格。我们知道，以集合为运算对象的集合代数是整个数学的基础，以命题为运算对象的命题代数也是整个数学的基础。那么两者之间哪个更加基础呢？根据布尔代数理论，其实并不存在这样的问题。因为从布尔同构的角度看，两者其实是同一个代数结构，或者说它们只是布尔代数中两个同构的具体实例而已。本节介绍布尔代数的基础知识，包括布尔代数与子代数、布尔同态与同构、布尔表达式与布尔函数。
布鲁克斯定理,定理,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.3.3 着色问题与算法', '一、点着色与边着色']","{'实体类型': '定理', '结论': '设G是一个连通简单图，其结点的最大度为Δ(G)。如果G既不是完全图，也不是长度奇数的基本回路，则χ(G)≤Δ(G)'}",,4,"首先考察一个实例，我们通常在同一台冰箱内存放不同种类的食物，其中有些食品必须分别保存在不同冰箱隔间以免串味或污染。例如，苹果和鸡蛋应该分开存放、腊肉和蔬菜应该分开存放等等。现有$A,B,C,D,E,F$六种食品，若要求$𝐴$与$𝐵$、$𝐴$与$C$、$𝐴$与$𝐷$、$B$与$C$、$C$与$D$、$C$与$F$、$D$与$E$、$E$与$F$不能放在一起，则至少需要几个隔间才能存放这些食物。  
![图10-56 冰箱中食物存放问题  ](images/557fa53c5bf02920ef35e88225888a1b53ecb35568cc495b689ec5f32f0de05e.jpg)  
可用一个无向图模型表示上述问题，图的每个结点分别代表一种食物，如果两种食物不能放在一起，则在这两种食物之间画一条无向边，如图10-55（a）所示。可通过对该图的结进行着色的方法实现对上述问题的求解。具体地说，就是对图中每个结点分别涂上或者标注一种颜色，并满足相邻的结点之间具有不同的颜色，将相同颜色结点所代表的食物放在同一个隔间，则所需要的最少颜色数目显然就是所求的冰箱隔间数目。  
不难知道，最少需要三种颜色才能实现对图10-55（a）所示无向图全部结点的着色，图10-55（b）表示其中一种着色方案。  
事实上，如果将上述六种食物分别看成是某个工程中的六项不同的任务，将不能存放在同一个隔间的两种食物理解为不能同时执行的两个任务，则可按照图10-55（b）所示的结点着色方案将这些任务以同色为标准分成3 个并行执行的任务集合。因此，无向图的着色理论与方法在并行计算与任务规划等领域具有非常重要的作用。  
对于一个比较复杂的无向图，要实现对该图所有结点的着色，在很多情况下不是一件很显然的事情。下面具体考察点着色问题，首先给出结点着色的定义，具体如下：  
【定义10.11】设$G=\langle V,E\rangle$是任意给定的一个无向图，如果对图𝐺的每个结点都涂上或标注一种颜色，并满足相邻的两个点具有不同的颜色，则称这种操作是对图$G$的结点着色，简称为对图𝐺的点着色。如果这些颜色选自于一个有𝑘种颜色的集合而不管$k$种颜色是否都用到，则称这样的点作色为称为𝒌着色，并称𝐺是${k}$-可着色的。若𝐺是$k{-}$可着色的，但不是$(k-$$1)-$可着色的，则称𝐺是一个${k}$-色图，并称$k$为图𝐺的点色数或色数，记为$𝜒(𝐺)$。  
![](images/53a26dc56eb7520c616c57e24f7d17f1e7686d610feaf89b55e20658f6ec1e28.jpg)  
例如，对于图10-55（a）所示无向图，该图就是一个3-色图，其射数$\chi(G)=3$。再如，图56（a）所示完全图$K_{5}$是一个5-色图；图56（b）所示完全二分图$K_{3,4}$是一个2-色图；图56（c）所示回路$C_{6}$是一个2-色图；图56（d）所示回路$C_{5}$为一个3-色图。  
通过上述例题不难看出，对于$G$的任何子图$H$，均有$\chi(H)\leq\chi(G)$，若$G$是$n$阶完全图，则$\chi(G)=n$；若$G$是至少有一边的二分图，则$\chi(G)=2$；若$G$是长为奇数的圈，则$\chi(G)=3$。一般地，关于无向图$G$的点色数，有如下定理：  
【定理10.19】设$G=\langle V,E\rangle$是任意给定的一个无向图，则有：  
（1）$\chi(G)=1$当且仅当$G$为零图。  
（2）对于完全图$K_{n}$：$\chi(K_{n})=n$。  
（3）$G$是一条回路：则若$|V|$是偶数，$\chi(G)=2$；若$|V|$是奇数，$\chi(G)=3$（4）$G$是一棵非平凡树，则$\chi(G)=2$。  
（5）$\chi(G)=2$的充要条件是：（a）$|E|\ge1$；（b）$G$为二分图。  
（6）对于任意无向线图$G$，若其结点的最大度为$\Delta(G)$  
$$
\chi(G)\leq\Delta(G)+1
$$  
【定理10.20】（布鲁克斯定理）设$G$是一个连通简单图，其结点的最大度为$\Delta(G)$。如果$G$既不是完全图，也不是长度奇数的基本回路，则$\chi(G)\leq\Delta(G)$。  
我们知道，任意一个不是零图的无向图都是由结点和边这两个要素构成，既然可对结点进行着色，自然也可对边进行着色。由此得到如下边着色的相关定义：  
【定义10.12】设$G=\langle V,E\rangle$是任意给定的一个无向图，如果对图$G$的每条边都涂上或标注一种颜色，并满足相邻的两条边具有不同的颜色，则称这种操作是对图$G$的边着色。如果这些颜色选自于一个有$k$种颜色的集合而不管$k$种颜色是否都用到，则称这样的边作色为称为𝒌边着色，并称$G$是$\pmb{k}$-边可着色的。若$G$是$k^{-}$边可着色的，但不是$\,(k-1)$-边可着色的，则称$G$是一个$\pmb{k}$-边色图，并称$k$为图$G$的边色数，记为$\chi^{\prime}(G)$。  
关于边色数的问题, 可以说目前已得到较好的解决。乌克兰数学家维津在1964 年提出的维津定理给出一个比较满意答案，具体如下：  
【定理10.21】（维津定理）设$G=\langle V,E\rangle$是任意给定的一个无向图，则有：  
（1）若图$G$是简单图，图中结点最大度为$\Delta(G)$，则$\chi^{\prime}(G)=\Delta(G)$或$\Delta(G)+1$；  
（2）若图$G$是二分图，图中结点最大度为$\Delta(G)$，则$\chi^{\prime}(G)=\Delta(G)$；  
（3）对于完全图$K_{n}$，若$n(n\neq1)$为奇数，$\chi^{\prime}(K_{n})=n$；若$_{n}$为偶数，$\chi^{\prime}(K_{n})=n-1$"
布鲁英序列,概念,"['第十章  特殊图模型与算法', '§ 10.4 网络流图及其优化问题', '10.5.1 鼓轮设计问题']","{'实体类型': '概念', '定义': '通过特定排列方式得到的二进制数码序列，用于计算机鼓轮设计', '应用': '用于确保鼓轮每旋转一周输出所有不同的二进制数'}",,3,"计算机鼓轮是由绝缘材料和导电材料制成，主要用于输出二进制数码。例如，对于如图10-7（a）所示的一个轮鼓，旋转鼓的表面分成了8 块扇形，图中阴影区表示用导电材料制成，空白区用绝缘材料制成，终端𝑎、𝑏和 $c$与扇面接触时接触导体输出1，接触绝缘体时输出0。鼓轮按逆时针旋转，触点每转一个扇区就输出一个三位二进制信号。  
问题是如何设计这8 块扇形区域绝缘材料与导电材料的分布，使得鼓轮每旋转一周，就能得到从000 到111 这8 个不同的二进制数。这就是计算机鼓论设计问题。从数学逻辑上看，这个问题也可理解为：如何将8 个二进制数码排成一个圆圈，使得任意3 个依次相连的数码组成的三位二进制数互不相同，而且能够产生全部8 个不同的三位二进制数。  
对于终端$a,b,c$，若某时刻的输出信号为$a_{1}a_{2}a_{3}$，则每转一个扇形，信号变成$a_{2}a_{3}a_{4}$。由此可见，前一次输出信号的右两位决定了后一次输出信号的左两位。故可把所有两位二进制数作为结点，将二进制数码之间传递关系的结点引一条有向边，将这两个二位二进制数进行串接并合并两者重复的部分，产生一个三位二进制数，并用这个三位二进制数表示该有向边。例如，对于结点$a_{1}a_{2}$和$a_{2}a_{3}$，可从$a_{1}a_{2}$到$a_{2}a_{3}$引一条有向边表示$a_{1}a_{2}a_{3}$这个三位的二进制数。由此得到如图10-7（b）所示的有向图。  
![图10-89 三位计算机轮鼓设计问题 ](images/fd2bd5a3740dee863b37e0bc2d2faadb7b3dbae1169c6c42913ac97c999411af.jpg)  
由于图10-7（b）所示有向图中每条边都代表一个三位二进制数，并且不同边表示不同的三位二进制数。因此，若能在该有向图上求出一条欧拉回路，则可得到该全部 8 个三位二进制数的一个圆排列，由该圆排列不难得到所求8 个二进制数码的圆排列。  
由图10-7（b）可知，该有向图4 个结点的出度和入度数均为2 故存在欧拉回路，比如$(e_{0},e_{1},e_{3},e_{7},e_{6},e_{5},e_{2},e_{4})$即是一条欧拉回路，根据该回路不难得到其对应的8 个二进制数码的圆排列为：00011101。按此数码排列分布计算机轮鼓8 块扇形区域绝缘材料与导电材料，则该鼓轮按逆时针每旋转一个扇区就输出一个三位二进制信号，鼓轮每旋转一周，就能得到从000 到111 这8 个不同的二进制数。  
上述所求的8 个二进制数码的圆排列00011101 称为一个8 位布鲁英序列。下面进一步考察16 位布鲁英序列。如图10-90（a）所示，此时旋转鼓的表面分成了16 块扇形，图中阴影区表示用导电材料制成，空白区用绝缘材料制成，终端$a$、$b$、𝑐和 $d$与扇面接触时接触导体输出1，接触绝缘体时输出0。鼓轮按逆时针旋转，触点每转一个扇区就输出一个二进制信号。问题是如何选取这16 块扇形的材料，使鼓轮旋转一周，触点能够输出个不同的四位二进制信号，并且每转一周就能得到从$0000{\sim}1111$ 这全部16 个四位二进制数。  
![图10-90 四位计算机轮鼓设计问题 ](images/5b3de38c173917b97e4ae2bdc5b3b0f102b52c396d35769298cedf57247d3416.jpg)  
从逻辑上看，四位计算机轮鼓设计问题也可理解为：把16 个二进制数排成一个圆圈，使得4 个依次相连的数字所组成的16 个四位二进制数互不相同。  
对于终端$a,b,c,d$，若某时刻的输出信号为$a_{1}a_{2}a_{3}a_{4}$，则每转一个扇形，信号变成$a_{2}a_{3}a_{4}a_{5}$。由此可以看出，前一次输出信号的右三位决定了后一次输出信号的左三位。因此，我们可把所有三位二进制数作结点，从每一个结点$a_{1}a_{2}a_{3}$到$a_{2}a_{3}a_{4}$引一条有向边表示$a_{1}a_{2}a_{3}a_{4}$这个四位的二进制数，作出表示所有可能的码变换的有向图如图10-90（b）所示。于是问题转化为在这个有向图上求一条欧拉回路。  
由图10-90（b）可知，该有向图8 个结点的出度和入度均为2，故存在欧拉回路，例如$e_{0},e_{1},e_{2},e_{4},e_{9},e_{3},e_{6},e_{13},e_{10},e_{5},e_{11},e_{7},e_{15},e_{14},e_{12},e_{8}$是一条欧拉回路，其对应布鲁英序列为0000100110101111。计算机轮鼓绝缘材料与导电材料按此序列分布便可满足要求。"
带余除法,概念,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.1 整数与整数除法']","{'实体类型': '概念', '定义': '假设a和b是任意给定的两个整数且a≠0，则必然存在唯一确定的一对整数q和r，满足b=aq+r, 0≤r<|a|', '属性': 'a为除数、b为被除数、q为b除以a的商、r为b除以a的余数'}",,3,"在第一章，我们得到自然数和自然数集的定义。在自然数集中加入每个非零元素的相反数就得到整数集合，整数集中每个元素称为整数。也就是说，对于整数集合$z$，有：  
$$
Z\!=\!\{\cdots\!,\,\!-4,\,\!-3,\,\!-2,\,\!-1,\,0,\,1,\,2,\,3,\,4,\,\cdots\}
$$  
对于整数，我们主要考察其除法运算，包括整除和带余除法，由此可以得到倍数与因子、素数与合数、商与余数的相关概念和性质。  
首先在整数及其乘法运算基础上，考察整除的概念与性质。  
【定义2.1】假设$a$ 和$b$ 是任意给定的两个整数且$a\neq0$，若存在整数$q$，满足$b=a\cdot q($其中“∙”表示普通数乘运算，通常将其省略)，则称$\pmb{a}$ 能整除$\pmb{b}$，或$\pmb{b}$ 能被$\pmb{a}$ 整除，记为a|b。此时，又称$a$ 是$b$ 的因子或$b$ 是$a$ 的倍数。若不存在任何整数$q$，满足$b=a q$，则称$\pmb{a}$ 不能整除$\pmb{b}$，或$\pmb{b}$ 不能被$\pmb{a}$ 整除，记为$a\nmid b$。  
例如：5|25，13 ∤120，7|49，13|0，$^{-3}\vert$-12，9 ∤−56；8 的因子有$\pm1$，$\pm2$，$\pm4$和$\pm8$，7的因子有$\pm1$和$\pm7$。显然，对于任意一个给定的整数$a$，它至少能够被$\pm1$或$\pm n$整除。因此，这四个是$a$ 的因子，称其为$a$ 的平凡因子。$a$ 的其它因子称为非平凡因子。  
【定义2.2】对于任意一个给定的非零整数$a$，若$a\ne\pm1$且没有非平凡因子，则称$a$ 为素数或质数；否则称$a$ 为合数。  
从一定意义上讲，素数是构成整数的基本要素，在整数理论中具有极其重要的地位。若非特别说明，我们所说的素数都是指正素数。2 是第一个正素数，其后还有3, 5, 7, 11,…, 等等。我们还会后续相关内容中详细讨论素数的性质与应用。  
例如，整数2, 3, 5, 7, 11, 13 都是素数，而4, 10, 16, 21 都不是素数。  
对于一个不是很大的整数，显然可用一个比较简单的方法来判定一个大于2 的正整数$b$是否为素数：用从2 到$b-1$的每一个整数去除$b$，如果这些整数都不是$b$ 的因子，那么$b$是素数。注意到：若$a k=b$，则$a$ 或$k$ 小于或等于$\sqrt{b}$。由此可知，如果$b$ 不是素数，那么它必有一个因子$k$ 满足不等式$1<k\leq{\sqrt{b}}$ 。因此，为得到更高的效率，只需在这个范围里检验因子。同样，如果$b$ 有一偶数因子，那么2 一定是该因子的一个因子。因此，在通过2 的整除性检验后，可以跳过所有偶数。要判断一个很大的整数是否为素数则不是一件容易的事情，我们将在本章后续的相关部分具体介绍整数集合中大素数的分布和查找知识。  
整数的整除运算具有如下基本性质：  
【定理2.1】假设$a,b,c$ 是3 个任意给定的整数，则有：  
（1）$a|b$ 当且仅当$\pm a|\pm b$；  
（2）若$a|b,\ b|c$，则 $a|c$；  
（3）若$;b|a_{i},\;\;i=1,\;\;2,\;\;\cdots,\;\;k$，则 $b|a_{1}x_{1}+a_{2}x_{2}+\cdots+a_{k}x_{k}$，此处 $x_{i}(i=1,\ \ 2$，$\cdots,\;\;k)$也是任意的整数；  
（4）若$b|a$，则 $b p|a p$，此处$p$ 是任意非零整数；  
（5）若$b|a$，$a\neq0$，则 $|b|\leq|a|$； 下面仅证明（3）和（5），其余性质的证明与此类似，读者可自行给出。  
根据整除的定义，我们知道任意两个整数之间并不一定满足整除关系。为使整数能够正常进行除法运算，必须对整除概念进行推广。事实上，对于任意两个整数，虽然它们之间不一定具有整除关系，但总存在如下关系：  
【定理2.2】假设$a$ 和$b$ 是任意给定的两个整数且$a\neq0$，则必然存在唯一确定的一对整数$q$ 和$r$，满足下列等式：  
$$
b=a q+r,\;\;0\leq r<|a|\tag{2-1}
$$  
此时称整数$a$ 为除数、$b$ 为被除数、$q$为$b$ 除以$a$的商、$r$为$b$ 除以$a$ 的余数。"
常函数,概念,"['第七章 函数与特殊函数', '§ 7.1 函数的基本概念', '7.1.3 常用特殊函数']","{'实体类型': '概念', '定义': '设f\\colon A\\to B，若有c\\in B，对\\forall x\\in A都有f(x)=c，则称f\\colon A\\to B是常函数'}",,3,"数学中常用的特殊函数有很多，在初等数学和高等数学中都有大量的分析讨论，例如三角函数、指数函数等基本初等函数，不再一一赘述。在此，我们主要介绍在计算机科学应用中经常使用的一些函数，例如恒等函数、常函数、取整函数、布尔函数、自然映射函数等。下面给出这些常用特殊函数的定义。  
【定义7.6】设$𝐴$和$B$是任意给定的两个非空集合：  
（1）设$f\colon A\to B$，若有$c\in B$，对$\forall x\in A$都有$f(x)=c$，则称$f\colon A\to B$是常函数。  
（2）$𝐴$上的恒等函数就是$𝐴$的恒等关系$I_{A}$，对$\forall x\in A$，有$I_{A}(x)=x$。  
（3）对实数 $x$ ， $f(x)$ 取不小于 $ x$ 的最小整数，则称 $f(x)$ 为上取整函数， 记为 $f(x)=\left\lceil x\right\rceil$  
（4）对实数$x$，$f(x)$取不大于$ x$的最大整数，则称$f(x)$为下取整函数，记为$f(x)=\lfloor x\rfloor$  
（5）如果$f(x)$是从集合$𝐴$到$B=\{0,1\}$上的函数，则称$f(x)$为布尔函数。  
（6）设$R$是$𝐴$上的等价关系，$A/R$是$𝐴$在关系$R$上的商集，令$g\colon A\to A/R$，$g(x)=[x]_{R}$则称$g$是从$A$到$A/R$的自然映射。"
常系数齐次线性递推关系,概念,"['第一章  集合与计数基础', '§ 1.4 有限集的高级计数技术', '1.4.2 递推关系的求解']","{'实体类型': '概念', '定义': '设$a_{1}$，$a_{2}$，⋯，$a_{k}$是$k$个常数且$a_{k}\\neq0$，则下列递推关系：$u_{n}=a_{1}u_{n-1}+a_{2}u_{n-2}+\\cdots+a_{k}u_{n-k}(n\\geq k)$称为$k$阶常系数线性齐次递推关系', '求解理论': '通过转化为常系数齐次线性递推关系实现求解'}",,3,"递推关系是复杂问题和动态问题求解重要工具，要使递推关系在问题求解中发挥作用特别是在计数问题中发挥作用，有时需要实现对递推关系式的求解，也就是说要找到满足递推公式的所有数列或部分数列的显示通项表达式。对递推关系式的求解是一个非常复杂的数学问题，属于离散数学及相关学科的前沿研究课题，有兴趣的读者可以查阅相关资料做进一步深入研究。作为抛砖引玉，我们仅介绍其中两种最常用的基本解法，即针对简单递推关系的迭代求解方法和针对常系数齐次线性递推关系的特征根求解方法。  
迭代求解法是一种最基本的解法，该方法主要用于求解一些比较简单的递推关系式，由如下两个基本步骤构成：  
第一、利用递推关系式对其右边的表达式进行迭代，并推测通项的显示表达式；  
第二、用数学归纳法证明得到的公式。  
目前还没有一个一般性的方法或公式能够实现对任意递推关系式的求解，通常需要针对对递推关系式的具体特点给出相应的求解方法。常系数齐次线性递推关系是一种特殊的递推关系，针对这类递推关系有一套完备可行的求解理论和方法。这套求解理论和方法是求解其它递推关系式的基础，因为很多其它递推关系式都是通过设法将其转化为某种常系数齐次线性递推关系的途径实现求解。下面给出常系数齐次线性递推关系的定义：  
【定义1.27】设$a_{1}$，$a_{2}$，⋯，$a_{k}$是$k$个常数且$a_{k}\neq0$，则下列递推关系：  
$$
u_{n}=a_{1}u_{n-1}+a_{2}u_{n-2}+\cdots+a_{k}u_{n-k}(n\geq k)
$$  
称为$k$阶常系数线性齐次递推关系。  
如果数列 $\{b_{n}\}_{n\geq0}$ 满足 $.b_{n}=a_{1}b_{n-1}+a_{2}b_{n-2}+\cdots+a_{k}b_{n-k}(n\geq k)$ ，则称数列 $\{b_{n}\}_{n\geq O}$ 或 $u_{n}=b_{n}{\big(}n=0,~1,~2,~\cdots{\big)}$是递推关系式(1 −17)的一个解。  
问题：递推关系式(1 −17)有没有解？如果有解，有多少个解？如何求解？下面的定理表明常系数齐次线性递推关系在满足初始条件的情况下有唯一解：  
【定理1.19】任意给出$k$个常数$b_{0}\,,\;\;b_{1}\,,\;\;\cdots\,,\;\;b_{k-1}$，有且仅有唯一一个数列是递推关系式 (1 −17) 满足初始条件 $v_{0}=b_{0}$ ， $v_{1}=b_{1}$ ， ⋯ ， $v_{k-1}=b_{k-1}$ 的解。  
对于常系数齐次线性递推关系的求解，基本思路是采用一种所谓特征根的方法，通过引入特征方程和特征根的概念，巧妙地将递推关系的求解问题转化为求代数方程根的求解问题。为此，我们引入如下特征方程和特征根的定义：  
【定义1.27】如下方程：  
$$
x^{k}-a_{1}x^{k-1}-a_{2}x^{k-2}-\cdots-a_{k-1}x-a_{k}=0
$$  
称为递推关系式(1 −17)的特征方程，它的根称为递推关系式(1 −17)的特征根。  
因为$a_{k}\neq0$，所以0 不是递推关系式(1 −17)的特征根。 下面的定理非常关键，它给出了特征根与常系数齐次线性递推关系解之间的联系：  
【定理1.20】设$q$ 是非0 复数，则$u_{n}=q^{n}$是递推关系式(1 −17)的一个解当且仅当$q$是递推关系式(1 −17)的一个特征根。  
下面定理给出了常系数齐次线性递推关系解的结构特点：  
【定理1.21】设$\cdot u_{n}=g_{i}(n)(i=1,2,\cdots,s)$均为递推关系式(1 −17)的解，$c_{i}(i=1,\!2,\cdots,s)$为任意常数，则有：  
$$
=\sum_{i=1}^{s}c_{i}g_{i}(n)
$$  
也是递推关系式(1 −17)的解。  
【定理1.22】如果递推关系式(1 −17)的$k$ 个特征根$q_{1}\,,\;\;q_{2}\,,\;\;\cdots\,,\;\;q_{k}$彼此相异，则  
$$
u_{n}=c_{1}q_{1}^{n}+c_{2}q_{2}^{n}+\cdots+c_{k}q_{k}^{n}
$$  
是递推关系式(1 −17)的通解。其中$c_{1}\,,\;\;c_{2}\,,\;\;\cdots\,,\;\;c_{k}$为任意常数。"
幂关系,概念,"['第五章 关系模型与理论', '§ 5.2 关系的基本运算', '5.2.3 幂关系与逆关系']","{'实体类型': '概念', '定义': '设R是集合A上的关系，则可归纳定义R的n次方幂R^n运算如下：R^0=I_A={⟨a,a⟩|a∈A}; R^1=R; R^(n+1)=R^n∘R=R∘R^n∘R', '特点': '方幂运算的结果也是A上的二元关系，即对于任何自然数k，有R^k⊆A×A', '运算法则': 'R^m∘R^n=R^(m+n); (R^m)^n=R^(mn)', '性质': '幂集R^n的基数|R^n|并非随着n的增加而增加，而是呈递减趋势；当n≥|A|时，则R^n出现循环取值或退化为空关系'}",,3,"如前所述，关系的复合运算满足结合律。也就是说，如果有多个关系进行复合运算，只要不交换它们的运算次序，不管哪个先参与合成，最后结果都一样。由此可见，对于某个集合上的一个二元关系，如果它可以不断地与自己做复合运算，那么运算结果只与该关系以及复合运算次数有关，而与复合的次序无光。由此可得如下关系方幂运算的概念：  
【定义5.15】设$R$ 是集合$A$ 上的关系，则可归纳定义$R$ 的$n$次方幂${R^{n}}$运算如下：  
$（1）R^{0}=I_{A}=\left\{\langle a,\ a\rangle\big|a\in A\right\};\quad(\,2\,)\,\ R^{1}=R;\ (\,3\,)\,\ R^{n+1}=R^{n}\circ R=R\circ R^{n}\circ R.$    方幂运算的结果也显然也是$A$ 上的二元关系，即对于任何自然数$k$，有$R^{k}\subseteq A\times A$。通常称为$R$的方幂关系或幂关系，不难证明方幂运算满足如下运算法则：
$$
R^{m}\circ R^{n}=R^{m+n};\,\,\,(R^{m})^{n}=R^{m n}
$$  
由上述例题可以看出：  
（1）幂集$R^{n}$的基数$\vert{R}^{n}\vert$并非随着$n$ 的增加而增加，而是呈递减趋势；  
（2）当$n\geq|A|$时，则$R^{n}$出现循环取值或退化为空关系。 下面的定理给出了上述结论的一个解释：  
【定理5.7】设𝐴是一个具有${n}$个元素的有限集合，$R$ 是$𝐴$上的二元关系，则必存在自然数$s$ 和$t$，使得$R^{s}=R^{t}$，$0\leq s<t\leq2^{n^{2}}$。  
上述定理表明，对于任意一个有限集合，该集合上的二元关系总共只有有限多个，而对于该集合上的二元关系，其方幂运算则可以无限地进行下去且运算结果均为该集合上的二元关系。因此，在一定次数的方幂运算之后，后续的方幂运算结果自然是以某种循环的方式出现，或者以恒等于某个特定关系的方式出现。  
【定义5.16】设$A,\ B$ 是任意两个集合，$R$ 是$A$ 到$B$ 的关系，则从$B$ 到$A$ 的关系：
$$
R^{-1}=\{\langle b,a\rangle|\langle a,b\rangle\in R\}\quad\text{(5-9)}
$$
称为$R$ 的逆关系，运算“-1”称为关系的逆运算。  
关于逆关系概念的理解，需要注意如下几个要点：（1）关系是序偶的集合，逆关系也是序偶的集合；（2）如果$R$ 是一个关系，则其逆关系$R^{-1}$和补关系$\bar{R}$都是关系，但是两者是完全不同的两个关系，千万不要混淆；（3）显然有$(R^{-1})^{-1}=R$，$\varnothing^{-1}=\varnothing$。  
【定理5.8】设$A$，$B$ 和$C$是任意三个集合，$R$，$S$ 分别是从$A$ 到$B$ 和$B$ 到$C$的二元关系，则有：$(R\circ S)^{-1}=S^{-1}\circ R^{-1}$  
可以看出，复合关系的逆关系等于它们逆关系的反复合。要注意$(R\circ S)^{-1}\neq R^{-1}\circ S^{-1}$，因为$R^{-1}$是从$B$ 到$A$ 的关系，而$S^{-1}$是从$C$ 到$B$ 的关系，因此$S^{-1}$与$R^{-1}$之间是可复合的，而$R^{-1}$与$S^{-1}$之间是不可复合的。  
下面定理给出了关系逆运算与关系集合运算之间的分配运算律：  
【定理5.9】设$R,\ S$是从集合$A$ 到集合$B$ 的关系，则有如下分配律：
$$
(R\cup S)^{-1}=R^{-1}\cup S^{-1};\;\;(R\cup S)^{-1}=R^{-1}\cup S^{-1};\;\;(R-S)^{-1}=R^{-1}-S^{-1}
$$  
对于任意给定的集合𝐴和$B$，目前所讨论的二元关系有两种基本类型，一种是集合$𝐴$到集合$ B$上的二元关系，另外一种是集合𝐴上的二元关系。事实上，这两种关系没有本质上的区别，因为若令$C=A\cup B$，则集合$𝐴$到集合$B$上的二元关系就可以看成是$C\times C$的几个子集合，或者说是$C$上的二元关系。因此，在后续内容中所说的关系，若非特别说明，均为某个集合上的关系而不是从某个集合到另外一个集合上的关系。"
幂等元,概念,"['第十二章 典型抽象代数结构', '§ 12.2 群结构的基本知识', '12.2.1 群的基本概念']","{'实体类型': '概念', '定义': '在群⟨G,*⟩中，单位元是⟨G,*⟩中唯一的一个幂等元'}",,3,"如前所述，群代数结构是对幺半群结构在逆元方面的进一步扩充，其具体定义如下：  
【定义12.8】假设$\langle G,*\rangle$是任意给定的一个二元代数结构，如果$\langle G,*\rangle$满足如下性质：  
（1）结合律：对于$\forall x,y,z\in G$，成立：$(x\ \ *y)*z=x\ \ *(y*z)$；  
（2）含单位元：$\exists e\in G$，使得对于$\forall x\in G$，成立$\,\!e*x=x*e=x$；  
（3）运算$*$可逆：对于$\forall x\in G$，都存在$x^{-1}\in G$，使得$x^{-1}*x=x*x^{-1}=e$。  
则称$\langle G,*\rangle$是一个群代数结构，简称为群结构或群。  
从上述定义可知，对于任意给定的非空集合 $G$ 以及该集合上某个二元运算 $*$ ，$\langle G,*\rangle$ 能够 形成一个群结构的充分必要条件是$\langle G,*\rangle$必须满足封闭性、结合律、含幺性和可逆性这四个基本运算性质。例如，对于实数集合及其上的普通加法运算构成的代数结构$\langle R,+\rangle$，显然满足群的四条基本性质，其中0 是其单位元，对于$\forall x\in R$，$-x$是$x$的逆元。但是，对于实数集合及其上的普通乘法运算构成的代数结构$\langle R,\times\rangle$则不是一个群，因为在$\langle R,\times\rangle$中0 没有逆元素。不难发现，对于任意给定的集合$𝐴$，$\langle{ P}(A),\cup\rangle$和$\langle{ P}(A),\cap\rangle$都不能构成群结构，因为在$\langle{ P}(A),\cup\rangle$中$𝐴$没有逆元，在$\langle{P}(A),\cap\rangle$中$\varnothing$没有逆元。  
【定义12.9】设$\langle G,*\rangle$是任意给定的一个群，称$|G|$为$\langle G,*\rangle$的阶，如果$|G|$为有限数，则称  
$\langle G,*\rangle$为有限群，否则$\langle G,*\rangle$为无限群。如果运算$^*$满足交换律，即对于$\forall x,y\in G$，有$x*y=y*$$x$则称群$\langle G,*\rangle$是一个交换群或阿贝尔群。  
【定理12.3】设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$的单位元是$\langle G,*\rangle$中唯一的一个幂等元，若$|G|>1$，则$\langle G,*\rangle$中无零元且满足消去律。  
下面的定理12.2.2 给出了群中逆元素的基本性质：  
【定理12.4】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，有：  
$$
(a^{-1})^{-1}=a\,\exists(a*b)^{-1}=b^{-1}*a^{-1}
$$  
下面的定理12.5 给出了群与方程可解性之间的关系：  
【定理12.5】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，方程$a\circ x=b$和$y\circ a=$$b$在$\langle G,*\rangle$中有且仅有唯一解。  
由于群结构满足结合律，故可类似于半群和含幺半群定义元素的方幂：  
【定义12.10】设$\langle G,*\rangle$是任意给定的一个群，对于$\forall a\in G$和正整数$ n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$ a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个a}
$$  
定义$a^{0}=e$且$a^{-n}=(a^{-1})^{n}$  
从上述定义可以看出，对于一个群结构$\langle G,*\rangle$可以定义其任意整数的方幂运算，包括负指数方幂。因此，对于$G$中的任何一个元素$a$，均可以通过其正方幂、零方幂和负方幂构成一个向胜负两端无限延伸的序列，具体如下：  
$$
\cdots,a^{-n},\cdots,a^{-2},a^{-1},a^{0}\ \ ,a^{1},a^{2},\cdots,a^{n},\cdots
$$  
这些序列显然满足幂的运算法则，即对于任意整数$n$和$m$，有：  
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
如果$\langle G,*\rangle$是一个有限群$\langle G,*\rangle$，则根据运算的封闭性和鸽笼原理易知，在$G$中任意一个元素的无穷多个方幂中，必然至少有两个是相等的。具体地说，对于任意给定的$G$中某个元素$a$，必然存在两个不相等的整数$m$和$|n$，不妨设$m<n$，满足：  
$$
a^n=a^m\text{或}a^{n-m}=e
$$  
此时，可将正整数$n-m$看成是元素$a$方幂变化的一个周期。一般地，有如下定义：  
【定义12.11】设$\langle G,*\rangle$是任意给定的一个群，$e$是该群的单位元，对于$G$中任意给定的某个元素$a$，如果存在正整数$n$，满足$a^{n}=e$，则其中最小的正整数称为元素$a$的周期或阶，记为$|a|$，否则称元素$a$的周期为无限大或元素$a$的阶为无限大。  
例如，对于群$\langle\underline{{6}},+_{6}\rangle$，元素1 的阶为6，元素2 的阶为3，元素3 的阶为2，元素4 的阶为3，元素5 的阶为6，元素0 的阶为1。对于整数集合上的加法群$\langle Z,+\rangle$，显然，除了元素0 的周期为1 之外，其余任一非零元素的周期均为无穷大。事实上，不难看出，对于任何一个群，有且只有其单位元的阶为1。  
下面给出关于元素阶的两个重要性质：  
【定理12.6】有限群$\langle G,*\rangle$的每个元素都有有限阶，且其阶数不超过群的阶数|G|。  
【定理12.7】设$\langle G,*\rangle$为群，$G$中元素$a$的阶为$ k$，那么$a^{n}=e$当且仅当$k$整除$ n$  。"
幂等律,性质,"['第十一章  抽象代数结构通论', '§ 11.2 代数结构的运算性质', '11.2.1  二元算律']","{'实体类型': '性质', '定义': '在二元代数结构中，存在元素a，满足a*a=a', '应用': '幂集合上的交运算和并运算', '反例': '整数上的加法运算'}",,3,"现在我们介绍和讨论二元运算律。一共有六个二元运算律，即结合律、交换律、幂等律、消去律、分配律和吸收率。其中前面四个基于单个二元运算，后面两个基于两个二元运算。下面分别讨论这些运算律，首先讨论结合律。  
结合律是大家非常熟悉也是非常重要的一个二元运算律，实数加法与乘法运算、矩阵的加法与乘法运算、关系与函数的复合运算、整数集合上的模余运算、幂集合的交运算与并运算等都满足结合律。结合律的具体定义如下：  
【定义11.5】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由$𝐴$和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$，成立$(x*y)*z=x*(y*z)$，则称$\langle A,*\rangle$的运算 $^*$ 在 𝐴 上是可结合的，或者说 $\langle A,*\rangle$ 的运算 $^*$ 在 𝐴 上满足结合律。  
对于任意给定的集合𝐴，由于𝐴上的二元运算${\ast}$满足封闭性，故对于$\forall x,y,z\in A$，有${x\ *}$$y\in A$且$y*z\in A$。因此，$(x*y)*z$和$x*(y*z)$都是有意义的算式，如果$*$满足结合律，则表达式$x*y*z$就有一个确定的计算结果，即有：  
$$
x*y*z=(x*y)*z=x*(y*z)
$$  
如果 $*$ 不满足结合律，则有可能有 $(x*y)*z\neq x*(y*z).$ 。   此时，表达式 $x*y*z$ 的含义就有歧义。因此，只有当某个运算$*$满足结合律时，才能定义其方幂运算。在后续半群与群中元素方幂的的定义中，其元素运算的结合律起着基础性的支撑作用。  
下面考察运算的交换律，首先给出交换律的定义，具体如下：  
【定义11.6】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y\in A$，成立$x*y=y*x$，则称$\langle A,\ *\rangle$的运算$^*$在𝐴上是可交换的，或者说$\langle A,\ *\rangle$的运算$^*$在𝐴上满足交换律。  
交换律表示代数结构载体集合中的任意两个元素在运算时都可以交换次序。 例如，实数加法与乘法运算、矩阵的加法、整数集合上的模余运算、幂集合的交运算与并运算等都满足交换律。 但是，矩阵的乘法运算、关系与函数的复合运算等都不满足交换律。  
【定义11.7】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，若存在某个元素$a\in A$，满足 a$*$$a=a$，则称$a$是$\langle A,\ *\rangle$的一个幂等元。 如果𝐴中的每个元素都是$\langle A,\ *\rangle$的幂等元，则称$\langle A,\ *\rangle$的运算$*$在𝐴上满足幂等律。  
从上述定义可以看出，所谓幂等元，就是该元素与其自身运算之后仍然等于其自身。例如，对于某个幂集合上的交运算和并运算，幂集合中每个元素显然都是幂等元，因此，幂集合上的交运算和并运算均满足幂等性。但是，对于整数上的加法运算，除了整数0 之外，其余整数显然都不是幂等元，因此,整数上的加法运算不满足幂等律。  
【定义11.8】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$：  
（1）若$z*y=z*x$，有$y=x$，则称运算$*$在𝐴上是可左消去的，或者说运算$∗$在𝐴上满足左消去律，并称$\cdot z$是$A$中关于运算$^*$的左可消去元；  
（2）若$y*z=x*z$，有$y=x$，则称运算$^*$在𝐴上是可右消去的，或者说运算$^*$在𝐴上满足右消去律，并称𝑧是$A$中关于运算$^*$的右可消去元。  
（3）若上述两种情况均满足，则称运算$*$在𝐴上满足消去律，并称$z$是𝐴中关于运算$*$的可消去元。  
下面介绍基于两个二元运算的运算律，即分配律和吸收律。首先给出分配律的定义：  
【定义11.9】假设𝐴是任意给定的一个非空集合，$^*$和$\Delta$均为𝐴上的二元运算，在由$𝐴$、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y,z\in A$：  
若有$x*(y\Delta z)=(x*y)\Delta(x*z)$，则称运算$*$对$\Delta$在𝐴上满足左分配律。  
若有$(y\Delta z)*x=(y*x)\Delta(z*x)$，则称运算$*$对$\Delta$在𝐴上满足右分配律。  
若运算$*$对$\Delta$在𝐴上同时满足左右分配律，则称运算$*$对$\Delta$在𝐴上满足分配律。  
例如，实数集合上的普通乘法对加法满足分配律，$M_{n}(R)$上的矩阵乘法对加法满足分配律，幂集$P(B)$上的集合交运算对并运算满足分配律，并且并运算对交运算也满足分配律。  
将上述关于集合的吸收律推广到一般运算对象和一般运算，得到一个新的运算律，即吸收律。其具体定义如下：  
【定义11.10】设𝐴是任意给定的一个非空集合，$*$和$\Delta$均为为𝐴上二元运算，在由𝐴、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y\in A$，成立：  
$$
x*(y\Delta z)=x,\;\;x\Delta(y*z)=x
$$  
则称 $*$ 和 $\Delta$ 在 A  上满足吸收律。"
幂集,概念,"['3.有限子集与幂集', '1.1.2 集合的概念与表示', '四、常用的特殊集合', '§ 1.1 集合的基本知识', '第一章  集合与计数基础']","{'实体类型': '概念', '特点': ['具有特殊性质', '是一种特殊的集族'], '定义': '以集合A的所有不同子集为元素构成的集合称为A的幂集', '记法': ['P(A)', '2^A'], 'name': '幂集'}",,4,集合论中有一些非常重要和常用的特殊集合，它们分别具有一些特殊性质。离散数学中很多基本概念的定义及其性质讨论都离不开它们。下面具体介绍这些特殊集合的基本概念及性质，包括空集、全集、有限集、无限集、子集、幂集等。
平凡图,概念,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.2 图的定义与分类']","{'实体类型': '概念', '定义': '仅含一个孤立结点而没有边的图'}",,3,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)"
平方取中法,算法,"['第七章 函数与特殊函数', '§ 7.4 有限集的置换函数', '7.5.1 哈希查找问题']","{'实体类型': '算法', '定义': '将关键字求平方后，取其中间的几位数字作为散列地址的方法', '特点': '产生冲突的可能性较小'}",,3,"在计算机系统中，数据的存放位置和时间都不能完全确定，此时需要一种有效的方法在有限的存储空间中合理存放数据并且能够实现快速定位查找。此时，如果建立一个关于存储位置和数据关键字的对应关系$f$，就能找给定值$k e y$的像$f(k e y)$。这里的对应关系$f$通常称为哈希函数，这种数据查找方法称为哈希查找。  
例如，如果要建立一张学生成绩表，最简单的方法是以学生的学号作为关键字，1 号学生的记录位置放在第一条，10 号学生的记录位置放在第10 条，以此类推。此时，如果要查看的学号为5 的学生的成绩，则只要取出第5 条记录就可以了.这样建立的表实际上就是一张简单的哈希表，其哈希函数为$f(k e y){=}\ k e y$。然而很多情况下的哈希函数并不如此简单。为了查看的方便，可能会以学生的名字作为关键字。此时，为了能够根据学生的名字直接定位出相应记录所在的位置，需要将这些名字转化为数字，构造出相应的哈希函数，下面给出两个不同的哈希函数：  
（1）考察学生名字的汉语拼音，将其中第一个字母在英语字母表中的序号作为哈希函数值。例如：“蔡军”的汉语拼音第一个字母为字母$C$，因此取03 作为其哈希值。  
（2）考察学生名字的汉语拼音，将其中第一个字母和最后一个字母在英语字母表中的序号之和作为哈希函数值。例如，“蔡军”的汉语拼音第一个字母和最后一个字母分别为$𝐶$和$N$，因此取17 作为其哈希值。  
分别应用这两个哈希函数，成绩表中部分学生名字不同的哈希函数值如表7-7 所示。  
表 7-7
![](images/a45025876fc98ab470bf113421a83e13ab1997baea6e789cdbd16990f25f7ba0.jpg)  
![](images/0f18f81e6e78fd7fb2b0f104794c8a798e21b0531706abe9d65a4f9970f2f012.jpg)  
在哈希表的构造过程中，可能会出现不同的关键字映射到同一地址的情况，即$k e y_{1}\neq$$k e y_{2}$，但$f(k e y_{1})=f(k e y_{2})$，也将这种现象称为冲突和碰撞。实际上，由于哈希函数是把任意长度的字符串映射为固定长度的字符串，冲突必然存在，只能尽可能减少。常见的构造哈希函数的方法有以下几种：  
（1）数字分析法。数字分析法适合于关键字由若干数码组成，同时各数码的分布规律事先知道的情况。具体方法是：分析关键字集合中每个关键字中的每一位数码的分布情况，找出数码分布均匀的若干位作为关键字的存储地址。例如，一个由80 个结点组成的结构，其关键字为6 位十进制数。选择哈希表长度为100，则可取关键字中的两位十进制数作为结点的存储地址。具体采用哪两位数码，需要用数字分析法对关键字中的数码分布情况进行分析。假设结点中有一部分关键字如下：  
$k e y_{1}=301514\;\;;\;\;\;k e y_{2}=303027;\;\;k e y_{3}=301103;\;\;\;k e y_{4}=308329;$ $k e y_{5}=300287;\;\;k e y_{6}=305939;\;\;k e y_{7}=300792;\;\;k e y_{8}=300463\circ878.$  
对上述关键字分析可以发现，关键字的第一位均是3，第二位均是0，分布集中，不适合作为存储地址。而第4 位和第5 位分布均匀，所以该哈希函数可以构造为取第4,5 位作为结点的存储地址。上述8 个节点的散列地址为：  
$f(k e y_{1})=51~~~~f(k e y_{2})=02~~~~f(k e y_{3})=10~~~~f(k e y_{4})=32$ $f(k e y_{5})=28\;\;\;\;\;f(k e y_{6})=93\;\;\;\;\;f(k e y_{7})=79\;\;\;\;\;f(k e y_{8})=46$  
（2）平方取中法。平方取中法是一种比较常用的构造哈希函数的方法，具体是：将关键字求平方后，取其中间的几位数字作为散列地址。由于关键字平方后的中间几位数字和组成关键字的每一位数字都有关，因此产生冲突的可能性较小，最后究竟取几位数字作为散列地址需要由散列表的长度决定。例如，若结构的存储地址范围是1\~999，则取平方值的中间三位，如表7-8 所示。  
表7-8  平方取中法
![](images/3bce2eeb41624a2b374dfdbdb4f5d0a22039c970673844c48a904ace588c42b7.jpg)  
（3）除留余数法。除留余数法取关键字被某个不大于哈希表表长$m$的数$ p$除后所得余数为哈希地址，即$f(k e y)=k e y({\bmod{\ p}})$，其中$p\leq m$。这是一种最简单也是最常用的构造哈希函数的方法。它不仅可以对关键字直接取模（mod），也可在平方取中等运算之后取模。值得注意的是，在使用除留余数法时，对$ p$的选择很重要。若$p$选的不好，容易产生同义词。由经验得知：一般情况下可以选$p$为质数或不包含小于20 的质因素的合数。  
哈希函数中会不可避免的存在冲突。因此，在建造哈希函数时不仅要设定一个“好”的哈希函数，而且要设定一种处理冲突的方法。假设哈希表地址集为$\!\sim\!(n-1)$，冲突是指由关键字得到的哈希地址为𝑗$(0\leq j\leq n-1)$的位置上已有记录，则“处理冲突”就是为该关键字的记录找到另一个“空”的哈希地址。  
在处理冲突的过程中可能得到一个地址序列$h_{i}$，其中，$h_{i}\in[0,\mathfrak{n}-1],\mathrm{i}=1,2,\cdots,\mathtt{k}$。即  
在处理哈希地址的冲突时，若得到的另一个哈希地址${\bf h}_{1}$ 仍然发生冲突，则再求下一个地址$h_{2}$，若$ h_{2}$仍然冲突，再求得$h_{3}$，依此类推，直至$h_{k}$不发生冲突为止，则$h_{k}$为记录在表中的地址。处理冲突的具体方法通常有开放定址法、再哈希法和拉链法，这里不再赘述。"
平衡二叉树,概念,"['第九章  树的基本理论与算法', '§ 9.3 特殊根数与算法', '9.3.1 平衡树模型']","{'实体类型': '概念', '定义': '一种特殊的二叉树，要求树中任何结点的两棵子树高度差不能超过1', '特点': '通过旋转操作维持平衡状态', '应用': '保证树上的基本操作具有较好的最坏情况性能，适用于信息查找等场合', '操作': '查找、插入和删除结点', '平衡因子': '-1，0 或1', '旋转方式': '左旋转，右旋转，先左后右旋转，先右后左旋转'}",,3,"对于二叉树的一些基本操作，比如插入、删除和查找等，其算法时间复杂度都与树的高度有关。因此，适当控制树高是一个非常关键的问题。显然，控制树高的一个有效措施就是尽量保持树的左右子树高度大致平衡，由此产生平衡二叉树的概念。  
平衡二叉树是一种特殊的二叉树，要求树中任何结点的两棵子树高度差不能超过1，如果插入或者删除一个结点使得高度之差大于1，就要进行结点之间的旋转操作，将二叉树重新维持在一个平衡状态。  
平衡二叉树是一种非常重要的树模型，因为它可以保证一些在树上的基本操作具有较好的最坏情况性能，这使它在信息查找等很多场合有着十分重要的作用。后面将会详细介绍平衡二叉树的若干特例，如红黑树、$B$树等。  
平衡二叉树的操作主要有查找、插入和删除结点等。其中插入和删除结点操作可能需要通过一次或多次旋转操作来重新平衡该树，使其满足平衡二叉树的要求。下面简要介绍有关平衡二叉树的一些基本概念和操作。  
树模型中某结点左子树的高度减去该结点右子树的高度，所形成的差值称为该结点的平衡因子，即$\mathrm{Balance~Fector(BF)=}$左子树的高度-右子树的高度。  
平衡二叉树的平衡因子为-1，0 或1。设计平衡二叉树操作算法的关键在于如何使得平衡二叉树保持平衡。以下四种情况下的插入操作可能会导致原有平衡二叉树发生不平衡:  
（1）LL：若某一节点的平衡因子为1，当在其左子树的左子树上插入一个新结点时会导致该结点的平衡因子由1 变为2。  
（2）RR：若某一节点的平衡因子为-1，当在其右子树的右子树上插入一个新结点时会导致该结点的平衡因子由-1 变为-2。  
（3）LR：若某一节点的平衡因子为1，当在其左子树的右子树上插入一个新结点时会导致该结点的平衡因子由1 变为2。  
（4）RL：若某一节点的平衡因子为-1，当在其右子树的左子树上插入一个新结点时会导致该结点的平衡因子由-1 变为-2。  
平衡二叉树有四种基本的旋转方式，分别为：左旋转，右旋转，先左后右旋转，先右后左旋转。针对上述四种情况可能导致的不平衡，可通过旋转的方式使得平衡二叉树恢复平衡，具体做法如下（箭头中数字为子树的高度，结点旁边的数字为其平衡因子）：  
![图 $9{-}30~\mathrm{LL}$  情况旋转](images/ca76734b4d3583b5c59b3d750c1c21778ffd2f87170aec4bd9132947c230f2d0.jpg)  
![图9-31RR 情况旋转 ](images/de09284418b14138ebb993596ee227f73dfbd205bc84b4dc9b8dc270f608bf3d.jpg)  
（1）LL 型调整：插入操作，当三个结点处于一条直线，并均是左结点时(导致LL 情况)需要以中间结点为旋转轴向右侧(顺时针)旋转一次。如图9-30 所示。具体步骤如下：  
步骤一：将 $𝐴$ 的左子树 $B$ 提升为新二叉树的根  
步骤二：将原来的 $𝐴$ 连同其右子树 ${\mathbf{}}A_{R}$ 向下旋转，使其成为 𝐵 的右子树  
步骤三：将$B$的原右子树${B_{R}}$作为左子树连接到𝐴上  
（2）RR 型调整：插入操作，当三个结点处于一条直线，并均是右结点时(导致RR 情况)需要以中间的结点为旋转轴向左侧(逆时针)旋转一次。如图9-31 所示。具体步骤如下：  
步骤一：将 $𝐴$ 的右子树 $B$ 提升为新二叉树的根  
步骤二：将原来的 $𝐴 $连同其左子树 ${}^{;}A_{L}$ 向下旋转，使其成为 $𝐵$ 的左子树  
步骤三：将$\cdot B$的原左子树$B_{L}$作为左子树连接到𝐴上  
（3）LR 型调整：插入操作，当三结点不在一直线且均是左结点时，需以插入结点为旋转轴向左侧(逆时针)旋转一次，然后向右侧(顺时针)旋转一次，即先做RR 操作再做一次LL 操作（在LR 情况，需要先将$B$左旋转，再将𝐴右旋转），如图9-32 所示。具体步骤如下：  
首先执行RR 旋转：  
步骤一：将 $B$ 的右子树 $C$ 提升为新二叉树的“根”  
步骤二：将原来的 $B$ 连同其左子树 ${'}B_{L}$ 向下旋转，使其成为 𝐶 的左子树  
步骤三：将$C$的原左子树$C_{L}$作为右子树连接到$B$上  
然后再执行LL 旋转：  
步骤四：将$𝐴 $的左子树 $C$ 提升为新二叉树的根  
步骤五：将原来的 $𝐴$ 连同其右子树 ${\mathbf{}}A_{R}$ 向下旋转，使其成为 $𝐶$ 的右子树  
步骤六：将𝐶的原右子树$C_{R}$作为左子树连接到𝐴上  
![图9-32 平衡二叉树插入操作LR 情况旋转](images/86ffa77dc86336b0d7814938270d287104a964c00ad6b86a183a77c341a73ccd.jpg)
![图9-33  RL 情况旋转 ](images/73d2aa49589db07f2f0cd8ac54b27db44de079203d670420e8cc6330c886ef14.jpg)  
（4）RL 型调整：插入操作，当三结点不在一直线且均是右结点时，需以插入结点为旋转轴向右侧(顺时针)旋转一次，然后向左侧(逆时针)旋转一次，即先做LL 操作再做一次RR 操作（在RL 情况，需先将$B$右旋转，再将𝐴左旋转）。如图9-33 所示。具体步骤如下：  
首先执行LL 旋转  
步骤一：将 $B$ 的左子树 $C$ 提升为新二叉树的“根”  
步骤二：将原来的 $B$ 连同其右子树 $B_{R}$ 向下旋转，使其成为 $𝐶$ 的右子树  
步骤三：将$𝐶$的原右子树$C_{R}$作为左子树连接到$B$上  
然后再执行 RR  旋转  
步骤四：将 $𝐴$ 的右子树 $C$ 提升为新二叉树的根  
步骤五：将原来的 $𝐴$ 连同其左子树 ${}^{;}A_{L}$ 向下旋转，使其成为 $𝐶$ 的左子树  
步骤六：将$𝐶$的原左子树$C_{L}$作为右子树连接到$𝐴$上 在上述四种旋转基础上，就可对平衡二叉树进行插入和删除操作，具体如下：  
（1）插入操作：插入完成后需要从插入的结点开始维护一个到根结点的路径，每经过一个结点都要维持树的平衡，需要根据高度差的特点采取不同的旋转策略进行调整，使整棵树恢复成为平衡树。  
（2）删除操作：首先定位要删除的结点，删除完成后，要从删除结点的父亲开始向上维护树的平衡一直到根结点，然后采取不同的旋转策略调整，使整棵树恢复成为平衡树。"
平衡因子,概念,"['第九章  树的基本理论与算法', '§ 9.3 特殊根数与算法', '9.3.1 平衡树模型']","{'实体类型': '概念', '定义': '树模型中某结点左子树的高度减去该结点右子树的高度所形成的差值'}",,3,"对于二叉树的一些基本操作，比如插入、删除和查找等，其算法时间复杂度都与树的高度有关。因此，适当控制树高是一个非常关键的问题。显然，控制树高的一个有效措施就是尽量保持树的左右子树高度大致平衡，由此产生平衡二叉树的概念。  
平衡二叉树是一种特殊的二叉树，要求树中任何结点的两棵子树高度差不能超过1，如果插入或者删除一个结点使得高度之差大于1，就要进行结点之间的旋转操作，将二叉树重新维持在一个平衡状态。  
平衡二叉树是一种非常重要的树模型，因为它可以保证一些在树上的基本操作具有较好的最坏情况性能，这使它在信息查找等很多场合有着十分重要的作用。后面将会详细介绍平衡二叉树的若干特例，如红黑树、$B$树等。  
平衡二叉树的操作主要有查找、插入和删除结点等。其中插入和删除结点操作可能需要通过一次或多次旋转操作来重新平衡该树，使其满足平衡二叉树的要求。下面简要介绍有关平衡二叉树的一些基本概念和操作。  
树模型中某结点左子树的高度减去该结点右子树的高度，所形成的差值称为该结点的平衡因子，即$\mathrm{Balance~Fector(BF)=}$左子树的高度-右子树的高度。  
平衡二叉树的平衡因子为-1，0 或1。设计平衡二叉树操作算法的关键在于如何使得平衡二叉树保持平衡。以下四种情况下的插入操作可能会导致原有平衡二叉树发生不平衡:  
（1）LL：若某一节点的平衡因子为1，当在其左子树的左子树上插入一个新结点时会导致该结点的平衡因子由1 变为2。  
（2）RR：若某一节点的平衡因子为-1，当在其右子树的右子树上插入一个新结点时会导致该结点的平衡因子由-1 变为-2。  
（3）LR：若某一节点的平衡因子为1，当在其左子树的右子树上插入一个新结点时会导致该结点的平衡因子由1 变为2。  
（4）RL：若某一节点的平衡因子为-1，当在其右子树的左子树上插入一个新结点时会导致该结点的平衡因子由-1 变为-2。  
平衡二叉树有四种基本的旋转方式，分别为：左旋转，右旋转，先左后右旋转，先右后左旋转。针对上述四种情况可能导致的不平衡，可通过旋转的方式使得平衡二叉树恢复平衡，具体做法如下（箭头中数字为子树的高度，结点旁边的数字为其平衡因子）：  
![图 $9{-}30~\mathrm{LL}$  情况旋转](images/ca76734b4d3583b5c59b3d750c1c21778ffd2f87170aec4bd9132947c230f2d0.jpg)  
![图9-31RR 情况旋转 ](images/de09284418b14138ebb993596ee227f73dfbd205bc84b4dc9b8dc270f608bf3d.jpg)  
（1）LL 型调整：插入操作，当三个结点处于一条直线，并均是左结点时(导致LL 情况)需要以中间结点为旋转轴向右侧(顺时针)旋转一次。如图9-30 所示。具体步骤如下：  
步骤一：将 $𝐴$ 的左子树 $B$ 提升为新二叉树的根  
步骤二：将原来的 $𝐴$ 连同其右子树 ${\mathbf{}}A_{R}$ 向下旋转，使其成为 𝐵 的右子树  
步骤三：将$B$的原右子树${B_{R}}$作为左子树连接到𝐴上  
（2）RR 型调整：插入操作，当三个结点处于一条直线，并均是右结点时(导致RR 情况)需要以中间的结点为旋转轴向左侧(逆时针)旋转一次。如图9-31 所示。具体步骤如下：  
步骤一：将 $𝐴$ 的右子树 $B$ 提升为新二叉树的根  
步骤二：将原来的 $𝐴 $连同其左子树 ${}^{;}A_{L}$ 向下旋转，使其成为 $𝐵$ 的左子树  
步骤三：将$\cdot B$的原左子树$B_{L}$作为左子树连接到𝐴上  
（3）LR 型调整：插入操作，当三结点不在一直线且均是左结点时，需以插入结点为旋转轴向左侧(逆时针)旋转一次，然后向右侧(顺时针)旋转一次，即先做RR 操作再做一次LL 操作（在LR 情况，需要先将$B$左旋转，再将𝐴右旋转），如图9-32 所示。具体步骤如下：  
首先执行RR 旋转：  
步骤一：将 $B$ 的右子树 $C$ 提升为新二叉树的“根”  
步骤二：将原来的 $B$ 连同其左子树 ${'}B_{L}$ 向下旋转，使其成为 𝐶 的左子树  
步骤三：将$C$的原左子树$C_{L}$作为右子树连接到$B$上  
然后再执行LL 旋转：  
步骤四：将$𝐴 $的左子树 $C$ 提升为新二叉树的根  
步骤五：将原来的 $𝐴$ 连同其右子树 ${\mathbf{}}A_{R}$ 向下旋转，使其成为 $𝐶$ 的右子树  
步骤六：将𝐶的原右子树$C_{R}$作为左子树连接到𝐴上  
![图9-32 平衡二叉树插入操作LR 情况旋转](images/86ffa77dc86336b0d7814938270d287104a964c00ad6b86a183a77c341a73ccd.jpg)
![图9-33  RL 情况旋转 ](images/73d2aa49589db07f2f0cd8ac54b27db44de079203d670420e8cc6330c886ef14.jpg)  
（4）RL 型调整：插入操作，当三结点不在一直线且均是右结点时，需以插入结点为旋转轴向右侧(顺时针)旋转一次，然后向左侧(逆时针)旋转一次，即先做LL 操作再做一次RR 操作（在RL 情况，需先将$B$右旋转，再将𝐴左旋转）。如图9-33 所示。具体步骤如下：  
首先执行LL 旋转  
步骤一：将 $B$ 的左子树 $C$ 提升为新二叉树的“根”  
步骤二：将原来的 $B$ 连同其右子树 $B_{R}$ 向下旋转，使其成为 $𝐶$ 的右子树  
步骤三：将$𝐶$的原右子树$C_{R}$作为左子树连接到$B$上  
然后再执行 RR  旋转  
步骤四：将 $𝐴$ 的右子树 $C$ 提升为新二叉树的根  
步骤五：将原来的 $𝐴$ 连同其左子树 ${}^{;}A_{L}$ 向下旋转，使其成为 $𝐶$ 的左子树  
步骤六：将$𝐶$的原左子树$C_{L}$作为右子树连接到$𝐴$上 在上述四种旋转基础上，就可对平衡二叉树进行插入和删除操作，具体如下：  
（1）插入操作：插入完成后需要从插入的结点开始维护一个到根结点的路径，每经过一个结点都要维持树的平衡，需要根据高度差的特点采取不同的旋转策略进行调整，使整棵树恢复成为平衡树。  
（2）删除操作：首先定位要删除的结点，删除完成后，要从删除结点的父亲开始向上维护树的平衡一直到根结点，然后采取不同的旋转策略调整，使整棵树恢复成为平衡树。"
平衡树,概念,['第九章  树的基本理论与算法'],"{'实体类型': '概念', '相关算法': '典型特殊树模型及其基本算法'}",,1,"树是大家非常熟悉的一类植物。通过对树的观察，不难发现自然界中的树总是有根、枝和叶，且具有这样一些特点：从根上可以长出枝来，从树杈上可以长出枝或叶，叶梢不长在一起，根、枝、叶之间总是畅通的，但它们之间不能构成圈。从结构上看，树是所有连通无向图中边数最少的图模型，同时也是所有无环无向图中边数最多的图模型。我们不得不惊叹大自然的神奇，竟然创造出如此高效而又和谐的离散结构。对自然界中树的这种特殊离散结构进行抽象，就可得到一种特殊的图模型，即树模型。在所有的图模型中，树模型是一种最简洁的连通无环结构，其中各结点之间有着最直接、最必要的联结关系。这种最简洁的连通结构决定了树在图模型知识体系中占有特别重要的地位。目前，树作为一种特殊图模型已被广泛应用于计算机各个领域，例如操作系统采用树结构来组织文件数据，编译程序采用树表示源程序的语法结构，在数据库系统中树被用来组织信息等等。  
本章主要介绍树模型基本理论及其算法设计的基本知识，首先介绍树模型的基本概念与性质、生成树与最小生成树等关于树模型的基本理论，然后具体讨论根树的概念与算法，包括树的递归遍历算法、森林与树的转换算法、最优树的构造与编码算法等，并在此基础上进一步学习若干典型特殊树模型及其基本算法，包括平衡树、红黑树、$B$树等，最后给出树模型的若干应用实例，包括决策树、博弈树等。"
平衡树模型,模型,"['第九章  树的基本理论与算法', '§ 9.3 特殊根数与算法']","{'实体类型': '模型', '特点': '特殊根树模型之一'}",,2,根树是一类非常重要的树模型，能够对很多复杂的数据信息进行表示和处理，广泛应用于程序设计、数据结构、算法设计与分析、操作系统等多门后续课程。根树的种类很多，可以针对不同类型的问题或数据建立相应类型的根树模型。本节着重介绍三种最为典型的特殊根树模型，即平衡树模型、红黑树模型和𝐵树模型，并分析和讨论这些模型的插入、删除、更改、旋转等基本算法，旨在为后续相关专业课程的学习打下良好的基础。
平面图,概念,"['第十章  特殊图模型与算法', '10.3.3 着色问题与算法', '§ 10.2 二分图与匹配问题', '二、平面图的着色问题', '10.3.1  平面图的概念与性质']","{'实体类型': '概念', '应用': ['解决图的着色与并行流程的设计问题', '在印刷电路板的设计、城市管网设计与规划等多个领域得到实际应用'], '相关理论': '平面图的相关理论', '定义': ['可以将该图嵌入到某个平面上，所有边除在结点处之外均不交叉的图', '可以在平面上绘制且边不相交的图'], '特点': '具有结点、边和面的概念，面的边界由边构成', 'name': '平面图'}",,1,"如前所述，图模型及其理论是数学家欧拉为解决哥尼斯堡七桥遍历问题而创立。事实上，图模型作为一种由结点和边组成的离散结构是一种非常强大的离散建模工具，除了能够解决哥尼斯堡七桥遍历问题之外，还可解决很多其它实际问题。例如，旅游的路径规划问题、资源分配与匹配问题、图的着色与并行流程的设计问题、最小费用流问题等等。针对不同的问题，通常需要设计出特定的图模型进行建模与求解。例如，解决哥尼斯堡七桥遍历问题需要使用欧拉图及相关理论、解决旅游的路径规划问题需要哈密顿图及相关理论、解决资源分配与匹配问题需要二分图及相关理论、解决图的着色与并行流程的设计问题需要平面图的相关理论、解决最小费用流问题需要网络流图的相关理论等等。由此产生很多种具有特殊结构和性质的图模型，每种特殊图模型都能针对性地有效地解决某一类或某几类特定问题。因此，要想高效合理地使用图模型实现对实际问题的建模与求解，除了掌握前述图模型的一般理论及算法之外，还需要进一步掌握多种特殊图模型的相关理论及算法。  
本章介绍几种重要的特殊图模型及相关算法，包括欧拉图模型的基本理论及边的遍历算法、哈密顿图的基本理论及结点的近似遍历算法、二分图模型的基本理论及匈牙利匹配构造算法、平面图的基本理论及着色算法、网络流图的基本理论及最大流算法，并结合具体实例分析和讨论这些特殊图模型的应用方法。"
平面图的对偶图,概念,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.3.2 平面图的对偶图']","{'实体类型': '概念', '定义': '将平面图的结点和面进行对换得到的新图模型', '性质': ['连通平面图的对偶图也是连通平面图', '若边是原图的环，则对应边为对偶图的桥，反之亦然', '若原图的面在边界上有两条以上公共边，则对偶图中关联的边有平行边', '同构图的对偶图不一定同构'], '定理': '若连通平面图的对偶图为G*，则G*的结点数等于原图的面数，边数相等，面数等于原图的结点数，且对偶图结点的度与原图对应面的度相等'}",,3,"我们知道，任何一个给定的平面图都具有结点、边和面这三个基本要素。如果将其中结点和面的概念进行对换，具体地说，就是将平面图中现有的所有结点分别变换成面，将现有的所有面分别变换成结点，则可以得到一个新的图模型。可以证明，这种新的图模型与现有平面图之间在很多方面具有相同的运算性质，彼此形成一种相互对偶的关系，故称之为平面图的对偶图。本节主要讨论对偶图的概念与性质，首先给出对偶图的定义：  
【定义10.10】设$G=\langle V,E\rangle$是任意给定的一个连通平面图，并且图中具有$n$个面，则对$G=\langle V,E\rangle$实施下列步骤所得到的图$G^{*}=\langle V^{*},E^{*}\rangle$称为$G$的对偶图：  
（1）在$G$的每个面$r_{i}$中设置$G^{*}$的一个结点${v_{i}}^{*}(1\leq i\leq n)$ ；  
（2）若$G$的面$r_{i}$和$r_{j}$有公共边界，那么经过界的每条边$\boldsymbol{\mathscr{e}}_{k}$分别作关联${v_{i}}^{*}$与${v_{j}}^{*}$的一条边${e}_{k}^{\ast}$且${e}_{k}^{*}$与$G^{*}$的其它边不相交$(1\leq i,j\leq n)$；  
（3）当$e_{k}$为面${r}_{i}$的边界但不是$r_{i}$与其它面的公共边界时，作${v_{i}}^{*}$的一条环与$e_{k}$相交，且不与$G^{*}$中其它边相交。  
![](images/fafbaa2a39700aee1a0d05561e456a1d09b8cc93cd865dffe10e0cd70d34d343.jpg)  
通过例题10.14，不难看出连通平面图$G$的对偶图为$G^{*}$，具有以下基本性质：  
（1）连通平面图$G$的对偶图$G^{*}$也是一个连通平面图。  
（2）若边$e$是$G$的环，则其对应边$e^{*}$为$G^{*}$的桥，若边$e$是$G$的桥，则去对应边$e^{*}$为$G^{*}$的环。  
（3）若$G$的面$r_{i}$与$r_{j}$在边界上至少有两条公共边，则关联${v_{i}}^{*}$与${v_{j}}^{*}$的边有平行边。  
（4）同构图的对偶图不一定同构，图的不同平面表示可能得到不同的对偶图。 下面的定理10.18 给出了连通平面图$G$的对偶图为$G^{*}$之间的数量关系：  
【定理10.18】若连通平面图$G$的对偶图为$G^{*}$，则有如下结论：  
（1）$G^{*}$结点数等于$G$的面数； $G^{*}$边数等于$G$的边数； $G^{*}$面数等于$G$的结点数。 （2）设$G^{*}$的结点${v_{i}}^{*}$位于$G$的面${r_{i}}$内部，则结点${v_{i}}^{*}$的度与面${r}_{i}$的度相等，即有：  
$$
\deg({v_{i}}^{*})=\deg({r_{i}})
$$"
并图,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.2.1 图的基本运算', '一、图的集合运算']","{'实体类型': '概念', '定义': '两个图模型的顶点集合和边集合的并集组成的图', '特点': '当两个图不存在公共边时，称为不重并'}",,4,"图模型作为一种特殊的集合具有并、交、差、补、环和等集合运算，下面分别介绍这些集合运算及其相关性质。 首先给出两个图不交、不重的定义：  
【定义8.10】假设 $G_{1}=\langle V_{1},E_{1}\rangle$和 $G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，则有：  
（1）如果 $V_{1}\cap V_{2}=\varnothing$，则称 $G_{1}$ 与 $G_{2}$ 是不交的；  
（2）如果 $E_{1}\cap E_{2}=\varnothing$ ，则称 $G_{1}$ 与 $G_{2}$ 是边不交的，或者说是不重的。  
显然，对于任意两个不交的图它们必然是不重的，反之不然。  
下面给出图模型基本集合运算的定义：  
【定义 8.11 】假设   $G_{1}=\langle V_{1},E_{1}\rangle$ 和   $G_{2}=\langle V_{2},E_{2}\rangle$ 分别为不含孤立结点的图模型（它们 同为无向图或者同为有向图）。  
（1）令图 $G_{1}\cup G_{2}=\left\langle V,E\right\rangle$，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的并图，其中：$V=V_{1}\cup V_{2},\;\;E=E_{1}\cup E_{2}$  
当 $G_{1}$ 与 $G_{2}$ 不存在公共的边时，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$  的不重并。  
（2）设图 $G_{1}\cap G_{2}=\langle V,E\rangle$，称 $G_{1}\cap G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的交图，其中：$V=V_{1}\cap V_{2},\,\,\,E=E_{1}\cap E_{2}$  
$G_{1}\cap G_{2}$是由 $G_{1},G_{2}$ 中所有公共的边组成的图。  
（3）设图 $G_{1}-G_{2}=\langle V,E\rangle$，称 $G_{1}-G_{2}$ 为 $G_{1}$ 减 $G_{2}$ 的差图，其中：
$$
V=V_{1},\,\,\,E=E_{1}-E_{2}
$$  
$G_{1}-G_{2}$ 是在图 $G_{1}$ 中减去属于 $G_{2}$ 的边后所剩余的部分组成的图。  
（4）环和图 $G_{1}\oplus G_{2}$ 是由 $G_{1}$ 与 $G_{2}$ 的并图减去 $G_{1}$ 与 $G_{2}$ 的交图后得到的图。
$$
G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})
$$  
从上述定义可以看出，图模型的并、交、差、环和等集合运算其实就是普通集合运算的延伸。 需要注意的是：  
（1）若   $G_{1}=G_{2}$   ，则 $G_{1}\cup G_{2}=G_{1}\cap G_{2}=G_{1}(G_{2}),~~~~~G_{1}-G_{2}=G_{2}-G_{1}=\varnothing\,。$  
（2）$G_{1}$ 与 $G_{2}$ 不重时，$G_{1}\cap G_{2}=\varnothing$，$G_{1}-G_{2}=G_{1}$，  $G_2-G_1=G_2, G_1\oplus G_2=G_1\cup $$G_{2}$。  
（3）两个图的环和可用并、差、交给出，$G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})\,.$"
广度优先搜索,算法,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.4.2  广度优先搜索']","{'实体类型': '算法', '定义': '一种以广度思维进行横向搜索的图遍历算法', '特点': '依次遍历每个遍历点的未被访问的邻接点，直到所有顶点都被访问', '步骤': '确定出发点，访问并标记，依次遍历邻接点，重复直到所有顶点被访问', '应用': '用于连通图和非连通图的遍历', '结果': '生成广度优先搜索序列和广度优先生成树或生成森林'}",,3,"广度优先搜索不同于深度优先搜索一层层地在每个遍历点处向下递归搜索的纵向搜索，而是以一种广度的思维进行横向搜索。对于一个给定的连通图$G=(V,E)$，同样地，需要先确定一个出发点，访问并将其标记为已访问之后，依次遍历其所有未被访问的邻接点 $v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$，访问之后同样进行标记，然后分别从结点$v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$开始依次遍历每个点的未被访问的点，依次类推，直到图中所有顶点都被访问为止。这个过程称为广度优先搜索，简称𝑩𝑭𝑺。  
同样地，对广度优先搜索算法进行整理并拓广为非连通图的情况下的算法如下：  
（1）首先确定一个出发点$v_{i}$，访问并将其标记为已访问。  
（2）依次访问$v_{i}$ 的每个尚未访问的邻接点$v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$  
（3）分别将这些邻接点$v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$作为遍历点，依次访问每个遍历点的尚未访问的邻接点并标记为已访问，同时要记录每个邻接点被访问的顺序，在访问完所有邻接点之后应该按照这个顺序，将这些邻接点$v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$分别作为当前遍历点进行广度优先搜索），依次类推，直到所有结点都被访问完为止。  
（4）若此时还有顶点未被访问，则继续选一个未被访问的顶点作为起始点，重复上述过程，直至所有顶点均被访问过为止  
在对图进行广度优先遍历时，按照结点的先后的被访问次序所组成的序列，称为广度优先搜索序列，简称𝑩𝑭𝑺序列。对于一个连通图，由广度优先搜索算法进行遍历得到的结点次序（𝐵𝐹𝑆序列），以及相应结点之间的边所构成的图称为广度优先生成树。对于一个非连通图，由广度优先搜索算法进行遍历得到的结点次序（𝐵𝐹𝑆序列），以及相应结点之间的边所构成的图称为广度优先生成森林。"
广度优先遍历算法,算法,"['第九章  树的基本理论与算法', '§ 9.1 无向树的基本知识', '9.1.2 无向图的生成树']","{'实体类型': '算法', '特点': '无需判断回路，具有较高的计算效率', '应用': '通过广度优先遍历构造生成树'}",,3,"如前所述，树模型是大自然赐予的一种最简洁最高效的连通无向图，任意两个结点之间有且仅有一条路径联结。因此，在对一般连通无向图进行化简的时候，经常会删除图的一些边将其转化为树结构的生成子图。这种生成子图称为无向图的生成树，其定义如下：  
【定义9.2】假设$G=\langle V,E\rangle$是任意给定的一个无向图模型，若$G$的某个生成子图是树，则称该树为$G$的一个生成树，记为$T_{G}$。生成树$T_{G}$中的每条边均称为树枝；$G$中不在$T_{G}$中的每条边均称为弦；$T_{G}$的所有弦的集合称为生成树的补。  
例如，对于图9-3(a)所示的图$G_{1}$无向图，$G_{2}$和$G_{3}$为该图的两棵不同构的生成树。对于图9-3(b)所示生成树$G_{2}$，边$\mathtt{e}_{2},\mathtt{e}_{3},\mathtt{e}_{4},\mathtt{e}_{5}$ 是其树枝，而$\mathsf{e}_{1},\,\mathsf{e}_{6}$ 是其弦；对于图9-3(c)所示的生成树$G_{3}$，$\mathsf{e}_{1},\mathsf{e}_{2},\mathsf{e}_{4},\mathsf{e}_{5}$ 是其树枝，而$\mathsf{e}_{3},\,\mathsf{e}_{6}$ 是其弦。  
![图9-3 连通无向图及其生成树  ](images/3447e9802eaf794918ba03e412f68817eae23f2621102647ed094020348d10e0.jpg)  
显然，对于一个无向连通图$G$，如果$G$本身就是树，则其生成树就是它自己，因而是唯一的。但是，如果$G$不是树，则其生成树就不是唯一的。下面的定理9.3 保证了无向连通图模型生成树的存在性，为无向连通图的化简提供了坚实的基础：  
【定理9.3】假设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$存在其生成树$T_{G}=\langle V_{T}\,,\,\,\,E_{T}\rangle$的充分必要条件是$G$是连通的。  
事实上，上述定理证明过程给出了构造生成树的一种具体算法，通常称之为破圈法。该算法的关键是判断图$G$中是否有回路。若有回路，则删除回路中的一条边，直到图中无回路为止。假设图$G$中有${n}$个结点和$m$条边，则由生成树结点与边的关系知，要构造该图的生成树，必需删除$m-n+1$条边。  
此外，由于含$_n$个结点和$m$条边无向连通图$G=(n,m)$一定存在生成树，且生成树中必有$n$个顶点，$n-1$条树枝和$m-n+1$条弦。因此，在$G$中选择不构成任何回路的$n-1$条边就一定可以得到$G$的一个生成树。这种构造生成树的方法，通常称为避圈法。  
![图9-4 构造生成树的破圈法与避圈法  ](images/6583966484122e279921cd749c7234aa541872b9fc25864834c494c7d9d17e62.jpg)  
破圈法和避圈法需要找出回路或验证不存在回路，计算量通常较大。由于在对一般连通无向图进行广度遍历搜索的时候，会自然形成一个无回路的连通生成子图，即该图生成树。因此，可以通过广度优先遍历算法构造生成树。该算法无需判断回路，因而具有较高的计算效率，比较适合计算机处理。对于连通图$G=\langle V,E\rangle$，该算法的具体过程如下：  
（1）任选$s\in V$，将$s$标记为0，令$L=\{s\},\;V=V-\{s\},k=0$；  
（2）如果$v=\varnothing$，则转（4），否则令$\cdot k=k+1$；  
（3）依次对$L$中的所有标记为$k-1$的结点$v$，如果它与𝑉中的结点𝑤相连接，则将𝑤标记为$k$，指定$v$为$w$的前驱，令$L=L\cup\{w\}$，转（2）；  
（4）$E_{G}=\big\{(v,w)\big|w\in L-\{s\},v\big\}$𝑤的前驱}结束。"
序偶,概念,"['第五章 关系模型与理论', '5.1.1  序偶与笛卡尔积', '§ 5.1 关系的数学模型']","{'实体类型': '概念', '作用': '将两个集合组合成一个高维空间', '定义': '来自相同集合或不同集合的两个元素绑定在一起的整体，有序偶和无序偶之分', '特点': '有序偶中元素具有确定次序，两个元素构成的序偶不相等', '应用': '用于表示具有某种确定联系的两个元素', 'name': '序偶'}",,2,从数学角度看，有些关系比较容易用数学符号表达。例如，自然数集合上自然数的大小比较关系，可用符号≤进行表示。但在很多时候，问题并没有这么简单，例如要表示某班每个学生与其籍贯之间的关系，这就涉及到该班学生集合与地域集合这两个集合元素之间的一种对应关系。此时，要想用数学符号表示这种对应关系，就需要一些巧妙的设计。事实上，可分别将学生集合和地域集合看成是两个在不同维度上的一维空间，并将这两个一维空间进行有序组合张成一个二维空间。此时，对于学生集合中任意一个给定的学生，将这个学生与其籍贯进行有序绑定后，就形成了这个二维空间中的一个点。所有这样的点构成的集合显然就准确地表示了该班每个学生与其籍贯之间的关系。由此可见，我们其实得到一种刻画两个集合中元素之间关系新方法，即首先将这两个集合组合成一个高维空间，然后用高维空间中点的集合来表示两个集合元素之间的关系。显然，这种新方法比前述用符号≤表示大小关系的传统方法更具普适性。本节着重介绍使用这种新方法构建的关系数学模型，为此首先介绍由两个集合组合成一个高维空间的数学机制，即元素的序偶与集合的笛卡尔积。
序偶相等,定义,"['第五章 关系模型与理论', '§ 5.1 关系的数学模型', '5.1.1  序偶与笛卡尔积']","{'实体类型': '定义', '条件': '两个序偶在对应位置上的元素相等'}",,3,"要用数学方式表达关系模型，首先必须建立有一种有效的数学机制将来自相同集合或不同集合的两个元素绑定在一起，以表明它们之间具体某种特定的关系。为此，下面给出二元组的相关概念来实现这种机制。  
【定义5.1】假设𝐴和$B$是任意给定的两个集合，则对于分别来自这两个集合中的元素$x$和𝑦，可将它们组合成一个整体并称之为二元组。如果这个二元组为无序二元组，则称其为无序偶对，简称为无序偶，通常记为$(x,y)$；如果这个二元组为有序二元组，则称其为有序偶对，简称为序偶，通常记为$\langle x,y\rangle$，并称$\cdot x\in A$为第一元素，$y\in B$为第二元素。  
在关系的数学理论中，通常使用序偶的概念绑定具有某种确定联系的两个元素。事实上序偶的用途非常广泛，日常生活和工作中的很多问题或概念都可用序偶表示。例如，平面上点$A$ 的横坐标是$x$，纵坐标是$y$，可用序偶表示为$\langle x,y\rangle$，$x,y\in R$；合肥是安徽的省会、南京是江苏的省会，可分别用序偶表示为〈合肥, 安徽〉，〈南京, 江苏〉；数学书在桌上、英语书在床上，可分别用序偶表示为〈数学书, 桌上〉，〈英语书,床上〉。  
由序偶的定义容易知道，序偶可以看作是具有两个元素的集合，但序偶中的两个元素是具有确定次序的，如果两个含有两个元素的集合相等，并不意味着这两个集合元素构成的序偶相等，因此即使成立$\{a,b\}=\{b,a\}$，在$a\neq b$的情况下会有：成立$\langle a,b\rangle\neq\langle b,a\rangle$。例如，对于前述的序偶〈合肥, 安徽〉，从集合的角度看，显然有{合肥, 安徽}$\}=$ {安徽,合肥}，但是序偶〈合肥, 安徽〉和〈安徽, 合肥〉显然代表的是两个不同的含义：前者表示合肥是安徽的省会，前者表示安徽是合肥的省会。因此，有：〈合肥, 安徽〉 $\neq$〈安徽,合肥〉。  
下面给出两个序偶相等的具体定义：  
【定义5.2】假设$\langle a,b\rangle$和$\langle c,d\rangle$是任意给定的两个序偶，如果$a=b$，$c=d$，那称这两个序偶相等，记为：$\langle a,b\rangle=\langle c,d\rangle$。  
从上述定义可知，两个序偶相等当且仅当这两个序偶在对应位置上的元素相等。例如，若有$\langle2x-3y,3x+2y\rangle=\langle1,3\rangle$，则有$2x-3y=1$且$3x+2y=3$；反之亦然。  
显然，可将上述序偶及其相等的相关定义自然推广到多个元素的情形。例如，对于任意给定的三个元素$x,y,z$，则可根据如下递归方式定义由这三个元素组成的有序三元组：  
$$
\langle x,y,\mathrm{z}\rangle=\langle\langle x,y\rangle,\mathrm{z}\rangle\tag{5-1}
$$  
从上式可以看出，所谓有序三元组，其实就是序偶的序偶。一般地，可得到如下关于$^{\cdot n}$元有序组的相关定义：  
【定义5.3】由$n$个元素$a_{1}$ ,$a_{2},\dotsc,a_{n}$组成 $n$元有序组由$n-1$元有序组$\langle a_{1}\;\,,a_{2},\dots,a_{n-1}\rangle$和元素$a_{n}$组成的序偶，记作$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$。即：$\langle a_{1}\;\;,a_{2},\ldots,a_{n}\rangle=\langle\langle a_{1}\;\;,a_{2},\ldots,a_{n-1}\rangle,a_{n}\rangle$。  
【定义5.4】假设$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$和$\langle b_{1},b_{2},\dots,b_{n}\rangle$是任意给定的两个$ n$元有序组，如果$a_{i}=$$b_{i}$，$i=1,2,\dots,n$，则称它们相等，记为：$\langle a_{1}\,\ ,a_{2},\ldots,a_{n}\rangle=\langle b_{1},b_{2},\ldots,b_{n}\rangle\,.$。  
【定义5.5】设$A,B$是任意给定的两个集合，用$A$中任意一个元素为第一元素、$B$中任任意一个元素为第二元素构成的所有可能的序偶组成的集合，称为$A$ 与$B$ 的笛卡尔积，亦称为$A$ 与$B$ 的直积，记为$A\times B$。即有：$A\times B=\{\langle x,y\rangle|(x\in A)\land(y\in B)\}$。  
由上述定义可知，集合$A$ 与$B$ 的笛卡尔积运算结果$A\times B$仍是一个集合，并且$A\times B$中的每个元素都是一个序偶，序偶中第一个元素取自集合$A$、第二个元素取自集合$B$。  
假设根据笛卡尔积的定义，不难证明笛卡尔积运算满足如下几条基本性质：  
（1）假设$A$,$B$是任意给定的两个集合，则有：$A\times\emptyset=B\times\emptyset=\emptyset$；  
（2）假设 $A$, $B$ 是任意给定的两个集合，则有 $A\times B=\emptyset$ ，当且仅当 $A=\emptyset$ 或 $B=\emptyset$；  
（3）当$A,B$是有限集合时，有：$|A\times B|=|B\times A|=|A||B|$  
下面定理表明笛卡尔积运算对集合的并运算和交运算均满足分配律：  
【定理5.1】设$A$、$B$、$C$ 是任意集合，则有：  
$A\times(B\cup C)=(A\times B)\cup(A\times C);\quad A\times(B\cap C)=(A\times B)\cap(A\times C);$  
$(A\cup B)\times C=(A\times C)\cup(B\times C);\quad(A\cap B)\times C=(A\cup C)\times(B\times C)\,$。  
【定理5.2】设$A$、${B}、{C}$ 是任意集合且$C\neq\emptyset$，则有：
$$
A\subseteq B\Leftrightarrow(A\times C\subseteq B\times C);\,\,\,A\subseteq B\Leftrightarrow(C\times A\subseteq C\times B)
$$  
【定理5.3】设$A、\ B、C、D$为非空集合，则有：
$$
A\subseteq C\land B\subseteq D\Leftrightarrow A\times B\subseteq C\times D
$$  
【定理5.4】假设集合$\cdot A_{1},A_{2},\cdots,A_{n}$均为有限集合，则有：
$$
|A_{1}\times A_{2}\times\cdots\times A_{n}|=|A_{1}|\times|A_{2}|\times\cdots\times|A_{n}|
$$"
序关系,概念,"['第六章 特殊关系模型', '§ 6.3 偏序关系与元素比较']","{'实体类型': '概念', '定义': '刻画对象之间在某些方面的差异性', '种类': '拟序关系、偏序关系、全序关系和良序关系'}",,2,前面讨论的等价关系和相容关系主要刻画对象之间的在某些方面的无差异性或存在某些共性特征。序关系刻画则是对象之间的在某些方面差异性，通过对集合中元素之间的差异性比较建立一种具有层次性的离散结构。日常生活和工作中常用的序关系有很多种，包括拟序关系、偏序关系、全序关系和良序关系等，其中的偏序关系最为典型也相对复杂，本节着重介绍偏序关系的相关知识。如果掌握了偏序关系的概念和性质，那么对拟序关系、全序关系和良序关系等其它序关系知识的学习问题就可迎刃而解。
库拉托夫斯基定理,定理,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.3.1  平面图的概念与性质']","{'实体类型': '定理', '内容': '一个图是平面图的充分必要条件是它的任何子图都不同胚于$K_5$或$K_{3,3}$'}",,3,"所谓平面图，直观地说就是可以将该图嵌入到某个平面上。如图10-46（a）所示，图模型的边有时不仅在结点处相交，而且还在某些非结点处有交叉，这些非结点处交叉点的边重叠特征显然会导致图模型不能嵌入在同一个平面上。因此，为了将图模型嵌入平面，首先必须适当调整该图中边的走向，以保证任意两条边不会在非结点处有交叉，如图10-46（b）所示。由此得到可平面图和平面图的相关概念。  
【定义10.6】设$G=\langle V,E\rangle$是任意给定的一个图模型，如果该图中有两条边在非结点处有交叉，则称这两条边为该图的交叉边，交叉的具体位置称为交叉点。如果可将图𝐺画在同一个平面上，并且所有边除在结点处之外均不交叉，则称图𝐺可嵌入平面，或称𝐺为可平面图，否则称该图为不可平面图或非平面图。对于可平面图𝐺，将其边不交叉的画法称为𝐺的平面嵌入表示。以平面嵌入方式表示的图可平面图𝐺称为平面图。对于一个平面图𝐺，若对其再加一条边就变成不可平面图，则称𝐺为最大平面图。  
![](images/ad5984e0ab09600028eb4068193d74e75743de0f027a20b4d084511a312873d4.jpg)  
![（a）完全二分图$K_{3,3}$  （b）无法消除交叉  ](images/aa69f9dcec49f0e95a534b493200688a98dae4f4be8a347fbd35c04b8c21413b.jpg)  
例如，对于图10-46（a）所示的图，该图有三对交叉边，即$(v_{1},v_{4})$和$(v_{2},v_{3}),~(v_{1},v_{4})$和$(v_{2},v_{5})$、$(v_{1},v_{5})$和$(v_{2},v_{3})$。由于可将该图表示成图10-46（b）的形式，故该图是一个可平面图。图10-46（b）所示的图就是一个平面图。显然，如果在该平面图上增加一条边，则该图就变成一个不可平面图，故该是一个最大平面图。再如，对于图10-47（a）所示的图模型，无论怎么调整边的走向都不能将其以平面嵌入方式表示，如图10-47（b）所示。故图10-47（a）所示的图模型为不可平面图或非平面图。  
在没有特别要求的情况下，通常将可平面图与平面图不加区分地统称为平面图。与一般图模型显著不同的是，平面图模型除了具有结点和边这两个基本构件之外，还有一般图模型所没有的面的概念，并且由进一步面衍生出边界的概念。因此，平面图是一类非常重要的特殊图模型，无论在理论上还是在应用方面都具有非常重要的价值，在印刷电路板的设计、城市管网设计与规划等多个领域得到实际应用。  
图论之父欧拉对平面图有着比较深刻的研究，发现并论证了平面图的结点、边和面之间的数量关系，提出了著名的欧拉公式。下面给出平面图中面的相关概念：  
【定义10.7】设$G=\langle V,E\rangle$是任意给定的一个平面图，由𝐺中边所包围且内部不包含结点与边的区域，称为$G$的一个面。区域面积有限的面称为有限面，区域面积无限的面称为无限面。对于$G$的任意一个面$R$，包围面$R$的所有边构成的回路称为面𝑅的边界，面𝑅边界中边的个数称为面$R$的次数或度，记为${\bf d e g}(R)$。  
通俗地说，如果把一个平面图画在平面上，然后用小刀沿着图的边将平面切开，那么整个平面就被切成若干块，其中每一块就是图的一个面。或者说，平面图的一个面就是平面中一个以边为界线不能再分割的区域块。例如，对于图10-46（b）所示的平面图，一共有六个面，其中有一个面是无限面，其余五个是有限面。需要注意的是，对于任何一个平面图，该图有且仅有一个无限面。下面的定理10.11 给出了平面图中面数与边数的数量关系：  
【定理10.11】平面图中所有面的次数之和等于边数的两倍。  
下面定理10.12 是著名的欧拉公式，给出了平面图中结点、边和面之间的数量关系：  
【定理10.12】设$G=\langle V,E\rangle$是任意给定的一个连通平面图，若它有$n$个结点、$m$条边、$r$ 个面，则有  
$$
n-m+r=2\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
【定理10.13】如果平面连通图$G$每个面的次数均为$l(l\geq3)$，则有：  
$$
m=l(n-2)/(l-2)
$$  
其中$m$为$G$的边数，$n$为$G$的结点数。  
【定理10.14】设$G$是一个$(n,m)$简单连通平面图，若$m>1$，则有：  
$$
m\leq3n-6\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
由定理10.4 的逆命题不成立，也就是说满足不等式$m\leq3n-6$的简单连通图不一定是平面图。但是对于一个简单连通图，若不满足$m\leq3n-6$，则一定是非平面图。因此，可用定理10.4 的结论证明某个简单连通图不是非平面图。  
【定理10.15】设$G$为一平面连通简单图，其结点数$n\geq4$，边数为$m$，且$G$不以$K_{3}$为其子图，则有$m\leq2n-4$。  
【定义10.8】对于是任意给定的一个图模型$G=\langle V,E\rangle$  
设$e=(u,v)$是$G$的任意一条边，如果在图$G$中删除该边并新增一个结点$w$及两条边$e_{1}=$$(u,w)$、$e_{2}=(w,v)$ ，则称该操作为对图$G$的边切割操作；  
设𝑤是$G$中任意一个度数为2 的结点，且是边${e_{1}=(u,w)}$和$e_{2}=(w,v)$的公共结点，如果在图$G$中删除结点$w$及边$e_{1},\,e_{2}$，并增加边$e=(u,v)$，则称该操作为对图$G$的结点贯通操作；  
对图$G$的边切割操作和结点贯通操作统称为对图$G$的同胚操作。  
显然，边切割操作和结点贯通操作是一对互逆操作。例如，对于图10-48 所示的两个图模型，可通过对边的切割操作将$G_{1}$变成$G_{2}$，也可通过对结点做贯通操作将$G_{2}$变成$G_{1}$。  
![图10-48  图的同胚操作与同胚关系  ](images/17b45e1706460a818a5492fb4df19f0ddd6b072e9cf57afef7db0852f0c58237.jpg)  
下面在同胚操作的基础上，引入如下两个图之间的同胚关系：  
【定义10.9】设$G_{1}=\langle V_{1},E_{1}\rangle$和$G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，如果可用同胚操作将其中一个转化为另外一个，则称$G_{1}$与$G_{2}$具有同胚关系，简称为$G_{1}$与$G_{2}$同胚。  
根据上述同胚的概念，可以得到如下关于平面图判定的库拉托夫斯基定理：  
【定理10.16】（库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是$G$的任何子图都不同胚于$K_{5}$或$K_{3,3}$。  
【定理10.17】(库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是𝐺的任何子图都不能通过边的收缩得到$K_{5}$或$K_{3,3}$。  
![图10-51 彼得森图收缩为$ K_{5}$](images/b6cd48c8bf37519af48b0cc187afdf1adc13d2c5e160a08fe418ce5c94762fd6.jpg)  
库拉托夫斯基定理是一个非常著名定理，通常将$K_{5}$和$K_{3,3}$称为库拉托夫斯基图。可以使用该定理判定一个图是否为平面图。例如，对于图$10{-}51\mathrm{a}$）所示的彼得森图，收缩其边$(v_{i},u_{i})(i=1,2,3,4,5)$，则可得到图$K_{5}$，见图10-51b)。故彼得森图不是平面图。  
值得注意的是，虽然库拉托夫斯基定理给出了平面图判定的充分必要条件，但是目前还没有基于该定理得到一个有效的判定算法。因此，对于一个比较复杂的图模型，要判定其是否为平面图，有时并不是一件容易的事情。"
度序列,定义,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.2.2 图模型的度结构']","{'实体类型': '定义', '内容': '假设 $G=\\\\langle V,E\\\\rangle$ 是任意给定的一个有向图或无向图，图中每个结点的图构成的自然数序列称为 $G$ 的度序列'}",,3,"现在我们考察图模型的结构特征。从结构上看，对于任意给定的一个图模型，只要该图不是零图，总会有一些点与一些边相互联结。从生成子图的概念可以看出，图的结点构成了图模型的骨架或主体结构，因此，我们主要从结点出发考察每个结点所关联的边关联多少条边。为此，对于图中的每个结点，都定义一个数来描述该结点所关联边的个数，这就是结点度的概念，其具体定义如下：  
【定义8.16】假设图 $G=\langle V,E\rangle$是任意给定的一个无向图，对于$G$中任意一个结点 $v$ ，与该结点关联边的条数称为该结点的度数，简称为度，记为 ${\sf d e g}(v)$。图$G$中各个结点度数的最大值称为图$G$的最大度，记为$\Delta(G)$；图$G$中各个结点度数的最小值称为图$G$的最小度，记为$\delta(G)$ $\Delta(\mathrm{G})=\mathrm{max}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\};\,\,\,\delta(\mathrm{G})=\mathrm{min}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\}\,.$  
【定义8.17】设图 $G=\langle V,E\rangle$是任意给定的一个有向图，$v$是$G$中任一结点，则有：  
（1）以该结点为起点的有向边的条数，称为该结点的出度，记为$\deg^{+}(v)$；以该结点为终点的有向边的条数，称为该结点的入度，记为 $\deg^{-}(v)$。  
（2）该结点的出度与入度之和称为该结点的度，记为${\sf d e g}(v)$。 即有：  
$$
\deg(v)=\deg^{+}(v)+\deg^{-}(v)
$$  
（3）图$G$中各个结点出度与入度的最大值分别称为图$G$的最大出度和最大入度，分别记为$\Delta^{+}(\mathsf{G})$和 $\Delta^{-}(\mathsf{G})$；图$G$中各个结点出度与入度的最小值分别称为图$G$的最小出度和最小入度，分别记为$\Delta^{+}(\mathbf{G})$和 $\Delta^{-}(\mathsf{G})$，即有：  
$\Delta^{+}(\mathrm{G})=\operatorname*{max}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\Delta^{-}(\mathrm{G})=\operatorname*{max}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$ $\delta^{+}(\mathrm{G})=\operatorname*{min}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\delta^{-}(\mathrm{G})=\operatorname*{min}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$  
从上述定义可以看出，引入度结点度概念的目的主要是通过对图中每个结点所关联边数进行统计分析来考察图模型的结构特征。  
【定义8.18】对于任意一个给定的有向图或无向图  $G=\langle V,E\rangle$ ，图中度数为1 的结点称为该图的悬挂结点，图中以悬挂结点为端点的边称为该图的悬挂边。如果图$G$中各个结点的度数均相同，则称该图正则图，各结点度均为$\ k$的正则图称为$\pmb{k}$-正则图。  
下面我们考察图的邻接矩阵与图中结点度之间的关系。  
假设 $G=\langle V,E\rangle$是任意给定的一个有向图或无向图，其中$V=\{v_{1},v_{2},\ldots,v_{n}\}$，$E=$$\{e_{1},e_{2},\ldots,e_{m}\}$。 $G$的邻接矩阵为：  
$$
A=(a_{i j})_{n\times n}=\left(\!\!{\begin{array}{c c c c}{a_{11}}&{a_{12}}&{\ldots}&{a_{1n}}\\ {a_{21}}&{a_{22}}&{\ldots}&{a_{2n}}\\ {\vdots}&{\ddots}&{\vdots}\\ {a_{n1}}&{a_{n2}}&{\ldots}&{a_{n n}}\end{array}}\!\!\right)
$$  
则有如下结论：  
（1）如果$G$是无向图，那么邻接矩阵𝐴中第𝑖行元素之和表示结点$v_{i}$的度数，第𝑗列元素之和表示结点$v_{j}$的度数。即有：  
$$
\deg(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};~~~~\deg\bigl(v_{j}\bigr)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（2）若G是有向图，那么邻接矩阵$A$中第𝑖行元素之和表示结点$v_{i}$的出度，第$j$列元素之和表示结点$v_{j}$的入度。简单地说，就是竖入横出。即有：  
$$
\deg^{-}(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};\qquad\deg^{+}\!\left(v_{j}\right)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（3）对于有向图G，注意到：  
$$
\sum_{j=1}^{n}\;\deg^{-}\!\left(v_{j}\right)=\sum_{i=1}^{n}\sum_{j=1}^{n}a_{i j}=\sum_{i=1}^{n}\deg^{+}\!\left(v_{i}\right)
$$  
因此，有向图中所有入度之和等于所有出度之和，这个和其实就是图的边数$m$。因为有向图的每条边均产生且仅产生一个出度和一个入度。  
对于图8-19 所示图模型$G$及如下邻接矩阵$A_{G}$，容易验证，结点度与邻接矩阵之间的数量关系。例如，$A_{G}$中第三行元素之和为3，即$v_{3}$的出度为3。
$$
\begin{gathered}v_{1}\quad v_{2}\quad v_{3}\quad v_{4}\quad v_{5}\\A_{G}=\begin{matrix}v_{1}\\v_{2}\\v_{3}\\v_{4}\end{matrix}\begin{pmatrix}0&1&0&0&0\\0&1&1&0&0\\1&1&0&1&0\\0&0&0&0&0\\0&0&0&0&0\end{pmatrix}\end{gathered}
$$  
关于图中结点度数与边的关系，有如下著名的图论基本定理：  
【定理8.1】（握手定理）假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，则该图中结点度数的总和等于边数的二倍，即有：  
$$
\sum_{v\in V}\deg(v)=2|E|
$$  
【推论8.1】图中度数为奇数的结点个数必为偶数。  
从以上定理及例题可以看出，图模型中结点的度从一种定量的角度反映了图中结点与边之间的制约关系，在一定程度上刻画了图模型的结构特征。为了更加方便地描述图模型中各个结点的度结构信息，下面给出度序列的概念：  
【定义8.19】假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，图中每个结点的图构成的自然数序列称为$G$的度序列。也就是说，若 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，则称序列：  
$$
(\deg(v_{1})\,,\deg(v_{2})\,,\cdots,\deg(v_{n}))
$$  
为图 $G$ 的度数序列，简称为度序列。 此外，对于任意一个给定的自然数序列，如果该序列能够成为某个图的度序列，则称该序列为可图化序列。  
例如，对于图8-22 所示图 $G$ ，其度数序列为 (2,3,3,4)  
![图8-22 图 $G$ ](images/77ba680d9b589e032065b86071c3f75473dc0d06736af0deb36aa2115de43d51.jpg)  
由于图模型的度要满足握手定理等基本约束要求，而且对于不同类型的图，其度序列也会有一些相应的数据特征。因此，并不是任意的自然数序列都可以构成图模型的度序列。对于任意给定的自然数序列，需要通过分析其数据特征来判断其是否为可图化序列。若是可图化序列，则可依据该序列数据来分析其所对应图的结构特征。"
异或,概念,"['第三章  命题演算与推理', '§ 3.1 命题的概念与运算', '3.1.3  命题的常用联结词', '二、合取与析取联结词']","{'实体类型': '概念', '定义': '表示两个命题中只有一个为真的逻辑关系'}",,4,"对于任意两个命题，有时需要构造一个新的复合命题表示这两个命题同时为真的含义，相当于自然语言中“与”或“并且”的意思，由此得到的逻辑运算称为命题的“合取”运算或者“与”运算。该运算及其逻辑联结词的具体定义如下：  
【定义3.3】设 $P$ 、$Q$ 是任意两个命题，复合命题$^{\prime\prime}P$并且 $Q$ ”称为 $P$ 与 $Q$ 的合取式或与运算，记作 $P\land Q$，其中符号$\wedge$称为合取联结词(简称为合取词)。 $P\land Q$的取值为真，当且仅当 $P$ 和$Q$ 同时为真；或者说$P$ ∧𝑄 的取值为假，当且仅当 $P$ 和 $Q$ 至少有一个为假。  
例如，若令$\cdot P$表示“我喜欢唱歌”， $Q$ 表示“我喜欢跳舞”，则合取式 $P\land Q$ 就表示复合命题“我喜欢唱歌并且喜欢跳舞”。  
对于任意两个命题 $P$ 和 $Q$ ，其合取运算 $P\land Q$的真值取值规定如表3-1 第5 列所示。  
有时需要构造一个复合命题表示两个命题中至少有一个为真的含义，相当于自然语言中“可兼或”的意思，由此得到的逻辑运算称为命题的“析取”运算或者“可兼或”运算。所谓可兼或，就是可两者兼得的或。该运算及其逻辑联结词的具体定义如下：  
【定义 3.4 】设   $P、 Q$   是任意给定的两个命题，复合命题 $^{\prime\prime}P$   或 $\textit{Q}\,^{\prime\prime}$ 称为   $P$ 与   $Q$   的析取 式或者可兼或运算，有时简称为或运算，记作 $P\lor Q$ ，其中符号$\vee$称为析取联结词(简称为析取词 ) 。 $P\lor Q$   的取值为真，当且仅当   $P$   和   $Q$   中至少有一个为真；或者说 $P\lor Q$   的取值 为假，当且仅当 $P$ 和 $Q$ 都为假。  
例如，若令 $P$ 表示“我喜欢唱歌”，$Q$ 表示“我喜欢跳舞”，则析取式 $P\lor Q$ 就表示复合命题“我喜欢唱歌或者喜欢跳舞”。  
对于任意两个命题 $P$ 和 $Q$，析取运算 $P\lor Q$ 的真值取值规定如表3-1 第6 列所示。  
在实际的逻辑电路中，通常用高电位表示1 或$T$，用低电位表示0 或$F$，通过逻辑与、或、非等运算，可构造相应的与门、或门、非门，如图所示。后面将具体介绍如何使用这些门电路来构造出一些复杂的逻辑电路。  
图3-2 逻辑电路  
需要注意的是：自然语言中或的含义是有歧义的，对或的理解除了上述可兼或外，有时还可理解成不可兼或，即两者不可兼得的或，有时称之为异或。在逻辑运算中，可兼或与异或之间具有完全不同的含义，我们将在后续相关内容中具体讨论异或逻辑联结词及其逻辑运算。除非特别说明，逻辑演算中或运算含义都默认为可兼或运算，即析取运算。  
在实际应用中，应根据语句的具体内容和上下文相关信息仔细甄别其中“或”表达的是可兼或还是不可兼或。例如，语句“今天晚上我看书或者听音乐”中“或”的含义应理解为可兼或；语句”这节课是数学课或者体育课“中“或”的含义应理解为不可兼或。"
弗洛莱算法,算法,"['§ 10.1 欧拉图与哈密顿图', '10.1.3 中国邮路问题', '10.1.1  欧拉图及其性质', '第十章  特殊图模型与算法']","{'实体类型': '算法', '基本思路': '从图中的任一点出发，随机去掉与此点相连的边，然后在保证不造成图模型不连通的基础上，依次去掉与之相连的边', '步骤': '1) 选择初始结点，设初始通路；2) 选取边并加入路径；3) 重复直到所有边被处理', '功能': '求解欧拉回路'}",,3,"为更好地介绍欧拉图，有必要再回顾一下前述哥尼斯堡七桥问题：哥尼斯堡小镇有一条贯穿全市的小河，河上有两个小岛，由七座桥将这两个小岛及其与河两岸进行互联，如图$10-$1(a)所示。问题是怎样才能不重复、不遗漏地走完七座桥，并回到出发点。  
![图10-1 哥尼斯堡七桥问题 ](images/f92d2bafd1492d4ec26c4c92f27d5040f5974fc8bef369b51ff49b676bd82f86.jpg)  
瑞士著名的数学家欧拉把该问题抽象成如图10-1(b)所示的图模型，其中两岸陆地和小岛分别被抽象成了 A, B, C, D 四个结点， 每个桥分别被抽象成了连接相应结点的无向边。 于是， 哥尼斯堡七桥问题就等价于图10-1(b)中是否存在一条从图中任意结点出发，经过图中所有边一次且仅一次的回路。由此得到如下欧拉图的相关定义：  
【定义10.1】设 $G=\langle V,E\rangle$是任意给定的一个图模型，通过图𝐺中所有边一次且仅一次的通路称为欧拉通路，通过图$G$中所有边一次且仅一的回路称为欧拉回路。如果图𝐺中存在欧拉回路，则称之为欧拉图，如果$G$中存在欧拉通路但不存在欧拉回路，则称之为半欧拉图。 规定平凡图为欧拉图。  
以上定义既适合无向图也适合有向图。从定义可以看出，欧拉通路是经过图中所有边的通路中长度最短的通路；欧拉回路是经过图中所有边的回路中长度最短的回路。如果仅用边来描述，那么欧拉通路和欧拉回路其实都是图中所有边的一个全排列。  
【定理10.1】设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$是欧拉图当且仅当 $G=\langle V,E\rangle$为连通图且所有结点度数均为偶数。  
【  
【推论10.1】设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$是半欧拉图当  
且仅当 $G=\langle V,E\rangle$为连通图且恰有2 个奇度数结点。  
由推论10.1 可知，如果$G$是连通图且刚好有奇度结点，那么在$G$中存在一条欧拉道路，且一定以其中一个奇度结点为始点，以另一个奇度结点为终点。  
下面进一步给出有向欧拉图和半欧拉图的判定定理：  
【定理10.2】设 $G=\langle V,E\rangle$是任意给定的一个有向图模型，则有：$G=\langle V,E\rangle$是欧拉图当且仅当 $G=\langle V,E\rangle$为连通图且所有结点的入度等等于出度；$G=\langle V,E\rangle$是半欧拉图，当且仅当$G=\langle V,E\rangle$连通且仅有一个结点的入度比出度大1，另外一个结点的出度比入度大1，其余结点的入度等于出度。  
对于一个欧拉图或半欧拉图，可以使用弗洛莱算法自动找到其欧拉回路或欧拉通路。该算法的基本思路是首先从图中的任一点出发，随机去掉与此点相连的边，然后在保证以下两个条件的基础上，依次去掉与之相连的边：  
1）如果去掉某边后使得该边的某端点为孤立结点，则将该端点与该边一并去掉。  
2）在去掉某边后，不能造成图模型的不连通。  
当算法停止时，获得的路径$L=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\ldots e_{n}v_{n}(v_{0}=v_{n})$就是图$G=\langle V,E\rangle$的一条欧拉回路。弗洛莱算法的具体步骤如下：  
1) 首先，在结点集𝑉中任选一个结点$v_{0}$为初始结点，并设初始通路为$L_{0}=v_{0}$。 2) 设已选好的简单通路为$\boldsymbol{\cdot}L_{i}=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\ldots e_{i}v_{i}$，按照下列条件从边集合：  
$$
E-\{e_{1},e_{2},e_{3},\ldots,e_{i}\}
$$  
中选取边]${e}_{i+1}$，其中$G_{1}$是从$G$删除边集合$\{e_{1},e_{2},e_{3},\ldots,e_{i}\}.$后得到的图：  
$\bullet$ 结点$v_{i}$是边$\boldsymbol{\cdot}\boldsymbol{e}_{i+1}$的端点。  
$\bullet$ 除非无其他边可以选取，否则删除边$\boldsymbol{\cdot}\boldsymbol{e}_{i+1}$后不改变图$G_{1}$的连通性。  
3）将$e_{i+1}v_{i+1}$加入到$L_{i}$中，形成新路径$\mathopen:L_{i+1}=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\dots e_{i}v_{i}e_{i+1}v_{i+1}$，令$i=i+1$  
4）返回步骤2）重复上述过程，直到 $i=|E|$ 。  
当图模型是一个半欧拉图时候，使用上述弗洛莱算法显然也可得到其欧拉通路，请读者自己思考算法的具体步骤和要点，不再赘述。  
![图10-10 房间布局的设计图     图10-11 图模型与欧拉通路       图10-12 行走路径 ](images/1200dfbb0792a6069379408b8f0f3304dd4b6248c5b1e2f4c4917b8d0bf94d23.jpg)"
弱分图,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.4 有向图的连通性']","{'实体类型': '概念', '定义': '有向图的子图是弱连通的，并且不存在更大的弱连通子图'}",,3,"现在讨论有向图的连通性。与无向图不同的是，有向图中的每条边都具有方向性，结点之间的可达性关系不一定满足对称性。因此，有向图的连通性质比无向图更加复杂，一般要分为强连通、单向连通和弱连通这三种基本情况讨论，其具体定义如下：  
【定义8.30】假设$G=\langle V,E\rangle$任意给定的一个有向图，则有：如果图 $G$中任意两个结点之间都是相互可达的，则称 $G$ 是强连通图；如果图 $G$ 中任意两个结点中至少有一个结点到另一个结点可达，则称 $G$ 是单向连通图，简称为单连通图；对于略去图 $G$ 中各边的方向得到的无向图 $G^{\prime}$，如果 $G^{\prime}$ 是无向连通图，则称 $G$ 是弱连通图，简称为连通图。  
从上述定义可以看出，在没有特别说明的情况下，连通的有向图一般意指为弱连通的有向图。显然，如果一个有向图 $G$ 是强连通的，那么它一定是单连通的，反之不然；如果一个有向图 $G$ 是单向连通图的，那么它一定是弱连通的，反之不然。  
例如，图8-47 所示的三个图模型$G_{1}$, $G_{2}$和$G_{3}$分别是强连通图，单连通图和弱连通图。其中$G_{1}$既是强连通图也是单连通图，$G_{2}$是单连通图也是弱连通图。  
![图8-47 强连通图、单向连通图、弱连通图  ](images/bb31206be85b6681e4bfdebf210d613d4577ab233c09b6ccf50f1f6eb3389294.jpg)  
【定理8.9】（连通性定理）有向图 $G$ 是强连通图的充要条件是存在一条经过图$G$所有结点的回路；有向图 $G$ 是单连通图的充要条件是存在一条经过图𝐺所有结点的通路。  
类似于无向图的连通分支的概念，可分别根据有向图的强连通、单向连通、弱连通概念定义相应的连通分支，得到强分图、单向分图、弱分图的概念，具体定义如下：  
【定义8.31】假设$G=\langle V,E\rangle$任意给定的一个有向图，设 $G^{\prime}$是 $G$ 的一个子图，如果$G^{\prime}$是强连通的（单向连通的、弱连通的），并且对 $\forall G^{\prime\prime}\subseteq G$，若$G^{\prime}\subset G^{\prime\prime}$，则 $G^{\prime\prime}$不是强连通的（单向连通的、弱连通的），则称 $G^{\prime}$ 为 $G$ 的强连通分支（单向连通分支、弱连通分支），简称为强分图（单分图、弱分图）。  
显然，强分图、单分图、弱分图都是 $G$ 的子图，可以用结点集合𝑉的子集导出。显然，强分图是单分图和弱分图，单分图一定是弱分图，但是为了强调它们之间的差异性，一般不再将强分图称为单分图或弱分图，也不再将单分图称为弱分图。  
从上述定义及例题不难看出，可分别通过强分图、单分图、弱分图的概念对有向图中所有结点进行分组。具体地说：  
（1）对于由强连通关系产生的强分图，由于有向图结点之间的强连通关系显然满足自反性、对称性和传递性，因此这种强连通关系是一种等价关系，从而可由此等价关系实现对图中所有结点的划分。显然，每个强分图其实就是一个等价类或者划分块，图中所有的强分图就是构成了所有的划分块。 因此，有向图的任何一个结点属于且仅属于一个强分图。  
（2）对于由弱连通关系产生的弱分图，可类似于无向图的方法进行讨论。事实上，不难看出，弱分图其实就是有向图所导出无向图中的连通分支。因此，所有的弱分图也构成了有向图中所有结点的一种划分，有向图的任何一个结点属于且仅属于一个若分图。  
（3）对于由单向连通关系产生的单分图，不难证明，有向图结点之间的单连通关系满足自反性、对称性，但不满足传递性，因而是一种相容关系。可由此相容关系实现对图中所有结点的最大覆盖。显然，每个强分图其实就是一个最大相容类，图中所有的单分图就是构成了所有的最大相容类。因此，有向图的任何一个结点至少属于一个强分图。  
类似地，可分别通过强分图、单分图、弱分图的概念对有向图中所有边进行分组。 不难发现：对于任何一个给定的有向图，它的每条边至多属于一个其强分图，至少属于一个其单分图，属于且仅属于一个其弱分图。  
例如，对于例题8.30 中的强分图、单分图和弱分图，不难看出它们均满足上述所有关于结点和边分组性质。"
弱流边,概念,"['第十章  特殊图模型与算法', '§ 10.4 网络流图及其优化问题', '10.4.1 流网络与切割']","{'实体类型': '概念', '定义': '既不是零流边也不是饱和边的边'}",,3,"首先介绍流网络模型的相关基本概念及其数据描述。如同每条公路有运输量、每根水管有最大流量限制一样，网络流图的每条边都有容量，或者说每条边都有一定的流量。网络流图其实就是每条边具有附带容量（可理解为权值）的有向图。其具体定义如下：  
【定义10.4.1】设有向图$G=\langle V,E\rangle$，$V$中包含一个源结点𝑠和一个汇结点$t$，且每条边$(u,v)\in E$均有一个非负容量$c(u,v)\geq0$，若$(u,v)\notin E$，则规定其容量$c(u,v)=0$，此时称有向图$G$是一个网络流图，简称为流网络或网络。源结点$s$即起点，汇结点$t$即终点。网络流是定义在网络$G$中关于边的一个实函数，用$f(u,v)$表示有向边$(u,v)\in E$上结点$ u$到结点$v$的网络流。$f(u,v)$表示$u$ 到$v$的净流。  
例如，如果$_{u}$到$v$有6 个单位的实际流，且$v$到$u$有3 个单位的实际流，那么$f(u,v)=$3，$f(v,u)=-3$，互为相反数。净流是实际通过的流量矢量和，可类比合力的概念。  
满足以下三个性质的网络流$f$称之为可行流：  
（1）容量限制：对所有的$(u,v)\in E$，都有$f(u,v)\leq c(u,\textit{}v)$。即一条边的流不能超过它的容量。这也很容易理解，如同自来水管的水流自然不会超过水管本身的容量。  
（2）斜对称：对所有$(u,v)\in E$，都有$f(u,v)=-f(v,u)$。即点$\cdot u$到$v$的净流必须与点𝑣到$u$的净流相反。可以类比物理中矢量概念，如作用力与反作用力，强调的是其方向性。  
（3）流守恒：对所有$u\in V-\{s,t\}$，都有$\textstyle\sum_{v\in V}f(u,v)=0$。即除源结点$𝑠$和汇结点$𝑡$外，其余每个结点的净流之和为0。  
![图10-68 网络及可行流  ](images/bada5974bba3db0db4c82fa8e3076a8834542abfa1641f17fac232a32e6fee29.jpg)  
例如，如图10-68 所示，网络中定义网络流$f(u,v)$是一条可行流。图中每条边所对应的序偶表示该边的容量和流量，第一个数字表示边的容量，第二个数字表示边的流量。  
下面结合图10-68 所示网络实例介绍网络流模型中与边相关的几个概念。可根据边的容量与流的大小关系对网络中的边进行分类：  
（1）满足$f(u,v)=c(u,v)$的边称为饱和边，如边(1,2)、 (2,3)  
（2）满足$f(u,v)<c(u,v)$的边称为非饱和边，如边(2,4)。  
（3）满足 $f(u,v)=0$ 的边称为零流边，如边 (3,4) ；满足 $f(u,v)>0$ 的边称为非零流 边，如边(5,4)。  
（4）既不是零流边也不是饱和边的边，称为弱流边，如边(5,6)  
如果把图10-78 看作是一个公路网，6 个结点分别表示6 座城镇，每条边上的权数表示两城镇间的距离。若现在需要从起点1 将一些物资运送到终点6，应怎样选择路线才能使总运输距离最短。我们知道，这样一类问题称为最短路径问题。类似的，如果把图10-1看作为一个输油管道网，结点1表示为发送点，结点6表示为接收点，其它点表示为中转站，各边的权数表示该段管道的最大运输油量。那么如何安排输油线路才能使从1到6的总运输量最大。这样一类问题就是最大流问题。  
最大流问题是网络优化中的一个典型的问题，简单地说，就是在满足容量约束的前提下将尽可能多的流从源结点流向汇结点。因此，最大流问题就是求流网络$G$中使其流量$f$达到最大的一个可行流，该可行流即为最大流。具体定义如下：  
【定义10.4.2】设有向图$G=\langle V,E\rangle$是任意给定的一个网络流图，若$f$是$G$ 中流量最大的的可行流，则称该可行流$f$是$G$ 的最大流，构构造网络流图$G$ 中最大流的问题，就称为网络流图的最大流问题。  
为了实现对最大流问题的求解，必须对网络流图中的增流空间进行合理的度量，通常使用一种名为残留网络的图模型实现这项工作。残留网络的具体定义如下：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图， $f$为$G$的一个流，对于$G$的任意一条边$(u,v)$，在不超过容量$c(u,v)$条件下，从$u$到$v$可压入的额外流量，称为$(u,v)$的残留容量。由$G$中所有边残留容量构成的带权有向图称为$G$的残留网络，记为$G_{f}=\langle V,E_{f}\rangle$。  
若$c_{f}(u,v)$为残留网络$G_{f}$中边$(u,v)$的残留容量，且边$(u,v)\in E$或边$(v,u)\in E$，则$(u,v)\in$$E_{f}$,$\,c_{f}(u,v)=c(u,v)-f(u,v)\,$。例如，若设$(u,v)$当前流量为(4,3)，此时$c(u,v)=4$，$f(u,v)$）$=3$，则有：$c_{f}(u,v)=1$。  
需要注意的是，残留网络具有这样的性质：假设从$_{.}u$到$v$已经有了3 个单位流量，那么从反方向上看，也就是从$v$ 到$u$ 就有了3 个单位的残留容量，这时$c_{f}(v,u)=3$。换句话说，从$u$ 到$v$ 有3 个单位流量，那么从$v$到$u$ 就有了将这3 个单位流量压回去的能力。因此，残留网络结点之间通常由双向带权边进行联结。例如，对于图10-69（a）所示的一个流网络$G$，图10-69（b）则表示该流网络𝐺的残留网络。  
![图10-69 流网络及其残留网络 ](images/d65d1c72064671125468548ae171a28ede5424f1d36d601972ed76c90131fc8c.jpg)  
对于任意给定的一个网络流图$G=\langle V,E\rangle$，可以通过其残留网络$G_{f}=\langle V,E_{f}\rangle$求得$G$的最大流。基本思路如下：首先，对所有的结点令初始状态时流的值为0，即对于$\forall u,v\in V$，有$f(u,v)=0$。然后，通过迭代方式其残留网络中不断寻找源点𝑠到汇点$t$之间的流量增广路径来增加网络流量值，直到残留网络没有这样的增广路径为止。  
因此，在残留网络$G_{f}=\langle V,E_{f}\rangle$寻找流量增广路径是最大流求解算法的关键。为正确理解该算法，现给出流网络增广路径的具体定义：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，$G_{f}=\langle V,E_{f}\rangle$为$G$在流$f$下的一个残留网络，则$G_{f}=\langle V,E_{f}\rangle$中任意一条从源点$s$到汇点$t$的简单路径$p$称为$G=\langle V,E\rangle$的一条流量增广路径，简称为增广路径。  
事实上，可将增广路径形象地理解为网络流图$G$中从源点𝑠到汇点𝑡的一条不违反流网络边容量限制的路径，并向这条路径压入一定的流量，以增加整个网络的流量值。例如，图10-69（b）所示的残留网络存在这样一条如图10-70 中加粗有向边所示的增广路径。  
![图10-70 增广路径 ](images/1e52dc98ce8f5b49283b093dbb72c0d5308ccdc9782306a98cb168474d58608f.jpg)  
![图10-71 流网络的一个切割](images/c52dd38b6f7d2bc46bb57e2440709d67355577a7b3d5fb2e920f10a5bfeb8598.jpg)  
若将图10-70 所示增广路径在流网络所对应每条边的流量增加4 个单位，得到一个新的流网络，其流量比原网络多4 个单位。然后，在新流网络所对应的残留网络中继续寻找新增广路径，直到找不到新增广路径为止。显然，现在的问题是：如果在残留网络$G_{f}=$$\langle V,E_{f}\rangle$中找不到增广路径，此时该残留网络所对应的流$f$是否就是流网络$G=\langle V,E\rangle$的最大流？要解决这个问题，必须进一步引入流网络切割的相关概念，具体如下：  
【定义10.4.4】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，如果将$G$的结点集合𝑉划分为𝑆和$T=V-S$两部分，使得源点$s\in S$且$t\in T$，则称$(S,T)$是$G=\langle V,E\rangle$的一个切割，简称为割。从集合 𝑆 到集合 𝑇 的所有有向边容量之和称为切割 $(S,T)$ 的容量，穿过切割 $(S,T)$所有边流量的代数和流量称为切割$(S,T)$的净流量，记为$f(S,T)$。  
主要注意的是，定义10.4.4 中边的流量带有正负方向，如果流从结点𝑆流向$T$，则该边的流量值为正，如果流从结点𝑇流向𝑆，则该边的流量值为负。例如，对图10-69（a）所示的流网络，可画一个如图10-71 所示的切割$(S,T)$，其容量为：  
$$
c(u,w)+c(v,x)=12+14=26
$$  
穿过该切割的净流量为：  
$$
f(u,w)+f(v,x)-f(w,v)=12+11-4=19
$$  
显然，对于任意一个切割，穿过该切割的净流量上界就是该切割的容量，即穿过切割的净流量不可能超过割的容量。由于流网络中所有切割的流都相等并且等于网络的流，因此，网络最大流必然无法超过网络的最小割。由此得到如下最大流最小割定理：  
【定理10.4.1】（最大流最小割定理）设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和$t$分别为其源点和汇点，则$G=\langle V,E\rangle$的最大流量等于其最小割切的容量。对于$G=\langle V,E\rangle$上的任意一个流$f$，以下三个结论彼此等价：  
(1) $f$是流网络$G=\langle V,E\rangle$的一个最大流；  
(2) 流网络$G=\langle V,E\rangle$的残留网络中不包括任何增广路径；  
(3) 存在流网络$G=\langle V,E\rangle$的某个切割$(S,T)$，满足：
$$
f(S,T)=c(S,T)
$$"
弱连通图,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.4 有向图的连通性']","{'实体类型': '概念', '定义': '略去有向图中各边的方向得到的无向图是无向连通图的图'}",,3,"现在讨论有向图的连通性。与无向图不同的是，有向图中的每条边都具有方向性，结点之间的可达性关系不一定满足对称性。因此，有向图的连通性质比无向图更加复杂，一般要分为强连通、单向连通和弱连通这三种基本情况讨论，其具体定义如下：  
【定义8.30】假设$G=\langle V,E\rangle$任意给定的一个有向图，则有：如果图 $G$中任意两个结点之间都是相互可达的，则称 $G$ 是强连通图；如果图 $G$ 中任意两个结点中至少有一个结点到另一个结点可达，则称 $G$ 是单向连通图，简称为单连通图；对于略去图 $G$ 中各边的方向得到的无向图 $G^{\prime}$，如果 $G^{\prime}$ 是无向连通图，则称 $G$ 是弱连通图，简称为连通图。  
从上述定义可以看出，在没有特别说明的情况下，连通的有向图一般意指为弱连通的有向图。显然，如果一个有向图 $G$ 是强连通的，那么它一定是单连通的，反之不然；如果一个有向图 $G$ 是单向连通图的，那么它一定是弱连通的，反之不然。  
例如，图8-47 所示的三个图模型$G_{1}$, $G_{2}$和$G_{3}$分别是强连通图，单连通图和弱连通图。其中$G_{1}$既是强连通图也是单连通图，$G_{2}$是单连通图也是弱连通图。  
![图8-47 强连通图、单向连通图、弱连通图  ](images/bb31206be85b6681e4bfdebf210d613d4577ab233c09b6ccf50f1f6eb3389294.jpg)  
【定理8.9】（连通性定理）有向图 $G$ 是强连通图的充要条件是存在一条经过图$G$所有结点的回路；有向图 $G$ 是单连通图的充要条件是存在一条经过图𝐺所有结点的通路。  
类似于无向图的连通分支的概念，可分别根据有向图的强连通、单向连通、弱连通概念定义相应的连通分支，得到强分图、单向分图、弱分图的概念，具体定义如下：  
【定义8.31】假设$G=\langle V,E\rangle$任意给定的一个有向图，设 $G^{\prime}$是 $G$ 的一个子图，如果$G^{\prime}$是强连通的（单向连通的、弱连通的），并且对 $\forall G^{\prime\prime}\subseteq G$，若$G^{\prime}\subset G^{\prime\prime}$，则 $G^{\prime\prime}$不是强连通的（单向连通的、弱连通的），则称 $G^{\prime}$ 为 $G$ 的强连通分支（单向连通分支、弱连通分支），简称为强分图（单分图、弱分图）。  
显然，强分图、单分图、弱分图都是 $G$ 的子图，可以用结点集合𝑉的子集导出。显然，强分图是单分图和弱分图，单分图一定是弱分图，但是为了强调它们之间的差异性，一般不再将强分图称为单分图或弱分图，也不再将单分图称为弱分图。  
从上述定义及例题不难看出，可分别通过强分图、单分图、弱分图的概念对有向图中所有结点进行分组。具体地说：  
（1）对于由强连通关系产生的强分图，由于有向图结点之间的强连通关系显然满足自反性、对称性和传递性，因此这种强连通关系是一种等价关系，从而可由此等价关系实现对图中所有结点的划分。显然，每个强分图其实就是一个等价类或者划分块，图中所有的强分图就是构成了所有的划分块。 因此，有向图的任何一个结点属于且仅属于一个强分图。  
（2）对于由弱连通关系产生的弱分图，可类似于无向图的方法进行讨论。事实上，不难看出，弱分图其实就是有向图所导出无向图中的连通分支。因此，所有的弱分图也构成了有向图中所有结点的一种划分，有向图的任何一个结点属于且仅属于一个若分图。  
（3）对于由单向连通关系产生的单分图，不难证明，有向图结点之间的单连通关系满足自反性、对称性，但不满足传递性，因而是一种相容关系。可由此相容关系实现对图中所有结点的最大覆盖。显然，每个强分图其实就是一个最大相容类，图中所有的单分图就是构成了所有的最大相容类。因此，有向图的任何一个结点至少属于一个强分图。  
类似地，可分别通过强分图、单分图、弱分图的概念对有向图中所有边进行分组。 不难发现：对于任何一个给定的有向图，它的每条边至多属于一个其强分图，至少属于一个其单分图，属于且仅属于一个其弱分图。  
例如，对于例题8.30 中的强分图、单分图和弱分图，不难看出它们均满足上述所有关于结点和边分组性质。"
强分图,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.4 有向图的连通性']","{'实体类型': '概念', '定义': '有向图的子图是强连通的，并且不存在更大的强连通子图'}",,3,"现在讨论有向图的连通性。与无向图不同的是，有向图中的每条边都具有方向性，结点之间的可达性关系不一定满足对称性。因此，有向图的连通性质比无向图更加复杂，一般要分为强连通、单向连通和弱连通这三种基本情况讨论，其具体定义如下：  
【定义8.30】假设$G=\langle V,E\rangle$任意给定的一个有向图，则有：如果图 $G$中任意两个结点之间都是相互可达的，则称 $G$ 是强连通图；如果图 $G$ 中任意两个结点中至少有一个结点到另一个结点可达，则称 $G$ 是单向连通图，简称为单连通图；对于略去图 $G$ 中各边的方向得到的无向图 $G^{\prime}$，如果 $G^{\prime}$ 是无向连通图，则称 $G$ 是弱连通图，简称为连通图。  
从上述定义可以看出，在没有特别说明的情况下，连通的有向图一般意指为弱连通的有向图。显然，如果一个有向图 $G$ 是强连通的，那么它一定是单连通的，反之不然；如果一个有向图 $G$ 是单向连通图的，那么它一定是弱连通的，反之不然。  
例如，图8-47 所示的三个图模型$G_{1}$, $G_{2}$和$G_{3}$分别是强连通图，单连通图和弱连通图。其中$G_{1}$既是强连通图也是单连通图，$G_{2}$是单连通图也是弱连通图。  
![图8-47 强连通图、单向连通图、弱连通图  ](images/bb31206be85b6681e4bfdebf210d613d4577ab233c09b6ccf50f1f6eb3389294.jpg)  
【定理8.9】（连通性定理）有向图 $G$ 是强连通图的充要条件是存在一条经过图$G$所有结点的回路；有向图 $G$ 是单连通图的充要条件是存在一条经过图𝐺所有结点的通路。  
类似于无向图的连通分支的概念，可分别根据有向图的强连通、单向连通、弱连通概念定义相应的连通分支，得到强分图、单向分图、弱分图的概念，具体定义如下：  
【定义8.31】假设$G=\langle V,E\rangle$任意给定的一个有向图，设 $G^{\prime}$是 $G$ 的一个子图，如果$G^{\prime}$是强连通的（单向连通的、弱连通的），并且对 $\forall G^{\prime\prime}\subseteq G$，若$G^{\prime}\subset G^{\prime\prime}$，则 $G^{\prime\prime}$不是强连通的（单向连通的、弱连通的），则称 $G^{\prime}$ 为 $G$ 的强连通分支（单向连通分支、弱连通分支），简称为强分图（单分图、弱分图）。  
显然，强分图、单分图、弱分图都是 $G$ 的子图，可以用结点集合𝑉的子集导出。显然，强分图是单分图和弱分图，单分图一定是弱分图，但是为了强调它们之间的差异性，一般不再将强分图称为单分图或弱分图，也不再将单分图称为弱分图。  
从上述定义及例题不难看出，可分别通过强分图、单分图、弱分图的概念对有向图中所有结点进行分组。具体地说：  
（1）对于由强连通关系产生的强分图，由于有向图结点之间的强连通关系显然满足自反性、对称性和传递性，因此这种强连通关系是一种等价关系，从而可由此等价关系实现对图中所有结点的划分。显然，每个强分图其实就是一个等价类或者划分块，图中所有的强分图就是构成了所有的划分块。 因此，有向图的任何一个结点属于且仅属于一个强分图。  
（2）对于由弱连通关系产生的弱分图，可类似于无向图的方法进行讨论。事实上，不难看出，弱分图其实就是有向图所导出无向图中的连通分支。因此，所有的弱分图也构成了有向图中所有结点的一种划分，有向图的任何一个结点属于且仅属于一个若分图。  
（3）对于由单向连通关系产生的单分图，不难证明，有向图结点之间的单连通关系满足自反性、对称性，但不满足传递性，因而是一种相容关系。可由此相容关系实现对图中所有结点的最大覆盖。显然，每个强分图其实就是一个最大相容类，图中所有的单分图就是构成了所有的最大相容类。因此，有向图的任何一个结点至少属于一个强分图。  
类似地，可分别通过强分图、单分图、弱分图的概念对有向图中所有边进行分组。 不难发现：对于任何一个给定的有向图，它的每条边至多属于一个其强分图，至少属于一个其单分图，属于且仅属于一个其弱分图。  
例如，对于例题8.30 中的强分图、单分图和弱分图，不难看出它们均满足上述所有关于结点和边分组性质。"
强连通图,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.4 有向图的连通性']","{'实体类型': '概念', '定义': '有向图中任意两个结点之间都是相互可达的图'}",,3,"现在讨论有向图的连通性。与无向图不同的是，有向图中的每条边都具有方向性，结点之间的可达性关系不一定满足对称性。因此，有向图的连通性质比无向图更加复杂，一般要分为强连通、单向连通和弱连通这三种基本情况讨论，其具体定义如下：  
【定义8.30】假设$G=\langle V,E\rangle$任意给定的一个有向图，则有：如果图 $G$中任意两个结点之间都是相互可达的，则称 $G$ 是强连通图；如果图 $G$ 中任意两个结点中至少有一个结点到另一个结点可达，则称 $G$ 是单向连通图，简称为单连通图；对于略去图 $G$ 中各边的方向得到的无向图 $G^{\prime}$，如果 $G^{\prime}$ 是无向连通图，则称 $G$ 是弱连通图，简称为连通图。  
从上述定义可以看出，在没有特别说明的情况下，连通的有向图一般意指为弱连通的有向图。显然，如果一个有向图 $G$ 是强连通的，那么它一定是单连通的，反之不然；如果一个有向图 $G$ 是单向连通图的，那么它一定是弱连通的，反之不然。  
例如，图8-47 所示的三个图模型$G_{1}$, $G_{2}$和$G_{3}$分别是强连通图，单连通图和弱连通图。其中$G_{1}$既是强连通图也是单连通图，$G_{2}$是单连通图也是弱连通图。  
![图8-47 强连通图、单向连通图、弱连通图  ](images/bb31206be85b6681e4bfdebf210d613d4577ab233c09b6ccf50f1f6eb3389294.jpg)  
【定理8.9】（连通性定理）有向图 $G$ 是强连通图的充要条件是存在一条经过图$G$所有结点的回路；有向图 $G$ 是单连通图的充要条件是存在一条经过图𝐺所有结点的通路。  
类似于无向图的连通分支的概念，可分别根据有向图的强连通、单向连通、弱连通概念定义相应的连通分支，得到强分图、单向分图、弱分图的概念，具体定义如下：  
【定义8.31】假设$G=\langle V,E\rangle$任意给定的一个有向图，设 $G^{\prime}$是 $G$ 的一个子图，如果$G^{\prime}$是强连通的（单向连通的、弱连通的），并且对 $\forall G^{\prime\prime}\subseteq G$，若$G^{\prime}\subset G^{\prime\prime}$，则 $G^{\prime\prime}$不是强连通的（单向连通的、弱连通的），则称 $G^{\prime}$ 为 $G$ 的强连通分支（单向连通分支、弱连通分支），简称为强分图（单分图、弱分图）。  
显然，强分图、单分图、弱分图都是 $G$ 的子图，可以用结点集合𝑉的子集导出。显然，强分图是单分图和弱分图，单分图一定是弱分图，但是为了强调它们之间的差异性，一般不再将强分图称为单分图或弱分图，也不再将单分图称为弱分图。  
从上述定义及例题不难看出，可分别通过强分图、单分图、弱分图的概念对有向图中所有结点进行分组。具体地说：  
（1）对于由强连通关系产生的强分图，由于有向图结点之间的强连通关系显然满足自反性、对称性和传递性，因此这种强连通关系是一种等价关系，从而可由此等价关系实现对图中所有结点的划分。显然，每个强分图其实就是一个等价类或者划分块，图中所有的强分图就是构成了所有的划分块。 因此，有向图的任何一个结点属于且仅属于一个强分图。  
（2）对于由弱连通关系产生的弱分图，可类似于无向图的方法进行讨论。事实上，不难看出，弱分图其实就是有向图所导出无向图中的连通分支。因此，所有的弱分图也构成了有向图中所有结点的一种划分，有向图的任何一个结点属于且仅属于一个若分图。  
（3）对于由单向连通关系产生的单分图，不难证明，有向图结点之间的单连通关系满足自反性、对称性，但不满足传递性，因而是一种相容关系。可由此相容关系实现对图中所有结点的最大覆盖。显然，每个强分图其实就是一个最大相容类，图中所有的单分图就是构成了所有的最大相容类。因此，有向图的任何一个结点至少属于一个强分图。  
类似地，可分别通过强分图、单分图、弱分图的概念对有向图中所有边进行分组。 不难发现：对于任何一个给定的有向图，它的每条边至多属于一个其强分图，至少属于一个其单分图，属于且仅属于一个其弱分图。  
例如，对于例题8.30 中的强分图、单分图和弱分图，不难看出它们均满足上述所有关于结点和边分组性质。"
归纳法,算法,"['第一章  集合与计数基础', '§ 1.1 集合的基本知识', '1.1.2 集合的概念与表示', '二、集合的表示方法', '3.归纳法']","{'实体类型': '算法', '定义': '一种基于构造策略的表示方法', '构造规则': '基础部分、归纳部分、边界部分', '基础部分': '确定集合中某些最基本的元素', '归纳部分': '确定由集合中已有元素构造出新元素的规则或方法', '边界部分': '确定集合在通过构造元素实现不断扩张的过程中不能超过的界限', '特点': '构造性特点非常适合用计算机进行处理', '应用': '在计算机相关领域得到广泛应用，用于定义概念或设计算法'}",,5,"归纳法是一种基于构造策略的表示方法。该方法通过定义一些规则把集合构造出来，由此实现对集合的表示。具体的构造规则通常由如下三个部分组成：  
（1）基础部分：确定集合中某些最基本的元素；（2）归纳部分：确定由集合中已有元素构造出新元素的规则或方法；（3）边界部分：确定集合在通过构造元素实现不断扩张的过程中不能超过的界限。  
上述基础部分决定了该集合为非空集合并确定了集合的初始元素，归纳部分则根据集合中初始元素通过一定的规则或方法不断构造出新的元素，是集合不断扩张的过程，边界部分则是对集合的扩张进行限制，给出了集合的边界，由此构成一个具有确定边界的集合。  
总之，基础部分和归纳部分确定了集合中至少包含哪些元素，边界部分则是确定了集合中最多包含哪些元素。  
集合归纳表示法的构造性特点非常适合用计算机进行处理，在计算机相关领域得到广泛应用。在后续内容中，我们将会看到，通过用归纳法构造集合的方式来定义一个概念或设计一个算法，在计算机相关领域是一件屡见不鲜的事情。"
循环半群,概念,"['§ 12.1 半群的概念与性质', '12.1.2  方幂与循环半群', '第十二章 典型抽象代数结构']","{'实体类型': '概念', '定义': ['由一个元素生成的半群', '半群G中的任意元素x都能写成某个元素a的方幂形式'], '性质': '存在生成元a，使得x=a^n', '相关定理': '每个循环半群都是可交换半群'}",,2,"与群相关的抽象代数结构有很多个，其共同特征是只含一个二元运算，具体包括广群、半群、含幺半群、群、交换群等。如图12-1 所示，这些抽象代数结构按照由一般到特殊的次序逐步递进。其中：广群是最具一般性，只需满足运算的封闭性即可，其实就是一般的只含一个二元运算的代数结构或代数系统；半群则比广群稍微特殊一些，即在广群的基础上增加一个满足结合律的限制；含幺半群则是在半群的基础上再增加存在单位元的限制；群则是在含幺半群的基础上再增加存在逆元的限制，即要求半群不仅含有单位元，而且还必须保证载体集合中每个元素都必须含有逆元；交换群则是一种满足交换律的特殊群。  
![](images/c6e03e109e469ca83f4980264e0b87779198ee1bcaf3a206ea39fe5f280b87e9.jpg)
图12-1 与群相关的抽象代数结构  
我们将按照图12-1-1 所示次序展开讨论，其中广群作为最一般的代数结构在前面第十一章已做介绍。因此，本节着重介绍半群的基本理论，主要包括半群、含幺半群、元素方幂、循环半群的基本概念与性质。"
循环群,概念,"['第十二章 典型抽象代数结构', '§ 12.2 群结构的基本知识', '12.2.3 循环群与置换群']","{'实体类型': '概念', '定义': '以某个元素的全部方幂载体集合的群', '特点': '是目前研究最彻底的一种群', '应用': '在信息压缩与编码、形式语言自动机、几何变换与图形算法设计等多个领域具有重要的实用价值', '定理': ['任意给定的循环群一定是交换群', '以a为生成元的循环群，若无限群则与整数加法群同构，若有限群则与n阶剩余类加群同构']}",,3,"本节主要介绍两种重要的特殊群结构，即循环群和置换群。循环群是以某个元素的全部方幂载体集合的群，是目前研究最彻底的一种群。基于普通加法的整数加群$\langle Z,+\rangle$和基于模加运算的剩余类加群$\langle\underline{{n}},+_{n}\rangle$都是循环群。事实上，从同构角度看，循环群也只有$\langle Z,+\rangle$。和$\langle\underline{{n}},+_{n}\rangle$这两种不同的群。置换群则是有限集上置换函数集合与函数复合运算构成的群，是以置换函数及其运算为研究对象的群。置换群的重要性主要在于任何一个有限群都与一个置换群同构，换句话说，从同构的角度看，所有的有限群都是置换群。此外，循环群和置换群的实用性都非常强，是很多理论问题证明和求解的重要工具，在信息压缩与编码、形式语言自动机、几何变换与图形算法设计等多个领域具有重要的实用价值。  
一、循环群  
前面我们已经学过循环半群和循环含幺半群，现将其直接推广到群结构，由此得到循环群的概念，具体如下：  
【定义12.13】设$\langle G,*\rangle$是任意给定的群，若存在$a\in G$ 使得  
$$
G=\{a^{k}\big|k\in Z\}=\langle a\rangle
$$  
则称 $\langle G,*\rangle$ 为循环群，记作 $\langle\langle a\rangle_{*}\rangle$ ，并称 $a$ 是 $G$ 的生成元。此时，若 $|a|=n$ ，则称 $\langle\langle a\rangle{,*}\rangle$ 为 ${n}$ 阶 循环群，若$|a|$为无穷大，则称$\langle\langle a\rangle{,*}\rangle$为无限阶循环群。  
【定理12.15】假设$\langle G,*\rangle$是任意给定的一个循环群，则该群一定是交换群。  
【定理12.17】设$\langle G,*\rangle$是以$a$为生成元的循环群，即$G=\langle a\rangle$，则  
（1）若$G$是无限群，则$G$与整数加法群$\langle Z,+\rangle$同构；  
（2）若$G$是无限群是有限群且$|G|=n$，则$G$与$n$阶剩余类加群$\langle n,+_{n}\rangle$同构。  
二、 置换群  
在前面我们已经学习置换函数及其乘法的有关知识，现在从群的角度来考察置换函数及其乘法的运算性质。我们知道，置换函数其实就是有限集合上的的双射函数。为了能够更为一般的概念和性质，现从更为一般的角度考察双射函数，即一般集合上的双射函数及其乘法运算，由此得到如下变换及变换乘法的概念：  
【定义12.14】设$𝐴$是任意给定的一个非空集合，$A$集合上的映射$ f$：$A\rightarrow A$称为$𝐴$的一个变换。若该映射$f$是双射，则称$f$为$𝐴$上的一个一一变换。  
例如$f$：$Z\rightarrow Z$，$f(x)=x$和$g$：$Z\rightarrow Z$，$f(x)=-x$都是𝑍上的一一变换。  
【定义12.15】设$f,g$是𝐴上的变换，$f$和$g$的复合称为$f$与$g$的乘积，记作$f\circ g$  。  
不难证明，$f\circ g$也是$𝐴$上的一个变换。如果$f$和$g$都是$𝐴$上的一一变换，则乘积$f\circ g$也是$𝐴$上的一个一一变换。  
下面的定理12.18 表明：以给定集合上全体一一变换集合为载体、以变换乘法∘为运算构成的二元代数结构是一个群，由此可以从群的角度考察一一变换及其乘法运算性质。  
【定理12.18】假设$𝐴$是任意给定的一个非空集合，$E(A)$是$𝐴$上的全体一一变换构成的集合，则$E(A)$与其上一一变换的乘法运算∘构成的二元代数结构$\langle E(A),\circ\rangle$是一个群。  
【定义12.16】假设$𝐴$是任意给定的一个非空集合，$E(A)$是𝐴上的全体一一变换构成的集合，则$E(A)$与其上一一变换的乘法运算∘构成的群$\langle E(A),\circ\rangle$称为变换群，当$𝐴$是有限集合时，称变换群$\langle E(A),\circ\rangle$为对称群，对称群的任何一个子群称为置换群。  
从上述定义可以看出，变换群的载体集合$ E(A)$可以是有限集合也可以是无限集合，或者说变换群可以是有限群也可以是无限群。对称群则是一种特殊的变换群，要求变换群的载体集合必须是有限集合，因此，对称群一定是有限群。置换群则是变换群的子群，当然对称群作为其自身的平凡子群是一种特殊的置换群，但置换群不一定是对称群。因此，置换群比对称群具有更加广泛的含义，一般主要考察置换群。  
我们知道，对于任意给定的一个有限集合$𝐴$，该集合上的一一变换称为$𝐴$上的置换。当$|A|=n$时称$𝐴$上的置换为${n}$元置换。为了叙述上的方便，常将$A$记作$\{1,2,\cdots,n\}$，这样就可以将$𝐴$上的$n$元置换$p$记作：  
$$
\pi={\binom{a_{1},\ldots a_{n}}{b_{1},\ldots b_{n}}}\,,b_{i}=\sigma(a_{i}),\qquad\qquad\qquad i=1,2,\cdots,n
$$  
易见$.\pi(1)\,\,\,\pi(2)\,\,\,\,\,\cdots\pi(n)$恰恰为${1,\,,2,\cdots,n}$的一个排列。在$𝐴$上的所有置换和$𝐴$的所有排列之间存在着一一对应，$n$元集有$n!$个排列，故有${n}$!个$n$ 元置换。所有这些置换的集合记作$S_{n}$，则$\langle S_{n},\circ\rangle$就是一个对称群。  
具体地说，设$A=\{1,\!2\}$，那么$𝐴$上有两个置换：  
$$
p_1=\binom{1\quad2}{1\quad2},\quad p_2=\binom{1\quad2}{2\quad1}
$$  
当$A=\{1,\!2,\!3\}$时，$A$上有6 个置换：  
$$
\pi_1=\begin{pmatrix}1&2&3\\1&2&3\end{pmatrix},\pi_2=\begin{pmatrix}1&2&3\\2&1&3\end{pmatrix},\pi_3=\begin{pmatrix}1&2&3\\3&2&1\end{pmatrix}
$$  
$$
\pi_1=\begin{pmatrix}1&2&3\\1&3&2\end{pmatrix},\pi_2=\begin{pmatrix}1&2&3\\2&3&1\end{pmatrix},\pi_3=\begin{pmatrix}1&2&3\\3&1&2\end{pmatrix}
$$  
一般地，$A=\{a_{1},a_{2},\dots a_{n}\}$时，$A$上有$n!$个置换。如有$\pi(a_{i})=a_{j_{i}}$时，则$\pi$可表示为：  
$$
\pi={\binom{a_{1},\,\dots\,a_{n}}{a_{j_{1}},\,\dots\,a_{j_{n}}}}
$$  
置换乘法运算或者复合运算通常用∘表示，置换乘法可以像计算两个关系的合成那样进行。需要特别注意的是，置换乘法或复合运算与通常函数的复合运算次序相反。例如：  
$$
\pi_6\circ\pi_4=\begin{pmatrix}1&2&3\\3&1&2\end{pmatrix}\cdot\begin{pmatrix}1&2&3\\1&3&2\end{pmatrix}=\begin{pmatrix}1&2&3\\2&1&3\end{pmatrix}
$$  
即有：$(\pi_{6}\circ\pi_{4})(x)=\pi_{4}(\pi_{6}(x))$  。  
下面考察置换群的几何意义，首先考察三元对称群：  
设$A=\{1,\!2,\!3\}$，则$A$上的6 个置换$S_{3}=\{\pi_{1},\pi_{2},\pi_{3},\pi_{4},\pi_{5},\pi_{6}\}$关于其乘法运算∘构成一个群$\langle S_{3},\circ\rangle$，并称之为三次对称群。其中$\pi_{1}$是恒等置换为群中的单位元，且有：  
$$
{p_{2}}^{-1}=p_{2};~~{p_{3}}^{-1}=p_{3};~~{p_{4}}^{-1}=p_{5};~~{p_{5}}^{-1}=p_{4};~~{p_{6}}^{-1}=p_{6}
$$  
其实，还可以从另一个角度也可得到这个群：用数字1,2,3 标记正三角形的三个顶点，如图12-3 所示。现将三角形以其中心O 为中心轴分别旋转$\sigma_{0},\sigma_{1},\sigma_{2}$（旋转$\cdot0^{\circ},120^{\circ},240^{\circ})$），或分别按直线$l_{1}l_{2}l_{3}$位对称轴进行翻转$(\sigma_{3},\sigma_{4},\sigma_{5})$，则每次旋转或翻转显然都都对应于三角形顶点数字的的一个置换，具体对应关系如下：  
$\sigma_{0}$（旋转$0^{\circ}$）        $p_1=\begin{pmatrix}1&2&3\\1&2&3\end{pmatrix};\quad\sigma_1\bigl(\text{旋转}120^\circ\bigr)\quad p_2=\bigl(\begin{matrix}1&2&3\\2&1&3\end{matrix}\bigr)$  
$\sigma_2\bigl(\text{旋转 240°}\bigr)\quad p_3=\bigl(\begin{matrix}1&2&3\\3&2&1\end{matrix}\bigr);\quad\sigma_3\bigl(\text{绕}l_3\text{翻转}\bigr)$$\quad\quad\quad p_4=\begin{pmatrix}1&2&3\\1&3&2\end{pmatrix}$  
$\sigma_4\big(\text{绕}l_2\text{翻转}\big)\quad p_5=\big(\begin{matrix}1&2&3\\2&3&1\end{matrix}\big);\quad\sigma_5\big(\text{绕}l_1\text{翻转}\big)\quad p_6=(\begin{matrix}1&2&3\\3&1&2\end{matrix})$  
不难看出：$\langle\{\sigma_{0},\sigma_{1},\sigma_{2},\sigma_{3},\sigma_{4},\sigma_{5}\},\circledast\rangle$构成一个群，其中$\circledast$表示旋转或翻转的操作的复合操作，并且与群$\langle\{\pi_{1},\pi_{2},\pi_{3},\pi_{4},\pi_{5},\pi_{6}\},\circ\rangle$同构。  
![](images/e6cbfb18c66c7d99640531f391a63f4a34c10b210258fb0a56bb479a832c31f2.jpg)  
图12-3 三角形的对称轴和对称中心  
![](images/c11de4754b3535d3b87f562740b93b202d5ef5e49fd3a0cb5d9d33538b6831cb.jpg)  
图12-4正方形的对称轴和对称中心  
下面进一步考察四元对称群的几何意义：令$A=\{1,\!2,\!3,\!4\}$，$S_{4}=\{p|p$为A 上的置换}，因此，$\langle S_{4},\circ\rangle$为四元对称群。现用数字1,2,3,4 分别标记正方形的4 个顶点，如图12-4 所示，$\sigma_{0},\sigma_{1},\sigma_{2},\sigma_{3},\sigma_{4},\sigma_{5},\sigma_{6},\sigma_{7}$分别表示正方形以其中心为中心轴进行旋转或按对称轴进行翻转，则它们分别对应与A 上的一个置换，具体如下：  
$ \sigma_0\big(\text{旋转 }0^\circ\big)\quad p_1=\begin{pmatrix}1&2&3&4\\1&2&3&4\end{pmatrix};\quad\sigma_1\big(\text{旋转 }90^\circ\big)\quad p_2=\begin{pmatrix}1&2&3&4\\2&3&4&1\end{pmatrix}$  
$\sigma_2\big(\text{旋转 180°}\big)\quad p_3=\begin{pmatrix}1&2&3&4\\3&4&1&2\end{pmatrix};\quad\sigma_3\big(\text{旋转 270°}\big)\quad p_4=(\begin{matrix}1&2&3&4\\4&1&2&3\end{matrix})$  
$\sigma_4(\text{绕}l_1\text{翻转})\quad p_5=\begin{pmatrix}1&2&3&4\\4&3&2&1\end{pmatrix};\quad\sigma_5(\text{绕}l_2\text{翻转})\quad p_6=(\begin{matrix}1&2&3&4\\1&4&3&2\end{matrix})$  
$\sigma_6(\text{绕}l_3\text{翻转})\quad p_7=\begin{pmatrix}1&2&3&4\\1&4&3&2\end{pmatrix};\quad\sigma_7(\text{绕}l_4\text{翻转})\quad p_8=(\begin{matrix}1&2&3&4\\1&4&3&2\end{matrix})$  
不难看出：$\langle\{\sigma_{0},\sigma_{1},\sigma_{2},\sigma_{3},\sigma_{4},\sigma_{5},\sigma_{6},\sigma_{7}\},\circledast\rangle$构成一个群，其中$\circledast$表示旋转或翻转的操作的复合操作，具体定义如表12-1 所示。  
表12-1 $\circledast$的运算表
![](images/0d658bbe39ea00a7b3a2683e4707c30ed3115f5772998f1ac1c9608422308ecc.jpg)  
由于$\langle\{\sigma_{0},\sigma_{1},\cdots,\sigma_{7}\},\circledast\rangle$与$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$同构，故$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$也是群，它是$\langle S_{4},\circ\rangle$的一个真子群，因为四元对称群$\langle S_{4},\circ\rangle$有24 个置换，而$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$仅有8 个置换。也就是说，群$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$是一个8 阶4 元置换群，但不是4 元对称群。  
【定理12.19】假设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$与某个变换群同构，如果$\langle G,*\rangle$是一个有限群，则$\langle G,*\rangle$与某个置换群同构。  
上述定理12.19 表明，变换群和对称群的重要性在于其作为两种具体的特殊群与一般的抽象群有着非常密切的联系。具体地说，每个群均同构于一个变换群，特别地，每个有限群均同构于一个置换群。因此，从同构的角度看，所有的群都可以看成是变换群，所有的有限群都可以看成是置换群。"
德摩根律,性质,"['第一章  集合与计数基础', '§ 1.1 集合的基本知识', '1.1.3 集合的基本运算', '二、差运算与补运算']","{'实体类型': '性质', '条件': '对于任意给定的两个集合A和B', '结论': 'A∪B=A∩B, A∩B=A∪B'}",,4,"对于任意给定的两个集合$A$ 和$B$，有时需要将属于$A$ 但不属于$B$ 的所有元素取出来构成一个新的集合，由此得到如下集合差运算的概念：  
【定义1.12】对于任意给定的两个集合$A$ 和$B$，集合$\cdot A-B=\{x|x\in A$并且$x\notin B\}$称为$A$ 与$B$ 的差集，$A-B$亦称为集合𝐴与$B$的差运算；令$U$表示全集，则${\bar{A}}=U-A=\{x|x\in$$U$且$x\notin A\}$称为$A$ 的补集，亦称$\bar{A}$为对集合$A$ 的补运算。  
一般来说，所谓两个对象互补，是指这两个对象之间无共同部分并且若将两者合并则构成一个完整的整体。如果将全集𝑈看成是一个完整的整体，那么任何一个集合与它的补集显然构成一种互补关系。图1-3 为集合差运算和补运算的文氏图。  
![](images/3dd3ff26327d44646f11d3b3940708dbd5563cf42578e139e0a56534e35c5eff.jpg)
图1-3 差、补运算的文氏图  
不难看出，集合的差运算和补运算其实就是实数减法运算在集合论中的推广。根据集合差运算与补运算的定义，不难证明它们满足如下基本运算性质：  
(1) 矛盾律：对于任意给定的集合$A$，有：$A\cap{\bar{A}}=\emptyset$；(2) 排中律：对于任意给定的集合$A$，有：$A\cup\bar{A}=U$  
(3) 双重否定律：对于任意给定的集合$A$，有：$\bar{\bar{A}}=A$  
(4) 德摩根律：对于任意给定的两个集合$A$ 和$B$，有： $\overline{{A\cup B}}=\bar{A}\cap\bar{B},\,\,\,\overline{{A\cap B}}=\bar{A}\cup\bar{B}$  
(5) 对于任意给定的三个集合$A$、$B$ 和$C$，有：  
$A\cup(B\cup C)=(A\cup B)\cup C;\;A\cap(B\cap C)=(A\cap B)\cap C\circ$ $A\cap(B\cup C)=(A\cap B)\cup(A\cap C);\;A\cup(B\cap C)=(A\cup B)\cap(A\cup C)\,.$ $A\cap(A\cup B)=A;\,\,\,A\cup(A\cap B)=A\,.$  
现仅以德摩根律为例给出上述运算性质的证明，读者可自行给出其余证明。【例题1.22】对于任意给定的两个集合$A$ 和$B$，证明如下德摩根律：  
$$
{\overline{{A\cup B}}}={\bar{A}}\cap{\overline{{B}}}\,;\;{\overline{{A\cap B}}}={\bar{A}}\cup{\bar{B}}
$$"
总分和,概念,"['第六章 特殊关系模型', '§ 6.3 偏序关系与元素比较', '6.4.2 得分评判问题']","{'实体类型': '概念', '定义': '评判表中各选手得分的总和', '特点': '是一个固定数σ=m(m-1)/2，其中m为参赛选手的人数'}",,3,"在很多需要排名次的非相互对抗场合，如歌手大赛中的参赛选手、成员的考评、电视节目中主持人大赛中参赛选手的考评等，其评断标准并不像球赛中进球、失球那样准确无误，往往由评判员们分别打分，通过分数计算名次。然而，分数有其不公平的一面。例如，甲、乙、丙三名歌手的得分分别为94 分，92 分，90 分。  
甲的分数-乙的分数$=$乙的分数-丙的分数。  
虽然这两个差相等，但并不能说明甲高出乙的水平等于乙高出丙的水平，因为这里1 分所表示的水平差距并不唯一确定，而是与评判者紧密相关。又如，对于期末考试中某班平均分语文85 分与数学60 分，该班某学生语文80 分，数学70 分，尽管$80>70$，也不能说明这名学生语文学的比数学好。因为这里分数基准点是不一致的。因此有了“标准分”和“等级记分”等科学记分方法，如 “优秀，良好，合格，不合格”四级打分法便是其中一种。  
由偏序关系的定义可知，任何排名次必是一个偏序关系，并且在很大情况下应是线性关系。因此，在上述排名场合（如歌手大赛考评等）可使用“0-1”法记分，并利用偏序关系的反对称性，在比赛过程对选手进行动态排名。下面结合具体实例介绍具体排名过程：  
设有 $A_{1},A_{2},A_{3},A_{4},A_{5},A_{6}$ 这 6  名参赛者，按其下标次序出场比赛。分别为每名评判员准 备一张如表$6–4$ 所示的表格用于对选手进行打分评判。  
表6-4 评判表
![](images/4c85af2d68ddc01acb3d234836cc3dd6fee35852bbb1e27a76917d56b5336e04.jpg)  
每个评判员的打分方法如下：当$A_{2}$参赛结束时，立即把他与$A_{1}$比较，谁更好一些，若$A_{2}$好一些，在表6-4 的$\mathsf{C}_{21}$位置填上1，若$A_{1}$好一些，则在该位置填上0；$A_{3}$参赛结束后，依次与$A_{1}$、$A_{2}$比较谁好一些，好一些为1，差一些为0，并把这两个比较出来的数依次填在${\mathsf C}_{31}$和  
${\mathsf{C}}_{32}$的位置上。如此下去，知道所有的选手参赛结束。即有：  
$$
C_{ij}=\begin{cases}1&\quad\text{当}A_i\text{比}A_j\text{好时}\\0&\quad\text{当}A_i\text{比}A_j\text{好时}\end{cases}\quad(j<i)\quad\text{(6-5)}
$$  
注意的是，当某一位选手比赛结束都要与他参赛的每一名选手比较而且给出谁好谁差的结论(是1 还是0)。也可以利用偏序关系的传递性减少比较次数。如$A_{5}$比$A_{1}$强，而此时已经有$\mathsf{C}_{31}=\mathsf{C}_{41}=0$，则必有${\mathsf{C}}_{53}={\mathsf{C}}_{54}=1$。表6-5 是某一位评判员所裁判的结果。  
表6-5   评判结果
![](images/0095a64294f10a0d76e1eae14906fdb5c9f5e6a5bc895b20e56aa4e7f6a6e039.jpg)  
如$|A_{5}$行说明$A_{5}$比$A_{1}$好，比$A_{2}$差，比$A_{3}$好，比$A_{4}$  
然后对表6-5 进行整理：首先利用偏序关系的反对称性填充表格的上角，上表虚线为对称轴，右上角各个位置(如$\mathsf C_{12}$)看它的对称位置(即$\mathsf{C}_{21}$)上的数，若其对称位置上数为$1\left(\mathbb{C}_{21}=1\right)$,则它为$0\left(\mathsf{C}_{12}=0\right)$)；若其对称位置上的数为1，则它就是0。即有：  
$$
\mathrm{C}_{ij}=\begin{cases}0&\quad\text{当C}_{ji}=1\text{时}\\1&\quad\text{当C}_{ji}=0\text{时}\end{cases}\quad(i<j)\quad\text{(6-6)}
$$  
完成后如表6-6 所示：  
表6-6 对评判结果的整理
![](images/620931865382a676e3093ac6d3295347415e7bef2cda108424f0318f6d3c3129.jpg)  
把表6-6 各行的数字加起来填入总分列中（倒数第二列），这个列中各数分别为其所在行中相应选手的得分。它们不可能有两个相等的数，否则说明评判或填表有误应作废。把这个列的各数相加填入这一列最后一格为总分和$σ$。事实上$σ$是一个固定数$σ=m(m-1)/2$其中$m$为参赛选手的人数。本例中$m=6$，故有$σ=6*(6-1)/2=15$。  
把表6-6 中各列数字加起来，填入最后一行（即总分行）的相应位置上，分别为其所在列上相应选手的失分，以虚线为对称轴和其对称位置上的得分加起来应该等于$m-1$，  
减1 是因为自己不与自己比较，总分行总分和也等于$m(m-1)/2$。表的最后一列是把各选手的得分转化为人们习惯的百分制，本例中用的是$(m-1)*$得分数$+60$，以避免出现低于60 分的情况，最后把所有评判员有效给出的各个选手成绩相应加起来求平均成绩，按平均成绩高低排名次，此时可能出现并列名次。"
恒等关系,概念,"['第五章 关系模型与理论', '§ 5.1 关系的数学模型', '5.1.3 关系的表示', '3、矩阵表示法']","{'实体类型': '概念', '定义': '集合上每个元素与自身对应的关系', '特点': '关系图中所有结点都有一个有向环，不同结点之间无任何有向边联结'}",,4,"在使用关系的数学模型对实际问题进行建模的时候，通常需要对关系模型进行一些定量的数值计算以实现对实际问题的求解，此时无论是关系的集合表示方法和关系图法，都不方便实现对关系模型定量的数值计算。为此，我们引入二元关系的矩阵表示法。  
假设$\boldsymbol A=\{a_{1},a_{2},\cdots,a_{n}\}$, $B=\{b_{1},b_{2},\cdots,b_{m}\}$是任意给定的两个非空有限集合，$R$是$A$到$B$的一个二元关系，则按下列方式定义的$m\times n$阶矩阵$M_{R}=(r_{i j})_{m\times n}$称为$R$的关系矩阵：
$$
r_{ij}=\begin{cases}1\text{,若}\langle a_i,b_j\rangle\in R\\0\text{,若}\langle a_i,b_j\rangle\not\in R\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-3)}
$$
其中$A$中元素$a_{i\cdot}$序号对应矩阵元素的行下标，$B$中元素$b_{j}$序号对应矩阵元素的列下标。  
值得注意的是：由关系矩阵的定义可知，关系矩阵的元素有且仅有0 和1 这两种状态，这样的矩阵一般称之为布尔矩阵，主要用于一些逻辑演算，在运算规则上与普通矩阵有一些差异。为满足后续内容学习的需要，在此简要介绍布尔矩阵的若干基本运算，具体包括并运算、交运算、补运算和布尔积运算，其具体定义如下：  
【定义5.9】设$A=\left(a_{i j}\right)$和$B=\left(b_{i j}\right)$是两个$m\times n$布尔矩阵，则$𝐴$和$B$的并矩阵定义为如下$m\times n$布尔矩阵：$A\lor B=C=\left(c_{i j}\right)$，其中：  
$c_{ij}=\begin{cases}1\text{,如果}a_{ij}=1\text{ 或}b_{ij}=1\\0\text{,如果}a_{ij}=0\text{ 且}b_{ij}=0\end{cases}(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-4)}$      （5-4）  
【定义5.10】设$A=\left(a_{i j}\right)$和$B=\left(b_{i j}\right)$是两个$m\times n$布尔矩阵，则$A$和$B$的交矩阵定义为如下一个$m\times n$布尔矩阵：$A\land B=C=\left(c_{i j}\right)$，其中：
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=1\text{ 且}b_{ij}=1\\0\text{,如果}a_{ij}=0\text{ 或}b_{ij}=0\end{cases}(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-5)}
$$
【定义5.11】设$A=\left(a_{i j}\right)$任意给定的一个$m\times n$布尔矩阵，则𝐴的补矩阵定义为如下$m\times$$n$布尔矩阵：$\bar{A}=C=\left(c_{i j}\right)$，其中：
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=0\\0\text{,如果}a_{ij}=1\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-6)}
$$
【定义5.12】设$A=\left(a_{i j}\right)$是$m\times p$矩阵，$B=\left(b_{i j}\right)$是$p\times n$矩阵，则$𝐴$和$B$的布尔积矩阵定义为如下$m\times n$布尔矩阵：$A\odot B=C=\left(c_{i j}\right)$，其中：  
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=0\\0\text{,如果}a_{ij}=1\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-6)}
$$
需要注意的是：两个布尔矩阵可进行布尔或和布尔与运算的前提是这两个矩阵具有相同的行数和列数，可进行布尔积运算的前提是前一个矩阵的列数等于后一个矩阵的行数。  
在学习了二元关系的三个基本表示方法后，下面我们考察空关系、完全关系和恒等关系这三个常用特殊关系的关系矩阵和关系图各有什么特点：  
(1) 空关系$\varnothing$  因为$\emptyset\subseteq A\times B$(或$\emptyset\subseteq A\times A)$)，所以$\varnothing$也是一个从$𝐴$到$B$(或$𝐴$上)的关系，称之为空关系，即无任何元素的关系。空关系的关系图中只有结点，无任何边，且关系矩阵中的元素全是0  
(2) 完全关系（全域关系） $A\times B$或(或$A\times A)$本身也是一个从$𝐴$到$B$(或$𝐴$上)的关系，称之为完全关系，即含有全部序偶的关系。完全关系的关系图中所有结点之间都有有向边互联，关系矩阵中的元素全是1。  
(3) 恒等关系 $I_{A}$  $I_{A}\subseteq A\times A$，则$I_{A}=\{\langle x,x\rangle|x\in A\}$为$A$上的恒等关系。完全关系的关系图中所有结点都有一个有向环，不同结点之间无任何有向边联结。  
![](images/9a95167e68610708edb7fef0f0474b8284d349dcc5f3b662d3280809d00fbf1e.jpg)
图5-6 空关系、全关系与恒等关系  
设$A=\left\{1,\ 2,\ 3\right\}$，则$A$ 上的空关系∅、完全关系$A\times A$及恒等关系$I_{A}$的关系图如图5-6 所示，下面三个布尔矩阵分别是它们的关系矩阵：  
$M_{\emptyset}=\left(\begin{array}{ccc}0&0&0\\0&0&0\\0&0&0\end{array}\right)\quad M_{A\times A}=\left(\begin{array}{ccc}1&1&1\\1&1&1\\1&1&1\end{array}\right)\quad M_{I_A}=\left(\begin{array}{ccc}1&0&0\\0&1&0\\0&0&1\end{array}\right)$"
恒等函数,概念,"['第七章 函数与特殊函数', '§ 7.1 函数的基本概念', '7.1.3 常用特殊函数']","{'实体类型': '概念', '定义': 'A上的恒等函数就是A的恒等关系I_{A}，对\\forall x\\in A，有I_{A}(x)=x'}",,3,"数学中常用的特殊函数有很多，在初等数学和高等数学中都有大量的分析讨论，例如三角函数、指数函数等基本初等函数，不再一一赘述。在此，我们主要介绍在计算机科学应用中经常使用的一些函数，例如恒等函数、常函数、取整函数、布尔函数、自然映射函数等。下面给出这些常用特殊函数的定义。  
【定义7.6】设$𝐴$和$B$是任意给定的两个非空集合：  
（1）设$f\colon A\to B$，若有$c\in B$，对$\forall x\in A$都有$f(x)=c$，则称$f\colon A\to B$是常函数。  
（2）$𝐴$上的恒等函数就是$𝐴$的恒等关系$I_{A}$，对$\forall x\in A$，有$I_{A}(x)=x$。  
（3）对实数 $x$ ， $f(x)$ 取不小于 $ x$ 的最小整数，则称 $f(x)$ 为上取整函数， 记为 $f(x)=\left\lceil x\right\rceil$  
（4）对实数$x$，$f(x)$取不大于$ x$的最大整数，则称$f(x)$为下取整函数，记为$f(x)=\lfloor x\rfloor$  
（5）如果$f(x)$是从集合$𝐴$到$B=\{0,1\}$上的函数，则称$f(x)$为布尔函数。  
（6）设$R$是$𝐴$上的等价关系，$A/R$是$𝐴$在关系$R$上的商集，令$g\colon A\to A/R$，$g(x)=[x]_{R}$则称$g$是从$A$到$A/R$的自然映射。"
悬挂结点,定义,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.2.2 图模型的度结构']","{'实体类型': '定义', '内容': '对于任意一个给定的有向图或无向图 $G=\\\\langle V,E\\\\rangle$ ，图中度数为1 的结点称为该图的悬挂结点，图中以悬挂结点为端点的边称为该图的悬挂边'}",,3,"现在我们考察图模型的结构特征。从结构上看，对于任意给定的一个图模型，只要该图不是零图，总会有一些点与一些边相互联结。从生成子图的概念可以看出，图的结点构成了图模型的骨架或主体结构，因此，我们主要从结点出发考察每个结点所关联的边关联多少条边。为此，对于图中的每个结点，都定义一个数来描述该结点所关联边的个数，这就是结点度的概念，其具体定义如下：  
【定义8.16】假设图 $G=\langle V,E\rangle$是任意给定的一个无向图，对于$G$中任意一个结点 $v$ ，与该结点关联边的条数称为该结点的度数，简称为度，记为 ${\sf d e g}(v)$。图$G$中各个结点度数的最大值称为图$G$的最大度，记为$\Delta(G)$；图$G$中各个结点度数的最小值称为图$G$的最小度，记为$\delta(G)$ $\Delta(\mathrm{G})=\mathrm{max}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\};\,\,\,\delta(\mathrm{G})=\mathrm{min}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\}\,.$  
【定义8.17】设图 $G=\langle V,E\rangle$是任意给定的一个有向图，$v$是$G$中任一结点，则有：  
（1）以该结点为起点的有向边的条数，称为该结点的出度，记为$\deg^{+}(v)$；以该结点为终点的有向边的条数，称为该结点的入度，记为 $\deg^{-}(v)$。  
（2）该结点的出度与入度之和称为该结点的度，记为${\sf d e g}(v)$。 即有：  
$$
\deg(v)=\deg^{+}(v)+\deg^{-}(v)
$$  
（3）图$G$中各个结点出度与入度的最大值分别称为图$G$的最大出度和最大入度，分别记为$\Delta^{+}(\mathsf{G})$和 $\Delta^{-}(\mathsf{G})$；图$G$中各个结点出度与入度的最小值分别称为图$G$的最小出度和最小入度，分别记为$\Delta^{+}(\mathbf{G})$和 $\Delta^{-}(\mathsf{G})$，即有：  
$\Delta^{+}(\mathrm{G})=\operatorname*{max}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\Delta^{-}(\mathrm{G})=\operatorname*{max}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$ $\delta^{+}(\mathrm{G})=\operatorname*{min}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\delta^{-}(\mathrm{G})=\operatorname*{min}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$  
从上述定义可以看出，引入度结点度概念的目的主要是通过对图中每个结点所关联边数进行统计分析来考察图模型的结构特征。  
【定义8.18】对于任意一个给定的有向图或无向图  $G=\langle V,E\rangle$ ，图中度数为1 的结点称为该图的悬挂结点，图中以悬挂结点为端点的边称为该图的悬挂边。如果图$G$中各个结点的度数均相同，则称该图正则图，各结点度均为$\ k$的正则图称为$\pmb{k}$-正则图。  
下面我们考察图的邻接矩阵与图中结点度之间的关系。  
假设 $G=\langle V,E\rangle$是任意给定的一个有向图或无向图，其中$V=\{v_{1},v_{2},\ldots,v_{n}\}$，$E=$$\{e_{1},e_{2},\ldots,e_{m}\}$。 $G$的邻接矩阵为：  
$$
A=(a_{i j})_{n\times n}=\left(\!\!{\begin{array}{c c c c}{a_{11}}&{a_{12}}&{\ldots}&{a_{1n}}\\ {a_{21}}&{a_{22}}&{\ldots}&{a_{2n}}\\ {\vdots}&{\ddots}&{\vdots}\\ {a_{n1}}&{a_{n2}}&{\ldots}&{a_{n n}}\end{array}}\!\!\right)
$$  
则有如下结论：  
（1）如果$G$是无向图，那么邻接矩阵𝐴中第𝑖行元素之和表示结点$v_{i}$的度数，第𝑗列元素之和表示结点$v_{j}$的度数。即有：  
$$
\deg(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};~~~~\deg\bigl(v_{j}\bigr)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（2）若G是有向图，那么邻接矩阵$A$中第𝑖行元素之和表示结点$v_{i}$的出度，第$j$列元素之和表示结点$v_{j}$的入度。简单地说，就是竖入横出。即有：  
$$
\deg^{-}(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};\qquad\deg^{+}\!\left(v_{j}\right)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（3）对于有向图G，注意到：  
$$
\sum_{j=1}^{n}\;\deg^{-}\!\left(v_{j}\right)=\sum_{i=1}^{n}\sum_{j=1}^{n}a_{i j}=\sum_{i=1}^{n}\deg^{+}\!\left(v_{i}\right)
$$  
因此，有向图中所有入度之和等于所有出度之和，这个和其实就是图的边数$m$。因为有向图的每条边均产生且仅产生一个出度和一个入度。  
对于图8-19 所示图模型$G$及如下邻接矩阵$A_{G}$，容易验证，结点度与邻接矩阵之间的数量关系。例如，$A_{G}$中第三行元素之和为3，即$v_{3}$的出度为3。
$$
\begin{gathered}v_{1}\quad v_{2}\quad v_{3}\quad v_{4}\quad v_{5}\\A_{G}=\begin{matrix}v_{1}\\v_{2}\\v_{3}\\v_{4}\end{matrix}\begin{pmatrix}0&1&0&0&0\\0&1&1&0&0\\1&1&0&1&0\\0&0&0&0&0\\0&0&0&0&0\end{pmatrix}\end{gathered}
$$  
关于图中结点度数与边的关系，有如下著名的图论基本定理：  
【定理8.1】（握手定理）假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，则该图中结点度数的总和等于边数的二倍，即有：  
$$
\sum_{v\in V}\deg(v)=2|E|
$$  
【推论8.1】图中度数为奇数的结点个数必为偶数。  
从以上定理及例题可以看出，图模型中结点的度从一种定量的角度反映了图中结点与边之间的制约关系，在一定程度上刻画了图模型的结构特征。为了更加方便地描述图模型中各个结点的度结构信息，下面给出度序列的概念：  
【定义8.19】假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，图中每个结点的图构成的自然数序列称为$G$的度序列。也就是说，若 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，则称序列：  
$$
(\deg(v_{1})\,,\deg(v_{2})\,,\cdots,\deg(v_{n}))
$$  
为图 $G$ 的度数序列，简称为度序列。 此外，对于任意一个给定的自然数序列，如果该序列能够成为某个图的度序列，则称该序列为可图化序列。  
例如，对于图8-22 所示图 $G$ ，其度数序列为 (2,3,3,4)  
![图8-22 图 $G$ ](images/77ba680d9b589e032065b86071c3f75473dc0d06736af0deb36aa2115de43d51.jpg)  
由于图模型的度要满足握手定理等基本约束要求，而且对于不同类型的图，其度序列也会有一些相应的数据特征。因此，并不是任意的自然数序列都可以构成图模型的度序列。对于任意给定的自然数序列，需要通过分析其数据特征来判断其是否为可图化序列。若是可图化序列，则可依据该序列数据来分析其所对应图的结构特征。"
成假赋值,定义,"['第三章  命题演算与推理', '§ 3.2 命题公式与等值演算', '3.2.1 命题公式的基本知识', '二、命题公式的解释与真值表']","{'实体类型': '定义', '定义': '命题公式在某种解释下的真值取值为假'}",,4,"命题公式是由命题变量、，其中命题变量泛指的无确定真值的、抽象的命题。因此，命题公式一般没有确定的真值。但是，如果对命题公式中每个命题变量分别指定确定真值的具体命题，那么命题公式就变成一个具有确定真值的复合命题。由此得到如下关于命题公式解释或赋值的概念：  
【定义3.9】设$P_{1},P_{2},\cdots,P_{n}$是出现在命题公式$G$中所有命题变量，对$P_{1},P_{2},\cdots,P_{n}$分别指定真值，由此得到的一组真值称为命题公式$G$的一个解释或赋值，通常记为$\smash{I_{\circ}}$。  
命题公式中的每个变量都有𝑇和$F$两种真值指定方式，对于$\cdot n$个命题变量的公式就有$\cdot2^{n}$个不同解释。例如，含2 个命题变量公式有4 种不同解释，含有3 个变量公式有8 种不同解释。命题公式在每种解释下都会有相应的真值取值，由此可得如下定义：  
【定义3.10】对于任意一个给定的命题公式$G$，如果该命题公式在某种解释下的真值取值为真，则称该解释为$G$的成真赋值或弄真赋值；如果该命题公式在某种解释下的真值取值为假，则称该解释为$G$的成假赋值或弄假赋值。  
为直观表达命题公式在不同解释下的取值状态，在变量不太多的情况下，可将命题公式在所有不同解释下的取值状态枚举出来，做成一个表格。由此得到如下真值表的概念：  
【定义3.11】对于任意一个含有$\cdot_{n}$个命题变量的命题公式$G$，$G$的所有解释以及在每个解释下真值取值所构成的表格称为$G$的真值表。  
在真值表中，一般将命题公式中的命题变量放在最左边，将命题公式在解释下的真值取值结果放在右边并加粗表示。对于比较复杂的公式，通常将计算命题公式真值的中间结果依次放在表中，或者中间结果放在相关逻辑联结词的下方。此外，为节约篇幅，通常将含有相同命题变量个数的多个命题公式真值取值结果合并到一个真值表中。  
表3-4  例题3.11 的真值表
![](images/b78e9e94318e03b09f7351596ca332bf194681eedad2d1334bdc1ed7b6f02552.jpg)"
成真赋值,定义,"['第三章  命题演算与推理', '§ 3.2 命题公式与等值演算', '3.2.1 命题公式的基本知识', '二、命题公式的解释与真值表']","{'实体类型': '定义', '定义': '命题公式在某种解释下的真值取值为真'}",,4,"命题公式是由命题变量、，其中命题变量泛指的无确定真值的、抽象的命题。因此，命题公式一般没有确定的真值。但是，如果对命题公式中每个命题变量分别指定确定真值的具体命题，那么命题公式就变成一个具有确定真值的复合命题。由此得到如下关于命题公式解释或赋值的概念：  
【定义3.9】设$P_{1},P_{2},\cdots,P_{n}$是出现在命题公式$G$中所有命题变量，对$P_{1},P_{2},\cdots,P_{n}$分别指定真值，由此得到的一组真值称为命题公式$G$的一个解释或赋值，通常记为$\smash{I_{\circ}}$。  
命题公式中的每个变量都有𝑇和$F$两种真值指定方式，对于$\cdot n$个命题变量的公式就有$\cdot2^{n}$个不同解释。例如，含2 个命题变量公式有4 种不同解释，含有3 个变量公式有8 种不同解释。命题公式在每种解释下都会有相应的真值取值，由此可得如下定义：  
【定义3.10】对于任意一个给定的命题公式$G$，如果该命题公式在某种解释下的真值取值为真，则称该解释为$G$的成真赋值或弄真赋值；如果该命题公式在某种解释下的真值取值为假，则称该解释为$G$的成假赋值或弄假赋值。  
为直观表达命题公式在不同解释下的取值状态，在变量不太多的情况下，可将命题公式在所有不同解释下的取值状态枚举出来，做成一个表格。由此得到如下真值表的概念：  
【定义3.11】对于任意一个含有$\cdot_{n}$个命题变量的命题公式$G$，$G$的所有解释以及在每个解释下真值取值所构成的表格称为$G$的真值表。  
在真值表中，一般将命题公式中的命题变量放在最左边，将命题公式在解释下的真值取值结果放在右边并加粗表示。对于比较复杂的公式，通常将计算命题公式真值的中间结果依次放在表中，或者中间结果放在相关逻辑联结词的下方。此外，为节约篇幅，通常将含有相同命题变量个数的多个命题公式真值取值结果合并到一个真值表中。  
表3-4  例题3.11 的真值表
![](images/b78e9e94318e03b09f7351596ca332bf194681eedad2d1334bdc1ed7b6f02552.jpg)"
或门,概念,"['第三章  命题演算与推理', '§ 3.6 命题逻辑的应用', '3.6.2 组合逻辑电路设计']","{'实体类型': '概念', '特点': '允许有多个输入'}",,3,"逻辑电路，又分为逻辑电路和时序逻辑电路。前者由最基本的“与门”、“或门”和“非门”电路组成，其输出值仅依赖于其输入变量的当前值，与输入变量的过去值无关—即不具记忆和存储功能；后者也由上述基本逻辑门电路组成，但存在反馈回路—它的输出值不仅依赖于输入变量的当前值， 也依赖于输入变量的过去值。 命题逻辑是组合逻辑电路设计的理论基础 和基本工具。如图3-10 所示，组合逻辑电路中的 “非门”、 “与门”、 “或门”，即为命题逻辑的“与”、“或”、“非”三种运算。通过利用这三种门，就可以构造出各种组合逻辑电路。  
![](images/e4f21b269b175874de7115f5156d6a3c1eb9e6666a1338dc9d4727bc0ca3ab30.jpg)
图3-10 基本类型的门  
“与门”和“或门”允许有多个输入，具有 $n$个输入的“与门”和“或门”如图3-11 所示。  
![](images/b8e3cbd2c8e7532c3d5f1acea4bd76306cd188918c6130d6354e264b174b34dc.jpg)
图3-11 具有 $n$ 个输入的门"
找假币问题,问题,"['第九章  树的基本理论与算法', '§ 9.4 树模型的应用', '9.4.1 找假币问题']","{'实体类型': '问题', '定义': '有若干外观完全一样的硬币，其中有一个是假币，通过称重的方式把该假币找出来', '特点': '可以看作为一种决策问题，根据每一步的决策，选择走相应的步骤'}",,3,"所谓找假币问题，就是有若干外观完全一样的硬币，其中有一个是假币，该假币的种类与其余硬币在重量上有一定差异，需要通过称重的方式把该假币找出来。这种找假币问题，其实可以看作为一种决策问题，即根据每一步的决策，选择走相应的步骤。  
对于决策问题，首先想到的是使用决策树来解决。从树根开始，每次回答一个问题，走相应的边，最后将会达到一个叶结点，即做出了选择。这样的一棵树称为决策树。例如，女孩子被父母安排相亲，为了确定见与不见，他可能会考虑诸如：年龄、长相、收入等问题。图9-54 所示的决策树就是她可能的一种决策过程。  
决策树作为树模型的一个典型应用，它可以把做出判决的逻辑关系用树结构的形式表现出来，最后的结果都集中在叶子上，条理清晰，一目了然，并且可以用决策树表示算法，使得在最坏情形下花费时间最少。因此，可以采取一种经典的树模型——决策树来解决这个问题。下面介绍两种基于决策树的解法，分别体现在如下问题一和问题二中，一种是基于两两比较的策略，另一种是基于分组比较的策略。  
![图9-54 是否相亲决策树  ](images/55dcf1b53e3f3d285d392dd47362956c928f6b44dead3c11e073f8a4468ae02e.jpg)  
![图9-55  3 元决策树](images/a77add97a68ea00460ddd28f80a5c06982291c918c8a7cf75e04eb033d4979ac.jpg)  
问题一、现有5 枚外观相同的硬币，其中有1 枚是假的，假币与真币在重量上有差异，但不知孰重孰轻。问如何使用一架无砝码天平找出假币并判别其与真币的重量关系？  
问题分析与求解：用天平来称𝐴和𝐵两枚硬币，只有$A<B$、$A=B$、$A>B$三种可能的情形，因此可构造3 元决策树来解决。如图9-54 所示。  
由图9-55 可知，从根到叶就是一种求解过程，由于该树有10 片叶子，因此最多有十种可能的解。又由于树高为3，因此最坏情形下需要3 次判别就能得到结论。  
问题二、现有12 个外观相同的硬币，其中有一枚是假的，且已知假币比真币重，要求用一个无砝码天平，只称3 次，把假币找出来。  
问题分析与求解：把硬币等分成三份，用天平分别对这三份进行称重。确定假币在哪一份，之后再对假币所在的那一份进行等分，并称重，直到找到假币。如图9-56 所示。  
![图9-56 决策树  ](images/db3a037f92dd9e6a550f65f863d04f248565341ddf14fb1910ec84f7e7556b97.jpg)  
决策树在生活中有着广泛的应用，除了解决假币问题，还可以解决排序类问题。  
例如，为了确定$𝐴$，$B$，$C$的大小顺序，我们可以采用如图9-57 所示的决策树模型来解决，每条边都用非叶结点基于问题答案的表排列进行标注，叶结点给出了排好的顺序.令最坏情形下的比较次数为排序的最坏时间情形，图9-57 所示的算法给出的最坏情形时间为3，可以证明这个算法是最优的。  
可以用反证法证明，没有其它算法能在最坏时间小于3 对3 个项排好序。假设存在一个这样的算法，并用基础上描述，因为最坏情形排序时间小于等于2，树高则小于等于2，因为每个叶结点最多有两个子结点，则这棵树最多有4 个叶结点。每个叶结点对应一个可能的结果，所以决策树高度小于等于2 的决策树最多只有4 个结果，但3 个项的排序有6种可能结果，这就产生了矛盾。因此，图9-58 的算法是最优的。  
同理，因为$4!=\!24$，所以对4 个项排序有24 种结果。对应24 个叶结点，必须要有树高至少为5 的决策树，因此对4 个项排序的任一算法，在最坏情形下至少要进行5 次比较。更多项的排序可以此类推，不再赘述。"
抽象代数,概念,"['第十一章  抽象代数结构通论', '§ 11.1 代数结构的基本概念', '11.1.1 数学结构与代数结构']","{'实体类型': '概念', '定义': '通过对运算和运算对象进行抽象的方式研究的代数结构', '发展': '由伽罗瓦的群论发展而来，成为现代代数学的重要分支', '知识体系': '包括群、环、域、格等典型抽象代数系统'}",,3,"代数结构作为四大基本数学结构之一，它以运算作为处理机制，在整个数学理论体系和计算机数学建模中占据非常重要的作用。代数结构是一种非常古老的数学结构，具有几千年发展历程，从最初初等代数逐步发展到大代数，然后进一步发展到抽象代数，目前正朝着泛代数的方向发展。本小节主要介绍抽象代数的由来及其基本知识结构。  
用计算机解决实际问题，一般需要对问题进行抽象并建立相应的数学模型，然后在此基础上将对实际问题的求解转化为对数学模型的求解。 因此，数学模型是用计算机解决实际问题的基础。现实问题纷繁复杂、变化万千，所建立的数学模型自然也是五花八门，多种多样，让人无所适从。值得欣慰的是，尽管我们面对的数学模型复杂多样，但从结构上看，所有这些数学模型都建立在四种基本的数学结构基础之上。  
这四种基本数学结构分别为：表示元素之间空间关系的拓扑结构，如图模型、树模型就是一些拓扑结构；表示元素之间运算关系的代数结构，如初等代数、向量代数、矩阵代数、命题代数、集合代数等都是代数结构；表示元素规模度量性质的测度结构，如高等数学里函数的微分和积分都是测度结构，它们主要计算面积、体积、弧长、速度等；表示元素之间次序关系的偏序结构，如整数的整除关系、集合的包含关系等偏序关系都是偏序结构。  
任何一个数学结构都是由载体、处理机制和处理规则这三个基本要素组成：  
（1）载体集合 对于任何一个数学结构，需要定义一些抽象的元素作为处理对象，这些抽象元素组成的集合构成数学结构的载体。载体集合是数学结构存在的基础或平台。  
（2）处理机制 为了实现对数学结构载体中元素的处理，需要定义一些处理机制，不同的数学结构具有不同的处理机制。例如：偏序结构是一种关系结构，它以元素之间的次序关系或者比较关系作为处理机制；代数结构是一种运算结构，它以元素之间的运算作为处理机制；拓扑结构是一种分布结构，它以元素之间的空间分布作为处理机制；测度结构则是一种度量结构，它以元素的规模度量作为处理机制。  
（3）处理规则 为使定义出来的数学结构满足一些合理性要求以及能够在处理实际问题中发挥作用，避免出现一些矛盾或荒诞的处理结果，还必须制定一些处理规则对处理机制做一些必要的限制。在现代数学的公理化系统中，通常称这些处理规则称为公理。不同的数学结构具有不同的处理规则，例如偏序结构限制元素之间的关系必须满足自反性、反对称性和传递性，这些限制或者性质构成了偏序结构公理系统；再如代数结构则是规定元素之间的运算必须满足结合律、交换律、分配律等运算性质。  
数学运算最早起源于算术运算，即使用具体的整数或分数进行四则运算。随着科学技术的不断发展，人们逐步意识到这种方法不能满足对一般性规律的认识。因此，采用抽象的字母来代替具体的整数和分数进行运算以获得通用性结果，并称之为代数运算或简称为代数。在微积分出现之前的数千年历史中，对代数运算的研究一直占据数学研究的核心地位。那时人们普遍信奉一种所谓的万能法则，即世界上所有问题都可以转化为数学问题，所有数学问题都可以转化为代数问题，所有代数问题都可以转化为方程问题。  
因此，在很长一段历史时期内，人们对数学的研究基本上都是对代数学的研究，对代数学的研究基本上是方程或方程组解法的研究。解方程是那个时期内所有数学家的中心任务，大家都非常期望能够通过使用代数运算的方法找到方程或方程组的通用求解公式。这种努力在线性方程组领域取得了非常完美的结果，并由初等代数逐步衍生出线性代数。但是，对于一元高次方程通用求解方法的研究并不是很顺利，对于次数高于四次的一元方程始终找不到通用求解公式或求解方法。一些非常著名的数学家，例如欧拉、高斯、拉格朗日等都对此做了大量非常艰苦的研究，但均告失败。  
在寻求五次方程通用求解方法的过程中，年仅17 岁的法国天才少年伽罗瓦在1828 年提出群的概念，运用群的思想证明了五次方程通用求解公式是不存在的，并给出了五次方程系数在满足一定条件下若干特殊解法，由此一举解决了困扰数学家长达200 多年的数学问题。伽罗瓦取得成功的关键在于不仅将运算对象进行抽象化，而且对运算本身进行抽象，在抽象对象和抽象运算的基础上通过构造一些特殊抽象代数结构进行求解。这个思想在当时实在过于超前以至于没有得到柯西、傅里叶、泊松等著名数学家的认可，泊松的判词是“完全不能理解”。 1832 年5 月31 日年仅21 岁的伽罗瓦死于决斗。在决斗之前，他把关于五次方程代数求解的研究成果写成长信，留给了人类。14 年后，法国数学家刘维尔整理并发表了伽罗瓦的遗作，人们才理解并惊叹他那超越时代的天才思想和巧妙构思。  
至此以后，人们对代数的研究内容由方程或方程组的求解技巧转变为对代数运算性质和运算结构的研究，通过对运算和运算对象进行抽象的方式实现对所有运算依其运算性质进行分类或归类，并将伽罗瓦的群论迅速发展成为一门称之为抽象代数结构的崭新数学分支。 抽象代数结构的诞生，把代数学从传统的初等代数发展到现代的抽象代数，由此打开了现代代数学的大门，开创了代数学研究的新纪元。因此，抽象代数结构通常也称为近世代数以区别于之前的初等代数。若无特别说明，我们通常将抽象代数结构简称为代数结构。  
经过一百多年的发展，抽象代数结构已经形成一个如图11-1 所示的知识体系。对于一个代数系统，我们不仅可以主动设计出它的运算并考察相应的运算规则，而且还可以通过分别对其载体集合进行相关改造或运算得到相应的子代数、积代数和商代数，可以通过映射的方式考察不同代数结构之间的区别与联系，还可根据运算性质对代数结构进行分类，形成若干典型抽象代数系统，如群、环、域、格等。  
![](images/37d476cf884c29ed65924bc021cb612de43bab4df8b1196f64e96cad4f61a01f.jpg)
图11-1 抽象代数结构的知识体系  
代数结构作为一种特殊的数学结构，具有载体、处理机制和处理规则这三个基本要素。如前所述，代数结构的载体就是由一些抽象对象为元素组成的集合，并通过运算机制实现对集合中元素的处理。所谓运算，其实就是通过映射的手段从已有元素中构造出新的元素。载体和运算统称为代数结构的成分。代数结构的处理规则即为运算性质。  
既然代数结构的载体是一个集合，那么就可以考虑通过一定方式由这个集合派生出新的集合并据此构造出新的代数结构。例如，可以考察其子集以及在子集上的运算，得到子代数的概念和性质；可以对作为载体的集合做笛卡尔集构成一个新的集合，并在新集合上定义相关运算，得到积代数的概念和性质；可以通过构造等价关系的方法实现对集合载体的划分，构成一个以等价类为元素的商集，并在这个商集上定义相关运算，得到商代数的概念和性质。子代数、积代数和商代数是构造和研究代数结构的基本方法论。  
当然，还可以考察两个代数结构之间的相似性与差异性。对于任意两个代数系统，可以在这两个代数结构的载体(集合)上建立一种保运算的映射，由此考察代数结构之间的联系。如果存在这种保运算映射，则称这两个代数系统同态。如果这种保运算的映射还是双射，则称这两个代数系统同构。同态和同构是考察代数结构之间联系的基本工具。  
依据代数结构的运算性质，可以将各种具体代数结构划分为若干抽象类型。典型的抽象代数结构类型主要有仅含一个二元运算的半群与群、含有两个二元运算的环与域，以及格与布尔代数。这些典型抽象代数结构构成代数结构知识体系的主要内容。"
抽象代数结构,概念,['第十一章  抽象代数结构通论'],"{'实体类型': '概念', '定义': '在初等代数抽象层次上的进一步抽象，其运算和运算性质具有更高层次的通用性和普适性', '应用': '为抽象数据类型及相关运算的设计提供基本思路和方法技巧，设计满足实际问题需要的计算模型', '领域应用': '信息编码与纠错、自动机与形式语言、大数据信息处理与知识发现、信息安全', '重要性': '使得代数学由主要针对各种运算技巧的研究转变为主要针对各种运算性质和运算结构的研究，开辟了数学代数学发展的新纪元'}",,1,"我们知道，小学数学中关于整数或分数的四则运算称之为算术，初中数学则将这些具体整数或分数抽象成字母，着重考察这些字母表达式的运算性质与运算技巧，称之为初等代数或代数。从本质上说，所谓代数，其实就是以运算为基本手段寻求针对某一类问题的通用求解方法或计算公式。因此，可运算性和通用性是代数学的两个核心要点。初等代数之所以用抽象字母代替具体的数，是因为字母比数更具一般性和通用性。事实上，我们的处理对象除数之外通常还有很多其它类型，例如向量、矩阵、命题、集合、函数、关系、图模型等等，这些对象都分别具有各自的运算及运算性质。那么就有一个想法：是否可以对这些对象做进一步抽象？具体地说，就是如同用字母表示数一样用一种抽象对象来统一表示这些各种各样的具体对象，并用一些抽象运算统一表示这些具体对象各自的运算及运算性质，从更加抽象的角度来考察这些不同对象所共有的一般性运算性质与规律，或者说从更加抽象的层次上根据运算性质的差异对这些不同对象进行分类。  
基于以上思想，就可得到抽象代数结构的概念。该结构是在初等代数抽象层次上的进一步抽象，其运算和运算性质具有更高层次的通用性和普适性。抽象代数结构的出现使得代数学由主要针对各种运算技巧的研究转变为主要针对各种运算性质和运算结构的研究，开辟了数学代数学发展的新纪元，将代数学带入了一个全新的发展阶段。从计算机的角度看，计算机处理的信息对象多种多样的且分别具有各自的运算和运算性质。对这些信息的处理一般需要建立若干抽象数据类型并将与之相关的数据运算封装于其中，并从抽象的角度考察它们的共同运算性质和运算规律。抽象代数结构的相关理论和技术可以为这些抽象的数据类型及相关运算的设计提供基本思路和方法技巧。此外，还可使用抽象代数结构理论设计出各种各样满足实际问题需要的计算模型。目前，这些计算模型已经在信息编码与纠错、自动机与形式语言、大数据信息处理与知识发现、信息安全等众多领域得到广泛应用。  
学习抽象代数结构知识不仅可以掌握抽象数据类型和计算模型的设计技巧，更为重要的是能够使得读者具备一种高度抽象的思维能力，可以站在比较高的层次上看待、分析和解决问题，获得一种更加宽广的视野。本章主要介绍抽象代数结构的基本知识，包括代数结构的基本概念、代数结构与子代数、代数结构的运算性质、代数结构的同态与同构等。"
拉格朗日定理,定理,"['第十二章 典型抽象代数结构', '§ 12.3 同余关系与商群', '12.3.1 同余关系与陪集']","{'实体类型': '定理', '内容': '设⟨G,*⟩是任意给定的一个有限群，⟨H,*⟩是⟨G,*⟩的任一子群，则群⟨G,*⟩的阶一定是其子群⟨H,*⟩阶的倍数，即有k=|G|/|H|，其中k为正整数且为子群⟨H,*⟩的一切不同左（右）陪集个数'}",,3,"现在我们在群结构的场合考察二元代数结构的同余关系。首先看下面具体实例：  
对于整数加群$\langle Z,+\rangle$，易知$\langle Z_{m},+\rangle$是$\langle Z,+\rangle$一个子群。其中$Z_{m}=\{k m|k\in Z\}$，$m$是任意给定的正整数。我们知道，任意两个整数$a$和$b$具有模$m$同余关系当且仅当$a-b\in Z_{m}$。  
对上述整数加群$\langle Z,+\rangle$上模$m$同余关系进行抽象，就得到如下群上的同余关系：  
【定义12.17】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，对于$\forall a,b\in G$,若有$a*b^{-1}\in H$，则称$a$与$b$具有模${H}$同余关系，记为$a\equiv b({mod{H}})$。  
下面的定理12.3.1 表明模$H$同余关系的确是一个同余关系，即要证明该关系不仅是一个等价关系，而且还对运算$*$具有保持性。  
【定理12.20】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则模${H}$同余关系是$G$上的一个等价关系且对运算${\ast}$具有保持性，即对于$\forall a,b,c\in G$，如果$a\equiv b({\bmod{\ H}})$，则有$a*c\equiv b*c({\bmod{\ H}})$。  
对于群$\langle G,*\rangle$的任意一个子群$\langle H,*\rangle$，既然模$H$同余关系是$G$上的一个等价关系，那么该关系必然确定一个对集合$G$的划分，每个划分块就是该等价关系的一个等价类。由于该等价关系显然由子群$\langle H,*\rangle$确定，因此，对集合的$G$划分也应由子群$\langle H,*\rangle$。为便于考察子群$\langle H,*\rangle$与集合划分的关系，现引入子群$\langle H,*\rangle$陪集的概念，并考察$\langle H,*\rangle$的左右陪集与模${H}$同余关系所确定等价类之间的联系。具体如下：  
【定义12.18】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则对于$\forall a\in G$，称集合$a$ $H=\{a*h|h\in H\}$为子群$\langle H,*\rangle$在群$\langle G,*\rangle$中的一个左陪集，集合$H a=\{h*a|h\in H\}$为子群$\langle H,*\rangle$在群$\langle G,*\rangle$中的一个右陪集，元素$a$为$𝑎$ $H$和$H a$的代表元。  
现在考察如何使用左右陪集实现对群的分解，为此首先引入如下定理：  
【定理12.21】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则对于$\forall a\in G$，其关于$\langle H,*\rangle$的左右陪集的基数相等且等于$ H$的基数，即有$\left|a H\right|=\left|H\right|=\left|H a\right|$。  
由此可见，对于群$\langle G,*\rangle$中的任意一个元素，其关于子群$\langle H,*\rangle$的左右陪集的基数相等且是一个仅与子集$H$有关的常数，即为$|H|$。由此可得如下关于群分解的拉格朗日定理：  
【定理12.22】（拉格朗日定理）设$\langle G,*\rangle$是任意给定的一个有限群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则群$\langle G,*\rangle$的阶一定是其子群$\langle H,*\rangle$阶的倍数，即有$k=|G|/|H|$，其中$k$为正整数且为子群$\langle H,*\rangle$的一切不同左（右）陪集个数。  
拉格朗日定理定理告诉我们：若$\langle G,*\rangle$是有限群，则其子群的阶是群$\langle G,*\rangle$阶的因子。因此，可以通过群与其子群阶的关系考察群的结构及其子群的个数。  
【推论12. 1】假设$\langle G,*\rangle$是一个$ n$阶有限群，则$G$中每个元素的阶均是${n}$的因子且对于$\forall a\in$$G$有$a^{n}=e$.  
【推论12.2】阶为素数的有限群是循环群."
拟序关系,概念,"['第六章 特殊关系模型', '§ 6.3 偏序关系与元素比较', '6.3.1 偏序关系与哈斯图']","{'实体类型': '概念', '定义': '设R为非空集合A上的一个二元关系，如果R满足反自反性、反对称性和传递性，则称R是A上的一个拟序关系或半序关系，简称为拟序或半序，记为<，读作小于', '特点': '拟序关系的自反闭包就是偏序关系', '关系': '偏序关系是拟序关系的一种扩充，拟序关系是偏序关系的一种缩减', '示例': '实数集上的实数小于关系'}",,3,"次序是日常生活和工作中经常遇到的一种关系，例如体育竞赛中的排名、全国高校排名、家族的长幼辈分、某单位的行政职位的级别、实数之间的大小关系、集合之间的包含关系、自然数集合上的整除关系等等，都是次序关系，刻画的是对象之间在某个方面的差异性比较关系。现在我们用数学方法来表示和处理这种序关系。  
我们知道，某集合幂集上的包含关系满足自反性、反对称性和传递性，自然数集合上的整除关系也满足自反性、反对称性和传递性。将这类关系抽象出来，可得到一种名为偏序关系的特殊关系，其具体定义如下：  
【定义6.9】设$R$非空集合$𝐴$上的一个二元关系，如果$𝑅$满足自反性、反对称性和传递性，则称 $R$是$𝐴$上的一个偏序关系,简称为偏序，记为$\preccurlyeq$，读作小于等于或先于。对于𝐴上的任意两个元素$x,y$，如果序偶$\langle x,y\rangle\in R$，则称$x$与𝑦可比且$x$前于$y$或$x$先于$ y$，记为$x\preccurlyeq y$。如果集合$𝐴$上有偏序关系$R$，则称$;A$为是一个偏序集,记为$\langle A,\preccurlyeq\rangle$。  
从上述定义可知，定义中小于等于或先于的含义并不一定是指数的大小，主要是指偏序关系中的顺序，$x$小于等于或先于$ y$的具体含义是：依照这个序关系$x$排在𝑦的前面或者$x$就是$y$。此外，定义中并没有保证$𝐴$中任意两个元素之间都必须具有这种序关系。这正是偏序的含义。所谓偏序,就是集合中的部分元素之间存在这种序关系。  
例如，集合$ A=\{2,4,6,8\}$上的整除关系为：  
$$
R=\{\ \langle2,2\rangle,\langle2,4\rangle,\langle2,6\rangle,\langle2,8\rangle,\langle4,6\rangle,\langle4,8\rangle,\langle6,6\rangle,\langle8,8\rangle\}
$$  
显然关系$R$具有自反性、反对称性和传递性，故为偏序关系。$\langle A,R\rangle$是一个偏序集。在这个偏序集中，4和8是可比的且4 先于8，而4 和6是不可比的。  
【定义6.10】设$𝑅$非空集合$𝐴$上的一个二元关系，如果$R$满足反自反性、反对称性和传递性，则称$𝑅$是$𝐴$上的一个拟序关系或半序关系,简称为拟序或半序，记为$\prec$，读作小于。对于$𝐴$上的任意两个元素$x,y$，如果序偶$\langle x,y\rangle\in R$，则称$x$与$𝑦$可比且$$x$$小于$ y$，记为$x\prec y$。如果集合$𝐴$上有偏序关系$R$，则称$𝐴$为是一个拟序集或半序集,记为$\langle A,\prec\rangle$。  
从上述定义可知，定义中小于的含义并不是指数的大小，而是指偏序关系中的顺序，$x$小于𝑦的含义是：依照这个序关系$x$排在𝑦的前面。显然，拟序关系的自反闭包就是偏序关系。因此，偏序关系是拟序关系一种扩充，拟序关系是偏序关系的一种缩减。例如，实数集上的实数小于关系就是一种拟序关系，小于等于关系则是一种偏序关系。"
拟序集,概念,"['第六章 特殊关系模型', '§ 6.3 偏序关系与元素比较', '6.3.1 偏序关系与哈斯图']","{'实体类型': '概念', '定义': '如果集合A上有拟序关系R，则称A为是一个拟序集或半序集，记为⟨A,<⟩'}",,3,"次序是日常生活和工作中经常遇到的一种关系，例如体育竞赛中的排名、全国高校排名、家族的长幼辈分、某单位的行政职位的级别、实数之间的大小关系、集合之间的包含关系、自然数集合上的整除关系等等，都是次序关系，刻画的是对象之间在某个方面的差异性比较关系。现在我们用数学方法来表示和处理这种序关系。  
我们知道，某集合幂集上的包含关系满足自反性、反对称性和传递性，自然数集合上的整除关系也满足自反性、反对称性和传递性。将这类关系抽象出来，可得到一种名为偏序关系的特殊关系，其具体定义如下：  
【定义6.9】设$R$非空集合$𝐴$上的一个二元关系，如果$𝑅$满足自反性、反对称性和传递性，则称 $R$是$𝐴$上的一个偏序关系,简称为偏序，记为$\preccurlyeq$，读作小于等于或先于。对于𝐴上的任意两个元素$x,y$，如果序偶$\langle x,y\rangle\in R$，则称$x$与𝑦可比且$x$前于$y$或$x$先于$ y$，记为$x\preccurlyeq y$。如果集合$𝐴$上有偏序关系$R$，则称$;A$为是一个偏序集,记为$\langle A,\preccurlyeq\rangle$。  
从上述定义可知，定义中小于等于或先于的含义并不一定是指数的大小，主要是指偏序关系中的顺序，$x$小于等于或先于$ y$的具体含义是：依照这个序关系$x$排在𝑦的前面或者$x$就是$y$。此外，定义中并没有保证$𝐴$中任意两个元素之间都必须具有这种序关系。这正是偏序的含义。所谓偏序,就是集合中的部分元素之间存在这种序关系。  
例如，集合$ A=\{2,4,6,8\}$上的整除关系为：  
$$
R=\{\ \langle2,2\rangle,\langle2,4\rangle,\langle2,6\rangle,\langle2,8\rangle,\langle4,6\rangle,\langle4,8\rangle,\langle6,6\rangle,\langle8,8\rangle\}
$$  
显然关系$R$具有自反性、反对称性和传递性，故为偏序关系。$\langle A,R\rangle$是一个偏序集。在这个偏序集中，4和8是可比的且4 先于8，而4 和6是不可比的。  
【定义6.10】设$𝑅$非空集合$𝐴$上的一个二元关系，如果$R$满足反自反性、反对称性和传递性，则称$𝑅$是$𝐴$上的一个拟序关系或半序关系,简称为拟序或半序，记为$\prec$，读作小于。对于$𝐴$上的任意两个元素$x,y$，如果序偶$\langle x,y\rangle\in R$，则称$x$与$𝑦$可比且$$x$$小于$ y$，记为$x\prec y$。如果集合$𝐴$上有偏序关系$R$，则称$𝐴$为是一个拟序集或半序集,记为$\langle A,\prec\rangle$。  
从上述定义可知，定义中小于的含义并不是指数的大小，而是指偏序关系中的顺序，$x$小于𝑦的含义是：依照这个序关系$x$排在𝑦的前面。显然，拟序关系的自反闭包就是偏序关系。因此，偏序关系是拟序关系一种扩充，拟序关系是偏序关系的一种缩减。例如，实数集上的实数小于关系就是一种拟序关系，小于等于关系则是一种偏序关系。"
排中律,性质,"['第一章  集合与计数基础', '§ 1.1 集合的基本知识', '1.1.3 集合的基本运算', '二、差运算与补运算']","{'实体类型': '性质', '条件': '对于任意给定的集合A', '结论': 'A∪A=U'}",,4,"对于任意给定的两个集合$A$ 和$B$，有时需要将属于$A$ 但不属于$B$ 的所有元素取出来构成一个新的集合，由此得到如下集合差运算的概念：  
【定义1.12】对于任意给定的两个集合$A$ 和$B$，集合$\cdot A-B=\{x|x\in A$并且$x\notin B\}$称为$A$ 与$B$ 的差集，$A-B$亦称为集合𝐴与$B$的差运算；令$U$表示全集，则${\bar{A}}=U-A=\{x|x\in$$U$且$x\notin A\}$称为$A$ 的补集，亦称$\bar{A}$为对集合$A$ 的补运算。  
一般来说，所谓两个对象互补，是指这两个对象之间无共同部分并且若将两者合并则构成一个完整的整体。如果将全集𝑈看成是一个完整的整体，那么任何一个集合与它的补集显然构成一种互补关系。图1-3 为集合差运算和补运算的文氏图。  
![](images/3dd3ff26327d44646f11d3b3940708dbd5563cf42578e139e0a56534e35c5eff.jpg)
图1-3 差、补运算的文氏图  
不难看出，集合的差运算和补运算其实就是实数减法运算在集合论中的推广。根据集合差运算与补运算的定义，不难证明它们满足如下基本运算性质：  
(1) 矛盾律：对于任意给定的集合$A$，有：$A\cap{\bar{A}}=\emptyset$；(2) 排中律：对于任意给定的集合$A$，有：$A\cup\bar{A}=U$  
(3) 双重否定律：对于任意给定的集合$A$，有：$\bar{\bar{A}}=A$  
(4) 德摩根律：对于任意给定的两个集合$A$ 和$B$，有： $\overline{{A\cup B}}=\bar{A}\cap\bar{B},\,\,\,\overline{{A\cap B}}=\bar{A}\cup\bar{B}$  
(5) 对于任意给定的三个集合$A$、$B$ 和$C$，有：  
$A\cup(B\cup C)=(A\cup B)\cup C;\;A\cap(B\cap C)=(A\cap B)\cap C\circ$ $A\cap(B\cup C)=(A\cap B)\cup(A\cap C);\;A\cup(B\cap C)=(A\cup B)\cap(A\cup C)\,.$ $A\cap(A\cup B)=A;\,\,\,A\cup(A\cap B)=A\,.$  
现仅以德摩根律为例给出上述运算性质的证明，读者可自行给出其余证明。【例题1.22】对于任意给定的两个集合$A$ 和$B$，证明如下德摩根律：  
$$
{\overline{{A\cup B}}}={\bar{A}}\cap{\overline{{B}}}\,;\;{\overline{{A\cap B}}}={\bar{A}}\cup{\bar{B}}
$$"
排列计数,概念,"['第一章  集合与计数基础', '§ 1.3 有限集的基本计数技术', '1.3.3 排列计数与组合计数']","{'实体类型': '概念', '定义': '根据从集合中选择元素的有序与无序、是否允许重复等限制条件进行计数的问题', '基本类型': '不重复的排列、可重复的排列'}",,3,排列与组合是两类比较基本的计数问题，根据从集合中选择元素的有序与无序、是否允许重复等限制条件，可将这两类问题进一步划分为四种基本类型，即不重复的排列、不重复的组合、可重复的排列和可重复的组合。
排序类问题,问题,"['第九章  树的基本理论与算法', '§ 9.4 树模型的应用', '9.4.1 找假币问题']","{'实体类型': '问题', '应用': '用决策树模型确定项的大小顺序', '特点': '每条边用非叶结点基于问题答案的表排列进行标注，叶结点给出排好的顺序'}",,3,"所谓找假币问题，就是有若干外观完全一样的硬币，其中有一个是假币，该假币的种类与其余硬币在重量上有一定差异，需要通过称重的方式把该假币找出来。这种找假币问题，其实可以看作为一种决策问题，即根据每一步的决策，选择走相应的步骤。  
对于决策问题，首先想到的是使用决策树来解决。从树根开始，每次回答一个问题，走相应的边，最后将会达到一个叶结点，即做出了选择。这样的一棵树称为决策树。例如，女孩子被父母安排相亲，为了确定见与不见，他可能会考虑诸如：年龄、长相、收入等问题。图9-54 所示的决策树就是她可能的一种决策过程。  
决策树作为树模型的一个典型应用，它可以把做出判决的逻辑关系用树结构的形式表现出来，最后的结果都集中在叶子上，条理清晰，一目了然，并且可以用决策树表示算法，使得在最坏情形下花费时间最少。因此，可以采取一种经典的树模型——决策树来解决这个问题。下面介绍两种基于决策树的解法，分别体现在如下问题一和问题二中，一种是基于两两比较的策略，另一种是基于分组比较的策略。  
![图9-54 是否相亲决策树  ](images/55dcf1b53e3f3d285d392dd47362956c928f6b44dead3c11e073f8a4468ae02e.jpg)  
![图9-55  3 元决策树](images/a77add97a68ea00460ddd28f80a5c06982291c918c8a7cf75e04eb033d4979ac.jpg)  
问题一、现有5 枚外观相同的硬币，其中有1 枚是假的，假币与真币在重量上有差异，但不知孰重孰轻。问如何使用一架无砝码天平找出假币并判别其与真币的重量关系？  
问题分析与求解：用天平来称𝐴和𝐵两枚硬币，只有$A<B$、$A=B$、$A>B$三种可能的情形，因此可构造3 元决策树来解决。如图9-54 所示。  
由图9-55 可知，从根到叶就是一种求解过程，由于该树有10 片叶子，因此最多有十种可能的解。又由于树高为3，因此最坏情形下需要3 次判别就能得到结论。  
问题二、现有12 个外观相同的硬币，其中有一枚是假的，且已知假币比真币重，要求用一个无砝码天平，只称3 次，把假币找出来。  
问题分析与求解：把硬币等分成三份，用天平分别对这三份进行称重。确定假币在哪一份，之后再对假币所在的那一份进行等分，并称重，直到找到假币。如图9-56 所示。  
![图9-56 决策树  ](images/db3a037f92dd9e6a550f65f863d04f248565341ddf14fb1910ec84f7e7556b97.jpg)  
决策树在生活中有着广泛的应用，除了解决假币问题，还可以解决排序类问题。  
例如，为了确定$𝐴$，$B$，$C$的大小顺序，我们可以采用如图9-57 所示的决策树模型来解决，每条边都用非叶结点基于问题答案的表排列进行标注，叶结点给出了排好的顺序.令最坏情形下的比较次数为排序的最坏时间情形，图9-57 所示的算法给出的最坏情形时间为3，可以证明这个算法是最优的。  
可以用反证法证明，没有其它算法能在最坏时间小于3 对3 个项排好序。假设存在一个这样的算法，并用基础上描述，因为最坏情形排序时间小于等于2，树高则小于等于2，因为每个叶结点最多有两个子结点，则这棵树最多有4 个叶结点。每个叶结点对应一个可能的结果，所以决策树高度小于等于2 的决策树最多只有4 个结果，但3 个项的排序有6种可能结果，这就产生了矛盾。因此，图9-58 的算法是最优的。  
同理，因为$4!=\!24$，所以对4 个项排序有24 种结果。对应24 个叶结点，必须要有树高至少为5 的决策树，因此对4 个项排序的任一算法，在最坏情形下至少要进行5 次比较。更多项的排序可以此类推，不再赘述。"
推论10.1,定理,"['第十章  特殊图模型与算法', '§ 10.1 欧拉图与哈密顿图', '10.1.1  欧拉图及其性质']","{'实体类型': '定理', '内容': '无向图是半欧拉图当且仅当为连通图且恰有2个奇度数结点'}",,3,"为更好地介绍欧拉图，有必要再回顾一下前述哥尼斯堡七桥问题：哥尼斯堡小镇有一条贯穿全市的小河，河上有两个小岛，由七座桥将这两个小岛及其与河两岸进行互联，如图$10-$1(a)所示。问题是怎样才能不重复、不遗漏地走完七座桥，并回到出发点。  
![图10-1 哥尼斯堡七桥问题 ](images/f92d2bafd1492d4ec26c4c92f27d5040f5974fc8bef369b51ff49b676bd82f86.jpg)  
瑞士著名的数学家欧拉把该问题抽象成如图10-1(b)所示的图模型，其中两岸陆地和小岛分别被抽象成了 A, B, C, D 四个结点， 每个桥分别被抽象成了连接相应结点的无向边。 于是， 哥尼斯堡七桥问题就等价于图10-1(b)中是否存在一条从图中任意结点出发，经过图中所有边一次且仅一次的回路。由此得到如下欧拉图的相关定义：  
【定义10.1】设 $G=\langle V,E\rangle$是任意给定的一个图模型，通过图𝐺中所有边一次且仅一次的通路称为欧拉通路，通过图$G$中所有边一次且仅一的回路称为欧拉回路。如果图𝐺中存在欧拉回路，则称之为欧拉图，如果$G$中存在欧拉通路但不存在欧拉回路，则称之为半欧拉图。 规定平凡图为欧拉图。  
以上定义既适合无向图也适合有向图。从定义可以看出，欧拉通路是经过图中所有边的通路中长度最短的通路；欧拉回路是经过图中所有边的回路中长度最短的回路。如果仅用边来描述，那么欧拉通路和欧拉回路其实都是图中所有边的一个全排列。  
【定理10.1】设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$是欧拉图当且仅当 $G=\langle V,E\rangle$为连通图且所有结点度数均为偶数。  
【  
【推论10.1】设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$是半欧拉图当  
且仅当 $G=\langle V,E\rangle$为连通图且恰有2 个奇度数结点。  
由推论10.1 可知，如果$G$是连通图且刚好有奇度结点，那么在$G$中存在一条欧拉道路，且一定以其中一个奇度结点为始点，以另一个奇度结点为终点。  
下面进一步给出有向欧拉图和半欧拉图的判定定理：  
【定理10.2】设 $G=\langle V,E\rangle$是任意给定的一个有向图模型，则有：$G=\langle V,E\rangle$是欧拉图当且仅当 $G=\langle V,E\rangle$为连通图且所有结点的入度等等于出度；$G=\langle V,E\rangle$是半欧拉图，当且仅当$G=\langle V,E\rangle$连通且仅有一个结点的入度比出度大1，另外一个结点的出度比入度大1，其余结点的入度等于出度。  
对于一个欧拉图或半欧拉图，可以使用弗洛莱算法自动找到其欧拉回路或欧拉通路。该算法的基本思路是首先从图中的任一点出发，随机去掉与此点相连的边，然后在保证以下两个条件的基础上，依次去掉与之相连的边：  
1）如果去掉某边后使得该边的某端点为孤立结点，则将该端点与该边一并去掉。  
2）在去掉某边后，不能造成图模型的不连通。  
当算法停止时，获得的路径$L=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\ldots e_{n}v_{n}(v_{0}=v_{n})$就是图$G=\langle V,E\rangle$的一条欧拉回路。弗洛莱算法的具体步骤如下：  
1) 首先，在结点集𝑉中任选一个结点$v_{0}$为初始结点，并设初始通路为$L_{0}=v_{0}$。 2) 设已选好的简单通路为$\boldsymbol{\cdot}L_{i}=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\ldots e_{i}v_{i}$，按照下列条件从边集合：  
$$
E-\{e_{1},e_{2},e_{3},\ldots,e_{i}\}
$$  
中选取边]${e}_{i+1}$，其中$G_{1}$是从$G$删除边集合$\{e_{1},e_{2},e_{3},\ldots,e_{i}\}.$后得到的图：  
$\bullet$ 结点$v_{i}$是边$\boldsymbol{\cdot}\boldsymbol{e}_{i+1}$的端点。  
$\bullet$ 除非无其他边可以选取，否则删除边$\boldsymbol{\cdot}\boldsymbol{e}_{i+1}$后不改变图$G_{1}$的连通性。  
3）将$e_{i+1}v_{i+1}$加入到$L_{i}$中，形成新路径$\mathopen:L_{i+1}=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\dots e_{i}v_{i}e_{i+1}v_{i+1}$，令$i=i+1$  
4）返回步骤2）重复上述过程，直到 $i=|E|$ 。  
当图模型是一个半欧拉图时候，使用上述弗洛莱算法显然也可得到其欧拉通路，请读者自己思考算法的具体步骤和要点，不再赘述。  
![图10-10 房间布局的设计图     图10-11 图模型与欧拉通路       图10-12 行走路径 ](images/1200dfbb0792a6069379408b8f0f3304dd4b6248c5b1e2f4c4917b8d0bf94d23.jpg)"
推论10.2,定理,"['第十章  特殊图模型与算法', '§ 10.1 欧拉图与哈密顿图', '10.1.2  哈密顿图及其性质']","{'实体类型': '定理', '内容': '设无向图G是半哈密顿图，则对于V的任意非空子集V1，均有p(G-V1)≤|V1|+1', '应用': '半哈密顿图的必要条件'}",,3,"与哥尼斯堡七桥问题类似，哈密顿图模型也是来源于一个有趣的实例。1856 年，著名的爱尔兰数学家哈密顿在给朋友的信中谈到一个关于如图10-13 所示十二面体的数学问题：把每个结点看成是一个城市，连接两个结点的边看成交通线，能否找到一条旅行线路，沿着交通线经过十二面体的全部20 个城市一次且仅一次，然后再回到原来的出发点？对于这个问题，哈密顿将如图10-13（a）所示十二面体展开成如图10-13（b）所示的图模型，并给出了如图10-12（c）所示的回路，哈密顿图和哈密顿回路由此得名。  
![图10-13 十二面体的数学问题  ](images/f9d9b1ce93d10109a19c31e0468e3a1ce9ead26e329e520a14ed719c39c74609.jpg)  
【定义10.2】经过图中每个结点一次且仅一次的通路称为哈密顿通路。经过图中每个结点一次且仅一次的回路称为哈密顿回路。存在哈密顿回路的图称为哈密顿图；存在哈密顿通路的图称为半哈密顿图。规定平凡图为哈密顿图。  
显然，哈密顿通路是经过图中所有结点的最短通路，即经过图中所有结点的基本通路。哈密顿回路是经过图中所有结点的最短回路，即经过图中所有结点的基本回路。事实上，哈密顿通路就是图中所有结点的一个全排列。  
![图 10-14  哈密顿图与非哈密顿图 ](images/428b9e316b5acee7d3001e928f0a06090173f2550480e12bbb7942d43098f612.jpg)  
例如，在图10-14 中，图$G_{1}$存在哈密顿通路，但是不存在哈密顿回路，故图$G_{1}$是半哈密顿图；图$G_{2}$存在哈密顿回路，故图$G_{2}$是哈密顿图；图$G_{3}$既不存在哈密顿通路，更不存在哈密顿回路，故图$G_{3}$既不是哈密顿图，更不是半哈密顿图。  
相比欧拉图，哈密顿图的研究要困难得多。因为对图中每个结点的遍历需要让每个结点都具有一定数量的边供遍历路径的选择，也是就说对每个结点的度有一定的数量要求，但是这种度的数量又与图模型的具体结构有非常密切且隐含关系。总的来说，就是要求图中结点的度数不能太少且分布比较均衡，但是又很难量化这种条件。因此，目前还没有找到能够直接判定一个图是哈密顿图的充分必要条件。首先给出哈密顿图的一个必要条件：  
【定理10.3】设无向图$G=\langle V,E\rangle$是哈密顿图，则对于𝑉的任意非空子集$.V_{1}$，均有：
$$
p(G-V_{1})\leq|V_{1}|
$$  
其中$p(G-V_{1})$是从图$G$中删除$\cdot V_{1}$后所得图的连通分支数。  
【推论10.2】设无向图$G=\langle V,E\rangle$是半哈密顿图，则$V_{1}$是𝑉的任意非空子集，均有：  
$$
p(G-V_{1})\leq|V_{1}|+1
$$  
定理10.3 和推论10.2 表明，在图中所有结点总度数确定的情况下，要使一个图模型为哈密顿图，就必须使得度数的分配比较均衡。因为如果图的度数集中分布到某一个或某几个结点，则删除这些结点后，会使得图中的边数大量减少，导致图的连通分支数目大量增加，即有 $p(G-V_{1})>|V_{1}|$ 或 $p(G-V_{1})>|V_{1}|+1$ ，此时就违背了上述定理或推论的条件。  
值得注意的是，定理10.3 和推论10.2 是必要而非充分条件。例如，对于图10-16 所示的彼得森图，该图显然满足定理10.3 的条件，但它不是哈密顿图。因此，定理10.3 和推论10.2 主要用于对哈密顿图的证伪。下面给出判定哈密顿图或者半哈密顿图的充分条件：  
【定理10.4】设图$G=\langle V,E\rangle$是任意给定的$n$阶无向简单图，如果对任意两个不相邻的结点$u,v\in V$，均有：  
$$
\deg(u)+\deg(v)\geq n-1
$$  
则图$G$中存在哈密顿通路。  
【定理10.5】（奥尔定理）设图$G=\langle V,E\rangle$是$n$阶无向简单图，如果对任意两个不相邻的结点$u,v\in V$，均有：  
$$
\deg(u)+\deg(v)\geq n
$$  
则图$G$中存在哈密顿回路。  
【定理10.6】（狄拉克定理）设图$G=\langle V,E\rangle$是$n$阶无向简单图，如果对于图中结点𝑣∈𝑉，均有$\deg(v)\geq n/2$ ，则图$G$中存在哈密顿回路。  
定理10.4、定理10.5 和定理10.6 给出了判定哈密顿图的充分条件，其中狄拉克定理可以看成是奥尔定理的一个推论。上述3 个定理表明，如果要使得一个图是哈密顿图，就必须保证图中有足够多的边并分布基本均衡，或者说图中每个结点都要关联足够多的边。不难看出，这些条件是比较强的或者说是比较苛刻的。事实上，这些条件并非必要条件。例如，一条具10 个结点的链显然是半哈密顿图，但该图并不满足定理10.4 的条件，将该链的首尾一条边相连构成的圈图显然是哈密顿图，但并不满足定理10.5 和定理10.6 的条件。"
推论12.1,推论,"['第十二章 典型抽象代数结构', '§ 12.3 同余关系与商群', '12.3.1 同余关系与陪集']","{'实体类型': '推论', '内容': '假设⟨G,*⟩是一个n阶有限群，则G中每个元素的阶均是n的因子且对于∀a∈G有a^n=e'}",,3,"现在我们在群结构的场合考察二元代数结构的同余关系。首先看下面具体实例：  
对于整数加群$\langle Z,+\rangle$，易知$\langle Z_{m},+\rangle$是$\langle Z,+\rangle$一个子群。其中$Z_{m}=\{k m|k\in Z\}$，$m$是任意给定的正整数。我们知道，任意两个整数$a$和$b$具有模$m$同余关系当且仅当$a-b\in Z_{m}$。  
对上述整数加群$\langle Z,+\rangle$上模$m$同余关系进行抽象，就得到如下群上的同余关系：  
【定义12.17】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，对于$\forall a,b\in G$,若有$a*b^{-1}\in H$，则称$a$与$b$具有模${H}$同余关系，记为$a\equiv b({mod{H}})$。  
下面的定理12.3.1 表明模$H$同余关系的确是一个同余关系，即要证明该关系不仅是一个等价关系，而且还对运算$*$具有保持性。  
【定理12.20】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则模${H}$同余关系是$G$上的一个等价关系且对运算${\ast}$具有保持性，即对于$\forall a,b,c\in G$，如果$a\equiv b({\bmod{\ H}})$，则有$a*c\equiv b*c({\bmod{\ H}})$。  
对于群$\langle G,*\rangle$的任意一个子群$\langle H,*\rangle$，既然模$H$同余关系是$G$上的一个等价关系，那么该关系必然确定一个对集合$G$的划分，每个划分块就是该等价关系的一个等价类。由于该等价关系显然由子群$\langle H,*\rangle$确定，因此，对集合的$G$划分也应由子群$\langle H,*\rangle$。为便于考察子群$\langle H,*\rangle$与集合划分的关系，现引入子群$\langle H,*\rangle$陪集的概念，并考察$\langle H,*\rangle$的左右陪集与模${H}$同余关系所确定等价类之间的联系。具体如下：  
【定义12.18】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则对于$\forall a\in G$，称集合$a$ $H=\{a*h|h\in H\}$为子群$\langle H,*\rangle$在群$\langle G,*\rangle$中的一个左陪集，集合$H a=\{h*a|h\in H\}$为子群$\langle H,*\rangle$在群$\langle G,*\rangle$中的一个右陪集，元素$a$为$𝑎$ $H$和$H a$的代表元。  
现在考察如何使用左右陪集实现对群的分解，为此首先引入如下定理：  
【定理12.21】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则对于$\forall a\in G$，其关于$\langle H,*\rangle$的左右陪集的基数相等且等于$ H$的基数，即有$\left|a H\right|=\left|H\right|=\left|H a\right|$。  
由此可见，对于群$\langle G,*\rangle$中的任意一个元素，其关于子群$\langle H,*\rangle$的左右陪集的基数相等且是一个仅与子集$H$有关的常数，即为$|H|$。由此可得如下关于群分解的拉格朗日定理：  
【定理12.22】（拉格朗日定理）设$\langle G,*\rangle$是任意给定的一个有限群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则群$\langle G,*\rangle$的阶一定是其子群$\langle H,*\rangle$阶的倍数，即有$k=|G|/|H|$，其中$k$为正整数且为子群$\langle H,*\rangle$的一切不同左（右）陪集个数。  
拉格朗日定理定理告诉我们：若$\langle G,*\rangle$是有限群，则其子群的阶是群$\langle G,*\rangle$阶的因子。因此，可以通过群与其子群阶的关系考察群的结构及其子群的个数。  
【推论12. 1】假设$\langle G,*\rangle$是一个$ n$阶有限群，则$G$中每个元素的阶均是${n}$的因子且对于$\forall a\in$$G$有$a^{n}=e$.  
【推论12.2】阶为素数的有限群是循环群."
推论12.2,推论,"['第十二章 典型抽象代数结构', '§ 12.3 同余关系与商群', '12.3.1 同余关系与陪集']","{'实体类型': '推论', '内容': '阶为素数的有限群是循环群'}",,3,"现在我们在群结构的场合考察二元代数结构的同余关系。首先看下面具体实例：  
对于整数加群$\langle Z,+\rangle$，易知$\langle Z_{m},+\rangle$是$\langle Z,+\rangle$一个子群。其中$Z_{m}=\{k m|k\in Z\}$，$m$是任意给定的正整数。我们知道，任意两个整数$a$和$b$具有模$m$同余关系当且仅当$a-b\in Z_{m}$。  
对上述整数加群$\langle Z,+\rangle$上模$m$同余关系进行抽象，就得到如下群上的同余关系：  
【定义12.17】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，对于$\forall a,b\in G$,若有$a*b^{-1}\in H$，则称$a$与$b$具有模${H}$同余关系，记为$a\equiv b({mod{H}})$。  
下面的定理12.3.1 表明模$H$同余关系的确是一个同余关系，即要证明该关系不仅是一个等价关系，而且还对运算$*$具有保持性。  
【定理12.20】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则模${H}$同余关系是$G$上的一个等价关系且对运算${\ast}$具有保持性，即对于$\forall a,b,c\in G$，如果$a\equiv b({\bmod{\ H}})$，则有$a*c\equiv b*c({\bmod{\ H}})$。  
对于群$\langle G,*\rangle$的任意一个子群$\langle H,*\rangle$，既然模$H$同余关系是$G$上的一个等价关系，那么该关系必然确定一个对集合$G$的划分，每个划分块就是该等价关系的一个等价类。由于该等价关系显然由子群$\langle H,*\rangle$确定，因此，对集合的$G$划分也应由子群$\langle H,*\rangle$。为便于考察子群$\langle H,*\rangle$与集合划分的关系，现引入子群$\langle H,*\rangle$陪集的概念，并考察$\langle H,*\rangle$的左右陪集与模${H}$同余关系所确定等价类之间的联系。具体如下：  
【定义12.18】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则对于$\forall a\in G$，称集合$a$ $H=\{a*h|h\in H\}$为子群$\langle H,*\rangle$在群$\langle G,*\rangle$中的一个左陪集，集合$H a=\{h*a|h\in H\}$为子群$\langle H,*\rangle$在群$\langle G,*\rangle$中的一个右陪集，元素$a$为$𝑎$ $H$和$H a$的代表元。  
现在考察如何使用左右陪集实现对群的分解，为此首先引入如下定理：  
【定理12.21】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则对于$\forall a\in G$，其关于$\langle H,*\rangle$的左右陪集的基数相等且等于$ H$的基数，即有$\left|a H\right|=\left|H\right|=\left|H a\right|$。  
由此可见，对于群$\langle G,*\rangle$中的任意一个元素，其关于子群$\langle H,*\rangle$的左右陪集的基数相等且是一个仅与子集$H$有关的常数，即为$|H|$。由此可得如下关于群分解的拉格朗日定理：  
【定理12.22】（拉格朗日定理）设$\langle G,*\rangle$是任意给定的一个有限群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则群$\langle G,*\rangle$的阶一定是其子群$\langle H,*\rangle$阶的倍数，即有$k=|G|/|H|$，其中$k$为正整数且为子群$\langle H,*\rangle$的一切不同左（右）陪集个数。  
拉格朗日定理定理告诉我们：若$\langle G,*\rangle$是有限群，则其子群的阶是群$\langle G,*\rangle$阶的因子。因此，可以通过群与其子群阶的关系考察群的结构及其子群的个数。  
【推论12. 1】假设$\langle G,*\rangle$是一个$ n$阶有限群，则$G$中每个元素的阶均是${n}$的因子且对于$\forall a\in$$G$有$a^{n}=e$.  
【推论12.2】阶为素数的有限群是循环群."
描述法,概念,"['二、集合的表示方法', '1、集合表示法（枚举法和描述法）', '1.1.2 集合的概念与表示', '5.1.3 关系的表示', '2.描述法', '第五章 关系模型与理论', '§ 5.1 关系的数学模型', '§ 1.1 集合的基本知识', '第一章  集合与计数基础']","{'实体类型': '概念', '定义': '描述集合中元素所具备的某种特性来表示集合；用集合的描述法表示作为关系的集合', '表示形式': 'A={x|P(x)}', '特点': '表示集合的内涵，是一种隐式表示方法，表达内容具有一定的抽象性和普适性', '优点': '不需要列出集合中全部元素，只需给出集合中元素的描述特性', '表达能力': '很强，既可表示有限集合，也可表示无限集合'}",,5,"所谓描述法，就是描述集合中元素所具备的某种特性来表示集合。通常用数学符号来表示集合中的任意元素都具有性质$P$。集合描述法表示的具体形式如下：  
$$
A=\{x|P(x)\}
$$  
其中：符号$P(x)$表示元素$x$具有性质$P$  
描述法表示的是集合的内涵，是一种隐式表示方法，表达内容具有一定的抽象性和普适性。描述法的优点是不需要列出集合中全部元素，只需给出集合中元素的描述特性。因此，描述法的表达能力很强，既可表示有限集合，也可表示无限集合。"
插入操作,算法,"['第九章  树的基本理论与算法', '§ 9.3 特殊根数与算法', '9.3.1 平衡树模型']","{'实体类型': '算法', '步骤': '插入完成后从插入的结点开始维护到根结点的路径，根据高度差采取不同的旋转策略进行调整'}",,3,"对于二叉树的一些基本操作，比如插入、删除和查找等，其算法时间复杂度都与树的高度有关。因此，适当控制树高是一个非常关键的问题。显然，控制树高的一个有效措施就是尽量保持树的左右子树高度大致平衡，由此产生平衡二叉树的概念。  
平衡二叉树是一种特殊的二叉树，要求树中任何结点的两棵子树高度差不能超过1，如果插入或者删除一个结点使得高度之差大于1，就要进行结点之间的旋转操作，将二叉树重新维持在一个平衡状态。  
平衡二叉树是一种非常重要的树模型，因为它可以保证一些在树上的基本操作具有较好的最坏情况性能，这使它在信息查找等很多场合有着十分重要的作用。后面将会详细介绍平衡二叉树的若干特例，如红黑树、$B$树等。  
平衡二叉树的操作主要有查找、插入和删除结点等。其中插入和删除结点操作可能需要通过一次或多次旋转操作来重新平衡该树，使其满足平衡二叉树的要求。下面简要介绍有关平衡二叉树的一些基本概念和操作。  
树模型中某结点左子树的高度减去该结点右子树的高度，所形成的差值称为该结点的平衡因子，即$\mathrm{Balance~Fector(BF)=}$左子树的高度-右子树的高度。  
平衡二叉树的平衡因子为-1，0 或1。设计平衡二叉树操作算法的关键在于如何使得平衡二叉树保持平衡。以下四种情况下的插入操作可能会导致原有平衡二叉树发生不平衡:  
（1）LL：若某一节点的平衡因子为1，当在其左子树的左子树上插入一个新结点时会导致该结点的平衡因子由1 变为2。  
（2）RR：若某一节点的平衡因子为-1，当在其右子树的右子树上插入一个新结点时会导致该结点的平衡因子由-1 变为-2。  
（3）LR：若某一节点的平衡因子为1，当在其左子树的右子树上插入一个新结点时会导致该结点的平衡因子由1 变为2。  
（4）RL：若某一节点的平衡因子为-1，当在其右子树的左子树上插入一个新结点时会导致该结点的平衡因子由-1 变为-2。  
平衡二叉树有四种基本的旋转方式，分别为：左旋转，右旋转，先左后右旋转，先右后左旋转。针对上述四种情况可能导致的不平衡，可通过旋转的方式使得平衡二叉树恢复平衡，具体做法如下（箭头中数字为子树的高度，结点旁边的数字为其平衡因子）：  
![图 $9{-}30~\mathrm{LL}$  情况旋转](images/ca76734b4d3583b5c59b3d750c1c21778ffd2f87170aec4bd9132947c230f2d0.jpg)  
![图9-31RR 情况旋转 ](images/de09284418b14138ebb993596ee227f73dfbd205bc84b4dc9b8dc270f608bf3d.jpg)  
（1）LL 型调整：插入操作，当三个结点处于一条直线，并均是左结点时(导致LL 情况)需要以中间结点为旋转轴向右侧(顺时针)旋转一次。如图9-30 所示。具体步骤如下：  
步骤一：将 $𝐴$ 的左子树 $B$ 提升为新二叉树的根  
步骤二：将原来的 $𝐴$ 连同其右子树 ${\mathbf{}}A_{R}$ 向下旋转，使其成为 𝐵 的右子树  
步骤三：将$B$的原右子树${B_{R}}$作为左子树连接到𝐴上  
（2）RR 型调整：插入操作，当三个结点处于一条直线，并均是右结点时(导致RR 情况)需要以中间的结点为旋转轴向左侧(逆时针)旋转一次。如图9-31 所示。具体步骤如下：  
步骤一：将 $𝐴$ 的右子树 $B$ 提升为新二叉树的根  
步骤二：将原来的 $𝐴 $连同其左子树 ${}^{;}A_{L}$ 向下旋转，使其成为 $𝐵$ 的左子树  
步骤三：将$\cdot B$的原左子树$B_{L}$作为左子树连接到𝐴上  
（3）LR 型调整：插入操作，当三结点不在一直线且均是左结点时，需以插入结点为旋转轴向左侧(逆时针)旋转一次，然后向右侧(顺时针)旋转一次，即先做RR 操作再做一次LL 操作（在LR 情况，需要先将$B$左旋转，再将𝐴右旋转），如图9-32 所示。具体步骤如下：  
首先执行RR 旋转：  
步骤一：将 $B$ 的右子树 $C$ 提升为新二叉树的“根”  
步骤二：将原来的 $B$ 连同其左子树 ${'}B_{L}$ 向下旋转，使其成为 𝐶 的左子树  
步骤三：将$C$的原左子树$C_{L}$作为右子树连接到$B$上  
然后再执行LL 旋转：  
步骤四：将$𝐴 $的左子树 $C$ 提升为新二叉树的根  
步骤五：将原来的 $𝐴$ 连同其右子树 ${\mathbf{}}A_{R}$ 向下旋转，使其成为 $𝐶$ 的右子树  
步骤六：将𝐶的原右子树$C_{R}$作为左子树连接到𝐴上  
![图9-32 平衡二叉树插入操作LR 情况旋转](images/86ffa77dc86336b0d7814938270d287104a964c00ad6b86a183a77c341a73ccd.jpg)
![图9-33  RL 情况旋转 ](images/73d2aa49589db07f2f0cd8ac54b27db44de079203d670420e8cc6330c886ef14.jpg)  
（4）RL 型调整：插入操作，当三结点不在一直线且均是右结点时，需以插入结点为旋转轴向右侧(顺时针)旋转一次，然后向左侧(逆时针)旋转一次，即先做LL 操作再做一次RR 操作（在RL 情况，需先将$B$右旋转，再将𝐴左旋转）。如图9-33 所示。具体步骤如下：  
首先执行LL 旋转  
步骤一：将 $B$ 的左子树 $C$ 提升为新二叉树的“根”  
步骤二：将原来的 $B$ 连同其右子树 $B_{R}$ 向下旋转，使其成为 $𝐶$ 的右子树  
步骤三：将$𝐶$的原右子树$C_{R}$作为左子树连接到$B$上  
然后再执行 RR  旋转  
步骤四：将 $𝐴$ 的右子树 $C$ 提升为新二叉树的根  
步骤五：将原来的 $𝐴$ 连同其左子树 ${}^{;}A_{L}$ 向下旋转，使其成为 $𝐶$ 的左子树  
步骤六：将$𝐶$的原左子树$C_{L}$作为右子树连接到$𝐴$上 在上述四种旋转基础上，就可对平衡二叉树进行插入和删除操作，具体如下：  
（1）插入操作：插入完成后需要从插入的结点开始维护一个到根结点的路径，每经过一个结点都要维持树的平衡，需要根据高度差的特点采取不同的旋转策略进行调整，使整棵树恢复成为平衡树。  
（2）删除操作：首先定位要删除的结点，删除完成后，要从删除结点的父亲开始向上维护树的平衡一直到根结点，然后采取不同的旋转策略调整，使整棵树恢复成为平衡树。"
插入算法,算法,"['第九章  树的基本理论与算法', '§ 9.3 特殊根数与算法']","{'实体类型': '算法', '应用': '根树模型的基本操作'}",,2,根树是一类非常重要的树模型，能够对很多复杂的数据信息进行表示和处理，广泛应用于程序设计、数据结构、算法设计与分析、操作系统等多门后续课程。根树的种类很多，可以针对不同类型的问题或数据建立相应类型的根树模型。本节着重介绍三种最为典型的特殊根树模型，即平衡树模型、红黑树模型和𝐵树模型，并分析和讨论这些模型的插入、删除、更改、旋转等基本算法，旨在为后续相关专业课程的学习打下良好的基础。
握手定理,定理,"['8.2.2 图模型的度结构', '第八章  图的基本理论与算法', '§ 8.2 图的运算与结构']","{'实体类型': '定理', '应用': '描述图中结点度数的基本数量关系', '内容': '假设 $G=\\\\langle V,E\\\\rangle$ 是任意给定的一个有向图或无向图，则该图中结点度数的总和等于边数的二倍，即有 $\\\\sum_{v\\\\in V}\\\\deg(v)=2|E|$', 'name': '握手定理'}",,2,本节在前述图模型基本概念基础上介绍关于图模型处理的基本知识和方法，包括图模型的集合运算、图模型的度结构性质、图同构的概念及判定方法。对于图模型，可对其定义一些相关运算与操作产生新的图模型并据此实现对问题的分析和求解。此外，结构性质是对图模型进行理解和处理的基本依据，图中结点与边之间显然存在一些基本约束，例如一条边关联且仅关联两个结点，这些约束使得图模型在结构上必须满足一定数量关系，如握手定理，它们构成了图模型最基本的结构性质。最后，本节通过图同构映射的机制考察和处理两个图模型之间在结构上等价关系，同构的图模型具有完全相同的结构性质。
摘香蕉问题,应用,"['第四章  谓词演算与推理', '§ 4.5 谓词逻辑的应用', '4.5.1 摘香蕉问题']","{'实体类型': '应用', '描述': '通过谓词逻辑为猴子规划摘香蕉的行动计划'}",,3,"假设某房间里有一只猴子（不妨设想其为机器人），位于$c$ 点；另有一只箱子，位于$a$点；而在$b$ 点的顶棚上吊着一把香蕉，如图4-2 所示。猴子自然希望能得到这把香蕉，但它因身材矮小够不到，当然，如果它站在箱子上便可如愿。但猴子的智慧尚不能像人那样，对将箱子推到香蕉下，踩在箱子上就可摘到香蕉的解决方案一目了然。试为猴子规划一个能摘到香蕉的行动计划。  
![](images/da6043b2c963f12fe3915d340fe42ec9b81a097c121fa6b1d07e9ec34d8173bb.jpg)
图4-2 猴子与香蕉问题  
可用谓词逻辑进行问题表示和求解。首先定义以下几个谓词：$A T\ (x,\ y)$，表示$x$ 在$y$处”；On_Box 表示“猴子在箱子上面”；Hold_$B$ 表示“猴子已经摘到香蕉”。并规定$x$的个体域为｛猴子、箱子、香蕉｝，$y$的个体域为$\{a,\ b,\ c\}$。则该问题可表示为：  
（1） 初始状态：  
AT（猴子，$a.$）：猴子在$a$ 处；$A T$（箱子，$c$）：箱子在$c$ 处；  
¬On_Box：猴子没有在箱子上面；  
¬Hold_$B$：猴子尚未摘到香蕉。  
（2） 目标状态：  
AT（猴子，$b$）：猴子在$b$ 处；$A T$（箱子，$b$）：箱子在$b$ 处；  
On_Box：猴子在箱子上面；Hold_B：猴子已经摘到香蕉。  
上述谓词只能描述事实性知识。下面再定义几个谓词表示过程性知识：  
Goto$(u,~\nu)$）：猴子从$u$ 处走到$\nu$ 处。  
条件：$A T$（猴子，$u$）为真——猴子必须在$u$ 处；$\neg O n\_B o x$ 为真——猴子不能在箱子上。  
动作：删除$A T$（猴子，$u$）；    增添$A T$（猴子，$\nu_{\cdot}$）。  
（1） pushBox$(\nu,\ \ w)$）：猴子将箱子从$\nu$ 处推到$w$ 处。  
条件：$A T$（猴子，$\nu$）为真——猴子须在$\nu$ 处；  
$A T$（箱子，$\nu$）为真——箱子须在$\nu$ 处；  
$\neg O n\_B o x$ 为真——猴子在箱子下才能推箱子。  
动作：删除$A T$（猴子，$\nu$）、$A T$（箱子，$\nu_{\perp}$）； 增添$A T$（猴子，$w$）、$A T$（箱子，$w$）  
（2） $ClimBox$：猴子爬上箱子。  
条件：AT（猴子，$u$）为真——猴子必须在$u$ 处；  
AT（箱子，$u$）为真——箱子也必须在$u$ 处；  
¬On_Box 为真——猴子不能在箱子上。  
动作：删除 $\neg O n\_B o x$ ；增添 On _ Box  
（3） Grasp：猴子已经摘到香蕉。  
条件：AT（猴子，$b$）为真——猴子必须在$b$ 处；  
AT（箱子，$b$）为真——箱子也必须在$b$ 处；  
On_Box 为真——猴子必须在箱子上；¬Hold_$B$ 为真——猴子没有摘到香蕉。  
动作：删除 ¬ Hold _ B ；   增添 Hold _ B  
可将该问题的状态描述成有序四元组$(\,W,\,x,\,y,\,z\,)$）。其中，$W$表示“猴子的水平位置”；$x$ 表示“猴子是否在箱顶（在则取1，否则为$_{0})$”；$y$ 表示“箱子的水平位置”；$z$ 表示“猴子是否摘到香蕉（摘到取1，否则为0）”。显然，$W$和$y$ 只能取$a$，$b$，$c$三个值，则基于上述操作性的谓词描述，该问题的求解过程即可描述如图4-3 所示。  
![](images/05c5b968cbbbe5fedfad9e5c185e1f46a65784eeb2eace9649980413581f7dfb.jpg)
图4-3 猴子与香蕉问题求解过程  
其实，在基于谓词逻辑思想的人工只能知识表示法中，还有产生式表示法，该表示法在信息识别和判断等诸多领域都有十分广泛的运用，此处不在赘述。"
支持向量机模型,算法,"['第八章  图的基本理论与算法', '§ 8.5 图模型的应用', '8.5.3 机器学习问题']","{'实体类型': '算法', '提出时间': '20世纪90年代中期', '应用': '浅层机器学习'}",,3,"1959 年，美国塞缪尔教授设计了一个具有学习能力的下棋程序。它可在不断对弈中改善自己的棋艺。4 年后，该程序战胜了设计者本人。又过3 年，该程序战胜了美国常胜冠军。由此可以看出机器学习的能力，特别是当下谷歌设计的AlphaGo 程序与围棋大师李世石的围棋大战，更是体现了机器学习的威力。所谓机器学习，就是数学模型或求解算法中具有似于人类的学习机制，能够从实际问题中采集适当样本数据，根据样本数据自动算出参数值，并随着样本数据的变化自动调整参数取值，使得数学模型和求解算法具有良好的普适性和自适应性。按机器学习的模型结构层次来分，机器学习经历了两次浪潮，分别是浅层学习和深度学习。近年来，机器学习的概念异常火爆，各种机器学习算法层出不穷。本小节简要介绍图模型在浅层学习和深度学习中的与应用。  
![图8-73 BP 网络结构](images/3e28bfeab67aaebdd2a54ed46ef1bb594380bb5384ccdde94e5e1d5ae51f9049.jpg)  
![图8-74 支持向量机结构](images/0d16cdb37dc68fb29e3b36be467fd837d3d52e2ccd7acbba9de1c8c373e6974d.jpg)  
无论是浅层学习还是深度学习的模型结构都是基于图模型。  图8-73 所示的图模型是20 世纪80 年代末期提出BP 神经网络模型，图8-74 所示的图模型是20 世纪90 年代中期提出支持向量机模型。 这些都是机器学习中的经典图模型用于浅层的机器学习。 正是这些图模型的建立给机器学习带来了希望，掀起了基于统计模型机器学习热潮。人们使用这类权图模型从大量训练样本中学习统计规律，然后根据学到的规律对未知事件进行预测。  
![图8-75 简单函数对复杂函数的逼近 ](images/fbe962cff1ffa6a7bb0339da768141046705e07e74feba559a3752dfe9c241b2.jpg)  
![图8-76 多层模型表示复杂函数  ](images/272fe3358ea6997e106f1355c74465d9d8b3888427cf64765b441f271abcfeac.jpg)  
然而，进入21 世纪，浅层学习研究的发展遇到瓶颈。从而，人们创立了深度学习的相关概念和理论，并借助分布式云计算的大数据平台，在机器学习领域取得了突破性进展。深度学习通过一种深层非线性网络结构，组合低层特征形成更加抽象的高层表示属性类别或特征，实现由简单函数向复杂函数的有效逼近，以发现数据的分布式特征表示。其具有强大的从少数样本中集中学习数据集本质特征的能力。图8-75 表示一个通过简单函数逼近复杂函数的实例。  
简单地说，深度学习就是对拥有深层结构的模型进行训练。所谓深层结构，是相对于前述的浅层结构而言的，两者的差异主要在于拥有的非线性运算单元的层数不同。深层结构是指非线性转换单元的层数大于或等于两层的模型，而使用多层模型的优势即可以使用较少的参数表示复杂的函数。使用多层模型表示复杂函数的例子如图8-76 所示。  
![图8-77 含多隐含层的深度学习模型图  ](images/a696f4639cd9bb8eadcb3b542d30322c2127fff383c01a8ce40760e85d44b787.jpg)  
![图8-78 自动编码器(AE)结构示意图  ](images/d437ba8ccbf4e13b83ff799a9ddec1778e03cc7629e09224d02fe81a54b359de.jpg)  
深度学习在模型中构建多层隐含层，并通过大量样本训练模型参数，获得更有用的特征，从而有效提升分类或预测的准确性。相比较传统的浅层结构，深度学习更强调了模型结构的深度，通常有5 至6 层隐含层，有的模型结构甚至包含10 层以上隐含层。此外，深度学习明确突出了特征学习的重要性。深度学习实现多层堆叠，每一层的输出作为下一层的输入，高层的特征是低层特征的组合，从低层到高层的特征表示越来越抽象，越来越能表现语义或者意图。而抽象层面越高，存在的可能猜测就越少，就越利于分类。换句话说，深度学习通过逐层特征变换，将样本在原始特征空间表示逐层变换到新的特征空间，从而使分类或预测的效果更加准确。图8-77 表示一个含多隐含层的深度学习模型。事实上，由如图8-78 所示自动编码器组合或其简单变形的模型也可看成是深度结构，例如堆叠自动编码器，稀疏自动编码器等。  
深度学习是机器学习发展的产物。与传统的机器学习方法相比，深度学习优势明显，目前在图像识别、语音识别、自然语言理解等领域得到广泛的应用。"
散列函数,特殊函数,['第七章 函数与特殊函数'],"{'实体类型': '特殊函数', '特点': '用于将数据映射到固定长度的散列值'}",,1,函数是一个在自然科学、工程技术，甚至在某些社会科学中被广泛应用的数学概念，无论在初等数学还是高等数学中，无论在基础课还是专业课中，大家都会经常与函数打交道，以函数为基本工具解决各种各样的数学问题和专业问题。然而，从严格意义角度给函数下个定义并不是一件容易的事情。有人会说，函数不就是一个集合到另外一个集合的映射吗？或者说，函数就是对于某个集合中的任一元素，在另外一个集合中存在唯一元素与之对应。这不就是函数的定义？如果函数是这样定义的话，那么映射或对应又怎么定义呢？这正是函数定义的困难所在。事实上，自函数概念首次被德国数学家被莱布尼茨提出以来，其定义一直没有得到很好地解决，因为没有人能够准确地回答什么叫映射或者对应。直到在集合论和关系理论出现后，人们才以关系理论为工具完美地解决了函数的定义。具体地说，函数就是一种满足单值性要求的特殊二元关系。通过关系模型定义函数，就用关系模型的特性来诠释映射或对应概念的含义。作为关系模型的一个具体应用，本章将从特殊关系的角度来介绍函数的基本知识及其应用，包括函数的基本概念、函数的基本运算，以及若干重要的特殊函数，例如特征函数、散列函数和置换函数等。
数字分析法,算法,"['第七章 函数与特殊函数', '§ 7.4 有限集的置换函数', '7.5.1 哈希查找问题']","{'实体类型': '算法', '定义': '分析关键字中数码分布情况，选择分布均匀的若干位作为存储地址的方法', '应用': '适用于关键字由若干数码组成且各数码分布规律已知的情况'}",,3,"在计算机系统中，数据的存放位置和时间都不能完全确定，此时需要一种有效的方法在有限的存储空间中合理存放数据并且能够实现快速定位查找。此时，如果建立一个关于存储位置和数据关键字的对应关系$f$，就能找给定值$k e y$的像$f(k e y)$。这里的对应关系$f$通常称为哈希函数，这种数据查找方法称为哈希查找。  
例如，如果要建立一张学生成绩表，最简单的方法是以学生的学号作为关键字，1 号学生的记录位置放在第一条，10 号学生的记录位置放在第10 条，以此类推。此时，如果要查看的学号为5 的学生的成绩，则只要取出第5 条记录就可以了.这样建立的表实际上就是一张简单的哈希表，其哈希函数为$f(k e y){=}\ k e y$。然而很多情况下的哈希函数并不如此简单。为了查看的方便，可能会以学生的名字作为关键字。此时，为了能够根据学生的名字直接定位出相应记录所在的位置，需要将这些名字转化为数字，构造出相应的哈希函数，下面给出两个不同的哈希函数：  
（1）考察学生名字的汉语拼音，将其中第一个字母在英语字母表中的序号作为哈希函数值。例如：“蔡军”的汉语拼音第一个字母为字母$C$，因此取03 作为其哈希值。  
（2）考察学生名字的汉语拼音，将其中第一个字母和最后一个字母在英语字母表中的序号之和作为哈希函数值。例如，“蔡军”的汉语拼音第一个字母和最后一个字母分别为$𝐶$和$N$，因此取17 作为其哈希值。  
分别应用这两个哈希函数，成绩表中部分学生名字不同的哈希函数值如表7-7 所示。  
表 7-7
![](images/a45025876fc98ab470bf113421a83e13ab1997baea6e789cdbd16990f25f7ba0.jpg)  
![](images/0f18f81e6e78fd7fb2b0f104794c8a798e21b0531706abe9d65a4f9970f2f012.jpg)  
在哈希表的构造过程中，可能会出现不同的关键字映射到同一地址的情况，即$k e y_{1}\neq$$k e y_{2}$，但$f(k e y_{1})=f(k e y_{2})$，也将这种现象称为冲突和碰撞。实际上，由于哈希函数是把任意长度的字符串映射为固定长度的字符串，冲突必然存在，只能尽可能减少。常见的构造哈希函数的方法有以下几种：  
（1）数字分析法。数字分析法适合于关键字由若干数码组成，同时各数码的分布规律事先知道的情况。具体方法是：分析关键字集合中每个关键字中的每一位数码的分布情况，找出数码分布均匀的若干位作为关键字的存储地址。例如，一个由80 个结点组成的结构，其关键字为6 位十进制数。选择哈希表长度为100，则可取关键字中的两位十进制数作为结点的存储地址。具体采用哪两位数码，需要用数字分析法对关键字中的数码分布情况进行分析。假设结点中有一部分关键字如下：  
$k e y_{1}=301514\;\;;\;\;\;k e y_{2}=303027;\;\;k e y_{3}=301103;\;\;\;k e y_{4}=308329;$ $k e y_{5}=300287;\;\;k e y_{6}=305939;\;\;k e y_{7}=300792;\;\;k e y_{8}=300463\circ878.$  
对上述关键字分析可以发现，关键字的第一位均是3，第二位均是0，分布集中，不适合作为存储地址。而第4 位和第5 位分布均匀，所以该哈希函数可以构造为取第4,5 位作为结点的存储地址。上述8 个节点的散列地址为：  
$f(k e y_{1})=51~~~~f(k e y_{2})=02~~~~f(k e y_{3})=10~~~~f(k e y_{4})=32$ $f(k e y_{5})=28\;\;\;\;\;f(k e y_{6})=93\;\;\;\;\;f(k e y_{7})=79\;\;\;\;\;f(k e y_{8})=46$  
（2）平方取中法。平方取中法是一种比较常用的构造哈希函数的方法，具体是：将关键字求平方后，取其中间的几位数字作为散列地址。由于关键字平方后的中间几位数字和组成关键字的每一位数字都有关，因此产生冲突的可能性较小，最后究竟取几位数字作为散列地址需要由散列表的长度决定。例如，若结构的存储地址范围是1\~999，则取平方值的中间三位，如表7-8 所示。  
表7-8  平方取中法
![](images/3bce2eeb41624a2b374dfdbdb4f5d0a22039c970673844c48a904ace588c42b7.jpg)  
（3）除留余数法。除留余数法取关键字被某个不大于哈希表表长$m$的数$ p$除后所得余数为哈希地址，即$f(k e y)=k e y({\bmod{\ p}})$，其中$p\leq m$。这是一种最简单也是最常用的构造哈希函数的方法。它不仅可以对关键字直接取模（mod），也可在平方取中等运算之后取模。值得注意的是，在使用除留余数法时，对$ p$的选择很重要。若$p$选的不好，容易产生同义词。由经验得知：一般情况下可以选$p$为质数或不包含小于20 的质因素的合数。  
哈希函数中会不可避免的存在冲突。因此，在建造哈希函数时不仅要设定一个“好”的哈希函数，而且要设定一种处理冲突的方法。假设哈希表地址集为$\!\sim\!(n-1)$，冲突是指由关键字得到的哈希地址为𝑗$(0\leq j\leq n-1)$的位置上已有记录，则“处理冲突”就是为该关键字的记录找到另一个“空”的哈希地址。  
在处理冲突的过程中可能得到一个地址序列$h_{i}$，其中，$h_{i}\in[0,\mathfrak{n}-1],\mathrm{i}=1,2,\cdots,\mathtt{k}$。即  
在处理哈希地址的冲突时，若得到的另一个哈希地址${\bf h}_{1}$ 仍然发生冲突，则再求下一个地址$h_{2}$，若$ h_{2}$仍然冲突，再求得$h_{3}$，依此类推，直至$h_{k}$不发生冲突为止，则$h_{k}$为记录在表中的地址。处理冲突的具体方法通常有开放定址法、再哈希法和拉链法，这里不再赘述。"
数学危机,概念,"['第一章  集合与计数基础', '§ 1.1 集合的基本知识', '1.1.1 数学危机与集合论']","{'实体类型': '概念', '原因': '希帕索斯悖论、贝克莱悖论、理发师悖论', '影响': '使得数学理论的正确性面临严峻挑战'}",,3,"众所周知，数学是整个自然科学体系的基础，人们对自然界的认识结论一般需要通过数学演算或数学证明来保证其正确性。打铁还需自身硬，从理论上说，数学既然能够作为一种可以鉴别认识结论真伪的基本工具，那么其自身就不应该有任何错误或矛盾。但实际情况并没有这么简单，千百年来陆续出现的希帕索斯悖论、贝克莱悖论、理发师悖论，使得数学理论的正确性面临一次又一次严峻挑战，历史上称之为数学危机。为拯救数学于危机之中，捍卫数学理论的正确性，无数杰出科学家做了大量深入系统的研究工作。直到在十九世纪初，柯西、维尔斯特拉斯等数学家通过创立极限理论，终于解决了希帕索斯悖论、贝克莱悖论问题，为实数理论和微积分的正确性奠定了坚实的基础。  
但是，极限理论在逻辑上还有需要完善的地方.因为极限概念由自然数定义，要保证极限理论的正确性，首先必须要保证自然数概念及相关理论的正确性。虽然自然数是大家熟知且常用的一个基本概念，大家从小学就开始学习自然数的计数和运算，但是对自然数概念的理解主要还是依靠经验。为保证极限理论的正确性，必须对自然数进行正式的数学定义。数学家冯·诺依曼用集合的方式定义了自然数并取得成功。由此，对整个数学理论体系正确性和无矛盾性的论证就转化为对集合论的正确性和无矛盾性的论证，集合论成为整个数学大厦的根基。尽管卢素提出理发师悖论指出了集合论的局限性，一度动摇了这个根基，但是有惊无险，策莫罗提出的公理化集合论有效解决了理发师悖论问题，不仅稳定了数学根基，而且进一步确立了集合论在整个数学大厦中的基础地位。集合论被誉为十九世纪最伟大的数学成就，集合论的创始人康托被誉为整个十九世纪最伟大的数学家，没有之一。"
数学归纳法第一原理,原理,"['第一章  集合与计数基础', '§ 1.2 可数集与不可数集', '1.2.2 自然数的集合定义', '三、自然数的归纳证明']","{'实体类型': '原理', '条件': '基础步骤：P(0)为真；归纳步骤：对于任意正整数k，如果P(k)为真，则P(k+1)为真', '结论': 'P(n)对一切自然数n均为真'}",,4,"使用归纳法不仅可以实现对自然数集合的一种构造性定义，而且还提供了关于自然数命题的一种有效证明方法，即自然数的归纳证明法。这种证明法两种具体形式，分别基于数学归纳法第一原理和数学归纳法第二原理。  
【数学归纳法第一原理】假设$P(n)$是一个关于自然数$n$ 的命题，若有：  
（1）基础步骤：$P(0)$为真；  
（2）归纳步骤：对于任意正整数$k$，如果$P(k)$为真，则$P(k{+}1)$为真。则$P(n)$对一切自然数$n$ 均为真。  
【证明】假设已经对$P(n)$完成了基础步骤和归纳步骤的证明，但是存在某个自然数$m_{0}$使得 $P(m_{0})$为假。令集合$S$ 为所有使得$P(n)$为假的自然数组成的集合，即：  
$S=\{m|m为自然数且P(m)为假\} $  
由于$\cdot m_{0}\in S$，故𝑆为非空集合，根据定理1.7 中的最小数原理知，$S$中必然存在最小的自然数$s$。由于$P(0)$为真，故$s\neq0$。因此，$s-1$为自然数且不在集合𝑆中，即$P(s-1)$为真。根据归纳假设有$P(s)$为真，这与$s\in S$矛盾！故$P(n)$对一切自然数$n$ 均为真。□  
使用数学归纳法第一原理完成证明的关键在于：首先需要假定对任意一个正整数$k$，$P(\mathrm{k})$为真，然后在此假定下证明$P(k{+}1)$必为真。如果用数学归纳法完成了上述原理中的两  
个步骤，那么就证明了对所有自然数而言$P(n)$为真。  
【数学归纳法第二原理】假设$P(n)$是一个关于自然数$n$ 的命题，若有：  
1）基础步骤：$P(1)$为真；  
（ 2 ）归纳步骤：对于任意正整数 $k$ ，若 $P(1),P(2),\dots,P(k)$ 均为真，则 $P(k{+}1)$ 为真。 则$P(n)$对一切自然数$n$ 均为真。"
数学归纳法第二原理,原理,"['第一章  集合与计数基础', '§ 1.2 可数集与不可数集', '1.2.2 自然数的集合定义', '三、自然数的归纳证明']","{'实体类型': '原理', '条件': '基础步骤：P(1)为真；归纳步骤：对于任意正整数k，若P(1),P(2),…,P(k)均为真，则P(k+1)为真', '结论': 'P(n)对一切自然数n均为真'}",,4,"使用归纳法不仅可以实现对自然数集合的一种构造性定义，而且还提供了关于自然数命题的一种有效证明方法，即自然数的归纳证明法。这种证明法两种具体形式，分别基于数学归纳法第一原理和数学归纳法第二原理。  
【数学归纳法第一原理】假设$P(n)$是一个关于自然数$n$ 的命题，若有：  
（1）基础步骤：$P(0)$为真；  
（2）归纳步骤：对于任意正整数$k$，如果$P(k)$为真，则$P(k{+}1)$为真。则$P(n)$对一切自然数$n$ 均为真。  
【证明】假设已经对$P(n)$完成了基础步骤和归纳步骤的证明，但是存在某个自然数$m_{0}$使得 $P(m_{0})$为假。令集合$S$ 为所有使得$P(n)$为假的自然数组成的集合，即：  
$S=\{m|m为自然数且P(m)为假\} $  
由于$\cdot m_{0}\in S$，故𝑆为非空集合，根据定理1.7 中的最小数原理知，$S$中必然存在最小的自然数$s$。由于$P(0)$为真，故$s\neq0$。因此，$s-1$为自然数且不在集合𝑆中，即$P(s-1)$为真。根据归纳假设有$P(s)$为真，这与$s\in S$矛盾！故$P(n)$对一切自然数$n$ 均为真。□  
使用数学归纳法第一原理完成证明的关键在于：首先需要假定对任意一个正整数$k$，$P(\mathrm{k})$为真，然后在此假定下证明$P(k{+}1)$必为真。如果用数学归纳法完成了上述原理中的两  
个步骤，那么就证明了对所有自然数而言$P(n)$为真。  
【数学归纳法第二原理】假设$P(n)$是一个关于自然数$n$ 的命题，若有：  
1）基础步骤：$P(1)$为真；  
（ 2 ）归纳步骤：对于任意正整数 $k$ ，若 $P(1),P(2),\dots,P(k)$ 均为真，则 $P(k{+}1)$ 为真。 则$P(n)$对一切自然数$n$ 均为真。"
数学结构,概念,"['第十一章  抽象代数结构通论', '§ 11.1 代数结构的基本概念', '11.1.1 数学结构与代数结构']","{'实体类型': '概念', '定义': '由载体、处理机制和处理规则组成的基本要素', '分类': '拓扑结构、代数结构、测度结构、偏序结构'}",,3,"代数结构作为四大基本数学结构之一，它以运算作为处理机制，在整个数学理论体系和计算机数学建模中占据非常重要的作用。代数结构是一种非常古老的数学结构，具有几千年发展历程，从最初初等代数逐步发展到大代数，然后进一步发展到抽象代数，目前正朝着泛代数的方向发展。本小节主要介绍抽象代数的由来及其基本知识结构。  
用计算机解决实际问题，一般需要对问题进行抽象并建立相应的数学模型，然后在此基础上将对实际问题的求解转化为对数学模型的求解。 因此，数学模型是用计算机解决实际问题的基础。现实问题纷繁复杂、变化万千，所建立的数学模型自然也是五花八门，多种多样，让人无所适从。值得欣慰的是，尽管我们面对的数学模型复杂多样，但从结构上看，所有这些数学模型都建立在四种基本的数学结构基础之上。  
这四种基本数学结构分别为：表示元素之间空间关系的拓扑结构，如图模型、树模型就是一些拓扑结构；表示元素之间运算关系的代数结构，如初等代数、向量代数、矩阵代数、命题代数、集合代数等都是代数结构；表示元素规模度量性质的测度结构，如高等数学里函数的微分和积分都是测度结构，它们主要计算面积、体积、弧长、速度等；表示元素之间次序关系的偏序结构，如整数的整除关系、集合的包含关系等偏序关系都是偏序结构。  
任何一个数学结构都是由载体、处理机制和处理规则这三个基本要素组成：  
（1）载体集合 对于任何一个数学结构，需要定义一些抽象的元素作为处理对象，这些抽象元素组成的集合构成数学结构的载体。载体集合是数学结构存在的基础或平台。  
（2）处理机制 为了实现对数学结构载体中元素的处理，需要定义一些处理机制，不同的数学结构具有不同的处理机制。例如：偏序结构是一种关系结构，它以元素之间的次序关系或者比较关系作为处理机制；代数结构是一种运算结构，它以元素之间的运算作为处理机制；拓扑结构是一种分布结构，它以元素之间的空间分布作为处理机制；测度结构则是一种度量结构，它以元素的规模度量作为处理机制。  
（3）处理规则 为使定义出来的数学结构满足一些合理性要求以及能够在处理实际问题中发挥作用，避免出现一些矛盾或荒诞的处理结果，还必须制定一些处理规则对处理机制做一些必要的限制。在现代数学的公理化系统中，通常称这些处理规则称为公理。不同的数学结构具有不同的处理规则，例如偏序结构限制元素之间的关系必须满足自反性、反对称性和传递性，这些限制或者性质构成了偏序结构公理系统；再如代数结构则是规定元素之间的运算必须满足结合律、交换律、分配律等运算性质。  
数学运算最早起源于算术运算，即使用具体的整数或分数进行四则运算。随着科学技术的不断发展，人们逐步意识到这种方法不能满足对一般性规律的认识。因此，采用抽象的字母来代替具体的整数和分数进行运算以获得通用性结果，并称之为代数运算或简称为代数。在微积分出现之前的数千年历史中，对代数运算的研究一直占据数学研究的核心地位。那时人们普遍信奉一种所谓的万能法则，即世界上所有问题都可以转化为数学问题，所有数学问题都可以转化为代数问题，所有代数问题都可以转化为方程问题。  
因此，在很长一段历史时期内，人们对数学的研究基本上都是对代数学的研究，对代数学的研究基本上是方程或方程组解法的研究。解方程是那个时期内所有数学家的中心任务，大家都非常期望能够通过使用代数运算的方法找到方程或方程组的通用求解公式。这种努力在线性方程组领域取得了非常完美的结果，并由初等代数逐步衍生出线性代数。但是，对于一元高次方程通用求解方法的研究并不是很顺利，对于次数高于四次的一元方程始终找不到通用求解公式或求解方法。一些非常著名的数学家，例如欧拉、高斯、拉格朗日等都对此做了大量非常艰苦的研究，但均告失败。  
在寻求五次方程通用求解方法的过程中，年仅17 岁的法国天才少年伽罗瓦在1828 年提出群的概念，运用群的思想证明了五次方程通用求解公式是不存在的，并给出了五次方程系数在满足一定条件下若干特殊解法，由此一举解决了困扰数学家长达200 多年的数学问题。伽罗瓦取得成功的关键在于不仅将运算对象进行抽象化，而且对运算本身进行抽象，在抽象对象和抽象运算的基础上通过构造一些特殊抽象代数结构进行求解。这个思想在当时实在过于超前以至于没有得到柯西、傅里叶、泊松等著名数学家的认可，泊松的判词是“完全不能理解”。 1832 年5 月31 日年仅21 岁的伽罗瓦死于决斗。在决斗之前，他把关于五次方程代数求解的研究成果写成长信，留给了人类。14 年后，法国数学家刘维尔整理并发表了伽罗瓦的遗作，人们才理解并惊叹他那超越时代的天才思想和巧妙构思。  
至此以后，人们对代数的研究内容由方程或方程组的求解技巧转变为对代数运算性质和运算结构的研究，通过对运算和运算对象进行抽象的方式实现对所有运算依其运算性质进行分类或归类，并将伽罗瓦的群论迅速发展成为一门称之为抽象代数结构的崭新数学分支。 抽象代数结构的诞生，把代数学从传统的初等代数发展到现代的抽象代数，由此打开了现代代数学的大门，开创了代数学研究的新纪元。因此，抽象代数结构通常也称为近世代数以区别于之前的初等代数。若无特别说明，我们通常将抽象代数结构简称为代数结构。  
经过一百多年的发展，抽象代数结构已经形成一个如图11-1 所示的知识体系。对于一个代数系统，我们不仅可以主动设计出它的运算并考察相应的运算规则，而且还可以通过分别对其载体集合进行相关改造或运算得到相应的子代数、积代数和商代数，可以通过映射的方式考察不同代数结构之间的区别与联系，还可根据运算性质对代数结构进行分类，形成若干典型抽象代数系统，如群、环、域、格等。  
![](images/37d476cf884c29ed65924bc021cb612de43bab4df8b1196f64e96cad4f61a01f.jpg)
图11-1 抽象代数结构的知识体系  
代数结构作为一种特殊的数学结构，具有载体、处理机制和处理规则这三个基本要素。如前所述，代数结构的载体就是由一些抽象对象为元素组成的集合，并通过运算机制实现对集合中元素的处理。所谓运算，其实就是通过映射的手段从已有元素中构造出新的元素。载体和运算统称为代数结构的成分。代数结构的处理规则即为运算性质。  
既然代数结构的载体是一个集合，那么就可以考虑通过一定方式由这个集合派生出新的集合并据此构造出新的代数结构。例如，可以考察其子集以及在子集上的运算，得到子代数的概念和性质；可以对作为载体的集合做笛卡尔集构成一个新的集合，并在新集合上定义相关运算，得到积代数的概念和性质；可以通过构造等价关系的方法实现对集合载体的划分，构成一个以等价类为元素的商集，并在这个商集上定义相关运算，得到商代数的概念和性质。子代数、积代数和商代数是构造和研究代数结构的基本方法论。  
当然，还可以考察两个代数结构之间的相似性与差异性。对于任意两个代数系统，可以在这两个代数结构的载体(集合)上建立一种保运算的映射，由此考察代数结构之间的联系。如果存在这种保运算映射，则称这两个代数系统同态。如果这种保运算的映射还是双射，则称这两个代数系统同构。同态和同构是考察代数结构之间联系的基本工具。  
依据代数结构的运算性质，可以将各种具体代数结构划分为若干抽象类型。典型的抽象代数结构类型主要有仅含一个二元运算的半群与群、含有两个二元运算的环与域，以及格与布尔代数。这些典型抽象代数结构构成代数结构知识体系的主要内容。"
数理逻辑,原理,"['§ 3.5 命题逻辑的演绎推理', '3.1.1  逻辑与命题逻辑', '§ 3.1 命题的概念与运算', '第三章  命题演算与推理', '第一章  集合与计数基础']","{'实体类型': '原理', '地位': '离散数学的分支之一', '定义': '基于数学符号表达和运算的形式化逻辑, 通过形式化符号系统表示和处理逻辑问题的数学理论, 用数学的方法研究推理', '构成': '最初主要由命题逻辑构成，后来发展到谓词逻辑', '分支': '证明论、模型论、递归论', '特点': '严密无歧义的符号化表达和处理方式', '作用': '在计算机与人工智能的各个领域发挥基础性支撑作用', '重要性': '计算机相关专业人员必须牢固掌握的基础知识', '起源': '由莱布尼茨提出构想，布尔和德摩根发展', '应用': '使逻辑能够像代数一样进行演算', '研究对象': '演绎推理', '研究内容': '推理的形式结构'}",,1,离散数学以各种离散量的概念、关系、结构和运算性质为研究对象，以充分满足计算机相关学科对离散量进行表示和处理的数学需求。正如微积分支撑了作为近代工业文明基础的物理学，离散数学支撑了作为现代信息社会基础的计算机科学。事实上，离散数学是一门综合的数学学科，由多个数学分支组成，包括集合论、数理逻辑、图论、数论、组合分析、代数结构等，分别从不同角度出发研究各种离散量之间数与形的关系。本章比较系统地介绍集合论与计数的基础知识， 它们是学习各个离散数学分支所必备的入门基础。 尽管读者可能已 经从其它途径获悉其中某些概念，但是要想掌握作为支撑整个计算机学科基石的离散数学，就必须重新审视和系统地学习这些入门知识。
数论,概念,['第一章  集合与计数基础'],"{'实体类型': '概念', '地位': '离散数学的分支之一'}",,1,离散数学以各种离散量的概念、关系、结构和运算性质为研究对象，以充分满足计算机相关学科对离散量进行表示和处理的数学需求。正如微积分支撑了作为近代工业文明基础的物理学，离散数学支撑了作为现代信息社会基础的计算机科学。事实上，离散数学是一门综合的数学学科，由多个数学分支组成，包括集合论、数理逻辑、图论、数论、组合分析、代数结构等，分别从不同角度出发研究各种离散量之间数与形的关系。本章比较系统地介绍集合论与计数的基础知识， 它们是学习各个离散数学分支所必备的入门基础。 尽管读者可能已 经从其它途径获悉其中某些概念，但是要想掌握作为支撑整个计算机学科基石的离散数学，就必须重新审视和系统地学习这些入门知识。
整数,概念,"['第二章  整数与算法设计基础', '2.1.1 整数与整数除法', '§ 2.1 整数的基本知识']","{'实体类型': '概念', '定义': ['最基本的离散量和离散结构', '整数相加、相减、相乘的结果都是整数，而除法结果却不一定是整数', '在自然数集中加入每个非零元素的相反数就得到整数集合，整数集中每个元素称为整数'], '作用': '在离散量的度量、计数和算法设计等方面发挥重要的基础性作用', '历史': '具有几千年历史的非常古老的数学分支', '地位': '被认为是思想的体操、数学思维能力的训练工具', '应用': '在散列函数构造、伪随机数生成、信息编码与加密等多个领域得到广泛应用', '研究重点': '运算结果相对比较复杂的除法'}",,1,"整数作为一种最基本的离散量和离散结构不仅是离散数学的研究对象，而且其自身也是研究其它离散结构的一项基本工具，在离散量的度量、计数和算法设计等方面发挥重要的基础性作用。整数是人类最早认识和使用的数，专门研究整数及其性质的整数理论是一个具有几千年历史的非常古老的数学分支。在很长一段时期内，整数理论被认为仅仅是思想的体操、数学思维能力的训练工具，其实用性并没有得到充分重视。著名数学家数学王子高斯就曾给出这样的评价：如果说数学是科学的皇后，那么整数理论则是皇后头上美丽的皇冠。意指其仅仅是漂亮而不够实用。直到20 世纪70 年代基于整数模余运算理论的非对称加密算法被设计出来并取得成功应用，整数理论的实用性才得到广泛重视。事实上，算法概念正是诞生于整数的算术运算，这使得整数理论与计算机算法有着一种天然的紧密联系。计算机学科的诞生与兴起让整数理论这门古老的学科重新焕发出新的生命并得到蓬勃发展。目前，整数理论已经成为算法设计与算法度量的一项基本工具，在散列函数构造、伪随机数生成、信息编码与加密等多个领域得到广泛应用。其实除整数之外，离散数学中很多其它离散结构模型，例如图模型、关系模型、群代数结构模型等，也都是通过相关算法在计算机领域发挥重要作用。因此，算法设计技术是学习与应用离散数学所必备的基本知识。  
综上所述，作为学习离散数学的另一入门基础，本章比较系统地介绍整数理论与算法设计的基本知识，具体包括整除的基本概念与运算性质、模余运算的基础知识、同余方程及其解法、非对称加密算法、算法设计的基本知识、算法设计的基本策略与应用等。"
整数分解,原理,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.2 整数的因数分解']","{'实体类型': '原理', '条件': '基于整除性质', '范围': '针对非负整数，结论可推广到所有整数'}",,3,对于任意两个整数，它们之间可以进行加法运算、减法运算和乘法运算，却不一定能够进行整除运算。因此，我们可以将整除运算作为一个基本工具来考察单个整数的离散结构特征以及整数与整数之间的各种联系。本节首先介绍公因数和公倍数的相关概念与性质，然后给出最大公因数的经典构造算法，最后讨论整数基于整除性质的分解。由于非零整数的正负号不影响其整除性质，因此，不失一般性，以下关于整数的讨论，在默认状态下是针对非负整数范围，所得结论可直接推广到所有整数的范围。
整数加密算法,算法,"['第二章  整数与算法设计基础', '§ 2.2 同余算术及其应用']","{'实体类型': '算法', '属性': '若干经典的'}",,2,前面关于整数理论的讨论主要基于整数整除的概念与性质。由于整除是一个是整数之间一个比较强的约束关系，很多整数都不能满足，因此引入一种具有普适性的带余除法概念，将整数的整除归结为一种余数为0 的特殊带余除法。德国数学家高斯则是从带余除法的角度对整除的概念进行推广，引入同余的概念及相关算术。从带余除法的角度看，同余并非像整除那样要求余数一定为0，而只要求两个整数被某个除数做带余除法后得到的余数相等，这个约束显然比整除的约束宽松很多。同余算术是整理理论一个重要发展并构成初等数论的理论核心，它从在一种比整除约束更为宽松的条件下考察整数的运算及性质并得到很多非常精彩的数论成果，这些成果在整数加密算法设计等多个领域得到广泛应用。本节主要介绍同余算术的概念、性质与应用，具体包括同余关系及其运算、剩余系的概念与性质、同余方程与方程组的求解、若干经典的整数加密算法。
整数理论,原理,['第二章  整数与算法设计基础'],"{'实体类型': '原理', '定义': '专门研究整数及其性质的数学分支', '历史评价': '被认为是漂亮而不够实用', '现代应用': '成为算法设计与算法度量的一项基本工具'}",,1,"整数作为一种最基本的离散量和离散结构不仅是离散数学的研究对象，而且其自身也是研究其它离散结构的一项基本工具，在离散量的度量、计数和算法设计等方面发挥重要的基础性作用。整数是人类最早认识和使用的数，专门研究整数及其性质的整数理论是一个具有几千年历史的非常古老的数学分支。在很长一段时期内，整数理论被认为仅仅是思想的体操、数学思维能力的训练工具，其实用性并没有得到充分重视。著名数学家数学王子高斯就曾给出这样的评价：如果说数学是科学的皇后，那么整数理论则是皇后头上美丽的皇冠。意指其仅仅是漂亮而不够实用。直到20 世纪70 年代基于整数模余运算理论的非对称加密算法被设计出来并取得成功应用，整数理论的实用性才得到广泛重视。事实上，算法概念正是诞生于整数的算术运算，这使得整数理论与计算机算法有着一种天然的紧密联系。计算机学科的诞生与兴起让整数理论这门古老的学科重新焕发出新的生命并得到蓬勃发展。目前，整数理论已经成为算法设计与算法度量的一项基本工具，在散列函数构造、伪随机数生成、信息编码与加密等多个领域得到广泛应用。其实除整数之外，离散数学中很多其它离散结构模型，例如图模型、关系模型、群代数结构模型等，也都是通过相关算法在计算机领域发挥重要作用。因此，算法设计技术是学习与应用离散数学所必备的基本知识。  
综上所述，作为学习离散数学的另一入门基础，本章比较系统地介绍整数理论与算法设计的基本知识，具体包括整除的基本概念与运算性质、模余运算的基础知识、同余方程及其解法、非对称加密算法、算法设计的基本知识、算法设计的基本策略与应用等。"
整数的因数分解,概念,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.2 整数的因数分解', '三、算术基本定理']","{'实体类型': '概念', '定义': '将整数分解成若干因数的乘积的过程', '特点': '素数是构成整数的基本要素'}",,4,"对于是任意给定的两个整数$a$ 和$b$，如果$a$ 能够整除$b$，则通过整数$a$ 实现了对整数$b$的一个分解，即将$b$ 分解成$a$ 和另外一个整数的乘积。现在我们从整除的角度讨论整数的分解问题，亦即整数的因数分解问题。  
我们知道，素数是整个整数中不能够再分解的数，因为素数除了±1和其自身之外，没有其它的非平凡因子。因此，在对整数进行因数分解的过程中可以将素数看出是构成整数的最基本的要素或构件。通过对整数进行到素数层次的因数分解，就可以从整除的角度比较完整地考察整数的基本结构，并由此探究整数的基本性质和基本规律。  
【定理2.12】任何大于1 的正整数$a$，或为一素数，或可以写成若干素数的积，即$a=$$p_{1}p_{2}\cdots p_{b}$，其中$p_{i}(1\leq i\leq b)$是素数。  
[定理2.13] (算术基本定理) 任何大于1 的整数$a$可以唯一表示成
$$
a=p_{1}^{a_{1}}p_{2}^{a_{2}}\cdots p_{k}^{a_{k}}\tag{2-4}
$$  
其中$p_{1},p_{2},\cdots,p_{k}$是素数，$p_{1}<p_{2}<\dots<p_{k}$，$a_{1},a_{2},\cdots,a_{k}$是正整数。  
上述定理给出了整数素数分解的存在性与唯一性，称之为算术基本定理。由此可以看出，整数的素数分解在整数理论以及在整数初等数学中的重要性。  
【定义2.8】若$p_{1},p_{2},\cdots,p_{k}$是素数，$p_{1}<p_{2}<\cdots<p_{k},$，$a_{1},a_{2},\cdots,a_{k}$是正整数，那么称  
$$
a=p_{1}^{a_{1}}p_{2}^{a_{2}}\cdots p_{k}^{a_{k}}\tag{2-6}
$$  
是整数$a$ 的素幂分解式，其中$p_{i}$是素数，$p_{1}<p_{2}<\dots<p_{k}$，$a_{i}$是正整数。【例题2.12】写出51480 的素幂分解式。  
整数的素幂分解式给出了整数一种基于素数的结构表达，在数论研究中具有非常重要的作用。例如，下面两个定理表明，可以使用其素幂分解式计算两个整数的最大公约数和最小公倍数，还可以证明最大公约数和最小公倍数之间的关系。  
【定理2.14】设整数$a,~b$ 的素因子分解式分别为：  
$$
a=p_{1}^{a_{1}}\cdots p_{k}^{a_{k}};\,\,\,b=p_{1}^{b_{1}}\cdots p_{k}^{b_{k}}
$$  
其中$p_{1},\cdots,p_{k}$是互不相同的素数，$a_{1},\cdots,a_{k},\;\;b_{1},\cdots,b_{k}$是非负整数。则有：  
$$
{\operatorname*{gcd}(a,b)=p_{1}^{m i n(a_{1},b_{1})}\cdots p_{k}^{m i n(a_{k},b_{k})\tag{2-7}}}
$$  
$$
{\operatorname{lcm}(a,b)=p_{1}^{m a x(a_{1},b_{1})}\cdots p_{k}^{m a x(a_{k},b_{k})}}\tag{2-8}
$$"
整数的基本知识,概念,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.2 整数的因数分解', '三、算术基本定理']","{'实体类型': '概念', '定义': '研究整数的整除、分解等基本性质和规律'}",,4,"对于是任意给定的两个整数$a$ 和$b$，如果$a$ 能够整除$b$，则通过整数$a$ 实现了对整数$b$的一个分解，即将$b$ 分解成$a$ 和另外一个整数的乘积。现在我们从整除的角度讨论整数的分解问题，亦即整数的因数分解问题。  
我们知道，素数是整个整数中不能够再分解的数，因为素数除了±1和其自身之外，没有其它的非平凡因子。因此，在对整数进行因数分解的过程中可以将素数看出是构成整数的最基本的要素或构件。通过对整数进行到素数层次的因数分解，就可以从整除的角度比较完整地考察整数的基本结构，并由此探究整数的基本性质和基本规律。  
【定理2.12】任何大于1 的正整数$a$，或为一素数，或可以写成若干素数的积，即$a=$$p_{1}p_{2}\cdots p_{b}$，其中$p_{i}(1\leq i\leq b)$是素数。  
[定理2.13] (算术基本定理) 任何大于1 的整数$a$可以唯一表示成
$$
a=p_{1}^{a_{1}}p_{2}^{a_{2}}\cdots p_{k}^{a_{k}}\tag{2-4}
$$  
其中$p_{1},p_{2},\cdots,p_{k}$是素数，$p_{1}<p_{2}<\dots<p_{k}$，$a_{1},a_{2},\cdots,a_{k}$是正整数。  
上述定理给出了整数素数分解的存在性与唯一性，称之为算术基本定理。由此可以看出，整数的素数分解在整数理论以及在整数初等数学中的重要性。  
【定义2.8】若$p_{1},p_{2},\cdots,p_{k}$是素数，$p_{1}<p_{2}<\cdots<p_{k},$，$a_{1},a_{2},\cdots,a_{k}$是正整数，那么称  
$$
a=p_{1}^{a_{1}}p_{2}^{a_{2}}\cdots p_{k}^{a_{k}}\tag{2-6}
$$  
是整数$a$ 的素幂分解式，其中$p_{i}$是素数，$p_{1}<p_{2}<\dots<p_{k}$，$a_{i}$是正整数。【例题2.12】写出51480 的素幂分解式。  
整数的素幂分解式给出了整数一种基于素数的结构表达，在数论研究中具有非常重要的作用。例如，下面两个定理表明，可以使用其素幂分解式计算两个整数的最大公约数和最小公倍数，还可以证明最大公约数和最小公倍数之间的关系。  
【定理2.14】设整数$a,~b$ 的素因子分解式分别为：  
$$
a=p_{1}^{a_{1}}\cdots p_{k}^{a_{k}};\,\,\,b=p_{1}^{b_{1}}\cdots p_{k}^{b_{k}}
$$  
其中$p_{1},\cdots,p_{k}$是互不相同的素数，$a_{1},\cdots,a_{k},\;\;b_{1},\cdots,b_{k}$是非负整数。则有：  
$$
{\operatorname*{gcd}(a,b)=p_{1}^{m i n(a_{1},b_{1})}\cdots p_{k}^{m i n(a_{k},b_{k})\tag{2-7}}}
$$  
$$
{\operatorname{lcm}(a,b)=p_{1}^{m a x(a_{1},b_{1})}\cdots p_{k}^{m a x(a_{k},b_{k})}}\tag{2-8}
$$"
整数除法,概念,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识']","{'实体类型': '概念', '应用': '可以得到整数的素因数分解'}",,2,本节主要介绍整数理论中若干最基本的知识。我们知道，整数相加、相减、相乘的结果都是整数，而除法结果却不一定是整数。因此，整数理论研究的重点自然是运算结果相对比较复杂的除法。通过整数的除法运算可以得到整数的素因数分解，由此我们便可以素数为基本构件来考察或窥探整数的离散结构特征与变化规律。在这个过程中，素数作为构造整数的基本构件，其性质与分布规律自然是整数理论的重要内容。因此，本节内容主要包括整数与整数除法的概念、公因数与公倍数、整数的素因数分解、素数的性质及相关算法等。
整除,概念,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.1 整数与整数除法']","{'实体类型': '概念', '定义': '假设a和b是任意给定的两个整数且a≠0，若存在整数q，满足b=a·q，则称a能整除b，或b能被a整除，记为a|b', '性质': '（1）a|b当且仅当±a|±b；（2）若a|b, b|c，则a|c；（3）若b|ai, i=1, 2, …, k，则b|a1x1+a2x2+…+akxk；（4）若b|a，则bp|ap，此处p是任意非零整数；（5）若b|a，a≠0，则|b|≤|a|'}",,3,"在第一章，我们得到自然数和自然数集的定义。在自然数集中加入每个非零元素的相反数就得到整数集合，整数集中每个元素称为整数。也就是说，对于整数集合$z$，有：  
$$
Z\!=\!\{\cdots\!,\,\!-4,\,\!-3,\,\!-2,\,\!-1,\,0,\,1,\,2,\,3,\,4,\,\cdots\}
$$  
对于整数，我们主要考察其除法运算，包括整除和带余除法，由此可以得到倍数与因子、素数与合数、商与余数的相关概念和性质。  
首先在整数及其乘法运算基础上，考察整除的概念与性质。  
【定义2.1】假设$a$ 和$b$ 是任意给定的两个整数且$a\neq0$，若存在整数$q$，满足$b=a\cdot q($其中“∙”表示普通数乘运算，通常将其省略)，则称$\pmb{a}$ 能整除$\pmb{b}$，或$\pmb{b}$ 能被$\pmb{a}$ 整除，记为a|b。此时，又称$a$ 是$b$ 的因子或$b$ 是$a$ 的倍数。若不存在任何整数$q$，满足$b=a q$，则称$\pmb{a}$ 不能整除$\pmb{b}$，或$\pmb{b}$ 不能被$\pmb{a}$ 整除，记为$a\nmid b$。  
例如：5|25，13 ∤120，7|49，13|0，$^{-3}\vert$-12，9 ∤−56；8 的因子有$\pm1$，$\pm2$，$\pm4$和$\pm8$，7的因子有$\pm1$和$\pm7$。显然，对于任意一个给定的整数$a$，它至少能够被$\pm1$或$\pm n$整除。因此，这四个是$a$ 的因子，称其为$a$ 的平凡因子。$a$ 的其它因子称为非平凡因子。  
【定义2.2】对于任意一个给定的非零整数$a$，若$a\ne\pm1$且没有非平凡因子，则称$a$ 为素数或质数；否则称$a$ 为合数。  
从一定意义上讲，素数是构成整数的基本要素，在整数理论中具有极其重要的地位。若非特别说明，我们所说的素数都是指正素数。2 是第一个正素数，其后还有3, 5, 7, 11,…, 等等。我们还会后续相关内容中详细讨论素数的性质与应用。  
例如，整数2, 3, 5, 7, 11, 13 都是素数，而4, 10, 16, 21 都不是素数。  
对于一个不是很大的整数，显然可用一个比较简单的方法来判定一个大于2 的正整数$b$是否为素数：用从2 到$b-1$的每一个整数去除$b$，如果这些整数都不是$b$ 的因子，那么$b$是素数。注意到：若$a k=b$，则$a$ 或$k$ 小于或等于$\sqrt{b}$。由此可知，如果$b$ 不是素数，那么它必有一个因子$k$ 满足不等式$1<k\leq{\sqrt{b}}$ 。因此，为得到更高的效率，只需在这个范围里检验因子。同样，如果$b$ 有一偶数因子，那么2 一定是该因子的一个因子。因此，在通过2 的整除性检验后，可以跳过所有偶数。要判断一个很大的整数是否为素数则不是一件容易的事情，我们将在本章后续的相关部分具体介绍整数集合中大素数的分布和查找知识。  
整数的整除运算具有如下基本性质：  
【定理2.1】假设$a,b,c$ 是3 个任意给定的整数，则有：  
（1）$a|b$ 当且仅当$\pm a|\pm b$；  
（2）若$a|b,\ b|c$，则 $a|c$；  
（3）若$;b|a_{i},\;\;i=1,\;\;2,\;\;\cdots,\;\;k$，则 $b|a_{1}x_{1}+a_{2}x_{2}+\cdots+a_{k}x_{k}$，此处 $x_{i}(i=1,\ \ 2$，$\cdots,\;\;k)$也是任意的整数；  
（4）若$b|a$，则 $b p|a p$，此处$p$ 是任意非零整数；  
（5）若$b|a$，$a\neq0$，则 $|b|\leq|a|$； 下面仅证明（3）和（5），其余性质的证明与此类似，读者可自行给出。  
根据整除的定义，我们知道任意两个整数之间并不一定满足整除关系。为使整数能够正常进行除法运算，必须对整除概念进行推广。事实上，对于任意两个整数，虽然它们之间不一定具有整除关系，但总存在如下关系：  
【定理2.2】假设$a$ 和$b$ 是任意给定的两个整数且$a\neq0$，则必然存在唯一确定的一对整数$q$ 和$r$，满足下列等式：  
$$
b=a q+r,\;\;0\leq r<|a|\tag{2-1}
$$  
此时称整数$a$ 为除数、$b$ 为被除数、$q$为$b$ 除以$a$的商、$r$为$b$ 除以$a$ 的余数。"
整除性质,性质,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.2 整数的因数分解']","{'实体类型': '性质', '特点': '整数之间可以进行加法、减法、乘法运算，但不一定能够进行整除运算'}",,3,对于任意两个整数，它们之间可以进行加法运算、减法运算和乘法运算，却不一定能够进行整除运算。因此，我们可以将整除运算作为一个基本工具来考察单个整数的离散结构特征以及整数与整数之间的各种联系。本节首先介绍公因数和公倍数的相关概念与性质，然后给出最大公因数的经典构造算法，最后讨论整数基于整除性质的分解。由于非零整数的正负号不影响其整除性质，因此，不失一般性，以下关于整数的讨论，在默认状态下是针对非负整数范围，所得结论可直接推广到所有整数的范围。
文字,概念,"['第三章  命题演算与推理', '§ 3.4 命题公式的范式', '3.4.1 范式的基本概念', '一、析取式与合取式']","{'实体类型': '概念', '定义': '设P是任意一个命题变量，则P和neg P均称为文字，且称P和neg P为互补对'}",,4,"在否定、合取、析取这三个联结词中，否定联结词具有最高的运算优先级，范式中用文字这个概念对其进行封装，规定范式中否定联结词只能作用于单个命题变量。这样就用文字的概念将否定运算封装命题公式范式的内层。下面给出文字概念的定义：  
【定义3.20】设𝑃是任意一个命题变量，则𝑃和$\neg P$均称为文字，且称𝑃和$\neg P$为互补对。由于合取和析取这两个联结词在运算上具有对等性质，也就是说合取运算具有析取运算的所有性质，析取运算也具有合取运算的所有性质。故有如下析取式与合取式的概念：  
【定义3.21】有限个文字的析取称为析取式，也称为子句；有限个文字的合取称为合取式，也称为短语。  
例如， $P$、 $\neg P$是文字、子句、短语； $P\lor Q\lor R$是子句； $P\land Q\land R$是短语。注意：一个命题变元或者其否定既可以是子句，也可以是短语。  
显然，析取式是一个具有两层结构的逻辑表达式，只有否定和析取这两种联结词，内层是否定联结词，外层是析取联结词；合取式也是一个具有两层结构的逻辑表达式，只有否定和合取这两种联结词，内层是否定联结词，外层是合取联结词。"
文氏图法,方法,"['第一章  集合与计数基础', '§ 1.1 集合的基本知识', '1.1.2 集合的概念与表示', '二、集合的表示方法', '4.文氏图法']","{'实体类型': '方法', '命名来源': '以英国数学家文恩的名字命名', '介绍时间': '1881年', '表示方式': '用长方形表示全集，用长方形内部的圆或其他几何图形表示普通集合', '应用': '常用于形象地表示集合之间的关系'}",,5,文氏图（或称文恩图）以英国数学家文恩的名字命名.文恩在1881 年介绍了这种图的使用方法。文氏图用长方形表示全集，用长方形内部的圆或其它几何图形表示普通集合。文氏图常用于形象地表示集合之间的关系。
斯科伦标准型,概念,"['第四章  谓词演算与推理', '§ 4.3 谓词公式的范式', '4.3.2 非等值型范式']","{'实体类型': '概念', '定义': '斯科伦范式的一种标准形式', '类型': '包括∃型前束范式和无∃型前束范式'}",,3,前束范式虽然能够与原谓词公式等值，但是这种范式中的量词的排列不够规整。在谓词逻辑演算或推理中，有时候只需要判断某个公式是否为永真式或者矛盾式，此时并不一定需要等值演算，可以牺牲等值的要求得到一些量词排列更加规整的前束公式或前束范式。例如，可以要求谓词公式中所有存在量词排在所有全称量词的左边，或者保留所有的全称量词而消去所有的存在量词，这些都是所谓斯科伦范式或斯科伦标准型的由来。本小节简要介绍两种基本的斯科伦标准型，即∃型前束范式和无∃型前束范式。
斯科伦范式,概念,"['第四章  谓词演算与推理', '§ 4.3 谓词公式的范式', '4.3.2 非等值型范式']","{'实体类型': '概念', '定义': '一种量词排列规整的前束公式或前束范式', '特点': '存在量词排在全称量词左边或消去所有存在量词'}",,3,前束范式虽然能够与原谓词公式等值，但是这种范式中的量词的排列不够规整。在谓词逻辑演算或推理中，有时候只需要判断某个公式是否为永真式或者矛盾式，此时并不一定需要等值演算，可以牺牲等值的要求得到一些量词排列更加规整的前束公式或前束范式。例如，可以要求谓词公式中所有存在量词排在所有全称量词的左边，或者保留所有的全称量词而消去所有的存在量词，这些都是所谓斯科伦范式或斯科伦标准型的由来。本小节简要介绍两种基本的斯科伦标准型，即∃型前束范式和无∃型前束范式。
斯通定理,定理,"['第十二章 典型抽象代数结构', '§ 12.6 布尔代数基础', '12.6.2 布尔同态与同构']","{'实体类型': '定理', '内容': '有限布尔代数和其所有原子构成的集合的幂集代数同构'}",,3,"将代数系统中同态和同构的概念应用于布尔代数，可定义如下布尔同态与同构：  
【定义12.36】设$\langle B_{1},*,\oplus,^{-},0,1\rangle$和$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$是任意给定的两个布尔代数，如果存在一个从$B_{1}$到$B_{2}$的映射$\psi$: $B_{1}\rightarrow B_{2}$，对$\forall a,b\in L,$，$\psi$满足：  
$\begin{aligned}\psi(a*b)&=\psi(a)\circ\psi(b); \psi(a\oplus b)=\psi(a)\circledast\psi(b);\\\psi(\bar{a})&=\triangle \psi(a); \psi(0)=\alpha; \psi(1)=\beta\end{aligned}$  
则称映射$\psi$是从$\langle B_{1},*,\oplus, ^{-},0,1\rangle$到$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$的一个同态映射，并称$\langle B_{1},*,\oplus, ^{-},0,1\rangle$与$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$为布尔同态。若$\psi$是双射，则称$\psi$是从$\langle B_{1},*,\oplus, ^{-},0,1\rangle$到$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$的一个同构映射，并称$\langle B_{1},*,\oplus, ^{-},0,1\rangle$与$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$为布尔同构。  
有时难以直接讨论或研究某个比较复杂或抽象的布尔代数系统，若能找到一个与之同构的具体布尔代数系统进行研究，就会带来很多方便，例如，如果某个布尔代数和集合代数同构，则可将集合代数作为具体研究对象，从而大大简化对该布尔代数的研究。  
为了给出一个比较重要的关于布尔同构的定理，下面定义一个所谓原子的概念：  
【定义12.37】设$\langle B,*,\oplus, ^{-},0,1\rangle$是任意给定的一个布尔代数，对于$\forall a\in B$且$a\neq0$，如果对于$\forall x\in B$，满足$x*a=a$或$x*a=0$，则称$^{}a$是$\langle B,*,\oplus, ^{-},0,1\rangle$的一个原子或极小元。  
在定义中$a\neq0$表示$a$不是$B$中的最小元，而且对$B$中任一元素${x}$，要么$x$比$a$大，要么$x$和$a$不可比。简言之，除去最小元0 外，不会有任何一个元素$x$比$a$小。下面的例题12.6.7 表明，对于任意给定的一个布尔代数，可能会有多个原子。  
例如，在图12-12（a）中，$b$是最小元，唯一的原子是$a$，同时也是最大元。在图12-12（b）中，$a_{4}$是最小元，$a_{2}$和$a_{3}$都是原子，$a_{1}$是最大元但不是原子。在图12-12（c）中，$b_{8}$是最小元，$b_{5}$，$b_{6}$，$b_{7}$是原子，而$b_{1}$，$b_{2}$，$b_{3}$，$b_{4}$都不是原子。  
![](images/543436e369e6162cc7d12db06777b18d401f37573a58bcd4b6f824c830035b69.jpg)  
图12-12  布尔代数的原子  
基于原子的概念，可以得到如下关于布尔同构的斯通定理：  
【定理12.41】（斯通定理）设$\langle B,*,\oplus,^{-},0,1\rangle$是有限布尔代数，集合$𝑆$是$B$中所有原子构成的集合，那么$\langle B,*,\oplus,^{-},0,1\rangle$和$\langle P(S),\subseteq,\cap,\cup,^{-},\emptyset,S\rangle$同构。"
方幂,概念,"['第十二章 典型抽象代数结构', '§ 12.2 群结构的基本知识', '12.2.1 群的基本概念']","{'实体类型': '概念', '定义': '设⟨G,*⟩是任意给定的一个群，对于∀a∈G和正整数n，a的n次方幂定义为n个a的重复n-1次*运算，记为a^n'}",,3,"如前所述，群代数结构是对幺半群结构在逆元方面的进一步扩充，其具体定义如下：  
【定义12.8】假设$\langle G,*\rangle$是任意给定的一个二元代数结构，如果$\langle G,*\rangle$满足如下性质：  
（1）结合律：对于$\forall x,y,z\in G$，成立：$(x\ \ *y)*z=x\ \ *(y*z)$；  
（2）含单位元：$\exists e\in G$，使得对于$\forall x\in G$，成立$\,\!e*x=x*e=x$；  
（3）运算$*$可逆：对于$\forall x\in G$，都存在$x^{-1}\in G$，使得$x^{-1}*x=x*x^{-1}=e$。  
则称$\langle G,*\rangle$是一个群代数结构，简称为群结构或群。  
从上述定义可知，对于任意给定的非空集合 $G$ 以及该集合上某个二元运算 $*$ ，$\langle G,*\rangle$ 能够 形成一个群结构的充分必要条件是$\langle G,*\rangle$必须满足封闭性、结合律、含幺性和可逆性这四个基本运算性质。例如，对于实数集合及其上的普通加法运算构成的代数结构$\langle R,+\rangle$，显然满足群的四条基本性质，其中0 是其单位元，对于$\forall x\in R$，$-x$是$x$的逆元。但是，对于实数集合及其上的普通乘法运算构成的代数结构$\langle R,\times\rangle$则不是一个群，因为在$\langle R,\times\rangle$中0 没有逆元素。不难发现，对于任意给定的集合$𝐴$，$\langle{ P}(A),\cup\rangle$和$\langle{ P}(A),\cap\rangle$都不能构成群结构，因为在$\langle{ P}(A),\cup\rangle$中$𝐴$没有逆元，在$\langle{P}(A),\cap\rangle$中$\varnothing$没有逆元。  
【定义12.9】设$\langle G,*\rangle$是任意给定的一个群，称$|G|$为$\langle G,*\rangle$的阶，如果$|G|$为有限数，则称  
$\langle G,*\rangle$为有限群，否则$\langle G,*\rangle$为无限群。如果运算$^*$满足交换律，即对于$\forall x,y\in G$，有$x*y=y*$$x$则称群$\langle G,*\rangle$是一个交换群或阿贝尔群。  
【定理12.3】设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$的单位元是$\langle G,*\rangle$中唯一的一个幂等元，若$|G|>1$，则$\langle G,*\rangle$中无零元且满足消去律。  
下面的定理12.2.2 给出了群中逆元素的基本性质：  
【定理12.4】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，有：  
$$
(a^{-1})^{-1}=a\,\exists(a*b)^{-1}=b^{-1}*a^{-1}
$$  
下面的定理12.5 给出了群与方程可解性之间的关系：  
【定理12.5】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，方程$a\circ x=b$和$y\circ a=$$b$在$\langle G,*\rangle$中有且仅有唯一解。  
由于群结构满足结合律，故可类似于半群和含幺半群定义元素的方幂：  
【定义12.10】设$\langle G,*\rangle$是任意给定的一个群，对于$\forall a\in G$和正整数$ n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$ a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个a}
$$  
定义$a^{0}=e$且$a^{-n}=(a^{-1})^{n}$  
从上述定义可以看出，对于一个群结构$\langle G,*\rangle$可以定义其任意整数的方幂运算，包括负指数方幂。因此，对于$G$中的任何一个元素$a$，均可以通过其正方幂、零方幂和负方幂构成一个向胜负两端无限延伸的序列，具体如下：  
$$
\cdots,a^{-n},\cdots,a^{-2},a^{-1},a^{0}\ \ ,a^{1},a^{2},\cdots,a^{n},\cdots
$$  
这些序列显然满足幂的运算法则，即对于任意整数$n$和$m$，有：  
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
如果$\langle G,*\rangle$是一个有限群$\langle G,*\rangle$，则根据运算的封闭性和鸽笼原理易知，在$G$中任意一个元素的无穷多个方幂中，必然至少有两个是相等的。具体地说，对于任意给定的$G$中某个元素$a$，必然存在两个不相等的整数$m$和$|n$，不妨设$m<n$，满足：  
$$
a^n=a^m\text{或}a^{n-m}=e
$$  
此时，可将正整数$n-m$看成是元素$a$方幂变化的一个周期。一般地，有如下定义：  
【定义12.11】设$\langle G,*\rangle$是任意给定的一个群，$e$是该群的单位元，对于$G$中任意给定的某个元素$a$，如果存在正整数$n$，满足$a^{n}=e$，则其中最小的正整数称为元素$a$的周期或阶，记为$|a|$，否则称元素$a$的周期为无限大或元素$a$的阶为无限大。  
例如，对于群$\langle\underline{{6}},+_{6}\rangle$，元素1 的阶为6，元素2 的阶为3，元素3 的阶为2，元素4 的阶为3，元素5 的阶为6，元素0 的阶为1。对于整数集合上的加法群$\langle Z,+\rangle$，显然，除了元素0 的周期为1 之外，其余任一非零元素的周期均为无穷大。事实上，不难看出，对于任何一个群，有且只有其单位元的阶为1。  
下面给出关于元素阶的两个重要性质：  
【定理12.6】有限群$\langle G,*\rangle$的每个元素都有有限阶，且其阶数不超过群的阶数|G|。  
【定理12.7】设$\langle G,*\rangle$为群，$G$中元素$a$的阶为$ k$，那么$a^{n}=e$当且仅当$k$整除$ n$  。"
方幂运算,概念,"['第十二章 典型抽象代数结构', '§ 12.1 半群的概念与性质', '12.1.2  方幂与循环半群']","{'实体类型': '概念', '定义': '对半群和含幺半群载体集合中的任意元素定义其方幂运算', '性质': 'a的n次方幂定义为n个a的重复n-1次*运算'}",,3,"我们知道半群和含幺半群都满足结合律，如果对载体集合中任意给定的某个元素进行多次重复运算，那么得到的运算结果与运算次序无关。也就是说，无论以怎样的次序对该元素进行多次重复运算，其结果仅与该元素和运算次数有关。因此，可对半群和含幺半群载体集合中的任意元素定义其方幂运算，具体如下：  
【定义12.6】假设$\langle G,*\rangle$是任意给定的一个半群，对于$\forall a\in G$和正整数$n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个 a}
$$  
如果$\langle G,*\rangle$是一个含幺半群且$e$是其单位元素，则定义$a^{0}=e$。  
例如，对于实数集合上的加法运算构成的含幺半群$\langle R,+\rangle$，显然有：  
$5^{3}=5+5+5=15;\;\;1^{4}=1+1+1+1=4;\;\;5^{0}=1^{0}=0;\;\;0^{0}=0^{1}=0^{2}=0$  
根据上述定义，显然成立方幂运算法则，即对于任意非负整数$ n$和$m$，有：
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
对于任意一个给定的半群或含幺半群$\langle G,*\rangle$，既然可以对其载体中的任意一个元素构造其任何次方幂，并且根据运算$*$在载体集合$ G$上的封闭性知，该元素所有方幂组成的集合必然是$G$的一个子集，那么自然就需要考察该子集以及运算$*$在该子集上的运算性质。下面的定理12.1 表明运算$*$可以在该子集上构成子半群或子含幺半群：  
【定理 12.1 】设 $\langle G,*\rangle$ 是任一给定的半群且对 $\forall a\in G$ ，令 $H=\{a^{n}|n\in Z^{+}\}$ ，则 $\langle H,*\rangle$ 是 $\langle G,*\rangle$的子半群。此时，若$\langle G,*\rangle$是含幺半群，则$\langle H,*\rangle$是$\langle G,*\rangle$的子含幺半群。  
如果$\langle G,*\rangle$是一个含幺半群，设$e$为其单位元。由于$e=a^{0}\in H$，故$e$也是$\langle H,*\rangle$的单位元。因此，$\langle H,*\rangle$也是一个含幺半群。  
从上述定理可知，对于任一给定的半群或含幺半群$\langle G,*\rangle$，载体集合$G$中任一给定元素$a$的所有方幂组成的集合$ H$可与运算$*$一起构成一种半群或含幺半群$\langle H,*\rangle$。事实上，$\langle H,*\rangle$是一种特殊的半群或含幺半群，其特殊性在于载体集合中$H$每个元素都是给定元素$a$的某个方幂。现在考察这种特殊半群或含幺半群的基本概念和性质，首先给出如下定义：  
【定义12.7】设$\langle G,*\rangle$是任一给定的半群，如果$\exists a\in G$，使得$G$中的任意元素$x$都能够写成元素$a$的方幂形式，即对于$\forall x\in G$，$\exists n\in N$,使得$x=a^{n}$，则称$\langle G,*\rangle$是一个循环半群，并称$a$是$\langle G,*\rangle$的一个生成元，$\langle G,*\rangle$的所有生成元组成的集合$C$称为$\langle G,*\rangle$的生成集。此时，如果$\langle G,*\rangle$还是一个含幺半群，则称$\langle G,*\rangle$是一个循环含幺半群。  
【定理 12.2】每个循环半群都是可交换半群。"
旋转操作,算法,"['第九章  树的基本理论与算法', '§ 9.3 特殊根数与算法', '9.3.1 平衡树模型']","{'实体类型': '算法', '作用': '使平衡二叉树恢复平衡', '类型': 'LL型调整，RR型调整，LR型调整，RL型调整'}",,3,"对于二叉树的一些基本操作，比如插入、删除和查找等，其算法时间复杂度都与树的高度有关。因此，适当控制树高是一个非常关键的问题。显然，控制树高的一个有效措施就是尽量保持树的左右子树高度大致平衡，由此产生平衡二叉树的概念。  
平衡二叉树是一种特殊的二叉树，要求树中任何结点的两棵子树高度差不能超过1，如果插入或者删除一个结点使得高度之差大于1，就要进行结点之间的旋转操作，将二叉树重新维持在一个平衡状态。  
平衡二叉树是一种非常重要的树模型，因为它可以保证一些在树上的基本操作具有较好的最坏情况性能，这使它在信息查找等很多场合有着十分重要的作用。后面将会详细介绍平衡二叉树的若干特例，如红黑树、$B$树等。  
平衡二叉树的操作主要有查找、插入和删除结点等。其中插入和删除结点操作可能需要通过一次或多次旋转操作来重新平衡该树，使其满足平衡二叉树的要求。下面简要介绍有关平衡二叉树的一些基本概念和操作。  
树模型中某结点左子树的高度减去该结点右子树的高度，所形成的差值称为该结点的平衡因子，即$\mathrm{Balance~Fector(BF)=}$左子树的高度-右子树的高度。  
平衡二叉树的平衡因子为-1，0 或1。设计平衡二叉树操作算法的关键在于如何使得平衡二叉树保持平衡。以下四种情况下的插入操作可能会导致原有平衡二叉树发生不平衡:  
（1）LL：若某一节点的平衡因子为1，当在其左子树的左子树上插入一个新结点时会导致该结点的平衡因子由1 变为2。  
（2）RR：若某一节点的平衡因子为-1，当在其右子树的右子树上插入一个新结点时会导致该结点的平衡因子由-1 变为-2。  
（3）LR：若某一节点的平衡因子为1，当在其左子树的右子树上插入一个新结点时会导致该结点的平衡因子由1 变为2。  
（4）RL：若某一节点的平衡因子为-1，当在其右子树的左子树上插入一个新结点时会导致该结点的平衡因子由-1 变为-2。  
平衡二叉树有四种基本的旋转方式，分别为：左旋转，右旋转，先左后右旋转，先右后左旋转。针对上述四种情况可能导致的不平衡，可通过旋转的方式使得平衡二叉树恢复平衡，具体做法如下（箭头中数字为子树的高度，结点旁边的数字为其平衡因子）：  
![图 $9{-}30~\mathrm{LL}$  情况旋转](images/ca76734b4d3583b5c59b3d750c1c21778ffd2f87170aec4bd9132947c230f2d0.jpg)  
![图9-31RR 情况旋转 ](images/de09284418b14138ebb993596ee227f73dfbd205bc84b4dc9b8dc270f608bf3d.jpg)  
（1）LL 型调整：插入操作，当三个结点处于一条直线，并均是左结点时(导致LL 情况)需要以中间结点为旋转轴向右侧(顺时针)旋转一次。如图9-30 所示。具体步骤如下：  
步骤一：将 $𝐴$ 的左子树 $B$ 提升为新二叉树的根  
步骤二：将原来的 $𝐴$ 连同其右子树 ${\mathbf{}}A_{R}$ 向下旋转，使其成为 𝐵 的右子树  
步骤三：将$B$的原右子树${B_{R}}$作为左子树连接到𝐴上  
（2）RR 型调整：插入操作，当三个结点处于一条直线，并均是右结点时(导致RR 情况)需要以中间的结点为旋转轴向左侧(逆时针)旋转一次。如图9-31 所示。具体步骤如下：  
步骤一：将 $𝐴$ 的右子树 $B$ 提升为新二叉树的根  
步骤二：将原来的 $𝐴 $连同其左子树 ${}^{;}A_{L}$ 向下旋转，使其成为 $𝐵$ 的左子树  
步骤三：将$\cdot B$的原左子树$B_{L}$作为左子树连接到𝐴上  
（3）LR 型调整：插入操作，当三结点不在一直线且均是左结点时，需以插入结点为旋转轴向左侧(逆时针)旋转一次，然后向右侧(顺时针)旋转一次，即先做RR 操作再做一次LL 操作（在LR 情况，需要先将$B$左旋转，再将𝐴右旋转），如图9-32 所示。具体步骤如下：  
首先执行RR 旋转：  
步骤一：将 $B$ 的右子树 $C$ 提升为新二叉树的“根”  
步骤二：将原来的 $B$ 连同其左子树 ${'}B_{L}$ 向下旋转，使其成为 𝐶 的左子树  
步骤三：将$C$的原左子树$C_{L}$作为右子树连接到$B$上  
然后再执行LL 旋转：  
步骤四：将$𝐴 $的左子树 $C$ 提升为新二叉树的根  
步骤五：将原来的 $𝐴$ 连同其右子树 ${\mathbf{}}A_{R}$ 向下旋转，使其成为 $𝐶$ 的右子树  
步骤六：将𝐶的原右子树$C_{R}$作为左子树连接到𝐴上  
![图9-32 平衡二叉树插入操作LR 情况旋转](images/86ffa77dc86336b0d7814938270d287104a964c00ad6b86a183a77c341a73ccd.jpg)
![图9-33  RL 情况旋转 ](images/73d2aa49589db07f2f0cd8ac54b27db44de079203d670420e8cc6330c886ef14.jpg)  
（4）RL 型调整：插入操作，当三结点不在一直线且均是右结点时，需以插入结点为旋转轴向右侧(顺时针)旋转一次，然后向左侧(逆时针)旋转一次，即先做LL 操作再做一次RR 操作（在RL 情况，需先将$B$右旋转，再将𝐴左旋转）。如图9-33 所示。具体步骤如下：  
首先执行LL 旋转  
步骤一：将 $B$ 的左子树 $C$ 提升为新二叉树的“根”  
步骤二：将原来的 $B$ 连同其右子树 $B_{R}$ 向下旋转，使其成为 $𝐶$ 的右子树  
步骤三：将$𝐶$的原右子树$C_{R}$作为左子树连接到$B$上  
然后再执行 RR  旋转  
步骤四：将 $𝐴$ 的右子树 $C$ 提升为新二叉树的根  
步骤五：将原来的 $𝐴$ 连同其左子树 ${}^{;}A_{L}$ 向下旋转，使其成为 $𝐶$ 的左子树  
步骤六：将$𝐶$的原左子树$C_{L}$作为右子树连接到$𝐴$上 在上述四种旋转基础上，就可对平衡二叉树进行插入和删除操作，具体如下：  
（1）插入操作：插入完成后需要从插入的结点开始维护一个到根结点的路径，每经过一个结点都要维持树的平衡，需要根据高度差的特点采取不同的旋转策略进行调整，使整棵树恢复成为平衡树。  
（2）删除操作：首先定位要删除的结点，删除完成后，要从删除结点的父亲开始向上维护树的平衡一直到根结点，然后采取不同的旋转策略调整，使整棵树恢复成为平衡树。"
旋转算法,算法,"['第九章  树的基本理论与算法', '§ 9.3 特殊根数与算法']","{'实体类型': '算法', '应用': '根树模型的基本操作'}",,2,根树是一类非常重要的树模型，能够对很多复杂的数据信息进行表示和处理，广泛应用于程序设计、数据结构、算法设计与分析、操作系统等多门后续课程。根树的种类很多，可以针对不同类型的问题或数据建立相应类型的根树模型。本节着重介绍三种最为典型的特殊根树模型，即平衡树模型、红黑树模型和𝐵树模型，并分析和讨论这些模型的插入、删除、更改、旋转等基本算法，旨在为后续相关专业课程的学习打下良好的基础。
无∃型前束范式,概念,"['第四章  谓词演算与推理', '§ 4.3 谓词公式的范式', '4.3.2 非等值型范式', '二、无∃型前束范式']","{'实体类型': '概念', '定义': '仅保留全称量词的前束范式', '构造方法': '将谓词公式转化为前束型公式，再转化为无∃型前束公式，最后将母式部分转化为析取范式或合取范式'}",,4,"另外一种斯科伦范式是仅保留全称量词的前束范式，称之为无∃型前束范式。对于任意一个谓词公式，可由下列方法构造其无∃型前束范式：  
第一步  将该谓词公式转化为前束型公式。  
第二步  将前束型公式转化为无$∃$型前束公式：在含有存在量词的前束型公式中，从左边数第一个存在量词开始，依次消除每个存在量词。消除的规则如下：如果存在量词$\exists x$的左边有$n$个全称量词，则任取一个新的以这些全称量词的指导变元为自变量的𝑛元个体函数取代谓词公式中的所有$x$的出现。特别地，当$n=0$时，即$\exists x$的左边无全称量词，则在消除$\exists x$后，以论域中某个未在公式中出现的个体常量取代谓词公式中的所有$\cdot_{x}$的出现。  
第三步  将无∃型前束型公式中不含量词的部分，即母式部分转化为析取范式或合取范式，便可得到所求的无∃型前束范式。  
【定理4.5】假设$G$ 是任意一个谓词公式，则可将$G$ 转化为一个无∃型前束范式，并且$G$ 是永假公式当且仅当其无∃型前束范式也是一个永假公式。  
该定理表明永假式与其无∃型前束范式等值，当一个谓词公式为永假式时，便可使用其无∃型前束范式进行谓词演算和推理。"
无向图,概念,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.2 图的定义与分类']","{'实体类型': '概念', '定义': '每条边都是无向边的图'}",,3,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)"
无向图关联矩阵,定义,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.3 图的表示方法', '二、关联矩阵表示法']","{'实体类型': '定义', '定义': '无向图的关联矩阵用数字2表示结点与边的自环关系，每条非自环边关联2个结点，矩阵中每列元素之和必为2'}",,4,"除了邻接矩阵外，还可以用关联矩阵表示图。关联矩阵主要表示图中每个结点与每条边之间的相关关系。对于任意给定的一个图模型$G$，其关联矩阵$M(G)$中元素$m_{i j}$的含义是图中结点$v_{i}$是否关联边$e_{j}$，如果$v_{i}$不关联$e_{j}$，则$m_{i j}=0$，如果$v_{i}$关联$e_{j}$，则用某个非零数字表示$m_{i j}$，具体数字依据图模型的类型和点边关联方式确定。  
与邻接矩阵一样，要确定一个图的关联矩阵，首先应对图中的所有结点进行编号，不同的结点编号对应于不同的关联矩阵，结点编号次序的交换对应于关联矩阵中行的交换。  
首先给出无向图关联矩阵的定义：  
【定义8.8】设$G=\langle V,E\rangle$是无向图 ，其中$\ V=\{v_{1},v_{2},\ldots,v_{n}\}$，$E=\{e_{1},e_{2},\dots,e_{m}\}$ ，则将$n\times m$阶矩阵$(m_{i j})_{n\times m}$称为 $G$ 的关联矩阵，记为 $M(G)$ 。其中元素$m_{i j}$ 表示图中结点 $v_{i}$ 与边 $e_{j}$ 的关联次数，具体定义如下：
$$
m_{ij}=\begin{cases}2,v_i的自环是e_j\\[2ex]1,v_i关联e_j且e_j不是自环\\[2ex]0,v_{i}不关联e_{j}\end{cases}
(i=1,2,\cdots,n,\quad j=1,\:2,\:...,\:m)(8-2)
$$  
从上述定义可以看出，无向图的关联矩阵用数字2 表示结点与边的自环关系，因为自环须与其关联结点关联 2  次。  
下面给出有向图关联矩阵的定义：  
【定义8.9】设 $D=\langle V,E\rangle$是有向图，其中 $V=\{v_{1},v_{2},\ldots,v_{n}\}$ ，$E=\{e_{1},e_{2},\dots,e_{m}\}$ ，则将${}n\times m$阶矩阵$(m_{i j})_{n\times m}$称为有向图 $D$ 的关联矩阵，记作 $M(D)$ 。 其中元素 $m_{i j}$ 表示图中结点 $v_{i}$ 与边 $e_{j}$ 的关联情况，具体定义如下：  
$$
m_{ij}=\begin{cases}-2,&v_i\text{为其关联自环}e_j\text{的起点和终点}\\1,&v_i\text{为其关联边}e_j\text{的起点但不是终点}\\-1,&v_i\text{为其关联边}e_j\text{的终点但不是起点}\\0,&v_i\text{不关联边}e_j\end{cases}
$$  
从上述定义可以看出，有向图的关联矩阵用数字−2表示结点与边的自环关系。事实上，有时候也可以用2 表示。因为有向图的自环是有方向的，即顺时针或逆时针方向。习惯上，用正数表示逆时针方向，负数表示顺时针方向。图中的自环默认为顺时针方向，故一般用−2表示结点与边的自环关系。  
对于无向图及其关联矩阵，由于每条非自环边关联2 个结点，故矩阵中每列元素之和必为2。而对于有向图及其关联矩阵，由于每条非自环有向边关联2 个结点，且一个为起点一个为终点，故图中每个非自环边在关联矩阵中所对应列元素之和必为0。  
因此，可以通过分析关联矩阵的数据特征分析来分析图中结点与边之间的结构信息。例如，对于任意一个关联矩阵，如果某行元素全为零，当且仅当该行所对应的结点为孤立结点。 再如，如果第 $j$列与第 $k$列相同，当且仅当 $e_{j}$ 与 $e_{k}$ 是平行边，或者说重边对应的列完全相同。 后面将经常使用关联矩阵分析图模型的各种结构特征。"
无向图的生成树,概念,"['第九章  树的基本理论与算法', '§ 9.1 无向树的基本知识', '9.1.2 无向图的生成树']","{'实体类型': '概念', '定义': '假设G是任意给定的一个无向图模型，若G的某个生成子图是树，则称该树为G的一个生成树', '特点': '生成树中的每条边均称为树枝；G中不在生成树中的每条边均称为弦；生成树的所有弦的集合称为生成树的补', '存在性条件': '无向连通图存在生成树的充分必要条件是图是连通的', '构造方法': '破圈法和避圈法'}",,3,"如前所述，树模型是大自然赐予的一种最简洁最高效的连通无向图，任意两个结点之间有且仅有一条路径联结。因此，在对一般连通无向图进行化简的时候，经常会删除图的一些边将其转化为树结构的生成子图。这种生成子图称为无向图的生成树，其定义如下：  
【定义9.2】假设$G=\langle V,E\rangle$是任意给定的一个无向图模型，若$G$的某个生成子图是树，则称该树为$G$的一个生成树，记为$T_{G}$。生成树$T_{G}$中的每条边均称为树枝；$G$中不在$T_{G}$中的每条边均称为弦；$T_{G}$的所有弦的集合称为生成树的补。  
例如，对于图9-3(a)所示的图$G_{1}$无向图，$G_{2}$和$G_{3}$为该图的两棵不同构的生成树。对于图9-3(b)所示生成树$G_{2}$，边$\mathtt{e}_{2},\mathtt{e}_{3},\mathtt{e}_{4},\mathtt{e}_{5}$ 是其树枝，而$\mathsf{e}_{1},\,\mathsf{e}_{6}$ 是其弦；对于图9-3(c)所示的生成树$G_{3}$，$\mathsf{e}_{1},\mathsf{e}_{2},\mathsf{e}_{4},\mathsf{e}_{5}$ 是其树枝，而$\mathsf{e}_{3},\,\mathsf{e}_{6}$ 是其弦。  
![图9-3 连通无向图及其生成树  ](images/3447e9802eaf794918ba03e412f68817eae23f2621102647ed094020348d10e0.jpg)  
显然，对于一个无向连通图$G$，如果$G$本身就是树，则其生成树就是它自己，因而是唯一的。但是，如果$G$不是树，则其生成树就不是唯一的。下面的定理9.3 保证了无向连通图模型生成树的存在性，为无向连通图的化简提供了坚实的基础：  
【定理9.3】假设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$存在其生成树$T_{G}=\langle V_{T}\,,\,\,\,E_{T}\rangle$的充分必要条件是$G$是连通的。  
事实上，上述定理证明过程给出了构造生成树的一种具体算法，通常称之为破圈法。该算法的关键是判断图$G$中是否有回路。若有回路，则删除回路中的一条边，直到图中无回路为止。假设图$G$中有${n}$个结点和$m$条边，则由生成树结点与边的关系知，要构造该图的生成树，必需删除$m-n+1$条边。  
此外，由于含$_n$个结点和$m$条边无向连通图$G=(n,m)$一定存在生成树，且生成树中必有$n$个顶点，$n-1$条树枝和$m-n+1$条弦。因此，在$G$中选择不构成任何回路的$n-1$条边就一定可以得到$G$的一个生成树。这种构造生成树的方法，通常称为避圈法。  
![图9-4 构造生成树的破圈法与避圈法  ](images/6583966484122e279921cd749c7234aa541872b9fc25864834c494c7d9d17e62.jpg)  
破圈法和避圈法需要找出回路或验证不存在回路，计算量通常较大。由于在对一般连通无向图进行广度遍历搜索的时候，会自然形成一个无回路的连通生成子图，即该图生成树。因此，可以通过广度优先遍历算法构造生成树。该算法无需判断回路，因而具有较高的计算效率，比较适合计算机处理。对于连通图$G=\langle V,E\rangle$，该算法的具体过程如下：  
（1）任选$s\in V$，将$s$标记为0，令$L=\{s\},\;V=V-\{s\},k=0$；  
（2）如果$v=\varnothing$，则转（4），否则令$\cdot k=k+1$；  
（3）依次对$L$中的所有标记为$k-1$的结点$v$，如果它与𝑉中的结点𝑤相连接，则将𝑤标记为$k$，指定$v$为$w$的前驱，令$L=L\cup\{w\}$，转（2）；  
（4）$E_{G}=\big\{(v,w)\big|w\in L-\{s\},v\big\}$𝑤的前驱}结束。"
无向图结点度,定义,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.2.2 图模型的度结构']","{'实体类型': '定义', '内容': '假设图 $G=\\\\langle V,E\\\\rangle$ 是任意给定的一个无向图，对于 $G$ 中任意一个结点 $v$ ，与该结点关联边的条数称为该结点的度数，简称为度，记为 ${\\\\sf d e g}(v)$。图 $G$ 中各个结点度数的最大值称为图 $G$ 的最大度，记为 $\\\\Delta(G)$；图 $G$ 中各个结点度数的最小值称为图 $G$ 的最小度，记为 $\\\\delta(G)$'}",,3,"现在我们考察图模型的结构特征。从结构上看，对于任意给定的一个图模型，只要该图不是零图，总会有一些点与一些边相互联结。从生成子图的概念可以看出，图的结点构成了图模型的骨架或主体结构，因此，我们主要从结点出发考察每个结点所关联的边关联多少条边。为此，对于图中的每个结点，都定义一个数来描述该结点所关联边的个数，这就是结点度的概念，其具体定义如下：  
【定义8.16】假设图 $G=\langle V,E\rangle$是任意给定的一个无向图，对于$G$中任意一个结点 $v$ ，与该结点关联边的条数称为该结点的度数，简称为度，记为 ${\sf d e g}(v)$。图$G$中各个结点度数的最大值称为图$G$的最大度，记为$\Delta(G)$；图$G$中各个结点度数的最小值称为图$G$的最小度，记为$\delta(G)$ $\Delta(\mathrm{G})=\mathrm{max}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\};\,\,\,\delta(\mathrm{G})=\mathrm{min}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\}\,.$  
【定义8.17】设图 $G=\langle V,E\rangle$是任意给定的一个有向图，$v$是$G$中任一结点，则有：  
（1）以该结点为起点的有向边的条数，称为该结点的出度，记为$\deg^{+}(v)$；以该结点为终点的有向边的条数，称为该结点的入度，记为 $\deg^{-}(v)$。  
（2）该结点的出度与入度之和称为该结点的度，记为${\sf d e g}(v)$。 即有：  
$$
\deg(v)=\deg^{+}(v)+\deg^{-}(v)
$$  
（3）图$G$中各个结点出度与入度的最大值分别称为图$G$的最大出度和最大入度，分别记为$\Delta^{+}(\mathsf{G})$和 $\Delta^{-}(\mathsf{G})$；图$G$中各个结点出度与入度的最小值分别称为图$G$的最小出度和最小入度，分别记为$\Delta^{+}(\mathbf{G})$和 $\Delta^{-}(\mathsf{G})$，即有：  
$\Delta^{+}(\mathrm{G})=\operatorname*{max}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\Delta^{-}(\mathrm{G})=\operatorname*{max}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$ $\delta^{+}(\mathrm{G})=\operatorname*{min}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\delta^{-}(\mathrm{G})=\operatorname*{min}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$  
从上述定义可以看出，引入度结点度概念的目的主要是通过对图中每个结点所关联边数进行统计分析来考察图模型的结构特征。  
【定义8.18】对于任意一个给定的有向图或无向图  $G=\langle V,E\rangle$ ，图中度数为1 的结点称为该图的悬挂结点，图中以悬挂结点为端点的边称为该图的悬挂边。如果图$G$中各个结点的度数均相同，则称该图正则图，各结点度均为$\ k$的正则图称为$\pmb{k}$-正则图。  
下面我们考察图的邻接矩阵与图中结点度之间的关系。  
假设 $G=\langle V,E\rangle$是任意给定的一个有向图或无向图，其中$V=\{v_{1},v_{2},\ldots,v_{n}\}$，$E=$$\{e_{1},e_{2},\ldots,e_{m}\}$。 $G$的邻接矩阵为：  
$$
A=(a_{i j})_{n\times n}=\left(\!\!{\begin{array}{c c c c}{a_{11}}&{a_{12}}&{\ldots}&{a_{1n}}\\ {a_{21}}&{a_{22}}&{\ldots}&{a_{2n}}\\ {\vdots}&{\ddots}&{\vdots}\\ {a_{n1}}&{a_{n2}}&{\ldots}&{a_{n n}}\end{array}}\!\!\right)
$$  
则有如下结论：  
（1）如果$G$是无向图，那么邻接矩阵𝐴中第𝑖行元素之和表示结点$v_{i}$的度数，第𝑗列元素之和表示结点$v_{j}$的度数。即有：  
$$
\deg(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};~~~~\deg\bigl(v_{j}\bigr)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（2）若G是有向图，那么邻接矩阵$A$中第𝑖行元素之和表示结点$v_{i}$的出度，第$j$列元素之和表示结点$v_{j}$的入度。简单地说，就是竖入横出。即有：  
$$
\deg^{-}(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};\qquad\deg^{+}\!\left(v_{j}\right)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（3）对于有向图G，注意到：  
$$
\sum_{j=1}^{n}\;\deg^{-}\!\left(v_{j}\right)=\sum_{i=1}^{n}\sum_{j=1}^{n}a_{i j}=\sum_{i=1}^{n}\deg^{+}\!\left(v_{i}\right)
$$  
因此，有向图中所有入度之和等于所有出度之和，这个和其实就是图的边数$m$。因为有向图的每条边均产生且仅产生一个出度和一个入度。  
对于图8-19 所示图模型$G$及如下邻接矩阵$A_{G}$，容易验证，结点度与邻接矩阵之间的数量关系。例如，$A_{G}$中第三行元素之和为3，即$v_{3}$的出度为3。
$$
\begin{gathered}v_{1}\quad v_{2}\quad v_{3}\quad v_{4}\quad v_{5}\\A_{G}=\begin{matrix}v_{1}\\v_{2}\\v_{3}\\v_{4}\end{matrix}\begin{pmatrix}0&1&0&0&0\\0&1&1&0&0\\1&1&0&1&0\\0&0&0&0&0\\0&0&0&0&0\end{pmatrix}\end{gathered}
$$  
关于图中结点度数与边的关系，有如下著名的图论基本定理：  
【定理8.1】（握手定理）假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，则该图中结点度数的总和等于边数的二倍，即有：  
$$
\sum_{v\in V}\deg(v)=2|E|
$$  
【推论8.1】图中度数为奇数的结点个数必为偶数。  
从以上定理及例题可以看出，图模型中结点的度从一种定量的角度反映了图中结点与边之间的制约关系，在一定程度上刻画了图模型的结构特征。为了更加方便地描述图模型中各个结点的度结构信息，下面给出度序列的概念：  
【定义8.19】假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，图中每个结点的图构成的自然数序列称为$G$的度序列。也就是说，若 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，则称序列：  
$$
(\deg(v_{1})\,,\deg(v_{2})\,,\cdots,\deg(v_{n}))
$$  
为图 $G$ 的度数序列，简称为度序列。 此外，对于任意一个给定的自然数序列，如果该序列能够成为某个图的度序列，则称该序列为可图化序列。  
例如，对于图8-22 所示图 $G$ ，其度数序列为 (2,3,3,4)  
![图8-22 图 $G$ ](images/77ba680d9b589e032065b86071c3f75473dc0d06736af0deb36aa2115de43d51.jpg)  
由于图模型的度要满足握手定理等基本约束要求，而且对于不同类型的图，其度序列也会有一些相应的数据特征。因此，并不是任意的自然数序列都可以构成图模型的度序列。对于任意给定的自然数序列，需要通过分析其数据特征来判断其是否为可图化序列。若是可图化序列，则可依据该序列数据来分析其所对应图的结构特征。"
无向图邻接矩阵,性质,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.3 图的表示方法', '一、邻接矩阵表示法']","{'实体类型': '性质', '特点': '关系矩阵是对称矩阵'}",,4,"邻接矩阵是表示图结点间邻接关系的矩阵，即表示图模型中的各个结点之间是否有边的联结关系的关系矩阵。邻接矩阵的具体定义如下：  
【定义8.7】设$G=\langle V,E\rangle$是任一给定的图模型 ，其中结点集合$\ V=\{v_{1},v_{2},\ldots,v_{n}\}$，边集合$E=\{e_{1},e_{2},\dots,e_{m}\}$。称 $n$ 阶方阵 $A_{G}=(a_{i j})_{n\times n}$为图 $G$ 的邻接矩阵，如果矩阵元素 $a_{i j}$ 表示图中结点$v_{i}$ 和 $v_{j}$ 之间是否有边相连：若有则$a_{i j}$为边数$k$，否则$a_{i j}=0$。即有：  
$$
a_{i j}={\left\{\begin{array}{l l}{k,}&{{\mathbb{若}}(v_{i},v_{j}){\in}E{\mathbb{或}}\langle v_{i},v_{j}\rangle{\in}E}\\ {0,}&{{\mathbb{否则}}}\end{array}\right.}\quad\quad\quad\quad(i,j=1,2,3,\cdots,n)
$$ {      }  
从上述定义可以看出，如果图$G=\langle V,E\rangle$是一个线图，则其邻接矩阵为布尔矩阵。此外，需要注意的是，要确定一个图的邻接矩阵，首先必须对图中的所有结点进行编号，邻接矩阵的表示与结点编号的次序紧密相关，不同的结点编号对应于不同的邻接矩阵，结点编号次序的交换对应于邻接矩阵行列的交换。  
图8-8 所示有向图 $G$ 在 $v_{1},v_{2},v_{3},v_{4}$的结点次序下的邻接矩阵为：  
$$
\begin{gathered}v_{1}\quad v_{2}\quad v_{3}\quad v_{4}\\A_{G}=(a_{ij})_{n\times n}=\begin{matrix}v_{2}\\v_{3}\\v_{4}\end{matrix}\begin{pmatrix}0&1&0&1\\1&0&1&1\\1&0&0&0\\0&0&1&0\end{pmatrix}.\end{gathered}
$$  
事实上，无向图和有向图的关联矩阵有一些差异。例如，无向图的每条边不带方向，或理解为每条边同时具有两个方向，故其表示的二元关系具有对称性。因此，关系矩阵或者说图的关联矩阵是一个对称矩阵。对于有向图，其表示的二元关系不一定具有对称性，故其关联矩阵不一定是对称矩阵。因此，通常分别讨论无向图和有向图的邻接矩阵。"
无向树,概念,"['第九章  树的基本理论与算法', '9.1.1  无向树的概念与性质', '§ 9.1 无向树的基本知识']","{'实体类型': '概念', '定义': ['树模型的一种，不关心树中各个边的方向差异，专注树结构的层次方向', '连通无回路的无向图称为树'], '特点': ['从根结点到叶子结点的层次结构蕴含方向', '树中悬挂结点称为树叶结点，简称为叶结点或叶，其它结点称为分支点或内点'], '应用': '通常所说的树模型均指无向树模型', '特例': '平凡图称为空树', 'name': '无向树'}",,2,我们知道图模型主要分为有向图和无向图两大类，树作为一类特殊的图模型，自然也就有有向树与无向树之分。不过，如果从树的根结点看过去，树模型从根结点到叶子结点的层次结构本身就蕴含着一种方向。因此，一般不再关心树中各个边的方向差异而专注树结构的层次方向。换句话说，对于有向树，必须将其转化为一种特殊的无向树即根树进行讨论。基于以上原因，若无特别说明，我们通常所说的树模型均指无向树模型。
无向边,概念,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.2 图的定义与分类']","{'实体类型': '概念', '定义': '连接u和v的无方向的边，用无序偶(u,v)表示'}",,3,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)"
无向连通图,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.3  无向图的连通性']","{'实体类型': '概念', '定义': '无向图中任何两个结点之间都是连通的图', '特点': '任何结点与其自身是连通的'}",,3,"前面我们学习了图的可达性概念及其判定，其描述的是图中两个结点之间是否可以通过一条或者多条通路进行联结，并从图的局部角度分别考察两个结点之间的连通关系。现在我  
们从全局性角度考察整个图中多个结点之间的连通关系，将两个结点之间的可达性概念推广到整个图中任意两个结点之间的可达性，由此得到图的连通性和连通图的相关概念。  
在图的连通性方面，无向图和有向图之间具有很大的差异。因此，我们分别讨论无向图和有向图的连通性。本小节主要介绍和讨论无向图连通性的概念与性质。首先给出无向图连通图的相关概念，具体定义如下：  
【定义8.25】设 $G=\langle V,E\rangle$ 为任一给定的无向图，对于图中的两个结点$v_{i}$ 与 $v_{j}$，如果从$\boldsymbol{v}_{i}$到$v_{j}$是可达的，则称从 $v_{i}$ 到 $v_{j}$是连通的，表示为[ $v_{i}\ \ ,v_{j}]$。规定图中任何结点与其自身是连通的。如果无向图$G$中任何两个结点之间都是连通的，则称该图为无向连通图或连通无向图，简称为连通图；否则，称$G$ 是非连通无向图，简称为非连通图。  
显然，无向图中两个结点之间的连通性是双向的，也就是说两结点之间的连通关系满足对称性，即：若有$v_{i}$ 到 $v_{j}$可达则必有$v_{j}$ 到 $v_{i}$可达。故在无向图中，也可将从${v}_{i}$ 到 $v_{j}$的连通说成$v_{i}$ 与 $v_{j}$连通。另外，注意到平凡图有且只有一个结点，根据无向图中结点连通性的规定，它是一种特殊的连通图。  
下面的定理表明，无向图模型中结点之间的连通性关系是一个等价关系：  
【定理8.7】设 $G=\langle V,E\rangle$ 为任一给定的无向图，其结点集为 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，令$R$ 是集合$\cdot V=\{v_{1},v_{2},\ldots,v_{n}\}$上结点之间的连通关系，即有：  
$R=\{\langle u,v\rangle|u,v\in V\}$, 且从$u$到𝑣连通}       （8-10）  
则$R$是集合𝑉上的一个等价关系。  
既然无向图模型中结点之间的连通性关系$R$是一个等价关系，那么就可以使用等价关系$R$ 将无向图 $G$ 的结点集合 𝑉 划分为若干互不相同的等价类，记为   $V_{1},V_{2},\ldots,V_{k}$ 。在这些等价类 中，相互连通的结点属于同一个等价类，不连通的结点属于不同的等价类。由此得到无向图模型的连通分支的概念，具体定义如下：  
【定义8.26】设 $G=\langle V,E\rangle$ 为任一给定的无向图$R$是图$G$结点集合𝑉上的连通性关系，则以关系𝑅的每个等价类为结点集的导出子图都称为图$G$的一个连通分支，并用$p(\mathbf G)$表示图𝐺的连通分支总数。  
由上述定义可知，如果无向图$G=\langle V,E\rangle$的结点连通性关系$R$作为一个等价关系，将结点集𝑉划分为$k$个不同的等价类$V_{1},V_{2},\ldots,V_{k}$，则由它们导出的子图$G(V_{1}),G(V_{2}),\cdots,G(V_{k})$均为图$G$的连通分支。因此，可以根据无向图中结点之间的连通关系实现对图模型的一个分解。显然，若   $p(G)=1$ ，则 $G$ 是连通图。若   $p(G)>1$ ，则   $G$ 是非连通图。  
【定义8.27】对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在结点集𝑉的某个子集 $V^{\prime}\subseteq$$V$ ，使得 $p(G-V^{\prime})>p(G)$ ，且对于 $V^{\prime}$的任何真子集 $V^{\prime\prime}$，有 $p(G-V^{\prime\prime})=p(G)$，则称 $V^{\prime}$为 $G$ 的点割集。如果点割集中只有一个结点 $v$ ，则称 $v$ 为割点。  
由上述定义可知，可通过删除图中适当结点以破坏图结构的方式考察图的连通程度。图中有些结点组成的集合在图的连通性中起着非常关键的作用，删除这些结点后会使得连通图变成非连通图，使得非连通图变得更加不连通，或者增加连通分支的数目。  
显然，对图中的任意一个点割集，该集合中所有结点都是由该点割集增加连通分支时必须同时删除的结点。例如在图8-40 所示的图$G_{1}$中，集合$\{v_{4}\},\{v_{1},v_{3}\}$都是点割集，但$\{v_{1},v_{3},v_{4}\}$则不是点割集，因为要增加图$G_{1}$的连通分支，不必同时删除结点$v_{1},v_{3},v_{4}$。  
需要注意的是，由于删除割点后，割点的邻接边也需要删除，因此我们用虚线表示已删除的边或者结点。同样，对下文所要介绍的边割集也做类似处理。  
同样，可以通过删除图中适当的边以破坏图结构的方式考察图模型的连通程度，由此可以得到边割集的相关概念，具体定义如下：  
【定义8.28】 对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在边集$E$的某个子集 $E^{\prime}\subseteq$$E$ ，使得 $p(G-\ E^{\prime})>p(G)$ ，且对于 $E^{\prime}$的任何真子集 $E^{\prime\prime}$，有 $p(G-\ E^{\prime\prime})=p(G)$，则称$V^{\prime}$为 $G$ 的边割集。如果点割集中只有一个条边  $e$ ，则称 $e$为割边或桥。  
![图8-42 例题8.24 图模型  ](images/6c126be3977ab4a2c63afc18255dc22be84fa010ee39891af7c0eba551970203.jpg)  
关于点割集与边割集，需要注意以下几个要点：  
（1）完全图 $K_{n}$ 无点割集，因为从 $K_{n}$ 中删除 $k\leq n-1$个顶点后，所得图仍然是连通的。  
（2）$n$ 阶零图既无点割集也无边割集。  
（3）对于连通图 $G$，$E^{\prime}$为 $G$ 的边割集，则必有 $p(G-E^{\prime})=2$ 。 因为删除一条边最多只能增加一个连通分支。  
（4）对于连通图 $G\ \ ,V^{\prime}$为 $G$ 的点割集，则 $p(G-V^{\prime})\geq2$，而且可能 $p(G-E^{\prime})>2$因为删除一个结点可能增加多个连通分支。  
从上述例题可以看出，对于任意给定的一个无向连通图，经常会有多个点割集或边割集，而且每个集合中所含元素的个数也不一样。此时，需要重点关注的应该是那些个数最小的集合。因为这些集合刻画了图连通结构中最为薄弱的环节，反映了连通图的最低连通程度。由此得到无向图连通图的点连通度与边连通度的概念，具体定义如下：  
【定义8.29】对于任意给定的一个无向连通图 $G=\langle V,E\rangle$，令：$\kappa(G){=}m i n\{|V^{\prime}||V^{\prime}$为G 的点割集}；$\lambda(\mathbf{G})=\operatorname*{min}\{|E^{\prime}||E^{\prime}$为G 的边割集} 并称 $\kappa(G)$ 为图 $G$ 的点连通度，$\lambda(G)$ 为图 $G$ 的边连通度。  
显然，点连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少结点数，边连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少边数。  
例如，对于图8-44 所示的无向连通图$G$ ，有$\kappa(G)=2$，$\lambda(G)=3$；对于图8-45 所示的彼得森图，有$\kappa(G)=\lambda(G)=3$。  
![图8-44 图的连通度  ](images/28f9ee3f26ab71faac7e5360d73417062a5a59d8421071b9feb627483727c42a.jpg)  
![图8-45  彼得森图  ](images/80ddd389b19bdc8904c989e51a73f2c183cb8c6f73b8b9c479ee3affcb66c7c0.jpg)  
关于无向连通图的点连通度$\kappa(G)$和边连通度$\lambda(\mathrm{G})$，需要注意以下几个要点：  
（1）如果 $G$是平凡图或非连通图，则规定 $\kappa(G)=\lambda(G)=0;$  
（2）如果$G$ 是完全图 $K_{n}$ ，由于 $G$ 中无点割集，当删除 $n-1$个顶点后，$G$ 为平凡图，故 $\kappa(G)=n-1$。  
（3）如果 $G$ 中存在割点，则 $\kappa(G)=1$；如果 $G$ 中存在割边，则 $\lambda(G)=1$。对于任何无向图 $G$ ，其点连通度 $\kappa$ 、边连通度 $\lambda$ 与结点最小度 δ 之间有如下关系：  
【定理8.8】对于任一无向图$G=\langle V,E\rangle$ ，均成立下列不等式：
$$
\kappa(G)\leq\lambda(G)\leq\delta\ (G)
$$"
无序偶,概念,"['第五章 关系模型与理论', '§ 5.1 关系的数学模型', '5.1.1  序偶与笛卡尔积']","{'实体类型': '概念', '定义': '无序二元组，通常记为(x,y)'}",,3,"要用数学方式表达关系模型，首先必须建立有一种有效的数学机制将来自相同集合或不同集合的两个元素绑定在一起，以表明它们之间具体某种特定的关系。为此，下面给出二元组的相关概念来实现这种机制。  
【定义5.1】假设𝐴和$B$是任意给定的两个集合，则对于分别来自这两个集合中的元素$x$和𝑦，可将它们组合成一个整体并称之为二元组。如果这个二元组为无序二元组，则称其为无序偶对，简称为无序偶，通常记为$(x,y)$；如果这个二元组为有序二元组，则称其为有序偶对，简称为序偶，通常记为$\langle x,y\rangle$，并称$\cdot x\in A$为第一元素，$y\in B$为第二元素。  
在关系的数学理论中，通常使用序偶的概念绑定具有某种确定联系的两个元素。事实上序偶的用途非常广泛，日常生活和工作中的很多问题或概念都可用序偶表示。例如，平面上点$A$ 的横坐标是$x$，纵坐标是$y$，可用序偶表示为$\langle x,y\rangle$，$x,y\in R$；合肥是安徽的省会、南京是江苏的省会，可分别用序偶表示为〈合肥, 安徽〉，〈南京, 江苏〉；数学书在桌上、英语书在床上，可分别用序偶表示为〈数学书, 桌上〉，〈英语书,床上〉。  
由序偶的定义容易知道，序偶可以看作是具有两个元素的集合，但序偶中的两个元素是具有确定次序的，如果两个含有两个元素的集合相等，并不意味着这两个集合元素构成的序偶相等，因此即使成立$\{a,b\}=\{b,a\}$，在$a\neq b$的情况下会有：成立$\langle a,b\rangle\neq\langle b,a\rangle$。例如，对于前述的序偶〈合肥, 安徽〉，从集合的角度看，显然有{合肥, 安徽}$\}=$ {安徽,合肥}，但是序偶〈合肥, 安徽〉和〈安徽, 合肥〉显然代表的是两个不同的含义：前者表示合肥是安徽的省会，前者表示安徽是合肥的省会。因此，有：〈合肥, 安徽〉 $\neq$〈安徽,合肥〉。  
下面给出两个序偶相等的具体定义：  
【定义5.2】假设$\langle a,b\rangle$和$\langle c,d\rangle$是任意给定的两个序偶，如果$a=b$，$c=d$，那称这两个序偶相等，记为：$\langle a,b\rangle=\langle c,d\rangle$。  
从上述定义可知，两个序偶相等当且仅当这两个序偶在对应位置上的元素相等。例如，若有$\langle2x-3y,3x+2y\rangle=\langle1,3\rangle$，则有$2x-3y=1$且$3x+2y=3$；反之亦然。  
显然，可将上述序偶及其相等的相关定义自然推广到多个元素的情形。例如，对于任意给定的三个元素$x,y,z$，则可根据如下递归方式定义由这三个元素组成的有序三元组：  
$$
\langle x,y,\mathrm{z}\rangle=\langle\langle x,y\rangle,\mathrm{z}\rangle\tag{5-1}
$$  
从上式可以看出，所谓有序三元组，其实就是序偶的序偶。一般地，可得到如下关于$^{\cdot n}$元有序组的相关定义：  
【定义5.3】由$n$个元素$a_{1}$ ,$a_{2},\dotsc,a_{n}$组成 $n$元有序组由$n-1$元有序组$\langle a_{1}\;\,,a_{2},\dots,a_{n-1}\rangle$和元素$a_{n}$组成的序偶，记作$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$。即：$\langle a_{1}\;\;,a_{2},\ldots,a_{n}\rangle=\langle\langle a_{1}\;\;,a_{2},\ldots,a_{n-1}\rangle,a_{n}\rangle$。  
【定义5.4】假设$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$和$\langle b_{1},b_{2},\dots,b_{n}\rangle$是任意给定的两个$ n$元有序组，如果$a_{i}=$$b_{i}$，$i=1,2,\dots,n$，则称它们相等，记为：$\langle a_{1}\,\ ,a_{2},\ldots,a_{n}\rangle=\langle b_{1},b_{2},\ldots,b_{n}\rangle\,.$。  
【定义5.5】设$A,B$是任意给定的两个集合，用$A$中任意一个元素为第一元素、$B$中任任意一个元素为第二元素构成的所有可能的序偶组成的集合，称为$A$ 与$B$ 的笛卡尔积，亦称为$A$ 与$B$ 的直积，记为$A\times B$。即有：$A\times B=\{\langle x,y\rangle|(x\in A)\land(y\in B)\}$。  
由上述定义可知，集合$A$ 与$B$ 的笛卡尔积运算结果$A\times B$仍是一个集合，并且$A\times B$中的每个元素都是一个序偶，序偶中第一个元素取自集合$A$、第二个元素取自集合$B$。  
假设根据笛卡尔积的定义，不难证明笛卡尔积运算满足如下几条基本性质：  
（1）假设$A$,$B$是任意给定的两个集合，则有：$A\times\emptyset=B\times\emptyset=\emptyset$；  
（2）假设 $A$, $B$ 是任意给定的两个集合，则有 $A\times B=\emptyset$ ，当且仅当 $A=\emptyset$ 或 $B=\emptyset$；  
（3）当$A,B$是有限集合时，有：$|A\times B|=|B\times A|=|A||B|$  
下面定理表明笛卡尔积运算对集合的并运算和交运算均满足分配律：  
【定理5.1】设$A$、$B$、$C$ 是任意集合，则有：  
$A\times(B\cup C)=(A\times B)\cup(A\times C);\quad A\times(B\cap C)=(A\times B)\cap(A\times C);$  
$(A\cup B)\times C=(A\times C)\cup(B\times C);\quad(A\cap B)\times C=(A\cup C)\times(B\times C)\,$。  
【定理5.2】设$A$、${B}、{C}$ 是任意集合且$C\neq\emptyset$，则有：
$$
A\subseteq B\Leftrightarrow(A\times C\subseteq B\times C);\,\,\,A\subseteq B\Leftrightarrow(C\times A\subseteq C\times B)
$$  
【定理5.3】设$A、\ B、C、D$为非空集合，则有：
$$
A\subseteq C\land B\subseteq D\Leftrightarrow A\times B\subseteq C\times D
$$  
【定理5.4】假设集合$\cdot A_{1},A_{2},\cdots,A_{n}$均为有限集合，则有：
$$
|A_{1}\times A_{2}\times\cdots\times A_{n}|=|A_{1}|\times|A_{2}|\times\cdots\times|A_{n}|
$$"
无权图,概念,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.2 图的定义与分类']","{'实体类型': '概念', '定义': '非赋权图'}",,3,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)"
无穷重m元重集的可重复r-排列数计算公式,定理,"['第一章  集合与计数基础', '§ 1.3 有限集的基本计数技术', '1.3.3 排列计数与组合计数', '二、可重复的排列']","{'实体类型': '定理', '内容': '假设{∞·a1,∞·a2,⋯,∞·am}是任意一个给定的无穷重m元重集，该重集下可重复r-排列数为m^r'}",,4,"现考察这样一个问题：用1、2、3 这3 个数字可以构成多少种不同的5 位数字？  
使用乘法原理不难知道该问题解为$\ 13^{5}=243$种。这显然是一个元素可以重复的排列问题，现具体讨论这类问题。我们知道，在经典集合论中，集合中元素是不可重复的。为解决集合中重复元素的表示问题，现引入重集的概念。与集合的概念一样，重集也是一个没有具体定义的原始概念，只有通过如下方式对其含义进行描述或理解：  
所谓重集，就是在指定范围内满足给定条件、且允许多个相同对象同时出现的所有对象构成的总体，重集中每个对象仍然称为该集合的元素，重集中相同元素的个数称为元素的重数。具体地说，如果一个重集中含有 $\cdot_{n_{1}}$ 个 $\cdot a_{1}$ ， $n_{2}$ 个 $a_{2}$ ， ⋯ ， $n_{m}$ 个 $a_{m}$ ，且 $n_{1}+n_{2}+\cdots+n_{m}=$ $n$，则称该重集为含有$n$个元素的$m$元重集，记为：$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}.$。  
约定：$\infty\cdot a$表示元素$a$可在重集中出现任意多次；$\{\infty\cdot a_{1},\infty\cdot a_{2},\cdots,\infty\cdot a_{m}\}$则表示重集中所有元素均可出现任意多次，称其为无穷重$\pmb{m}$ 元重集。  
事实上，可将$m$ 元重集看成是由$m$ 个容器组成的容器组，其中第一个容器可以放入（或取出）$n_{1}$个元素$a_{1}$，第二个容器可以放入（或取出）$n_{2}$个元素$a_{2}$，…，第$m$个容器可以放入（或取出）$n_{m}$个元素$a_{m}$.对于$\infty\cdot a$，则可将其理解为可以放入（或取出）无穷多个元素$a$的容器.需要注意的是，通常认为重集不是集合，但可将集合看成是重集的特例。  
显然，用1、2、3 这个数字构成5 位数字，就是一个无穷重3 元重集中取出5 个元素的排列问题。一般地，这种重集排列问题或可重复排列问题的定义如下：  
【定义1.24】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的重集，从该重集中依次取出$r$ 个元素并将其按取出的次序排成一排，由此形成的一个有序排列称之为可重复$r$-排列，可重复$r\mathbf{\cdot}$-排列的个数称为可重复$r$-排列数；令$\cdot n_{1}+n_{2}+\cdots n_{m}=n$，则称$\cdot r=n$时构成的排列称为全排列，$r<n$时构成的排列为选排列。  
通过乘法原理不难得到如下无穷重$m$ 元重集的可重复$r\mathbf{\cdot}$-排列数计算公式  
【定理1.16】假设$\{\infty\cdot a_{1},\infty\cdot a_{2},\cdots,\infty\cdot a_{m}\}$是任意一个给定的无穷重$m$ 元重集，该重集下可重复$r$-排列数为$m^{r}$。  
【证明】无穷重数$m$ 元重集$\{\infty\cdot a_{1}$，$\infty\cdot a_{2}$，⋯，$\infty\cdot a_{m}\}$ $r$-排列的每一个位置上，均有$m$  种选择方案，故而 $r$ - 排列数为 $\ \ \cdot m^{r}$ 。□  
【例题1.57】（1）用7 颗六彩珠串成长链，可串出多少种不同长链（假定六彩珠取之不尽，且不考虑链子的反转）？（2）至少用两种颜色的六彩珠串成7 珠环链，求环链的种数（假定六彩的珠子取之不尽，且不考虑链子的反转）？  
![](images/3f1e76f81dba91759e05f5e7aace97377518f23c7e8ea20e34523f4359261b28.jpg)
图1-8 4-圆排列  
有穷集$m$ 元重集上可重复$r\mathbf{\cdot}$-排列数的计算是一个比较复杂的问题，有兴趣的同学可以查阅相关资料，不再赘述。在此仅考虑如下比较简单的全排列数的计算问题：  
【定理1.17】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的含有$n$ 个元素的有限$m$元重集，从该重集中依次取出$n$ 个元素的全排列数为：  
$$
\frac{n!}{n_{1}!\cdot n_{2}!\cdot\dots\cdot n_{m}!}
$$  
【例题1.58】EXCELLENT 单词含有9 个字母，若重新排序字母顺序，请问能构成多少个不同字符串？"
无穷重数的m元重集的r组合数的母函数,定理,"['第一章  集合与计数基础', '§ 1.4 有限集的高级计数技术', '1.4.3 生成函数计数法']","{'实体类型': '定理', '结论': '无穷重数的$m$元重集的$r$-组合数的母函数是$f(x)=(1+x+x^{2}+\\cdots+x^{n}+\\cdots)^{m}$，$f(x)$中$x^{r}$的系数等于上述$r-$组合数'}",,3,"前面我们通过考察数列通项之间的递推关系建立求解问题的动态演化模型并据此实现对有限集合的计数。现在我们仍然以数列为基本工具，通过以数列为系数建立无穷次多项式或幂级数的方式找到联结离散数学与连续数学的桥梁，巧妙地将离散数学中离散量的计数问题转化为连续数学中对幂级数的处理问题。这种幂级数我们称之为数列的生成函数或母函数。生成函数是组合分析与计数的重要工具，运用生成函数求解某些给定条件下的组合数、排列数，以及求解某些递推关系时，有时能获得意想不到的效果。  
【定义1.28】设$\cdot x$为一抽象符号，$a_{n}$（$(n=0{,}1{,}2,\cdots)$）为实数。若函数$F(x)$可表示成  
$$
F(x)=a_{0}+a_{1}x+a_{2}x^{2}+\cdots+a_{n}x^{n}+\cdots
$$  
则称$\cdot F(x)$为数列$a_{n}$$_{\imath}\left(n=0,\!1,\!2,\cdots\right)$）的生成函数。并约定，若某个$\cdot a_{i}=0(i=0,1,2,\cdots)$，则$a_{i}x^{i}$项可以略去。  
比如$|F(x)=1+x+x^{2}+x^{3}+\cdots+x^{n}+\cdots$是无穷序列1，1，1，⋯的生成函数。  
对于一个有限序列$a_{0}\,,\;\;a_{1}\,,\;\;\cdots,\;\;a_{n}\,.$，可以通过将$a_{n}$之后的项定义为0 的方式扩充成一个无限序列，由此定义生成函数。对于有限序列，当$j>n$时没有形如$|a_{j}x^{j}$的项出现，即有：  
$$
G(x)=a_{0}+a_{1}x+\cdots+a_{n}x^{n}
$$  
【定理1.23】无穷重数的$m$元重集$\left\{\infty\cdot a_{1},\ \infty\cdot a_{2},\ \ \cdots,\ \infty\cdot a_{m-1},\ \infty\cdot a_{m}\right\}|$的$r$-组合数的母函数是$f(x)=(1+x+x^{2}+\cdots+x^{n}+\cdots)^{m}$，$f(x)$中$x^{r}$的系数等于上述$r-$组合数。"
无限群,概念,"['第十二章 典型抽象代数结构', '§ 12.2 群结构的基本知识', '12.2.1 群的基本概念']","{'实体类型': '概念', '定义': '设⟨G,*⟩是任意给定的一个群，称|G|为⟨G,*⟩的阶，如果|G|为无限数，则称⟨G,*⟩为无限群'}",,3,"如前所述，群代数结构是对幺半群结构在逆元方面的进一步扩充，其具体定义如下：  
【定义12.8】假设$\langle G,*\rangle$是任意给定的一个二元代数结构，如果$\langle G,*\rangle$满足如下性质：  
（1）结合律：对于$\forall x,y,z\in G$，成立：$(x\ \ *y)*z=x\ \ *(y*z)$；  
（2）含单位元：$\exists e\in G$，使得对于$\forall x\in G$，成立$\,\!e*x=x*e=x$；  
（3）运算$*$可逆：对于$\forall x\in G$，都存在$x^{-1}\in G$，使得$x^{-1}*x=x*x^{-1}=e$。  
则称$\langle G,*\rangle$是一个群代数结构，简称为群结构或群。  
从上述定义可知，对于任意给定的非空集合 $G$ 以及该集合上某个二元运算 $*$ ，$\langle G,*\rangle$ 能够 形成一个群结构的充分必要条件是$\langle G,*\rangle$必须满足封闭性、结合律、含幺性和可逆性这四个基本运算性质。例如，对于实数集合及其上的普通加法运算构成的代数结构$\langle R,+\rangle$，显然满足群的四条基本性质，其中0 是其单位元，对于$\forall x\in R$，$-x$是$x$的逆元。但是，对于实数集合及其上的普通乘法运算构成的代数结构$\langle R,\times\rangle$则不是一个群，因为在$\langle R,\times\rangle$中0 没有逆元素。不难发现，对于任意给定的集合$𝐴$，$\langle{ P}(A),\cup\rangle$和$\langle{ P}(A),\cap\rangle$都不能构成群结构，因为在$\langle{ P}(A),\cup\rangle$中$𝐴$没有逆元，在$\langle{P}(A),\cap\rangle$中$\varnothing$没有逆元。  
【定义12.9】设$\langle G,*\rangle$是任意给定的一个群，称$|G|$为$\langle G,*\rangle$的阶，如果$|G|$为有限数，则称  
$\langle G,*\rangle$为有限群，否则$\langle G,*\rangle$为无限群。如果运算$^*$满足交换律，即对于$\forall x,y\in G$，有$x*y=y*$$x$则称群$\langle G,*\rangle$是一个交换群或阿贝尔群。  
【定理12.3】设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$的单位元是$\langle G,*\rangle$中唯一的一个幂等元，若$|G|>1$，则$\langle G,*\rangle$中无零元且满足消去律。  
下面的定理12.2.2 给出了群中逆元素的基本性质：  
【定理12.4】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，有：  
$$
(a^{-1})^{-1}=a\,\exists(a*b)^{-1}=b^{-1}*a^{-1}
$$  
下面的定理12.5 给出了群与方程可解性之间的关系：  
【定理12.5】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，方程$a\circ x=b$和$y\circ a=$$b$在$\langle G,*\rangle$中有且仅有唯一解。  
由于群结构满足结合律，故可类似于半群和含幺半群定义元素的方幂：  
【定义12.10】设$\langle G,*\rangle$是任意给定的一个群，对于$\forall a\in G$和正整数$ n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$ a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个a}
$$  
定义$a^{0}=e$且$a^{-n}=(a^{-1})^{n}$  
从上述定义可以看出，对于一个群结构$\langle G,*\rangle$可以定义其任意整数的方幂运算，包括负指数方幂。因此，对于$G$中的任何一个元素$a$，均可以通过其正方幂、零方幂和负方幂构成一个向胜负两端无限延伸的序列，具体如下：  
$$
\cdots,a^{-n},\cdots,a^{-2},a^{-1},a^{0}\ \ ,a^{1},a^{2},\cdots,a^{n},\cdots
$$  
这些序列显然满足幂的运算法则，即对于任意整数$n$和$m$，有：  
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
如果$\langle G,*\rangle$是一个有限群$\langle G,*\rangle$，则根据运算的封闭性和鸽笼原理易知，在$G$中任意一个元素的无穷多个方幂中，必然至少有两个是相等的。具体地说，对于任意给定的$G$中某个元素$a$，必然存在两个不相等的整数$m$和$|n$，不妨设$m<n$，满足：  
$$
a^n=a^m\text{或}a^{n-m}=e
$$  
此时，可将正整数$n-m$看成是元素$a$方幂变化的一个周期。一般地，有如下定义：  
【定义12.11】设$\langle G,*\rangle$是任意给定的一个群，$e$是该群的单位元，对于$G$中任意给定的某个元素$a$，如果存在正整数$n$，满足$a^{n}=e$，则其中最小的正整数称为元素$a$的周期或阶，记为$|a|$，否则称元素$a$的周期为无限大或元素$a$的阶为无限大。  
例如，对于群$\langle\underline{{6}},+_{6}\rangle$，元素1 的阶为6，元素2 的阶为3，元素3 的阶为2，元素4 的阶为3，元素5 的阶为6，元素0 的阶为1。对于整数集合上的加法群$\langle Z,+\rangle$，显然，除了元素0 的周期为1 之外，其余任一非零元素的周期均为无穷大。事实上，不难看出，对于任何一个群，有且只有其单位元的阶为1。  
下面给出关于元素阶的两个重要性质：  
【定理12.6】有限群$\langle G,*\rangle$的每个元素都有有限阶，且其阶数不超过群的阶数|G|。  
【定理12.7】设$\langle G,*\rangle$为群，$G$中元素$a$的阶为$ k$，那么$a^{n}=e$当且仅当$k$整除$ n$  。"
无限集,概念,"['1.1.2 集合的概念与表示', '2.有限集与无限集', '四、常用的特殊集合', '§ 1.1 集合的基本知识', '§ 1.2 可数集与不可数集', '第一章  集合与计数基础']","{'实体类型': '概念', '特点': ['具有特殊性质', '需要进行差异性分析以划分不同层次或等级'], '定义': ['对于任意给定的集合A，如果它的基数不是一个有限数，则称该集合是一个无限集', '基数为无穷大的集合'], '无限集中元素的个数是无限的': '无限'}",,4,集合论中有一些非常重要和常用的特殊集合，它们分别具有一些特殊性质。离散数学中很多基本概念的定义及其性质讨论都离不开它们。下面具体介绍这些特殊集合的基本概念及性质，包括空集、全集、有限集、无限集、子集、幂集等。
无限集的基数比较,原理,"['第一章  集合与计数基础', '§ 1.2 可数集与不可数集', '1.2.3 无限集的基数比较']","{'实体类型': '原理', '内容': '无限集合的基数已经不能通过集合中元素的个数来度量，而是需要以自然数集或其它无限集合的基数为标准进行度量'}",,3,"从前面的讨论不难看出，对于任意一个给定的自然数$n$，该自然数其实就是对所有含有$n$ 个元素集合的一种抽象。例如，自然数3 就是对所有含有3 个元素集合的抽象，或者说自然数3 就是将所有含有3 个元素的集合房子一起组成集族。因此，自然数可以根据集合中所含元素个数为标准对所有有限集进行分类，从而实现对有限集基数的度量和比较。  
对无限集基数的度量和比较则没有这么简单。如前所述，任意一个无限集合，都可以找到它的一个子集与自然数集等势。因此，自然数集应当是规模最小的一种无限集合，可用自然数集作为无限集基数的最小度量单位或者度量基准。据此得到如下定义：  
【定义1.19】凡是与自然数集$N$ 等势的集合都称为可数集合，该类集合的基数记为$\aleph_{0}$，读作阿列夫零。  
根据上述例题，可以得到关于有限集合和可数集合的如下基本性质：  
（1）两个有限集合等势，当且仅当它们具有相同的元素个数；（2）有限集合不可能与其任何真子集合等势； （3）可数集合可以与其可数的真子集等势。  
由此可知，元素个数不相等的无限集之间仍有可能存在等势关系。因此，无限集合的基数已经不能通过集合中元素的个数来度量，或者说不能用一个自然数来度量，而是需要以自然数集或其它无限集合的基数为标准进行度量。  
现在考察这样的一个问题，除了可数集合之外，还有没有其它的无限集合？或者说，是否每一个无限集合都能够与自然数集合建立一一对应的关系？事实上并非如此，例如开区间(0, 1)就不能与自然数建立等势关系，所有与开区间(0, 1)等势的集合构成了另外一类不同规模的集合，称之为不可数集合。其具体定义如下：  
【定义1.20】开区间(0, 1)称为不可数集合，其基数记为ℵ，读作阿列夫；凡是与开区间(0, 1)等势的集合都称为不可数集合。  
因此，不可数集合是比可数集合规模更大的一种无限集合类型。当然，还可以考虑不可数集合的幂集、不可数集合幂集的幂集等等，由此可以构造出很多种不同基数的无限集合。关于这些无限集合基数及其性质的讨论已经超出了离散数学的范畴，有兴趣的读者可以参阅实变函数理论中与连续统相关的内容。"
无零因子含幺交换环,概念,"['第十二章 典型抽象代数结构', '§ 12.4 环和域的基本知识', '12.4.2  域的概念与性质']","{'实体类型': '概念', '条件': '元素大于1的有限无零因子含幺交换环必定是域'}",,3,"从环结构的定义不难看出，构成环的两个子系统并不对等，其加法子系统是一个交换群，乘法子系统一个是半群，至多是可交换含幺半群。为何其乘法子系统不能定义成群呢？根本原因就是其乘法子系统中含有作为加法子系统单位元的零元，而零元在乘法运算下不可能有逆元，故不能直接将其乘法子系统定义为群。  
事实上，可以采用一种变通的方法定义乘法子系统的群结构，具体地说，就是在去除0元素的载体集合中定义乘法运算的群结构，由此得到如下关于域结构的定义：  
【定义12.25】如果$\langle G,+,\times\rangle$是具有两个二元运算的代数系统，且满足：（1）$\langle G,+\rangle$是交换群；（2）$\left\langle G-\{0\},\cdot\right\rangle$是交换群；（3）$G$中的$\times$对$^+$满足分配律。则称$\langle G,+,\times\rangle$是域代数结构或域代数系统，通常简称为域结构、域系统或域，并称$+$和$\times$分别为域中的加法和乘法。  
由域的定义可以看出，域结构其实是对环结构施加进一步的限制，即要求$\langle G-\{0\},\ \times\rangle$是一个可交换群。  
【定理12.31】设$\langle G,+,\times\rangle$是任意给定的一个无零因子含幺交换环，且$1<|G|<n,n\in N_{+}$则$\langle G,+,\times\rangle$是域。  
该定理表明元素大于1 的有限无零因子含幺交换环必定是域。  
由于域结构是由两个交换群子结构组成，故与群结构类似，域结构也存在子域、商域和域同态的相关概念和理论。事实上，子域、商域、域同态概念和性质完全可以使用与群类似的思路进行讨论，这里不再赘述，读者可自行查阅域结构的相关资料深入学习。"
无零因子环,概念,"['第十二章 典型抽象代数结构', '§ 12.4 环和域的基本知识', '12.4.1  环的概念与性质']","{'实体类型': '概念', '定义': '不存在两个非零元素乘积为零的环'}",,3,"我们知道，整数集合𝑍上具有加法$+$和乘法$\times$这两种运算，并且$\langle Z,+\rangle$是一个交换群、$\langle Z,\times\rangle$是一个半群，并且乘法对加法满足左、右分配律，即有：  
$$
a\times(b+c)=a\times b+a\times c;\ (b+c)\times a=b\times a+c a\times
$$  
由此可见，整数运算系统主要由两个运算子系统构成，即由一个基于加法运算的交换群和一个基于乘法运算的半群构成，并且乘法对加法满足分配律。  
将整数运算系统的上述性质进行抽象，就得到如果环代数结构的定义：  
【定义12.22】如果$\langle G,+,\times\rangle$是具有两个二元运算的代数系统，且满足：（1）$\langle G,+\rangle$是交换群；（2）$\langle G,\times\rangle$是半群；（3）$G$中的$\times$对$+$满足分配律。则称$\langle G,+,\times\rangle$是环代数结构或环代数系统，通常简称为环结构、环系统或环，并称$+$和$\times$分别为环中的加法和乘法。  
由上述定义可知，环结构由加法交换群和乘法半群这两个子结构组成，且满足乘法对加法的分配律。显然，代数系统$\langle Z,+,\times\rangle$就是一个环结构。  
此外，$\langle Q,+,\times\rangle,~\langle R,+,\times\rangle,~\langle C,+,\times\rangle$也都是环结构，其中$Q$是有理数集，$R$是实数集，$C$是复数集，分别称作整数环，有理数环，实数环和复数环。  
可根据构成环的群子结构或半群子结构的特点，对环结构做进一步的分类：  
【定义12.23】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果$\langle G,\times\rangle$是一个含幺半群，则称$\langle G,+,\times\rangle$是一个含幺环，如果$\langle G,\times\rangle$是一个交换半群，则称$\langle G,+,\times\rangle$是一个交换环，如果$\langle G,\times\rangle$是一个含幺交换半群，则称$\langle G,+,\times\rangle$是一个含幺交换环。  
为了叙述上的方便，通常将环中加法的单位元记作0，而将环中元素$x$关于加法的逆元称作$x$的负元，记作$-x$。如果环中乘法有单位元，就把这个单位元记作1，而将$ x$关于乘法的逆元（若存在的话）称为$x$的逆元，记作$:\!x^{-1}$。类似地，可用$x-y,$表示$ x+(-y)$，分别用$n x$和$x^{n}$表示$x$的加法和乘法$ n$次幂，即有：  
$$
n x=\underbrace{x+x+\cdots+x}_{n^{}个};\,\,\,x^{n}=\underbrace{x x\cdots x}_{n^{}个}
$$  
下面讨论环的基本性质。由环的定义可知，环中加法满足交换律、结合律，有单位元0  ，  
每个元素都有负元，环中乘法适合结合律，乘法对加法适合分配律。除此之外，我们进一步考察环的其它一些性质。首先考察环结构中加法逆元的性质：  
【定理12.28】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a,b\in G$，有：  
$$
-(a\times b)=a\times(-b)=(-a)\times b\quad\text{(12-20)}
$$  
下面考察环结构中加法单位元的性质：  
【定理12.29】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a\in G$，有：  
$$
a\times0=0\times a=0\quad\text{(12-21)}
$$  
上述定理12.29 表明，环结构中加法运算的单位元是乘法运算的零元，并且环中任二元素相乘，若其中至少有一个为零元，则乘积必为零元。但反之不然，因为在环中，两个非零元的乘积可能为零元，由此引出如下环结构中零因子的概念：  
【定义12.24】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果存在$G$中两个非零元素满足$a\cdot b=0$ ，称该环为含零因子环，元素 $a$ 和 $b$ 是其零因子，否则称该环为无零因子环。  
【定理12.30】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则$\langle G,+,\times\rangle$是无零因子环当且仅当于$\langle G,\times\rangle$满足消去律。  
由于环是由群和半群这两个子结构构成，故与群结构类似，环结构也存在子环、环同态的相关概念和理论。事实上，子环和环同态的概念和性质完全可以使用与群类似的思路进行讨论，这里不再赘述，读者可自行查阅环结构的相关资料深入学习。"
时间复杂度,概念,"['第二章  整数与算法设计基础', '§ 2.3 算法设计的基本知识', '2.3.2 算法效率的度量']","{'实体类型': '概念', '定义': '定量描述算法运行时间的函数', '表示方法': '常用大O符号表述', '类型': '包括常数级、对数级、多项式级、指数级、阶乘级等'}",,3,"从实际应用考虑，如果一个算法的运行时间过久，比如需要长达数年的时间，那么该算法就不适合用来解决问题。同样，一个算法如果需要占用很大的内存开销，导致系统无法为其它程序提供必须的内存资源，那么这也是不能够接受的。因此，对于设计出来的算法，需要对其利用时间和内存空间的效率进行分析，这就是算法的效率分析。无论是时间效率还是空间效率上看，算法的效率都是问题规模的某个函数，并且函数值随着问题规模的增长而增长。如果函数值随问题规模的增长而增长得很快，则说明算法效率很低，反之，如果函数值随问题规模的增长而增长得很慢，则说明算法效率很高。  
因此，为了更好地分析算法的效率，需要一些合适的方法来描述或度量函数值随自变量增长而增长的速度，如果不能精确地算出函数增长的速度，那么至少也要针对函数增长的不同速度划分出若干性质不同的等级，这就是函数增长的阶。当输入规模足够大时，精确表示的运行时间函数中的常系数和低阶项会被输入规模所掩盖。此时，只需要考虑高阶项即可。比如若复杂度为多项式$x^{2+}\!x$，$x$的复杂度会被$x^{2}$的复杂所吸收，因此只需考虑最高阶。  
事实上，在分析和度量算法效率的时候，重点考虑的是当问题规模充分大时的函数值增长的情况。因此，分析和度量算法效率时，一般都使用渐近效率的概念，即从极限的角度考虑运行时间如何随输入规模的增长而增长。为了更加准确地阐释和度量算法复杂度随问题规模增长而增长的速度，计算机科学家在算法领域引入了一些函数增长符号，其中时间复杂度常用大𝑂符号表述，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。使用这种方式时，时间复杂度可被称为是渐近的，它主要考察当输入值充分大时的情况。  
对于绝大多数算法来说，其复杂度的增长速度还可以使用基本或常用函数增长类型通过示例性的方法来描述或表示，如常数级、对数级、多项式级、指数级、阶乘级增长速度，等等。这些常用函数的增长速度非常直观，以它们增长速度为标准对算法的计算复杂度进行度量，会使得算法复杂度分析变得易于理解。因此，掌握这些常用函数的基本增长类型对算法设计具有非常重要的指导意义，下面对其做简要介绍：  
（1）$\mathrm{O}(1)$：复杂度为常数级，例如从一个数据集中取出第一个元素；  
（2）$\mathrm{O}(\lg n)$：该类型常见于将一个数据集分成两半，然后将其中每一半再分成两半，以此类推。例如对有序数组进行二分查找，其时间复杂度就是$\mathrm{O}(\lg n)$；  
（3）$\mathrm{O}(n)$：该类型常见于数据集中的遍历，例如在线性结构中顺序查找某个元素的算法，其时间复杂度就是$\mathrm{O}(n)$；  
（4）$\mathrm{O}(n\lg n)$：该类型与前面所述的$\mathbf O(1g\ n)$有点类似，常见于将一个数据集分成两半，然后将每一半再分成两半，并且对每一半数据进行遍历，以此类推，例如归并排序时间复杂度就是$\mathrm{O}(n\,1\mathrm{g}\,n)$；  
（5）${\mathrm{O}}(n^{2})$：常见于两重嵌套循环的算法之中，也就是说在遍历一个数据集中的每一个元素的时候同时遍历另一个数量级相同的数据集，基本排序算法（如冒泡排序、直接插入排序、直接选择排序等）的时间复杂度是${\mathrm{O}}(n^{2})$；  
（6）${\mathrm{O}}(n^{3})$：该类型常见于三重嵌套循环的算法之中，在线性代数中，两个$n$阶方阵相乘的时间复杂度就是${\mathrm{O}}(n^{3})$，著名求解最短路径Floyd 算法的时间复杂度也是${\mathrm{O}}(n^{3})$；  
（7）$\mathrm{O}(2^{n})$：为一个数据集生成所有的子集，这种数量级的算法可以说是很低效的，在规模较大的时候是不可行的；  
（8）$\mathrm{O}(n!)$：对具有$n$ 个元素的集合进行全排列时就是该类型的典型例子，这种数量级的算法基本上是不可行的。"
普莱姆算法,算法,"['第九章  树的基本理论与算法', '§ 9.1 无向树的基本知识', '9.1.3  最小生成树']","{'实体类型': '算法', '基本思路': '从图中任意一个结点开始，每次选择增加一条权最小的边构成一棵新树，每次在所有一端已经入选一端未入选的边中，选择权值最小的边加入且不构成回路', '特点': '基于贪心策略，每次循环只考虑本次选择的最优结果，是一种局部最优算法', '正确性证明': '定理9.4证明了普莱姆算法的正确性，保证了该算法可通过不断计算局部最优值获得整体最优值'}",,3,"为了更好地了解理解最小生成树的概念，我们首先考察一个具体应用实例：对于图9-7所示的带权图𝐺表示在某地6 个小区结点之间修建能源管道的费用预算情况(单位为万元)，图中每条边的权表示在该边两个端点之间修建管道的费用预算，问题是如何在保证这6 个小区连通的前提下使用最少的管道修建费用。  
![图 9-7   带权无向连通图及其最小生成树  ](images/69b981817af345f5a438b8a88bfbbbd31ee6159c07c4129830a99641d06e89d2.jpg)  
显然，如果所修建的所有管道能够构成$G$的一个生成树，就能满足小区之间的连通性要求。但是，图$G$有多个不同的生成树，并且对于不同的生成树，其边也不完全相同，从而修建的总费用会有一些差异。因此，通常希望能够找到一个修建总费用达到最小的生成树，即各树枝权的总和为最小的生成树，由此得到如下最小生成树的概念：  
【定义9.3】设假设$G=\langle V,E,W\rangle$是任意给定的一个连通无向赋权图模型，𝑇是𝐺的一棵生成树，𝑇的每个树枝所赋权值之和称为𝑇的权，记为$\omega(T)$。图$G$中具有最小权的生成树称为$G$的最小生成树。  
例如，图9-7(b)所示的带权树就是图9-7(a)所示带权图的最小生成树。因此，在保证小区连通前提下管道修建费用最少为$10+10+7+6+5=38$(万元)。  
需要注意的是，由于一个无向图的生成树不唯一。因此，一般不能保证一个赋权图的最小生成树一定是唯一的。但生成树的最小权一定是唯一的，对于不同的最小生成树，它们的权肯定彼此相等并且都等于最小权。  
下面介绍连通无向赋权图的最小生成树构造方法。求赋权图最小生成树的方法很多，其中最常见的主要是普莱姆算法和克鲁斯卡尔算法。  
普莱姆算法基于贪心策略，从图中任意一个结点开始，每次选择增加一条权最小的边构成一棵新树，基本思路就是每次在所有一端已经入选一端未入选的边中，选择权值最小的边加入且不构成回路。算法的具体过程如下：  
（1）从$G$中任意选取一个结点$v_{1}$，置$V_{T}=\{v_{1}\}$，$E_{T}=\varnothing$，$k=1$ 。  
（2）在$V-V_{T}$中选取与某个$v_{i}\in V_{T}$邻接的结点$v_{j}$，使得边$(v_{i},\ v_{j})$的权最小，置$V_{T}=$${T}\cup\{v_{j}\},\;\;E_{T}=E_{T}\cup\{(v_{i}\,,\;\,v_{j})\},\;\;k=k+1.$  
（3）重复步骤(2)，直到$k=|V|$。  
在普莱姆算法的步骤(2)中，若满足条件的最小权边不止一条，则可从中选择一条。由此会产生不同的最小生成树。  
对于图9-7 所示带权图使用普莱姆算法构造其最小生成树的具体过程如图9-8 所示：  
![图9-8 普莱姆算法构造最小生成树](images/8a0f2320ecde8e2695b2e2cead9370c247645fefffa9f77fa84c367a18def480.jpg)  
由于普莱姆算法基于贪心策略， 每次循环只考虑本次选择的最优结果， 而不考虑下次如 何选择，是一种局部最优算法。因此，必须证明算法的正确性。下面定理9.4 证明了普莱姆算法的正确性，保证了该算法可通过不断计算局部最优值获得整体最优值。  
【定理9.4】假设$G=\langle V,E,W\rangle$是任一给定的连通无向赋权图，则由普莱姆算法构造的任何生成树$T=G\{e_{1},e_{2},\ldots,e_{n-1}\}$都是$G$的最小生成树，其中$n$为$G$的结点数。  
![图9-9 普莱姆算法构造最小生成树  ](images/75143a931b95de54e246d3f0ca5e18faed40466b8fb351a6ce6667aea6eaa5e2.jpg)  
![图9-9 普莱姆算法构造最小生成树  ](images/56147ba86dfc989b0cbc43dab1318a7a4a9458fc90e3612e58f3bc1a780819cd.jpg)  
【定理9.5】假设$G=\langle V,E,W\rangle$是任一给定的连通无向赋权图，则由克鲁斯卡尔算法构造的任何生成树$T=G\{e_{1},e_{2},\ldots,e_{n-1}\}$都是$G$的最小生成树，其中$n$为𝐺的结点数。"
更改算法,算法,"['第九章  树的基本理论与算法', '§ 9.3 特殊根数与算法']","{'实体类型': '算法', '应用': '根树模型的基本操作'}",,2,根树是一类非常重要的树模型，能够对很多复杂的数据信息进行表示和处理，广泛应用于程序设计、数据结构、算法设计与分析、操作系统等多门后续课程。根树的种类很多，可以针对不同类型的问题或数据建立相应类型的根树模型。本节着重介绍三种最为典型的特殊根树模型，即平衡树模型、红黑树模型和𝐵树模型，并分析和讨论这些模型的插入、删除、更改、旋转等基本算法，旨在为后续相关专业课程的学习打下良好的基础。
替换定理,定理,"['§ 3.2 命题公式与等值演算', '三、命题公式的等值演算', '第三章  命题演算与推理', '3.2.2 等值关系与等值演算', '二、基本等值关系']","{'实体类型': '定理', '条件': '设G1是G的子公式，H1是任一命题公式，在G中凡出现G1处都以H1替换后得到新的命题公式H', '结论': '若G1⇔H1，则G⇔H', '应用': '用于命题公式的等值演算'}",,4,"在初等代数中，我们常常借助一些已经证明为正确的恒等式，例如平方差公式等进行代数式的恒等变形或演算。在命题逻辑中，也可以这样做。具体地说，就是首先通过真值表证  
明一些基本的等值关系式，然后将这些基本等值关系式作为已知工具直接在命题公式等值演算中使用，达到简化演算过程的效果。这些基本等值关系式一共有24 个，具体如下：  
幂等律：$E_{1}\colon G\vee G\Leftrightarrow G$；                    $E_{2}\colon G\wedge G\Leftrightarrow G$；  
交换律：$E_{3}\colon G\vee H\Leftrightarrow H\vee G$；                 $E_{4}\colon G\wedge H=H\wedge\mathsf{G}$；  
结合律：$E_{5}\colon G\vee(H\vee S)\Leftrightarrow(G\vee H)\vee S \ \  \ \ E_{6}\colon G\wedge(H\wedge S)\Leftrightarrow(G\wedge H)\wedge S$  
同一律：$E_{7}\colon G\vee0\Leftrightarrow G$；                     $E_{8}\colon G\wedge1\Leftrightarrow G$；  
零  律： $E_{9}\colon G\vee1\Leftrightarrow1$；                     $𝐸_{10}: 𝐺∧0 ⇔0$；  
分配律：$E_{11}\colon G\vee(H\wedge S)\Leftrightarrow(G\vee H)\wedge(G\vee S)$$ 𝐸_{12}: 𝐺∧(𝐻∨𝑆) ⇔(𝐺∧𝐻) ∨(𝐺∧𝐻)；$  
吸收律：$E_{13}\colon G\vee(G\wedge H)\Leftrightarrow G$；               $𝐸_{14}: 𝐺∧(𝐺∨𝐻) ⇔𝐺； $  
矛盾律与排中律：$E_{15}{\colon G\wedge\neg G\Leftrightarrow0}$；            $E_{16}\colon G\vee\neg G\Leftrightarrow1;$；  
双从否定律：$E_{17}\colon\neg(\neg G)\Leftrightarrow G$  
德摩根律：$E_{18}\colon\neg(G\vee H)\Leftrightarrow\neg G\wedge\neg H$；         $E_{19}\colon\neg(G\wedge H)\Leftrightarrow\neg H\vee\neg G$  
等值蕴含与假言易位： $E_{20}\colon G\to H\Leftrightarrow\lnot G\vee H$ ； $E_{21}\colon G\to H=\neg H\to\neg G\colon$  
等价与等价否定：$E_{22}\colon G\leftrightarrow H\Leftrightarrow(\neg G\lor H)\land(\neg H\lor G);\quad $  
$E_{23}\colon G\leftrightarrow H\Leftrightarrow\neg G\leftrightarrow\neg H;$  
归谬论：$E_{24}\colon(G\to H)\wedge(G\to\lnot H)\Leftrightarrow\lnot G$。  
除了上述24 个基本等值关系之外，命题公式的等值演算还经常用到两个著名的定理，  
即代入定理和替换定理。  
对于任意一个永真式或永假式，其真值与公式中命题变元的取值状态无关。因此，用任意公式取代永真式或永假式中的变元，都不会改变其取值的永真性或永假性。下列代入定理正是表达了这个含义：  
【定理3.3**]**（代入定理）设$G(P_{1},P_{2},\cdots P_{n})$是一个命题公式，其中$P_{1},P_{2},\cdots P_{n}$是$G$中的$n$个命题变元，$G_{1}(P_{1},P_{2},\cdots P_{n})$，$G_{2}(P_{1},P_{2},\cdots P_{n})$，⋯，$G_{n}(P_{1},P_{2},\cdots P_{n})$为任意命题公式，此时若$G$为永真公式或永假公式，则用$G_{1}$取代$P_{1}$，用$G_{2}$取代$P_{2}$，⋯，用$G_{n}$取代$P_{n}$后得到的新的命题公式： $\mathsf{G}(G_{1},G_{2},\cdots G_{n})\,\Leftrightarrow\,G^{\prime}(P_{1},P_{2},\cdots P_{n})$也是一个永真公式或者永假公式。  
【定理3.4】（替换定理）设${\mathcal{G}}_{1}$是$G$的子公式，$H_{1}$是任一命题公式，在$G$中凡出现$G_{1}$处都以$H_{1}$替换后得到新的命题公式$\mathsf{H}$，若$G_{1}\Leftrightarrow H_{1}$，则$G\Leftrightarrow H$。"
最优子结构性质,性质,"['第二章  整数与算法设计基础', '§ 2.4 算法设计策略与应用', '2.4.3  回溯与动态规划', '二、动态规划策略']","{'实体类型': '性质', '定义': '如果问题最优解所包含子问题的解也是最优的，则称该问题具有最优子结构性质', '重要性': '动态规划求解问题的必要条件'}",,4,"【定义2.25】动态规划是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。  
当问题的数学模型是递推式时，按理应该使用递归算法求解。但是，递归算法有时存在大量重复计算，使得算法时间复杂度过高。实际上，不同子问题的个数往往只有多项式数量级，若将已经计算过的子问题中间数据和计算结果记录下来，需要某个子问题的解时就直接调用，则可避免大量的重复计算，甚至可以获得多项式时间的算法计算量。动态规划算法正是遵循这种思想，将求解过程中所有子问题的解全部记录下来，不管该子问题以后是否会被其它子问题用到。可以看出，动态规划采用的是以空间换取时间的策略。  
动态规划法的有效性依赖于求解问题的两个重要性质，即：最优子结构性质和子问题重叠性质。  
$\bullet$ 最优子结构性质  如果问题最优解所包含子问题的解也是最优的，则称该问题具有最优子结构性质。最优子结构性质是动态规划求解问题的必要条件。  
$\bullet$ 子问题重叠性质  子问题重叠性质是指在用递归算法由自顶向下的方式对问题求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。当再次需要计算已经计算过的子问题时，无需再次计算，只需查表即可。 当确定待解决的问题可以使用动态规划算法求解时，通常按照以下几个步骤进行：  
（1）把所有最优化问题分成若干个阶段，找出最优解的性质，并刻画其结构特性。  
（2）将问题发展到各个阶段时所处的不同状态表示出来，确定各个阶段状态之间的递推（或递归）关系，并确定初始（边界）条件。  
（3）应用递推（或递归）关系求解最优值。  
（4）根据计算最优值时得到的信息，构造最优解。  
以上（1）~（3）步是动态规划算法解决问题的基本步骤，在只需要计算最优值的问题中，完成这三个基本步骤即可。  
如果问题需要构造最优解，仍需执行第（4）步；此时，在第（3）步通常需要记录更多的信息，以便在步骤（4）中有足够信息快速地构造出最优解。"
最优树,概念,"['第九章  树的基本理论与算法', '§ 9.2 根树的基本知识', '9.2.3  前缀码与最优树']","{'实体类型': '概念', '定义': '设有一棵二元树T，若对其所有的t片叶赋以权值w1,w2,⋯,wt，则称之为赋权二元树；若权为wi的叶的层数为L(wi)，则称w(T)=∑wi×L(wi)为该赋权二元树T的权；w(T)最小的二元树称为最优树', '应用': '用于构造高效的编码树', '特点': '具有最小权值'}",,3,"在计算机及通信技术中，常用二进制编码来表示符号，称之为码字。例如，可用00、01、10、11 分别表示字母A、B、C、D。如果字母A、B、C、D 出现的频率是一样的，则传输100 个字母会使用200 个二进制位。但实际上字母出现的频率很不一样，比如A 出现的频率为$60\%$，B 出现的频率为$25\%$，C 出现的频率为$10\%$，D 出现的频率为$5\%$。能否用不等长的二进制序列表示字母A、B、C、D，使传输的信息的二进制位尽可能少呢？  
事实上，可用000 表示字母D，用001 表示字母C，01 表示B，1 表示A。此时，传输100 个字母所用的二进制位为：  
$$
3\times5+3\times10+2\times25+1\times60=155
$$  
这种表示比用等长的二进制序列表示法好，节省了二进制位。  
在编码时还要考虑一个问题，就是二进制序列的分词问题。例如，如果用1 表示A，用00 表示B，用001 表示C，用000 表示D 时，那么在接收到信息001000 时，则无法辨别它是CD 还是BAD。因此，在使用二进制序列表示A、B、C、D 等字母时，需要一些特定的编码策略以避免出现类似容易混淆的情况。为此引入如下前缀及前缀码的概念：  
【定义9.9】设$a_{1}a_{2}\cdots a_{n-1}a_{n}$是长度为$n$的符号串，则称其子串$a_{1},a_{1}a_{2},a_{1}a_{2}a_{3},\cdots\,,$,$a_{1}a_{2}\cdots a_{n-1}$分别为$a_{1}a_{2}\cdots a_{n-1}a_{n}$的长度为1，2，⋯，$n-1$的前缀。  
【定义9.10】设$A=\{b_{1},b_{2},\cdots,b_{m}\}$是一个符号串集合，若对任意$b_{i}$，$b_{j}\in A$，$b_{i}\neq$$b_{j}$，$b_{i}$不是$.b_{j}$的前缀，$b_{j}$也不是$b_{i}$的前缀，则称𝐴为前缀码。若在符号串$b_{i}\bigl(i=1,2,\cdots,\ \mathsf{m}\bigr)$中，只出现0 和1 两个符号，则称𝐴为二元前缀码,在不引起混淆时简称为前缀码。  
例如{1，01，001，000}是前缀码，而{1，11，001，0011}不是前缀码。那么如何产生前缀码呢？事实上，可用一棵二元树来产生一个二元前缀码：  
给定一棵有𝑡片叶二元树𝑇。设$v$是𝑇的任一分支点，则$v$至少一个儿子至多两个儿子。若𝑣有两个儿子，则在由𝑣引出的两条边上，左边的标0，右边的标1；若$v$只有一个儿子，在$v$引出的边上可标0 也可标1。设${v}_{i}$为𝑇的任意一片叶，从树根到$v_{i}$的通路上各边的标号组成的符号串放在$v_{i}$处，$t$片叶处的𝑡个符号串组成的集合为一个二元前缀码。  
由上述做法可知，$v_{i}$中符号串的前缀码均在${v}_{i}$所在通路上，因而所得集合为0 和1 组成前缀码。显然，若𝑇存在带一个儿子的分支点，则𝑇产生不唯一的前缀码， 𝑇若为二元完全树，则𝑇产生唯一的前缀码。例如，图9-26 所示二元树产生的前缀码为：  
![](images/0e364ce62d589d6e701c3aee01259a3ff2b2c5a6aebc38eaf711e5ecde762552.jpg)  
![](images/c850aef1e068c66827fea6f4c98a09846df47e5a769a3618a27f7a6bb63e479e.jpg)  
【定义9.11】设有一棵二元树𝑇，若对其所以的𝑡片叶赋以权值$w_{1},w_{2},\cdots,w_{t}$，则称之为赋权二元树；若权为$w_{i}$的叶的层数为$L(w_{i})$，则称：  
$$
w(T)=\sum_{i=1}^{t}w_{i}\times L(w_{i})
$$  
为该赋权二元树 𝑇 的权；   $w(T)$ 最小的二元树称为最优树。  
下面的定理9.7 给出了构造最优树的一个基本思路：  
【定理9.7】假设𝑇是一棵带有权值为$|w_{1}\leq w_{2}\leq\cdots\leq w_{t}$二元最优树。其中权$w_{1}$和$w_{2}$所对应叶结点必定是兄弟，并且如果将其父结点由分支结点改为带权$w_{1}+w_{2}$的叶结点，则由此得到的一棵新树$T^{\prime}$也是一棵最优树。  
根据上述定理，美国计算机科学家霍夫曼在1952 年提出一种构造最优树的算法，通常称之为霍夫曼算法。对于任意给定的权值 $w_{1}\leq w_{2}\leq\cdots\leq w_{t}$，算法的基本思路是：要画一棵带有$t$个权的最优树，则可依据定理9.7 将问题转化为要画一棵带有𝑡−1个权的最优树，依次类推.具体做法是：首先找出两个最小的权值设为$w_{1}$和$w_{2}$，然后对𝑡−1个权$w_{1}+$$w_{2},w_{3},\cdots,w_{t}$求作最优树，并将这棵最优树中权$w_{1}+w_{2}$对应的叶结点分叉出两个儿子，依次类推，直到只有一个权值的最优树的情形.具体算法过程如下：  
（1）初始：令${\cal{S}}=\{w_{1},w_{2},\cdots,\}$ ;  
（2）从𝑆中取出两个最小的权$w_{i}$和$w_{j}$，画结点$v_{i}$，带权$w_{i}$，画结点$v_{j}$，带权$w_{j}$。画$v_{i}$和$v_{j}$的父亲$v$，连接$v_{i}$和$v$，$v_{j}$和$v$，令$v$带权$.w_{i}+w_{j}$；  
（3）令$S=\left(S-\left\{w_{i},w_{j}\right\}\right)\cup\{w_{i}+w_{j}\};$  
（4）判断𝑆是否只含一个元素。若是，则停止，否则转（2）。  
从上述算法过程可以看出，霍夫曼算法采用递推的方式构造最优树，核心思想是逐步从从带权为$w_{1}+w_{2},w_{3},\cdots,w_{t}$的最优树${T^{\prime}}$中得到带权为$w_{1}$，$w_{2}$，⋯，$w_{t}$的最优树。  
下面结合具体实例介绍最优树的具体构造过程："
最优路线问题,问题,"['第十章  特殊图模型与算法', '§ 10.4 网络流图及其优化问题', '10.5.3 最优路线问题']","{'实体类型': '问题', '定义': '在给定条件下寻找总路程最短的路线问题', '应用': '旅游路线规划', '特点': '可用哈密顿图模型求解', '条件': '在加权无向图中寻找遍历所有结点仅一次再回到起点的路线'}",,3,"如果想在较短的时间内旅游较多的景点，则需要确定一个合理的路线，尽量缩短旅游的路程，使总路程最短。该问题可用哈密顿图模型求解。  
首先，将旅游线路模型化。把每个旅游景点分别看作是加权无向图中的一个结点，各景点之间的直达公路看作加权无向图中对应结点间的边，将各条公路的长度分别看作其对应边上的权。有的景点之间尽管没有直达的公路，但是它们加权无向图中对应结点之间也要用边相连，而这条边的含义是：从其中一个景点出发，通过中转站到达另一景点所需的最短距离。  
此时，旅游景点之间的公路网就转化为加权无向图，寻找旅游各个景点近似最佳旅行线路问题就转化为：在给定的加权无向图中，寻找从给定的结点出发，行遍所有结点仅一次再回到该指定的结点，使得总权数最小，即总路程最短。可以运用图论中的最邻近插入法来寻找近似最佳旅游线路和路程。算法的基本步骤如下：  
步骤1：用沃舍尔∙弗洛伊德算法求出加权无向图中任意两点之间的最短路程，形成仅含一条边的初始道路$\left\langle i,j\right\rangle$，权$w(i,j)$表示道路$\langle i,j\rangle$的长度。  
步骤2：设$x$表示最新加到这道路$\langle i,j\rangle$上的景点，从不属于该条道路上所有景点中选一个与景点$x$距离最近的景点𝑦，把连接景点$x$与景点𝑦的边加到$\langle i,j\rangle$上。重复这个步骤，直到加权无向图中所有景点都包含到$\left\langle i,j\right\rangle$这条路上。  
步骤3：将连接起点与最后加入景点之间的边加到这条路上，就得到一个总权数最小的汉密尔顿回路。  
![](images/3eb5c42c98242b09cf1d107a9f19a39189dbcd95c1ca7e77768503681d0519c4.jpg)  
下面结合具体实例说明寻找近似最佳旅行线路的具体构造过程。  
从上述讨论和例题10.18 可以看出，遍历多个景点的最短旅游路线问题，其实就是从具有$n$个结点的无向带权完全图中寻找一条哈密顿回路的问题。如果景点个数较多的时候，比如说几十个或者上百个，则上述算法就非常复杂甚至不可行。  
这其实是图论中的一个著名问题，通常称之为货郎担问题。因为该问题也可以描述为：某地区共有${n}$个村庄，某售货员从他所在的某个村庄出发，前往其它$𝑛$−1个村庄一次且恰好一次，最后返回到他所在的村庄，求一条满足上述要求且总路程最短的回路。  
货郎担问题是一个十分有趣而且具有实用价值的问题，很多数学家和计算机科学家对该问题做了大量的研究，取得了丰硕的研究成果。但是，遗憾的是至今无法找到一个有效的精  
确算法，这显然是一个 NP-hard 问题，当图中结点较多时，精确算法由于计算量过于巨大而变得不可行。目前，对该问题的求解主要采用近似算法，例如在例题10.18 中使用的最近邻算法，除此之外还有抄近路算法、动态规划算法、模拟退火算法、遗传算法、蚁群算法等等，读者可参阅相关的资料进一步深入学习。"
最大公因数,概念,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.2 整数的因数分解', '一、公因数与公倍数']","{'实体类型': '概念', '定义': '两个或多个整数共有因数中最大的一个，假设a和b是任意给定的两个整数，a和b的所有公因数中最大的那个整数称为a和b的最大公因数', '算法': '经典构造算法', '记法': 'gcd(a,b)或(a,b)', '性质': '若a和b不全为零，则gcd(a,b)>0', 'name': '最大公因数'}",,3,对于任意两个整数，它们之间可以进行加法运算、减法运算和乘法运算，却不一定能够进行整除运算。因此，我们可以将整除运算作为一个基本工具来考察单个整数的离散结构特征以及整数与整数之间的各种联系。本节首先介绍公因数和公倍数的相关概念与性质，然后给出最大公因数的经典构造算法，最后讨论整数基于整除性质的分解。由于非零整数的正负号不影响其整除性质，因此，不失一般性，以下关于整数的讨论，在默认状态下是针对非负整数范围，所得结论可直接推广到所有整数的范围。
最大公约数,概念,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.2 整数的因数分解', '三、算术基本定理']","{'实体类型': '概念', '计算方法': '通过整数的素因子分解式，取各素数的幂的最小值'}",,4,"对于是任意给定的两个整数$a$ 和$b$，如果$a$ 能够整除$b$，则通过整数$a$ 实现了对整数$b$的一个分解，即将$b$ 分解成$a$ 和另外一个整数的乘积。现在我们从整除的角度讨论整数的分解问题，亦即整数的因数分解问题。  
我们知道，素数是整个整数中不能够再分解的数，因为素数除了±1和其自身之外，没有其它的非平凡因子。因此，在对整数进行因数分解的过程中可以将素数看出是构成整数的最基本的要素或构件。通过对整数进行到素数层次的因数分解，就可以从整除的角度比较完整地考察整数的基本结构，并由此探究整数的基本性质和基本规律。  
【定理2.12】任何大于1 的正整数$a$，或为一素数，或可以写成若干素数的积，即$a=$$p_{1}p_{2}\cdots p_{b}$，其中$p_{i}(1\leq i\leq b)$是素数。  
[定理2.13] (算术基本定理) 任何大于1 的整数$a$可以唯一表示成
$$
a=p_{1}^{a_{1}}p_{2}^{a_{2}}\cdots p_{k}^{a_{k}}\tag{2-4}
$$  
其中$p_{1},p_{2},\cdots,p_{k}$是素数，$p_{1}<p_{2}<\dots<p_{k}$，$a_{1},a_{2},\cdots,a_{k}$是正整数。  
上述定理给出了整数素数分解的存在性与唯一性，称之为算术基本定理。由此可以看出，整数的素数分解在整数理论以及在整数初等数学中的重要性。  
【定义2.8】若$p_{1},p_{2},\cdots,p_{k}$是素数，$p_{1}<p_{2}<\cdots<p_{k},$，$a_{1},a_{2},\cdots,a_{k}$是正整数，那么称  
$$
a=p_{1}^{a_{1}}p_{2}^{a_{2}}\cdots p_{k}^{a_{k}}\tag{2-6}
$$  
是整数$a$ 的素幂分解式，其中$p_{i}$是素数，$p_{1}<p_{2}<\dots<p_{k}$，$a_{i}$是正整数。【例题2.12】写出51480 的素幂分解式。  
整数的素幂分解式给出了整数一种基于素数的结构表达，在数论研究中具有非常重要的作用。例如，下面两个定理表明，可以使用其素幂分解式计算两个整数的最大公约数和最小公倍数，还可以证明最大公约数和最小公倍数之间的关系。  
【定理2.14】设整数$a,~b$ 的素因子分解式分别为：  
$$
a=p_{1}^{a_{1}}\cdots p_{k}^{a_{k}};\,\,\,b=p_{1}^{b_{1}}\cdots p_{k}^{b_{k}}
$$  
其中$p_{1},\cdots,p_{k}$是互不相同的素数，$a_{1},\cdots,a_{k},\;\;b_{1},\cdots,b_{k}$是非负整数。则有：  
$$
{\operatorname*{gcd}(a,b)=p_{1}^{m i n(a_{1},b_{1})}\cdots p_{k}^{m i n(a_{k},b_{k})\tag{2-7}}}
$$  
$$
{\operatorname{lcm}(a,b)=p_{1}^{m a x(a_{1},b_{1})}\cdots p_{k}^{m a x(a_{k},b_{k})}}\tag{2-8}
$$"
最大匹配,概念,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.2.2 完备匹配与最大匹配']","{'实体类型': '概念', '定义': '二分图中基数最大的匹配', '特点': '总是存在，但不一定是完备匹配'}",,3,"首先考察一个有趣的问题：假设在某个小型舞会上有5 名男士和5 名女士，其中某些男士与某些女士之间相互认识，问如何安排才能使得相互认识的男生和女士人成为舞伴。  
可用如图10-30（a）所示的二分图模型$G=\langle X,E,Y\rangle$表示上述舞伴配对问题，其中结点集合$X=\{x_{1},x_{2},x_{3},x_{4},x_{5}\}$和$Y=\{y_{1},y_{2},y_{3},y_{4},y_{5}\}$分别表示5 名男士和5 名女士构成的集合，图中有无向边$(x_{i},y_{j})$当且仅当男士$x_{i}$与女士$y_{j}$相互认识。  
![图10-30  舞伴的安排问题 ](images/e92b7888a1cc6a1b77006b78c8c42919c89a7e806394091bb76e5c5538b07826.jpg)  
通过观察，不难得到如图10-30（b）中实线边所示的一种安排方案。由于每个人最多只能与一个异性匹配成舞伴，故所得到的安排方案其实就是图$G=\langle X,E,Y\rangle$中5 条不相邻边组成的$E$的子集：$M=\{(x_{1},y_{3}),(x_{2},y_{1}),(x_{3},y_{2}),(x_{4},y_{5}),(x_{5},y_{4})\}_{\circ}$。  
不难看出，上述问题其实就是在两类不同性质的对象之间寻找某种配对或者匹配的问题。事实上，日常生活和工作中的很多问题，例如学生选课、工作任务安排等等，都可以归结为这种匹配问题。对上述实例进行抽象，得到如下匹配的相关概念：  
【定义10.4】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，图中互不相邻的边构成$.E$的子集$M$称为$G$的一个匹配，$G$中与$M$中的边关联的结点称为匹配$M$的饱和结点。如果$X$中每个结点都是某个匹配的饱和结点，则称该匹配为$G$的一个$X^{.}$-完备匹配；如果𝑌中每个结点都是某个匹配的饱和结点，则称该匹配为$G$的一个𝑌-完备匹配；如果$G$的某个匹配既是$X-$完备匹配，又是𝑌-完备匹配，则称该匹配为完备匹配。$G$中基数最大的匹配称为𝐺的最大匹配，最大匹配中的边数称为$G$的匹配数，记作$\alpha^{\prime}(G)$。  
由定义10.4 可知，二分图的$X^{-}$完备匹配、$Y-$完备匹配和完备匹配肯定是最大匹配，反之不然，最大匹配不一定是$X-$完备匹配、$Y-$完备匹配或完备匹配。对于任意一个给定的二分图，其最大匹配总是存在，但其$X{-}$完备匹配、$Y-$完备匹配或完备匹配不一定存在。如果一个二分图存在完备匹配，则必有$|X|=|Y|$，反之不然。  
![图10-31  二分图及其最大匹配  ](images/426797d69400c6077f0021e199ce3acdf2169381fe7ee70516dbf26e96f0ac68.jpg)  
例如，对于图10-31（a）所示的二分图，图10-31（b）所示的全部实线边构成的集合：  
$$
M=\{(x_{1},y_{3}),(x_{2},y_{1}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
是该二分图的一个最大匹配。该匹配显然不是$X^{-}$完备匹配、$Y-$完备匹配或完备匹配，因为$x_{4}$和$y_{4}$均是其非饱和点。再如，图10-30（b）中实线边所示的匹配显然是一个完备匹配，自然也是最大匹配。  
下面考察对于一个给定的二分图$G=\langle X,E,Y\rangle$，当$G$满足什么条件时存在完备匹配。这里仅讨论$X^{-}$完备匹配的情形，至于$Y-$完备匹配和完备匹配的情况，可类似讨论。  
首先给出著名的霍尔婚姻定理，该定理给出了二分图$G=\langle X,E,Y\rangle$存在$X^{-}$完备匹配的一个充分必要条件，具体如下：  
【定理10.8】（霍尔婚姻定理）设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，则$G$存在$X^{-}$完备匹配的充分必要条件是$X$中任意$k$个结点至少与𝑌中$k$个结点相邻。具体地说，就是对于$\forall S\subseteq X$，有$|S|\leq|\mathsf{N}(\mathsf{S})|$，其中N(S)表示𝑌中所有与S中结点相邻的结点组成的集合。  
![图10-32  $X$-完备匹配存在性的判定](images/e5661ccfd2ab0df27e3feadf55016324a2bdd2f775f9de7183f592d16a209926.jpg)  
例如，图10-32（a）所示二分图满足霍尔婚姻定理的条件，故存在$X^{-}$完备匹配，图$10-$32（b）所示二分图不满足霍尔婚姻定理的条件，故不存在$X^{-}$完备匹配。  
定理10.8 中需要计算𝑋中所有子集在𝑌中邻接结点的集合，在很多情况下计算量很大，不便使用。为此，下面给出一个名为$t-$条件的充分条件，具体如下：  
【定理10.9】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，如果$G$满足：$X$中每个结点至少关联t-条边且𝑌中每个结点至多关联$t^{-}$条边，则图$G$一定存在$X^{-}$完备匹配。  
判断𝑡条件非常简单，只需计算$X$中结点最小度$\delta(X)$和$\Delta(Y)$中结点最大度$\Delta$即可。例如，对于图10-32（a）所示二分图，显然有$\delta(X)=\Delta(Y)=2=t$，故存在$X{-}$完备匹配。"
最大平面图,概念,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.3.1  平面图的概念与性质']","{'实体类型': '概念', '定义': '对其再加一条边就变成不可平面图的平面图'}",,3,"所谓平面图，直观地说就是可以将该图嵌入到某个平面上。如图10-46（a）所示，图模型的边有时不仅在结点处相交，而且还在某些非结点处有交叉，这些非结点处交叉点的边重叠特征显然会导致图模型不能嵌入在同一个平面上。因此，为了将图模型嵌入平面，首先必须适当调整该图中边的走向，以保证任意两条边不会在非结点处有交叉，如图10-46（b）所示。由此得到可平面图和平面图的相关概念。  
【定义10.6】设$G=\langle V,E\rangle$是任意给定的一个图模型，如果该图中有两条边在非结点处有交叉，则称这两条边为该图的交叉边，交叉的具体位置称为交叉点。如果可将图𝐺画在同一个平面上，并且所有边除在结点处之外均不交叉，则称图𝐺可嵌入平面，或称𝐺为可平面图，否则称该图为不可平面图或非平面图。对于可平面图𝐺，将其边不交叉的画法称为𝐺的平面嵌入表示。以平面嵌入方式表示的图可平面图𝐺称为平面图。对于一个平面图𝐺，若对其再加一条边就变成不可平面图，则称𝐺为最大平面图。  
![](images/ad5984e0ab09600028eb4068193d74e75743de0f027a20b4d084511a312873d4.jpg)  
![（a）完全二分图$K_{3,3}$  （b）无法消除交叉  ](images/aa69f9dcec49f0e95a534b493200688a98dae4f4be8a347fbd35c04b8c21413b.jpg)  
例如，对于图10-46（a）所示的图，该图有三对交叉边，即$(v_{1},v_{4})$和$(v_{2},v_{3}),~(v_{1},v_{4})$和$(v_{2},v_{5})$、$(v_{1},v_{5})$和$(v_{2},v_{3})$。由于可将该图表示成图10-46（b）的形式，故该图是一个可平面图。图10-46（b）所示的图就是一个平面图。显然，如果在该平面图上增加一条边，则该图就变成一个不可平面图，故该是一个最大平面图。再如，对于图10-47（a）所示的图模型，无论怎么调整边的走向都不能将其以平面嵌入方式表示，如图10-47（b）所示。故图10-47（a）所示的图模型为不可平面图或非平面图。  
在没有特别要求的情况下，通常将可平面图与平面图不加区分地统称为平面图。与一般图模型显著不同的是，平面图模型除了具有结点和边这两个基本构件之外，还有一般图模型所没有的面的概念，并且由进一步面衍生出边界的概念。因此，平面图是一类非常重要的特殊图模型，无论在理论上还是在应用方面都具有非常重要的价值，在印刷电路板的设计、城市管网设计与规划等多个领域得到实际应用。  
图论之父欧拉对平面图有着比较深刻的研究，发现并论证了平面图的结点、边和面之间的数量关系，提出了著名的欧拉公式。下面给出平面图中面的相关概念：  
【定义10.7】设$G=\langle V,E\rangle$是任意给定的一个平面图，由𝐺中边所包围且内部不包含结点与边的区域，称为$G$的一个面。区域面积有限的面称为有限面，区域面积无限的面称为无限面。对于$G$的任意一个面$R$，包围面$R$的所有边构成的回路称为面𝑅的边界，面𝑅边界中边的个数称为面$R$的次数或度，记为${\bf d e g}(R)$。  
通俗地说，如果把一个平面图画在平面上，然后用小刀沿着图的边将平面切开，那么整个平面就被切成若干块，其中每一块就是图的一个面。或者说，平面图的一个面就是平面中一个以边为界线不能再分割的区域块。例如，对于图10-46（b）所示的平面图，一共有六个面，其中有一个面是无限面，其余五个是有限面。需要注意的是，对于任何一个平面图，该图有且仅有一个无限面。下面的定理10.11 给出了平面图中面数与边数的数量关系：  
【定理10.11】平面图中所有面的次数之和等于边数的两倍。  
下面定理10.12 是著名的欧拉公式，给出了平面图中结点、边和面之间的数量关系：  
【定理10.12】设$G=\langle V,E\rangle$是任意给定的一个连通平面图，若它有$n$个结点、$m$条边、$r$ 个面，则有  
$$
n-m+r=2\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
【定理10.13】如果平面连通图$G$每个面的次数均为$l(l\geq3)$，则有：  
$$
m=l(n-2)/(l-2)
$$  
其中$m$为$G$的边数，$n$为$G$的结点数。  
【定理10.14】设$G$是一个$(n,m)$简单连通平面图，若$m>1$，则有：  
$$
m\leq3n-6\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
由定理10.4 的逆命题不成立，也就是说满足不等式$m\leq3n-6$的简单连通图不一定是平面图。但是对于一个简单连通图，若不满足$m\leq3n-6$，则一定是非平面图。因此，可用定理10.4 的结论证明某个简单连通图不是非平面图。  
【定理10.15】设$G$为一平面连通简单图，其结点数$n\geq4$，边数为$m$，且$G$不以$K_{3}$为其子图，则有$m\leq2n-4$。  
【定义10.8】对于是任意给定的一个图模型$G=\langle V,E\rangle$  
设$e=(u,v)$是$G$的任意一条边，如果在图$G$中删除该边并新增一个结点$w$及两条边$e_{1}=$$(u,w)$、$e_{2}=(w,v)$ ，则称该操作为对图$G$的边切割操作；  
设𝑤是$G$中任意一个度数为2 的结点，且是边${e_{1}=(u,w)}$和$e_{2}=(w,v)$的公共结点，如果在图$G$中删除结点$w$及边$e_{1},\,e_{2}$，并增加边$e=(u,v)$，则称该操作为对图$G$的结点贯通操作；  
对图$G$的边切割操作和结点贯通操作统称为对图$G$的同胚操作。  
显然，边切割操作和结点贯通操作是一对互逆操作。例如，对于图10-48 所示的两个图模型，可通过对边的切割操作将$G_{1}$变成$G_{2}$，也可通过对结点做贯通操作将$G_{2}$变成$G_{1}$。  
![图10-48  图的同胚操作与同胚关系  ](images/17b45e1706460a818a5492fb4df19f0ddd6b072e9cf57afef7db0852f0c58237.jpg)  
下面在同胚操作的基础上，引入如下两个图之间的同胚关系：  
【定义10.9】设$G_{1}=\langle V_{1},E_{1}\rangle$和$G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，如果可用同胚操作将其中一个转化为另外一个，则称$G_{1}$与$G_{2}$具有同胚关系，简称为$G_{1}$与$G_{2}$同胚。  
根据上述同胚的概念，可以得到如下关于平面图判定的库拉托夫斯基定理：  
【定理10.16】（库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是$G$的任何子图都不同胚于$K_{5}$或$K_{3,3}$。  
【定理10.17】(库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是𝐺的任何子图都不能通过边的收缩得到$K_{5}$或$K_{3,3}$。  
![图10-51 彼得森图收缩为$ K_{5}$](images/b6cd48c8bf37519af48b0cc187afdf1adc13d2c5e160a08fe418ce5c94762fd6.jpg)  
库拉托夫斯基定理是一个非常著名定理，通常将$K_{5}$和$K_{3,3}$称为库拉托夫斯基图。可以使用该定理判定一个图是否为平面图。例如，对于图$10{-}51\mathrm{a}$）所示的彼得森图，收缩其边$(v_{i},u_{i})(i=1,2,3,4,5)$，则可得到图$K_{5}$，见图10-51b)。故彼得森图不是平面图。  
值得注意的是，虽然库拉托夫斯基定理给出了平面图判定的充分必要条件，但是目前还没有基于该定理得到一个有效的判定算法。因此，对于一个比较复杂的图模型，要判定其是否为平面图，有时并不是一件容易的事情。"
最大流最小切割定理,定理,"['第十章  特殊图模型与算法', '§ 10.4 网络流图及其优化问题', '10.4.3 最大流求解算法']","{'实体类型': '定理', '内容': '最大流量等于最小割容量'}",,3,"网络流理论的创立主要用于解决最大网络流问题，即在一定的约束条件下，如何使得网络中流的总量达到最大。该理论证明了最大流量一定等于最小割容量这个重要结论，并根据这一结论设计并实现了多种最大流的算法。其中比较经典的有Ford-Fulkerson 算法、Edmonds-Karp 算法、Dinic 算法以及预流推进算法等。  
本节主要介绍其中最具代表性的Ford-Fulkerson 算法。该算法由美国普林斯顿大学的两位著名运筹学教授Ford.L.R 和Fulkerson.D.R 提出。Ford-Fulkerson 算法是一种迭代算法，基本思路如下：首先，对所有结点$u,v\in V$令$f(u,v)=0$。然后，通过迭代的方式不断在残留网络中寻找一个增广路径来增加流值，直到残留网络中不包括增广路径为止。  
具体地说：首先，初始化一条容量为0 的流$f$和一个残余网络$G_{f}$，第一个残余网络为原  
图$G$，每条边的残留容量初始化为每条边的初始容量$c_{f}(u,v)=c(u,v)$。然后，在残留网络$G_{f}$中寻找增广路径$P$，取增广路径$P$中的边的残留容量$c_{f}(u,v)$最小值作为流的增量$\triangle\,f$，使得$f^{\prime}=f+\triangle\,f$。修改剩余图中每条边的容量：  
$$
c_{f}^{\prime}(u,v)=c_{f}(u,v)-\triangle\,f
$$  
得到残留网络$ G_{f}$。重复上述过程，直到找不到一条增广路径为止。  
Ford-Fulkerson 算法依赖于残留网络、增广路径和切割这三个概念。算法的正确性可由最大流最小切割定理保证。设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和𝑡分别为其源点和汇点，$f$为$G$的一个流，则该算法基本过程如下：  
1）对网络$G=\langle V,E\rangle$初始化，使$f(e)=0$，$e\in E$  
2）给源点𝑠标号$(-,\ \infty)$，其它结点均未标号；  
3）依次选一个未标号的结点，根据其方向进行标号，若当前标号的结点为汇点𝑡，转步骤4），否则转步骤6）；  
4）选择一条标号过的增流路径进行增流；  
5）转步骤2）  
6）这时得到的$f$就是最大可行流。  
对于如图10-72 为初始网络$G$，其中边上的数字表示对应边的容量，下面介绍通过Ford-Fulkerson 算法寻找其的最大可行流的具体实现过程：  
1）首先初始化$f(e)=0$，$e\in E$，如图10-73 所示；  
2）给源点$𝑠$标号$(-,\infty)$，其它结点均未标号，如图10-74 所示；  
![](images/d01d4ec14f1aff44a86873230240f7edbcb814f97a9366a1ac732e953b2aaa81.jpg)  
3 ）选可进行正向或反向标号的结点进行标号，若当前标号的结点为 𝑡 ，则转步骤 4 ） ； 若 没有这样的结点可选时，则转步骤6），如图10-75 所示；  
4）当前标号的结点为𝑡，对标号过的增流路径进行增流，增流路径为：$(s-\textit{a}-\textit{b}-$$c-\ t)$，增量$\triangle\,f$取增广路径中的边的残留容量$c_{f}(u,v)$最小值2，如图10-76 所示；  
5）转到步骤2），即给源点𝑠标号$(-,\infty)$，其它结点均未标号，如图10-77 所示；  
![](images/34aabd8b5a71470ee2b35d4d37961da9a5f6ada16975b230634ead0f16e07488.jpg)  
6）类似地，按照步骤3 再次进行标号，如图10-78 所示；  
7）当前标号的结点为𝑡，对标号过的增流路径进行增流，增流路径为：$(s-b-a-t)$增量$\triangle\,f$取增广路径中的边的残留容量$c_{f}(u,v)$最小值6，如图10-79 所示；  
8）同理，再对源点𝑠标号$(-,\ \infty)$，其他结点均未标号，如图10-80 所示；  
![](images/0f5b5f38aed586b9e60d5dccb4b3630e897dacff029a529f37f234c7155e86b7.jpg)  
9）按步骤3，再次进行标号，如图10-81 所示；  
10）当前标号的结点为𝑡，对标号过的增流路径进行增流，增流路径为：$\begin{array}{r l r}{~~~}&{{}(s-}&{b-a-}\end{array}$$t)$，增量$\triangle\,f$取增广路径中的边的残留容量$c_{f}(u,v)$最小值2，如图10-82 所示；  
11）同理，再对源点𝑠标号$(-,\ \infty)$，其他结点均未标号，类似的，增流路径为：$(s-\ b-$$c-t)$，增量$\triangle\,f$取1，如图10-83 所示；  
![](images/062c661062259beec86ff3629be8e97fdac80b28c61e2ace5ae35565f4731050.jpg)  
12）同理，再对源点𝑠标号$(-,\ \infty)$，其它结点均未标号，类似地，增流路径为：$\begin{array}{l l}{(s-}&{c-}\end{array}$$t)$，增量$\triangle\,f$取2，如图10-84 所示；  
13）同理，再对源点𝑠标号$(-,\ \infty)$，其它结点均未标号，类似地，增流路径为：$(s-c-$$b-a)$，此时当前结点为$a$，算法结束，所得可行流即为所求最大流，如图10-85 所示。  
![图10-84  增流过程  5](images/1913d4d69345305d204c147879cef0c2b861b90402556b9d5ebafe81eeaf5bff.jpg)  
![图10-85  网络$G$最大流  ](images/d7adb0913e78b96ab009478c7164178b41b7185b8446090115774418a82e3cf7.jpg)  
下面给出网络最大流的一个具体应用实例：  
【例题10.17】某货运车站有$n$个车道，由于车道长度有限，每个车道在某时刻最多只能停靠一列货运列车。车站正常运行后，每天有$m$列货运列车从车站经过，其中第$i$ 列列车到达车站的时间为$𝑅𝑒𝑎𝑐ℎ[𝑖]$，列车上装有价值$𝐶𝑜𝑠𝑡[𝑖]$的货物。如果准许列车𝑖进站，则车站将获得$10\%\times C o s t[i]$的收益，受到货物搬运时间制约，列车在站停留时间长度为$𝑆𝑡𝑎𝑦[𝑖]$。这段时间内，列车将占用车站某个车道；若不允许某列车进站，则该列车直接出站，此时车站无任何收益。现有2 个车道，5 列列车，列车进站时间、停车价值、停留时间如表10-1 所示，如何合理安排列车的进站与出站，才能使得车站的总收益最大？  
![表10-1 时间价值表 ](images/a7dc7c1c3b8b134efa88b94b361c280ae0e7e4db6c3d4edd361dc330595e5076.jpg)  
![图10-86 进出站时间 ](images/2c392864c4179f14536de4f9b63f959455c42ecc7344ede3aef7ced37250a84d.jpg)  
【解】可用一个流网络对该问题进行建模，具体过程如下：  
1）将每一列列车看成是联结两个结点的一条带权边，如第𝑖列列车拆成点$𝑖$和$i^{\prime}$，$𝑖$到$i^{\prime}$之间加一条容量为1，费用为$10\%\times C o s t[i]$的边$i\rightarrow i^{\prime}$；若$i\rightarrow i^{\prime}$的边的流量为1，则表示该列火车进站，并获得$10\%\times C o s t[i]$。  
2）增加一个源点$S$，$S$与每个点$i$连一条容量为1 费用为0 的边$S\rightarrow i$；如果$S\rightarrow i$的流量为1，则表示列车$𝑖$作为某个车道的第一列入站的列车  
3）再增加一个源点$S^{\prime}$，$S^{\prime}{\to}S$的容量为$n$，表示有$n$个车道；  
4）增加一个汇点$T$，每个点$i^{\prime}$与𝑇连一条容量为1 费用为0 的边$i^{\prime}\rightarrow T$；如果𝑖’ $\rightarrow T$的流量为1，则表示列车$𝑖$作为某个车道的最后一列入站的列车；  
5）对于所有$𝑖$和$j(i\neq j)$，如果$R e a c h[i]+S t a y[i]<R e a c h[j]$，则在$i^{\prime}$与$𝑗$之间连一条容量为1，费用为0 边，表示可以在某一个车道先停入列车𝑖，等𝑖出站后再停入列车𝑗。  
![图10-86 列车流量网络模型  ](images/e877c0962ea89c788357a0ce9a48c4f306c3bc33bc71d559136cc0a052c8c375.jpg)  
![图10-87 列车调度问题总收益最大流图  ](images/820628b77bdb2600c45369a5e8ccfe88b488f7bb28ab752799b5e76d0dabc2f0.jpg)  
如图10-86 所示的流网络为列车调度的流量网络模型，其中粗线箭头上的数字表示费用，未标数字的弧的费用为 0 ，未标明容量的弧的容量为 1 。  
![图10-88 列车进站安排  ](images/25158a79180787e9c0c3c5ee956180ccd3bcebdba893d1c1a3d3773d0bfcced1.jpg)  
对于求解出来的所有最大流分别计算整个网络的费用，求得如图10-87 所示的最大流即为安排列车的进站与出站，使得车站的总收益最大的方案，其中粗线箭头上的数字表示流量，未标数字的弧的流量为0。由图10-87 知，列车进站的最优安排方案为：让列车1、3 进站并停留在第一车道，列车2、5 进站并停留在第二车道，具体如图10-88 所示，其中粗线表示先停入列车1 再停入列车3；细线表示先停入列车2 再停入列车5。此时车站最大收益为$0.5+0.6+0.4+0.3=1.8$。"
最大流最小割定理,定理,"['第十章  特殊图模型与算法', '§ 10.4 网络流图及其优化问题', '10.4.1 流网络与切割']","{'实体类型': '定理', '内容': '流网络的最大流量等于其最小切割的容量', '结论': '最大流、无增广路径、存在切割满足f(S,T)=c(S,T)三者等价'}",,3,"首先介绍流网络模型的相关基本概念及其数据描述。如同每条公路有运输量、每根水管有最大流量限制一样，网络流图的每条边都有容量，或者说每条边都有一定的流量。网络流图其实就是每条边具有附带容量（可理解为权值）的有向图。其具体定义如下：  
【定义10.4.1】设有向图$G=\langle V,E\rangle$，$V$中包含一个源结点𝑠和一个汇结点$t$，且每条边$(u,v)\in E$均有一个非负容量$c(u,v)\geq0$，若$(u,v)\notin E$，则规定其容量$c(u,v)=0$，此时称有向图$G$是一个网络流图，简称为流网络或网络。源结点$s$即起点，汇结点$t$即终点。网络流是定义在网络$G$中关于边的一个实函数，用$f(u,v)$表示有向边$(u,v)\in E$上结点$ u$到结点$v$的网络流。$f(u,v)$表示$u$ 到$v$的净流。  
例如，如果$_{u}$到$v$有6 个单位的实际流，且$v$到$u$有3 个单位的实际流，那么$f(u,v)=$3，$f(v,u)=-3$，互为相反数。净流是实际通过的流量矢量和，可类比合力的概念。  
满足以下三个性质的网络流$f$称之为可行流：  
（1）容量限制：对所有的$(u,v)\in E$，都有$f(u,v)\leq c(u,\textit{}v)$。即一条边的流不能超过它的容量。这也很容易理解，如同自来水管的水流自然不会超过水管本身的容量。  
（2）斜对称：对所有$(u,v)\in E$，都有$f(u,v)=-f(v,u)$。即点$\cdot u$到$v$的净流必须与点𝑣到$u$的净流相反。可以类比物理中矢量概念，如作用力与反作用力，强调的是其方向性。  
（3）流守恒：对所有$u\in V-\{s,t\}$，都有$\textstyle\sum_{v\in V}f(u,v)=0$。即除源结点$𝑠$和汇结点$𝑡$外，其余每个结点的净流之和为0。  
![图10-68 网络及可行流  ](images/bada5974bba3db0db4c82fa8e3076a8834542abfa1641f17fac232a32e6fee29.jpg)  
例如，如图10-68 所示，网络中定义网络流$f(u,v)$是一条可行流。图中每条边所对应的序偶表示该边的容量和流量，第一个数字表示边的容量，第二个数字表示边的流量。  
下面结合图10-68 所示网络实例介绍网络流模型中与边相关的几个概念。可根据边的容量与流的大小关系对网络中的边进行分类：  
（1）满足$f(u,v)=c(u,v)$的边称为饱和边，如边(1,2)、 (2,3)  
（2）满足$f(u,v)<c(u,v)$的边称为非饱和边，如边(2,4)。  
（3）满足 $f(u,v)=0$ 的边称为零流边，如边 (3,4) ；满足 $f(u,v)>0$ 的边称为非零流 边，如边(5,4)。  
（4）既不是零流边也不是饱和边的边，称为弱流边，如边(5,6)  
如果把图10-78 看作是一个公路网，6 个结点分别表示6 座城镇，每条边上的权数表示两城镇间的距离。若现在需要从起点1 将一些物资运送到终点6，应怎样选择路线才能使总运输距离最短。我们知道，这样一类问题称为最短路径问题。类似的，如果把图10-1看作为一个输油管道网，结点1表示为发送点，结点6表示为接收点，其它点表示为中转站，各边的权数表示该段管道的最大运输油量。那么如何安排输油线路才能使从1到6的总运输量最大。这样一类问题就是最大流问题。  
最大流问题是网络优化中的一个典型的问题，简单地说，就是在满足容量约束的前提下将尽可能多的流从源结点流向汇结点。因此，最大流问题就是求流网络$G$中使其流量$f$达到最大的一个可行流，该可行流即为最大流。具体定义如下：  
【定义10.4.2】设有向图$G=\langle V,E\rangle$是任意给定的一个网络流图，若$f$是$G$ 中流量最大的的可行流，则称该可行流$f$是$G$ 的最大流，构构造网络流图$G$ 中最大流的问题，就称为网络流图的最大流问题。  
为了实现对最大流问题的求解，必须对网络流图中的增流空间进行合理的度量，通常使用一种名为残留网络的图模型实现这项工作。残留网络的具体定义如下：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图， $f$为$G$的一个流，对于$G$的任意一条边$(u,v)$，在不超过容量$c(u,v)$条件下，从$u$到$v$可压入的额外流量，称为$(u,v)$的残留容量。由$G$中所有边残留容量构成的带权有向图称为$G$的残留网络，记为$G_{f}=\langle V,E_{f}\rangle$。  
若$c_{f}(u,v)$为残留网络$G_{f}$中边$(u,v)$的残留容量，且边$(u,v)\in E$或边$(v,u)\in E$，则$(u,v)\in$$E_{f}$,$\,c_{f}(u,v)=c(u,v)-f(u,v)\,$。例如，若设$(u,v)$当前流量为(4,3)，此时$c(u,v)=4$，$f(u,v)$）$=3$，则有：$c_{f}(u,v)=1$。  
需要注意的是，残留网络具有这样的性质：假设从$_{.}u$到$v$已经有了3 个单位流量，那么从反方向上看，也就是从$v$ 到$u$ 就有了3 个单位的残留容量，这时$c_{f}(v,u)=3$。换句话说，从$u$ 到$v$ 有3 个单位流量，那么从$v$到$u$ 就有了将这3 个单位流量压回去的能力。因此，残留网络结点之间通常由双向带权边进行联结。例如，对于图10-69（a）所示的一个流网络$G$，图10-69（b）则表示该流网络𝐺的残留网络。  
![图10-69 流网络及其残留网络 ](images/d65d1c72064671125468548ae171a28ede5424f1d36d601972ed76c90131fc8c.jpg)  
对于任意给定的一个网络流图$G=\langle V,E\rangle$，可以通过其残留网络$G_{f}=\langle V,E_{f}\rangle$求得$G$的最大流。基本思路如下：首先，对所有的结点令初始状态时流的值为0，即对于$\forall u,v\in V$，有$f(u,v)=0$。然后，通过迭代方式其残留网络中不断寻找源点𝑠到汇点$t$之间的流量增广路径来增加网络流量值，直到残留网络没有这样的增广路径为止。  
因此，在残留网络$G_{f}=\langle V,E_{f}\rangle$寻找流量增广路径是最大流求解算法的关键。为正确理解该算法，现给出流网络增广路径的具体定义：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，$G_{f}=\langle V,E_{f}\rangle$为$G$在流$f$下的一个残留网络，则$G_{f}=\langle V,E_{f}\rangle$中任意一条从源点$s$到汇点$t$的简单路径$p$称为$G=\langle V,E\rangle$的一条流量增广路径，简称为增广路径。  
事实上，可将增广路径形象地理解为网络流图$G$中从源点𝑠到汇点𝑡的一条不违反流网络边容量限制的路径，并向这条路径压入一定的流量，以增加整个网络的流量值。例如，图10-69（b）所示的残留网络存在这样一条如图10-70 中加粗有向边所示的增广路径。  
![图10-70 增广路径 ](images/1e52dc98ce8f5b49283b093dbb72c0d5308ccdc9782306a98cb168474d58608f.jpg)  
![图10-71 流网络的一个切割](images/c52dd38b6f7d2bc46bb57e2440709d67355577a7b3d5fb2e920f10a5bfeb8598.jpg)  
若将图10-70 所示增广路径在流网络所对应每条边的流量增加4 个单位，得到一个新的流网络，其流量比原网络多4 个单位。然后，在新流网络所对应的残留网络中继续寻找新增广路径，直到找不到新增广路径为止。显然，现在的问题是：如果在残留网络$G_{f}=$$\langle V,E_{f}\rangle$中找不到增广路径，此时该残留网络所对应的流$f$是否就是流网络$G=\langle V,E\rangle$的最大流？要解决这个问题，必须进一步引入流网络切割的相关概念，具体如下：  
【定义10.4.4】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，如果将$G$的结点集合𝑉划分为𝑆和$T=V-S$两部分，使得源点$s\in S$且$t\in T$，则称$(S,T)$是$G=\langle V,E\rangle$的一个切割，简称为割。从集合 𝑆 到集合 𝑇 的所有有向边容量之和称为切割 $(S,T)$ 的容量，穿过切割 $(S,T)$所有边流量的代数和流量称为切割$(S,T)$的净流量，记为$f(S,T)$。  
主要注意的是，定义10.4.4 中边的流量带有正负方向，如果流从结点𝑆流向$T$，则该边的流量值为正，如果流从结点𝑇流向𝑆，则该边的流量值为负。例如，对图10-69（a）所示的流网络，可画一个如图10-71 所示的切割$(S,T)$，其容量为：  
$$
c(u,w)+c(v,x)=12+14=26
$$  
穿过该切割的净流量为：  
$$
f(u,w)+f(v,x)-f(w,v)=12+11-4=19
$$  
显然，对于任意一个切割，穿过该切割的净流量上界就是该切割的容量，即穿过切割的净流量不可能超过割的容量。由于流网络中所有切割的流都相等并且等于网络的流，因此，网络最大流必然无法超过网络的最小割。由此得到如下最大流最小割定理：  
【定理10.4.1】（最大流最小割定理）设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和$t$分别为其源点和汇点，则$G=\langle V,E\rangle$的最大流量等于其最小割切的容量。对于$G=\langle V,E\rangle$上的任意一个流$f$，以下三个结论彼此等价：  
(1) $f$是流网络$G=\langle V,E\rangle$的一个最大流；  
(2) 流网络$G=\langle V,E\rangle$的残留网络中不包括任何增广路径；  
(3) 存在流网络$G=\langle V,E\rangle$的某个切割$(S,T)$，满足：
$$
f(S,T)=c(S,T)
$$"
最大流求解算法,算法,"['第十章  特殊图模型与算法', '§ 10.4 网络流图及其优化问题', '10.4.3 最大流求解算法']","{'实体类型': '算法', '定义': '用于求解网络流图中最大流的算法', '经典算法': 'Ford-Fulkerson算法、Edmonds-Karp算法、Dinic算法、预流推进算法'}",,3,"网络流理论的创立主要用于解决最大网络流问题，即在一定的约束条件下，如何使得网络中流的总量达到最大。该理论证明了最大流量一定等于最小割容量这个重要结论，并根据这一结论设计并实现了多种最大流的算法。其中比较经典的有Ford-Fulkerson 算法、Edmonds-Karp 算法、Dinic 算法以及预流推进算法等。  
本节主要介绍其中最具代表性的Ford-Fulkerson 算法。该算法由美国普林斯顿大学的两位著名运筹学教授Ford.L.R 和Fulkerson.D.R 提出。Ford-Fulkerson 算法是一种迭代算法，基本思路如下：首先，对所有结点$u,v\in V$令$f(u,v)=0$。然后，通过迭代的方式不断在残留网络中寻找一个增广路径来增加流值，直到残留网络中不包括增广路径为止。  
具体地说：首先，初始化一条容量为0 的流$f$和一个残余网络$G_{f}$，第一个残余网络为原  
图$G$，每条边的残留容量初始化为每条边的初始容量$c_{f}(u,v)=c(u,v)$。然后，在残留网络$G_{f}$中寻找增广路径$P$，取增广路径$P$中的边的残留容量$c_{f}(u,v)$最小值作为流的增量$\triangle\,f$，使得$f^{\prime}=f+\triangle\,f$。修改剩余图中每条边的容量：  
$$
c_{f}^{\prime}(u,v)=c_{f}(u,v)-\triangle\,f
$$  
得到残留网络$ G_{f}$。重复上述过程，直到找不到一条增广路径为止。  
Ford-Fulkerson 算法依赖于残留网络、增广路径和切割这三个概念。算法的正确性可由最大流最小切割定理保证。设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和𝑡分别为其源点和汇点，$f$为$G$的一个流，则该算法基本过程如下：  
1）对网络$G=\langle V,E\rangle$初始化，使$f(e)=0$，$e\in E$  
2）给源点𝑠标号$(-,\ \infty)$，其它结点均未标号；  
3）依次选一个未标号的结点，根据其方向进行标号，若当前标号的结点为汇点𝑡，转步骤4），否则转步骤6）；  
4）选择一条标号过的增流路径进行增流；  
5）转步骤2）  
6）这时得到的$f$就是最大可行流。  
对于如图10-72 为初始网络$G$，其中边上的数字表示对应边的容量，下面介绍通过Ford-Fulkerson 算法寻找其的最大可行流的具体实现过程：  
1）首先初始化$f(e)=0$，$e\in E$，如图10-73 所示；  
2）给源点$𝑠$标号$(-,\infty)$，其它结点均未标号，如图10-74 所示；  
![](images/d01d4ec14f1aff44a86873230240f7edbcb814f97a9366a1ac732e953b2aaa81.jpg)  
3 ）选可进行正向或反向标号的结点进行标号，若当前标号的结点为 𝑡 ，则转步骤 4 ） ； 若 没有这样的结点可选时，则转步骤6），如图10-75 所示；  
4）当前标号的结点为𝑡，对标号过的增流路径进行增流，增流路径为：$(s-\textit{a}-\textit{b}-$$c-\ t)$，增量$\triangle\,f$取增广路径中的边的残留容量$c_{f}(u,v)$最小值2，如图10-76 所示；  
5）转到步骤2），即给源点𝑠标号$(-,\infty)$，其它结点均未标号，如图10-77 所示；  
![](images/34aabd8b5a71470ee2b35d4d37961da9a5f6ada16975b230634ead0f16e07488.jpg)  
6）类似地，按照步骤3 再次进行标号，如图10-78 所示；  
7）当前标号的结点为𝑡，对标号过的增流路径进行增流，增流路径为：$(s-b-a-t)$增量$\triangle\,f$取增广路径中的边的残留容量$c_{f}(u,v)$最小值6，如图10-79 所示；  
8）同理，再对源点𝑠标号$(-,\ \infty)$，其他结点均未标号，如图10-80 所示；  
![](images/0f5b5f38aed586b9e60d5dccb4b3630e897dacff029a529f37f234c7155e86b7.jpg)  
9）按步骤3，再次进行标号，如图10-81 所示；  
10）当前标号的结点为𝑡，对标号过的增流路径进行增流，增流路径为：$\begin{array}{r l r}{~~~}&{{}(s-}&{b-a-}\end{array}$$t)$，增量$\triangle\,f$取增广路径中的边的残留容量$c_{f}(u,v)$最小值2，如图10-82 所示；  
11）同理，再对源点𝑠标号$(-,\ \infty)$，其他结点均未标号，类似的，增流路径为：$(s-\ b-$$c-t)$，增量$\triangle\,f$取1，如图10-83 所示；  
![](images/062c661062259beec86ff3629be8e97fdac80b28c61e2ace5ae35565f4731050.jpg)  
12）同理，再对源点𝑠标号$(-,\ \infty)$，其它结点均未标号，类似地，增流路径为：$\begin{array}{l l}{(s-}&{c-}\end{array}$$t)$，增量$\triangle\,f$取2，如图10-84 所示；  
13）同理，再对源点𝑠标号$(-,\ \infty)$，其它结点均未标号，类似地，增流路径为：$(s-c-$$b-a)$，此时当前结点为$a$，算法结束，所得可行流即为所求最大流，如图10-85 所示。  
![图10-84  增流过程  5](images/1913d4d69345305d204c147879cef0c2b861b90402556b9d5ebafe81eeaf5bff.jpg)  
![图10-85  网络$G$最大流  ](images/d7adb0913e78b96ab009478c7164178b41b7185b8446090115774418a82e3cf7.jpg)  
下面给出网络最大流的一个具体应用实例：  
【例题10.17】某货运车站有$n$个车道，由于车道长度有限，每个车道在某时刻最多只能停靠一列货运列车。车站正常运行后，每天有$m$列货运列车从车站经过，其中第$i$ 列列车到达车站的时间为$𝑅𝑒𝑎𝑐ℎ[𝑖]$，列车上装有价值$𝐶𝑜𝑠𝑡[𝑖]$的货物。如果准许列车𝑖进站，则车站将获得$10\%\times C o s t[i]$的收益，受到货物搬运时间制约，列车在站停留时间长度为$𝑆𝑡𝑎𝑦[𝑖]$。这段时间内，列车将占用车站某个车道；若不允许某列车进站，则该列车直接出站，此时车站无任何收益。现有2 个车道，5 列列车，列车进站时间、停车价值、停留时间如表10-1 所示，如何合理安排列车的进站与出站，才能使得车站的总收益最大？  
![表10-1 时间价值表 ](images/a7dc7c1c3b8b134efa88b94b361c280ae0e7e4db6c3d4edd361dc330595e5076.jpg)  
![图10-86 进出站时间 ](images/2c392864c4179f14536de4f9b63f959455c42ecc7344ede3aef7ced37250a84d.jpg)  
【解】可用一个流网络对该问题进行建模，具体过程如下：  
1）将每一列列车看成是联结两个结点的一条带权边，如第𝑖列列车拆成点$𝑖$和$i^{\prime}$，$𝑖$到$i^{\prime}$之间加一条容量为1，费用为$10\%\times C o s t[i]$的边$i\rightarrow i^{\prime}$；若$i\rightarrow i^{\prime}$的边的流量为1，则表示该列火车进站，并获得$10\%\times C o s t[i]$。  
2）增加一个源点$S$，$S$与每个点$i$连一条容量为1 费用为0 的边$S\rightarrow i$；如果$S\rightarrow i$的流量为1，则表示列车$𝑖$作为某个车道的第一列入站的列车  
3）再增加一个源点$S^{\prime}$，$S^{\prime}{\to}S$的容量为$n$，表示有$n$个车道；  
4）增加一个汇点$T$，每个点$i^{\prime}$与𝑇连一条容量为1 费用为0 的边$i^{\prime}\rightarrow T$；如果𝑖’ $\rightarrow T$的流量为1，则表示列车$𝑖$作为某个车道的最后一列入站的列车；  
5）对于所有$𝑖$和$j(i\neq j)$，如果$R e a c h[i]+S t a y[i]<R e a c h[j]$，则在$i^{\prime}$与$𝑗$之间连一条容量为1，费用为0 边，表示可以在某一个车道先停入列车𝑖，等𝑖出站后再停入列车𝑗。  
![图10-86 列车流量网络模型  ](images/e877c0962ea89c788357a0ce9a48c4f306c3bc33bc71d559136cc0a052c8c375.jpg)  
![图10-87 列车调度问题总收益最大流图  ](images/820628b77bdb2600c45369a5e8ccfe88b488f7bb28ab752799b5e76d0dabc2f0.jpg)  
如图10-86 所示的流网络为列车调度的流量网络模型，其中粗线箭头上的数字表示费用，未标数字的弧的费用为 0 ，未标明容量的弧的容量为 1 。  
![图10-88 列车进站安排  ](images/25158a79180787e9c0c3c5ee956180ccd3bcebdba893d1c1a3d3773d0bfcced1.jpg)  
对于求解出来的所有最大流分别计算整个网络的费用，求得如图10-87 所示的最大流即为安排列车的进站与出站，使得车站的总收益最大的方案，其中粗线箭头上的数字表示流量，未标数字的弧的流量为0。由图10-87 知，列车进站的最优安排方案为：让列车1、3 进站并停留在第一车道，列车2、5 进站并停留在第二车道，具体如图10-88 所示，其中粗线表示先停入列车1 再停入列车3；细线表示先停入列车2 再停入列车5。此时车站最大收益为$0.5+0.6+0.4+0.3=1.8$。"
最大流算法,算法,['第十章  特殊图模型与算法'],"{'实体类型': '算法', '应用': '网络流图中的基本算法'}",,1,"如前所述，图模型及其理论是数学家欧拉为解决哥尼斯堡七桥遍历问题而创立。事实上，图模型作为一种由结点和边组成的离散结构是一种非常强大的离散建模工具，除了能够解决哥尼斯堡七桥遍历问题之外，还可解决很多其它实际问题。例如，旅游的路径规划问题、资源分配与匹配问题、图的着色与并行流程的设计问题、最小费用流问题等等。针对不同的问题，通常需要设计出特定的图模型进行建模与求解。例如，解决哥尼斯堡七桥遍历问题需要使用欧拉图及相关理论、解决旅游的路径规划问题需要哈密顿图及相关理论、解决资源分配与匹配问题需要二分图及相关理论、解决图的着色与并行流程的设计问题需要平面图的相关理论、解决最小费用流问题需要网络流图的相关理论等等。由此产生很多种具有特殊结构和性质的图模型，每种特殊图模型都能针对性地有效地解决某一类或某几类特定问题。因此，要想高效合理地使用图模型实现对实际问题的建模与求解，除了掌握前述图模型的一般理论及算法之外，还需要进一步掌握多种特殊图模型的相关理论及算法。  
本章介绍几种重要的特殊图模型及相关算法，包括欧拉图模型的基本理论及边的遍历算法、哈密顿图的基本理论及结点的近似遍历算法、二分图模型的基本理论及匈牙利匹配构造算法、平面图的基本理论及着色算法、网络流图的基本理论及最大流算法，并结合具体实例分析和讨论这些特殊图模型的应用方法。"
最大流问题,问题,"['第十章  特殊图模型与算法', '§ 10.4 网络流图及其优化问题', '10.4.1 流网络与切割']","{'实体类型': '问题', '定义': '在满足容量约束前提下，使尽可能多的流从源结点流向汇结点', '特点': '求流量最大的可行流'}",,3,"首先介绍流网络模型的相关基本概念及其数据描述。如同每条公路有运输量、每根水管有最大流量限制一样，网络流图的每条边都有容量，或者说每条边都有一定的流量。网络流图其实就是每条边具有附带容量（可理解为权值）的有向图。其具体定义如下：  
【定义10.4.1】设有向图$G=\langle V,E\rangle$，$V$中包含一个源结点𝑠和一个汇结点$t$，且每条边$(u,v)\in E$均有一个非负容量$c(u,v)\geq0$，若$(u,v)\notin E$，则规定其容量$c(u,v)=0$，此时称有向图$G$是一个网络流图，简称为流网络或网络。源结点$s$即起点，汇结点$t$即终点。网络流是定义在网络$G$中关于边的一个实函数，用$f(u,v)$表示有向边$(u,v)\in E$上结点$ u$到结点$v$的网络流。$f(u,v)$表示$u$ 到$v$的净流。  
例如，如果$_{u}$到$v$有6 个单位的实际流，且$v$到$u$有3 个单位的实际流，那么$f(u,v)=$3，$f(v,u)=-3$，互为相反数。净流是实际通过的流量矢量和，可类比合力的概念。  
满足以下三个性质的网络流$f$称之为可行流：  
（1）容量限制：对所有的$(u,v)\in E$，都有$f(u,v)\leq c(u,\textit{}v)$。即一条边的流不能超过它的容量。这也很容易理解，如同自来水管的水流自然不会超过水管本身的容量。  
（2）斜对称：对所有$(u,v)\in E$，都有$f(u,v)=-f(v,u)$。即点$\cdot u$到$v$的净流必须与点𝑣到$u$的净流相反。可以类比物理中矢量概念，如作用力与反作用力，强调的是其方向性。  
（3）流守恒：对所有$u\in V-\{s,t\}$，都有$\textstyle\sum_{v\in V}f(u,v)=0$。即除源结点$𝑠$和汇结点$𝑡$外，其余每个结点的净流之和为0。  
![图10-68 网络及可行流  ](images/bada5974bba3db0db4c82fa8e3076a8834542abfa1641f17fac232a32e6fee29.jpg)  
例如，如图10-68 所示，网络中定义网络流$f(u,v)$是一条可行流。图中每条边所对应的序偶表示该边的容量和流量，第一个数字表示边的容量，第二个数字表示边的流量。  
下面结合图10-68 所示网络实例介绍网络流模型中与边相关的几个概念。可根据边的容量与流的大小关系对网络中的边进行分类：  
（1）满足$f(u,v)=c(u,v)$的边称为饱和边，如边(1,2)、 (2,3)  
（2）满足$f(u,v)<c(u,v)$的边称为非饱和边，如边(2,4)。  
（3）满足 $f(u,v)=0$ 的边称为零流边，如边 (3,4) ；满足 $f(u,v)>0$ 的边称为非零流 边，如边(5,4)。  
（4）既不是零流边也不是饱和边的边，称为弱流边，如边(5,6)  
如果把图10-78 看作是一个公路网，6 个结点分别表示6 座城镇，每条边上的权数表示两城镇间的距离。若现在需要从起点1 将一些物资运送到终点6，应怎样选择路线才能使总运输距离最短。我们知道，这样一类问题称为最短路径问题。类似的，如果把图10-1看作为一个输油管道网，结点1表示为发送点，结点6表示为接收点，其它点表示为中转站，各边的权数表示该段管道的最大运输油量。那么如何安排输油线路才能使从1到6的总运输量最大。这样一类问题就是最大流问题。  
最大流问题是网络优化中的一个典型的问题，简单地说，就是在满足容量约束的前提下将尽可能多的流从源结点流向汇结点。因此，最大流问题就是求流网络$G$中使其流量$f$达到最大的一个可行流，该可行流即为最大流。具体定义如下：  
【定义10.4.2】设有向图$G=\langle V,E\rangle$是任意给定的一个网络流图，若$f$是$G$ 中流量最大的的可行流，则称该可行流$f$是$G$ 的最大流，构构造网络流图$G$ 中最大流的问题，就称为网络流图的最大流问题。  
为了实现对最大流问题的求解，必须对网络流图中的增流空间进行合理的度量，通常使用一种名为残留网络的图模型实现这项工作。残留网络的具体定义如下：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图， $f$为$G$的一个流，对于$G$的任意一条边$(u,v)$，在不超过容量$c(u,v)$条件下，从$u$到$v$可压入的额外流量，称为$(u,v)$的残留容量。由$G$中所有边残留容量构成的带权有向图称为$G$的残留网络，记为$G_{f}=\langle V,E_{f}\rangle$。  
若$c_{f}(u,v)$为残留网络$G_{f}$中边$(u,v)$的残留容量，且边$(u,v)\in E$或边$(v,u)\in E$，则$(u,v)\in$$E_{f}$,$\,c_{f}(u,v)=c(u,v)-f(u,v)\,$。例如，若设$(u,v)$当前流量为(4,3)，此时$c(u,v)=4$，$f(u,v)$）$=3$，则有：$c_{f}(u,v)=1$。  
需要注意的是，残留网络具有这样的性质：假设从$_{.}u$到$v$已经有了3 个单位流量，那么从反方向上看，也就是从$v$ 到$u$ 就有了3 个单位的残留容量，这时$c_{f}(v,u)=3$。换句话说，从$u$ 到$v$ 有3 个单位流量，那么从$v$到$u$ 就有了将这3 个单位流量压回去的能力。因此，残留网络结点之间通常由双向带权边进行联结。例如，对于图10-69（a）所示的一个流网络$G$，图10-69（b）则表示该流网络𝐺的残留网络。  
![图10-69 流网络及其残留网络 ](images/d65d1c72064671125468548ae171a28ede5424f1d36d601972ed76c90131fc8c.jpg)  
对于任意给定的一个网络流图$G=\langle V,E\rangle$，可以通过其残留网络$G_{f}=\langle V,E_{f}\rangle$求得$G$的最大流。基本思路如下：首先，对所有的结点令初始状态时流的值为0，即对于$\forall u,v\in V$，有$f(u,v)=0$。然后，通过迭代方式其残留网络中不断寻找源点𝑠到汇点$t$之间的流量增广路径来增加网络流量值，直到残留网络没有这样的增广路径为止。  
因此，在残留网络$G_{f}=\langle V,E_{f}\rangle$寻找流量增广路径是最大流求解算法的关键。为正确理解该算法，现给出流网络增广路径的具体定义：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，$G_{f}=\langle V,E_{f}\rangle$为$G$在流$f$下的一个残留网络，则$G_{f}=\langle V,E_{f}\rangle$中任意一条从源点$s$到汇点$t$的简单路径$p$称为$G=\langle V,E\rangle$的一条流量增广路径，简称为增广路径。  
事实上，可将增广路径形象地理解为网络流图$G$中从源点𝑠到汇点𝑡的一条不违反流网络边容量限制的路径，并向这条路径压入一定的流量，以增加整个网络的流量值。例如，图10-69（b）所示的残留网络存在这样一条如图10-70 中加粗有向边所示的增广路径。  
![图10-70 增广路径 ](images/1e52dc98ce8f5b49283b093dbb72c0d5308ccdc9782306a98cb168474d58608f.jpg)  
![图10-71 流网络的一个切割](images/c52dd38b6f7d2bc46bb57e2440709d67355577a7b3d5fb2e920f10a5bfeb8598.jpg)  
若将图10-70 所示增广路径在流网络所对应每条边的流量增加4 个单位，得到一个新的流网络，其流量比原网络多4 个单位。然后，在新流网络所对应的残留网络中继续寻找新增广路径，直到找不到新增广路径为止。显然，现在的问题是：如果在残留网络$G_{f}=$$\langle V,E_{f}\rangle$中找不到增广路径，此时该残留网络所对应的流$f$是否就是流网络$G=\langle V,E\rangle$的最大流？要解决这个问题，必须进一步引入流网络切割的相关概念，具体如下：  
【定义10.4.4】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，如果将$G$的结点集合𝑉划分为𝑆和$T=V-S$两部分，使得源点$s\in S$且$t\in T$，则称$(S,T)$是$G=\langle V,E\rangle$的一个切割，简称为割。从集合 𝑆 到集合 𝑇 的所有有向边容量之和称为切割 $(S,T)$ 的容量，穿过切割 $(S,T)$所有边流量的代数和流量称为切割$(S,T)$的净流量，记为$f(S,T)$。  
主要注意的是，定义10.4.4 中边的流量带有正负方向，如果流从结点𝑆流向$T$，则该边的流量值为正，如果流从结点𝑇流向𝑆，则该边的流量值为负。例如，对图10-69（a）所示的流网络，可画一个如图10-71 所示的切割$(S,T)$，其容量为：  
$$
c(u,w)+c(v,x)=12+14=26
$$  
穿过该切割的净流量为：  
$$
f(u,w)+f(v,x)-f(w,v)=12+11-4=19
$$  
显然，对于任意一个切割，穿过该切割的净流量上界就是该切割的容量，即穿过切割的净流量不可能超过割的容量。由于流网络中所有切割的流都相等并且等于网络的流，因此，网络最大流必然无法超过网络的最小割。由此得到如下最大流最小割定理：  
【定理10.4.1】（最大流最小割定理）设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和$t$分别为其源点和汇点，则$G=\langle V,E\rangle$的最大流量等于其最小割切的容量。对于$G=\langle V,E\rangle$上的任意一个流$f$，以下三个结论彼此等价：  
(1) $f$是流网络$G=\langle V,E\rangle$的一个最大流；  
(2) 流网络$G=\langle V,E\rangle$的残留网络中不包括任何增广路径；  
(3) 存在流网络$G=\langle V,E\rangle$的某个切割$(S,T)$，满足：
$$
f(S,T)=c(S,T)
$$"
最大相容类,概念,"['第六章 特殊关系模型', '§ 6.2 相容关系与元素聚类', '6.2.1 相容关系与相容类']","{'实体类型': '概念', '定义': '设𝑅是非空集合𝐴上的一个相容关系，𝐶是𝑅的一个相容类，若在𝐶中添加𝐴的任何其他元素后，就不再构成相容类，则称𝐶为𝑅的一个最大相容类', '求法': '可用相容关系的简化关系图求最大相容类'}",,3,"相容关系表示的是一种求同存异的关系，对象之间有一些共同点但不完全相同。现在我们从数学的角度来考察相容关系。如前所述，人与人之间的朋友关系、英文单词之间存在共同字母的关系等都可看成是相容关系。不难发现，这些相容关系都满足自反性和对称性，但不满足传递性。由此得到如下关于相容关系的定义：  
【定义6.5】设$𝑅$为非空集合$𝐴$上的关系，若$R$满足自反性和对称性，则称$𝑅$为$𝐴$上的一个相容关系。此时，对于$𝐴$中任意两个元素$x$和𝑦，若$\langle x,y\rangle\in R$，则称$x$与𝑦相容，记为$x\approx y$。  
根据上述定义，不难发现所有的等价关系都可以看成是一种特殊的相容关系，即满足传递性的相容关系，但相容关系不一定是等价关系。  
与等价关系中等价类的概念类似，对于非空集合$𝐴$上的相容关系$R$，将𝐴中一些彼此具有相容关系$R$的元素放在一起构成𝐴的一个子集，由此得到如下相容类的概念：  
【定义6.6】设$ R$是非空集合$𝐴$上的一个相容关系，集合$C$是$𝐴$的某个子集，若对于任意的$x,y\in C$都有$\langle x,y\rangle\in R$，则称$C$是由相容关系$R$的一个相容类。  
例如，在例题6.16 中，$\{a\},\{a,e\},\{b,c\}$等都是$R$的相容类，$\{b,c\}\cup\{d\}=\{b,c,d\}$也是𝑅的相容类，但$\{a,e\}$与任何非空集合的并集都不再是$R$的相容类，此时称$\{a,e\}$为$R$的一个最大相容类，其具体定义如下：  
【定义6.7】设$R$是非空集合$𝐴$上的一个相容关系，$C$是$R$的一个相容类，若在$C$中添加$𝐴$的任何其他元素后，就不再构成相容类，则称$C$为$R$ 的一个最大相容类，记为$C_{R}$。  
例如，在例题6.16 中，$\{a,e\}$和$\{b,c,d\}$都是$R$ 的一个最大相容类。可用相容关系的简化关系图求最大相容类，具体方法如下：  
（1）图中最大完全多边形顶点构成的集合是最大相容类。  
（2）图中每个孤立结点是构成的集合分别是一个最大相容类。  
（3）如果图中某条边不是任何一个完全多边形的边，则该边的两个端点构成的集合是一个最大相容类。  
【定理6.3】设$R$是非空集合$𝐴$上的一个相容关系， $C$是$R$的一个相容类，那么必存在𝑅的一个最大相容类$C_{R}$，使得$C\subseteq C_{R}$。"
最小公倍数,概念,"['第二章  整数与算法设计基础', '三、算术基本定理', '2.1.2 整数的因数分解', '一、公因数与公倍数', '§ 2.1 整数的基本知识']","{'实体类型': '概念', '定义': '假设a和b是任意给定的两个整数，a和b的所有公倍数中最小的那个整数称为a和b的最小公倍数', '记法': 'lcm(a,b)或[a,b]', '计算方法': '通过整数的素因子分解式，取各素数的幂的最大值'}",,4,"假设$a$ 和$b$ 是任意给定的两个整数，如果$b$ 能够整除$a$，那么$b$ 就是$a$的一个因数、$a$就是$b$ 的一个倍数，此时可分别从因数和倍数这两个角度对整数进行考察。  
具体地说，如果$b$ 也是另外一个整数$c$ 的因数，则$b$ 就反映出$a$ 和$c$ 的某种共同特征，或者说整数$a$ 和$c$ 具有一个相同的构件$b$，通常将其称为$a$ 与$c$的公因数。同样，如果整数$a$ 也是另外一个整数$s$ 的倍数，则$b$ 和$s$ 就有一个共同的倍数$a$，通常称之为公倍数。公因数和公倍数分别从两个不同角度考察任意两个整数之间的联系，具体定义如下：  
【定义2.3】假设$i$ 和$j$是任意两个整数，如果整数$b$ 能够同时整除$i$和$j$，则称$b$ 是$i$和$j$ 的一个公因数，如果$i$ 和$j$都能够整除整数$a$，则称$a$ 是$i$ 和$j$的一个公倍数。  
自然数1 可以整除任意整数，因此对于任意两个整数，它们的公因数总是存在的。公因数表达的是两个整数的共同部分，通常需要考察两个整数之间的共同部分最大值能达到多少，故有所谓最大公因数的概念。同样，对于任意两个整数，这两个整数的乘积就是它们的公倍数，因此，公倍数总是存在的，需要着重考察的通常式公倍数的最小值，因而有最小公倍数的概念。最大公因数和最小公倍数的具体定义如下：  
【定义2.4】假设$a$ 和$b$ 是任意给定的两个整数，$a$ 和$b$ 的所有公因数中最大的那个整数称为$a$ 和$b$ 的最大公因数，记为$\operatorname*{gcd}(a,b)$或$(a,b)$，$a$ 和$b$ 的所有公倍数中最小的那个整数称为$a$ 和$b$ 的最小公倍数，记为$\operatorname{lcm}(a,b)$或$[a,b]$。  
例如： $\operatorname*{gcd}(5,7)=1$$\operatorname*{gcd}(15,21)=3;\;\;\operatorname*{gcd}(132,240)=12;$； $\operatorname{lcm}(5,7)=35;\ \operatorname{lcm}(15,21)=105;\ \operatorname{lcm}(132,240)=2640$  
规定g$\mathtt{c d}(0,0)=0$。易知若$a$，$b$不全为零，则$\operatorname*{gcd}(a,\ b)>0$。  
【定理2.3】假设$a$ 和$b$ 是任意给定的两个整数，则有：  
$$
a\cdot b=\left(a,b\right)\cdot\ \left[a,b\right]\tag{2-2}
$$  
【定理2.4】假设$a$ 和$b$ 是任意给定的两个整数，如果$a$ 和$b$ 都能整除整数$k$，则其最小公倍数$[a,b]$也能整除$k$。  
显然，可以将公因数和公倍数的相关直接概念推广到如下多个整数的情形：  
【定义2.5】假设$a_{1},a_{2},\cdots,a_{k}$是$k$ 个不全为零的整数，如果$s$ 是其中每个整数的因数，则称$t$是$a_{1},a_{2},\cdots,a_{k}$的一个公因数。对于给定的整数$a_{1},a_{2},\cdots,a_{k}$，它们的公因数只有有限多个，其中最大的那个公因数称为$a_{1},a_{2},\cdots,a_{k}$的最大公因数，记为gc$\mathfrak{d}(a_{1},a_{2},\cdots,a_{k}).$。  
【定义2.6】假设$a_{1},a_{2},\cdots,a_{k}$是$k$ 个不全为零的整数，如果$t$是其中每个整数的倍数，则称$t$ 是$a_{1},a_{2},\cdots,a_{k}$的一个公倍数。$a_{1},a_{2},\cdots,a_{k}$的所有公倍数中数值最小的那个公倍数，称为$a_{1},a_{2},\cdots,a_{k}$的最小公倍数，记为$\operatorname{lcm}(a_{1},a_{2},\cdots,a_{k})$。  
下面定理是最大公因数的一个重要定理，它刻画了最大公因数在带余除法中的不变性质，为最大公因数的构造算法——辗转相除法提供了坚实的理论基础。  
【定理2.5】假设$a$ 和$b$ 是任意给定的两个整数，若有$b=a q+r$，$0\leq|r|<a$，则必有：$\operatorname*{gcd}(b,a)=\operatorname*{gcd}(a,r).$。  
【定理2.6】假设$a$ 和$b$ 是任意两个整数，则必然存在两个整数$\cdot k_{1}$和$k_{2}$，满足：
$$
\operatorname*{gcd}(b,a)=k_{1}\cdot b+k_{2}\cdot a\tag{2-3}
$$  
上述定理表明，整数$a$ 和$b$ 的最大公因数可以表示为它们的一个线性组合。这就给出了最大公因式一种具体表达形式，这种表达形式对于考察最大公因数的性质具有非常重要的作用。例如，使用上述线性组合表达式，可得到最大公因数下述性质：  
【定理2.7】假设$a$ 和$b$ 是任意给定的两个整数，如果$d$ 是$a$ 和$b$ 的任意一个公因数，则$d$一定能整除$\operatorname*{gcd}(a,b)$。"
最小生成树,概念,"['第九章  树的基本理论与算法', '9.1.3  最小生成树', '§ 9.1 无向树的基本知识']","{'实体类型': '概念', '相关理论': '关于树模型的基本理论', '定义': '设假设G=⟨V,E,W⟩是任意给定的一个连通无向赋权图模型，T是G的一棵生成树，T的每个树枝所赋权值之和称为T的权，记为ω(T)。图G中具有最小权的生成树称为G的最小生成树', '特点': '一个无向图的生成树不唯一，但生成树的最小权一定是唯一的', '应用': '在保证小区连通前提下管道修建费用最少', 'name': '最小生成树'}",,1,"树是大家非常熟悉的一类植物。通过对树的观察，不难发现自然界中的树总是有根、枝和叶，且具有这样一些特点：从根上可以长出枝来，从树杈上可以长出枝或叶，叶梢不长在一起，根、枝、叶之间总是畅通的，但它们之间不能构成圈。从结构上看，树是所有连通无向图中边数最少的图模型，同时也是所有无环无向图中边数最多的图模型。我们不得不惊叹大自然的神奇，竟然创造出如此高效而又和谐的离散结构。对自然界中树的这种特殊离散结构进行抽象，就可得到一种特殊的图模型，即树模型。在所有的图模型中，树模型是一种最简洁的连通无环结构，其中各结点之间有着最直接、最必要的联结关系。这种最简洁的连通结构决定了树在图模型知识体系中占有特别重要的地位。目前，树作为一种特殊图模型已被广泛应用于计算机各个领域，例如操作系统采用树结构来组织文件数据，编译程序采用树表示源程序的语法结构，在数据库系统中树被用来组织信息等等。  
本章主要介绍树模型基本理论及其算法设计的基本知识，首先介绍树模型的基本概念与性质、生成树与最小生成树等关于树模型的基本理论，然后具体讨论根树的概念与算法，包括树的递归遍历算法、森林与树的转换算法、最优树的构造与编码算法等，并在此基础上进一步学习若干典型特殊树模型及其基本算法，包括平衡树、红黑树、$B$树等，最后给出树模型的若干应用实例，包括决策树、博弈树等。"
最早启动时间,概念,"['第八章  图的基本理论与算法', '§ 8.5 图模型的应用', '8.5.2 作业规划问题']","{'实体类型': '概念', '定义': '源点到某作业起点vi的最长路径长度πi', '应用': '确定作业的最早开始时间'}",,3,"生活中有着多种多样的工程，而每一项工程往往都是由多种不同的活动相互组合而成，这些活动中，有的可以并行执行，而有的活动却必须要等到前面的准备活动都做好之后才能开始进行。例如，在一个软件开发项目中，包括以下几个阶段：需求分析，系统设计，模块代码编写，单元测试，软件维护。其中代码编写和单元测试可以同时进行，但是代码编写却一定要在需求分析和系统设计完成之后才行，需求分析和系统设计构成了代码编写的准备工作。既然存在这样的现象，那么在一项很复杂的工程中，如何合理的安排活动的进行，能够使得整个工程完成时间最早呢？其实，这就是关键路径问题。在求解关键路径问题之前，我们有必要先了解下PERT 图的相关概念。  
PERT 图是一个有向连通图$G=\langle V,E\rangle$，且  
（1）每条边表示一个作业（工序），边的非负实数权表示完成该作业所需的时间；  
（2）每个顶点表示以该顶点为起点的作业开始，也表示以该顶点为终点的作业结束；  
（3）作业开始条件：某条有向边$e=\langle v,u\rangle$所代表的作业可以开始 当且仅当 以v为终点的有向边所代表的作业全部完成；  
（4）G没有有向回路，也没有环；  
（5）G中有且仅有一个顶点的入度为0，称该顶点为源点；同时G中有且禁言一个顶点的出度为0，称该顶点为汇点。  
对于给定的PERT 图$G=\langle V,E\rangle$，我们主要关心其关键路径，以及每个作业的最早开始时间和最晚开始时间。关于PERT 图，有如下定义：  
（1）关键路径：G中从源点到汇点最长带权路径路径称为关键路径。关键路径的长度T为完成整个任务（即包括所有作业）所必需的最少时间。  
（2）关键作业：关键路径上的边所代表的作业称为关键作业。  
（3）最早启动时间：对于某个作业${e}=\left<v_{i},-\right>$，源点到该作业起点$v_{i}$的最长路径长度$\pi_{i}$称为该作业的最早启动时间。  
（4）最晚启动时间：设$v_{i}$到汇点${v}_{n}$的最长路径长度为$\pi_{i}^{\prime}$，则该作业可最晚于$\mathsf{\Delta}\mathsf{T}_{i}=\mathsf{T}-$$\uppi_{i}^{\prime}$时间启动而不影响整个任务完成的预期时间T，$\uptau_{i}$称为该作业的最晚启动时间。  
显然，作业${e}=\langle v_{i},-\rangle$是关键作业当且仅当$\pi_{i}=\uptau_{i}$，因为这时e是处于源点到汇点最长带权路径上。故可通过求每个作业的最早启动时间和最晚启动时间而得到PERT 图的关键路径。那么如何求解作业的最早启动时间和最晚启动时间呢？下面给出了求解方法：  
设PERT 图$G=\langle V,E\rangle$的顶点编号$v_{1},v_{2},\dots,v_{n}$，使得边$e=\langle v_{i},v_{j}\rangle\in E$蕴含$i<j$  
令$\pi_{1}=0$，$\pi_{j}=m a x\{\pi_{m}+w(v_{m},v_{j})|1\leq m<j\}$，则$\pi_{i}(1\leq i\leq n)$是作业$e=\langle v_{i},v_{j}\rangle$的最早启动时间。这里$w(v_{m},v_{j})$定义为：  
$w(v_m,v_j)=\begin{cases}\text{边}\langle v_m,v_j\rangle\text{的非负实数权,~~~~~~~~若}\langle v_m,v_j\rangle\in E;\\-\infty,&\text{否则}\end{cases}\text{(8-18)}$  
令$\tau_{n}=\pi_{n}$，$\tau_{k}=m a x\{\tau_{k},\tau_{k}-w(v_{k},v_{m})|k<m\leq n\}$，则$\tau_{i}(1\leq i\leq n)$是作业$e=$$\langle v_{i},v_{j}\rangle$的最晚启动时间。  
由于某顶点的最早启动时间（最晚启动时间）就是所有以该顶点为起点的作业的最早启动时间（最晚启动时间）。因此求解关键路径，可以通过计算每个顶点的最早启动时间和最晚启动时间来确定。  
另外，为了更方便的判断顶点$v_{i}$是否为关键路径上的顶点，在此定义$v_{i}$的缓冲时间$S_{i}=$$\tau_{i}-\pi_{i}$。在关键路径上，各顶点的缓冲时间𝑆均为0，任何关键作业如果耽误了时间𝑡，整个工程就耽误了时间𝑡。下面给出求解关键路径的具体例子。"
最晚启动时间,概念,"['第八章  图的基本理论与算法', '§ 8.5 图模型的应用', '8.5.2 作业规划问题']","{'实体类型': '概念', '定义': ""设vi到汇点vn的最长路径长度为πi'，则该作业可最晚于ΔTi=T-πi'时间启动而不影响整个任务完成的预期时间T"", '应用': '确定作业的最晚开始时间'}",,3,"生活中有着多种多样的工程，而每一项工程往往都是由多种不同的活动相互组合而成，这些活动中，有的可以并行执行，而有的活动却必须要等到前面的准备活动都做好之后才能开始进行。例如，在一个软件开发项目中，包括以下几个阶段：需求分析，系统设计，模块代码编写，单元测试，软件维护。其中代码编写和单元测试可以同时进行，但是代码编写却一定要在需求分析和系统设计完成之后才行，需求分析和系统设计构成了代码编写的准备工作。既然存在这样的现象，那么在一项很复杂的工程中，如何合理的安排活动的进行，能够使得整个工程完成时间最早呢？其实，这就是关键路径问题。在求解关键路径问题之前，我们有必要先了解下PERT 图的相关概念。  
PERT 图是一个有向连通图$G=\langle V,E\rangle$，且  
（1）每条边表示一个作业（工序），边的非负实数权表示完成该作业所需的时间；  
（2）每个顶点表示以该顶点为起点的作业开始，也表示以该顶点为终点的作业结束；  
（3）作业开始条件：某条有向边$e=\langle v,u\rangle$所代表的作业可以开始 当且仅当 以v为终点的有向边所代表的作业全部完成；  
（4）G没有有向回路，也没有环；  
（5）G中有且仅有一个顶点的入度为0，称该顶点为源点；同时G中有且禁言一个顶点的出度为0，称该顶点为汇点。  
对于给定的PERT 图$G=\langle V,E\rangle$，我们主要关心其关键路径，以及每个作业的最早开始时间和最晚开始时间。关于PERT 图，有如下定义：  
（1）关键路径：G中从源点到汇点最长带权路径路径称为关键路径。关键路径的长度T为完成整个任务（即包括所有作业）所必需的最少时间。  
（2）关键作业：关键路径上的边所代表的作业称为关键作业。  
（3）最早启动时间：对于某个作业${e}=\left<v_{i},-\right>$，源点到该作业起点$v_{i}$的最长路径长度$\pi_{i}$称为该作业的最早启动时间。  
（4）最晚启动时间：设$v_{i}$到汇点${v}_{n}$的最长路径长度为$\pi_{i}^{\prime}$，则该作业可最晚于$\mathsf{\Delta}\mathsf{T}_{i}=\mathsf{T}-$$\uppi_{i}^{\prime}$时间启动而不影响整个任务完成的预期时间T，$\uptau_{i}$称为该作业的最晚启动时间。  
显然，作业${e}=\langle v_{i},-\rangle$是关键作业当且仅当$\pi_{i}=\uptau_{i}$，因为这时e是处于源点到汇点最长带权路径上。故可通过求每个作业的最早启动时间和最晚启动时间而得到PERT 图的关键路径。那么如何求解作业的最早启动时间和最晚启动时间呢？下面给出了求解方法：  
设PERT 图$G=\langle V,E\rangle$的顶点编号$v_{1},v_{2},\dots,v_{n}$，使得边$e=\langle v_{i},v_{j}\rangle\in E$蕴含$i<j$  
令$\pi_{1}=0$，$\pi_{j}=m a x\{\pi_{m}+w(v_{m},v_{j})|1\leq m<j\}$，则$\pi_{i}(1\leq i\leq n)$是作业$e=\langle v_{i},v_{j}\rangle$的最早启动时间。这里$w(v_{m},v_{j})$定义为：  
$w(v_m,v_j)=\begin{cases}\text{边}\langle v_m,v_j\rangle\text{的非负实数权,~~~~~~~~若}\langle v_m,v_j\rangle\in E;\\-\infty,&\text{否则}\end{cases}\text{(8-18)}$  
令$\tau_{n}=\pi_{n}$，$\tau_{k}=m a x\{\tau_{k},\tau_{k}-w(v_{k},v_{m})|k<m\leq n\}$，则$\tau_{i}(1\leq i\leq n)$是作业$e=$$\langle v_{i},v_{j}\rangle$的最晚启动时间。  
由于某顶点的最早启动时间（最晚启动时间）就是所有以该顶点为起点的作业的最早启动时间（最晚启动时间）。因此求解关键路径，可以通过计算每个顶点的最早启动时间和最晚启动时间来确定。  
另外，为了更方便的判断顶点$v_{i}$是否为关键路径上的顶点，在此定义$v_{i}$的缓冲时间$S_{i}=$$\tau_{i}-\pi_{i}$。在关键路径上，各顶点的缓冲时间𝑆均为0，任何关键作业如果耽误了时间𝑡，整个工程就耽误了时间𝑡。下面给出求解关键路径的具体例子。"
最短路径,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.4.3 单源最短路径']","{'实体类型': '概念', '定义': '图中一个结点到另一个结点的最短距离', '应用': '地图上查找两地之间最短路径，路由选择中查找距离目的地最近的路径'}",,3,"最短路径，顾名思义就是图中一个结点到另一个结点的之间最短的距离。在日常生活之中，涉及到最短路径计算问题的实际案例有很多，比如在地图上查找两地之间最短路径，为大家的出行提供方便；另外，在路由选择中，从一个路由器出发查找距离目的地最近的一条路径等。最短路径的求解主要有两种算法，一种是单源最短路径算法，即一个结点到其他所有剩余结点的最短路径，代表算法是迪杰斯特拉算法；另一种是求整个图中所有结点之间的最短距离，代表算法是沃舍尔∙弗洛伊德算法。  
因此，给定简单无向赋权图 $G=\langle V,E\rangle$ ，从顶点 $v_{1}$ 到 $v_{n}$ 的最短路径可应用迪杰斯特拉算法算法进行求解。迪杰斯特拉算法的基本思想如下：  
假定有两个集合 $A$ 和 $B$ ，$A$ 集合中存放已找到最短路径的结点$B$集合中存放的是剩余结点。初始状态下，集合 $A$ 中包含默认的源点 $v_{1}$ ，然后从集合 $B$ 中选取到结点$v_{1}$最近的那个结点，记为 $v_{2}$，将 $v_{2}$ 放入集合 $A$ 中，并对$ v_{2}$到$v_{1}$的距离进行永久性标注，然后再以 $v_{2}$ 为中介点，更新 $v_{1}$ 到其他剩余结点的最短路径临时值。然后再从集合B中选取最近的结点，并入集合 $A$ 中，并对该结点到$v_{1}$的最短路径临时值进行永久性标注，使得该临时值变成永久值，重复以上过程，直到将集合B中的所有结点全部并入集合 $A$ 中并得到永久性标注。  
迪杰斯特拉算法的数学描述如下：  
（1）初始化：$A=\{v_1\},d(v_1)=0,B=\{v_i|v_i\in V,i\neq1\}$,即 $B=V-A$,且有
$$d(v_i)=\begin{cases}\omega(v_1,v_i),~~~~~~~若(v_1,v_i)\in E\\\infty,~~~~~~~~~~~~~~~~~若(v_1,v_i)\notin E\end{cases}$$              (8-13)  
（2）找最近：在 $B$ 集合中寻找离顶点 $v_{1}$ 最近的结点。若为 $v_{k}$ ，则将 $v_{k}$ 添加到集合 $A$ 中，并在 $B$ 集合中删除 $v_{k}$ ，即 $A=A\cup\{v_{k}\}$，$B=B-\{v_{k}\}$  
（3）更新：以 $v_{k}$ 为中介点，更新 $v_{1}$ 到 $B$ 集合中剩余结点的最短路径长度。$\forall$$v_{i}\in$$B$，  
$d(v_{i})={\left\{\begin{array}{l l}{d(v_{k})+\omega(v_{k},v_{i}),~~~~~~~~~~~~~~若\dot{}d(v_{k})+\omega(v_{k},v_{i})<d(v_{i})}\\ {\qquad d(v_{i}),~~~~~~~~~~~~~~~~~~~~~~~否则}\end{array}\right.}$      （8 −14）  
（4）重复（2）和（3），直到 $B$ 集合为空为止。  
实际上，当 $v_{n}$ 归入集合 $A$ ，且正好 $A=V$，不仅求出了从 $v_{1}$ 到 $v_{n}$ 的最短路径，而且求出了从 $v_{1}$ 到所有顶点的最短路径。  
上述算法的正确性是显然的。因为每一步中，集合 $A$中的每一个元素（顶点）都是 $v_{1}$ 到该元素（顶点）的最短路径，因此只要证明上述 $d(v_{i})$ 是从 $v_{1}$ 到 $v_{i}$ 的最短路径即可。  
事实上，任何一条从 $v_{1}$ 到 $v_{i}$ 的路径，若通过集合 $B$ 中的第一个顶点是 $v_{p}$，且 $v_{p}\neq$$v_{i}$ ，显然这种路径的长度不会比 $d(v_{i})$小（因为所有边的权值为非负）。"
最邻近插入法,算法,"['第十章  特殊图模型与算法', '§ 10.4 网络流图及其优化问题', '10.5.3 最优路线问题']","{'实体类型': '算法', '定义': '用于寻找近似最佳旅游线路的算法', '步骤': '1. 求最短路程形成初始道路；2. 逐步加入最近景点；3. 形成总权数最小的汉密尔顿回路'}",,3,"如果想在较短的时间内旅游较多的景点，则需要确定一个合理的路线，尽量缩短旅游的路程，使总路程最短。该问题可用哈密顿图模型求解。  
首先，将旅游线路模型化。把每个旅游景点分别看作是加权无向图中的一个结点，各景点之间的直达公路看作加权无向图中对应结点间的边，将各条公路的长度分别看作其对应边上的权。有的景点之间尽管没有直达的公路，但是它们加权无向图中对应结点之间也要用边相连，而这条边的含义是：从其中一个景点出发，通过中转站到达另一景点所需的最短距离。  
此时，旅游景点之间的公路网就转化为加权无向图，寻找旅游各个景点近似最佳旅行线路问题就转化为：在给定的加权无向图中，寻找从给定的结点出发，行遍所有结点仅一次再回到该指定的结点，使得总权数最小，即总路程最短。可以运用图论中的最邻近插入法来寻找近似最佳旅游线路和路程。算法的基本步骤如下：  
步骤1：用沃舍尔∙弗洛伊德算法求出加权无向图中任意两点之间的最短路程，形成仅含一条边的初始道路$\left\langle i,j\right\rangle$，权$w(i,j)$表示道路$\langle i,j\rangle$的长度。  
步骤2：设$x$表示最新加到这道路$\langle i,j\rangle$上的景点，从不属于该条道路上所有景点中选一个与景点$x$距离最近的景点𝑦，把连接景点$x$与景点𝑦的边加到$\langle i,j\rangle$上。重复这个步骤，直到加权无向图中所有景点都包含到$\left\langle i,j\right\rangle$这条路上。  
步骤3：将连接起点与最后加入景点之间的边加到这条路上，就得到一个总权数最小的汉密尔顿回路。  
![](images/3eb5c42c98242b09cf1d107a9f19a39189dbcd95c1ca7e77768503681d0519c4.jpg)  
下面结合具体实例说明寻找近似最佳旅行线路的具体构造过程。  
从上述讨论和例题10.18 可以看出，遍历多个景点的最短旅游路线问题，其实就是从具有$n$个结点的无向带权完全图中寻找一条哈密顿回路的问题。如果景点个数较多的时候，比如说几十个或者上百个，则上述算法就非常复杂甚至不可行。  
这其实是图论中的一个著名问题，通常称之为货郎担问题。因为该问题也可以描述为：某地区共有${n}$个村庄，某售货员从他所在的某个村庄出发，前往其它$𝑛$−1个村庄一次且恰好一次，最后返回到他所在的村庄，求一条满足上述要求且总路程最短的回路。  
货郎担问题是一个十分有趣而且具有实用价值的问题，很多数学家和计算机科学家对该问题做了大量的研究，取得了丰硕的研究成果。但是，遗憾的是至今无法找到一个有效的精  
确算法，这显然是一个 NP-hard 问题，当图中结点较多时，精确算法由于计算量过于巨大而变得不可行。目前，对该问题的求解主要采用近似算法，例如在例题10.18 中使用的最近邻算法，除此之外还有抄近路算法、动态规划算法、模拟退火算法、遗传算法、蚁群算法等等，读者可参阅相关的资料进一步深入学习。"
有向图,概念,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.2 图的定义与分类']","{'实体类型': '概念', '定义': '每条边都是有向边的图'}",,3,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)"
有向图关联矩阵,定义,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.3 图的表示方法', '二、关联矩阵表示法']","{'实体类型': '定义', '定义': '有向图的关联矩阵用数字-2表示结点与边的自环关系，每条非自环有向边关联2个结点，矩阵中每列元素之和必为0'}",,4,"除了邻接矩阵外，还可以用关联矩阵表示图。关联矩阵主要表示图中每个结点与每条边之间的相关关系。对于任意给定的一个图模型$G$，其关联矩阵$M(G)$中元素$m_{i j}$的含义是图中结点$v_{i}$是否关联边$e_{j}$，如果$v_{i}$不关联$e_{j}$，则$m_{i j}=0$，如果$v_{i}$关联$e_{j}$，则用某个非零数字表示$m_{i j}$，具体数字依据图模型的类型和点边关联方式确定。  
与邻接矩阵一样，要确定一个图的关联矩阵，首先应对图中的所有结点进行编号，不同的结点编号对应于不同的关联矩阵，结点编号次序的交换对应于关联矩阵中行的交换。  
首先给出无向图关联矩阵的定义：  
【定义8.8】设$G=\langle V,E\rangle$是无向图 ，其中$\ V=\{v_{1},v_{2},\ldots,v_{n}\}$，$E=\{e_{1},e_{2},\dots,e_{m}\}$ ，则将$n\times m$阶矩阵$(m_{i j})_{n\times m}$称为 $G$ 的关联矩阵，记为 $M(G)$ 。其中元素$m_{i j}$ 表示图中结点 $v_{i}$ 与边 $e_{j}$ 的关联次数，具体定义如下：
$$
m_{ij}=\begin{cases}2,v_i的自环是e_j\\[2ex]1,v_i关联e_j且e_j不是自环\\[2ex]0,v_{i}不关联e_{j}\end{cases}
(i=1,2,\cdots,n,\quad j=1,\:2,\:...,\:m)(8-2)
$$  
从上述定义可以看出，无向图的关联矩阵用数字2 表示结点与边的自环关系，因为自环须与其关联结点关联 2  次。  
下面给出有向图关联矩阵的定义：  
【定义8.9】设 $D=\langle V,E\rangle$是有向图，其中 $V=\{v_{1},v_{2},\ldots,v_{n}\}$ ，$E=\{e_{1},e_{2},\dots,e_{m}\}$ ，则将${}n\times m$阶矩阵$(m_{i j})_{n\times m}$称为有向图 $D$ 的关联矩阵，记作 $M(D)$ 。 其中元素 $m_{i j}$ 表示图中结点 $v_{i}$ 与边 $e_{j}$ 的关联情况，具体定义如下：  
$$
m_{ij}=\begin{cases}-2,&v_i\text{为其关联自环}e_j\text{的起点和终点}\\1,&v_i\text{为其关联边}e_j\text{的起点但不是终点}\\-1,&v_i\text{为其关联边}e_j\text{的终点但不是起点}\\0,&v_i\text{不关联边}e_j\end{cases}
$$  
从上述定义可以看出，有向图的关联矩阵用数字−2表示结点与边的自环关系。事实上，有时候也可以用2 表示。因为有向图的自环是有方向的，即顺时针或逆时针方向。习惯上，用正数表示逆时针方向，负数表示顺时针方向。图中的自环默认为顺时针方向，故一般用−2表示结点与边的自环关系。  
对于无向图及其关联矩阵，由于每条非自环边关联2 个结点，故矩阵中每列元素之和必为2。而对于有向图及其关联矩阵，由于每条非自环有向边关联2 个结点，且一个为起点一个为终点，故图中每个非自环边在关联矩阵中所对应列元素之和必为0。  
因此，可以通过分析关联矩阵的数据特征分析来分析图中结点与边之间的结构信息。例如，对于任意一个关联矩阵，如果某行元素全为零，当且仅当该行所对应的结点为孤立结点。 再如，如果第 $j$列与第 $k$列相同，当且仅当 $e_{j}$ 与 $e_{k}$ 是平行边，或者说重边对应的列完全相同。 后面将经常使用关联矩阵分析图模型的各种结构特征。"
有向图的连通性,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.4 有向图的连通性']","{'实体类型': '概念', '定义': '有向图中每条边具有方向性，结点之间的可达性关系不一定满足对称性', '特点': '分为强连通、单向连通和弱连通三种基本情况'}",,3,"现在讨论有向图的连通性。与无向图不同的是，有向图中的每条边都具有方向性，结点之间的可达性关系不一定满足对称性。因此，有向图的连通性质比无向图更加复杂，一般要分为强连通、单向连通和弱连通这三种基本情况讨论，其具体定义如下：  
【定义8.30】假设$G=\langle V,E\rangle$任意给定的一个有向图，则有：如果图 $G$中任意两个结点之间都是相互可达的，则称 $G$ 是强连通图；如果图 $G$ 中任意两个结点中至少有一个结点到另一个结点可达，则称 $G$ 是单向连通图，简称为单连通图；对于略去图 $G$ 中各边的方向得到的无向图 $G^{\prime}$，如果 $G^{\prime}$ 是无向连通图，则称 $G$ 是弱连通图，简称为连通图。  
从上述定义可以看出，在没有特别说明的情况下，连通的有向图一般意指为弱连通的有向图。显然，如果一个有向图 $G$ 是强连通的，那么它一定是单连通的，反之不然；如果一个有向图 $G$ 是单向连通图的，那么它一定是弱连通的，反之不然。  
例如，图8-47 所示的三个图模型$G_{1}$, $G_{2}$和$G_{3}$分别是强连通图，单连通图和弱连通图。其中$G_{1}$既是强连通图也是单连通图，$G_{2}$是单连通图也是弱连通图。  
![图8-47 强连通图、单向连通图、弱连通图  ](images/bb31206be85b6681e4bfdebf210d613d4577ab233c09b6ccf50f1f6eb3389294.jpg)  
【定理8.9】（连通性定理）有向图 $G$ 是强连通图的充要条件是存在一条经过图$G$所有结点的回路；有向图 $G$ 是单连通图的充要条件是存在一条经过图𝐺所有结点的通路。  
类似于无向图的连通分支的概念，可分别根据有向图的强连通、单向连通、弱连通概念定义相应的连通分支，得到强分图、单向分图、弱分图的概念，具体定义如下：  
【定义8.31】假设$G=\langle V,E\rangle$任意给定的一个有向图，设 $G^{\prime}$是 $G$ 的一个子图，如果$G^{\prime}$是强连通的（单向连通的、弱连通的），并且对 $\forall G^{\prime\prime}\subseteq G$，若$G^{\prime}\subset G^{\prime\prime}$，则 $G^{\prime\prime}$不是强连通的（单向连通的、弱连通的），则称 $G^{\prime}$ 为 $G$ 的强连通分支（单向连通分支、弱连通分支），简称为强分图（单分图、弱分图）。  
显然，强分图、单分图、弱分图都是 $G$ 的子图，可以用结点集合𝑉的子集导出。显然，强分图是单分图和弱分图，单分图一定是弱分图，但是为了强调它们之间的差异性，一般不再将强分图称为单分图或弱分图，也不再将单分图称为弱分图。  
从上述定义及例题不难看出，可分别通过强分图、单分图、弱分图的概念对有向图中所有结点进行分组。具体地说：  
（1）对于由强连通关系产生的强分图，由于有向图结点之间的强连通关系显然满足自反性、对称性和传递性，因此这种强连通关系是一种等价关系，从而可由此等价关系实现对图中所有结点的划分。显然，每个强分图其实就是一个等价类或者划分块，图中所有的强分图就是构成了所有的划分块。 因此，有向图的任何一个结点属于且仅属于一个强分图。  
（2）对于由弱连通关系产生的弱分图，可类似于无向图的方法进行讨论。事实上，不难看出，弱分图其实就是有向图所导出无向图中的连通分支。因此，所有的弱分图也构成了有向图中所有结点的一种划分，有向图的任何一个结点属于且仅属于一个若分图。  
（3）对于由单向连通关系产生的单分图，不难证明，有向图结点之间的单连通关系满足自反性、对称性，但不满足传递性，因而是一种相容关系。可由此相容关系实现对图中所有结点的最大覆盖。显然，每个强分图其实就是一个最大相容类，图中所有的单分图就是构成了所有的最大相容类。因此，有向图的任何一个结点至少属于一个强分图。  
类似地，可分别通过强分图、单分图、弱分图的概念对有向图中所有边进行分组。 不难发现：对于任何一个给定的有向图，它的每条边至多属于一个其强分图，至少属于一个其单分图，属于且仅属于一个其弱分图。  
例如，对于例题8.30 中的强分图、单分图和弱分图，不难看出它们均满足上述所有关于结点和边分组性质。"
有向图结点度,定义,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.2.2 图模型的度结构']","{'实体类型': '定义', '内容': '设图 $G=\\\\langle V,E\\\\rangle$ 是任意给定的一个有向图，$v$ 是 $G$ 中任一结点，则以该结点为起点的有向边的条数，称为该结点的出度，记为 $\\\\deg^{+}(v)$；以该结点为终点的有向边的条数，称为该结点的入度，记为 $\\\\deg^{-}(v)$。该结点的出度与入度之和称为该结点的度，记为 ${\\\\sf d e g}(v)$'}",,3,"现在我们考察图模型的结构特征。从结构上看，对于任意给定的一个图模型，只要该图不是零图，总会有一些点与一些边相互联结。从生成子图的概念可以看出，图的结点构成了图模型的骨架或主体结构，因此，我们主要从结点出发考察每个结点所关联的边关联多少条边。为此，对于图中的每个结点，都定义一个数来描述该结点所关联边的个数，这就是结点度的概念，其具体定义如下：  
【定义8.16】假设图 $G=\langle V,E\rangle$是任意给定的一个无向图，对于$G$中任意一个结点 $v$ ，与该结点关联边的条数称为该结点的度数，简称为度，记为 ${\sf d e g}(v)$。图$G$中各个结点度数的最大值称为图$G$的最大度，记为$\Delta(G)$；图$G$中各个结点度数的最小值称为图$G$的最小度，记为$\delta(G)$ $\Delta(\mathrm{G})=\mathrm{max}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\};\,\,\,\delta(\mathrm{G})=\mathrm{min}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\}\,.$  
【定义8.17】设图 $G=\langle V,E\rangle$是任意给定的一个有向图，$v$是$G$中任一结点，则有：  
（1）以该结点为起点的有向边的条数，称为该结点的出度，记为$\deg^{+}(v)$；以该结点为终点的有向边的条数，称为该结点的入度，记为 $\deg^{-}(v)$。  
（2）该结点的出度与入度之和称为该结点的度，记为${\sf d e g}(v)$。 即有：  
$$
\deg(v)=\deg^{+}(v)+\deg^{-}(v)
$$  
（3）图$G$中各个结点出度与入度的最大值分别称为图$G$的最大出度和最大入度，分别记为$\Delta^{+}(\mathsf{G})$和 $\Delta^{-}(\mathsf{G})$；图$G$中各个结点出度与入度的最小值分别称为图$G$的最小出度和最小入度，分别记为$\Delta^{+}(\mathbf{G})$和 $\Delta^{-}(\mathsf{G})$，即有：  
$\Delta^{+}(\mathrm{G})=\operatorname*{max}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\Delta^{-}(\mathrm{G})=\operatorname*{max}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$ $\delta^{+}(\mathrm{G})=\operatorname*{min}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\delta^{-}(\mathrm{G})=\operatorname*{min}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$  
从上述定义可以看出，引入度结点度概念的目的主要是通过对图中每个结点所关联边数进行统计分析来考察图模型的结构特征。  
【定义8.18】对于任意一个给定的有向图或无向图  $G=\langle V,E\rangle$ ，图中度数为1 的结点称为该图的悬挂结点，图中以悬挂结点为端点的边称为该图的悬挂边。如果图$G$中各个结点的度数均相同，则称该图正则图，各结点度均为$\ k$的正则图称为$\pmb{k}$-正则图。  
下面我们考察图的邻接矩阵与图中结点度之间的关系。  
假设 $G=\langle V,E\rangle$是任意给定的一个有向图或无向图，其中$V=\{v_{1},v_{2},\ldots,v_{n}\}$，$E=$$\{e_{1},e_{2},\ldots,e_{m}\}$。 $G$的邻接矩阵为：  
$$
A=(a_{i j})_{n\times n}=\left(\!\!{\begin{array}{c c c c}{a_{11}}&{a_{12}}&{\ldots}&{a_{1n}}\\ {a_{21}}&{a_{22}}&{\ldots}&{a_{2n}}\\ {\vdots}&{\ddots}&{\vdots}\\ {a_{n1}}&{a_{n2}}&{\ldots}&{a_{n n}}\end{array}}\!\!\right)
$$  
则有如下结论：  
（1）如果$G$是无向图，那么邻接矩阵𝐴中第𝑖行元素之和表示结点$v_{i}$的度数，第𝑗列元素之和表示结点$v_{j}$的度数。即有：  
$$
\deg(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};~~~~\deg\bigl(v_{j}\bigr)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（2）若G是有向图，那么邻接矩阵$A$中第𝑖行元素之和表示结点$v_{i}$的出度，第$j$列元素之和表示结点$v_{j}$的入度。简单地说，就是竖入横出。即有：  
$$
\deg^{-}(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};\qquad\deg^{+}\!\left(v_{j}\right)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（3）对于有向图G，注意到：  
$$
\sum_{j=1}^{n}\;\deg^{-}\!\left(v_{j}\right)=\sum_{i=1}^{n}\sum_{j=1}^{n}a_{i j}=\sum_{i=1}^{n}\deg^{+}\!\left(v_{i}\right)
$$  
因此，有向图中所有入度之和等于所有出度之和，这个和其实就是图的边数$m$。因为有向图的每条边均产生且仅产生一个出度和一个入度。  
对于图8-19 所示图模型$G$及如下邻接矩阵$A_{G}$，容易验证，结点度与邻接矩阵之间的数量关系。例如，$A_{G}$中第三行元素之和为3，即$v_{3}$的出度为3。
$$
\begin{gathered}v_{1}\quad v_{2}\quad v_{3}\quad v_{4}\quad v_{5}\\A_{G}=\begin{matrix}v_{1}\\v_{2}\\v_{3}\\v_{4}\end{matrix}\begin{pmatrix}0&1&0&0&0\\0&1&1&0&0\\1&1&0&1&0\\0&0&0&0&0\\0&0&0&0&0\end{pmatrix}\end{gathered}
$$  
关于图中结点度数与边的关系，有如下著名的图论基本定理：  
【定理8.1】（握手定理）假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，则该图中结点度数的总和等于边数的二倍，即有：  
$$
\sum_{v\in V}\deg(v)=2|E|
$$  
【推论8.1】图中度数为奇数的结点个数必为偶数。  
从以上定理及例题可以看出，图模型中结点的度从一种定量的角度反映了图中结点与边之间的制约关系，在一定程度上刻画了图模型的结构特征。为了更加方便地描述图模型中各个结点的度结构信息，下面给出度序列的概念：  
【定义8.19】假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，图中每个结点的图构成的自然数序列称为$G$的度序列。也就是说，若 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，则称序列：  
$$
(\deg(v_{1})\,,\deg(v_{2})\,,\cdots,\deg(v_{n}))
$$  
为图 $G$ 的度数序列，简称为度序列。 此外，对于任意一个给定的自然数序列，如果该序列能够成为某个图的度序列，则称该序列为可图化序列。  
例如，对于图8-22 所示图 $G$ ，其度数序列为 (2,3,3,4)  
![图8-22 图 $G$ ](images/77ba680d9b589e032065b86071c3f75473dc0d06736af0deb36aa2115de43d51.jpg)  
由于图模型的度要满足握手定理等基本约束要求，而且对于不同类型的图，其度序列也会有一些相应的数据特征。因此，并不是任意的自然数序列都可以构成图模型的度序列。对于任意给定的自然数序列，需要通过分析其数据特征来判断其是否为可图化序列。若是可图化序列，则可依据该序列数据来分析其所对应图的结构特征。"
有向图表示法,算法,"['第五章 关系模型与理论', '§ 5.1 关系的数学模型', '5.1.3 关系的表示', '2、有向图表示法']","{'实体类型': '算法', '特点': '由结点和有向边构成，用于表示有限集合上的二元关系', '方法': '将集合元素视为结点，关系中的序偶视为有向边'}",,4,"图是一种非常重要的数学模型，是问题表示和求解的基本工具。本书将在后续相关内容专门介绍和讨论图模型的基本理论及应用。这里主要给出二元关系的一种图模型表示方法。一般来说，图模型由一些结点和一些联结结点的边构成，一条边关联且仅关联两个结点。对于任意给定的一条边，如果将关联这条边的其中一个结点确定为起点，另外一个结点确定为终点，则称该边为有向边，若一个图中的每条边都是有向边，则称该图为有向图。在一般情况下，有向图只能表示有限集合上的二元关系。下面给出二元关系的一种有向图表示方法，通常称表示关系的有向图为关系图。  
假设𝐴, $B$是任意给定的两个非空有限集合，$R$是$𝐴$到$B$的一个二元关系： （1）当$A\ne B$时，不妨设$A=\{a_{1},a_{2},\cdots,a_{n}\}$，$B=\{b_{1},b_{2},\cdots,b_{m}\}$，则可将$𝐴,$ $B$中每个元素分别看成是有向图的一个结点，用“ ∘”表示，并将$𝐴$中元素$a_{1},a_{2},\cdots,a_{n}$对应的结点放在左边一列作为有向边的起点，将$B$中元素$\cdot b_{1},b_{2},\cdots,b_{m}$对应的结点放在右边一列作为有向边的终点。对于关系$R$中的每个序偶，则构成有向图中的一条有向边，也就是说，对于$𝐴$中的任一元素$a_{i}$和$B$中的任一元素$b_{j}$组合而成的序偶$\langle a_{i},b_{j}\rangle$，当且仅当$\langle a_{i},b_{j}\rangle\in R$时，以$a_{i}$对应的结点为起点、以$b_{j}$对应的结点为终点画出一条有向边，由此得到$R$的关系图。  
（2）当$A=B$时，设$A=B=\{a_{1},a_{2},\cdots,a_{n}\}$，此时$R$ 是集合$𝐴$上的关系，则将$𝐴$中的每个元素分别看成是有向图中的一个结点，用“ ∘”表示，对于任意一个序偶$\langle a_{i},a_{j}\rangle$：  
如果$a_{i}$和$a_{j}$对应的不是同一个结点，则当且仅当$\langle a_{i},a_{j}\rangle\in R$时，使用以$a_{i}$对应的结点为起点、以$b_{j}$对应的结点为终点的有向边联结$a_{i}$和$a_{j}$对应的两个结点；如果$a_{i}$和$a_{j}$对应的是同一个结点，即$a_{i}$和$a_{j}$是$𝐴$中同一个元素，则当且仅当$\langle a_{i},a_{i}\rangle\in R$时，则在$a_{i}$对应的结点上画一个从该结点出发并回到该结点的有向小圆环。  
下面举例说明关系图的构造方法："
有向图邻接矩阵,性质,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.3 图的表示方法', '一、邻接矩阵表示法']","{'实体类型': '性质', '特点': '关系矩阵不一定是对称矩阵'}",,4,"邻接矩阵是表示图结点间邻接关系的矩阵，即表示图模型中的各个结点之间是否有边的联结关系的关系矩阵。邻接矩阵的具体定义如下：  
【定义8.7】设$G=\langle V,E\rangle$是任一给定的图模型 ，其中结点集合$\ V=\{v_{1},v_{2},\ldots,v_{n}\}$，边集合$E=\{e_{1},e_{2},\dots,e_{m}\}$。称 $n$ 阶方阵 $A_{G}=(a_{i j})_{n\times n}$为图 $G$ 的邻接矩阵，如果矩阵元素 $a_{i j}$ 表示图中结点$v_{i}$ 和 $v_{j}$ 之间是否有边相连：若有则$a_{i j}$为边数$k$，否则$a_{i j}=0$。即有：  
$$
a_{i j}={\left\{\begin{array}{l l}{k,}&{{\mathbb{若}}(v_{i},v_{j}){\in}E{\mathbb{或}}\langle v_{i},v_{j}\rangle{\in}E}\\ {0,}&{{\mathbb{否则}}}\end{array}\right.}\quad\quad\quad\quad(i,j=1,2,3,\cdots,n)
$$ {      }  
从上述定义可以看出，如果图$G=\langle V,E\rangle$是一个线图，则其邻接矩阵为布尔矩阵。此外，需要注意的是，要确定一个图的邻接矩阵，首先必须对图中的所有结点进行编号，邻接矩阵的表示与结点编号的次序紧密相关，不同的结点编号对应于不同的邻接矩阵，结点编号次序的交换对应于邻接矩阵行列的交换。  
图8-8 所示有向图 $G$ 在 $v_{1},v_{2},v_{3},v_{4}$的结点次序下的邻接矩阵为：  
$$
\begin{gathered}v_{1}\quad v_{2}\quad v_{3}\quad v_{4}\\A_{G}=(a_{ij})_{n\times n}=\begin{matrix}v_{2}\\v_{3}\\v_{4}\end{matrix}\begin{pmatrix}0&1&0&1\\1&0&1&1\\1&0&0&0\\0&0&1&0\end{pmatrix}.\end{gathered}
$$  
事实上，无向图和有向图的关联矩阵有一些差异。例如，无向图的每条边不带方向，或理解为每条边同时具有两个方向，故其表示的二元关系具有对称性。因此，关系矩阵或者说图的关联矩阵是一个对称矩阵。对于有向图，其表示的二元关系不一定具有对称性，故其关联矩阵不一定是对称矩阵。因此，通常分别讨论无向图和有向图的邻接矩阵。"
有向树,概念,"['第九章  树的基本理论与算法', '§ 9.2 根树的基本知识', '9.2.1  有向树与根树']","{'实体类型': '概念', '定义': '对于任意一个给定的有向图，如果略去其所有有向边的方向而得到的无向图是一棵树，则该有向图称为一棵有向树', '特点': '连通性与无环性由其伴随的无向图模型决定'}",,3,"我们知道无向树是一种由无向图构成的特殊图模型.那么如何定义和处理由有向图构成的有向树模型呢？现在就来讨论这个问题，首先给出如下有向树模型的定义：  
【定义9.4】对于任意一个给定的有向图，如果略去其所有有向边的方向而得到的无向图是一棵树，则该有向图称为一棵有向树。  
![图 9-12 有向树与非有向树  ](images/2fdb86589dcfaa78bb54f5eaf1ee2b9affe960919c61d426d8acd7eff5e51d45.jpg)  
例如，对于图9-12 所示若干有向图，略去其所有边的方向，则由图9-12(a)、（b）得到的无向图都是树，而由图9-12（c）得到的无向图有回路，由图9-12（d）得到的无向图为森林。因此，图9-12（a）、（b）均是有向树，图9-12（c）、（d）均不是有向树。  
从上述定义及例题可以看出，有向树模型的连通性与无环性是由其伴随的无向图模型决定的，或者说是略去边的方向而直接将有向树看成是无向树.这与一般有向图模型的概念和处理方式有很大差异.因此，如果在树模型的框架下讨论有向树中某条或某几条边在方向上的差异，则没有太大意义，甚至有时还会引起概念上的混淆。  
事实上，自然界中的树模型本身就蕴含着一种方向，这种方向体现在由树根、树枝和树叶结点所构成的层次结构当中，由树根、树枝和树叶结点之间在属性上的差异来刻画边的方向性，不过这种边的方向不是个别边的方向而是所有边的整体方向，即从根到叶的方向或从叶到根的方向。对自然界中树模型的上述特征进行抽象，得到如下根树的概念：  
【定义9.5】对于一棵非平凡的有向树，如果恰有一个结点的入度为0，其余所有结点的入度均为1，则称之为根树或外向树.入度为0 的结点称为根结点,简称为根；出度为0 的结点称为叶结点，简称为叶；入度为1，出度大于0 的称为内结点，简称为内点；又将内点和根统称为分支结点，简称为分支点。在根树中，从根到任一结点的通路长度，称为该结点的层数；所有结点的层数最大值称为根树的高。  
通常使用倒置法表示根树，即把根画在最上方，叶画在最下方，有向边的方向均指向下方。例如，图9-13（a）中的有向树就是一棵根树，其中$v_{1}$为根，$v_{5},v_{6},v_{8},v_{9},v_{10},v_{12},v_{13}$为叶，$v_{2},v_{3},v_{4},v_{7},v_{11}$为内点。其中，$v_{1}$处在第0 层，层数为0；$v_{2},v_{3},v_{4}$同处在第一层，层数为1；$v_{5},v_{6},v_{7},v_{8},v_{9}$同处在第二层，层数为2；$v_{10},v_{11},v_{12}$同处在第三层，层数为3；$v_{13}$处在第四层，层数为4；这棵树的高度为4。  
![图9-13 根树的方向与方向省略  ](images/f923bd763ba9a19de150bb3a9be8189594c2d07589f0b79f2493ff5c6c70768a.jpg)  
从根树的定义及上述例题不难发现，根树作为一种特殊的有向树其所有边均是朝着一个方向，即是从根结点到叶结点的方向，如图9-13（a）所示。既然如此就可以对这种特殊的有向图进行化简，即省略根树中所有边的方向将其转化为无向树，如图9-13（b）所示.由此可知，根树其实是一种具有根、枝、叶等层次结构的特殊无向树。  
![图9-14 根树的层次结构  ](images/d86c7aab6ba7ea9d62cfd7298cb652c45b9ae862b8d84a5cb286853843255862.jpg)  
如图9-14 所示，根树是一种由子树不断嵌套而产生的一种层次结构模型，故还可用如下递归的方式定义根树：  
【定义9.6】树是一个$n(n>0)$元有限集，集合中所有数据元素具有如下层次关系：当$n=0$ 时，集合为空集，称之为空树；当$n>0$ 时，集合中有且只有一个特定的结点，称之为树模型的根；当$n>1$ 时，除根以外的其余结点可分为$m(m>0)$个互不相交的有限集$T_{1},T_{2},\cdots,T_{m}$，其中每个集合本身又是一棵树，并称$T_{1},T_{2},\cdots,T_{m}$称为根的子树。  
例如，图9-15 表示一个具体的树模型结构。该树有10 个结点，其中𝐴是根结点，其余结点被分为 3  个互不相交的子集： $T_{1}=\{B,E,F\},T_{2}=\{C,G\},T_{3}=\{D,H,I,J\}$ ； $T_{1}$ ， $T_{2}$ ， $T_{3}$ 都 是 𝐴 的子树，它们本身也分别是一棵树。  
![](images/64aed744b0075ece5ec5a03893d3b845267949822e6760ad07e255b850f44d71.jpg)  
也可用家族关系表示根树中各节点间的关系。  
【定义9.7】在根树中，若从结点$v_{i}$到$v_{j}$可达，则称$v_{i}$是$v_{j}$的祖先，$v_{j}$是$v_{i}$的后代；又若 $\langle v_{i},v_{j}\rangle$是根树中的有向边，则称$v_{i}$是$v_{j}$的父亲，$v_{j}$是$v_{i}$的儿子；如果两个结点是同一个结点的儿子，则称这两个结点是兄弟。  
例如，对于图9-16 所表示的树，结点𝐴 的出度为3，结点$B$的出度为2，结点𝑀的出度为0；结点$A$的孩子为$(B,C,D)$，结点$B$的孩子为$(E,F)$；结点𝐴的层次为1，结点𝑀的层次为4 ； 叶结点有 $(K,L,F,G,M,I,J)$ ， 分枝结点有 $(A,B,C,D,E,H)$ ； 结点 𝐼 的双亲为 $D$ ， 结点 𝐿 的双亲 为$E$；结点$B,C,D$为兄弟，结点$K$，$L$为兄弟；树的高度为4；结点𝐴是结点$F$、$G$的祖先，结点$B$，$C$是结点𝐴的子孙。  
有时还会在根树的同层次的兄弟结点之间规定具体的大小排序，一般是从左到右进行排序，有时也可以用边的次序代替结点的次序。  
在根树的实际应用中，例如对目标的排序与查找等，需要经常对其中间结点的分支数进行度量、设计和分析，为此给出如下关于$\cdot k$元根树或$k$叉根树的概念：  
【定义9.8】 在根树𝑇中，若每个分支点至多有${k}$个儿子，则称𝑇为𝒌元树或𝒌叉树；若每个分支点都恰有${k}$个儿子，则称𝑇为完全$ k$元树或完全$ k$叉树；若$k$元树𝑇的兄弟结点之间有序，则称𝑇为𝒌元有序树或$k$叉有序树；若完全$ k$元树𝑇的兄弟结点之间有序，则称𝑇为有序完全𝒌元树或有序完全$k$叉树。在根树$T$中，任一结点$v$及其所有后代导出的子图$𝑇′$称为$𝑇$的以$v$为根的子树.当然$T^{\prime}$也可以有自己的子树.有序二元树的每个结点$𝑣$至多有两个儿子，分别称为 $𝑣$ 的左儿子和右儿子，至多有两棵子树，分别称为 $𝑣$ 的左子树和右子树。  
注意：以$v$为根的子树包含$𝑣$，而$𝑣$的左右子树则不包含$𝑣$  
【定理9.6】在$k$元完全树中，若叶为𝑡，分支点数为 $i$，则下式成立：  
$(k-1)\times i=t-1~~~~~~~~~~~~~~\quad(9-1)$"
有向边,概念,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.2 图的定义与分类']","{'实体类型': '概念', '定义': '从结点u出发到结点v的有方向的边，用序偶<u,v>表示'}",,3,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)"
有序三元组,概念,"['第五章 关系模型与理论', '§ 5.1 关系的数学模型', '5.1.1  序偶与笛卡尔积']","{'实体类型': '概念', '定义': '序偶的序偶，由三个元素组成的有序组'}",,3,"要用数学方式表达关系模型，首先必须建立有一种有效的数学机制将来自相同集合或不同集合的两个元素绑定在一起，以表明它们之间具体某种特定的关系。为此，下面给出二元组的相关概念来实现这种机制。  
【定义5.1】假设𝐴和$B$是任意给定的两个集合，则对于分别来自这两个集合中的元素$x$和𝑦，可将它们组合成一个整体并称之为二元组。如果这个二元组为无序二元组，则称其为无序偶对，简称为无序偶，通常记为$(x,y)$；如果这个二元组为有序二元组，则称其为有序偶对，简称为序偶，通常记为$\langle x,y\rangle$，并称$\cdot x\in A$为第一元素，$y\in B$为第二元素。  
在关系的数学理论中，通常使用序偶的概念绑定具有某种确定联系的两个元素。事实上序偶的用途非常广泛，日常生活和工作中的很多问题或概念都可用序偶表示。例如，平面上点$A$ 的横坐标是$x$，纵坐标是$y$，可用序偶表示为$\langle x,y\rangle$，$x,y\in R$；合肥是安徽的省会、南京是江苏的省会，可分别用序偶表示为〈合肥, 安徽〉，〈南京, 江苏〉；数学书在桌上、英语书在床上，可分别用序偶表示为〈数学书, 桌上〉，〈英语书,床上〉。  
由序偶的定义容易知道，序偶可以看作是具有两个元素的集合，但序偶中的两个元素是具有确定次序的，如果两个含有两个元素的集合相等，并不意味着这两个集合元素构成的序偶相等，因此即使成立$\{a,b\}=\{b,a\}$，在$a\neq b$的情况下会有：成立$\langle a,b\rangle\neq\langle b,a\rangle$。例如，对于前述的序偶〈合肥, 安徽〉，从集合的角度看，显然有{合肥, 安徽}$\}=$ {安徽,合肥}，但是序偶〈合肥, 安徽〉和〈安徽, 合肥〉显然代表的是两个不同的含义：前者表示合肥是安徽的省会，前者表示安徽是合肥的省会。因此，有：〈合肥, 安徽〉 $\neq$〈安徽,合肥〉。  
下面给出两个序偶相等的具体定义：  
【定义5.2】假设$\langle a,b\rangle$和$\langle c,d\rangle$是任意给定的两个序偶，如果$a=b$，$c=d$，那称这两个序偶相等，记为：$\langle a,b\rangle=\langle c,d\rangle$。  
从上述定义可知，两个序偶相等当且仅当这两个序偶在对应位置上的元素相等。例如，若有$\langle2x-3y,3x+2y\rangle=\langle1,3\rangle$，则有$2x-3y=1$且$3x+2y=3$；反之亦然。  
显然，可将上述序偶及其相等的相关定义自然推广到多个元素的情形。例如，对于任意给定的三个元素$x,y,z$，则可根据如下递归方式定义由这三个元素组成的有序三元组：  
$$
\langle x,y,\mathrm{z}\rangle=\langle\langle x,y\rangle,\mathrm{z}\rangle\tag{5-1}
$$  
从上式可以看出，所谓有序三元组，其实就是序偶的序偶。一般地，可得到如下关于$^{\cdot n}$元有序组的相关定义：  
【定义5.3】由$n$个元素$a_{1}$ ,$a_{2},\dotsc,a_{n}$组成 $n$元有序组由$n-1$元有序组$\langle a_{1}\;\,,a_{2},\dots,a_{n-1}\rangle$和元素$a_{n}$组成的序偶，记作$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$。即：$\langle a_{1}\;\;,a_{2},\ldots,a_{n}\rangle=\langle\langle a_{1}\;\;,a_{2},\ldots,a_{n-1}\rangle,a_{n}\rangle$。  
【定义5.4】假设$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$和$\langle b_{1},b_{2},\dots,b_{n}\rangle$是任意给定的两个$ n$元有序组，如果$a_{i}=$$b_{i}$，$i=1,2,\dots,n$，则称它们相等，记为：$\langle a_{1}\,\ ,a_{2},\ldots,a_{n}\rangle=\langle b_{1},b_{2},\ldots,b_{n}\rangle\,.$。  
【定义5.5】设$A,B$是任意给定的两个集合，用$A$中任意一个元素为第一元素、$B$中任任意一个元素为第二元素构成的所有可能的序偶组成的集合，称为$A$ 与$B$ 的笛卡尔积，亦称为$A$ 与$B$ 的直积，记为$A\times B$。即有：$A\times B=\{\langle x,y\rangle|(x\in A)\land(y\in B)\}$。  
由上述定义可知，集合$A$ 与$B$ 的笛卡尔积运算结果$A\times B$仍是一个集合，并且$A\times B$中的每个元素都是一个序偶，序偶中第一个元素取自集合$A$、第二个元素取自集合$B$。  
假设根据笛卡尔积的定义，不难证明笛卡尔积运算满足如下几条基本性质：  
（1）假设$A$,$B$是任意给定的两个集合，则有：$A\times\emptyset=B\times\emptyset=\emptyset$；  
（2）假设 $A$, $B$ 是任意给定的两个集合，则有 $A\times B=\emptyset$ ，当且仅当 $A=\emptyset$ 或 $B=\emptyset$；  
（3）当$A,B$是有限集合时，有：$|A\times B|=|B\times A|=|A||B|$  
下面定理表明笛卡尔积运算对集合的并运算和交运算均满足分配律：  
【定理5.1】设$A$、$B$、$C$ 是任意集合，则有：  
$A\times(B\cup C)=(A\times B)\cup(A\times C);\quad A\times(B\cap C)=(A\times B)\cap(A\times C);$  
$(A\cup B)\times C=(A\times C)\cup(B\times C);\quad(A\cap B)\times C=(A\cup C)\times(B\times C)\,$。  
【定理5.2】设$A$、${B}、{C}$ 是任意集合且$C\neq\emptyset$，则有：
$$
A\subseteq B\Leftrightarrow(A\times C\subseteq B\times C);\,\,\,A\subseteq B\Leftrightarrow(C\times A\subseteq C\times B)
$$  
【定理5.3】设$A、\ B、C、D$为非空集合，则有：
$$
A\subseteq C\land B\subseteq D\Leftrightarrow A\times B\subseteq C\times D
$$  
【定理5.4】假设集合$\cdot A_{1},A_{2},\cdots,A_{n}$均为有限集合，则有：
$$
|A_{1}\times A_{2}\times\cdots\times A_{n}|=|A_{1}|\times|A_{2}|\times\cdots\times|A_{n}|
$$"
有序偶,概念,"['第五章 关系模型与理论', '§ 5.1 关系的数学模型', '5.1.1  序偶与笛卡尔积']","{'实体类型': '概念', '定义': '有序二元组，通常记为⟨x,y⟩，第一元素来自集合A，第二元素来自集合B'}",,3,"要用数学方式表达关系模型，首先必须建立有一种有效的数学机制将来自相同集合或不同集合的两个元素绑定在一起，以表明它们之间具体某种特定的关系。为此，下面给出二元组的相关概念来实现这种机制。  
【定义5.1】假设𝐴和$B$是任意给定的两个集合，则对于分别来自这两个集合中的元素$x$和𝑦，可将它们组合成一个整体并称之为二元组。如果这个二元组为无序二元组，则称其为无序偶对，简称为无序偶，通常记为$(x,y)$；如果这个二元组为有序二元组，则称其为有序偶对，简称为序偶，通常记为$\langle x,y\rangle$，并称$\cdot x\in A$为第一元素，$y\in B$为第二元素。  
在关系的数学理论中，通常使用序偶的概念绑定具有某种确定联系的两个元素。事实上序偶的用途非常广泛，日常生活和工作中的很多问题或概念都可用序偶表示。例如，平面上点$A$ 的横坐标是$x$，纵坐标是$y$，可用序偶表示为$\langle x,y\rangle$，$x,y\in R$；合肥是安徽的省会、南京是江苏的省会，可分别用序偶表示为〈合肥, 安徽〉，〈南京, 江苏〉；数学书在桌上、英语书在床上，可分别用序偶表示为〈数学书, 桌上〉，〈英语书,床上〉。  
由序偶的定义容易知道，序偶可以看作是具有两个元素的集合，但序偶中的两个元素是具有确定次序的，如果两个含有两个元素的集合相等，并不意味着这两个集合元素构成的序偶相等，因此即使成立$\{a,b\}=\{b,a\}$，在$a\neq b$的情况下会有：成立$\langle a,b\rangle\neq\langle b,a\rangle$。例如，对于前述的序偶〈合肥, 安徽〉，从集合的角度看，显然有{合肥, 安徽}$\}=$ {安徽,合肥}，但是序偶〈合肥, 安徽〉和〈安徽, 合肥〉显然代表的是两个不同的含义：前者表示合肥是安徽的省会，前者表示安徽是合肥的省会。因此，有：〈合肥, 安徽〉 $\neq$〈安徽,合肥〉。  
下面给出两个序偶相等的具体定义：  
【定义5.2】假设$\langle a,b\rangle$和$\langle c,d\rangle$是任意给定的两个序偶，如果$a=b$，$c=d$，那称这两个序偶相等，记为：$\langle a,b\rangle=\langle c,d\rangle$。  
从上述定义可知，两个序偶相等当且仅当这两个序偶在对应位置上的元素相等。例如，若有$\langle2x-3y,3x+2y\rangle=\langle1,3\rangle$，则有$2x-3y=1$且$3x+2y=3$；反之亦然。  
显然，可将上述序偶及其相等的相关定义自然推广到多个元素的情形。例如，对于任意给定的三个元素$x,y,z$，则可根据如下递归方式定义由这三个元素组成的有序三元组：  
$$
\langle x,y,\mathrm{z}\rangle=\langle\langle x,y\rangle,\mathrm{z}\rangle\tag{5-1}
$$  
从上式可以看出，所谓有序三元组，其实就是序偶的序偶。一般地，可得到如下关于$^{\cdot n}$元有序组的相关定义：  
【定义5.3】由$n$个元素$a_{1}$ ,$a_{2},\dotsc,a_{n}$组成 $n$元有序组由$n-1$元有序组$\langle a_{1}\;\,,a_{2},\dots,a_{n-1}\rangle$和元素$a_{n}$组成的序偶，记作$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$。即：$\langle a_{1}\;\;,a_{2},\ldots,a_{n}\rangle=\langle\langle a_{1}\;\;,a_{2},\ldots,a_{n-1}\rangle,a_{n}\rangle$。  
【定义5.4】假设$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$和$\langle b_{1},b_{2},\dots,b_{n}\rangle$是任意给定的两个$ n$元有序组，如果$a_{i}=$$b_{i}$，$i=1,2,\dots,n$，则称它们相等，记为：$\langle a_{1}\,\ ,a_{2},\ldots,a_{n}\rangle=\langle b_{1},b_{2},\ldots,b_{n}\rangle\,.$。  
【定义5.5】设$A,B$是任意给定的两个集合，用$A$中任意一个元素为第一元素、$B$中任任意一个元素为第二元素构成的所有可能的序偶组成的集合，称为$A$ 与$B$ 的笛卡尔积，亦称为$A$ 与$B$ 的直积，记为$A\times B$。即有：$A\times B=\{\langle x,y\rangle|(x\in A)\land(y\in B)\}$。  
由上述定义可知，集合$A$ 与$B$ 的笛卡尔积运算结果$A\times B$仍是一个集合，并且$A\times B$中的每个元素都是一个序偶，序偶中第一个元素取自集合$A$、第二个元素取自集合$B$。  
假设根据笛卡尔积的定义，不难证明笛卡尔积运算满足如下几条基本性质：  
（1）假设$A$,$B$是任意给定的两个集合，则有：$A\times\emptyset=B\times\emptyset=\emptyset$；  
（2）假设 $A$, $B$ 是任意给定的两个集合，则有 $A\times B=\emptyset$ ，当且仅当 $A=\emptyset$ 或 $B=\emptyset$；  
（3）当$A,B$是有限集合时，有：$|A\times B|=|B\times A|=|A||B|$  
下面定理表明笛卡尔积运算对集合的并运算和交运算均满足分配律：  
【定理5.1】设$A$、$B$、$C$ 是任意集合，则有：  
$A\times(B\cup C)=(A\times B)\cup(A\times C);\quad A\times(B\cap C)=(A\times B)\cap(A\times C);$  
$(A\cup B)\times C=(A\times C)\cup(B\times C);\quad(A\cap B)\times C=(A\cup C)\times(B\times C)\,$。  
【定理5.2】设$A$、${B}、{C}$ 是任意集合且$C\neq\emptyset$，则有：
$$
A\subseteq B\Leftrightarrow(A\times C\subseteq B\times C);\,\,\,A\subseteq B\Leftrightarrow(C\times A\subseteq C\times B)
$$  
【定理5.3】设$A、\ B、C、D$为非空集合，则有：
$$
A\subseteq C\land B\subseteq D\Leftrightarrow A\times B\subseteq C\times D
$$  
【定理5.4】假设集合$\cdot A_{1},A_{2},\cdots,A_{n}$均为有限集合，则有：
$$
|A_{1}\times A_{2}\times\cdots\times A_{n}|=|A_{1}|\times|A_{2}|\times\cdots\times|A_{n}|
$$"
有效公式,概念,"['第四章  谓词演算与推理', '§ 4.2  谓词公式与等值演算', '4.2.3 谓词公式的解释与分类']","{'实体类型': '概念', '定义': '在其所有解释下的真值取值为真的谓词公式'}",,3,"我们知道，对于一个命题公式，确定其真值取值状态是比较简单的，只需对命题公式中各个变量逐个指派真值便可得到命题公式的真值，而且在命题变量不是太多的情况下还可通过对命题变量真值指派的各种状态进行枚举的方式列出命题公式的真值表。然而，要确定一个谓词公式的真值取值状态，通常就没有这么简单了。  
例如，要确定谓词公式$(\forall x)(H(x){\rightarrow}D(x))$的真值，首先要确定其个体域，然后还要确定谓词$H(x)$和$D(x)$的具体含义。如果使用全总个体域$H(x)$表示 $x$是人$D(x)$表示 $x$会死的，则该谓词公式的取值为真，若将$D(x)$表示为 $x$是勇敢的，则谓词公式的取值为真为假。  
一般来说，对于任意给定的谓词公式，其含义与真值取值不仅依赖于个体域，依赖于公式中各个个体变量的取值状况，还依赖于对公式中谓词符号、函数符号、常量符号具体含义的确认，这些所有的依赖信息构成对谓词公式的解释。如果不对谓词公式中常量符号、变量符号、函数符号、谓词符号进行具体的解释，则公式就没有确定的含义和确定的真值取值.下面给出关于谓词公式解释的具体定义：  
【定义4.15】 谓词公式$G$的每一个解释$I$由如下四个部分组成：  
（1）确定非空的个体域集合$D$；  
（2）确定公式$G$ 中的每个常量符号的含义，即指定$D$ 中的某个特定的元素；  
（3）确定公式$G$ 中的每个$n$元函数的具体形式，即对于公式$G$ 中每个$n$元函数分别指定一个从$D^{n}$ 到$D$ 中的特定函数与之对应；  
（4）确定公式$G$ 中的每个$n$元谓词符号的具体形式，即对于公式$G$ 中每个$n$元谓词符号分别指定一个从$D^{n}$ 到$\{0,1\}$的特定函数与之对应。  
易知，对于任意一个给定的谓词公式，如果该公式是封闭公式，即不含有任何自由个体变量，则该公式在任何解释下均有确定的真值。  
由上述例题可知，与命题公式一样，有些谓词公式在有些解释下为真，在另外一些解释下为假；而有些谓词公式则在所有解释下均为真；还有一些谓词公式在所有解释下均为假。由此可以得到如下有效公式、矛盾公式和可满足公式的定义：  
【定义4.16】 对于任意一个给定的谓词公式$G$，如果$G$ 在其所有的解释$I$下的真值取值为真，则称$G$ 称为有效公式；如果$G$ 在其所有的解释$I$下的真值取值都为假，则称$G$为矛盾公式；如果$G$ 不是矛盾公式，则称其为可满足公式。  
从上述定义可知三种特殊公式之间具有如下关系：有效公式的否定为矛盾公式；矛盾公式的否定为有效公式；有效公式一定为可满足公式。"
有效推理,概念,"['第三章  命题演算与推理', '§ 3.5 命题逻辑的演绎推理', '3.5.2 命题公式推演系统']","{'实体类型': '概念', '定义': '设G1,G2,...,Gn，H是一些命题公式，如果它们满足下列性质：对于这些公式的任意一个解释I，G1,G2,...,Gn在该解释下同时为真的情况下H在该解释下也为真，则称命题公式G1,G2,...,Gn可有效推出公式H，或称由G1,G2,...,Gn得到H的逻辑推理为有效推理，记为G1,G2,...,Gn⇒H，并称G1,G2,...,Gn为推理前提，H为G1,G2,...,Gn的逻辑结论', '特点': '把永真蕴含关系由两个命题公式之间的关系推广到多个命题公式之间的关系，即由一组命题公式构成的永真蕴含前件与一个永真蕴含后件之间的关系'}",,3,"现在我们学习命题的数理逻辑推理。首先给出如下有效推理的概念：  
【定义3.28】设$G_{1},G_{2}\cdots G_{n}$，$H$是一些命题公式，如果它们满足下列性质：对于这些公式的任意一个解释𝐼，$G_{1},G_{2}\cdots G_{n}$在该解释下同时为真的情况下$\cdot_{H}$在该解释下也为真，则称命题公式$G_{1},G_{2}\cdots G_{n}$可有效推出公式$\cdot H$，或称由$G_{1},G_{2}\cdots G_{n}$得到$H$的逻辑推理为有效推理，记为$G_{1},G_{2}\cdots G_{n}\Rightarrow H$，并称$G_{1},G_{2}\cdots G_{n}$为推理前提，$H$为$G_{1},G_{2}\cdots G_{n}$的逻辑结论。  
从上述定义不难看出，有效推理其实就是把永真蕴含关系由两个命题公式之间的关系推广到多个命题公式之间的关系，即由一组命题公式构成的永真蕴含前件与一个永真蕴含后件之间的关系。下面定理表明有效推理的过程其实就是证明逻辑蕴含式的过程。  
【定理3.14】命题公式$H$是命题公式$G_{1},G_{2},\cdots,G_{n}$的逻辑结论，即$G_{1},G_{2},\cdots,G_{n}\Rightarrow H$，当且仅当$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\to H$为永真公式。  
从理论上讲，利用真值表技术完全可以在有限的步骤内完成对任意含有限个命题变量的永真蕴含关系进行判定或者说进行有效的命题逻辑推理。但是，在针对具体问题的命题逻辑推理时，推理的前提条件一般包含很多个命题公式，有时会涉及大量的命题变量，此时真值表方法就出现组合爆炸问题而变的不可行。因此，需要建立一种命题公式推演系统，在少量基本等值关系式和永真蕴含关系式的基础上，通过建立若干推理规则进行演绎推证的方式实现命题逻辑的有效推理。人们提出了很多各具特色的推演系统，对这系统的详细讨论已经超出了本课程的学习范畴，有兴趣的读者可以查阅相关资料。我们主要介绍一种最基本的推演系统，下图3-9 表示系统的基本结构。  
![](images/9e9fac00c2d40b2f3ec288b2f0ea17c474bc9160a1447874b9a37744cd5272d2.jpg)
图3-9 推演系统的基本结构  
上图表示的推演系统中包括事实库、公理库和推理规则这三个基本模块，公理库和事实库构成命题推理的基本依据。公理库包含已被证明为正确的24 个基本等值式和15 个基本永真蕴含式，这些基本关系式构成推演系统的基础知识资源，事实库由具体命题推理实例的所有前提条件以及推理过程中产生的有效中间结论组成；推理规则是命题逻辑推理的核心机制，主要由$P$规则、$T$规则和$C P$规则这三个基本规则组成。  
（1）$P$规则（前提引用规则）：推导过程中可随时引入前提集合中的任意一个前提。  
（2）$T$规则（逻辑结果引用规则）推导的过程中可随时引入公式𝑆，该公式𝑆是由其前的一个或多个公式推导出来的逻辑结果。  
（3）$C P$规则（附加前提规则）如果能从给定的前提集合$\Gamma$与公式$P$推导出𝑆，则能从此前提集合$\Gamma$ 推导出$P\rightarrow S$。  
注意：$C P$规则适用于结论为条件式的有效推理。使用𝐶𝑃规则就是把结论中的前件作为附加前提加入前提集合，共同去推出结论的后件。  
根据上述命题演算推理系统，就可进行有效的命题逻辑推理。通过有效推理，就可证明命题逻辑中所有定理。所谓证明，就是有效推理的具体推演过程，具体定义如下：  
【定义3.29】从前提集合Г 推出结论$\cdot H$的一个演绎或形式证明，就是构造一个命题公式的有限序列：$H_{1},H_{2},H_{3},\ldots,H_{n}$。其中：$H_{i}$或者是Г 中的某个前提，或者是前面的某些${\cdot}H_{j}(j{<}i)$的有效结论，并且${\cal H}_{n}$就是$H$。此时称$H$为该演绎的有效结论。"
有界格,概念,"['第十二章 典型抽象代数结构', '§ 12.5 格的概念与性质', '12.5.3 常用特殊格结构']","{'实体类型': '概念', '定义': '存在最小元和最大元的格', '条件': '存在a,b使得对任意x，有a≤x且x≤b', '特点': '最大元记为1，最小元记为0', '定理': '最大值和最小值唯一'}",,3,"以上从偏序和代数这两个角度考察了格结构的基本概念和基本性质。如果对一般格结构赋予一些新的特征或约束条件，则可进一步得到相应的特殊格。本小节主要讨论若干重要的特殊格，主要包括分配格、有界格和有补格。  
一、分配格  
我们知道格结构的代数运算满足交换律、结合律和吸收律，但并没有要求其满足分配律。事实上，对于一般的格结构只能满足确界运算对偏序的分配不等式，这是一个以不等式形式出现分配形式，这只是一个弱分配律运算性质，如果将该性质加强为以等式形式构成真正意义上的分配律，由此便可得到一种名为分配格的特殊格结构，其具体定义如下：  
【定义12.31】设$\langle L,*,\oplus\rangle$是一个格，如果对于$\forall\ \ a,b,c\in L$，都有： $a*(b\oplus c)=(a*b)\oplus(a*c);\,\,\,a\oplus(b*c)=(a\oplus b)*(a\oplus c)$  
即运算满足分配律，则称$\langle L,*,\oplus\rangle$是一个分配格。  
值得注意的是，以上定义中两个式子其实是对偶式。因此，如要证明一个格是分配格只需证明上式中的任意一个等式即可。  
【定理12.34】设$\langle L,\leq\rangle$是任意给定的一个格结构，则$\langle L,\leq\rangle$是分配格当且仅当$\langle L,\leq\rangle$中即不存在与钻石格同构的子格，也不存在与五角格同构的子格  
【定理12.35】任意一条链都是一个分配格。  
消去律在格中一般不成立，但在分配格中具有如下一种特殊的消去律：  
【定理12.36】设$\langle L,*,\oplus\rangle$是任意给定的一个分配格，则对$\forall$$a,b,c\in L$$，如果a*b=a*c且$$a\oplus b=a\oplus c$，那么有$b=c$。  
二、有界格  
我们知道，格结构是一个偏序结构，如果在该结构的载体集合中引入存在最大值和最小值的约束条件，则可得到有界格的概念，具体如下：  
【定义12.32】设$\langle L,\leq\rangle$是任一给定的格，若$L$中存在最小元和最大元，即$\exists a,b\in L$，对∀ $x\in L$，有$a\leq x$且$x\leq b$，则称$\langle L,\leq\rangle$为有界格，通常将其最大元记为1，最小值记为0。 例如，设$𝑆$是一个非空集合，则格$\langle S,{\subseteq}\rangle$是一个有界格，其最大元是$𝑆$，最小元是$\varnothing$。并不是所有的格都是有界格，例如是实数集上的是小于或等于关系构成的格$<R,\leq\;>$，显然不是有界格。根据最小元和最大元以及幺元和零元的定义，易知成立下列等式：  
$1*x=x*1=x;1\oplus x=x\oplus1=1;0*x=x*0=0;0\oplus x=x\oplus0=x$  
也就是说1 是$*$和⊕的幺元与零元，0 是⊕和$*$的幺元和零元。  
【定理12.37】对于任意一个有界格$\langle L,\leq\rangle$，其最大值和最小值是唯一的。  
三、有补格  
对于格$\langle P(A),\subseteq\rangle$或$\langle{ P}(A),\cap,\cup\rangle$来说，集合$𝐴$和空集$\varnothing$显然是$P(A)$的最大元和最小元。我们知道，可在$\langle{ P}(A),\cap,\cup\rangle$上定义集合的补运算，即对于$\forall B\in P(A)$，存在${\bar{B}}\in P(A)$，满足：  
$$
B\cup\bar{B}=\ A;\ B\cap\bar{B}=\ \varnothing\quad\text{(12.5.9)}
$$  
通常称集合$\bar{B}$是集合$ B$的补集，或者称集合$\bar{B}$与$B$具有互补关系。现将格结构$\langle{ P}(A),\cap,\cup\rangle$或$\langle P(A),\subseteq\rangle$上的补运算推广到一般的有界格中，得到如下有补格的概念：  
【定义12.33】设$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$是任意给定的一个有界格，则对$\forall a\in L$，如果存在$b\in$$L$，满足$a*b=0$ 且$a\oplus b=1$，则称$ b$是$a$的补元素，通常简称为补元，记作$\bar{a}$。如果有界格$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$中每个元素都存在其补元素，则称$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$为有补格。  
由格结构的交换律可知，如果$b$是$a$的补元，那么$a$也是$b$的补元，即$a$与$b$互为补元。易知，在有界格中， 0 的唯一补元是1，1 的唯一补元是0。但是，对于有界格中一般的元素，其补元不一定存在。因此，虽然有补格一定是有界格，但有界格不一定是有补格。  
另一方面，对于任个有补格，并不能保证其中每个元素的补元素是唯一确定的。例如，对于如图12-8 所示的有界格，易知$a$补元是$b$和$c$，$b$的补元是$a$和$c$，$c$的补元是$a$和$b$。  
![](images/15c8cb1c91d0343f4329e4fe28808131c9c2a9b35b96281ded4f82ad6ec628e1.jpg)  
有补格中元素补元的这种不唯一性容易造成对问题分析和求解的混淆。因此，必须对一般的有补格结构附加适当的约束条件，使其能够满足格中任意元素补元的唯一性。事实上，如果对有补格附加满足分配律的约束，这可保证其补元的唯一性，即有如下定理：  
【定理12.38】设$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$是一个有补格并且也是一个分配格，即是一个有补分配格，则$L$中任意元素的补元存在且唯一。  
从以上分析讨论可知：有补格仅保证了补元的普遍性，即格中任意一个元素都至少存在一个补元，但不能保证补元的唯一性；分配格则可以保证补元的唯一性但不能保证补元的普遍性；有补分配格同时吸收了有补格和分配格这两种特殊格的优点，能够同时保证补元的普遍性和唯一性。因此，有补分配格是一个具有优良性质的特殊格结构。事实上，有补分配格就是在计算机、电子信息、自动化等科学与工程中大量用到的布尔格或布尔代数。"
有补分配格,概念,"['第十二章 典型抽象代数结构', '§ 12.5 格的概念与性质', '12.5.3 常用特殊格结构']","{'实体类型': '概念', '定义': '同时满足分配律和补元存在的格', '特点': '保证补元的普遍性和唯一性', '应用': '布尔格或布尔代数'}",,3,"以上从偏序和代数这两个角度考察了格结构的基本概念和基本性质。如果对一般格结构赋予一些新的特征或约束条件，则可进一步得到相应的特殊格。本小节主要讨论若干重要的特殊格，主要包括分配格、有界格和有补格。  
一、分配格  
我们知道格结构的代数运算满足交换律、结合律和吸收律，但并没有要求其满足分配律。事实上，对于一般的格结构只能满足确界运算对偏序的分配不等式，这是一个以不等式形式出现分配形式，这只是一个弱分配律运算性质，如果将该性质加强为以等式形式构成真正意义上的分配律，由此便可得到一种名为分配格的特殊格结构，其具体定义如下：  
【定义12.31】设$\langle L,*,\oplus\rangle$是一个格，如果对于$\forall\ \ a,b,c\in L$，都有： $a*(b\oplus c)=(a*b)\oplus(a*c);\,\,\,a\oplus(b*c)=(a\oplus b)*(a\oplus c)$  
即运算满足分配律，则称$\langle L,*,\oplus\rangle$是一个分配格。  
值得注意的是，以上定义中两个式子其实是对偶式。因此，如要证明一个格是分配格只需证明上式中的任意一个等式即可。  
【定理12.34】设$\langle L,\leq\rangle$是任意给定的一个格结构，则$\langle L,\leq\rangle$是分配格当且仅当$\langle L,\leq\rangle$中即不存在与钻石格同构的子格，也不存在与五角格同构的子格  
【定理12.35】任意一条链都是一个分配格。  
消去律在格中一般不成立，但在分配格中具有如下一种特殊的消去律：  
【定理12.36】设$\langle L,*,\oplus\rangle$是任意给定的一个分配格，则对$\forall$$a,b,c\in L$$，如果a*b=a*c且$$a\oplus b=a\oplus c$，那么有$b=c$。  
二、有界格  
我们知道，格结构是一个偏序结构，如果在该结构的载体集合中引入存在最大值和最小值的约束条件，则可得到有界格的概念，具体如下：  
【定义12.32】设$\langle L,\leq\rangle$是任一给定的格，若$L$中存在最小元和最大元，即$\exists a,b\in L$，对∀ $x\in L$，有$a\leq x$且$x\leq b$，则称$\langle L,\leq\rangle$为有界格，通常将其最大元记为1，最小值记为0。 例如，设$𝑆$是一个非空集合，则格$\langle S,{\subseteq}\rangle$是一个有界格，其最大元是$𝑆$，最小元是$\varnothing$。并不是所有的格都是有界格，例如是实数集上的是小于或等于关系构成的格$<R,\leq\;>$，显然不是有界格。根据最小元和最大元以及幺元和零元的定义，易知成立下列等式：  
$1*x=x*1=x;1\oplus x=x\oplus1=1;0*x=x*0=0;0\oplus x=x\oplus0=x$  
也就是说1 是$*$和⊕的幺元与零元，0 是⊕和$*$的幺元和零元。  
【定理12.37】对于任意一个有界格$\langle L,\leq\rangle$，其最大值和最小值是唯一的。  
三、有补格  
对于格$\langle P(A),\subseteq\rangle$或$\langle{ P}(A),\cap,\cup\rangle$来说，集合$𝐴$和空集$\varnothing$显然是$P(A)$的最大元和最小元。我们知道，可在$\langle{ P}(A),\cap,\cup\rangle$上定义集合的补运算，即对于$\forall B\in P(A)$，存在${\bar{B}}\in P(A)$，满足：  
$$
B\cup\bar{B}=\ A;\ B\cap\bar{B}=\ \varnothing\quad\text{(12.5.9)}
$$  
通常称集合$\bar{B}$是集合$ B$的补集，或者称集合$\bar{B}$与$B$具有互补关系。现将格结构$\langle{ P}(A),\cap,\cup\rangle$或$\langle P(A),\subseteq\rangle$上的补运算推广到一般的有界格中，得到如下有补格的概念：  
【定义12.33】设$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$是任意给定的一个有界格，则对$\forall a\in L$，如果存在$b\in$$L$，满足$a*b=0$ 且$a\oplus b=1$，则称$ b$是$a$的补元素，通常简称为补元，记作$\bar{a}$。如果有界格$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$中每个元素都存在其补元素，则称$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$为有补格。  
由格结构的交换律可知，如果$b$是$a$的补元，那么$a$也是$b$的补元，即$a$与$b$互为补元。易知，在有界格中， 0 的唯一补元是1，1 的唯一补元是0。但是，对于有界格中一般的元素，其补元不一定存在。因此，虽然有补格一定是有界格，但有界格不一定是有补格。  
另一方面，对于任个有补格，并不能保证其中每个元素的补元素是唯一确定的。例如，对于如图12-8 所示的有界格，易知$a$补元是$b$和$c$，$b$的补元是$a$和$c$，$c$的补元是$a$和$b$。  
![](images/15c8cb1c91d0343f4329e4fe28808131c9c2a9b35b96281ded4f82ad6ec628e1.jpg)  
有补格中元素补元的这种不唯一性容易造成对问题分析和求解的混淆。因此，必须对一般的有补格结构附加适当的约束条件，使其能够满足格中任意元素补元的唯一性。事实上，如果对有补格附加满足分配律的约束，这可保证其补元的唯一性，即有如下定理：  
【定理12.38】设$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$是一个有补格并且也是一个分配格，即是一个有补分配格，则$L$中任意元素的补元存在且唯一。  
从以上分析讨论可知：有补格仅保证了补元的普遍性，即格中任意一个元素都至少存在一个补元，但不能保证补元的唯一性；分配格则可以保证补元的唯一性但不能保证补元的普遍性；有补分配格同时吸收了有补格和分配格这两种特殊格的优点，能够同时保证补元的普遍性和唯一性。因此，有补分配格是一个具有优良性质的特殊格结构。事实上，有补分配格就是在计算机、电子信息、自动化等科学与工程中大量用到的布尔格或布尔代数。"
有补格,概念,"['第十二章 典型抽象代数结构', '§ 12.5 格的概念与性质', '12.5.3 常用特殊格结构']","{'实体类型': '概念', '定义': '每个元素都存在补元素的格', '条件': '对于任意a，存在b使得a*b=0且a⊕b=1', '特点': '补元不一定唯一', '定理': '有补分配格中补元存在且唯一'}",,3,"以上从偏序和代数这两个角度考察了格结构的基本概念和基本性质。如果对一般格结构赋予一些新的特征或约束条件，则可进一步得到相应的特殊格。本小节主要讨论若干重要的特殊格，主要包括分配格、有界格和有补格。  
一、分配格  
我们知道格结构的代数运算满足交换律、结合律和吸收律，但并没有要求其满足分配律。事实上，对于一般的格结构只能满足确界运算对偏序的分配不等式，这是一个以不等式形式出现分配形式，这只是一个弱分配律运算性质，如果将该性质加强为以等式形式构成真正意义上的分配律，由此便可得到一种名为分配格的特殊格结构，其具体定义如下：  
【定义12.31】设$\langle L,*,\oplus\rangle$是一个格，如果对于$\forall\ \ a,b,c\in L$，都有： $a*(b\oplus c)=(a*b)\oplus(a*c);\,\,\,a\oplus(b*c)=(a\oplus b)*(a\oplus c)$  
即运算满足分配律，则称$\langle L,*,\oplus\rangle$是一个分配格。  
值得注意的是，以上定义中两个式子其实是对偶式。因此，如要证明一个格是分配格只需证明上式中的任意一个等式即可。  
【定理12.34】设$\langle L,\leq\rangle$是任意给定的一个格结构，则$\langle L,\leq\rangle$是分配格当且仅当$\langle L,\leq\rangle$中即不存在与钻石格同构的子格，也不存在与五角格同构的子格  
【定理12.35】任意一条链都是一个分配格。  
消去律在格中一般不成立，但在分配格中具有如下一种特殊的消去律：  
【定理12.36】设$\langle L,*,\oplus\rangle$是任意给定的一个分配格，则对$\forall$$a,b,c\in L$$，如果a*b=a*c且$$a\oplus b=a\oplus c$，那么有$b=c$。  
二、有界格  
我们知道，格结构是一个偏序结构，如果在该结构的载体集合中引入存在最大值和最小值的约束条件，则可得到有界格的概念，具体如下：  
【定义12.32】设$\langle L,\leq\rangle$是任一给定的格，若$L$中存在最小元和最大元，即$\exists a,b\in L$，对∀ $x\in L$，有$a\leq x$且$x\leq b$，则称$\langle L,\leq\rangle$为有界格，通常将其最大元记为1，最小值记为0。 例如，设$𝑆$是一个非空集合，则格$\langle S,{\subseteq}\rangle$是一个有界格，其最大元是$𝑆$，最小元是$\varnothing$。并不是所有的格都是有界格，例如是实数集上的是小于或等于关系构成的格$<R,\leq\;>$，显然不是有界格。根据最小元和最大元以及幺元和零元的定义，易知成立下列等式：  
$1*x=x*1=x;1\oplus x=x\oplus1=1;0*x=x*0=0;0\oplus x=x\oplus0=x$  
也就是说1 是$*$和⊕的幺元与零元，0 是⊕和$*$的幺元和零元。  
【定理12.37】对于任意一个有界格$\langle L,\leq\rangle$，其最大值和最小值是唯一的。  
三、有补格  
对于格$\langle P(A),\subseteq\rangle$或$\langle{ P}(A),\cap,\cup\rangle$来说，集合$𝐴$和空集$\varnothing$显然是$P(A)$的最大元和最小元。我们知道，可在$\langle{ P}(A),\cap,\cup\rangle$上定义集合的补运算，即对于$\forall B\in P(A)$，存在${\bar{B}}\in P(A)$，满足：  
$$
B\cup\bar{B}=\ A;\ B\cap\bar{B}=\ \varnothing\quad\text{(12.5.9)}
$$  
通常称集合$\bar{B}$是集合$ B$的补集，或者称集合$\bar{B}$与$B$具有互补关系。现将格结构$\langle{ P}(A),\cap,\cup\rangle$或$\langle P(A),\subseteq\rangle$上的补运算推广到一般的有界格中，得到如下有补格的概念：  
【定义12.33】设$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$是任意给定的一个有界格，则对$\forall a\in L$，如果存在$b\in$$L$，满足$a*b=0$ 且$a\oplus b=1$，则称$ b$是$a$的补元素，通常简称为补元，记作$\bar{a}$。如果有界格$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$中每个元素都存在其补元素，则称$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$为有补格。  
由格结构的交换律可知，如果$b$是$a$的补元，那么$a$也是$b$的补元，即$a$与$b$互为补元。易知，在有界格中， 0 的唯一补元是1，1 的唯一补元是0。但是，对于有界格中一般的元素，其补元不一定存在。因此，虽然有补格一定是有界格，但有界格不一定是有补格。  
另一方面，对于任个有补格，并不能保证其中每个元素的补元素是唯一确定的。例如，对于如图12-8 所示的有界格，易知$a$补元是$b$和$c$，$b$的补元是$a$和$c$，$c$的补元是$a$和$b$。  
![](images/15c8cb1c91d0343f4329e4fe28808131c9c2a9b35b96281ded4f82ad6ec628e1.jpg)  
有补格中元素补元的这种不唯一性容易造成对问题分析和求解的混淆。因此，必须对一般的有补格结构附加适当的约束条件，使其能够满足格中任意元素补元的唯一性。事实上，如果对有补格附加满足分配律的约束，这可保证其补元的唯一性，即有如下定理：  
【定理12.38】设$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$是一个有补格并且也是一个分配格，即是一个有补分配格，则$L$中任意元素的补元存在且唯一。  
从以上分析讨论可知：有补格仅保证了补元的普遍性，即格中任意一个元素都至少存在一个补元，但不能保证补元的唯一性；分配格则可以保证补元的唯一性但不能保证补元的普遍性；有补分配格同时吸收了有补格和分配格这两种特殊格的优点，能够同时保证补元的普遍性和唯一性。因此，有补分配格是一个具有优良性质的特殊格结构。事实上，有补分配格就是在计算机、电子信息、自动化等科学与工程中大量用到的布尔格或布尔代数。"
有限m元重集的全排列数计算公式,定理,"['第一章  集合与计数基础', '§ 1.3 有限集的基本计数技术', '1.3.3 排列计数与组合计数', '二、可重复的排列']","{'实体类型': '定理', '内容': '假设{n1·a1,n2·a2,⋯,nm·am}是任意一个给定的含有n个元素的有限m元重集，从该重集中依次取出n个元素的全排列数为n!/(n1!·n2!·⋯·nm!)'}",,4,"现考察这样一个问题：用1、2、3 这3 个数字可以构成多少种不同的5 位数字？  
使用乘法原理不难知道该问题解为$\ 13^{5}=243$种。这显然是一个元素可以重复的排列问题，现具体讨论这类问题。我们知道，在经典集合论中，集合中元素是不可重复的。为解决集合中重复元素的表示问题，现引入重集的概念。与集合的概念一样，重集也是一个没有具体定义的原始概念，只有通过如下方式对其含义进行描述或理解：  
所谓重集，就是在指定范围内满足给定条件、且允许多个相同对象同时出现的所有对象构成的总体，重集中每个对象仍然称为该集合的元素，重集中相同元素的个数称为元素的重数。具体地说，如果一个重集中含有 $\cdot_{n_{1}}$ 个 $\cdot a_{1}$ ， $n_{2}$ 个 $a_{2}$ ， ⋯ ， $n_{m}$ 个 $a_{m}$ ，且 $n_{1}+n_{2}+\cdots+n_{m}=$ $n$，则称该重集为含有$n$个元素的$m$元重集，记为：$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}.$。  
约定：$\infty\cdot a$表示元素$a$可在重集中出现任意多次；$\{\infty\cdot a_{1},\infty\cdot a_{2},\cdots,\infty\cdot a_{m}\}$则表示重集中所有元素均可出现任意多次，称其为无穷重$\pmb{m}$ 元重集。  
事实上，可将$m$ 元重集看成是由$m$ 个容器组成的容器组，其中第一个容器可以放入（或取出）$n_{1}$个元素$a_{1}$，第二个容器可以放入（或取出）$n_{2}$个元素$a_{2}$，…，第$m$个容器可以放入（或取出）$n_{m}$个元素$a_{m}$.对于$\infty\cdot a$，则可将其理解为可以放入（或取出）无穷多个元素$a$的容器.需要注意的是，通常认为重集不是集合，但可将集合看成是重集的特例。  
显然，用1、2、3 这个数字构成5 位数字，就是一个无穷重3 元重集中取出5 个元素的排列问题。一般地，这种重集排列问题或可重复排列问题的定义如下：  
【定义1.24】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的重集，从该重集中依次取出$r$ 个元素并将其按取出的次序排成一排，由此形成的一个有序排列称之为可重复$r$-排列，可重复$r\mathbf{\cdot}$-排列的个数称为可重复$r$-排列数；令$\cdot n_{1}+n_{2}+\cdots n_{m}=n$，则称$\cdot r=n$时构成的排列称为全排列，$r<n$时构成的排列为选排列。  
通过乘法原理不难得到如下无穷重$m$ 元重集的可重复$r\mathbf{\cdot}$-排列数计算公式  
【定理1.16】假设$\{\infty\cdot a_{1},\infty\cdot a_{2},\cdots,\infty\cdot a_{m}\}$是任意一个给定的无穷重$m$ 元重集，该重集下可重复$r$-排列数为$m^{r}$。  
【证明】无穷重数$m$ 元重集$\{\infty\cdot a_{1}$，$\infty\cdot a_{2}$，⋯，$\infty\cdot a_{m}\}$ $r$-排列的每一个位置上，均有$m$  种选择方案，故而 $r$ - 排列数为 $\ \ \cdot m^{r}$ 。□  
【例题1.57】（1）用7 颗六彩珠串成长链，可串出多少种不同长链（假定六彩珠取之不尽，且不考虑链子的反转）？（2）至少用两种颜色的六彩珠串成7 珠环链，求环链的种数（假定六彩的珠子取之不尽，且不考虑链子的反转）？  
![](images/3f1e76f81dba91759e05f5e7aace97377518f23c7e8ea20e34523f4359261b28.jpg)
图1-8 4-圆排列  
有穷集$m$ 元重集上可重复$r\mathbf{\cdot}$-排列数的计算是一个比较复杂的问题，有兴趣的同学可以查阅相关资料，不再赘述。在此仅考虑如下比较简单的全排列数的计算问题：  
【定理1.17】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的含有$n$ 个元素的有限$m$元重集，从该重集中依次取出$n$ 个元素的全排列数为：  
$$
\frac{n!}{n_{1}!\cdot n_{2}!\cdot\dots\cdot n_{m}!}
$$  
【例题1.58】EXCELLENT 单词含有9 个字母，若重新排序字母顺序，请问能构成多少个不同字符串？"
有限群,概念,"['第十二章 典型抽象代数结构', '§ 12.2 群结构的基本知识', '12.2.1 群的基本概念']","{'实体类型': '概念', '定义': '设⟨G,*⟩是任意给定的一个群，称|G|为⟨G,*⟩的阶，如果|G|为有限数，则称⟨G,*⟩为有限群'}",,3,"如前所述，群代数结构是对幺半群结构在逆元方面的进一步扩充，其具体定义如下：  
【定义12.8】假设$\langle G,*\rangle$是任意给定的一个二元代数结构，如果$\langle G,*\rangle$满足如下性质：  
（1）结合律：对于$\forall x,y,z\in G$，成立：$(x\ \ *y)*z=x\ \ *(y*z)$；  
（2）含单位元：$\exists e\in G$，使得对于$\forall x\in G$，成立$\,\!e*x=x*e=x$；  
（3）运算$*$可逆：对于$\forall x\in G$，都存在$x^{-1}\in G$，使得$x^{-1}*x=x*x^{-1}=e$。  
则称$\langle G,*\rangle$是一个群代数结构，简称为群结构或群。  
从上述定义可知，对于任意给定的非空集合 $G$ 以及该集合上某个二元运算 $*$ ，$\langle G,*\rangle$ 能够 形成一个群结构的充分必要条件是$\langle G,*\rangle$必须满足封闭性、结合律、含幺性和可逆性这四个基本运算性质。例如，对于实数集合及其上的普通加法运算构成的代数结构$\langle R,+\rangle$，显然满足群的四条基本性质，其中0 是其单位元，对于$\forall x\in R$，$-x$是$x$的逆元。但是，对于实数集合及其上的普通乘法运算构成的代数结构$\langle R,\times\rangle$则不是一个群，因为在$\langle R,\times\rangle$中0 没有逆元素。不难发现，对于任意给定的集合$𝐴$，$\langle{ P}(A),\cup\rangle$和$\langle{ P}(A),\cap\rangle$都不能构成群结构，因为在$\langle{ P}(A),\cup\rangle$中$𝐴$没有逆元，在$\langle{P}(A),\cap\rangle$中$\varnothing$没有逆元。  
【定义12.9】设$\langle G,*\rangle$是任意给定的一个群，称$|G|$为$\langle G,*\rangle$的阶，如果$|G|$为有限数，则称  
$\langle G,*\rangle$为有限群，否则$\langle G,*\rangle$为无限群。如果运算$^*$满足交换律，即对于$\forall x,y\in G$，有$x*y=y*$$x$则称群$\langle G,*\rangle$是一个交换群或阿贝尔群。  
【定理12.3】设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$的单位元是$\langle G,*\rangle$中唯一的一个幂等元，若$|G|>1$，则$\langle G,*\rangle$中无零元且满足消去律。  
下面的定理12.2.2 给出了群中逆元素的基本性质：  
【定理12.4】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，有：  
$$
(a^{-1})^{-1}=a\,\exists(a*b)^{-1}=b^{-1}*a^{-1}
$$  
下面的定理12.5 给出了群与方程可解性之间的关系：  
【定理12.5】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，方程$a\circ x=b$和$y\circ a=$$b$在$\langle G,*\rangle$中有且仅有唯一解。  
由于群结构满足结合律，故可类似于半群和含幺半群定义元素的方幂：  
【定义12.10】设$\langle G,*\rangle$是任意给定的一个群，对于$\forall a\in G$和正整数$ n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$ a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个a}
$$  
定义$a^{0}=e$且$a^{-n}=(a^{-1})^{n}$  
从上述定义可以看出，对于一个群结构$\langle G,*\rangle$可以定义其任意整数的方幂运算，包括负指数方幂。因此，对于$G$中的任何一个元素$a$，均可以通过其正方幂、零方幂和负方幂构成一个向胜负两端无限延伸的序列，具体如下：  
$$
\cdots,a^{-n},\cdots,a^{-2},a^{-1},a^{0}\ \ ,a^{1},a^{2},\cdots,a^{n},\cdots
$$  
这些序列显然满足幂的运算法则，即对于任意整数$n$和$m$，有：  
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
如果$\langle G,*\rangle$是一个有限群$\langle G,*\rangle$，则根据运算的封闭性和鸽笼原理易知，在$G$中任意一个元素的无穷多个方幂中，必然至少有两个是相等的。具体地说，对于任意给定的$G$中某个元素$a$，必然存在两个不相等的整数$m$和$|n$，不妨设$m<n$，满足：  
$$
a^n=a^m\text{或}a^{n-m}=e
$$  
此时，可将正整数$n-m$看成是元素$a$方幂变化的一个周期。一般地，有如下定义：  
【定义12.11】设$\langle G,*\rangle$是任意给定的一个群，$e$是该群的单位元，对于$G$中任意给定的某个元素$a$，如果存在正整数$n$，满足$a^{n}=e$，则其中最小的正整数称为元素$a$的周期或阶，记为$|a|$，否则称元素$a$的周期为无限大或元素$a$的阶为无限大。  
例如，对于群$\langle\underline{{6}},+_{6}\rangle$，元素1 的阶为6，元素2 的阶为3，元素3 的阶为2，元素4 的阶为3，元素5 的阶为6，元素0 的阶为1。对于整数集合上的加法群$\langle Z,+\rangle$，显然，除了元素0 的周期为1 之外，其余任一非零元素的周期均为无穷大。事实上，不难看出，对于任何一个群，有且只有其单位元的阶为1。  
下面给出关于元素阶的两个重要性质：  
【定理12.6】有限群$\langle G,*\rangle$的每个元素都有有限阶，且其阶数不超过群的阶数|G|。  
【定理12.7】设$\langle G,*\rangle$为群，$G$中元素$a$的阶为$ k$，那么$a^{n}=e$当且仅当$k$整除$ n$  。"
有限集,概念,"['1.1.2 集合的概念与表示', '2.有限集与无限集', '四、常用的特殊集合', '§ 1.1 集合的基本知识', '第一章  集合与计数基础']","{'实体类型': '概念', '特点': '具有特殊性质, 有限集中元素的个数是有限的', '定义': '对于任意给定的集合A，如果它的基数是一个有限数，则称该集合是一个有限集'}",,4,集合论中有一些非常重要和常用的特殊集合，它们分别具有一些特殊性质。离散数学中很多基本概念的定义及其性质讨论都离不开它们。下面具体介绍这些特殊集合的基本概念及性质，包括空集、全集、有限集、无限集、子集、幂集等。
有限集合,概念,"['第一章  集合与计数基础', '§ 1.1 集合的基本知识', '1.1.2 集合的概念与表示', '四、常用的特殊集合', '3.有限子集与幂集']","{'实体类型': '概念', '定义': '含有n个元素的集合称为n元集合', '特点': '可以构造出相关的子集并对子集进行计数'}",,5,"对于有限集合，我们可以构造出相关的子集并对子集进行计数，具体定义如下：  
【定义1.8】设$A$ 是任一有限集合，若$A$ 中含有$n$ 个元素，即有$\left|A\right|{=}n$，则称$A$ 为$n$ 元集合。对于$A$ 的任意一个子集$B$，若$B$ 中含有$m$ 个元素，则称$B$ 为$A$ 的$m$ 元子集。  
也就是说：$n$ 元集合共有$2^{n}$个不同的子集。  
事实上，对于任意一个集合$A$，还可以将其每个子集分别作为一个元素构成一个新的集合，由此得到如下幂集的概念：  
【定义1.9】假设$A$ 任意一个给定的集合，以$A$ 的所有不同子集为元素构成的集合称为$A$ 的幂集，记为$P(A)$或$2^{A}$，即有：  
$$
P(A)=\{B|B\subseteq A\}
$$  
对于以集合作为元素的集合，亦即集合的集合，通常称之为集族。由此可知，幂集其实就是一种特殊的集族。"
有限集的基本计数技术,概念,"['第一章  集合与计数基础', '§ 1.3 有限集的基本计数技术']","{'实体类型': '概念', '定义': '统计有限集中元素个数的技巧或技术', '应用': '在计算机问题求解或算法设计中具有基础性的重要作用', '分类': '基本计数技术和高级计数技术', '具体内容': '加法原理与乘法原理、容斥原理与鸽笼原理、排列计数与组合计数'}",,2,现考察有限集的度量问题，度量有限集的目标是要统计出集合中元素的个数。当集合不是以枚举方式出现时，对元素个数的统计有时就不一定是显然的，需要一些相关技巧或技术，称之为计数技术。有限集合的计数技术在计算机问题求解或算法设计中具有基础性的重要作用。例如对于算法设计来说，如果要设计出问题求解的有效算法，很多情况下需要计算或估算出解空间或状态空间大小规模。事实上，这些解空间就是一些有限集合，度量这些有限集的大小就需要对其进行计数。目前，计数技术可大致分为基本计数技术和高级计数技术这两种基本类型，本节主要学习若干基本计数技术，具体包括加法原理与乘法原理、容斥原理与鸽笼原理、排列计数与组合计数。
有限集的置换函数,概念,"['7.5.2 宽带分配问题', '第七章 函数与特殊函数', '§ 7.4 有限集的置换函数']","{'实体类型': '概念', '定义': ['有限集上的双射函数，实际上是有限集上所有元素的一个全排列', '研究有限集上元素置换的函数'], '性质': '有限集上的单射必是满射，满射也必是单射', '基本类型': '双射函数和既非单射也非满射的函数', '讨论内容': '基本概念、运算性质、轮换分解'}",,2,有限集上的函数是一类很特别的函数，具有很多非常重要而有趣的性质。如前所述，有限集$𝐴$上的单射必是满射，满射也必是单射。因此，有限集$𝐴$上的函数只有两种基本类型，一 种是双射函数，另外一种则为既非单射也非满射的函数。不难看出，有限集$𝐴$上双射函数其实就是$𝐴$上所有元素的一个全排列，因此，有限集$𝐴$上双射函数也称为置换函数。本节主要讨论有限集$𝐴$上双射函数的概念与关系运算性质，包括置换函数的基本概念、置换函数的运算性质、置换函数的轮换分解。
机器学习,概念,"['第八章  图的基本理论与算法', '§ 8.5 图模型的应用', '8.5.3 机器学习问题']","{'实体类型': '概念', '定义': '数学模型或求解算法中具有似于人类的学习机制，能够从实际问题中采集适当样本数据，根据样本数据自动算出参数值，并随着样本数据的变化自动调整参数取值，使得数学模型和求解算法具有良好的普适性和自适应性', '应用': '图像识别、语音识别、自然语言理解等领域', '特点': '经历了浅层学习和深度学习两次浪潮'}",,3,"1959 年，美国塞缪尔教授设计了一个具有学习能力的下棋程序。它可在不断对弈中改善自己的棋艺。4 年后，该程序战胜了设计者本人。又过3 年，该程序战胜了美国常胜冠军。由此可以看出机器学习的能力，特别是当下谷歌设计的AlphaGo 程序与围棋大师李世石的围棋大战，更是体现了机器学习的威力。所谓机器学习，就是数学模型或求解算法中具有似于人类的学习机制，能够从实际问题中采集适当样本数据，根据样本数据自动算出参数值，并随着样本数据的变化自动调整参数取值，使得数学模型和求解算法具有良好的普适性和自适应性。按机器学习的模型结构层次来分，机器学习经历了两次浪潮，分别是浅层学习和深度学习。近年来，机器学习的概念异常火爆，各种机器学习算法层出不穷。本小节简要介绍图模型在浅层学习和深度学习中的与应用。  
![图8-73 BP 网络结构](images/3e28bfeab67aaebdd2a54ed46ef1bb594380bb5384ccdde94e5e1d5ae51f9049.jpg)  
![图8-74 支持向量机结构](images/0d16cdb37dc68fb29e3b36be467fd837d3d52e2ccd7acbba9de1c8c373e6974d.jpg)  
无论是浅层学习还是深度学习的模型结构都是基于图模型。  图8-73 所示的图模型是20 世纪80 年代末期提出BP 神经网络模型，图8-74 所示的图模型是20 世纪90 年代中期提出支持向量机模型。 这些都是机器学习中的经典图模型用于浅层的机器学习。 正是这些图模型的建立给机器学习带来了希望，掀起了基于统计模型机器学习热潮。人们使用这类权图模型从大量训练样本中学习统计规律，然后根据学到的规律对未知事件进行预测。  
![图8-75 简单函数对复杂函数的逼近 ](images/fbe962cff1ffa6a7bb0339da768141046705e07e74feba559a3752dfe9c241b2.jpg)  
![图8-76 多层模型表示复杂函数  ](images/272fe3358ea6997e106f1355c74465d9d8b3888427cf64765b441f271abcfeac.jpg)  
然而，进入21 世纪，浅层学习研究的发展遇到瓶颈。从而，人们创立了深度学习的相关概念和理论，并借助分布式云计算的大数据平台，在机器学习领域取得了突破性进展。深度学习通过一种深层非线性网络结构，组合低层特征形成更加抽象的高层表示属性类别或特征，实现由简单函数向复杂函数的有效逼近，以发现数据的分布式特征表示。其具有强大的从少数样本中集中学习数据集本质特征的能力。图8-75 表示一个通过简单函数逼近复杂函数的实例。  
简单地说，深度学习就是对拥有深层结构的模型进行训练。所谓深层结构，是相对于前述的浅层结构而言的，两者的差异主要在于拥有的非线性运算单元的层数不同。深层结构是指非线性转换单元的层数大于或等于两层的模型，而使用多层模型的优势即可以使用较少的参数表示复杂的函数。使用多层模型表示复杂函数的例子如图8-76 所示。  
![图8-77 含多隐含层的深度学习模型图  ](images/a696f4639cd9bb8eadcb3b542d30322c2127fff383c01a8ce40760e85d44b787.jpg)  
![图8-78 自动编码器(AE)结构示意图  ](images/d437ba8ccbf4e13b83ff799a9ddec1778e03cc7629e09224d02fe81a54b359de.jpg)  
深度学习在模型中构建多层隐含层，并通过大量样本训练模型参数，获得更有用的特征，从而有效提升分类或预测的准确性。相比较传统的浅层结构，深度学习更强调了模型结构的深度，通常有5 至6 层隐含层，有的模型结构甚至包含10 层以上隐含层。此外，深度学习明确突出了特征学习的重要性。深度学习实现多层堆叠，每一层的输出作为下一层的输入，高层的特征是低层特征的组合，从低层到高层的特征表示越来越抽象，越来越能表现语义或者意图。而抽象层面越高，存在的可能猜测就越少，就越利于分类。换句话说，深度学习通过逐层特征变换，将样本在原始特征空间表示逐层变换到新的特征空间，从而使分类或预测的效果更加准确。图8-77 表示一个含多隐含层的深度学习模型。事实上，由如图8-78 所示自动编码器组合或其简单变形的模型也可看成是深度结构，例如堆叠自动编码器，稀疏自动编码器等。  
深度学习是机器学习发展的产物。与传统的机器学习方法相比，深度学习优势明显，目前在图像识别、语音识别、自然语言理解等领域得到广泛的应用。"
极小完备联结词集合,概念,"['第三章  命题演算与推理', '§ 3.3 联结词的完备集', '3.3.2 联结词的完备性']","{'实体类型': '概念', '定义': '假设𝑆是一个任意给定的联结词的完备集，从𝑆中任意删除一个联结词后得到新的联结词集合$S^{*}$，则$S^{*}$不是联结词的完备集，也就是说，至少有一个命题公式不能等价于由$S^{*}$中联结词表示的任一公式，此时称𝑆是一个极小完备联结词集合', '特点': '不包含冗余联结词'}",,3,"现在我们进一步考察联结词的表示功能的完备性问题，即至少需要多少种运算联结词才能表示任意命题公式？首先给出如下联结词功能完备集的概念：  
【定义3.18】假设𝑆是一个由逻辑运算联结词组成的集合，如果对于任意一个命题公式，都有由𝑆中联结词表示出来的命题公式与之等值，则称𝑆是一个完备的联结词集合，或者说𝑆是一个联结词的完备集。  
由联结词的枚举可知联结词的数量或种类有很多，其实不难发现其中有很多联结词之间是可以互推的，或者说可以相互表示。因此，对于一个联结词的完备集，其中可能会存在联结词的冗余，有时需要消除这种冗余，故有如下极小完备联结词集合的概念：  
【定义3.19】假设𝑆是一个任意给定的联结词的完备集，从𝑆中任意删除一个联结词后得到新的联结词集合$\boldsymbol{\cdot}\boldsymbol{S}^{*}$，则$S^{*}$不是联结词的完备集，也就是说，至少有一个命题公式不能等价于由$S^{*}$中联结词表示的任一公式，此时称𝑆是一个极小完备联结词集合。  
通常都需要选用适当的联结词完备集以更加方便地进行命题公式演算。由于命题公式的归纳定义仅涉及一元联结词和二元联结词，故仅需考察由一元联结词和二元联结词为元素组成的联结词集合。下面给出一些重要的联结词完备集：  
由于：$P\rightarrow Q\Leftrightarrow\neg P\rightarrow Q,\,\,\,P\leftrightarrow Q\Leftrightarrow(\neg P\lor Q)\land(\neg Q\lor P),\,\,\,P\land Q\Leftrightarrow\neg(\neg P\lor\neg Q)$。所以$\{\neg,\ \vee\}$可构成极小完备集，同理$\{\neg,\ \land\}$也可以构成极小完备集。  
由于：$P\vee Q\Leftrightarrow\neg P\rightarrow Q， \Rightarrow\neg P\to Q\ ,\ \ P\land Q\Leftrightarrow\neg(\neg P\lor\neg Q)\Leftrightarrow\neg(P\to\neg Q)\ ,\ \ P\leftrightarrow Q\Leftrightarrow(P\to Q)\land$  
$(Q\rightarrow P)$。所以$\{\neg,\ \ \rightarrow\}$可以构成极小完备集。  
由于$P\land Q\Leftrightarrow\neg(\neg P\lor\neg Q)\Leftrightarrow\neg(P\to\neg Q)\Leftrightarrow P\nRightarrow\neg Q$，故$\{\neg,\quad\nrightarrow\}$可构成极小完备集。  
由于$\neg P\Leftrightarrow\neg(P\land P)\Leftrightarrow P\uparrow P,$，$P\land Q\Leftrightarrow\neg\neg(P\land Q)\Leftrightarrow\neg\ P\uparrow Q$，故{↑}可构成极小完备集。同理，$\{\downarrow\}$可构成极小完备集。↑和↓在大规模集成电路中具有广泛应用。  
由以上的分析可知， $\{\neg,\ \ \vee\},\ \{\neg,\ \ \wedge\},\ \{\neg,\ \ \rightarrow\},\ \ \{\neg,\ \ \nrightarrow\},\ \ \{\uparrow\} \},$都是极小完备集，$\left\{\neg,\ \ \lor\ ,\ \ \land\right\}$是一个完备的联结词集合。但是$\{\lor\},\ \{\land\},\ \{\lor,\ \land\}$等都不是极小完备集"
极小项,概念,"['第十二章 典型抽象代数结构', '§ 12.6 布尔代数基础', '12.6.3 布尔表达式与函数']","{'实体类型': '概念', '定义': '由n个布尔变元构成的特定布尔表达式', '性质': '具有特定运算性质，如m_i * m_j = 0 (i ≠ j)'}",,3,"我们知道，无论是命题代数还是集合代数都可以通过相应的表达式进行计算，集合代数有集合运算表示式，命题代数有命题表达式或命题公式，事实上，可以从更加抽象的布尔代数的角度考察这些运算表达式，或者说可以将这些具体的运算表达式抽象成一般的布尔表达式研究其共同运算性质。由此得到布尔表达式的概念，具体定义如下：  
【定义12.38】设$\langle B,*,\oplus,^{-},0,1\rangle$是任意给定的一个布尔代数，则集合$ B$中的元素称为布尔常元，取值于$ B$中元素的变元称为布尔变元。  
与命题代数类似，使用归纳的方法定义布尔表达式：  
【定义12.39】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数，则 $B$上布尔表达式定义如下：  
（1）$B$中的任何一个布尔常元是布尔表达式；  
（2）$B$中的任何一个布尔变元是布尔表达式；  
（3）如果$e_{1}$和$e_{2}$是布尔表达式，则$\overline{{e_{1}}}$ ，$e_{1}*e_{2}$，$e_{1}\oplus e_{2}$也是布尔表达式；  
（4）只有有限次使用（1）、（2）和（3）所构造的符号串才是布尔表达式。  
【定义12.40】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数，$B$中含有${n}$个相异布尔变元的布尔表达式称为$\mathbf{n}$元布尔表达式，记为$f(x_{1},x_{2},\cdots,x_{n})$，其中$x_{1},x_{2},\cdots,x_{n}$是布尔变元。布尔表达式的值是指将$B$中的布尔常元作为布尔变元$x_{i}(i=1,2,\cdots,n)$的值来代替布尔表达式中相应的布尔变元，而计算出的布尔表达式的值。  
例如，表达式$f(x,y)=(a*x)\oplus({\bar{b}}\oplus y)\oplus(x\oplus{\bar{y}})$是布尔代数$\langle\lbrace0,a,b,1\rbrace,*,\oplus,^{-},0,1\rangle$上的二元布尔表达式。如果对该表达式中布尔变元$x,y$赋初值为$x=a,y=b$，则可得到：  
$$
f(a,b)=(a*a)\oplus\left({\bar{b}}\oplus b\right)\oplus\left(a\oplus{\bar{b}}\right)=a\oplus1\oplus\left(a\oplus{\bar{b}}\right)=1
$$  
【定义12.41】设$f_{1}(x_{1},x_{2},\cdots,x_{n})$和$f_{2}(x_{1},x_{2},\cdots,x_{n})$是$\langle B,*,\oplus,^{-},0,1\rangle$上的两个布尔表达式，如果对${x_{i}}$任意的赋值即$x_{i}=b_{i},b_{i}\in B,(i=1,2,\cdots,n)$均有：  
$$
f_{1}(b_{1},b_{2},\cdots,b_{n})=f_{2}(b_{1},b_{2},\cdots,b_{n})\quad\text{(12-26)}
$$  
则称这两个布尔表达式为等价或等值，记为$f_{1}(x_{1},x_{2},\cdots,x_{n})=f_{2}(x_{1},x_{2},\cdots,x_{n})\,。$  
如果要验证两个布尔表达式是等价的，一般情况下可以采取如下两种方法：一种是直接验证，另外一种是利用布尔代数的运算律进行有限次的推导。例如，对于$\langle B,*,\oplus,^{-},0,1\rangle$上两个布尔表达式：  
$$
f_{1}(x_{1},x_{2},x_{3})=x_{1}*(x_{2}\oplus x_{3}),\;\;f_{2}(x_{1},x_{2},x_{3})=(x_{1}*x_{2})\oplus(x_{1}*x_{3})
$$  
对于$\forall x_{i}=b_{i},b_{i}\in B,(i=1,2,3)$，可以直接验证$f_{1}(x_{1},x_{2},x_{3})=f_{2}(x_{1},x_{2},x_{3})$。也可以利用分配律验证其等价性。这与命题逻辑中的真值表法和演算法非常类似。  
对于布尔代数$\langle B,*,\oplus,^{-},0,1\rangle$上任意一个布尔表达式$f(x_{1},x_{2},\cdots,x_{n})$，由于运算${*,\bigoplus,^{-}}$在$B$上封闭，故对于$\langle x_{1},x_{2},\cdots,x_{n}\rangle$的任何赋值$\langle b_{1},b_{2},\cdots,b_{n}\rangle,b_{i}\in B$，有$f(b_{1},b_{2},\cdots,b_{n})\in B$。这表明$f(x_{1},x_{2},\cdots,x_{n})$确定了一个从$B^{n}$到$B$的函数。据此引入如下布尔函数的概念：  
【定义12.42】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数，$f$为一个从$B^{n}$到$B$的函数，如果它能够用$\langle B,*,\oplus,^{-},0,1\rangle$上的$n$元布尔表达式表示，则称该函数为布尔函数。  
对于任意一个给定的布尔函数，如何确定其所对应的布尔表达式呢？现在就来讨论这个问题，首先给出如下布尔表达式极小项的定义  
【定义12.43】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数，给定$n$个布尔变元$x_{1},x_{2},\cdots,x_{n}$，表达式$\widetilde{x}_{1}*\widetilde{x}_{2}*\widetilde{x}_{3}*\cdots*\widetilde{x}_{n}$称为极小项，其中$\tilde{x}_{i}$表示$ x_{i}$或$\overline{{x_{\iota}}}$。  
例如，对于两个布尔变元$x_{1},x_{2}$，其极小项为$x_{1}*x_{2}\,,\ \bar{x}_{1}*x_{2}\,,\ x_{1}*\bar{x}_{2}$和${x}_{1}*{x}_{2}$  。  
容易验证$n$个布尔变元可以构成$\ 2^{n}$个不同的极小项，分别记为$m_{0},m_{1},m_{2},\cdots,m_{2^{n}-1}$，其中下标是二进制数$a_{1}a_{2}\cdots a_{n}$对应的十进制数，其中：  
$$
a_i=\begin{cases}1,&\text{当}\widetilde{x_i}=x_i\text{时}\\0,&\text{当}\widetilde{x_i}=\bar{x_i}\text{时}\end{cases}(i=1, 2, \cdots, n)
$$  
具体可表述为：  
$m_{0}={\bar{x}}_{1}*{\bar{x}}_{2}*\cdots*{\bar{x}}_{n},\quad m_{1}={\bar{x}}_{1}*{\bar{x}}_{2}*\cdots*{\bar{x}}_{n-1}*x_{n},\ \cdots,\quad m_{n}=x_{1}*x_{2}*\cdots*x_{n}$ 不难验证极小项具有如下两个基本性质：  
（1）$m_{i}*m_{j}=0$，当$i\neq j$时；（2）$m_{0}\oplus m_{1}\oplus m_{2}\oplus\cdots\oplus m_{2^{n}-1}=1\,$。  
【定义12.44】设$<\mathrm{B},*,\oplus,\stackrel{\_}{\ },0,1>$布尔代数，称形如：
$$
(\,\alpha_{0}*m_{0}\,)\,\oplus(\alpha_{1}*m_{1})\oplus(\alpha_{2}*m_{2})\oplus\cdots\oplus(\alpha_{2^{n}-1}\oplus m_{2^{n}-1})
$$  
的布尔表达式成为主析取范式，这里$\alpha_{i}$是布尔常元，$m_{i}$是极小项$(i=1,\!2,\!\cdots,2^{n}-1)$.  
因为每个$\alpha_{i}$有$|B|$种取法，故具有$n$个布尔变元的不同主析取范式共有$|\mathrm{B}|^{2^{n}}$个，当$B=${0,1}时有$2^{2^{n}}$个。而$2^{n}$个极小项最多只能构造出$|\mathbf{B}|^{2^{n}}$个不同的主析取范式，所以一个$\mathsf{n}$ 元布尔表达式必等价于这$|\mathbf{B}|^{2^{n}}$个主析取范式之一。又由于任何两个不同的主析取范式显然是不等价的，所以一个n 元布尔表达式都唯一等价于一个主析取范式。可将${ n}$元布尔表达式化成等价的主析取范式，方法与将命题公式换成主析取范式的方法完全一致。  
对于任意给定的一个$ n$元布尔表达式，其${n}$个布尔变元的每一指派，都可确定该表达式在集合B中的一个取值，故每个布尔表达式都代表一个布尔函数。由于$n$个布尔变元的主析取范式最多只有$|\mathrm{B}|^{2^{n}}$个，故布尔表达式最多只能表示$|\mathrm{B}|^{2^{n}}$个不同函数。$B=\{0,1\}$时，从$B^{n}$到$B$的函数共有$2^{2^{n}}$个，主析取范式也有$2^{2^{n}}$个，恰好每一个主析取范式代表一个布尔函数，此时每个函数均可用布尔表达式表示。  
可用同样方法讨论极大项和主合取范式，不再赘述。
![](images/d9aea4daa121e3eccc7b12420a8fb81447c40edfd8e103d7c7a3a0401f26dc77.jpg)  
图 12-14 离散数学的知识体系  
从上述分析讨论不难看出，布尔表达式和布尔函数的运算性质与命题代数的演算基本上相同。因此，可将布尔代数看成是命题代数的一个抽象，将命题代数看成是布尔代数的一个具体实例。事实上，集合代数也是布尔代数的一个具体实例。如图12-14 所示，集合代数和命题（逻辑）代数作为一种理论基础共同支撑了离散数学结构的整个知识体系，同时两者又在抽象布尔代数的层次上实现了完美的统一。"
极限理论,原理,"['第一章  集合与计数基础', '§ 1.1 集合的基本知识', '1.1.1 数学危机与集合论']","{'实体类型': '原理', '作用': '解决希帕索斯悖论、贝克莱悖论问题', '基础': '为实数理论和微积分的正确性奠定基础'}",,3,"众所周知，数学是整个自然科学体系的基础，人们对自然界的认识结论一般需要通过数学演算或数学证明来保证其正确性。打铁还需自身硬，从理论上说，数学既然能够作为一种可以鉴别认识结论真伪的基本工具，那么其自身就不应该有任何错误或矛盾。但实际情况并没有这么简单，千百年来陆续出现的希帕索斯悖论、贝克莱悖论、理发师悖论，使得数学理论的正确性面临一次又一次严峻挑战，历史上称之为数学危机。为拯救数学于危机之中，捍卫数学理论的正确性，无数杰出科学家做了大量深入系统的研究工作。直到在十九世纪初，柯西、维尔斯特拉斯等数学家通过创立极限理论，终于解决了希帕索斯悖论、贝克莱悖论问题，为实数理论和微积分的正确性奠定了坚实的基础。  
但是，极限理论在逻辑上还有需要完善的地方.因为极限概念由自然数定义，要保证极限理论的正确性，首先必须要保证自然数概念及相关理论的正确性。虽然自然数是大家熟知且常用的一个基本概念，大家从小学就开始学习自然数的计数和运算，但是对自然数概念的理解主要还是依靠经验。为保证极限理论的正确性，必须对自然数进行正式的数学定义。数学家冯·诺依曼用集合的方式定义了自然数并取得成功。由此，对整个数学理论体系正确性和无矛盾性的论证就转化为对集合论的正确性和无矛盾性的论证，集合论成为整个数学大厦的根基。尽管卢素提出理发师悖论指出了集合论的局限性，一度动摇了这个根基，但是有惊无险，策莫罗提出的公理化集合论有效解决了理发师悖论问题，不仅稳定了数学根基，而且进一步确立了集合论在整个数学大厦中的基础地位。集合论被誉为十九世纪最伟大的数学成就，集合论的创始人康托被誉为整个十九世纪最伟大的数学家，没有之一。"
析取,运算,"['第三章  命题演算与推理', '§ 3.1 命题的概念与运算', '3.1.3  命题的常用联结词', '二、合取与析取联结词']","{'实体类型': '运算', '定义': '表示两个命题中至少有一个为真的逻辑运算', '特点': '记作P∨Q，当且仅当P和Q中至少有一个为真时取值为真'}",,4,"对于任意两个命题，有时需要构造一个新的复合命题表示这两个命题同时为真的含义，相当于自然语言中“与”或“并且”的意思，由此得到的逻辑运算称为命题的“合取”运算或者“与”运算。该运算及其逻辑联结词的具体定义如下：  
【定义3.3】设 $P$ 、$Q$ 是任意两个命题，复合命题$^{\prime\prime}P$并且 $Q$ ”称为 $P$ 与 $Q$ 的合取式或与运算，记作 $P\land Q$，其中符号$\wedge$称为合取联结词(简称为合取词)。 $P\land Q$的取值为真，当且仅当 $P$ 和$Q$ 同时为真；或者说$P$ ∧𝑄 的取值为假，当且仅当 $P$ 和 $Q$ 至少有一个为假。  
例如，若令$\cdot P$表示“我喜欢唱歌”， $Q$ 表示“我喜欢跳舞”，则合取式 $P\land Q$ 就表示复合命题“我喜欢唱歌并且喜欢跳舞”。  
对于任意两个命题 $P$ 和 $Q$ ，其合取运算 $P\land Q$的真值取值规定如表3-1 第5 列所示。  
有时需要构造一个复合命题表示两个命题中至少有一个为真的含义，相当于自然语言中“可兼或”的意思，由此得到的逻辑运算称为命题的“析取”运算或者“可兼或”运算。所谓可兼或，就是可两者兼得的或。该运算及其逻辑联结词的具体定义如下：  
【定义 3.4 】设   $P、 Q$   是任意给定的两个命题，复合命题 $^{\prime\prime}P$   或 $\textit{Q}\,^{\prime\prime}$ 称为   $P$ 与   $Q$   的析取 式或者可兼或运算，有时简称为或运算，记作 $P\lor Q$ ，其中符号$\vee$称为析取联结词(简称为析取词 ) 。 $P\lor Q$   的取值为真，当且仅当   $P$   和   $Q$   中至少有一个为真；或者说 $P\lor Q$   的取值 为假，当且仅当 $P$ 和 $Q$ 都为假。  
例如，若令 $P$ 表示“我喜欢唱歌”，$Q$ 表示“我喜欢跳舞”，则析取式 $P\lor Q$ 就表示复合命题“我喜欢唱歌或者喜欢跳舞”。  
对于任意两个命题 $P$ 和 $Q$，析取运算 $P\lor Q$ 的真值取值规定如表3-1 第6 列所示。  
在实际的逻辑电路中，通常用高电位表示1 或$T$，用低电位表示0 或$F$，通过逻辑与、或、非等运算，可构造相应的与门、或门、非门，如图所示。后面将具体介绍如何使用这些门电路来构造出一些复杂的逻辑电路。  
图3-2 逻辑电路  
需要注意的是：自然语言中或的含义是有歧义的，对或的理解除了上述可兼或外，有时还可理解成不可兼或，即两者不可兼得的或，有时称之为异或。在逻辑运算中，可兼或与异或之间具有完全不同的含义，我们将在后续相关内容中具体讨论异或逻辑联结词及其逻辑运算。除非特别说明，逻辑演算中或运算含义都默认为可兼或运算，即析取运算。  
在实际应用中，应根据语句的具体内容和上下文相关信息仔细甄别其中“或”表达的是可兼或还是不可兼或。例如，语句“今天晚上我看书或者听音乐”中“或”的含义应理解为可兼或；语句”这节课是数学课或者体育课“中“或”的含义应理解为不可兼或。"
析取式,概念,"['第三章  命题演算与推理', '§ 3.4 命题公式的范式', '3.4.1 范式的基本概念', '一、析取式与合取式']","{'实体类型': '概念', '定义': '有限个文字的析取称为析取式，也称为子句', '特点': '一个具有两层结构的逻辑表达式，只有否定和析取这两种联结词，内层是否定联结词，外层是析取联结词'}",,4,"在否定、合取、析取这三个联结词中，否定联结词具有最高的运算优先级，范式中用文字这个概念对其进行封装，规定范式中否定联结词只能作用于单个命题变量。这样就用文字的概念将否定运算封装命题公式范式的内层。下面给出文字概念的定义：  
【定义3.20】设𝑃是任意一个命题变量，则𝑃和$\neg P$均称为文字，且称𝑃和$\neg P$为互补对。由于合取和析取这两个联结词在运算上具有对等性质，也就是说合取运算具有析取运算的所有性质，析取运算也具有合取运算的所有性质。故有如下析取式与合取式的概念：  
【定义3.21】有限个文字的析取称为析取式，也称为子句；有限个文字的合取称为合取式，也称为短语。  
例如， $P$、 $\neg P$是文字、子句、短语； $P\lor Q\lor R$是子句； $P\land Q\land R$是短语。注意：一个命题变元或者其否定既可以是子句，也可以是短语。  
显然，析取式是一个具有两层结构的逻辑表达式，只有否定和析取这两种联结词，内层是否定联结词，外层是析取联结词；合取式也是一个具有两层结构的逻辑表达式，只有否定和合取这两种联结词，内层是否定联结词，外层是合取联结词。"
析取联结词,概念,"['第三章  命题演算与推理', '§ 3.1 命题的概念与运算', '3.1.3  命题的常用联结词', '二、合取与析取联结词']","{'实体类型': '概念', '定义': '用于表示析取运算的逻辑联结词，记作∨'}",,4,"对于任意两个命题，有时需要构造一个新的复合命题表示这两个命题同时为真的含义，相当于自然语言中“与”或“并且”的意思，由此得到的逻辑运算称为命题的“合取”运算或者“与”运算。该运算及其逻辑联结词的具体定义如下：  
【定义3.3】设 $P$ 、$Q$ 是任意两个命题，复合命题$^{\prime\prime}P$并且 $Q$ ”称为 $P$ 与 $Q$ 的合取式或与运算，记作 $P\land Q$，其中符号$\wedge$称为合取联结词(简称为合取词)。 $P\land Q$的取值为真，当且仅当 $P$ 和$Q$ 同时为真；或者说$P$ ∧𝑄 的取值为假，当且仅当 $P$ 和 $Q$ 至少有一个为假。  
例如，若令$\cdot P$表示“我喜欢唱歌”， $Q$ 表示“我喜欢跳舞”，则合取式 $P\land Q$ 就表示复合命题“我喜欢唱歌并且喜欢跳舞”。  
对于任意两个命题 $P$ 和 $Q$ ，其合取运算 $P\land Q$的真值取值规定如表3-1 第5 列所示。  
有时需要构造一个复合命题表示两个命题中至少有一个为真的含义，相当于自然语言中“可兼或”的意思，由此得到的逻辑运算称为命题的“析取”运算或者“可兼或”运算。所谓可兼或，就是可两者兼得的或。该运算及其逻辑联结词的具体定义如下：  
【定义 3.4 】设   $P、 Q$   是任意给定的两个命题，复合命题 $^{\prime\prime}P$   或 $\textit{Q}\,^{\prime\prime}$ 称为   $P$ 与   $Q$   的析取 式或者可兼或运算，有时简称为或运算，记作 $P\lor Q$ ，其中符号$\vee$称为析取联结词(简称为析取词 ) 。 $P\lor Q$   的取值为真，当且仅当   $P$   和   $Q$   中至少有一个为真；或者说 $P\lor Q$   的取值 为假，当且仅当 $P$ 和 $Q$ 都为假。  
例如，若令 $P$ 表示“我喜欢唱歌”，$Q$ 表示“我喜欢跳舞”，则析取式 $P\lor Q$ 就表示复合命题“我喜欢唱歌或者喜欢跳舞”。  
对于任意两个命题 $P$ 和 $Q$，析取运算 $P\lor Q$ 的真值取值规定如表3-1 第6 列所示。  
在实际的逻辑电路中，通常用高电位表示1 或$T$，用低电位表示0 或$F$，通过逻辑与、或、非等运算，可构造相应的与门、或门、非门，如图所示。后面将具体介绍如何使用这些门电路来构造出一些复杂的逻辑电路。  
图3-2 逻辑电路  
需要注意的是：自然语言中或的含义是有歧义的，对或的理解除了上述可兼或外，有时还可理解成不可兼或，即两者不可兼得的或，有时称之为异或。在逻辑运算中，可兼或与异或之间具有完全不同的含义，我们将在后续相关内容中具体讨论异或逻辑联结词及其逻辑运算。除非特别说明，逻辑演算中或运算含义都默认为可兼或运算，即析取运算。  
在实际应用中，应根据语句的具体内容和上下文相关信息仔细甄别其中“或”表达的是可兼或还是不可兼或。例如，语句“今天晚上我看书或者听音乐”中“或”的含义应理解为可兼或；语句”这节课是数学课或者体育课“中“或”的含义应理解为不可兼或。"
析取范式,概念,"['第三章  命题演算与推理', '§ 3.4 命题公式的范式', '3.4.1 范式的基本概念', '二、析取范式与合取范式']","{'实体类型': '概念', '定义': '有限个短语的析取式称为析取范式', '形式': '一个命题公式为析取范式，当且仅当它具有形式：A1∨A2∨…∨An，其中A1，A2，…，An均为由命题变元或其否定所组成的合取式', '特点': '一个命题的析取范式不唯一'}",,4,"合取式是一个只有否定层与合取运算层的两层结构表达式，如果在其外层增加一个析取运算层，则得到所谓的析取范式；同样，析取式是一个只有否定层与析取运算层的两层结构表达式，如果在其外层增加一个合取运算层，则得到所谓的合取范式。  
【定义3.22】有限个短语的析取式称为析取范式；有限个子句的合取式称为合取范式。析取范式与合取范式统称为范式。 也就是说，一个命题公式为析取范式，当且仅当它具有形式：$A_{1}\lor A_{2}\lor\ldots\lor A_{n}$。其中，$A_{1}$，$A_{2}$，… ，$A_{n}$均为由命题变元或其否定所组成的合取式。  
例如，$(P\land\neg Q\land R)\lor(\neg P\land Q)\lor\neg R$是析取范式。  
同样地，一个命题公式称为合取范式，当且仅当该命题具形式：$B_{1}\wedge B_{2}\wedge\cdots\wedge B_{n}$。其中，$B_{1}$，$B_{2}$，⋯，$B_{n}$均为由命题变元或其否定所组成的析取式。  
例如，$(P\lor\neg Q\lor R)\land(\neg P\lor Q)\land\neg R$是合取范式。  
注意：①一个命题的析取范式或合取范式不唯一；②形如$P\land\neg Q\land R$的公式既可看成是由一个合取式构成的析取范式，也可以看成是由3 个析取式构成的合取范式，但是公式$(P\land$$\neg Q\land R)$只能将其看成是析取范式；③形如$P\lor\neg Q\lor R$的公式既是合取范式，又是析取范式，但$(P\lor\neg Q\lor R)$仅是合取范式。  
对于任意一个命题公式，下面定理保证了其析取范式和合取范式的存在性：  
【定理3.8】对于任意命题公式，都存在与其等值的析取范式和合取范式。"
枚举法,算法,"['二、集合的表示方法', '1、集合表示法（枚举法和描述法）', '1.1.2 集合的概念与表示', '5.1.3 关系的表示', '第五章 关系模型与理论', '§ 5.1 关系的数学模型', '1.枚举法', '§ 1.1 集合的基本知识', '第一章  集合与计数基础']","{'实体类型': ['算法', '概念'], '定义': ['列出集合中所有元素或者可以看出元素变化规律的部分元素的方法', '将作为关系的集合中所有序偶一一枚举出来'], '应用条件': '集合中仅含个数较少的有限个元素或元素之间有明显关系时', '特点': '直观性强、易于理解', '局限性': '对于元素数目较多的集合不是有效方法、甚至不可行，从计算机角度看，一次性输入大量数据将占据大量内存', 'name': '枚举法'}",,5,"所谓枚举法，就是列出集合中所有元素或者可以看出元素变化规律的部分元素。对于一个集合，如果该集合中仅含个数较少的有限个元素，或者集合中元素之间有明显关系时，通常使用枚举法表示该集合。  
枚举法表示的是集合的外延，是一种显示表示方法，具有直观性强、易于理解等优点。但对于元素数目较多的集合，枚举法显然不是一种有效方法、甚至不可行。从计算机的角度看，如果一次性将大量数据输入计算机，将占据大量内存。因此，有时需要使用描述法、归纳法等其它方式来表示集合。"
标准分,概念,"['第六章 特殊关系模型', '§ 6.3 偏序关系与元素比较', '6.4.2 得分评判问题']","{'实体类型': '概念', '定义': '科学记分方法之一，用于解决分数不公平问题', '应用': '期末考试中某班平均分语文85分与数学60分，该班某学生语文80分，数学70分的情况'}",,3,"在很多需要排名次的非相互对抗场合，如歌手大赛中的参赛选手、成员的考评、电视节目中主持人大赛中参赛选手的考评等，其评断标准并不像球赛中进球、失球那样准确无误，往往由评判员们分别打分，通过分数计算名次。然而，分数有其不公平的一面。例如，甲、乙、丙三名歌手的得分分别为94 分，92 分，90 分。  
甲的分数-乙的分数$=$乙的分数-丙的分数。  
虽然这两个差相等，但并不能说明甲高出乙的水平等于乙高出丙的水平，因为这里1 分所表示的水平差距并不唯一确定，而是与评判者紧密相关。又如，对于期末考试中某班平均分语文85 分与数学60 分，该班某学生语文80 分，数学70 分，尽管$80>70$，也不能说明这名学生语文学的比数学好。因为这里分数基准点是不一致的。因此有了“标准分”和“等级记分”等科学记分方法，如 “优秀，良好，合格，不合格”四级打分法便是其中一种。  
由偏序关系的定义可知，任何排名次必是一个偏序关系，并且在很大情况下应是线性关系。因此，在上述排名场合（如歌手大赛考评等）可使用“0-1”法记分，并利用偏序关系的反对称性，在比赛过程对选手进行动态排名。下面结合具体实例介绍具体排名过程：  
设有 $A_{1},A_{2},A_{3},A_{4},A_{5},A_{6}$ 这 6  名参赛者，按其下标次序出场比赛。分别为每名评判员准 备一张如表$6–4$ 所示的表格用于对选手进行打分评判。  
表6-4 评判表
![](images/4c85af2d68ddc01acb3d234836cc3dd6fee35852bbb1e27a76917d56b5336e04.jpg)  
每个评判员的打分方法如下：当$A_{2}$参赛结束时，立即把他与$A_{1}$比较，谁更好一些，若$A_{2}$好一些，在表6-4 的$\mathsf{C}_{21}$位置填上1，若$A_{1}$好一些，则在该位置填上0；$A_{3}$参赛结束后，依次与$A_{1}$、$A_{2}$比较谁好一些，好一些为1，差一些为0，并把这两个比较出来的数依次填在${\mathsf C}_{31}$和  
${\mathsf{C}}_{32}$的位置上。如此下去，知道所有的选手参赛结束。即有：  
$$
C_{ij}=\begin{cases}1&\quad\text{当}A_i\text{比}A_j\text{好时}\\0&\quad\text{当}A_i\text{比}A_j\text{好时}\end{cases}\quad(j<i)\quad\text{(6-5)}
$$  
注意的是，当某一位选手比赛结束都要与他参赛的每一名选手比较而且给出谁好谁差的结论(是1 还是0)。也可以利用偏序关系的传递性减少比较次数。如$A_{5}$比$A_{1}$强，而此时已经有$\mathsf{C}_{31}=\mathsf{C}_{41}=0$，则必有${\mathsf{C}}_{53}={\mathsf{C}}_{54}=1$。表6-5 是某一位评判员所裁判的结果。  
表6-5   评判结果
![](images/0095a64294f10a0d76e1eae14906fdb5c9f5e6a5bc895b20e56aa4e7f6a6e039.jpg)  
如$|A_{5}$行说明$A_{5}$比$A_{1}$好，比$A_{2}$差，比$A_{3}$好，比$A_{4}$  
然后对表6-5 进行整理：首先利用偏序关系的反对称性填充表格的上角，上表虚线为对称轴，右上角各个位置(如$\mathsf C_{12}$)看它的对称位置(即$\mathsf{C}_{21}$)上的数，若其对称位置上数为$1\left(\mathbb{C}_{21}=1\right)$,则它为$0\left(\mathsf{C}_{12}=0\right)$)；若其对称位置上的数为1，则它就是0。即有：  
$$
\mathrm{C}_{ij}=\begin{cases}0&\quad\text{当C}_{ji}=1\text{时}\\1&\quad\text{当C}_{ji}=0\text{时}\end{cases}\quad(i<j)\quad\text{(6-6)}
$$  
完成后如表6-6 所示：  
表6-6 对评判结果的整理
![](images/620931865382a676e3093ac6d3295347415e7bef2cda108424f0318f6d3c3129.jpg)  
把表6-6 各行的数字加起来填入总分列中（倒数第二列），这个列中各数分别为其所在行中相应选手的得分。它们不可能有两个相等的数，否则说明评判或填表有误应作废。把这个列的各数相加填入这一列最后一格为总分和$σ$。事实上$σ$是一个固定数$σ=m(m-1)/2$其中$m$为参赛选手的人数。本例中$m=6$，故有$σ=6*(6-1)/2=15$。  
把表6-6 中各列数字加起来，填入最后一行（即总分行）的相应位置上，分别为其所在列上相应选手的失分，以虚线为对称轴和其对称位置上的得分加起来应该等于$m-1$，  
减1 是因为自己不与自己比较，总分行总分和也等于$m(m-1)/2$。表的最后一列是把各选手的得分转化为人们习惯的百分制，本例中用的是$(m-1)*$得分数$+60$，以避免出现低于60 分的情况，最后把所有评判员有效给出的各个选手成绩相应加起来求平均成绩，按平均成绩高低排名次，此时可能出现并列名次。"
树模型,概念,"['第九章  树的基本理论与算法', '§ 9.4 树模型的应用']","{'实体类型': '概念', '定义': '所有连通无向图中边数最少的图模型，所有无环无向图中边数最多的图模型', '特点': '最简洁的连通无环结构，各结点之间有最直接、最必要的联结关系', '地位': '在图模型知识体系中占有特别重要的地位', '应用': '广泛应用于计算机各个领域，如操作系统组织文件数据，编译程序表示源程序语法结构，数据库系统组织信息', '应用范围': '广泛', '构造': '算法构造', '优化原则': '优化原则和方法', '设计与应用': '深入彻底地认识和掌握该类算法的设计与应用'}",,1,"树是大家非常熟悉的一类植物。通过对树的观察，不难发现自然界中的树总是有根、枝和叶，且具有这样一些特点：从根上可以长出枝来，从树杈上可以长出枝或叶，叶梢不长在一起，根、枝、叶之间总是畅通的，但它们之间不能构成圈。从结构上看，树是所有连通无向图中边数最少的图模型，同时也是所有无环无向图中边数最多的图模型。我们不得不惊叹大自然的神奇，竟然创造出如此高效而又和谐的离散结构。对自然界中树的这种特殊离散结构进行抽象，就可得到一种特殊的图模型，即树模型。在所有的图模型中，树模型是一种最简洁的连通无环结构，其中各结点之间有着最直接、最必要的联结关系。这种最简洁的连通结构决定了树在图模型知识体系中占有特别重要的地位。目前，树作为一种特殊图模型已被广泛应用于计算机各个领域，例如操作系统采用树结构来组织文件数据，编译程序采用树表示源程序的语法结构，在数据库系统中树被用来组织信息等等。  
本章主要介绍树模型基本理论及其算法设计的基本知识，首先介绍树模型的基本概念与性质、生成树与最小生成树等关于树模型的基本理论，然后具体讨论根树的概念与算法，包括树的递归遍历算法、森林与树的转换算法、最优树的构造与编码算法等，并在此基础上进一步学习若干典型特殊树模型及其基本算法，包括平衡树、红黑树、$B$树等，最后给出树模型的若干应用实例，包括决策树、博弈树等。"
树模型算法,算法,"['第九章  树的基本理论与算法', '§ 9.4 树模型的应用']","{'实体类型': '算法', '应用': '常见应用', '构造': '算法构造', '优化原则': '优化原则和方法', '设计与应用': '深入彻底地认识和掌握该类算法的设计与应用'}",,2,基于树模型的算法应用范围十分广泛，本节通过介绍若干树模型的一些常见应用，以进一步阐述树模型算法的构造、优化原则和方法，便于读者更加深入彻底地认识和掌握该类算法的设计与应用。
根树,概念,"['第九章  树的基本理论与算法', '§ 9.3 特殊根数与算法', '§ 9.2 根树的基本知识', '9.2.1  有向树与根树', '§ 9.1 无向树的基本知识']","{'实体类型': '概念', '相关算法': '递归遍历算法、森林与树的转换算法、最优树的构造与编码算法', '定义': ['一种特殊的无向树，用于将有向树转化为无向树进行讨论', '在无向树模型基础上引入树根、树枝和树叶等概念，刻画无向树模型的层次结构的特殊无向树模型', '对于一棵非平凡的有向树，如果恰有一个结点的入度为0，其余所有结点的入度均为1，则称之为根树或外向树', '一类非常重要的树模型'], '特点': ['反映自然界树模型的层次结构特征', '具有根、枝、叶等层次结构'], '应用': ['讨论根树模型的基本性质、基本算法与应用', '表示和处理复杂的数据信息'], '表示方法': '通常使用倒置法表示，即把根画在最上方，叶画在最下方，有向边的方向均指向下方', '相关课程': '程序设计、数据结构、算法设计与分析、操作系统'}",,1,"树是大家非常熟悉的一类植物。通过对树的观察，不难发现自然界中的树总是有根、枝和叶，且具有这样一些特点：从根上可以长出枝来，从树杈上可以长出枝或叶，叶梢不长在一起，根、枝、叶之间总是畅通的，但它们之间不能构成圈。从结构上看，树是所有连通无向图中边数最少的图模型，同时也是所有无环无向图中边数最多的图模型。我们不得不惊叹大自然的神奇，竟然创造出如此高效而又和谐的离散结构。对自然界中树的这种特殊离散结构进行抽象，就可得到一种特殊的图模型，即树模型。在所有的图模型中，树模型是一种最简洁的连通无环结构，其中各结点之间有着最直接、最必要的联结关系。这种最简洁的连通结构决定了树在图模型知识体系中占有特别重要的地位。目前，树作为一种特殊图模型已被广泛应用于计算机各个领域，例如操作系统采用树结构来组织文件数据，编译程序采用树表示源程序的语法结构，在数据库系统中树被用来组织信息等等。  
本章主要介绍树模型基本理论及其算法设计的基本知识，首先介绍树模型的基本概念与性质、生成树与最小生成树等关于树模型的基本理论，然后具体讨论根树的概念与算法，包括树的递归遍历算法、森林与树的转换算法、最优树的构造与编码算法等，并在此基础上进一步学习若干典型特殊树模型及其基本算法，包括平衡树、红黑树、$B$树等，最后给出树模型的若干应用实例，包括决策树、博弈树等。"
根树遍历,算法,"['第九章  树的基本理论与算法', '§ 9.2 根树的基本知识', '9.2.2 根树的基本算法']","{'实体类型': '算法', '定义': '系统地访问树的结点，使得每个结点恰好访问一次', '应用': '在二元树中应用广泛', '方法': '先根遍历算法、中根遍历算法和后根次序遍历算法'}",,3,"对于根树，一个十分重要的问题是要找到一些方法能系统地访问树的结点，使得每个结点恰好访问一次，这就是根树的遍历问题。由于二元树在计算机中最易处理且任意根树都可转化为二元树，因此在$k$元树中，应用得最广泛的是二元树。下面先介绍二元树的三种常用的遍历方法，然后介绍如何将任意根树转化为二元树。  
二元树的遍历算法主要有先根遍历算法、中根遍历算法和后根次序遍历算法，这三种算法都是采用递归的方式进行：  
先根遍历算法，顾名思义就是首先递归访问根结点；然后递归访问根的左子树，最后，就递归访问根的右子树；中根遍历算法，首先递归访问根的左子树；然后递归访问根结点；最后递归访问根的右子树；后根遍历算法，首先递归访问根的左子树；然后递归访问根的右子树；最后递归访问根结点。"
格,概念,"['§ 12.5 格的概念与性质', '§ 11.1 代数结构的基本概念', '12.5.2 格的基本性质', '12.5.3 常用特殊格结构', '第十二章 典型抽象代数结构', '12.5.1 偏序格与代数格', '第十一章  抽象代数结构通论', '11.1.1 数学结构与代数结构']","{'实体类型': '概念', '定义': ['一种特殊的抽象代数结构，同时具备偏序结构和代数结构，与拓扑结构具有非常紧密的联系', '对偏序集⟨L,≤⟩中的任意两个元素a,b，如果集合{a,b}恒存在上确界(𝐺𝐿𝐵)和下确界(𝐿𝑈𝐵)，则称偏序集⟨L,≤⟩是一个格', '一个特殊的代数系统', '从偏序和代数角度考察的结构'], '基本知识': '格的基本概念与性质', '特点': ['同时具备偏序结构和代数结构，与拓扑结构具有非常紧密的联系', '既可从偏序角度借助哈斯图直观地表示格结构，也可从代数角度通过子代数、同态和同构策略等分析讨论格结构'], '应用': ['密码学', '计算机语义学', '开关理论', '逻辑设计等多个领域'], '运算': '偏序格中任意两个元素a,b构成的集合{a,b}，其上确界和下确界唯一存在且均属于L，可用a*b表示集合{a,b}的下确界，称为a和b的保交，用a⊕b表示集合{a,b}的上确界，称为a和b的保联', '基本性质': ['自反性', '反对称性', '传递性', '保序性', '交换律', '结合律', '吸收律', '幂等律', '偏序对运算的保序性', '确界运算对偏序的分配不等式', '确界运算对偏序的模不等式'], '对偶性': '格结构最基本的特征，格与其对偶格具有紧密联系', '性质': '满足交换律、结合律和吸收律'}",,3,"代数结构作为四大基本数学结构之一，它以运算作为处理机制，在整个数学理论体系和计算机数学建模中占据非常重要的作用。代数结构是一种非常古老的数学结构，具有几千年发展历程，从最初初等代数逐步发展到大代数，然后进一步发展到抽象代数，目前正朝着泛代数的方向发展。本小节主要介绍抽象代数的由来及其基本知识结构。  
用计算机解决实际问题，一般需要对问题进行抽象并建立相应的数学模型，然后在此基础上将对实际问题的求解转化为对数学模型的求解。 因此，数学模型是用计算机解决实际问题的基础。现实问题纷繁复杂、变化万千，所建立的数学模型自然也是五花八门，多种多样，让人无所适从。值得欣慰的是，尽管我们面对的数学模型复杂多样，但从结构上看，所有这些数学模型都建立在四种基本的数学结构基础之上。  
这四种基本数学结构分别为：表示元素之间空间关系的拓扑结构，如图模型、树模型就是一些拓扑结构；表示元素之间运算关系的代数结构，如初等代数、向量代数、矩阵代数、命题代数、集合代数等都是代数结构；表示元素规模度量性质的测度结构，如高等数学里函数的微分和积分都是测度结构，它们主要计算面积、体积、弧长、速度等；表示元素之间次序关系的偏序结构，如整数的整除关系、集合的包含关系等偏序关系都是偏序结构。  
任何一个数学结构都是由载体、处理机制和处理规则这三个基本要素组成：  
（1）载体集合 对于任何一个数学结构，需要定义一些抽象的元素作为处理对象，这些抽象元素组成的集合构成数学结构的载体。载体集合是数学结构存在的基础或平台。  
（2）处理机制 为了实现对数学结构载体中元素的处理，需要定义一些处理机制，不同的数学结构具有不同的处理机制。例如：偏序结构是一种关系结构，它以元素之间的次序关系或者比较关系作为处理机制；代数结构是一种运算结构，它以元素之间的运算作为处理机制；拓扑结构是一种分布结构，它以元素之间的空间分布作为处理机制；测度结构则是一种度量结构，它以元素的规模度量作为处理机制。  
（3）处理规则 为使定义出来的数学结构满足一些合理性要求以及能够在处理实际问题中发挥作用，避免出现一些矛盾或荒诞的处理结果，还必须制定一些处理规则对处理机制做一些必要的限制。在现代数学的公理化系统中，通常称这些处理规则称为公理。不同的数学结构具有不同的处理规则，例如偏序结构限制元素之间的关系必须满足自反性、反对称性和传递性，这些限制或者性质构成了偏序结构公理系统；再如代数结构则是规定元素之间的运算必须满足结合律、交换律、分配律等运算性质。  
数学运算最早起源于算术运算，即使用具体的整数或分数进行四则运算。随着科学技术的不断发展，人们逐步意识到这种方法不能满足对一般性规律的认识。因此，采用抽象的字母来代替具体的整数和分数进行运算以获得通用性结果，并称之为代数运算或简称为代数。在微积分出现之前的数千年历史中，对代数运算的研究一直占据数学研究的核心地位。那时人们普遍信奉一种所谓的万能法则，即世界上所有问题都可以转化为数学问题，所有数学问题都可以转化为代数问题，所有代数问题都可以转化为方程问题。  
因此，在很长一段历史时期内，人们对数学的研究基本上都是对代数学的研究，对代数学的研究基本上是方程或方程组解法的研究。解方程是那个时期内所有数学家的中心任务，大家都非常期望能够通过使用代数运算的方法找到方程或方程组的通用求解公式。这种努力在线性方程组领域取得了非常完美的结果，并由初等代数逐步衍生出线性代数。但是，对于一元高次方程通用求解方法的研究并不是很顺利，对于次数高于四次的一元方程始终找不到通用求解公式或求解方法。一些非常著名的数学家，例如欧拉、高斯、拉格朗日等都对此做了大量非常艰苦的研究，但均告失败。  
在寻求五次方程通用求解方法的过程中，年仅17 岁的法国天才少年伽罗瓦在1828 年提出群的概念，运用群的思想证明了五次方程通用求解公式是不存在的，并给出了五次方程系数在满足一定条件下若干特殊解法，由此一举解决了困扰数学家长达200 多年的数学问题。伽罗瓦取得成功的关键在于不仅将运算对象进行抽象化，而且对运算本身进行抽象，在抽象对象和抽象运算的基础上通过构造一些特殊抽象代数结构进行求解。这个思想在当时实在过于超前以至于没有得到柯西、傅里叶、泊松等著名数学家的认可，泊松的判词是“完全不能理解”。 1832 年5 月31 日年仅21 岁的伽罗瓦死于决斗。在决斗之前，他把关于五次方程代数求解的研究成果写成长信，留给了人类。14 年后，法国数学家刘维尔整理并发表了伽罗瓦的遗作，人们才理解并惊叹他那超越时代的天才思想和巧妙构思。  
至此以后，人们对代数的研究内容由方程或方程组的求解技巧转变为对代数运算性质和运算结构的研究，通过对运算和运算对象进行抽象的方式实现对所有运算依其运算性质进行分类或归类，并将伽罗瓦的群论迅速发展成为一门称之为抽象代数结构的崭新数学分支。 抽象代数结构的诞生，把代数学从传统的初等代数发展到现代的抽象代数，由此打开了现代代数学的大门，开创了代数学研究的新纪元。因此，抽象代数结构通常也称为近世代数以区别于之前的初等代数。若无特别说明，我们通常将抽象代数结构简称为代数结构。  
经过一百多年的发展，抽象代数结构已经形成一个如图11-1 所示的知识体系。对于一个代数系统，我们不仅可以主动设计出它的运算并考察相应的运算规则，而且还可以通过分别对其载体集合进行相关改造或运算得到相应的子代数、积代数和商代数，可以通过映射的方式考察不同代数结构之间的区别与联系，还可根据运算性质对代数结构进行分类，形成若干典型抽象代数系统，如群、环、域、格等。  
![](images/37d476cf884c29ed65924bc021cb612de43bab4df8b1196f64e96cad4f61a01f.jpg)
图11-1 抽象代数结构的知识体系  
代数结构作为一种特殊的数学结构，具有载体、处理机制和处理规则这三个基本要素。如前所述，代数结构的载体就是由一些抽象对象为元素组成的集合，并通过运算机制实现对集合中元素的处理。所谓运算，其实就是通过映射的手段从已有元素中构造出新的元素。载体和运算统称为代数结构的成分。代数结构的处理规则即为运算性质。  
既然代数结构的载体是一个集合，那么就可以考虑通过一定方式由这个集合派生出新的集合并据此构造出新的代数结构。例如，可以考察其子集以及在子集上的运算，得到子代数的概念和性质；可以对作为载体的集合做笛卡尔集构成一个新的集合，并在新集合上定义相关运算，得到积代数的概念和性质；可以通过构造等价关系的方法实现对集合载体的划分，构成一个以等价类为元素的商集，并在这个商集上定义相关运算，得到商代数的概念和性质。子代数、积代数和商代数是构造和研究代数结构的基本方法论。  
当然，还可以考察两个代数结构之间的相似性与差异性。对于任意两个代数系统，可以在这两个代数结构的载体(集合)上建立一种保运算的映射，由此考察代数结构之间的联系。如果存在这种保运算映射，则称这两个代数系统同态。如果这种保运算的映射还是双射，则称这两个代数系统同构。同态和同构是考察代数结构之间联系的基本工具。  
依据代数结构的运算性质，可以将各种具体代数结构划分为若干抽象类型。典型的抽象代数结构类型主要有仅含一个二元运算的半群与群、含有两个二元运算的环与域，以及格与布尔代数。这些典型抽象代数结构构成代数结构知识体系的主要内容。"
格同态,概念,"['12.5.2 格的基本性质', '§ 12.5 格的概念与性质', '第十二章 典型抽象代数结构']","{'实体类型': '概念', '定义': '设⟨L,∧,∨⟩和⟨S,*,⊕⟩是两个格，f是从L到S的映射，若对∀x,y∈L，有f(x∧y)=f(x)*f(y)；f(x∨y)=f(x)⊕f(y)，则称f为从格⟨L,∧,∨⟩到格⟨S,*,⊕⟩的格同态映射'}",,2,格是一种非常特殊的代数结构。如前所述，数学主要有偏序、代数、拓扑和测度这四大基本结构，格结构同时具备偏序结构和代数结构，并与拓扑结构具有非常紧密的联系。不过从本质上看，格仍属于代数结构。格结构在密码学、计算机语义学、开关理论、逻辑设计等多个领域都具有非常重要的应用。本节主要介绍格的基本概念与性质，包括偏序格与代数格的概念、格结构的基本性质、格同态与同构以及若干常用的特殊格。
格同构,概念,"['第十二章 典型抽象代数结构', '§ 12.5 格的概念与性质']",{'实体类型': '概念'},,2,格是一种非常特殊的代数结构。如前所述，数学主要有偏序、代数、拓扑和测度这四大基本结构，格结构同时具备偏序结构和代数结构，并与拓扑结构具有非常紧密的联系。不过从本质上看，格仍属于代数结构。格结构在密码学、计算机语义学、开关理论、逻辑设计等多个领域都具有非常重要的应用。本节主要介绍格的基本概念与性质，包括偏序格与代数格的概念、格结构的基本性质、格同态与同构以及若干常用的特殊格。
格结构,概念,"['第十二章 典型抽象代数结构', '§ 12.5 格的概念与性质']","{'实体类型': '概念', '基本性质': '包括偏序格与代数格的概念、格同态与同构以及若干常用的特殊格'}",,2,格是一种非常特殊的代数结构。如前所述，数学主要有偏序、代数、拓扑和测度这四大基本结构，格结构同时具备偏序结构和代数结构，并与拓扑结构具有非常紧密的联系。不过从本质上看，格仍属于代数结构。格结构在密码学、计算机语义学、开关理论、逻辑设计等多个领域都具有非常重要的应用。本节主要介绍格的基本概念与性质，包括偏序格与代数格的概念、格结构的基本性质、格同态与同构以及若干常用的特殊格。
梅森素数,概念,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.3 素数的性质与查找']","{'实体类型': '概念', '定义': '具有2^p-1这种形式的素数，其中p也是素数'}",,3,"通过算术基本定理可以看出，素数是构成所有整数的基本要素，在整个整数理论中占据非常重要的基础性地位。现在我们就来学习有关素数的基本知识，讨论素数的若干基本性质、素数的分布以及相关的查找方法。  
素数的一个非常独特性质是它与其它整数之间具有如下非常简单而直接的关系，这种简单直接的关系是使用素数考察整数性质的基础。  
【定理2.15】假设$p$ 是任意一个给定的素数，则它与其它任意整数$a$ 之间的关系是：要么$p$ 与$a$ 互素，要么$p$ 能够整除$a$。  
可以通过上述定理证明下面结论：  
【定理2.16】假设$p$ 是任意一个给定的素数，$a$ 和$b$ 是任意两个整数，如果$p$ 能整除$a$与$b$ 的乘积，则$p$ 至少能整除$a$ 与$b$ 中的一个。更一般地，假设$a_{1},a_{2},\cdots,a_{k}$是任意给出的$k$个整数，如果素数$p$ 能够整除$a_{1},a_{2},\cdots,a_{k}$，则$p$ 至少能够整除$a_{1},a_{2},\cdots,a_{k}$中的一个。  
下面讨论素数的计数问题。首先考虑在整个正整数集合中，到底有多少个素数？下面的定理给出了答案：  
【定理2.17】正整数集合中的素数有无穷多个。  
下面进一步讨论有限正整数集合中素数的计数与分布情况：  
【定理2.18】设$a$是任意大于1 的整数，则$a$除1 外的最小正因数$q$一定是素数，并且，当$a$是合数时，$q\leq{\sqrt{a}}$，亦即：若$a$ 是合数，则$a$ 必有一个小于等于$\sqrt{a}$的素因子。  
使用上述定理，可以获得一种名为爱氏筛法的素数查找方法。对于任意给定的一个正整数$N$，可以使用该方法找到所有不超过$N$的素数，具体做法如下：  
首先把所有不超过$N$的正整数按从小到大的次序排成一个队列，然后在队列中划去1以及划去一切不超过$\sqrt{N}$的素数的所有倍数，剩下的数即为所求的素数。  
由于有无穷多个素数，因此人们总是希望能够找到尽可能大的素数。300 年来人们找到的最大素数都是$2^{p}-1$这种形式的整数，其中$p$ 也是素数。我们将具有这种形式的素数称为梅森素数，目前有一个名为互联网梅森素数大搜索组织专门搜索大素数，有兴趣的读者可以查阅有关资料了解大素数查找的进展情况。"
森林,概念,"['第九章  树的基本理论与算法', '§ 9.1 无向树的基本知识', '9.1.1  无向树的概念与性质']","{'实体类型': '概念', '定义': '所有连通分支均为树的无向图称为森林'}",,3,"我们知道，自然界中任何一棵树都一个连通的整体，其根、枝、叶之间总相互畅通以保证养分能够顺利到达树的各个部分。此外，从树的结构上看，树的根、枝、叶之间没有任何回路。将树的上述两个基本特征进行抽象，就可得到树的本质结构特征：树模型其实就是一种无环的连通无向图。由此得到如下关于树的定义：  
【定义9.1】连通无回路的无向图称为树。树中悬挂结点称为树叶结点，简称为叶结点或叶，其它结点称为分支点或内点。平凡图称为空树。所有连通分支均为树的无向图称为森林，单个的树模型本身可看成是一个森林。  
【定理9.1】假设${G}=\left\langle{V},{E}\right\rangle$是任意给定的一个无向图模型，且 $\vert V\vert=n,\vert E\vert=m$，则下述各个命题相互等值：  
（1）$G$连通而不含回路（即$G$是树）；  
（2）$G$中无回路且$m=n-1$；  
（3）$G$是连通的且$m=n-1$；  
（4）$G$中无回路，但在$G$中任意增加一条新边，就会得到唯一一条基本回路；  
（5）当$n\geq2$时，$G$是连通的，但删除$G$中的任一条边后，便不连通；  （6）当$n\geq2$时，$G$中每一对结点之间都有唯一的一条基本通路。  
下面定理9.2 给出了关于树模型叶结点的一个基本性质：  
【定理 9.2】 任意非平凡树$T(n,m)$都至少有两片叶。【分析】 利用握手定理和$m=n-1$即可证明。"
模H同余关系,性质,"['第十二章 典型抽象代数结构', '§ 12.3 同余关系与商群', '12.3.1 同余关系与陪集']","{'实体类型': '性质', '特点': '是G上的一个等价关系且对运算*具有保持性'}",,3,"现在我们在群结构的场合考察二元代数结构的同余关系。首先看下面具体实例：  
对于整数加群$\langle Z,+\rangle$，易知$\langle Z_{m},+\rangle$是$\langle Z,+\rangle$一个子群。其中$Z_{m}=\{k m|k\in Z\}$，$m$是任意给定的正整数。我们知道，任意两个整数$a$和$b$具有模$m$同余关系当且仅当$a-b\in Z_{m}$。  
对上述整数加群$\langle Z,+\rangle$上模$m$同余关系进行抽象，就得到如下群上的同余关系：  
【定义12.17】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，对于$\forall a,b\in G$,若有$a*b^{-1}\in H$，则称$a$与$b$具有模${H}$同余关系，记为$a\equiv b({mod{H}})$。  
下面的定理12.3.1 表明模$H$同余关系的确是一个同余关系，即要证明该关系不仅是一个等价关系，而且还对运算$*$具有保持性。  
【定理12.20】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则模${H}$同余关系是$G$上的一个等价关系且对运算${\ast}$具有保持性，即对于$\forall a,b,c\in G$，如果$a\equiv b({\bmod{\ H}})$，则有$a*c\equiv b*c({\bmod{\ H}})$。  
对于群$\langle G,*\rangle$的任意一个子群$\langle H,*\rangle$，既然模$H$同余关系是$G$上的一个等价关系，那么该关系必然确定一个对集合$G$的划分，每个划分块就是该等价关系的一个等价类。由于该等价关系显然由子群$\langle H,*\rangle$确定，因此，对集合的$G$划分也应由子群$\langle H,*\rangle$。为便于考察子群$\langle H,*\rangle$与集合划分的关系，现引入子群$\langle H,*\rangle$陪集的概念，并考察$\langle H,*\rangle$的左右陪集与模${H}$同余关系所确定等价类之间的联系。具体如下：  
【定义12.18】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则对于$\forall a\in G$，称集合$a$ $H=\{a*h|h\in H\}$为子群$\langle H,*\rangle$在群$\langle G,*\rangle$中的一个左陪集，集合$H a=\{h*a|h\in H\}$为子群$\langle H,*\rangle$在群$\langle G,*\rangle$中的一个右陪集，元素$a$为$𝑎$ $H$和$H a$的代表元。  
现在考察如何使用左右陪集实现对群的分解，为此首先引入如下定理：  
【定理12.21】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则对于$\forall a\in G$，其关于$\langle H,*\rangle$的左右陪集的基数相等且等于$ H$的基数，即有$\left|a H\right|=\left|H\right|=\left|H a\right|$。  
由此可见，对于群$\langle G,*\rangle$中的任意一个元素，其关于子群$\langle H,*\rangle$的左右陪集的基数相等且是一个仅与子集$H$有关的常数，即为$|H|$。由此可得如下关于群分解的拉格朗日定理：  
【定理12.22】（拉格朗日定理）设$\langle G,*\rangle$是任意给定的一个有限群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则群$\langle G,*\rangle$的阶一定是其子群$\langle H,*\rangle$阶的倍数，即有$k=|G|/|H|$，其中$k$为正整数且为子群$\langle H,*\rangle$的一切不同左（右）陪集个数。  
拉格朗日定理定理告诉我们：若$\langle G,*\rangle$是有限群，则其子群的阶是群$\langle G,*\rangle$阶的因子。因此，可以通过群与其子群阶的关系考察群的结构及其子群的个数。  
【推论12. 1】假设$\langle G,*\rangle$是一个$ n$阶有限群，则$G$中每个元素的阶均是${n}$的因子且对于$\forall a\in$$G$有$a^{n}=e$.  
【推论12.2】阶为素数的有限群是循环群."
模m同余的判定定理,定理,"['第二章  整数与算法设计基础', '§ 2.2 同余算术及其应用', '2.2.1 同余关系及其运算']","{'实体类型': '定理', '内容': '假设m是任一给定的正整数，任意两个整数a和b具有模m同余关系，当且仅当m能够整除a-b'}",,3,"在很多场合，我们往往只关心用某一特定正整数除以整数得到的余数。例如，星期日期就是从某个星期日开始经历的天数除以7 得到的余数，通过对天数取以7 为除数的余数，就可以用短短的7 个数字借助以7 为周期的循环机制表示无穷无尽的天数。事实上，取余数是一种以有限驾驭无限的重要智慧，对于任一给定的正整数$m$，通过考察所有整数除以$m$ 所得余数的差异，把所有具有相同余数的整数归为一类，则可将所有整数分为$m$ 个基本类型。若分别从每个类中取一个整数作为代表构成一个$m$ 元有限集，则可将这个有限集看成是对整数集的一个抽象，由此完成了整数集从无限向有限的转化。在这个分类过程中，整数之间是否具有相同余数的关系起着非常关键的作用，由此得到如下同余的概念：  
【定义2.9】假设$m$ 是任一给定的正整数，对于任意两个整数$a$和$b$，它们除以$m$ 后得到的余数分别记为$a({\bmod{\ m}})$和$b({\bmod{\ m}})$，如果这两个余数相等，即有：  
$$
a({\bmod{\ m}})=b({\bmod{\ m}})\tag{2-9}
$$  
则称$a$与$b$具有模$\pmb{m}$同余关系，简称为$a$与$b$模$\pmb{m}$同余或同余，记为$a\equiv b({\bmod{m}})$或$b\equiv$$a({\bmod{\ m}})$；否则称$a$与$b$对于模$\mathbfit{m}$不同余，记为$a\not\equiv b({\bmod{{m}}})$或$b\not\equiv a({\bmod{\ m}})$。  
根据上述定义，不难证明下面关于模$_m$同余的判定定理：  
【定理2.19】假设$m$是任一给定的正整数，任意两个整数$a$和$b$具有模$_m$同余关系，当且仅当$m$能够整除$a-b$。  
【定理2.20】假设$m$ 是任一给定的正整数，任意两个整数$a$ 和$b$ 具有模$m$同余关系，  
当且仅当存在整数$k$，使得整除$a=b+k m$  
下面定理表明了同余关系的保加性和保乘性：  
【定理2.21】设$m$ 是任一正整数，若整数$a$ 与$b$ 模$m$ 同余，整数$c$与$d$ 同余模$m$，则它们的和与积也分别模$m$ 同余。即：若$a\equiv b({\bmod{\ }}m)$，$c\equiv d({\bmod{\pmod{m}}})$，则有：  
$$
a+c\equiv(b+d)(\bmod{\ m}),\ \ a c\equiv b d(\bmod{\ m})
$$  
【定理2.22】假设$m$ 是任一给定的正整数，则对任意两个整数$a$ 和$b$，成立下面两个关于余数的计算公式：  
$$
(a+b){\bmod{\ m}}=((a{\bmod{\ m}})+(b{\bmod{\ m}})){\bmod{\ m}}\tag{2-10}
$$  
$$
ab\ {\bmod{\ m}}=((a{\bmod{\ m}})(b{\bmod{\ m}}))\ {\bmod{\ m}}\tag{2-11}
$$  
例如，对于$7\equiv2{\bmod{\mathrm{~5~}}}$和$11\equiv1{\bmod{\mathrm{~5~}}}$，由定理2.21 知：  
$$
18=7+11\equiv2+1=3({\bmod{\mathrm{~}}}5)
$$  
$$
77=7\cdot11\equiv2\cdot1=2{\pmod{5}}
$$  
再如，对于任意三个数，比如说1, 2 和5，由定理2.22 知存在如下等式：  
$$
(1+2)({\bmod{\ }}5)=((1\ \,({\bmod{\ }}5)+(2\ \,({\bmod{\ }}5))({\bmod{\ }}5)
$$  
$$
2\,\bmod\,5=\left((1\,\bmod\,5)(2\,\bmod\,5)\right)\,(\bmod\,5)
$$  
值得注意的是，同余关系在一般情况下不满足消去律，例如 $8\equiv12({\bmod{\mathrm{~}}}4)$，两边同除以4 后，$2\equiv3({\bmod{\mathrm{~}}}4)$显然是不成立的，但是存在下列性质：  
【定理2.23】若$a c\equiv b c({\bmod{\pmod{m}}})$，且$c$ 与$m$ 互素，则有：$a\equiv b({\bmod{\ }}m)$  
如前所述，使用同余可以实现对整数集合的划分或分类，现在就来讨论这个问题。由同余的定义可知，对于任意给定的正整数$m$，可依照除以$m$ 后的余数值以及模$m$ 同余关系，将所有整数划分为$m$ 个互不相交的子集合。据此，我们引入如下同余类的概念：  
【定义2.10】设$m$ 是任一给定正整数，对于每个整数$i$，$0\leq i<m$，定义如下集合：  
$$
R_{i}(m)=\{n|n\equiv i({\bmod{\pmod{\ m}}},n\in Z\}\tag{2-12}
$$  
则称每个$^{}R_{i}(m)$分别是模$m$ 的一个同余类或剩余类，在不引起混淆的情况下，通常也将$R_{i}(m)$简记为$[i]$，并记为：$Z_{m}=\{[0],[1],\cdots[m-1]\}.$。  
【定理2.24】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m),$所有模$m$ 同余类，则有下述结论成立：  
（1）每个整数$a$ 都恰好属于某个同余类，通常将这个同余类记为$[a]_{m}$或$[a]$  
（2）对于任意的两个整数$a$ 和$b$，它们属于同一个同余类的充分必要条件是：
$$
a\equiv b({\bmod{m}})
$$  
上述定理表明，每个整数必定属于且仅属于其中一个剩余类，属于同一个剩余类的任意两个整数都是模$m$ 同余的，属于不同剩余类的任意两个整数不可能是模$m$ 同余的。  
根据定理，可以在$.Z_{m}=\{[0],[1],\cdots[m-1]\}$上定义关于同余类的加法和乘法运算：  
【定义2.11】假设$m$ 是任一给定的正整数对于任意给定的两个整数$a$和$b$，定义：
$$
[a]_{m}+[b]_{m}=[a+b]_{m}
$$  
$$
[a]_{m}\cdot[b]_{m}=[a\cdot b]_{m}
$$  
【定义2.12】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m)$是所有模$m$ 同余类，如果从每个同余类$R_{i}(m)$中分别取一个整数$x_{i}$构成一个$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$，则称该有限集合为模$m$ 的一个完全剩余系，简称为完全系；称$m$ 元有限集合$\{0,\ 1,\ 2,\ \cdots\ ,$为最小非负完全剩余系。  
对于正整数$m$，假设$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$是模$m$ 的一个完全剩余系，对于其中的任意一个整数$\cdot x_{i}$，如果${\bf\nabla}_{}^{}$与$m$ 互素，则$x_{i}$所在同余类${\mathbf{}}R_{i}(m)$中每个整数$k$ 都与$m$ 互素。这是因为根据$k\equiv x_{i}({\bmod{\pmod{m}}})$，即有$\cdot_{x_{i}}=k+q m$。由此可知，如果$k$ 与$m$有大于1 的公因子，那么$x_{i}$必然与$m$ 有大于1 的公因子。类似地，如果$x_{i}$与$m$ 互素，则$x_{i}$所在同余类$R_{i}(m)$中每个整数$k$ 都与$m$ 不互素。由此得到如下简化同余类和简化剩余系的概念：  
【定义2.13】对于正整数$m$，假设$R_{i}(m)$是任意一个模$m$ 同余类，若$R_{i}(m)$中存在一个整数与 $m$  互素，则称 $\ R_{i}(m)$ 是一个模 $\pmb{m}$  简化同余类或模 $\pmb{m}$  简化剩余类。如果分别从每个模 $m$ 简化同余类中取出一个整数作为代表$x_{i}$构成一个有限集合$\{x_{0},\ x_{1},\ \cdots,x_{\varphi(m-1)}\}$，则称该集合为模$m$ 的一个简化剩余系，简称为简化系。其中$\varphi(m)$称为欧拉函数，表示模$m$ 简化剩余类的数目，亦即不超过$m$ 且与$m$ 互素的正整数个数。  
因为所有模$m$ 同余类构成整数集合的一个划分，所以每个与$m$ 互质的整数仅存在于它  所在的简化同余类中。由此可以看出，简化同余类以及欧拉函数$\varphi(m)$在整数互质性质的研究中具有非常重要的作用，后面将使用这些概念证明欧拉定理和费马小定理。这两个定理不仅是整数理论中非常著名而重要的定理，而且还是现代非对称数论加密算法的基础。"
模余运算,概念,['第二章  整数与算法设计基础'],"{'实体类型': '概念', '地位': '整数理论的基础知识之一'}",,1,"整数作为一种最基本的离散量和离散结构不仅是离散数学的研究对象，而且其自身也是研究其它离散结构的一项基本工具，在离散量的度量、计数和算法设计等方面发挥重要的基础性作用。整数是人类最早认识和使用的数，专门研究整数及其性质的整数理论是一个具有几千年历史的非常古老的数学分支。在很长一段时期内，整数理论被认为仅仅是思想的体操、数学思维能力的训练工具，其实用性并没有得到充分重视。著名数学家数学王子高斯就曾给出这样的评价：如果说数学是科学的皇后，那么整数理论则是皇后头上美丽的皇冠。意指其仅仅是漂亮而不够实用。直到20 世纪70 年代基于整数模余运算理论的非对称加密算法被设计出来并取得成功应用，整数理论的实用性才得到广泛重视。事实上，算法概念正是诞生于整数的算术运算，这使得整数理论与计算机算法有着一种天然的紧密联系。计算机学科的诞生与兴起让整数理论这门古老的学科重新焕发出新的生命并得到蓬勃发展。目前，整数理论已经成为算法设计与算法度量的一项基本工具，在散列函数构造、伪随机数生成、信息编码与加密等多个领域得到广泛应用。其实除整数之外，离散数学中很多其它离散结构模型，例如图模型、关系模型、群代数结构模型等，也都是通过相关算法在计算机领域发挥重要作用。因此，算法设计技术是学习与应用离散数学所必备的基本知识。  
综上所述，作为学习离散数学的另一入门基础，本章比较系统地介绍整数理论与算法设计的基本知识，具体包括整除的基本概念与运算性质、模余运算的基础知识、同余方程及其解法、非对称加密算法、算法设计的基本知识、算法设计的基本策略与应用等。"
模逆,概念,"['第二章  整数与算法设计基础', '§ 2.2 同余算术及其应用', '2.2.2 同余方程与方程组']","{'实体类型': '概念', '定义': '与m互素的整数a，满足a·x≡1(mod m)的最小正整数解'}",,3,"相等的两个整数除以某一正整数$m$ 后得到的余数自然是相等的。因此，两个整数之间的同余关系不仅可以看成是对整除关系的一种推广，而且还可以看成是对两个整数相等关系的一种推广。下面定理表明整数相等关系与同余关系自己具有共同本质属性。  
【定理2.25】假设$m$ 是任一给定的正整数，则模$m$ 同余关系满足下列性质：  
(1) 自反性：$a\equiv a({\bmod{\ m}})$，对一切整数$a$ 成立；  
(2) 对称性：若$a\equiv b({\bmod{\ }}m)$，则$b\equiv a({\bmod{\ m}}).$；  
(3) 传递性：若$a\equiv b({\bmod{\ }}m)$，$b\equiv c({{\pmod{m}}})$，则$a\equiv c({{\pmod{m}}}).$。  
我们知道，根据整数之间相等关系的制约可以列出相应的整数方程和方程组。那么，根据整数同余关系的制约是否也可以列出相应的方程和方程组呢？如果可以，那么这些方程和方程组如何求解？本节我们就来讨论这些问题。  
【定义2.14】假设$m$ 是任一给定的正整数，$a$ 和$b$ 是任意给定的两个整数，下式：  
$$
a x\equiv b({\bmod{m}})\tag{2-13}
$$  
称为关于未知数$x$ 的一次线性同余方程，简称为同余方程，其中$x$ 为未知整数。若存在一个整数$\cdot x_{0}$，当$x=x_{0}$时，成立$.a x\equiv b({\bmod{\pmod{m}}})$，则称$\cdot x_{0}$是该同余方程的一个解。  
显然，如果$x_{0}$是某个同余方程的一个解，则与$x_{0}$同余的所有整数都是该同余方程的解，这是一种平凡情形，通常将与$x_{0}$同余的所有整数与$x_{0}$一起看成是同一个解。因此，同余方程解的计数标准为：凡是相互之间模$m$ 同余的解都视为同一个解，同余方程解的个数是指它的关于模$m$ 互不同余所有解的个数，亦即在模$m$ 的一个完全剩余系中解的个数。  
下面考察一次线性同余方程解的存在性：  
【定理2.26】假设$m$ 是任一给定的正整数，$a,b$ 是任意给定的两个整数，如果$a$ 与$m$之间没有整除关系，即有$a\not\equiv0({\bmod{m}})$ ，则下列同余方程  
$$
a x\equiv b({\bmod{m}})
$$  
有解的充要条件是$a$ 与$m$ 的最大公因数能够整除$b$。若有解，则解的个数为$\operatorname*{gcd}(a,m)$。  
对于同余方程$a\cdot x \equiv 1(\mod m)$，其有解的充要条件是$a$ 与$m$ 的最大公因数能够整除1，即互素$a$ 与$m$。且有解的情况下只有唯一解。由此给出如下关于$\bar{a}$的定义：  
【定义2.15】设$m$ 是任一给定的正整数，$a$ 是任一与$m$ 互素的整数，满足$a\cdot x\equiv$1 (mod $m^{\prime}$)的最小正整数解称为整数$a$的模$\pmb{m}$ 逆，记为$\cdot\bar{a}$。  
下面定理的证明过程给出了整数$a$ 模$m$ 逆$\bar{a}$的一个具体求法：  
【定理2.27】设$m$ 和$a$ 是两个互素的整数，且$m>1$，则存在唯一一个小于$m$ 的正整数$\bar{a}$，它是$a$ 的模$m$ 逆，即有：${\bar{a}}\cdot a\equiv1({\bmod{{m}}})$。  
【定义2.16】假设$m_{1},m_{2},\cdots,m_{k}$为$k$个正整数，$a_{1},a_{2},\cdots,a_{k}$为$k$ 个整数，由下列$k$ 个以$x$ 为未知整数的同余方程联立而成的方程组，称为同余方程组：  
$$
\left\{\begin{array}{l l}{x\equiv a_{1}(\bmod~m_{1})}\\ {x\equiv a_{2}(\bmod m_{2})}\\ {\qquad\dots}\\ {x\equiv a_{k}(\bmod~m_{k})}\end{array}\right.\tag{2-14}
$$  
若存在一个整数$\cdot x_{0}$满足上述所有同余方程，则称$\cdot x_{0}$是该同余方程组的一个解。  
当以上定义的同余方程组中所有模两两互素时，方程组一定有唯一的一组解。下面的中国余数定理是整数理论中一个非常著名的定理，又称为孙子定理。该定理不仅确认了上述结论，而且其证明过程其实给出了一个具体的求解方法。  
【定理2.28】（中国余数定理）设$m_{1}$$\cdot\ \ m_{2},\ \ \cdots m_{k}$是两两互素的正整数，那么同余式组（2-14）有唯一的以$M=m_{1}m_{2}\cdots m_{k}$为模的解。"
欧拉公式,定理,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.3.1  平面图的概念与性质']","{'实体类型': '定理', '内容': '对于连通平面图，结点数$n$、边数$m$和面数$r$之间满足$n-m+r=2$'}",,3,"所谓平面图，直观地说就是可以将该图嵌入到某个平面上。如图10-46（a）所示，图模型的边有时不仅在结点处相交，而且还在某些非结点处有交叉，这些非结点处交叉点的边重叠特征显然会导致图模型不能嵌入在同一个平面上。因此，为了将图模型嵌入平面，首先必须适当调整该图中边的走向，以保证任意两条边不会在非结点处有交叉，如图10-46（b）所示。由此得到可平面图和平面图的相关概念。  
【定义10.6】设$G=\langle V,E\rangle$是任意给定的一个图模型，如果该图中有两条边在非结点处有交叉，则称这两条边为该图的交叉边，交叉的具体位置称为交叉点。如果可将图𝐺画在同一个平面上，并且所有边除在结点处之外均不交叉，则称图𝐺可嵌入平面，或称𝐺为可平面图，否则称该图为不可平面图或非平面图。对于可平面图𝐺，将其边不交叉的画法称为𝐺的平面嵌入表示。以平面嵌入方式表示的图可平面图𝐺称为平面图。对于一个平面图𝐺，若对其再加一条边就变成不可平面图，则称𝐺为最大平面图。  
![](images/ad5984e0ab09600028eb4068193d74e75743de0f027a20b4d084511a312873d4.jpg)  
![（a）完全二分图$K_{3,3}$  （b）无法消除交叉  ](images/aa69f9dcec49f0e95a534b493200688a98dae4f4be8a347fbd35c04b8c21413b.jpg)  
例如，对于图10-46（a）所示的图，该图有三对交叉边，即$(v_{1},v_{4})$和$(v_{2},v_{3}),~(v_{1},v_{4})$和$(v_{2},v_{5})$、$(v_{1},v_{5})$和$(v_{2},v_{3})$。由于可将该图表示成图10-46（b）的形式，故该图是一个可平面图。图10-46（b）所示的图就是一个平面图。显然，如果在该平面图上增加一条边，则该图就变成一个不可平面图，故该是一个最大平面图。再如，对于图10-47（a）所示的图模型，无论怎么调整边的走向都不能将其以平面嵌入方式表示，如图10-47（b）所示。故图10-47（a）所示的图模型为不可平面图或非平面图。  
在没有特别要求的情况下，通常将可平面图与平面图不加区分地统称为平面图。与一般图模型显著不同的是，平面图模型除了具有结点和边这两个基本构件之外，还有一般图模型所没有的面的概念，并且由进一步面衍生出边界的概念。因此，平面图是一类非常重要的特殊图模型，无论在理论上还是在应用方面都具有非常重要的价值，在印刷电路板的设计、城市管网设计与规划等多个领域得到实际应用。  
图论之父欧拉对平面图有着比较深刻的研究，发现并论证了平面图的结点、边和面之间的数量关系，提出了著名的欧拉公式。下面给出平面图中面的相关概念：  
【定义10.7】设$G=\langle V,E\rangle$是任意给定的一个平面图，由𝐺中边所包围且内部不包含结点与边的区域，称为$G$的一个面。区域面积有限的面称为有限面，区域面积无限的面称为无限面。对于$G$的任意一个面$R$，包围面$R$的所有边构成的回路称为面𝑅的边界，面𝑅边界中边的个数称为面$R$的次数或度，记为${\bf d e g}(R)$。  
通俗地说，如果把一个平面图画在平面上，然后用小刀沿着图的边将平面切开，那么整个平面就被切成若干块，其中每一块就是图的一个面。或者说，平面图的一个面就是平面中一个以边为界线不能再分割的区域块。例如，对于图10-46（b）所示的平面图，一共有六个面，其中有一个面是无限面，其余五个是有限面。需要注意的是，对于任何一个平面图，该图有且仅有一个无限面。下面的定理10.11 给出了平面图中面数与边数的数量关系：  
【定理10.11】平面图中所有面的次数之和等于边数的两倍。  
下面定理10.12 是著名的欧拉公式，给出了平面图中结点、边和面之间的数量关系：  
【定理10.12】设$G=\langle V,E\rangle$是任意给定的一个连通平面图，若它有$n$个结点、$m$条边、$r$ 个面，则有  
$$
n-m+r=2\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
【定理10.13】如果平面连通图$G$每个面的次数均为$l(l\geq3)$，则有：  
$$
m=l(n-2)/(l-2)
$$  
其中$m$为$G$的边数，$n$为$G$的结点数。  
【定理10.14】设$G$是一个$(n,m)$简单连通平面图，若$m>1$，则有：  
$$
m\leq3n-6\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
由定理10.4 的逆命题不成立，也就是说满足不等式$m\leq3n-6$的简单连通图不一定是平面图。但是对于一个简单连通图，若不满足$m\leq3n-6$，则一定是非平面图。因此，可用定理10.4 的结论证明某个简单连通图不是非平面图。  
【定理10.15】设$G$为一平面连通简单图，其结点数$n\geq4$，边数为$m$，且$G$不以$K_{3}$为其子图，则有$m\leq2n-4$。  
【定义10.8】对于是任意给定的一个图模型$G=\langle V,E\rangle$  
设$e=(u,v)$是$G$的任意一条边，如果在图$G$中删除该边并新增一个结点$w$及两条边$e_{1}=$$(u,w)$、$e_{2}=(w,v)$ ，则称该操作为对图$G$的边切割操作；  
设𝑤是$G$中任意一个度数为2 的结点，且是边${e_{1}=(u,w)}$和$e_{2}=(w,v)$的公共结点，如果在图$G$中删除结点$w$及边$e_{1},\,e_{2}$，并增加边$e=(u,v)$，则称该操作为对图$G$的结点贯通操作；  
对图$G$的边切割操作和结点贯通操作统称为对图$G$的同胚操作。  
显然，边切割操作和结点贯通操作是一对互逆操作。例如，对于图10-48 所示的两个图模型，可通过对边的切割操作将$G_{1}$变成$G_{2}$，也可通过对结点做贯通操作将$G_{2}$变成$G_{1}$。  
![图10-48  图的同胚操作与同胚关系  ](images/17b45e1706460a818a5492fb4df19f0ddd6b072e9cf57afef7db0852f0c58237.jpg)  
下面在同胚操作的基础上，引入如下两个图之间的同胚关系：  
【定义10.9】设$G_{1}=\langle V_{1},E_{1}\rangle$和$G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，如果可用同胚操作将其中一个转化为另外一个，则称$G_{1}$与$G_{2}$具有同胚关系，简称为$G_{1}$与$G_{2}$同胚。  
根据上述同胚的概念，可以得到如下关于平面图判定的库拉托夫斯基定理：  
【定理10.16】（库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是$G$的任何子图都不同胚于$K_{5}$或$K_{3,3}$。  
【定理10.17】(库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是𝐺的任何子图都不能通过边的收缩得到$K_{5}$或$K_{3,3}$。  
![图10-51 彼得森图收缩为$ K_{5}$](images/b6cd48c8bf37519af48b0cc187afdf1adc13d2c5e160a08fe418ce5c94762fd6.jpg)  
库拉托夫斯基定理是一个非常著名定理，通常将$K_{5}$和$K_{3,3}$称为库拉托夫斯基图。可以使用该定理判定一个图是否为平面图。例如，对于图$10{-}51\mathrm{a}$）所示的彼得森图，收缩其边$(v_{i},u_{i})(i=1,2,3,4,5)$，则可得到图$K_{5}$，见图10-51b)。故彼得森图不是平面图。  
值得注意的是，虽然库拉托夫斯基定理给出了平面图判定的充分必要条件，但是目前还没有基于该定理得到一个有效的判定算法。因此，对于一个比较复杂的图模型，要判定其是否为平面图，有时并不是一件容易的事情。"
欧拉回路,原理,"['第十章  特殊图模型与算法', '§ 10.4 网络流图及其优化问题', '10.5.1 鼓轮设计问题']","{'实体类型': '原理', '定义': '图中经过每条边恰好一次的回路', '应用': '用于解决鼓轮设计问题中的二进制数码排列'}",,3,"计算机鼓轮是由绝缘材料和导电材料制成，主要用于输出二进制数码。例如，对于如图10-7（a）所示的一个轮鼓，旋转鼓的表面分成了8 块扇形，图中阴影区表示用导电材料制成，空白区用绝缘材料制成，终端𝑎、𝑏和 $c$与扇面接触时接触导体输出1，接触绝缘体时输出0。鼓轮按逆时针旋转，触点每转一个扇区就输出一个三位二进制信号。  
问题是如何设计这8 块扇形区域绝缘材料与导电材料的分布，使得鼓轮每旋转一周，就能得到从000 到111 这8 个不同的二进制数。这就是计算机鼓论设计问题。从数学逻辑上看，这个问题也可理解为：如何将8 个二进制数码排成一个圆圈，使得任意3 个依次相连的数码组成的三位二进制数互不相同，而且能够产生全部8 个不同的三位二进制数。  
对于终端$a,b,c$，若某时刻的输出信号为$a_{1}a_{2}a_{3}$，则每转一个扇形，信号变成$a_{2}a_{3}a_{4}$。由此可见，前一次输出信号的右两位决定了后一次输出信号的左两位。故可把所有两位二进制数作为结点，将二进制数码之间传递关系的结点引一条有向边，将这两个二位二进制数进行串接并合并两者重复的部分，产生一个三位二进制数，并用这个三位二进制数表示该有向边。例如，对于结点$a_{1}a_{2}$和$a_{2}a_{3}$，可从$a_{1}a_{2}$到$a_{2}a_{3}$引一条有向边表示$a_{1}a_{2}a_{3}$这个三位的二进制数。由此得到如图10-7（b）所示的有向图。  
![图10-89 三位计算机轮鼓设计问题 ](images/fd2bd5a3740dee863b37e0bc2d2faadb7b3dbae1169c6c42913ac97c999411af.jpg)  
由于图10-7（b）所示有向图中每条边都代表一个三位二进制数，并且不同边表示不同的三位二进制数。因此，若能在该有向图上求出一条欧拉回路，则可得到该全部 8 个三位二进制数的一个圆排列，由该圆排列不难得到所求8 个二进制数码的圆排列。  
由图10-7（b）可知，该有向图4 个结点的出度和入度数均为2 故存在欧拉回路，比如$(e_{0},e_{1},e_{3},e_{7},e_{6},e_{5},e_{2},e_{4})$即是一条欧拉回路，根据该回路不难得到其对应的8 个二进制数码的圆排列为：00011101。按此数码排列分布计算机轮鼓8 块扇形区域绝缘材料与导电材料，则该鼓轮按逆时针每旋转一个扇区就输出一个三位二进制信号，鼓轮每旋转一周，就能得到从000 到111 这8 个不同的二进制数。  
上述所求的8 个二进制数码的圆排列00011101 称为一个8 位布鲁英序列。下面进一步考察16 位布鲁英序列。如图10-90（a）所示，此时旋转鼓的表面分成了16 块扇形，图中阴影区表示用导电材料制成，空白区用绝缘材料制成，终端$a$、$b$、𝑐和 $d$与扇面接触时接触导体输出1，接触绝缘体时输出0。鼓轮按逆时针旋转，触点每转一个扇区就输出一个二进制信号。问题是如何选取这16 块扇形的材料，使鼓轮旋转一周，触点能够输出个不同的四位二进制信号，并且每转一周就能得到从$0000{\sim}1111$ 这全部16 个四位二进制数。  
![图10-90 四位计算机轮鼓设计问题 ](images/5b3de38c173917b97e4ae2bdc5b3b0f102b52c396d35769298cedf57247d3416.jpg)  
从逻辑上看，四位计算机轮鼓设计问题也可理解为：把16 个二进制数排成一个圆圈，使得4 个依次相连的数字所组成的16 个四位二进制数互不相同。  
对于终端$a,b,c,d$，若某时刻的输出信号为$a_{1}a_{2}a_{3}a_{4}$，则每转一个扇形，信号变成$a_{2}a_{3}a_{4}a_{5}$。由此可以看出，前一次输出信号的右三位决定了后一次输出信号的左三位。因此，我们可把所有三位二进制数作结点，从每一个结点$a_{1}a_{2}a_{3}$到$a_{2}a_{3}a_{4}$引一条有向边表示$a_{1}a_{2}a_{3}a_{4}$这个四位的二进制数，作出表示所有可能的码变换的有向图如图10-90（b）所示。于是问题转化为在这个有向图上求一条欧拉回路。  
由图10-90（b）可知，该有向图8 个结点的出度和入度均为2，故存在欧拉回路，例如$e_{0},e_{1},e_{2},e_{4},e_{9},e_{3},e_{6},e_{13},e_{10},e_{5},e_{11},e_{7},e_{15},e_{14},e_{12},e_{8}$是一条欧拉回路，其对应布鲁英序列为0000100110101111。计算机轮鼓绝缘材料与导电材料按此序列分布便可满足要求。"
欧拉图,概念,"['§ 10.1 欧拉图与哈密顿图', '10.1.3 中国邮路问题', '10.1.1  欧拉图及其性质', '第十章  特殊图模型与算法']","{'实体类型': '概念', '定义': ['对图中边的唯一性遍历问题', '通过图中所有边一次且仅一次的回路称为欧拉回路，如果图中存在欧拉回路，则称之为欧拉图'], '特点': ['有明确易用的充要条件实现对问题可解性的判定', '欧拉通路是经过图中所有边的通路中长度最短的通路；欧拉回路是经过图中所有边的回路中长度最短的回路', '每条边经过且仅经过一次'], '判定条件': '无向图中所有结点度数均为偶数', '应用': ['解决哥尼斯堡七桥遍历问题', '图模型的一笔画问题', '可以使用弗洛莱算法自动找到其欧拉回路或欧拉通路', '用于求解中国邮路问题中的最优路径'], '相关理论': '欧拉图及相关理论'}",,1,"如前所述，图模型及其理论是数学家欧拉为解决哥尼斯堡七桥遍历问题而创立。事实上，图模型作为一种由结点和边组成的离散结构是一种非常强大的离散建模工具，除了能够解决哥尼斯堡七桥遍历问题之外，还可解决很多其它实际问题。例如，旅游的路径规划问题、资源分配与匹配问题、图的着色与并行流程的设计问题、最小费用流问题等等。针对不同的问题，通常需要设计出特定的图模型进行建模与求解。例如，解决哥尼斯堡七桥遍历问题需要使用欧拉图及相关理论、解决旅游的路径规划问题需要哈密顿图及相关理论、解决资源分配与匹配问题需要二分图及相关理论、解决图的着色与并行流程的设计问题需要平面图的相关理论、解决最小费用流问题需要网络流图的相关理论等等。由此产生很多种具有特殊结构和性质的图模型，每种特殊图模型都能针对性地有效地解决某一类或某几类特定问题。因此，要想高效合理地使用图模型实现对实际问题的建模与求解，除了掌握前述图模型的一般理论及算法之外，还需要进一步掌握多种特殊图模型的相关理论及算法。  
本章介绍几种重要的特殊图模型及相关算法，包括欧拉图模型的基本理论及边的遍历算法、哈密顿图的基本理论及结点的近似遍历算法、二分图模型的基本理论及匈牙利匹配构造算法、平面图的基本理论及着色算法、网络流图的基本理论及最大流算法，并结合具体实例分析和讨论这些特殊图模型的应用方法。"
欧拉定理,定理,"['第二章  整数与算法设计基础', '§ 2.2 同余算术及其应用', '2.2.3 整数加密算法']","{'实体类型': '定理', '内容': '设m是任一正整数，a是任一与m互素的整数，则有a^φ(m)≡1(mod m)，其中φ(m)是欧拉函数'}",,3,"为防止机密信息被泄露或破坏，需采用数据加密技术对其进行保护。数据加密的基本思想是对原始数据加以伪装，使非法接入者无法理解信息的真正含义，基本过程就是对原来为明文信息或数据按某种算法进行处理，使其成为不可读的一段代码，称为密文，使其只能在输入相应密钥之后才能显示出本来内容。数据加密通常分为对称式加密和非对称式加密两大类。本节介绍两种基于整数理论的经典加密算法，一种是名为仿射加密算法的对称加密算法，另一种是名为RSA 的非对称加密算法。  
仿射加密算法又称为凯撒加密算法，是一种简单且广为人知的加密技术。它是一种替换加密技术，基本思想如下：首先使用0 到25 之间的数字表示A 到Z 这26 个字母。然后，对于每个不大于25 的非负整数$\cdot p$，定义其加密函数值$f(p)$为$\{0,1,2,\ \cdots,25\}$中某个数字。加密函数$f(p)$的有多种定义方法，例如可采用如下加密函数：  
$$
f(p)=(p+3)\;{\bmod{\,}}26
$$  
对于上述加密函数，此时用整数$(p+3)\,\mathrm{mod}\,26$代表的字母替代由整数$p$表示的字母实现加密。例如，对“WELCOME TO HEFEI”进行加密，首先用数字代替字母，然后使用加密函数$f(p)=(p+3)\mod 26$ 代替$p$，翻译成字母后，得到获得到的加密信息为：“ZHOFRPH VR KHIHL”具体过程如下：  
表2-3 凯撒密码的加密过程
![](images/168580ee1913d8c32220b048da1875515ce367981f5bce7472f95af1471231b8.jpg)  
解密则需要使用加密函数的$f(p)$反函数 $f^{-1}(p)$  
$$
f^{-1}(p)=(p-3){\bmod{\,}}26
$$  
解密时需将加密信息转换成数字，然后使用$f^{-1}(p)$把$\{0,1,2,\ \cdots,25\}$中整数$\cdot p$恢复成信息原文对应的整数，之后再将数字装换成字母获得原文。  
RSA 算法由三位数学家Rivest、Shamir 和Adleman 于1977 年共同提出，是至今最为广泛使用的非对称加密算法，特别适合于对通过互联网传送的数据进行加密，通常于数字签名等场合。RSA 算法使用整数模余运算性质生成公钥和私钥，并进行加密和解密。RSA 算法原理基于欧拉定理和费马小定理，为此首先介绍这两个定理。  
【定理2.29】（欧拉定理）设$m$ 是任一正整数，$a$ 是任一与$m$ 互素的整数，则有：  
$$
a^{\varphi(m)}\equiv1({\bmod{\ m}})\tag{2-15}
$$  
其中$\varphi(m)$是欧拉函数。  
如果上述猜想能够成立，则提供了一个非常有效的素数判定方法。但是遗憾的是，上述猜想并不成立。事实上，$p$ 为只要是素数，则其必满足上式，但反之不然。法国数学家给出了如下称之为费马小定理更一般结论：  
【定理2.30】（费马小定理）假设$p$ 是一个任意给定的素数，则对于任意整数$a$，有：  
$$
a^{p}\equiv a({\bmod{\ p}})\tag{2-16}
$$  
特别地，当$a$与$p$ 互素时，有：$a^{p-1}\equiv1({\bmod{\ p}})$。  
下面介绍RSA 算法的基本原理和具体计算过程。RSA 算法理论基础是同余算术以及欧拉定理和费马小定理，其安全性依赖于大整数素因子分解的困难性，即已知整数$n$ 是两个大素数$p$ 和$q$ 的乘积，则难以在可接受的时间范围内通过$n$ 的素因子分解方法获得$p$ 和$q$ 的取值。RSA 算法的密钥生成、加密、解密的具体过程如下：  
1） 密钥的生成  
首先生成两个互不相同的大素数$p$ 和$q$，并令$n=p\cdot q$。其中$p$ 和$q$ 是属于解密信息，不可对外公开，整数$n$ 属于加密信息，需要对外公开。  
然后，令$\varphi(n)=(p-1)(q-1)$，并任意选择一个与$\varphi(n)$互素的正整数$e$，满足：  
$2\leq e\leq\varphi(n)$  
其中$\varphi(n)$不可对外公开，$e$ 为加密密钥，需要对外公开。  
由于$p$ 和$q$ 都是素数，故小于$p$ 且与$p$ 互素的非负整数的个数为$(p-1)$个，小于$q$ 且与$q$ 互素的非负整数的个数为$(q-1)$个。注意到$n=p\cdot q$，由计数的乘法原理及素数的性质可知，小于$\cdot n$且与$n$互素的非负整数的个数为$(p-1)$ $(q-1)$个，因此，$\varphi(n)=(p-1)(q-$1)其实就是欧拉函数。  
由于$e$ 的模$\varphi(n)$互素，因此$e$ 的模$\varphi(n)$同余逆$d$存在且唯一。算出$e$ 的模$\varphi(n)$同余逆$d$，使其满足：  
$$
e d\equiv1({\bmod{\ }}\varphi(n))\tag{2-17}
$$  
整数$d$ 属于解密密钥，不可对外公开。  
由此得到RSA 加密算法中作为公钥的加密密钥$e$，作为私钥的解密密钥$d$。  
2） 加密过程  
在RSA 加密算法中，要将明文信息转化成若干组整数序列。为此，首先将每个字母翻译成相应的整数，例如可以使用前述的凯撒加密算法完成这项工作。然后，将这些由明文字母对应的整数合并成若干组，每个组分别形成一个大整数，代表一个字母段。  
RSA 加密过程其实就是每个表示明文字母段的大整数$M$逐个转化为表示密文字母段的大整数$C$，具体转化公式如下：  
$$
C=M^{e}{\pmod{n}}\tag{2-18}
$$  
在转化过程中总是假定$M<n$。如果$M\geq n$，则需要对表示明文的所有整数重新进行分组以确保每个字母段对应的大整数小于$n$。  
3） 解密过程  
由于$d$ 是$e$ 的模$\varphi(n)$逆，即是$e$ 的模$(p-1)(q-1)$逆，故有：  
$$
e d\equiv1(\bmod(p-1)(q-1))\tag{2-19}
$$  
也就是说，$_{e d}$除以$(p-1)(q-1)$的余数为1，故存在整数$k$，使得：  
$$
e d={\begin{array}{l}{(p-1)(q-1)k+1}\end{array}}
$$  
故有：  
$$
C^{d}\equiv(M^{e})^{d}\equiv M^{e d}\equiv M^{(p-1)(q-1)k+1}\,({\mathrm{mod}}\,\,n)
$$  
假定$M$与$p$ 和$q$ 均为互素，则根据费马小定理有：  
$$
M^{p-1}\equiv1(\mathrm{\;mod}\;\left(p\right))\mathcal{X}M^{p-1}\equiv1(\mathrm{\;mod}\;\,q)
$$  
从而有：  
$$
\begin{array}{r}{C^{d}\equiv M^{(p-1)(q-1)k+1}\equiv\!\!M\!\cdot\!(M^{p-1})^{k(q-1)}\!\!\equiv\!\!M\!\cdot\!1\!\equiv\!\!M\,(\mathrm{mod}\,p)}\\ {C^{d}\equiv M^{(p-1)(q-1)k+1}\equiv\!\!M\!\cdot\!(M^{q-1})^{k(p-1)}\!\!\equiv\!\!M\!\cdot\!1\!\equiv\!\!M\,(\mathrm{mod}\,q)}\end{array}
$$  
由于$p$ 与$q$ 互素，则根据中国余数定理，有：  
$$
C^{d}\equiv M\,({\sf m o d}\,\,\,p\cdot q)\mathbb{\bar{X}}C^{d}\equiv M\,({\sf m o d}\,\,\,n)
$$  
由于$M<n$，故必有：$M=C^{d}\;({\mathsf{m o d}}\;\,n)$  
因此，若已知解密密钥$d$，就可使用公式$M=C^{d}\,({\sf m o d}\,n),$对密文$C$ 进行解密。  
在RSA 加密和解密算法中，如果$p,\ q$ 被信息窃取者获得，则可算出$(p-1)(q-1).$。由于$e$ 是公开密钥，且$d$是$e$ 关于关于模$(p-1)(q-1)$的逆，则不难求出$d$，如此RSA 系统便被完全攻破，信息窃取者就会很容易获得加密的信息。  
RSA 算法中的素数都是十进制整数，怎样才能选择好的$p$ 和$q$，这是$R S A$ 加密算法最关键的问题。针对素数$p$ 和$q$ 的选择，1978 年Rivest 等人在关于RSA 公开密钥的论文中，建议对素数$p$ 和$q$ 的选择应当满足：  
1）$p$ 和$q$ 要足够长，在长度上应相差几位，且二者之差与$p$ 和$q$ 位数相近；  
2）$p{-}1$ 和$q{-}1$ 的最大公约数$\operatorname*{gcd}(p -1\,,\,\,\,q-\!\!1)$要尽量小；  
3）$p{-}1$ 和$q{-}1$ 均应至少含有一个大的素数因子。  
并把满足这些条件的素数称为安全素数。  
从实用的观点看，如果加密后的信息能够保证在足够长的时间内不能被破解，则认为这个加密方法是安全的。相对于RSA 加密算法而言，如果整数$n$ 不是足够大，例如只有10 位，那么按照计算机目前的计算能力，几乎可以立刻求出其所有素因子实现对RSA 加密算法的破解。如果计算机的计算能力得到进一步的提高，则或许能够破解200 位的整数$n$。但是，如果使用200 素数$p$ 和200 位素数$q$ 构成400 位整数$n$，则计算机无法破解由此设计的RSA加密算法。因此，就目前以及今后一段时间而言，RSA 加密算法具有较好的安全性。"
正则图,定义,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.2.2 图模型的度结构']","{'实体类型': '定义', '内容': '如果图 $G$ 中各个结点的度数均相同，则称该图正则图，各结点度均为 $k$ 的正则图称为 $\\\\pmb{k}$-正则图'}",,3,"现在我们考察图模型的结构特征。从结构上看，对于任意给定的一个图模型，只要该图不是零图，总会有一些点与一些边相互联结。从生成子图的概念可以看出，图的结点构成了图模型的骨架或主体结构，因此，我们主要从结点出发考察每个结点所关联的边关联多少条边。为此，对于图中的每个结点，都定义一个数来描述该结点所关联边的个数，这就是结点度的概念，其具体定义如下：  
【定义8.16】假设图 $G=\langle V,E\rangle$是任意给定的一个无向图，对于$G$中任意一个结点 $v$ ，与该结点关联边的条数称为该结点的度数，简称为度，记为 ${\sf d e g}(v)$。图$G$中各个结点度数的最大值称为图$G$的最大度，记为$\Delta(G)$；图$G$中各个结点度数的最小值称为图$G$的最小度，记为$\delta(G)$ $\Delta(\mathrm{G})=\mathrm{max}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\};\,\,\,\delta(\mathrm{G})=\mathrm{min}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\}\,.$  
【定义8.17】设图 $G=\langle V,E\rangle$是任意给定的一个有向图，$v$是$G$中任一结点，则有：  
（1）以该结点为起点的有向边的条数，称为该结点的出度，记为$\deg^{+}(v)$；以该结点为终点的有向边的条数，称为该结点的入度，记为 $\deg^{-}(v)$。  
（2）该结点的出度与入度之和称为该结点的度，记为${\sf d e g}(v)$。 即有：  
$$
\deg(v)=\deg^{+}(v)+\deg^{-}(v)
$$  
（3）图$G$中各个结点出度与入度的最大值分别称为图$G$的最大出度和最大入度，分别记为$\Delta^{+}(\mathsf{G})$和 $\Delta^{-}(\mathsf{G})$；图$G$中各个结点出度与入度的最小值分别称为图$G$的最小出度和最小入度，分别记为$\Delta^{+}(\mathbf{G})$和 $\Delta^{-}(\mathsf{G})$，即有：  
$\Delta^{+}(\mathrm{G})=\operatorname*{max}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\Delta^{-}(\mathrm{G})=\operatorname*{max}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$ $\delta^{+}(\mathrm{G})=\operatorname*{min}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\delta^{-}(\mathrm{G})=\operatorname*{min}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$  
从上述定义可以看出，引入度结点度概念的目的主要是通过对图中每个结点所关联边数进行统计分析来考察图模型的结构特征。  
【定义8.18】对于任意一个给定的有向图或无向图  $G=\langle V,E\rangle$ ，图中度数为1 的结点称为该图的悬挂结点，图中以悬挂结点为端点的边称为该图的悬挂边。如果图$G$中各个结点的度数均相同，则称该图正则图，各结点度均为$\ k$的正则图称为$\pmb{k}$-正则图。  
下面我们考察图的邻接矩阵与图中结点度之间的关系。  
假设 $G=\langle V,E\rangle$是任意给定的一个有向图或无向图，其中$V=\{v_{1},v_{2},\ldots,v_{n}\}$，$E=$$\{e_{1},e_{2},\ldots,e_{m}\}$。 $G$的邻接矩阵为：  
$$
A=(a_{i j})_{n\times n}=\left(\!\!{\begin{array}{c c c c}{a_{11}}&{a_{12}}&{\ldots}&{a_{1n}}\\ {a_{21}}&{a_{22}}&{\ldots}&{a_{2n}}\\ {\vdots}&{\ddots}&{\vdots}\\ {a_{n1}}&{a_{n2}}&{\ldots}&{a_{n n}}\end{array}}\!\!\right)
$$  
则有如下结论：  
（1）如果$G$是无向图，那么邻接矩阵𝐴中第𝑖行元素之和表示结点$v_{i}$的度数，第𝑗列元素之和表示结点$v_{j}$的度数。即有：  
$$
\deg(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};~~~~\deg\bigl(v_{j}\bigr)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（2）若G是有向图，那么邻接矩阵$A$中第𝑖行元素之和表示结点$v_{i}$的出度，第$j$列元素之和表示结点$v_{j}$的入度。简单地说，就是竖入横出。即有：  
$$
\deg^{-}(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};\qquad\deg^{+}\!\left(v_{j}\right)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（3）对于有向图G，注意到：  
$$
\sum_{j=1}^{n}\;\deg^{-}\!\left(v_{j}\right)=\sum_{i=1}^{n}\sum_{j=1}^{n}a_{i j}=\sum_{i=1}^{n}\deg^{+}\!\left(v_{i}\right)
$$  
因此，有向图中所有入度之和等于所有出度之和，这个和其实就是图的边数$m$。因为有向图的每条边均产生且仅产生一个出度和一个入度。  
对于图8-19 所示图模型$G$及如下邻接矩阵$A_{G}$，容易验证，结点度与邻接矩阵之间的数量关系。例如，$A_{G}$中第三行元素之和为3，即$v_{3}$的出度为3。
$$
\begin{gathered}v_{1}\quad v_{2}\quad v_{3}\quad v_{4}\quad v_{5}\\A_{G}=\begin{matrix}v_{1}\\v_{2}\\v_{3}\\v_{4}\end{matrix}\begin{pmatrix}0&1&0&0&0\\0&1&1&0&0\\1&1&0&1&0\\0&0&0&0&0\\0&0&0&0&0\end{pmatrix}\end{gathered}
$$  
关于图中结点度数与边的关系，有如下著名的图论基本定理：  
【定理8.1】（握手定理）假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，则该图中结点度数的总和等于边数的二倍，即有：  
$$
\sum_{v\in V}\deg(v)=2|E|
$$  
【推论8.1】图中度数为奇数的结点个数必为偶数。  
从以上定理及例题可以看出，图模型中结点的度从一种定量的角度反映了图中结点与边之间的制约关系，在一定程度上刻画了图模型的结构特征。为了更加方便地描述图模型中各个结点的度结构信息，下面给出度序列的概念：  
【定义8.19】假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，图中每个结点的图构成的自然数序列称为$G$的度序列。也就是说，若 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，则称序列：  
$$
(\deg(v_{1})\,,\deg(v_{2})\,,\cdots,\deg(v_{n}))
$$  
为图 $G$ 的度数序列，简称为度序列。 此外，对于任意一个给定的自然数序列，如果该序列能够成为某个图的度序列，则称该序列为可图化序列。  
例如，对于图8-22 所示图 $G$ ，其度数序列为 (2,3,3,4)  
![图8-22 图 $G$ ](images/77ba680d9b589e032065b86071c3f75473dc0d06736af0deb36aa2115de43d51.jpg)  
由于图模型的度要满足握手定理等基本约束要求，而且对于不同类型的图，其度序列也会有一些相应的数据特征。因此，并不是任意的自然数序列都可以构成图模型的度序列。对于任意给定的自然数序列，需要通过分析其数据特征来判断其是否为可图化序列。若是可图化序列，则可依据该序列数据来分析其所对应图的结构特征。"
残留网络,概念,"['第十章  特殊图模型与算法', '§ 10.4 网络流图及其优化问题', '10.4.1 流网络与切割']","{'实体类型': '概念', '定义': '由网络流图中所有边残留容量构成的带权有向图', '特点': '边残留容量为c(u,v)-f(u,v)，具有双向带权边'}",,3,"首先介绍流网络模型的相关基本概念及其数据描述。如同每条公路有运输量、每根水管有最大流量限制一样，网络流图的每条边都有容量，或者说每条边都有一定的流量。网络流图其实就是每条边具有附带容量（可理解为权值）的有向图。其具体定义如下：  
【定义10.4.1】设有向图$G=\langle V,E\rangle$，$V$中包含一个源结点𝑠和一个汇结点$t$，且每条边$(u,v)\in E$均有一个非负容量$c(u,v)\geq0$，若$(u,v)\notin E$，则规定其容量$c(u,v)=0$，此时称有向图$G$是一个网络流图，简称为流网络或网络。源结点$s$即起点，汇结点$t$即终点。网络流是定义在网络$G$中关于边的一个实函数，用$f(u,v)$表示有向边$(u,v)\in E$上结点$ u$到结点$v$的网络流。$f(u,v)$表示$u$ 到$v$的净流。  
例如，如果$_{u}$到$v$有6 个单位的实际流，且$v$到$u$有3 个单位的实际流，那么$f(u,v)=$3，$f(v,u)=-3$，互为相反数。净流是实际通过的流量矢量和，可类比合力的概念。  
满足以下三个性质的网络流$f$称之为可行流：  
（1）容量限制：对所有的$(u,v)\in E$，都有$f(u,v)\leq c(u,\textit{}v)$。即一条边的流不能超过它的容量。这也很容易理解，如同自来水管的水流自然不会超过水管本身的容量。  
（2）斜对称：对所有$(u,v)\in E$，都有$f(u,v)=-f(v,u)$。即点$\cdot u$到$v$的净流必须与点𝑣到$u$的净流相反。可以类比物理中矢量概念，如作用力与反作用力，强调的是其方向性。  
（3）流守恒：对所有$u\in V-\{s,t\}$，都有$\textstyle\sum_{v\in V}f(u,v)=0$。即除源结点$𝑠$和汇结点$𝑡$外，其余每个结点的净流之和为0。  
![图10-68 网络及可行流  ](images/bada5974bba3db0db4c82fa8e3076a8834542abfa1641f17fac232a32e6fee29.jpg)  
例如，如图10-68 所示，网络中定义网络流$f(u,v)$是一条可行流。图中每条边所对应的序偶表示该边的容量和流量，第一个数字表示边的容量，第二个数字表示边的流量。  
下面结合图10-68 所示网络实例介绍网络流模型中与边相关的几个概念。可根据边的容量与流的大小关系对网络中的边进行分类：  
（1）满足$f(u,v)=c(u,v)$的边称为饱和边，如边(1,2)、 (2,3)  
（2）满足$f(u,v)<c(u,v)$的边称为非饱和边，如边(2,4)。  
（3）满足 $f(u,v)=0$ 的边称为零流边，如边 (3,4) ；满足 $f(u,v)>0$ 的边称为非零流 边，如边(5,4)。  
（4）既不是零流边也不是饱和边的边，称为弱流边，如边(5,6)  
如果把图10-78 看作是一个公路网，6 个结点分别表示6 座城镇，每条边上的权数表示两城镇间的距离。若现在需要从起点1 将一些物资运送到终点6，应怎样选择路线才能使总运输距离最短。我们知道，这样一类问题称为最短路径问题。类似的，如果把图10-1看作为一个输油管道网，结点1表示为发送点，结点6表示为接收点，其它点表示为中转站，各边的权数表示该段管道的最大运输油量。那么如何安排输油线路才能使从1到6的总运输量最大。这样一类问题就是最大流问题。  
最大流问题是网络优化中的一个典型的问题，简单地说，就是在满足容量约束的前提下将尽可能多的流从源结点流向汇结点。因此，最大流问题就是求流网络$G$中使其流量$f$达到最大的一个可行流，该可行流即为最大流。具体定义如下：  
【定义10.4.2】设有向图$G=\langle V,E\rangle$是任意给定的一个网络流图，若$f$是$G$ 中流量最大的的可行流，则称该可行流$f$是$G$ 的最大流，构构造网络流图$G$ 中最大流的问题，就称为网络流图的最大流问题。  
为了实现对最大流问题的求解，必须对网络流图中的增流空间进行合理的度量，通常使用一种名为残留网络的图模型实现这项工作。残留网络的具体定义如下：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图， $f$为$G$的一个流，对于$G$的任意一条边$(u,v)$，在不超过容量$c(u,v)$条件下，从$u$到$v$可压入的额外流量，称为$(u,v)$的残留容量。由$G$中所有边残留容量构成的带权有向图称为$G$的残留网络，记为$G_{f}=\langle V,E_{f}\rangle$。  
若$c_{f}(u,v)$为残留网络$G_{f}$中边$(u,v)$的残留容量，且边$(u,v)\in E$或边$(v,u)\in E$，则$(u,v)\in$$E_{f}$,$\,c_{f}(u,v)=c(u,v)-f(u,v)\,$。例如，若设$(u,v)$当前流量为(4,3)，此时$c(u,v)=4$，$f(u,v)$）$=3$，则有：$c_{f}(u,v)=1$。  
需要注意的是，残留网络具有这样的性质：假设从$_{.}u$到$v$已经有了3 个单位流量，那么从反方向上看，也就是从$v$ 到$u$ 就有了3 个单位的残留容量，这时$c_{f}(v,u)=3$。换句话说，从$u$ 到$v$ 有3 个单位流量，那么从$v$到$u$ 就有了将这3 个单位流量压回去的能力。因此，残留网络结点之间通常由双向带权边进行联结。例如，对于图10-69（a）所示的一个流网络$G$，图10-69（b）则表示该流网络𝐺的残留网络。  
![图10-69 流网络及其残留网络 ](images/d65d1c72064671125468548ae171a28ede5424f1d36d601972ed76c90131fc8c.jpg)  
对于任意给定的一个网络流图$G=\langle V,E\rangle$，可以通过其残留网络$G_{f}=\langle V,E_{f}\rangle$求得$G$的最大流。基本思路如下：首先，对所有的结点令初始状态时流的值为0，即对于$\forall u,v\in V$，有$f(u,v)=0$。然后，通过迭代方式其残留网络中不断寻找源点𝑠到汇点$t$之间的流量增广路径来增加网络流量值，直到残留网络没有这样的增广路径为止。  
因此，在残留网络$G_{f}=\langle V,E_{f}\rangle$寻找流量增广路径是最大流求解算法的关键。为正确理解该算法，现给出流网络增广路径的具体定义：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，$G_{f}=\langle V,E_{f}\rangle$为$G$在流$f$下的一个残留网络，则$G_{f}=\langle V,E_{f}\rangle$中任意一条从源点$s$到汇点$t$的简单路径$p$称为$G=\langle V,E\rangle$的一条流量增广路径，简称为增广路径。  
事实上，可将增广路径形象地理解为网络流图$G$中从源点𝑠到汇点𝑡的一条不违反流网络边容量限制的路径，并向这条路径压入一定的流量，以增加整个网络的流量值。例如，图10-69（b）所示的残留网络存在这样一条如图10-70 中加粗有向边所示的增广路径。  
![图10-70 增广路径 ](images/1e52dc98ce8f5b49283b093dbb72c0d5308ccdc9782306a98cb168474d58608f.jpg)  
![图10-71 流网络的一个切割](images/c52dd38b6f7d2bc46bb57e2440709d67355577a7b3d5fb2e920f10a5bfeb8598.jpg)  
若将图10-70 所示增广路径在流网络所对应每条边的流量增加4 个单位，得到一个新的流网络，其流量比原网络多4 个单位。然后，在新流网络所对应的残留网络中继续寻找新增广路径，直到找不到新增广路径为止。显然，现在的问题是：如果在残留网络$G_{f}=$$\langle V,E_{f}\rangle$中找不到增广路径，此时该残留网络所对应的流$f$是否就是流网络$G=\langle V,E\rangle$的最大流？要解决这个问题，必须进一步引入流网络切割的相关概念，具体如下：  
【定义10.4.4】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，如果将$G$的结点集合𝑉划分为𝑆和$T=V-S$两部分，使得源点$s\in S$且$t\in T$，则称$(S,T)$是$G=\langle V,E\rangle$的一个切割，简称为割。从集合 𝑆 到集合 𝑇 的所有有向边容量之和称为切割 $(S,T)$ 的容量，穿过切割 $(S,T)$所有边流量的代数和流量称为切割$(S,T)$的净流量，记为$f(S,T)$。  
主要注意的是，定义10.4.4 中边的流量带有正负方向，如果流从结点𝑆流向$T$，则该边的流量值为正，如果流从结点𝑇流向𝑆，则该边的流量值为负。例如，对图10-69（a）所示的流网络，可画一个如图10-71 所示的切割$(S,T)$，其容量为：  
$$
c(u,w)+c(v,x)=12+14=26
$$  
穿过该切割的净流量为：  
$$
f(u,w)+f(v,x)-f(w,v)=12+11-4=19
$$  
显然，对于任意一个切割，穿过该切割的净流量上界就是该切割的容量，即穿过切割的净流量不可能超过割的容量。由于流网络中所有切割的流都相等并且等于网络的流，因此，网络最大流必然无法超过网络的最小割。由此得到如下最大流最小割定理：  
【定理10.4.1】（最大流最小割定理）设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和$t$分别为其源点和汇点，则$G=\langle V,E\rangle$的最大流量等于其最小割切的容量。对于$G=\langle V,E\rangle$上的任意一个流$f$，以下三个结论彼此等价：  
(1) $f$是流网络$G=\langle V,E\rangle$的一个最大流；  
(2) 流网络$G=\langle V,E\rangle$的残留网络中不包括任何增广路径；  
(3) 存在流网络$G=\langle V,E\rangle$的某个切割$(S,T)$，满足：
$$
f(S,T)=c(S,T)
$$"
水容器问题,问题,"['第四章  谓词演算与推理', '§ 4.5 谓词逻辑的应用', '4.5.2 水容器问题']","{'实体类型': '问题', '定义': '通过操作两个容器使大容器中有特定量的水', '条件': '初始容器为空，允许三种操作', '结论': '大容器装4升水，小容器不限'}",,3,"设有两个分别能盛7 升与5 升的水容器，初始均为空，允许对容器做以下三种操作：  
（1） 向容器倒满水；  
（2） 将容器中的水倒光；  
（3） 从一个容器倒水至另一个容器，使一个容器倒光或另一容器倒满。最后要求能使大容器（能盛7 升的容器）中有4 升水，并求其操作过程。  
用一个谓词𝑆（𝑢，𝑣）表示两个容器的盛水状态，如𝑆（3，1）表示大容器盛3 升，小容器盛1 升。  
因此在这个问题中的公理系统为：（1）开始时两个容器为空；（2）允许做三种操作。要求得到的结论为：大容器装4 升水，小容器不限。  
上述问题可用如下语句表示：  
开始时两个容器均为空：𝑆（0，0）；  
向大容器倒满水：$(\forall x)\ (\forall y)\ (S\ (x,\ y)\ \to S\ (7,\ y))$；  
向小容器倒满水：$(\forall x)\ (\forall y)\ (S\ (x,\ y)\ \rightarrow S\ (x,\ 5))$；  
将大容器的水倒光：$(\forall x)\ (\forall y)\ (S\ (x,\ y)\ \to S\ (\,0,\ y))$；  
将小容器的水倒光：$(\forall x)\ (\forall y)\ (S\ (x,\ y)\ \rightarrow S\ (x,\ 0))$；  
从容器$x$ 将水倒至$y$，使$x$空：$(∀𝑥)(∀𝑦)(∃𝑧) (𝑆(𝑥，𝑦) →𝑆(0，𝑧))$ ，$𝑥+ 𝑦= 𝑧，𝑧≤5$；  
从容器$y$ 将水倒至$x$，使$y$ 空：$(∀𝑥)(∀𝑦)(∃𝑧) (𝑆(𝑥，𝑦) →𝑆(𝑧，0))$，$𝑥+ 𝑦= 𝑧，𝑧≤7$；  
从容器$y$ 倒水至$x$，使$x$ 满：$(∀𝑥)(∀𝑦)(∃𝑧) (𝑆(𝑥，𝑦) →𝑆(7，𝑧))$，$𝑥+ 𝑦= 7 + 𝑧$；  
从容器$x$ 倒水至$y$，使$y$满：$(\forall x)(\forall y)(\exists z)\left(S\!\left(x,\,\,y\right)\to S\!\left(z,\,\,5\right)\right)$ ，$𝑥+ 𝑦= 𝑧+ 5$。  
所求的结论为：$S$（4，0）。  
$\begin{aligned}
&(1) S (0, 0) &&\text{P}\\
&(2) (\forall x) (\forall y) (S (x, y) \to S (7, y)) && \text{P} \\
&(3) (\forall y) (S (0, y) \to S (7, y))&& US, (2) \\
& (4) S (0, 0) \to S (7, 0) && US, (3) \\
&(5) S (7, 0)&& T, (1), (4), \mathrm{I} \\
&(6) (\forall x)(\forall y)(\exists z)\left(S(x, y)\to S(z, 5)\right)&& \text{P} \\
&(7) (\forall y)(\exists z)\left(S\big(7, y\big)\to S\big(z, 5\big)\right)&& US, (6) \\
&(8) (\exists z)\left(S\big(7, 0\big)\to S\big(z, 5\big)\right)&& US, (7) \\
& (9) S(7, 0)\to S(2, 5) && ES, (8) \\
&10 ) S(2, 5) && T, (5), (9), \mathrm{I} \\
& (11) (\forall x) (\forall y) (S (x, y) \to S (x, 0)) && \text{P} \\
&(12)\quad(\forall y) (S (2, y) \to S (2, 0))&& US, (11) \\
&(13) S\big(2, 5\big)\to S\big(2, 0\big)&& ES, (12) \\
& (14) S(2, 0) && T, (10), (13), \mathrm{I} \\
&( 15 ) (\forall x)(\forall y)(\exists z)\left(S(x, y)\rightarrow S(0, z)\right)&& \text{P} \\
&(16) (\forall y)(\exists z)\left(S\bigl(2, y\bigr)\rightarrow S\bigl(0, z\bigr)\right)&& US, (15) \\
&(17) (\exists z)\Big(S\big(2, 0\big)\to S\big(0, z\big)\Big)&& US, (16) \\
& (18) S\bigl(2, 0\bigr)\rightarrow S\bigl(0, 2\bigr) && ES, (17) \\
&( 19 ) S(0 , 2)&& T, (14), (18), \mathrm{I} \\
& (20) (\forall x) (\forall y) (S (x, y) \to S (7, y)) && \text{P}
\\&(21)\quad(\forall y) (S (0, y) \to S (7, y))\quad&& US, (20)\end{aligned}$  
$\begin{aligned}
&(22) S (0, 2) \to S (7, 2)&& US, (21) \\
&(23) S (7, 2)&& T, (19), (22), \mathrm{I} \\
&(24) (\forall x)(\forall y)(\exists z)\Big(S\big(x, y\big)\rightarrow S\big(z, 5\big)\Big)&& \text{P} \\
&(25) (\forall y)(\exists z)\left(S(7, y)\rightarrow S(z, 5)\right)&& US, (24) \\
&(26) (\exists z)\Big(S\big(7, 2\big)\to S\big(z, 5\big)\Big)&& US, (25) \\
&(27) S\big(7, 2\big)\to S\big(4, 5\big)&& ES, (26) \\
&(28) S(4, 5)&& T, (23), (27), \mathrm{I} \\
&(29) (\forall x) (\forall y) (S (x, y) \rightarrow S (x, 0))&& \text{P} \\
&(30)\quad(\forall y) (S (4, y) \rightarrow S (4, 0))&& US, (29) \\
&(31)S(4, 5) \to S(4, 0)&& US, (30) \\
&(32)S(4,0)&& T, (28), (31), \mathrm{I}
\end{aligned}$  
上述推导过程如图4-4 所示：  
![](images/7fd9db7f4d707c709f0cb5214a897d2f9fdc915f8ef2986abce312f2e7c7143c.jpg)
图4-4 水容器问题求解过程"
永假公式,性质,"['第三章  命题演算与推理', '§ 3.2 命题公式与等值演算', '3.2.1 命题公式的基本知识', '三、命题公式的基本类型']","{'实体类型': '性质', '条件': 'G在所有解释下的真值取值都为假', '关系': '命题公式G为永真式，当且仅当¬G为永假式'}",,4,"如表3-7 所示，有些命题公式在任何解释下均为真，例如 $(P\land(P\rightarrow Q))\rightarrow Q$；有些命题公式则在任何解释下均为假，例如$\neg(P\to Q)\land Q$；有些命题公式则在一些解释下为真、在另一些解释下为假，例如$P\rightarrow Q$。  
表3-7   命题公式真值的基本类型
![](images/ada5d39d23c2aab3e5ff74aa9eea0cba51046190f43c79f376715f46f49cb38f.jpg)  
![](images/cd9a8308cc683710575b4eca9243b69a0a582e5f86c663d5bdcde36ca15c8940.jpg)  
由此可将命题公式分为永真、永假和可满足这三种基本类型，具体定义如下：  
【定义3.12】对于任给定的命题公式$G$  
（1）如果$G$在所有解释下的真值取值都为真，则称其为永真公式或重言式；  
（2）如果$G$在所有解释下的真值取值都为假，则称其为永假公式或矛盾式；  
（3）如果命题公式不是矛盾式，则称其为可满足式。  
根据上述定义，不难看出这三类公式之间的基本关系：  
（1）命题公式$G$为永真式，当且仅当¬G为永假式。  
（2）若命题公式$G$为永真式，则𝐺必为可满足式；反之不然。  
（3）若命题公式$G$为可满足式，当且仅当至少存在一种解释$I$，使得$G$为真。"
永真公式,性质,"['第三章  命题演算与推理', '§ 3.2 命题公式与等值演算', '3.2.1 命题公式的基本知识', '三、命题公式的基本类型']","{'实体类型': '性质', '条件': 'G在所有解释下的真值取值都为真', '关系': '命题公式G为永真式，当且仅当¬G为永假式'}",,4,"如表3-7 所示，有些命题公式在任何解释下均为真，例如 $(P\land(P\rightarrow Q))\rightarrow Q$；有些命题公式则在任何解释下均为假，例如$\neg(P\to Q)\land Q$；有些命题公式则在一些解释下为真、在另一些解释下为假，例如$P\rightarrow Q$。  
表3-7   命题公式真值的基本类型
![](images/ada5d39d23c2aab3e5ff74aa9eea0cba51046190f43c79f376715f46f49cb38f.jpg)  
![](images/cd9a8308cc683710575b4eca9243b69a0a582e5f86c663d5bdcde36ca15c8940.jpg)  
由此可将命题公式分为永真、永假和可满足这三种基本类型，具体定义如下：  
【定义3.12】对于任给定的命题公式$G$  
（1）如果$G$在所有解释下的真值取值都为真，则称其为永真公式或重言式；  
（2）如果$G$在所有解释下的真值取值都为假，则称其为永假公式或矛盾式；  
（3）如果命题公式不是矛盾式，则称其为可满足式。  
根据上述定义，不难看出这三类公式之间的基本关系：  
（1）命题公式$G$为永真式，当且仅当¬G为永假式。  
（2）若命题公式$G$为永真式，则𝐺必为可满足式；反之不然。  
（3）若命题公式$G$为可满足式，当且仅当至少存在一种解释$I$，使得$G$为真。"
永真蕴含,概念,"['第三章  命题演算与推理', '§ 3.5 命题逻辑的演绎推理', '3.5.1 永真蕴含关系与判定', '一、永真蕴含的概念与性质']","{'实体类型': '概念', '定义': '设G(P1,P2,⋯,Pn)和H(P1,P2,⋯,Pn)是任意两个具有相同命题变量的命题公式，如果对于P1,P2,⋯Pn的任意一组真值指派，G(P1,P2,⋯Pn)的真值总是不大于H(P1,P2,⋯Pn)的真值，则称G(P1,P2,⋯Pn)永真蕴含H(P1,P2,⋯Pn)', '本质含义': '若G(P1,P2,⋯Pn)真，则H(P1,P2,⋯Pn)必为真，或者说由G(P1,P2,⋯Pn)为真可符合逻辑地推出H(P1,P2,⋯Pn)也为真'}",,4,"如同命题公式的等值关系相当于多项式的恒等式关系，命题公式的永真蕴含关系相当于多项式的不等式关系，表达的是命题公式真值的小于或等于关系。  
【定义3.27】设$G(P_{1},P_{2},\cdots,P_{n})$和$H(P_{1},P_{2},\cdots,P_{n})$是任意两个具有相同命题变量的命题公式，如果对于$P_{1},P_{2},\cdots P_{n}$的任意一组真值指派，$G(P_{1},P_{2},\cdots P_{n})$的真值总是不大于$H(P_{1},P_{2},\cdots P_{n})$的真值，即$v(G(P_{1},P_{2},\cdots P_{n}))\leq v(H(P_{1},P_{2},\cdots P_{n}))$，则称$G(P_{1},P_{2},\cdots P_{n})$永真蕴含$H(P_{1},P_{2},\cdots P_{n})$，记作$G(P_{1},P_{2},\cdots P_{n})\ \Rightarrow H(P_{1},P_{2},\cdots P_{n})$，且称$G(P_{1},P_{2},\cdots P_{n})$为永真蕴含的前件，$H(P_{1},P_{2},\cdots P_{n})$为永真蕴含的后件。  
从逻辑含义上看，命题公式$G(P_{1},P_{2},\cdots P_{n})$的真值总不大于$H(P_{1},P_{2},\cdots P_{n})$的真值就意味着：若 $G(P_{1},P_{2},\cdots P_{n})$ 真，则 $H(P_{1},P_{2},\cdots P_{n})$ 必为真，或者说由 $G(P_{1},P_{2},\cdots P_{n})$ 为真可符合逻辑 地推出$H(P_{1},P_{2},\cdots P_{n})$也为真。这正是命题公式之间永真蕴含关系“$\Rightarrow$”的本质含义。  
下面的定理表明命题公式的永真蕴含关系$\scriptstyle""\Rightarrow\ ""$与逻辑运算的蕴含联结词“${\rightarrow}$”之间有着非常紧密的联系。  
【定理3.11】设$G(P_{1},P_{2},\cdots P_{n})$和$H(P_{1},P_{2},\cdots P_{n})$是任意两个具有相同命题变量的命题公式，$G(P_{1},P_{2},\cdots P_{n})$永真蕴含$H(P_{1},P_{2},\cdots P_{n})$，有：$G(P_{1},P_{2},\cdots P_{n})\Rightarrow H(P_{1},P_{2},\cdots P_{n})$ 当且仅当命题公式$G(P_{1},P_{2},\cdots P_{n})\rightarrow H(P_{1},P_{2},\cdots P_{n})$为永真公式。  
下面定理表明了永真蕴含关系的基本性质：  
【定理3.12】命题公式的永真蕴含关系满足如下三条基本性质：  
（1）自反性：对任意命题公式𝐴，有$A\Rightarrow A$；  
（2）反对称性：对任意命题公式$\cdot A$，$B$，如果$A\Rightarrow B$，并且$B\Rightarrow A$，那么$A\Leftrightarrow B$  
（3）传递性：对任意命题公式𝐴，$B$，$C$，如果$A\Rightarrow B$，$B\Rightarrow C$，那么$A\Rightarrow C$。  
【定理3.13】设𝐴、$B$为任意两个命题公式，$A\Leftrightarrow B$的充分必要条件是$A\Rightarrow B$，且$B\Rightarrow A$"
永真蕴含与逻辑运算的蕴含联结词的关系,定理,"['第三章  命题演算与推理', '§ 3.5 命题逻辑的演绎推理', '3.5.1 永真蕴含关系与判定', '一、永真蕴含的概念与性质']","{'实体类型': '定理', '内容': '设G(P1,P2,⋯Pn)和H(P1,P2,⋯Pn)是任意两个具有相同命题变量的命题公式，G(P1,P2,⋯Pn)永真蕴含H(P1,P2,⋯Pn)，有：G(P1,P2,⋯Pn)⇒H(P1,P2,⋯Pn)当且仅当命题公式G(P1,P2,⋯Pn)→H(P1,P2,⋯Pn)为永真公式'}",,4,"如同命题公式的等值关系相当于多项式的恒等式关系，命题公式的永真蕴含关系相当于多项式的不等式关系，表达的是命题公式真值的小于或等于关系。  
【定义3.27】设$G(P_{1},P_{2},\cdots,P_{n})$和$H(P_{1},P_{2},\cdots,P_{n})$是任意两个具有相同命题变量的命题公式，如果对于$P_{1},P_{2},\cdots P_{n}$的任意一组真值指派，$G(P_{1},P_{2},\cdots P_{n})$的真值总是不大于$H(P_{1},P_{2},\cdots P_{n})$的真值，即$v(G(P_{1},P_{2},\cdots P_{n}))\leq v(H(P_{1},P_{2},\cdots P_{n}))$，则称$G(P_{1},P_{2},\cdots P_{n})$永真蕴含$H(P_{1},P_{2},\cdots P_{n})$，记作$G(P_{1},P_{2},\cdots P_{n})\ \Rightarrow H(P_{1},P_{2},\cdots P_{n})$，且称$G(P_{1},P_{2},\cdots P_{n})$为永真蕴含的前件，$H(P_{1},P_{2},\cdots P_{n})$为永真蕴含的后件。  
从逻辑含义上看，命题公式$G(P_{1},P_{2},\cdots P_{n})$的真值总不大于$H(P_{1},P_{2},\cdots P_{n})$的真值就意味着：若 $G(P_{1},P_{2},\cdots P_{n})$ 真，则 $H(P_{1},P_{2},\cdots P_{n})$ 必为真，或者说由 $G(P_{1},P_{2},\cdots P_{n})$ 为真可符合逻辑 地推出$H(P_{1},P_{2},\cdots P_{n})$也为真。这正是命题公式之间永真蕴含关系“$\Rightarrow$”的本质含义。  
下面的定理表明命题公式的永真蕴含关系$\scriptstyle""\Rightarrow\ ""$与逻辑运算的蕴含联结词“${\rightarrow}$”之间有着非常紧密的联系。  
【定理3.11】设$G(P_{1},P_{2},\cdots P_{n})$和$H(P_{1},P_{2},\cdots P_{n})$是任意两个具有相同命题变量的命题公式，$G(P_{1},P_{2},\cdots P_{n})$永真蕴含$H(P_{1},P_{2},\cdots P_{n})$，有：$G(P_{1},P_{2},\cdots P_{n})\Rightarrow H(P_{1},P_{2},\cdots P_{n})$ 当且仅当命题公式$G(P_{1},P_{2},\cdots P_{n})\rightarrow H(P_{1},P_{2},\cdots P_{n})$为永真公式。  
下面定理表明了永真蕴含关系的基本性质：  
【定理3.12】命题公式的永真蕴含关系满足如下三条基本性质：  
（1）自反性：对任意命题公式𝐴，有$A\Rightarrow A$；  
（2）反对称性：对任意命题公式$\cdot A$，$B$，如果$A\Rightarrow B$，并且$B\Rightarrow A$，那么$A\Leftrightarrow B$  
（3）传递性：对任意命题公式𝐴，$B$，$C$，如果$A\Rightarrow B$，$B\Rightarrow C$，那么$A\Rightarrow C$。  
【定理3.13】设𝐴、$B$为任意两个命题公式，$A\Leftrightarrow B$的充分必要条件是$A\Rightarrow B$，且$B\Rightarrow A$"
永真蕴含关系,性质,"['（1）真值表法', '二、基本永真蕴含关系', '§ 3.5 命题逻辑的演绎推理', '第四章  谓词演算与推理', '第三章  命题演算与推理', '4.2.4 谓词公式的等值与蕴含', '§ 4.2  谓词公式与等值演算', '三、永真蕴含关系判定法', '3.5.1 永真蕴含关系与判定']","{'实体类型': ['性质', '概念'], '定义': ['如果前提为真，那么结论必然为真', '在所有可能的情况下都为真的蕴含关系', '命题公式之间的永真蕴含关系', '谓词公式之间的永真蕴含关系'], '应用': ['作为命题逻辑演绎推理的基础', '简化命题公式的等值演算过程', '进行谓词逻辑的推理'], '特点': '通过真值表证明基本永真蕴含关系式，作为已知工具使用', '判定方法': ['真值表法', '等值演算法'], '判定': '通过真值表验证在每一种真值指派下A的真值都小于B的真值'}",,3,从数理逻辑的角度看，演绎推理就是从作为前提的命题公式中推出新的命题公式作为推理结论，而且前提与结论之间具有必然联系。这种必然联系就是如果前提为真，那么结论必然为真。因此，演绎推理的本质就是揭示前提与结论之间的这种永真蕴含关系。作为命题逻辑演绎推理的基础，本小节给出命题公式永真蕴含关系及其判定的基本知识。
永真蕴含关系与判定,性质,"['第三章  命题演算与推理', '§ 3.5 命题逻辑的演绎推理', '3.5.1 永真蕴含关系与判定', '三、永真蕴含关系判定法', '（2）公式演算法']","{'实体类型': '性质', '特点': '判定命题之间是否存在永真蕴含关系'}",,5,通过上述例子可以发现，对于永真蕴含关系的判定和证明，公式演算法与真值表法的基本思路几乎一样，二者的差别仅仅在于求解的表现形式不同，一个通过真值表的枚举，另外一个是通过命题公式的逻辑演算。
永真蕴含关系判定法,算法,"['§ 3.5 命题逻辑的演绎推理', '（2）公式演算法', '第三章  命题演算与推理', '三、永真蕴含关系判定法', '3.5.1 永真蕴含关系与判定']","{'实体类型': '算法', '解法': '①证明蕴含逻辑算式的永真性②假设前件为真，则后件也为真③假设后件为假，则前件也为假', '方法': '通过公式演算法或真值表法进行判定', '区别': '公式演算法通过命题公式的逻辑演算，真值表法通过真值表的枚举'}",,4,命题公式永真蕴含关系的判定主要有如下两种基本方法，即真值表法、等值演算法。其每一种判定方法都对应三种不同的解法：①证明蕴含逻辑算式的永真性②假设前件为真，则后件也为真③假设后件为假，则前件也为假。下面将结合实例介绍这两种基本判定方法：
永真蕴含关系的基本性质,定理,"['第三章  命题演算与推理', '§ 3.5 命题逻辑的演绎推理', '3.5.1 永真蕴含关系与判定', '一、永真蕴含的概念与性质']","{'实体类型': '定理', '自反性': '对任意命题公式A，有A⇒A', '反对称性': '对任意命题公式A，B，如果A⇒B，并且B⇒A，那么A⇔B', '传递性': '对任意命题公式A，B，C，如果A⇒B，B⇒C，那么A⇒C'}",,4,"如同命题公式的等值关系相当于多项式的恒等式关系，命题公式的永真蕴含关系相当于多项式的不等式关系，表达的是命题公式真值的小于或等于关系。  
【定义3.27】设$G(P_{1},P_{2},\cdots,P_{n})$和$H(P_{1},P_{2},\cdots,P_{n})$是任意两个具有相同命题变量的命题公式，如果对于$P_{1},P_{2},\cdots P_{n}$的任意一组真值指派，$G(P_{1},P_{2},\cdots P_{n})$的真值总是不大于$H(P_{1},P_{2},\cdots P_{n})$的真值，即$v(G(P_{1},P_{2},\cdots P_{n}))\leq v(H(P_{1},P_{2},\cdots P_{n}))$，则称$G(P_{1},P_{2},\cdots P_{n})$永真蕴含$H(P_{1},P_{2},\cdots P_{n})$，记作$G(P_{1},P_{2},\cdots P_{n})\ \Rightarrow H(P_{1},P_{2},\cdots P_{n})$，且称$G(P_{1},P_{2},\cdots P_{n})$为永真蕴含的前件，$H(P_{1},P_{2},\cdots P_{n})$为永真蕴含的后件。  
从逻辑含义上看，命题公式$G(P_{1},P_{2},\cdots P_{n})$的真值总不大于$H(P_{1},P_{2},\cdots P_{n})$的真值就意味着：若 $G(P_{1},P_{2},\cdots P_{n})$ 真，则 $H(P_{1},P_{2},\cdots P_{n})$ 必为真，或者说由 $G(P_{1},P_{2},\cdots P_{n})$ 为真可符合逻辑 地推出$H(P_{1},P_{2},\cdots P_{n})$也为真。这正是命题公式之间永真蕴含关系“$\Rightarrow$”的本质含义。  
下面的定理表明命题公式的永真蕴含关系$\scriptstyle""\Rightarrow\ ""$与逻辑运算的蕴含联结词“${\rightarrow}$”之间有着非常紧密的联系。  
【定理3.11】设$G(P_{1},P_{2},\cdots P_{n})$和$H(P_{1},P_{2},\cdots P_{n})$是任意两个具有相同命题变量的命题公式，$G(P_{1},P_{2},\cdots P_{n})$永真蕴含$H(P_{1},P_{2},\cdots P_{n})$，有：$G(P_{1},P_{2},\cdots P_{n})\Rightarrow H(P_{1},P_{2},\cdots P_{n})$ 当且仅当命题公式$G(P_{1},P_{2},\cdots P_{n})\rightarrow H(P_{1},P_{2},\cdots P_{n})$为永真公式。  
下面定理表明了永真蕴含关系的基本性质：  
【定理3.12】命题公式的永真蕴含关系满足如下三条基本性质：  
（1）自反性：对任意命题公式𝐴，有$A\Rightarrow A$；  
（2）反对称性：对任意命题公式$\cdot A$，$B$，如果$A\Rightarrow B$，并且$B\Rightarrow A$，那么$A\Leftrightarrow B$  
（3）传递性：对任意命题公式𝐴，$B$，$C$，如果$A\Rightarrow B$，$B\Rightarrow C$，那么$A\Rightarrow C$。  
【定理3.13】设𝐴、$B$为任意两个命题公式，$A\Leftrightarrow B$的充分必要条件是$A\Rightarrow B$，且$B\Rightarrow A$"
永真蕴含的充分必要条件,定理,"['第三章  命题演算与推理', '§ 3.5 命题逻辑的演绎推理', '3.5.1 永真蕴含关系与判定', '一、永真蕴含的概念与性质']","{'实体类型': '定理', '内容': '设A、B为任意两个命题公式，A⇔B的充分必要条件是A⇒B，且B⇒A'}",,4,"如同命题公式的等值关系相当于多项式的恒等式关系，命题公式的永真蕴含关系相当于多项式的不等式关系，表达的是命题公式真值的小于或等于关系。  
【定义3.27】设$G(P_{1},P_{2},\cdots,P_{n})$和$H(P_{1},P_{2},\cdots,P_{n})$是任意两个具有相同命题变量的命题公式，如果对于$P_{1},P_{2},\cdots P_{n}$的任意一组真值指派，$G(P_{1},P_{2},\cdots P_{n})$的真值总是不大于$H(P_{1},P_{2},\cdots P_{n})$的真值，即$v(G(P_{1},P_{2},\cdots P_{n}))\leq v(H(P_{1},P_{2},\cdots P_{n}))$，则称$G(P_{1},P_{2},\cdots P_{n})$永真蕴含$H(P_{1},P_{2},\cdots P_{n})$，记作$G(P_{1},P_{2},\cdots P_{n})\ \Rightarrow H(P_{1},P_{2},\cdots P_{n})$，且称$G(P_{1},P_{2},\cdots P_{n})$为永真蕴含的前件，$H(P_{1},P_{2},\cdots P_{n})$为永真蕴含的后件。  
从逻辑含义上看，命题公式$G(P_{1},P_{2},\cdots P_{n})$的真值总不大于$H(P_{1},P_{2},\cdots P_{n})$的真值就意味着：若 $G(P_{1},P_{2},\cdots P_{n})$ 真，则 $H(P_{1},P_{2},\cdots P_{n})$ 必为真，或者说由 $G(P_{1},P_{2},\cdots P_{n})$ 为真可符合逻辑 地推出$H(P_{1},P_{2},\cdots P_{n})$也为真。这正是命题公式之间永真蕴含关系“$\Rightarrow$”的本质含义。  
下面的定理表明命题公式的永真蕴含关系$\scriptstyle""\Rightarrow\ ""$与逻辑运算的蕴含联结词“${\rightarrow}$”之间有着非常紧密的联系。  
【定理3.11】设$G(P_{1},P_{2},\cdots P_{n})$和$H(P_{1},P_{2},\cdots P_{n})$是任意两个具有相同命题变量的命题公式，$G(P_{1},P_{2},\cdots P_{n})$永真蕴含$H(P_{1},P_{2},\cdots P_{n})$，有：$G(P_{1},P_{2},\cdots P_{n})\Rightarrow H(P_{1},P_{2},\cdots P_{n})$ 当且仅当命题公式$G(P_{1},P_{2},\cdots P_{n})\rightarrow H(P_{1},P_{2},\cdots P_{n})$为永真公式。  
下面定理表明了永真蕴含关系的基本性质：  
【定理3.12】命题公式的永真蕴含关系满足如下三条基本性质：  
（1）自反性：对任意命题公式𝐴，有$A\Rightarrow A$；  
（2）反对称性：对任意命题公式$\cdot A$，$B$，如果$A\Rightarrow B$，并且$B\Rightarrow A$，那么$A\Leftrightarrow B$  
（3）传递性：对任意命题公式𝐴，$B$，$C$，如果$A\Rightarrow B$，$B\Rightarrow C$，那么$A\Rightarrow C$。  
【定理3.13】设𝐴、$B$为任意两个命题公式，$A\Leftrightarrow B$的充分必要条件是$A\Rightarrow B$，且$B\Rightarrow A$"
沃舍尔∙弗洛伊德算法,算法,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.4.4 多源最短路径']","{'实体类型': '算法', '定义': '求解图中任意一对结点之间最短路径长度的算法', '基本思想': '通过逐次增加中介结点的途径，不断优化和更新图中每对结点之间的路径长度', '初始化': '将路径长度矩阵和路径记录矩阵初始化', '更新规则': '根据中介结点更新路径长度和路径记录矩阵', '最终结果': '通过路径长度矩阵和路径记录矩阵求出任意一对结点之间的最短路径'}",,3,"迪杰斯特拉算法解决的是单源最短路径问题，只能求出单独某个源点到其它结点最短路径，然而沃舍尔∙弗洛伊德算法则是求得这个图中任意对结点之间的最短路径长度。  
沃舍尔∙弗洛伊德算法的基本思想是通过逐次增加中介结点的途径，不断优化和更新图中每对结点之间的路径长度。首先，将$v_{1}$作为中介结点，据此更新图中仅以$v_{1}$作为中介结点的路径长度以及相应的路径记录。然后在$v_{1}$的基础上，进一步引入${{v}}_{2}$作为新增的中介结点，并更新图中仅以$v_{1}v_{2}$作为中介结点的路径长度和路径记录。依次类推，在$v_{1}v_{2}v_{3}\ldots v_{k}$作为中介结点的基础上，以$v_{k}$作为新增中介结点计算并更新图中以$v_{1}v_{2}v_{3}\ldots v_{k}$为中介结点的每对结点之间路径长度和路径记录。这样当$k=n$(𝑛为结点个数)时，便可求出图中每对结点的最短路径长度及其相应的路径记录。  
从上面描述的基本思想可以知道，在整个问题解决中有两个点非常重要，一个是路径长度，一个是路径记录，为了方便叙述，我们分别定义相应的矩阵用于记录数据，$D^{(k)}(v_{i},v_{j})$表示在考虑了$v_{1}v_{2}v_{3}\ldots v_{k}$作为中介结点的基础上，结点$v_{i}$与$v_{j}$的当前最短路径长度。$R^{(k)}(v_{i},v_{j})$ 是一个包含结点元素的矩阵，表示在考虑了$v_{1}v_{2}v_{3}\ldots v_{k}$作为中介结点的基础上，结点$v_{i}$与$v_{j}$的当前最短路径长度中必经的一个中间点。  
需要注意的是，在还没有考虑中介结点的最初情况时，应该按如下方法初始化$D$和$R$矩阵元素值，对于图中任意两个相邻结点$v_{i}$和$v_{j}$，即存在一条边$(v_{i},v_{j})$，边上权值为$w(v_{i},v_{j})$，那其长度为$D^{(0)}\big(v_{i},v_{j}\big)=w(v_{i},v_{j})$，否则规定$v_{i}$与$v_{j}$存在一条假想边$(v_{i},v_{j})$，令其长度为无穷大。另外，在尚未开始算法迭代时，将$\cdot R$矩阵每行内容分别置为$v_{j}(j=1,2,3\ldots n)$。  
下面以结点$v_{i}$到$v_{j}$为代表，详细介绍具体计算过程：  
首先，将$v_{1}$作为从$v_{i}$到$v_{j}$的中介结点，进行比较路径$\left(v_{i},v_{j}\right)$和$(v_{i},v_{1},v_{j})$长度的大小，若路径$\left(v_{i},v_{j}\right)$的长度不大于$\left(v_{i},v_{1},v_{j}\right)$的长度，那么取$(v_{i},v_{j})$为从$v_{i}$到$v_{j}$的当前最短路径，即$D^{(1)}\big(v_{i},v_{j}\big)=w(v_{i},v_{j})$，此时不需要更新路径记录矩阵$R$；若是路径$\left(v_{i},v_{1},v_{j}\right)$的长度较小，则取$\left(v_{i},v_{1},v_{j}\right)$为从$v_{i}$到$v_{j}$的当前最短路径，即：  
$$
D^{(1)}\big(v_{i},v_{j}\big)=w(v_{i},v_{1})+w\big(v_{1},v_{j}\big)
$$  
并将$v_{1}$暂时作为$v_{i}$到$v_{j}$的中间点，即$R^{(1)}{\bigl(}v_{i},v_{j}{\bigr)}=v_{1}.$。需要注意的是，当前最短路径中介结点序号不大于1，即当前最短路径只可能经由中介点$v_{1}$。  
对$v_{i}$到$v_{j}$的中介结点集合，再引入结点$v_{2}$，即$v_{i}$到$v_{j}$的中介结点为${v}_{1}$和$v_{2}$。首先确定$(v_{i},\ldots,v_{2})$和$(v_{2},\ldots,v_{j})$分别是当前找到的最短路径（只可能经由中介结点$v_{1}$），则$\left(v_{i},\ldots,v_{2},\ldots,v_{j}\right)$有可能是从$v_{i}$到$v_{j}$的最短路径（只可能经由中介结点$v_{1}$和$v_{2}$）。将其与当前从$v_{i}$到$v_{j}$的最短路径$(v_{i},\ldots,v_{j})$进行比较（只可能经由中介结点$v_{1}$），从中选出从${v}_{i}$到$v_{j}$的最短路径（此时只可能经由中介结点$v_{1}$和$v_{2}$），并按照上述的原则更新相应的$D$和$R$。如此下去，直到将图中所有结点加入${v}_{i}$到$v_{j}$的中介结点集合。  
对于一般情形， $(v_{i},\ldots,v_{k})$和$(v_{k},\ldots,v_{j})$分别是从${v}_{i}$到$v_{k}$和从${{v}}_{k}$到$v_{j}$的当前最短路径(中间路径只可能经过$v_{1}v_{2}v_{3}\ldots v_{k-1})$，则将$\left(v_{i},\ldots,v_{k},\ldots,v_{j}\right)$与从$v_{i}$到$v_{j}$的当前最短路径$\left(v_{i},\ldots,v_{j}\right)$（中间路径只可能经过$v_{1}v_{2}v_{3}\ldots v_{k-1})$）进行比较，其长度较短者便是从${v}_{i}$到$v_{j}$的当前最短路径（此时引入了$v_{k}$，故中间路径可能经由$v_{1}v_{2}v_{3}\ldots v_{k})$。若$(v_{i},\ldots,v_{k})$和$(v_{k},\ldots,v_{j})$ 组合起来的路径 $\left(v_{i},\ldots,v_{k},\ldots,v_{j}\right)$ 不大于引入中介结点 $v_{k}$ 的路径长度， 则当前路径长度矩阵 $.D$ 和路径记录矩阵$R$不做任何更新。否则：$\begin{array}{r}{D^{(k)}\big(v_{i},v_{j}\big)=w(v_{i},v_{k})+w\big(v_{k},v_{j}\big),\;\;R^{(k)}\big(v_{i},v_{j}\big)=}\end{array}$$v_{k}$。  
在中介结点集合中增加所有可能的中介结点后，最后求得最短路径的必然是从${v}_{i}$到$v_{j}$的最短路径。由$v_{i}$和$v_{j}$的任意性，可求得各对结点间的最短路径。  
具体地说，沃舍尔∙弗洛伊德算法的基本步骤如下：  
（1）首先进行初始化操作。  
![](images/81a82f8a70a1c69c5768fae83738a36908b9e06f149f4c5733693401ae15cac2.jpg)  
$$
R^{(0)}\big(v_{i},v_{j}\big)=v_{j}
$$  
（2）按如下的原则，将图中的每个结点$v_{k}(k=1,\!2,\dots,n)$分别作为中介结点，更新$D$和$R$矩阵，依次获得矩阵$D^{(1)},D^{(2)},\dots,D^{(n)}$和$R^{(1)},R^{(2)},\ldots,R^{(n)}$。  
(i)若$D^{(k-1)}\big(v_{i},v_{j}\big)>D^{(k-1)}(v_{i},v_{k})+D^{(k-1)}\big(v_{k},v_{j}\big),$  则，  
$$
D^{(k)}\!\left(v_{i},v_{j}\right)\!\!=\!\!D^{(k-1)}(v_{i},v_{k})\!+\!D^{(k-1)}\!\left(v_{k},v_{j}\right)\!;\,\,\,R^{(k)}\!\left(v_{i},v_{j}\right)=v_{k}
$$  
(ii)  若 $ D^{(k-1)}\!\left(v_{i},v_{j}\right)\leq D^{(k-1)}\!\left(v_{k},v_{j}\right)\!+\!D^{(k-1)}\!\left(v_{k},v_{j}\right)$ ，则，   $D^{(k)}\!\left(v_{i},v_{j}\right)\!\!=\!\!D^{(k-1)}\!\left(v_{i},v_{j}\right)\!;\,\,\,R^{(k)}\!\left(v_{i},v_{j}\right)=R^{(k-1)}\!\left(v_{i},v_{j}\right)$  
（3）根据矩阵${ D}^{(n)}$和$R^{(n)}$，计算任意结点之间的最短路径长度和路径序列。以$v_{i}$和$v_{j}$为例计算两者的最短路径序列：若$R^{(n)}=v_{k}$，则在$v_{i}$到$v_{j}$的最短路径中必有中间结点$v_{k}$，那么根据如下规则，分别向$v_{k}$两头追溯一定可以得到$v_{i}$到$v_{j}$的最短路径：  
(i) 向点$v_{i}$方向追溯可以得到：  
$$
R^{(n)}(v_{i},v_{k})=v_{k-1},\ R(v_{i},v_{k-1})=v_{k-2},...,\ R^{(n)}(v_{i},v_{k-m})=v_{i}
$$  
(ii) 向点$v_{j}$方向追溯可以得到：  
$$
R^{(n)}\big(v_{k},v_{j}\big)=v_{k+1},\ R^{(n)}\big(v_{k+1},v_{j}\big)=v_{k+2},...,\ R^{(n)}(v_{i},v_{k+s})=v_{j}
$$  
追溯方向图，如下图8-61 所示。  
![图8-61 通过路径矩阵寻找具体的最短路径  ](images/6a3ea39179dd4fb30e351249de4e2648087eaf5e2356569531de0cb959af6180.jpg)  
由此可见，通过路径长度矩阵$D$和路径记录矩阵$R$，可以求出图中任意一对结点之间的最短路径。"
沃舍尔弗洛伊德算法,算法,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.4.3 单源最短路径']","{'实体类型': '算法', '定义': '求整个图中所有结点之间的最短距离的算法'}",,3,"最短路径，顾名思义就是图中一个结点到另一个结点的之间最短的距离。在日常生活之中，涉及到最短路径计算问题的实际案例有很多，比如在地图上查找两地之间最短路径，为大家的出行提供方便；另外，在路由选择中，从一个路由器出发查找距离目的地最近的一条路径等。最短路径的求解主要有两种算法，一种是单源最短路径算法，即一个结点到其他所有剩余结点的最短路径，代表算法是迪杰斯特拉算法；另一种是求整个图中所有结点之间的最短距离，代表算法是沃舍尔∙弗洛伊德算法。  
因此，给定简单无向赋权图 $G=\langle V,E\rangle$ ，从顶点 $v_{1}$ 到 $v_{n}$ 的最短路径可应用迪杰斯特拉算法算法进行求解。迪杰斯特拉算法的基本思想如下：  
假定有两个集合 $A$ 和 $B$ ，$A$ 集合中存放已找到最短路径的结点$B$集合中存放的是剩余结点。初始状态下，集合 $A$ 中包含默认的源点 $v_{1}$ ，然后从集合 $B$ 中选取到结点$v_{1}$最近的那个结点，记为 $v_{2}$，将 $v_{2}$ 放入集合 $A$ 中，并对$ v_{2}$到$v_{1}$的距离进行永久性标注，然后再以 $v_{2}$ 为中介点，更新 $v_{1}$ 到其他剩余结点的最短路径临时值。然后再从集合B中选取最近的结点，并入集合 $A$ 中，并对该结点到$v_{1}$的最短路径临时值进行永久性标注，使得该临时值变成永久值，重复以上过程，直到将集合B中的所有结点全部并入集合 $A$ 中并得到永久性标注。  
迪杰斯特拉算法的数学描述如下：  
（1）初始化：$A=\{v_1\},d(v_1)=0,B=\{v_i|v_i\in V,i\neq1\}$,即 $B=V-A$,且有
$$d(v_i)=\begin{cases}\omega(v_1,v_i),~~~~~~~若(v_1,v_i)\in E\\\infty,~~~~~~~~~~~~~~~~~若(v_1,v_i)\notin E\end{cases}$$              (8-13)  
（2）找最近：在 $B$ 集合中寻找离顶点 $v_{1}$ 最近的结点。若为 $v_{k}$ ，则将 $v_{k}$ 添加到集合 $A$ 中，并在 $B$ 集合中删除 $v_{k}$ ，即 $A=A\cup\{v_{k}\}$，$B=B-\{v_{k}\}$  
（3）更新：以 $v_{k}$ 为中介点，更新 $v_{1}$ 到 $B$ 集合中剩余结点的最短路径长度。$\forall$$v_{i}\in$$B$，  
$d(v_{i})={\left\{\begin{array}{l l}{d(v_{k})+\omega(v_{k},v_{i}),~~~~~~~~~~~~~~若\dot{}d(v_{k})+\omega(v_{k},v_{i})<d(v_{i})}\\ {\qquad d(v_{i}),~~~~~~~~~~~~~~~~~~~~~~~否则}\end{array}\right.}$      （8 −14）  
（4）重复（2）和（3），直到 $B$ 集合为空为止。  
实际上，当 $v_{n}$ 归入集合 $A$ ，且正好 $A=V$，不仅求出了从 $v_{1}$ 到 $v_{n}$ 的最短路径，而且求出了从 $v_{1}$ 到所有顶点的最短路径。  
上述算法的正确性是显然的。因为每一步中，集合 $A$中的每一个元素（顶点）都是 $v_{1}$ 到该元素（顶点）的最短路径，因此只要证明上述 $d(v_{i})$ 是从 $v_{1}$ 到 $v_{i}$ 的最短路径即可。  
事实上，任何一条从 $v_{1}$ 到 $v_{i}$ 的路径，若通过集合 $B$ 中的第一个顶点是 $v_{p}$，且 $v_{p}\neq$$v_{i}$ ，显然这种路径的长度不会比 $d(v_{i})$小（因为所有边的权值为非负）。"
沃舍尔算法,算法,"['第五章 关系模型与理论', '§ 5.4 关系的性质闭包', '5.4.2 传递闭包的构造']","{'实体类型': '算法', '核心思想': '采用递推方法从关系矩阵M₀逐步计算出传递闭包的关系矩阵Mₙ', '应用': '高效构造关系的传递闭包'}",,3,"自反闭包和对称闭包的构造比较简单，一般通过枚举的方法就可以得到解决。然而，传递闭包的构造比自反闭包和对称闭包要困难一些，需要一些技巧。因此，本小节对传递闭包概念做进一步深入理解并由此给出传递闭包构造方法和技巧。  
假设𝐴是任一给定的有限非空集合，$R$ 是$A$ 上的一个二元关系，$t(R)$是$R$ 的传递闭包，显然有${\boldsymbol{R}}\subseteq\ t({\boldsymbol{R}})$。现对于任意$\langle x,z\rangle\in R^{2}$或$\langle x,z\rangle\in R\circ R$，由$R\circ R$的定义知必存在$A$ 中某个元素$y$，使得$\langle x,y\rangle\in R$且$\langle y,z\rangle\in R$，那么根据关系$t(R)$的传递性，必有$\langle x,z\rangle\in t(R)$。故有：$R^{2}\subseteq\ t(R)$，即$R^{2}$也是$t(R)$的一个子集合。  
类似地，对于任意$\langle x,z\rangle\in R^{3}$或$\langle x,z\rangle\in R^{2}\circ R$，则必存在$A$ 中某元素$y$，使得$\langle x,y\rangle\in R^{2}$且$\langle y,z\rangle\in R$，从而有$\langle x,z\rangle\in t(R)$，故有$R^{3}\subseteq\ t(R)$。以此类推，可知，对于任意自然数$k$，必有$R^{k}\subseteq\ t(R)$。故有：
$$
R\ \cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots\subseteq\ t(R)\quad\text{(5-15)}
$$
根据传递闭包$t(R)$的定义，$t(R)$是包含$ R$的传递性关系中最小的集合，要证明：
$$
t(R)\ \,\subseteq\,R\,\cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots
$$
只需证明 $R\ \cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots$ 满足传递性即可。任取两个序偶 $\langle x,y\rangle$ 和 $\langle y,z\rangle$ ，满足：
$$
\langle x,y\rangle\in R\ \cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots;\ \ \langle y,z\rangle\in R\ \cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots
$$
则分别存在自然数$t,s$，使得$\langle x,y\rangle\in R^{t}$且$\langle y,z\rangle\in R^{s}$，则根据关系复合运算的定义，有：$\langle x,z\rangle\in R^{t}\circ R^{s}$，即有：$\langle x,z\rangle\in R^{t+s}$。故有：$\langle x,z\rangle\in\!\!R\,\cup\!R^{2}\cup\!R^{3}\cup\cdots\cup\!R^{k}\cup\cdots_{\circ}$。即有：
$$
t(R)\ \,\subseteq\,R\,\cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots\quad\text{(5-16)}
$$
经过以上分析，可得到如果关于传递闭包构造定理：  
【定理5.13】设$R$ 是非空集合$A$ 上的关系，$t(R)$是$R$ 的传递闭包，$M$和$M_{t}$分别为$R$ 和$t(R)$的关系矩阵，则有：
$$
t(R)=\,R\,\cup R^{2}\cup R^{3}\cup\cdots\quad\text{(5-17)}
$$  
$$
M_{t}=M\lor M^{2}\lor M^{3}\lor\cdots\quad\text{(5-18)}
$$  
通过前面的例题可以看出，使用集合运算法计算传递闭包比较繁琐晦涩，非常容易出错，使用矩阵计算则涉及计算量很大的方幂计算。为了更加方便地构造关系的传递闭包，下面介绍一个比较高效传递闭包构造算法，即著名的沃舍尔算法。  
假设$R$ 是非空集合$A$ 上的二元关系，$t(R)$是$R$ 的传递闭包，$G$ 是$R$ 的关系图。从前面分析可知，在传递闭包$t(R)$的关系图中，若从结点$x$到结点$y$有一条边，当且仅当在$R$的关系图$G$ 中存在一条从结点$x$到结点$y$且边数大于或等于1 的链路，即在图$G$ 可以从结点$x$连通到结点$y$。因此，关于$R$的传递闭包$t(R)$实际上就是$R$的关系图$G$ 的连通关系$R^{*}$，即有：  
$R^{*}=\{\langle x,y\rangle|$在图$G$中存在一条从结点结点$x$到结点𝑦有向链路}  
现考虑 $n+1$ 个矩阵序列 $M_{0},M_{1},\cdots,M_{n}$ ，将矩阵 ${M}_{k}$ 的第 $𝑖 $行第$ 𝑗 $列的元素记为 $M_{k}[i,j]$ 。对 于$k=0,1,\cdots n$，$M_{k}[i,j]=1$当且仅当在$R$的关系图$G$ 中存在一条结点$x_{i}$到结点$x_{j}$的一条链路，并且这条链路除两个端点之外的中间结点只能经过集合$\{x_{1},x_{2},\cdots,x_{k}\}$中的结点。显然，$M_{0}$就是$R$ 的关系矩阵，而$M_{n}$就是$R$ 的传递闭包$t(R)$的关系矩阵。沃舍尔算法的核心思想就是采用递推的方法从$M_{0}$逐步计算出$M_{n}$，据此给出$t(R)$的高效构造算法。  
假设$M_{k}$已经计算完成，那么如何从$M_{k}$计算出$M_{k+1}$呢？所谓计算出$M_{k+1}$，其实就是对每组$i,j$，确定$M_{k+1}[i,j]$是否为1。根据$M_{k+1}$的定义，$M_{k+1}[i,j]=1$当且仅当在$R$的关系图$G$中存在一条结点$x_{i}$到结点$x_{j}$的一条链路，并且这条链路除两个端点之外的中间结点只能经过集合$\{x_{1},x_{2},\cdots,x_{k},x_{k+1}\}$中的结点。这种链路只有两种可能性：  
第一种是只经过$\{x_{1},x_{2},\cdots,x_{k}\}$中的结点，此时$M_{k}[i,j]=1$  
第二种可能是链路经过了结点$x_{k+1}$，此时显然仅考虑只经过结点$x_{k+1}$一次的情形，因为如果经过两次$x_{k+1}$则必然形成一个回路，将该回路删除即可。将该链路分成如下两段，即：从结点$x_{i}$到结点$x_{k+1}$，以及从结点$x_{k+1}$到结点$x_{j}$。故有$M_{k}[i,k+1]{=}1$ 且$M_{k}[k+1,j]{=}1$。  
综上所述，可由下列公式从$M_{k}$计算出$M_{k+1}$
$$
M_{k+1}[i,j]=M_{k}[i,j]\vee M_{k}[i,k+1]\wedge M_{k}[k+1,j]\quad\text{(5-19)}
$$
具体地说，对于$k=0,1,2,\cdots,n-1$，从$M_{k}$构造$M_{k+1}$的具体过程如下：  
(1)$ M_{k}[i,j]=s_{i j},\,\,\,M_{k+1}[i,j]=t_{i j}$  
（2）将$M_{k}$中的所有值为1 元素复制到$M_{k+1}$中相应位置，即若$s_{i j}=1$，则$t_{i j}=1$  ;  
（3）对于所有$i,j=1,2,\cdots,n$，若$t_{i j}=0$，则当$s_{i k+1}=s_{k+1j}=1$时，令$t_{i j}=1$ 。"
流网络,概念,"['§ 10.4 网络流图及其优化问题', '10.4.1 流网络与切割', '第十章  特殊图模型与算法']","{'实体类型': '概念', '介绍': '网络流图的基本概念之一', '定义': '每条边具有附带容量的有向图，包含源结点和汇结点，边有非负容量', '特点': '定义在网络中关于边的实函数，表示结点间的净流', '性质': '容量限制、斜对称、流守恒', 'name': '流网络'}",,2,对交通运输、网络通信和管道运输等实际问题的建模，不仅需要图模型，而且不可避免地涉及到车流、水流、人流、信息流等流的概念与计算。将图模型与流进行整合，就形成了一个新的数学模型——网络流模型。该模型是一种有向带权图，要求每条边都有一定容量限制，边的流量数不能超过其容量，而且除源点和汇点外，每道流进入某结点的流量数必须等于离开该结点的流量数。目前，随着增益流、多终端流、多商品流以及各种网络流的出现，网络流模型及算法已普遍应用到通讯、运输、电力、工程规划、任务分派、设备更新等诸多领域。本节介绍网络流图的基本概念及算法，主要包括流网络的基本概念、网络切割的基本概念与性质、网络最大流求解算法。
流量增广路径,概念,"['第十章  特殊图模型与算法', '§ 10.4 网络流图及其优化问题', '10.4.1 流网络与切割']","{'实体类型': '概念', '定义': '残留网络中从源点到汇点的不违反边容量限制的路径', '特点': '通过压入流量增加网络流量值'}",,3,"首先介绍流网络模型的相关基本概念及其数据描述。如同每条公路有运输量、每根水管有最大流量限制一样，网络流图的每条边都有容量，或者说每条边都有一定的流量。网络流图其实就是每条边具有附带容量（可理解为权值）的有向图。其具体定义如下：  
【定义10.4.1】设有向图$G=\langle V,E\rangle$，$V$中包含一个源结点𝑠和一个汇结点$t$，且每条边$(u,v)\in E$均有一个非负容量$c(u,v)\geq0$，若$(u,v)\notin E$，则规定其容量$c(u,v)=0$，此时称有向图$G$是一个网络流图，简称为流网络或网络。源结点$s$即起点，汇结点$t$即终点。网络流是定义在网络$G$中关于边的一个实函数，用$f(u,v)$表示有向边$(u,v)\in E$上结点$ u$到结点$v$的网络流。$f(u,v)$表示$u$ 到$v$的净流。  
例如，如果$_{u}$到$v$有6 个单位的实际流，且$v$到$u$有3 个单位的实际流，那么$f(u,v)=$3，$f(v,u)=-3$，互为相反数。净流是实际通过的流量矢量和，可类比合力的概念。  
满足以下三个性质的网络流$f$称之为可行流：  
（1）容量限制：对所有的$(u,v)\in E$，都有$f(u,v)\leq c(u,\textit{}v)$。即一条边的流不能超过它的容量。这也很容易理解，如同自来水管的水流自然不会超过水管本身的容量。  
（2）斜对称：对所有$(u,v)\in E$，都有$f(u,v)=-f(v,u)$。即点$\cdot u$到$v$的净流必须与点𝑣到$u$的净流相反。可以类比物理中矢量概念，如作用力与反作用力，强调的是其方向性。  
（3）流守恒：对所有$u\in V-\{s,t\}$，都有$\textstyle\sum_{v\in V}f(u,v)=0$。即除源结点$𝑠$和汇结点$𝑡$外，其余每个结点的净流之和为0。  
![图10-68 网络及可行流  ](images/bada5974bba3db0db4c82fa8e3076a8834542abfa1641f17fac232a32e6fee29.jpg)  
例如，如图10-68 所示，网络中定义网络流$f(u,v)$是一条可行流。图中每条边所对应的序偶表示该边的容量和流量，第一个数字表示边的容量，第二个数字表示边的流量。  
下面结合图10-68 所示网络实例介绍网络流模型中与边相关的几个概念。可根据边的容量与流的大小关系对网络中的边进行分类：  
（1）满足$f(u,v)=c(u,v)$的边称为饱和边，如边(1,2)、 (2,3)  
（2）满足$f(u,v)<c(u,v)$的边称为非饱和边，如边(2,4)。  
（3）满足 $f(u,v)=0$ 的边称为零流边，如边 (3,4) ；满足 $f(u,v)>0$ 的边称为非零流 边，如边(5,4)。  
（4）既不是零流边也不是饱和边的边，称为弱流边，如边(5,6)  
如果把图10-78 看作是一个公路网，6 个结点分别表示6 座城镇，每条边上的权数表示两城镇间的距离。若现在需要从起点1 将一些物资运送到终点6，应怎样选择路线才能使总运输距离最短。我们知道，这样一类问题称为最短路径问题。类似的，如果把图10-1看作为一个输油管道网，结点1表示为发送点，结点6表示为接收点，其它点表示为中转站，各边的权数表示该段管道的最大运输油量。那么如何安排输油线路才能使从1到6的总运输量最大。这样一类问题就是最大流问题。  
最大流问题是网络优化中的一个典型的问题，简单地说，就是在满足容量约束的前提下将尽可能多的流从源结点流向汇结点。因此，最大流问题就是求流网络$G$中使其流量$f$达到最大的一个可行流，该可行流即为最大流。具体定义如下：  
【定义10.4.2】设有向图$G=\langle V,E\rangle$是任意给定的一个网络流图，若$f$是$G$ 中流量最大的的可行流，则称该可行流$f$是$G$ 的最大流，构构造网络流图$G$ 中最大流的问题，就称为网络流图的最大流问题。  
为了实现对最大流问题的求解，必须对网络流图中的增流空间进行合理的度量，通常使用一种名为残留网络的图模型实现这项工作。残留网络的具体定义如下：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图， $f$为$G$的一个流，对于$G$的任意一条边$(u,v)$，在不超过容量$c(u,v)$条件下，从$u$到$v$可压入的额外流量，称为$(u,v)$的残留容量。由$G$中所有边残留容量构成的带权有向图称为$G$的残留网络，记为$G_{f}=\langle V,E_{f}\rangle$。  
若$c_{f}(u,v)$为残留网络$G_{f}$中边$(u,v)$的残留容量，且边$(u,v)\in E$或边$(v,u)\in E$，则$(u,v)\in$$E_{f}$,$\,c_{f}(u,v)=c(u,v)-f(u,v)\,$。例如，若设$(u,v)$当前流量为(4,3)，此时$c(u,v)=4$，$f(u,v)$）$=3$，则有：$c_{f}(u,v)=1$。  
需要注意的是，残留网络具有这样的性质：假设从$_{.}u$到$v$已经有了3 个单位流量，那么从反方向上看，也就是从$v$ 到$u$ 就有了3 个单位的残留容量，这时$c_{f}(v,u)=3$。换句话说，从$u$ 到$v$ 有3 个单位流量，那么从$v$到$u$ 就有了将这3 个单位流量压回去的能力。因此，残留网络结点之间通常由双向带权边进行联结。例如，对于图10-69（a）所示的一个流网络$G$，图10-69（b）则表示该流网络𝐺的残留网络。  
![图10-69 流网络及其残留网络 ](images/d65d1c72064671125468548ae171a28ede5424f1d36d601972ed76c90131fc8c.jpg)  
对于任意给定的一个网络流图$G=\langle V,E\rangle$，可以通过其残留网络$G_{f}=\langle V,E_{f}\rangle$求得$G$的最大流。基本思路如下：首先，对所有的结点令初始状态时流的值为0，即对于$\forall u,v\in V$，有$f(u,v)=0$。然后，通过迭代方式其残留网络中不断寻找源点𝑠到汇点$t$之间的流量增广路径来增加网络流量值，直到残留网络没有这样的增广路径为止。  
因此，在残留网络$G_{f}=\langle V,E_{f}\rangle$寻找流量增广路径是最大流求解算法的关键。为正确理解该算法，现给出流网络增广路径的具体定义：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，$G_{f}=\langle V,E_{f}\rangle$为$G$在流$f$下的一个残留网络，则$G_{f}=\langle V,E_{f}\rangle$中任意一条从源点$s$到汇点$t$的简单路径$p$称为$G=\langle V,E\rangle$的一条流量增广路径，简称为增广路径。  
事实上，可将增广路径形象地理解为网络流图$G$中从源点𝑠到汇点𝑡的一条不违反流网络边容量限制的路径，并向这条路径压入一定的流量，以增加整个网络的流量值。例如，图10-69（b）所示的残留网络存在这样一条如图10-70 中加粗有向边所示的增广路径。  
![图10-70 增广路径 ](images/1e52dc98ce8f5b49283b093dbb72c0d5308ccdc9782306a98cb168474d58608f.jpg)  
![图10-71 流网络的一个切割](images/c52dd38b6f7d2bc46bb57e2440709d67355577a7b3d5fb2e920f10a5bfeb8598.jpg)  
若将图10-70 所示增广路径在流网络所对应每条边的流量增加4 个单位，得到一个新的流网络，其流量比原网络多4 个单位。然后，在新流网络所对应的残留网络中继续寻找新增广路径，直到找不到新增广路径为止。显然，现在的问题是：如果在残留网络$G_{f}=$$\langle V,E_{f}\rangle$中找不到增广路径，此时该残留网络所对应的流$f$是否就是流网络$G=\langle V,E\rangle$的最大流？要解决这个问题，必须进一步引入流网络切割的相关概念，具体如下：  
【定义10.4.4】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，如果将$G$的结点集合𝑉划分为𝑆和$T=V-S$两部分，使得源点$s\in S$且$t\in T$，则称$(S,T)$是$G=\langle V,E\rangle$的一个切割，简称为割。从集合 𝑆 到集合 𝑇 的所有有向边容量之和称为切割 $(S,T)$ 的容量，穿过切割 $(S,T)$所有边流量的代数和流量称为切割$(S,T)$的净流量，记为$f(S,T)$。  
主要注意的是，定义10.4.4 中边的流量带有正负方向，如果流从结点𝑆流向$T$，则该边的流量值为正，如果流从结点𝑇流向𝑆，则该边的流量值为负。例如，对图10-69（a）所示的流网络，可画一个如图10-71 所示的切割$(S,T)$，其容量为：  
$$
c(u,w)+c(v,x)=12+14=26
$$  
穿过该切割的净流量为：  
$$
f(u,w)+f(v,x)-f(w,v)=12+11-4=19
$$  
显然，对于任意一个切割，穿过该切割的净流量上界就是该切割的容量，即穿过切割的净流量不可能超过割的容量。由于流网络中所有切割的流都相等并且等于网络的流，因此，网络最大流必然无法超过网络的最小割。由此得到如下最大流最小割定理：  
【定理10.4.1】（最大流最小割定理）设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和$t$分别为其源点和汇点，则$G=\langle V,E\rangle$的最大流量等于其最小割切的容量。对于$G=\langle V,E\rangle$上的任意一个流$f$，以下三个结论彼此等价：  
(1) $f$是流网络$G=\langle V,E\rangle$的一个最大流；  
(2) 流网络$G=\langle V,E\rangle$的残留网络中不包括任何增广路径；  
(3) 存在流网络$G=\langle V,E\rangle$的某个切割$(S,T)$，满足：
$$
f(S,T)=c(S,T)
$$"
浅层学习,概念,"['第八章  图的基本理论与算法', '§ 8.5 图模型的应用', '8.5.3 机器学习问题']","{'实体类型': '概念', '特点': '基于图模型，使用权图模型从大量训练样本中学习统计规律，然后根据学到的规律对未知事件进行预测', '模型结构': '基于图模型，如BP神经网络模型、支持向量机模型'}",,3,"1959 年，美国塞缪尔教授设计了一个具有学习能力的下棋程序。它可在不断对弈中改善自己的棋艺。4 年后，该程序战胜了设计者本人。又过3 年，该程序战胜了美国常胜冠军。由此可以看出机器学习的能力，特别是当下谷歌设计的AlphaGo 程序与围棋大师李世石的围棋大战，更是体现了机器学习的威力。所谓机器学习，就是数学模型或求解算法中具有似于人类的学习机制，能够从实际问题中采集适当样本数据，根据样本数据自动算出参数值，并随着样本数据的变化自动调整参数取值，使得数学模型和求解算法具有良好的普适性和自适应性。按机器学习的模型结构层次来分，机器学习经历了两次浪潮，分别是浅层学习和深度学习。近年来，机器学习的概念异常火爆，各种机器学习算法层出不穷。本小节简要介绍图模型在浅层学习和深度学习中的与应用。  
![图8-73 BP 网络结构](images/3e28bfeab67aaebdd2a54ed46ef1bb594380bb5384ccdde94e5e1d5ae51f9049.jpg)  
![图8-74 支持向量机结构](images/0d16cdb37dc68fb29e3b36be467fd837d3d52e2ccd7acbba9de1c8c373e6974d.jpg)  
无论是浅层学习还是深度学习的模型结构都是基于图模型。  图8-73 所示的图模型是20 世纪80 年代末期提出BP 神经网络模型，图8-74 所示的图模型是20 世纪90 年代中期提出支持向量机模型。 这些都是机器学习中的经典图模型用于浅层的机器学习。 正是这些图模型的建立给机器学习带来了希望，掀起了基于统计模型机器学习热潮。人们使用这类权图模型从大量训练样本中学习统计规律，然后根据学到的规律对未知事件进行预测。  
![图8-75 简单函数对复杂函数的逼近 ](images/fbe962cff1ffa6a7bb0339da768141046705e07e74feba559a3752dfe9c241b2.jpg)  
![图8-76 多层模型表示复杂函数  ](images/272fe3358ea6997e106f1355c74465d9d8b3888427cf64765b441f271abcfeac.jpg)  
然而，进入21 世纪，浅层学习研究的发展遇到瓶颈。从而，人们创立了深度学习的相关概念和理论，并借助分布式云计算的大数据平台，在机器学习领域取得了突破性进展。深度学习通过一种深层非线性网络结构，组合低层特征形成更加抽象的高层表示属性类别或特征，实现由简单函数向复杂函数的有效逼近，以发现数据的分布式特征表示。其具有强大的从少数样本中集中学习数据集本质特征的能力。图8-75 表示一个通过简单函数逼近复杂函数的实例。  
简单地说，深度学习就是对拥有深层结构的模型进行训练。所谓深层结构，是相对于前述的浅层结构而言的，两者的差异主要在于拥有的非线性运算单元的层数不同。深层结构是指非线性转换单元的层数大于或等于两层的模型，而使用多层模型的优势即可以使用较少的参数表示复杂的函数。使用多层模型表示复杂函数的例子如图8-76 所示。  
![图8-77 含多隐含层的深度学习模型图  ](images/a696f4639cd9bb8eadcb3b542d30322c2127fff383c01a8ce40760e85d44b787.jpg)  
![图8-78 自动编码器(AE)结构示意图  ](images/d437ba8ccbf4e13b83ff799a9ddec1778e03cc7629e09224d02fe81a54b359de.jpg)  
深度学习在模型中构建多层隐含层，并通过大量样本训练模型参数，获得更有用的特征，从而有效提升分类或预测的准确性。相比较传统的浅层结构，深度学习更强调了模型结构的深度，通常有5 至6 层隐含层，有的模型结构甚至包含10 层以上隐含层。此外，深度学习明确突出了特征学习的重要性。深度学习实现多层堆叠，每一层的输出作为下一层的输入，高层的特征是低层特征的组合，从低层到高层的特征表示越来越抽象，越来越能表现语义或者意图。而抽象层面越高，存在的可能猜测就越少，就越利于分类。换句话说，深度学习通过逐层特征变换，将样本在原始特征空间表示逐层变换到新的特征空间，从而使分类或预测的效果更加准确。图8-77 表示一个含多隐含层的深度学习模型。事实上，由如图8-78 所示自动编码器组合或其简单变形的模型也可看成是深度结构，例如堆叠自动编码器，稀疏自动编码器等。  
深度学习是机器学习发展的产物。与传统的机器学习方法相比，深度学习优势明显，目前在图像识别、语音识别、自然语言理解等领域得到广泛的应用。"
消去律,性质,"['§ 11.2 代数结构的运算性质', '12.2.1 群的基本概念', '11.2.1  二元算律', '第十二章 典型抽象代数结构', '§ 12.2 群结构的基本知识', '第十一章  抽象代数结构通论']","{'实体类型': '性质', '定义': ['在二元代数结构中，若z*y=z*x则有y=x（左消去律）；若y*z=x*z则有y=x（右消去律）', '若|G|>1，则⟨G,*⟩中无零元且满足消去律'], '分类': '左消去律、右消去律、消去律', 'name': '消去律'}",,3,"现在我们介绍和讨论二元运算律。一共有六个二元运算律，即结合律、交换律、幂等律、消去律、分配律和吸收率。其中前面四个基于单个二元运算，后面两个基于两个二元运算。下面分别讨论这些运算律，首先讨论结合律。  
结合律是大家非常熟悉也是非常重要的一个二元运算律，实数加法与乘法运算、矩阵的加法与乘法运算、关系与函数的复合运算、整数集合上的模余运算、幂集合的交运算与并运算等都满足结合律。结合律的具体定义如下：  
【定义11.5】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由$𝐴$和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$，成立$(x*y)*z=x*(y*z)$，则称$\langle A,*\rangle$的运算 $^*$ 在 𝐴 上是可结合的，或者说 $\langle A,*\rangle$ 的运算 $^*$ 在 𝐴 上满足结合律。  
对于任意给定的集合𝐴，由于𝐴上的二元运算${\ast}$满足封闭性，故对于$\forall x,y,z\in A$，有${x\ *}$$y\in A$且$y*z\in A$。因此，$(x*y)*z$和$x*(y*z)$都是有意义的算式，如果$*$满足结合律，则表达式$x*y*z$就有一个确定的计算结果，即有：  
$$
x*y*z=(x*y)*z=x*(y*z)
$$  
如果 $*$ 不满足结合律，则有可能有 $(x*y)*z\neq x*(y*z).$ 。   此时，表达式 $x*y*z$ 的含义就有歧义。因此，只有当某个运算$*$满足结合律时，才能定义其方幂运算。在后续半群与群中元素方幂的的定义中，其元素运算的结合律起着基础性的支撑作用。  
下面考察运算的交换律，首先给出交换律的定义，具体如下：  
【定义11.6】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y\in A$，成立$x*y=y*x$，则称$\langle A,\ *\rangle$的运算$^*$在𝐴上是可交换的，或者说$\langle A,\ *\rangle$的运算$^*$在𝐴上满足交换律。  
交换律表示代数结构载体集合中的任意两个元素在运算时都可以交换次序。 例如，实数加法与乘法运算、矩阵的加法、整数集合上的模余运算、幂集合的交运算与并运算等都满足交换律。 但是，矩阵的乘法运算、关系与函数的复合运算等都不满足交换律。  
【定义11.7】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，若存在某个元素$a\in A$，满足 a$*$$a=a$，则称$a$是$\langle A,\ *\rangle$的一个幂等元。 如果𝐴中的每个元素都是$\langle A,\ *\rangle$的幂等元，则称$\langle A,\ *\rangle$的运算$*$在𝐴上满足幂等律。  
从上述定义可以看出，所谓幂等元，就是该元素与其自身运算之后仍然等于其自身。例如，对于某个幂集合上的交运算和并运算，幂集合中每个元素显然都是幂等元，因此，幂集合上的交运算和并运算均满足幂等性。但是，对于整数上的加法运算，除了整数0 之外，其余整数显然都不是幂等元，因此,整数上的加法运算不满足幂等律。  
【定义11.8】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$：  
（1）若$z*y=z*x$，有$y=x$，则称运算$*$在𝐴上是可左消去的，或者说运算$∗$在𝐴上满足左消去律，并称$\cdot z$是$A$中关于运算$^*$的左可消去元；  
（2）若$y*z=x*z$，有$y=x$，则称运算$^*$在𝐴上是可右消去的，或者说运算$^*$在𝐴上满足右消去律，并称𝑧是$A$中关于运算$^*$的右可消去元。  
（3）若上述两种情况均满足，则称运算$*$在𝐴上满足消去律，并称$z$是𝐴中关于运算$*$的可消去元。  
下面介绍基于两个二元运算的运算律，即分配律和吸收律。首先给出分配律的定义：  
【定义11.9】假设𝐴是任意给定的一个非空集合，$^*$和$\Delta$均为𝐴上的二元运算，在由$𝐴$、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y,z\in A$：  
若有$x*(y\Delta z)=(x*y)\Delta(x*z)$，则称运算$*$对$\Delta$在𝐴上满足左分配律。  
若有$(y\Delta z)*x=(y*x)\Delta(z*x)$，则称运算$*$对$\Delta$在𝐴上满足右分配律。  
若运算$*$对$\Delta$在𝐴上同时满足左右分配律，则称运算$*$对$\Delta$在𝐴上满足分配律。  
例如，实数集合上的普通乘法对加法满足分配律，$M_{n}(R)$上的矩阵乘法对加法满足分配律，幂集$P(B)$上的集合交运算对并运算满足分配律，并且并运算对交运算也满足分配律。  
将上述关于集合的吸收律推广到一般运算对象和一般运算，得到一个新的运算律，即吸收律。其具体定义如下：  
【定义11.10】设𝐴是任意给定的一个非空集合，$*$和$\Delta$均为为𝐴上二元运算，在由𝐴、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y\in A$，成立：  
$$
x*(y\Delta z)=x,\;\;x\Delta(y*z)=x
$$  
则称 $*$ 和 $\Delta$ 在 A  上满足吸收律。"
消去量词等值式,性质,"['第四章  谓词演算与推理', '§ 4.2  谓词公式与等值演算', '4.2.4 谓词公式的等值与蕴含', '一、谓词公式的等值关系']","{'实体类型': '性质', '定义': '设个体域D为有限集{x0,x1,⋯,xn}，则有：∀xP(x)⇔P(x0)∧P(x1)∧⋯∧P(xn); ∃xP(x)⇔P(x0)∨P(x1)∨⋯∨P(xn)'}",,4,"谓词公式等值关系的含义与命题公式等值关系很类似，是指两个谓词公式在任意相同的解释下具有完全相同的真值，表达的是两个谓词公式之间的恒等关系。下面借助谓词公式的概念给出谓词公式等值关系的具体定义：  
【定义4.17】 假设$G$ 和$H$ 是任意两个给定的谓词公式，若公式$G\leftrightarrow H$是有效公式，则称公式$G$ 和$H$ 称为等值的，记为$G\Leftrightarrow H$，并称$G\Leftrightarrow H$为等值表达式或等值式。  
由上述定义可知，判断两个谓词公式$G$ 和$H$是否等值，关键在于证明谓词公式$G\leftrightarrow H$为有效公式，这种思路与证明命题公式等值关系的基本思路是一致的。类似于命题公式的等值演算系统，在谓词公式的等值演算系统中，通常也是先证明出一些重要的谓词公式等值式，然后将这些重要谓词等值式作为基本等值式进一步推演出更多的谓词公式等值式，这种推演过程构成了谓词公式等值演算的主要内容。下面不加证明地给出这些重要而基本的谓词公式等值式，读者可自行给出证明。  
第一组  命题公式中永真公式的谓词公式代换实例显然是有效谓词公式。因此，按命题逻辑中24 个基本等值式模式使用谓词公式代换出来的实例必定是谓词公式等值式。例如：  
$\forall x P(x)\Leftrightarrow\neg\neg\forall x P(x);\;\;\forall x\exists y\big(H(x,y)\to R(x,y)\big)\Leftrightarrow\neg\neg\forall x\exists y\big(H(x,y)\to R(x,y)\big)$ 等都是双重否定律的代换实例。再如：  
$$
\forall x(\ P(x)\rightarrow Q(y))\rightarrow\exists z H(z)\Leftrightarrow\lnot\forall x(\ P(x)\rightarrow Q(y))\lor\exists z H(z)
$$  
等都是蕴含等值式的代替实例。  
第二组  关于量词的若干等值式：  
（1）消去量词等值式：设个体域$D$ 为有限集$\{x_{0},x_{1},\cdots,x_{n}\ \}$，则有： $\forall x P(x)\Leftrightarrow P(x_{0})\land P(x_{1})\land\cdots\land P(x_{n});\ \ \exists x P(x)\Leftrightarrow P(x_{0})\lor P(x_{1})\lor\cdots\lor P(x_{n})$  
（2）量词否定等值式：对于含有量词的谓词式$\forall x P(x)$和$\exists x Q(x)$，有：$\lnot\forall x P(x)\Leftrightarrow\exists x\lnot P(x);\;\;\lnot\exists x Q(x)\Leftrightarrow\forall x\lnot Q(x)$  
（3）量词辖域的收缩与扩张等值式：  
$$
\forall x(P(x)\lor S)\Leftrightarrow\forall x P(x)\lor S;\;\;\forall x(P(x)\land S)\Leftrightarrow\forall x P(x)\land S;
$$  
$$
\exists x(P(x)\lor S)\Leftrightarrow\exists x P(x)\lor S;\ \exists x(P(x)\land S)\Leftrightarrow\exists x P(x)\land S;
$$  
$$
\forall x(P(x)\rightarrow S)\Leftrightarrow\exists x P(x)\rightarrow S;\quad\exists x(P(x)\rightarrow S)\Leftrightarrow\forall x P(x)\rightarrow S;
$$  
$$
\forall x(S\rightarrow P(x))\Leftrightarrow S\rightarrow\forall x P(x);\ \exists x(S\rightarrow P(x))\Leftrightarrow S\rightarrow\exists x P(x)\\,
$$  
(4）量词分配等值式  
$$
\forall x(P(x)\land Q(x))\Leftrightarrow\forall x P(x)\land\forall x Q(x);\ \exists x(P(x)\lor Q(x))\Leftrightarrow\exists x P(x)\lor\exists x Q(x);
$$  
上述基本的等值关系式很多可以互相推导。特别是当个体域为有限集时，很容易理解上述等值关系的合理性。  
例如，假设$P(x)$表示$x$ 今天上课，个体域为计算机学院全体学生的集合，则：  
$(\forall x)P(x)$表示今天所有学生都上课了；$\neg(\forall x)P(x)$表示今天不是所有学生上课了；$(\exists x)\lnot P(x)$表示今天有学生没上课。即有：$\lnot(\forall x)P(x)\Leftrightarrow(\exists x)\lnot P(x).$。  
$(\exists x)P(x)$表示今天有学生上课；$\neg(\exists x)P(x)$表示今天没有学生上课；$(\forall x)\neg P(x)$表示今天所有学生都没上课。即有：$\lnot(\exists x)P(x)\Leftrightarrow(\forall x)\lnot P(x)\,$。  
再如，假设谓词$G(x)$表示$x$ 勤奋学习，谓词$H(x)$表示$x$ 喜欢体育运动，个体域是某大学里的全体学生。则有：  
谓词公式$(\forall x)(G(x)\land H(x))$表示：“某大学里的所有学生既勤奋学习又喜欢体育运动”；谓词公式$(\forall x)G(x)\land(\forall x)H(x).$表示：“某大学里的所有学生都勤奋学习且大学里的所有学生都喜欢体育运动”。两者含义显然相同，即有$\forall x(G(x)\land H(x))\Leftrightarrow\forall x G(x)\land\forall x H(x)\,$。  
谓词公式 $(\exists x)(G(x)\lor H(x))$表示：“某大学里有些学生勤奋学习或喜欢体育运动”；谓词公式$(\exists x)G(x)\lor(\exists x)H(x)$表示：“某大学里有些学生勤奋学习或大学里有些学生喜欢体育运动”。两者的含义显然相同，即有$\exists x(G(x)\lor H(x))\Leftrightarrow\exists x G(x)\lor\exists x H(x)\,\mathrm{s}$。"
深度优先搜索,算法,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.4.1  深度优先搜索']","{'实体类型': '算法', '定义': '按照深度方向进行搜索，对于一个给定的连通图，首先确定一个遍历的出发点，将其标记为已访问之后，选择与该点相邻且尚未访问过的结点作为新的遍历点，以此类推，直到图中所有结点被访问', '过程': '如果在遍历过程中遇到已访问的结点，则跳过该点，选择其他相邻未访问的点，直到找到未被访问的点进行下一次深度遍历，若当前遍历点的所有邻接点都被访问，则返回上一层遍历点继续搜索，直到搜索过程完成为止', '应用': '适用于连通图和非连通图的遍历'}",,3,"图的遍历是指从图中的任一结点出发，按照一定的搜索方式对图中的所有结点进行访问，每个结点访问一次且仅一次。图的遍历是关于图的一种最基本的操作，图的许多其他操作都是建立在图的遍历基础之上。一般来讲，根据搜索路径的不同，图的遍历算法有两种基本类型，即深度优先搜索遍历和广度优先搜索遍历。  
深度优先搜索是按照深度方向进行搜索，对于一个给定的连通图$G=\langle V,E\rangle$，首先确定一个遍历的出发点$v_{i}$ ,将其标记为已访问之后，再次选择与点$v_{i}$相邻并且尚未访问过的结点$v_{j}$作为新的遍历；同样地，标记$v_{j}$为已访问之后，再次选择与点$v_{j}$相邻并且尚未访问过的新结点$v_{k}$作为遍历点，以此类推，直到图中所有的结点全部被访问，搜索过程完成为止。  
如果在遍历过程中，遇到了与当前遍历点相邻但已访问的结点，则直接跳过该点，再次选择匹配与当前遍历点相邻的其他点，直到找到未被访问的点进行下一次的深度遍历为止，在此过程中，如果已搜索完与当前遍历点所有的邻接点都没有找到未被访问的结点，则此层遍历结束，算法返回上一层遍历点继续深度搜索，以此类推，直到搜索过程完成为止。这个过程称为连通图的深度优先搜索，简称为 DFS。  
上述算法讲述了对于连通图$G=(V,E)$的深度优先遍历过程，下面对其进行整理并拓广为非连通图的情况下的算法整理如下：  
（1）首先确定一个出发点$v_{i}$，访问并将其标记为已访问。  
（2）找出与结点$v_{i}$相邻且未被访问的邻接点$v_{j}$，访问并标记其为已访问，再以$v_{j}$作为当前遍历点继续访问与$v_{j}$相邻切未被访问的邻接点。递归重复本过程，直到当前遍历点的所有邻接点都被访问为止。  
（3）返回上一层访问过的遍历点，若此遍历点仍没有尚未被访问的邻接点，则继续返回上一层直到找到尚有未被访问的邻接点的遍历点，继续执行步骤（2），否则执行步骤（4）  
（4）若此时图中还有顶点未被访问，则继续选择图中一个未被访问的顶点作为起始点，重复上述描述过程，直至图中所有顶点均被访问过为止。  
在对图进行深度优先遍历时，按照结点的先后的被访问次序所组成的序列，称为深度优先搜索序列，简称𝑫𝑭𝑺序列。对于一个连通图，由深度优先搜索算法进行遍历得到的结点次序（𝐷𝐹𝑆序列），以及相应结点之间的边所构成的图称为深度优先生成树。对于一个非连通图，由深度优先搜索算法进行遍历得到的结点次序（𝐷𝐹𝑆序列），以及相应结点之间的边所构成的图称为深度优先生成森林。"
深度优先搜索序列,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.4.1  深度优先搜索']","{'实体类型': '概念', '定义': '按照结点的先后被访问次序所组成的序列'}",,3,"图的遍历是指从图中的任一结点出发，按照一定的搜索方式对图中的所有结点进行访问，每个结点访问一次且仅一次。图的遍历是关于图的一种最基本的操作，图的许多其他操作都是建立在图的遍历基础之上。一般来讲，根据搜索路径的不同，图的遍历算法有两种基本类型，即深度优先搜索遍历和广度优先搜索遍历。  
深度优先搜索是按照深度方向进行搜索，对于一个给定的连通图$G=\langle V,E\rangle$，首先确定一个遍历的出发点$v_{i}$ ,将其标记为已访问之后，再次选择与点$v_{i}$相邻并且尚未访问过的结点$v_{j}$作为新的遍历；同样地，标记$v_{j}$为已访问之后，再次选择与点$v_{j}$相邻并且尚未访问过的新结点$v_{k}$作为遍历点，以此类推，直到图中所有的结点全部被访问，搜索过程完成为止。  
如果在遍历过程中，遇到了与当前遍历点相邻但已访问的结点，则直接跳过该点，再次选择匹配与当前遍历点相邻的其他点，直到找到未被访问的点进行下一次的深度遍历为止，在此过程中，如果已搜索完与当前遍历点所有的邻接点都没有找到未被访问的结点，则此层遍历结束，算法返回上一层遍历点继续深度搜索，以此类推，直到搜索过程完成为止。这个过程称为连通图的深度优先搜索，简称为 DFS。  
上述算法讲述了对于连通图$G=(V,E)$的深度优先遍历过程，下面对其进行整理并拓广为非连通图的情况下的算法整理如下：  
（1）首先确定一个出发点$v_{i}$，访问并将其标记为已访问。  
（2）找出与结点$v_{i}$相邻且未被访问的邻接点$v_{j}$，访问并标记其为已访问，再以$v_{j}$作为当前遍历点继续访问与$v_{j}$相邻切未被访问的邻接点。递归重复本过程，直到当前遍历点的所有邻接点都被访问为止。  
（3）返回上一层访问过的遍历点，若此遍历点仍没有尚未被访问的邻接点，则继续返回上一层直到找到尚有未被访问的邻接点的遍历点，继续执行步骤（2），否则执行步骤（4）  
（4）若此时图中还有顶点未被访问，则继续选择图中一个未被访问的顶点作为起始点，重复上述描述过程，直至图中所有顶点均被访问过为止。  
在对图进行深度优先遍历时，按照结点的先后的被访问次序所组成的序列，称为深度优先搜索序列，简称𝑫𝑭𝑺序列。对于一个连通图，由深度优先搜索算法进行遍历得到的结点次序（𝐷𝐹𝑆序列），以及相应结点之间的边所构成的图称为深度优先生成树。对于一个非连通图，由深度优先搜索算法进行遍历得到的结点次序（𝐷𝐹𝑆序列），以及相应结点之间的边所构成的图称为深度优先生成森林。"
深度优先生成树,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.4.1  深度优先搜索']","{'实体类型': '概念', '定义': '对于一个连通图，由深度优先搜索算法进行遍历得到的结点次序（DFS序列），以及相应结点之间的边所构成的图'}",,3,"图的遍历是指从图中的任一结点出发，按照一定的搜索方式对图中的所有结点进行访问，每个结点访问一次且仅一次。图的遍历是关于图的一种最基本的操作，图的许多其他操作都是建立在图的遍历基础之上。一般来讲，根据搜索路径的不同，图的遍历算法有两种基本类型，即深度优先搜索遍历和广度优先搜索遍历。  
深度优先搜索是按照深度方向进行搜索，对于一个给定的连通图$G=\langle V,E\rangle$，首先确定一个遍历的出发点$v_{i}$ ,将其标记为已访问之后，再次选择与点$v_{i}$相邻并且尚未访问过的结点$v_{j}$作为新的遍历；同样地，标记$v_{j}$为已访问之后，再次选择与点$v_{j}$相邻并且尚未访问过的新结点$v_{k}$作为遍历点，以此类推，直到图中所有的结点全部被访问，搜索过程完成为止。  
如果在遍历过程中，遇到了与当前遍历点相邻但已访问的结点，则直接跳过该点，再次选择匹配与当前遍历点相邻的其他点，直到找到未被访问的点进行下一次的深度遍历为止，在此过程中，如果已搜索完与当前遍历点所有的邻接点都没有找到未被访问的结点，则此层遍历结束，算法返回上一层遍历点继续深度搜索，以此类推，直到搜索过程完成为止。这个过程称为连通图的深度优先搜索，简称为 DFS。  
上述算法讲述了对于连通图$G=(V,E)$的深度优先遍历过程，下面对其进行整理并拓广为非连通图的情况下的算法整理如下：  
（1）首先确定一个出发点$v_{i}$，访问并将其标记为已访问。  
（2）找出与结点$v_{i}$相邻且未被访问的邻接点$v_{j}$，访问并标记其为已访问，再以$v_{j}$作为当前遍历点继续访问与$v_{j}$相邻切未被访问的邻接点。递归重复本过程，直到当前遍历点的所有邻接点都被访问为止。  
（3）返回上一层访问过的遍历点，若此遍历点仍没有尚未被访问的邻接点，则继续返回上一层直到找到尚有未被访问的邻接点的遍历点，继续执行步骤（2），否则执行步骤（4）  
（4）若此时图中还有顶点未被访问，则继续选择图中一个未被访问的顶点作为起始点，重复上述描述过程，直至图中所有顶点均被访问过为止。  
在对图进行深度优先遍历时，按照结点的先后的被访问次序所组成的序列，称为深度优先搜索序列，简称𝑫𝑭𝑺序列。对于一个连通图，由深度优先搜索算法进行遍历得到的结点次序（𝐷𝐹𝑆序列），以及相应结点之间的边所构成的图称为深度优先生成树。对于一个非连通图，由深度优先搜索算法进行遍历得到的结点次序（𝐷𝐹𝑆序列），以及相应结点之间的边所构成的图称为深度优先生成森林。"
深度优先生成森林,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.4.1  深度优先搜索']","{'实体类型': '概念', '定义': '对于一个非连通图，由深度优先搜索算法进行遍历得到的结点次序（DFS序列），以及相应结点之间的边所构成的图'}",,3,"图的遍历是指从图中的任一结点出发，按照一定的搜索方式对图中的所有结点进行访问，每个结点访问一次且仅一次。图的遍历是关于图的一种最基本的操作，图的许多其他操作都是建立在图的遍历基础之上。一般来讲，根据搜索路径的不同，图的遍历算法有两种基本类型，即深度优先搜索遍历和广度优先搜索遍历。  
深度优先搜索是按照深度方向进行搜索，对于一个给定的连通图$G=\langle V,E\rangle$，首先确定一个遍历的出发点$v_{i}$ ,将其标记为已访问之后，再次选择与点$v_{i}$相邻并且尚未访问过的结点$v_{j}$作为新的遍历；同样地，标记$v_{j}$为已访问之后，再次选择与点$v_{j}$相邻并且尚未访问过的新结点$v_{k}$作为遍历点，以此类推，直到图中所有的结点全部被访问，搜索过程完成为止。  
如果在遍历过程中，遇到了与当前遍历点相邻但已访问的结点，则直接跳过该点，再次选择匹配与当前遍历点相邻的其他点，直到找到未被访问的点进行下一次的深度遍历为止，在此过程中，如果已搜索完与当前遍历点所有的邻接点都没有找到未被访问的结点，则此层遍历结束，算法返回上一层遍历点继续深度搜索，以此类推，直到搜索过程完成为止。这个过程称为连通图的深度优先搜索，简称为 DFS。  
上述算法讲述了对于连通图$G=(V,E)$的深度优先遍历过程，下面对其进行整理并拓广为非连通图的情况下的算法整理如下：  
（1）首先确定一个出发点$v_{i}$，访问并将其标记为已访问。  
（2）找出与结点$v_{i}$相邻且未被访问的邻接点$v_{j}$，访问并标记其为已访问，再以$v_{j}$作为当前遍历点继续访问与$v_{j}$相邻切未被访问的邻接点。递归重复本过程，直到当前遍历点的所有邻接点都被访问为止。  
（3）返回上一层访问过的遍历点，若此遍历点仍没有尚未被访问的邻接点，则继续返回上一层直到找到尚有未被访问的邻接点的遍历点，继续执行步骤（2），否则执行步骤（4）  
（4）若此时图中还有顶点未被访问，则继续选择图中一个未被访问的顶点作为起始点，重复上述描述过程，直至图中所有顶点均被访问过为止。  
在对图进行深度优先遍历时，按照结点的先后的被访问次序所组成的序列，称为深度优先搜索序列，简称𝑫𝑭𝑺序列。对于一个连通图，由深度优先搜索算法进行遍历得到的结点次序（𝐷𝐹𝑆序列），以及相应结点之间的边所构成的图称为深度优先生成树。对于一个非连通图，由深度优先搜索算法进行遍历得到的结点次序（𝐷𝐹𝑆序列），以及相应结点之间的边所构成的图称为深度优先生成森林。"
深度学习,概念,"['第八章  图的基本理论与算法', '§ 8.5 图模型的应用', '8.5.3 机器学习问题']","{'实体类型': '概念', '定义': '对拥有深层结构的模型进行训练，通过深层非线性网络结构，组合低层特征形成更加抽象的高层表示属性类别或特征，实现由简单函数向复杂函数的有效逼近', '特点': '强调了模型结构的深度，通常有5至6层隐含层，有的模型结构甚至包含10层以上隐含层，突出了特征学习的重要性', '优势': '具有强大的从少数样本中集中学习数据集本质特征的能力，有效提升分类或预测的准确性', '应用': '图像识别、语音识别、自然语言理解等领域'}",,3,"1959 年，美国塞缪尔教授设计了一个具有学习能力的下棋程序。它可在不断对弈中改善自己的棋艺。4 年后，该程序战胜了设计者本人。又过3 年，该程序战胜了美国常胜冠军。由此可以看出机器学习的能力，特别是当下谷歌设计的AlphaGo 程序与围棋大师李世石的围棋大战，更是体现了机器学习的威力。所谓机器学习，就是数学模型或求解算法中具有似于人类的学习机制，能够从实际问题中采集适当样本数据，根据样本数据自动算出参数值，并随着样本数据的变化自动调整参数取值，使得数学模型和求解算法具有良好的普适性和自适应性。按机器学习的模型结构层次来分，机器学习经历了两次浪潮，分别是浅层学习和深度学习。近年来，机器学习的概念异常火爆，各种机器学习算法层出不穷。本小节简要介绍图模型在浅层学习和深度学习中的与应用。  
![图8-73 BP 网络结构](images/3e28bfeab67aaebdd2a54ed46ef1bb594380bb5384ccdde94e5e1d5ae51f9049.jpg)  
![图8-74 支持向量机结构](images/0d16cdb37dc68fb29e3b36be467fd837d3d52e2ccd7acbba9de1c8c373e6974d.jpg)  
无论是浅层学习还是深度学习的模型结构都是基于图模型。  图8-73 所示的图模型是20 世纪80 年代末期提出BP 神经网络模型，图8-74 所示的图模型是20 世纪90 年代中期提出支持向量机模型。 这些都是机器学习中的经典图模型用于浅层的机器学习。 正是这些图模型的建立给机器学习带来了希望，掀起了基于统计模型机器学习热潮。人们使用这类权图模型从大量训练样本中学习统计规律，然后根据学到的规律对未知事件进行预测。  
![图8-75 简单函数对复杂函数的逼近 ](images/fbe962cff1ffa6a7bb0339da768141046705e07e74feba559a3752dfe9c241b2.jpg)  
![图8-76 多层模型表示复杂函数  ](images/272fe3358ea6997e106f1355c74465d9d8b3888427cf64765b441f271abcfeac.jpg)  
然而，进入21 世纪，浅层学习研究的发展遇到瓶颈。从而，人们创立了深度学习的相关概念和理论，并借助分布式云计算的大数据平台，在机器学习领域取得了突破性进展。深度学习通过一种深层非线性网络结构，组合低层特征形成更加抽象的高层表示属性类别或特征，实现由简单函数向复杂函数的有效逼近，以发现数据的分布式特征表示。其具有强大的从少数样本中集中学习数据集本质特征的能力。图8-75 表示一个通过简单函数逼近复杂函数的实例。  
简单地说，深度学习就是对拥有深层结构的模型进行训练。所谓深层结构，是相对于前述的浅层结构而言的，两者的差异主要在于拥有的非线性运算单元的层数不同。深层结构是指非线性转换单元的层数大于或等于两层的模型，而使用多层模型的优势即可以使用较少的参数表示复杂的函数。使用多层模型表示复杂函数的例子如图8-76 所示。  
![图8-77 含多隐含层的深度学习模型图  ](images/a696f4639cd9bb8eadcb3b542d30322c2127fff383c01a8ce40760e85d44b787.jpg)  
![图8-78 自动编码器(AE)结构示意图  ](images/d437ba8ccbf4e13b83ff799a9ddec1778e03cc7629e09224d02fe81a54b359de.jpg)  
深度学习在模型中构建多层隐含层，并通过大量样本训练模型参数，获得更有用的特征，从而有效提升分类或预测的准确性。相比较传统的浅层结构，深度学习更强调了模型结构的深度，通常有5 至6 层隐含层，有的模型结构甚至包含10 层以上隐含层。此外，深度学习明确突出了特征学习的重要性。深度学习实现多层堆叠，每一层的输出作为下一层的输入，高层的特征是低层特征的组合，从低层到高层的特征表示越来越抽象，越来越能表现语义或者意图。而抽象层面越高，存在的可能猜测就越少，就越利于分类。换句话说，深度学习通过逐层特征变换，将样本在原始特征空间表示逐层变换到新的特征空间，从而使分类或预测的效果更加准确。图8-77 表示一个含多隐含层的深度学习模型。事实上，由如图8-78 所示自动编码器组合或其简单变形的模型也可看成是深度结构，例如堆叠自动编码器，稀疏自动编码器等。  
深度学习是机器学习发展的产物。与传统的机器学习方法相比，深度学习优势明显，目前在图像识别、语音识别、自然语言理解等领域得到广泛的应用。"
混合图,概念,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.2 图的定义与分类']","{'实体类型': '概念', '定义': '有些边是无向边，有些边是有向边的图'}",,3,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)"
渐近效率,概念,"['第二章  整数与算法设计基础', '§ 2.3 算法设计的基本知识', '2.3.2 算法效率的度量']","{'实体类型': '概念', '定义': '从极限角度考虑运行时间如何随输入规模的增长而增长', '应用': '用于更准确地阐释和度量算法复杂度'}",,3,"从实际应用考虑，如果一个算法的运行时间过久，比如需要长达数年的时间，那么该算法就不适合用来解决问题。同样，一个算法如果需要占用很大的内存开销，导致系统无法为其它程序提供必须的内存资源，那么这也是不能够接受的。因此，对于设计出来的算法，需要对其利用时间和内存空间的效率进行分析，这就是算法的效率分析。无论是时间效率还是空间效率上看，算法的效率都是问题规模的某个函数，并且函数值随着问题规模的增长而增长。如果函数值随问题规模的增长而增长得很快，则说明算法效率很低，反之，如果函数值随问题规模的增长而增长得很慢，则说明算法效率很高。  
因此，为了更好地分析算法的效率，需要一些合适的方法来描述或度量函数值随自变量增长而增长的速度，如果不能精确地算出函数增长的速度，那么至少也要针对函数增长的不同速度划分出若干性质不同的等级，这就是函数增长的阶。当输入规模足够大时，精确表示的运行时间函数中的常系数和低阶项会被输入规模所掩盖。此时，只需要考虑高阶项即可。比如若复杂度为多项式$x^{2+}\!x$，$x$的复杂度会被$x^{2}$的复杂所吸收，因此只需考虑最高阶。  
事实上，在分析和度量算法效率的时候，重点考虑的是当问题规模充分大时的函数值增长的情况。因此，分析和度量算法效率时，一般都使用渐近效率的概念，即从极限的角度考虑运行时间如何随输入规模的增长而增长。为了更加准确地阐释和度量算法复杂度随问题规模增长而增长的速度，计算机科学家在算法领域引入了一些函数增长符号，其中时间复杂度常用大𝑂符号表述，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。使用这种方式时，时间复杂度可被称为是渐近的，它主要考察当输入值充分大时的情况。  
对于绝大多数算法来说，其复杂度的增长速度还可以使用基本或常用函数增长类型通过示例性的方法来描述或表示，如常数级、对数级、多项式级、指数级、阶乘级增长速度，等等。这些常用函数的增长速度非常直观，以它们增长速度为标准对算法的计算复杂度进行度量，会使得算法复杂度分析变得易于理解。因此，掌握这些常用函数的基本增长类型对算法设计具有非常重要的指导意义，下面对其做简要介绍：  
（1）$\mathrm{O}(1)$：复杂度为常数级，例如从一个数据集中取出第一个元素；  
（2）$\mathrm{O}(\lg n)$：该类型常见于将一个数据集分成两半，然后将其中每一半再分成两半，以此类推。例如对有序数组进行二分查找，其时间复杂度就是$\mathrm{O}(\lg n)$；  
（3）$\mathrm{O}(n)$：该类型常见于数据集中的遍历，例如在线性结构中顺序查找某个元素的算法，其时间复杂度就是$\mathrm{O}(n)$；  
（4）$\mathrm{O}(n\lg n)$：该类型与前面所述的$\mathbf O(1g\ n)$有点类似，常见于将一个数据集分成两半，然后将每一半再分成两半，并且对每一半数据进行遍历，以此类推，例如归并排序时间复杂度就是$\mathrm{O}(n\,1\mathrm{g}\,n)$；  
（5）${\mathrm{O}}(n^{2})$：常见于两重嵌套循环的算法之中，也就是说在遍历一个数据集中的每一个元素的时候同时遍历另一个数量级相同的数据集，基本排序算法（如冒泡排序、直接插入排序、直接选择排序等）的时间复杂度是${\mathrm{O}}(n^{2})$；  
（6）${\mathrm{O}}(n^{3})$：该类型常见于三重嵌套循环的算法之中，在线性代数中，两个$n$阶方阵相乘的时间复杂度就是${\mathrm{O}}(n^{3})$，著名求解最短路径Floyd 算法的时间复杂度也是${\mathrm{O}}(n^{3})$；  
（7）$\mathrm{O}(2^{n})$：为一个数据集生成所有的子集，这种数量级的算法可以说是很低效的，在规模较大的时候是不可行的；  
（8）$\mathrm{O}(n!)$：对具有$n$ 个元素的集合进行全排列时就是该类型的典型例子，这种数量级的算法基本上是不可行的。"
满射函数,概念,"['第七章 函数与特殊函数', '§ 7.1 函数的基本概念', '7.1.2 函数的基本类型']","{'实体类型': '概念', '定义': '如果集合B中的每个元素都有原像，则称f为A到B的满射函数', '条件': 'f的值域等于B'}",,3,"从本质上讲，从集合$𝐴$到集合$B$的函数描述的是$𝐴$中元素与$𝐵$中元素之间的一种特殊对应关系，这种特殊对应关系可以是一对一的也可以是多对一的，但不能是一对多或多对多的关系。这是函数对应关系与一般对应关系的主要差别。此外，函数值域可以是$B$的某个真子集，也可以是$B$自身。根据以上讨论，就可将所有函数分成如下四种不同的基本类型，即是单射但不是满射的函数、是满射但不是单射的函数、既是单射又是满射的函数、既不是单射也不是满射的函数。本节主要讨论这四种函数，首先给出单射函数和满射函数的定义：  
【定义7.5】设$f$从集合$𝐴$到集合$ B$的函数：  
（1）若$f$的不同自变量映射到不同的像，则称$f$为为$𝐴$到$B$的单射函数,简称为单射。也就是说，对任意的$x_{1},x_{2}\in A$，如果$x_{1}\neq x_{2}$，那么$f(x_{1})\neq f(x_{2})$，则称$f$为$𝐴$到$B$的单射。  
（2）如果集合$ B$中的每个元素都有原像，则称$f$为$𝐴$到$B$的满射函数，简称为满射；也就是说，如果$f$的值域等于$B$，即有$𝑟𝑎𝑛$ $f=B$，则称${f}$为$𝐴$到$B$的满射。  
（3）若$f$是满射且是单射，则称$f$为$𝐴$到$B$的双射；若$A=B$，则称${f}$为$𝐴$上的函数；当$𝐴$上的函数$f$是双射时，则称$f$为$𝐴$上的一个变换。  
可依据上述定义判断函数$f\colon A\to B$是否为满射、单射、双射。判断满射就是检查$B$中的每个元素是否都是函数值。如果在$B$中找到不是函数值的元素，那么$f$就不是满射的。判断单射的方法就是检查不同的自变量是否对应于不同的函数值。  
由定义7.2 和例7.1.7 可看出，若$ f$是从有限集$𝐴$到有限集$B$的函数，则$f$是单射的必要条件是$|A|\leq|B|$；$f$是满射的必要条件是$|A|\geq|B|$；$f$是双射的必要条件是$|A|=|B|$。此外，当$A$ 和$B$ 是基数相同的有限集合时，还有以下结论：  
【定理7.3】设$𝐴$，$B$是有限集合且$|A|=|B|$。如果$f$是一个从$A$到$B$的单射函数，则$f$必然是从𝐴到$B$的满射函数，反之亦然。"
演绎或形式证明,概念,"['第三章  命题演算与推理', '§ 3.5 命题逻辑的演绎推理', '3.5.2 命题公式推演系统']","{'实体类型': '概念', '定义': '从前提集合Г推出结论H的一个演绎或形式证明，就是构造一个命题公式的有限序列：H1,H2,H3,...,Hn。其中：Hi或者是Г中的某个前提，或者是前面的某些Hj(j<i)的有效结论，并且Hn就是H'}",,3,"现在我们学习命题的数理逻辑推理。首先给出如下有效推理的概念：  
【定义3.28】设$G_{1},G_{2}\cdots G_{n}$，$H$是一些命题公式，如果它们满足下列性质：对于这些公式的任意一个解释𝐼，$G_{1},G_{2}\cdots G_{n}$在该解释下同时为真的情况下$\cdot_{H}$在该解释下也为真，则称命题公式$G_{1},G_{2}\cdots G_{n}$可有效推出公式$\cdot H$，或称由$G_{1},G_{2}\cdots G_{n}$得到$H$的逻辑推理为有效推理，记为$G_{1},G_{2}\cdots G_{n}\Rightarrow H$，并称$G_{1},G_{2}\cdots G_{n}$为推理前提，$H$为$G_{1},G_{2}\cdots G_{n}$的逻辑结论。  
从上述定义不难看出，有效推理其实就是把永真蕴含关系由两个命题公式之间的关系推广到多个命题公式之间的关系，即由一组命题公式构成的永真蕴含前件与一个永真蕴含后件之间的关系。下面定理表明有效推理的过程其实就是证明逻辑蕴含式的过程。  
【定理3.14】命题公式$H$是命题公式$G_{1},G_{2},\cdots,G_{n}$的逻辑结论，即$G_{1},G_{2},\cdots,G_{n}\Rightarrow H$，当且仅当$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\to H$为永真公式。  
从理论上讲，利用真值表技术完全可以在有限的步骤内完成对任意含有限个命题变量的永真蕴含关系进行判定或者说进行有效的命题逻辑推理。但是，在针对具体问题的命题逻辑推理时，推理的前提条件一般包含很多个命题公式，有时会涉及大量的命题变量，此时真值表方法就出现组合爆炸问题而变的不可行。因此，需要建立一种命题公式推演系统，在少量基本等值关系式和永真蕴含关系式的基础上，通过建立若干推理规则进行演绎推证的方式实现命题逻辑的有效推理。人们提出了很多各具特色的推演系统，对这系统的详细讨论已经超出了本课程的学习范畴，有兴趣的读者可以查阅相关资料。我们主要介绍一种最基本的推演系统，下图3-9 表示系统的基本结构。  
![](images/9e9fac00c2d40b2f3ec288b2f0ea17c474bc9160a1447874b9a37744cd5272d2.jpg)
图3-9 推演系统的基本结构  
上图表示的推演系统中包括事实库、公理库和推理规则这三个基本模块，公理库和事实库构成命题推理的基本依据。公理库包含已被证明为正确的24 个基本等值式和15 个基本永真蕴含式，这些基本关系式构成推演系统的基础知识资源，事实库由具体命题推理实例的所有前提条件以及推理过程中产生的有效中间结论组成；推理规则是命题逻辑推理的核心机制，主要由$P$规则、$T$规则和$C P$规则这三个基本规则组成。  
（1）$P$规则（前提引用规则）：推导过程中可随时引入前提集合中的任意一个前提。  
（2）$T$规则（逻辑结果引用规则）推导的过程中可随时引入公式𝑆，该公式𝑆是由其前的一个或多个公式推导出来的逻辑结果。  
（3）$C P$规则（附加前提规则）如果能从给定的前提集合$\Gamma$与公式$P$推导出𝑆，则能从此前提集合$\Gamma$ 推导出$P\rightarrow S$。  
注意：$C P$规则适用于结论为条件式的有效推理。使用𝐶𝑃规则就是把结论中的前件作为附加前提加入前提集合，共同去推出结论的后件。  
根据上述命题演算推理系统，就可进行有效的命题逻辑推理。通过有效推理，就可证明命题逻辑中所有定理。所谓证明，就是有效推理的具体推演过程，具体定义如下：  
【定义3.29】从前提集合Г 推出结论$\cdot H$的一个演绎或形式证明，就是构造一个命题公式的有限序列：$H_{1},H_{2},H_{3},\ldots,H_{n}$。其中：$H_{i}$或者是Г 中的某个前提，或者是前面的某些${\cdot}H_{j}(j{<}i)$的有效结论，并且${\cal H}_{n}$就是$H$。此时称$H$为该演绎的有效结论。"
演绎推理,概念,"['第三章  命题演算与推理', '§ 3.5 命题逻辑的演绎推理', '3.5.1 永真蕴含关系与判定']","{'实体类型': '概念', '定义': '从作为前提的命题公式中推出新的命题公式作为推理结论', '特点': '前提与结论之间具有必然联系', '本质': '揭示前提与结论之间的永真蕴含关系'}",,3,从数理逻辑的角度看，演绎推理就是从作为前提的命题公式中推出新的命题公式作为推理结论，而且前提与结论之间具有必然联系。这种必然联系就是如果前提为真，那么结论必然为真。因此，演绎推理的本质就是揭示前提与结论之间的这种永真蕴含关系。作为命题逻辑演绎推理的基础，本小节给出命题公式永真蕴含关系及其判定的基本知识。
点割集,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.3  无向图的连通性']","{'实体类型': '概念', '定义': '删除后增加连通分支数的结点集', '特点': '集合中所有结点必须同时删除以增加连通分支'}",,3,"前面我们学习了图的可达性概念及其判定，其描述的是图中两个结点之间是否可以通过一条或者多条通路进行联结，并从图的局部角度分别考察两个结点之间的连通关系。现在我  
们从全局性角度考察整个图中多个结点之间的连通关系，将两个结点之间的可达性概念推广到整个图中任意两个结点之间的可达性，由此得到图的连通性和连通图的相关概念。  
在图的连通性方面，无向图和有向图之间具有很大的差异。因此，我们分别讨论无向图和有向图的连通性。本小节主要介绍和讨论无向图连通性的概念与性质。首先给出无向图连通图的相关概念，具体定义如下：  
【定义8.25】设 $G=\langle V,E\rangle$ 为任一给定的无向图，对于图中的两个结点$v_{i}$ 与 $v_{j}$，如果从$\boldsymbol{v}_{i}$到$v_{j}$是可达的，则称从 $v_{i}$ 到 $v_{j}$是连通的，表示为[ $v_{i}\ \ ,v_{j}]$。规定图中任何结点与其自身是连通的。如果无向图$G$中任何两个结点之间都是连通的，则称该图为无向连通图或连通无向图，简称为连通图；否则，称$G$ 是非连通无向图，简称为非连通图。  
显然，无向图中两个结点之间的连通性是双向的，也就是说两结点之间的连通关系满足对称性，即：若有$v_{i}$ 到 $v_{j}$可达则必有$v_{j}$ 到 $v_{i}$可达。故在无向图中，也可将从${v}_{i}$ 到 $v_{j}$的连通说成$v_{i}$ 与 $v_{j}$连通。另外，注意到平凡图有且只有一个结点，根据无向图中结点连通性的规定，它是一种特殊的连通图。  
下面的定理表明，无向图模型中结点之间的连通性关系是一个等价关系：  
【定理8.7】设 $G=\langle V,E\rangle$ 为任一给定的无向图，其结点集为 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，令$R$ 是集合$\cdot V=\{v_{1},v_{2},\ldots,v_{n}\}$上结点之间的连通关系，即有：  
$R=\{\langle u,v\rangle|u,v\in V\}$, 且从$u$到𝑣连通}       （8-10）  
则$R$是集合𝑉上的一个等价关系。  
既然无向图模型中结点之间的连通性关系$R$是一个等价关系，那么就可以使用等价关系$R$ 将无向图 $G$ 的结点集合 𝑉 划分为若干互不相同的等价类，记为   $V_{1},V_{2},\ldots,V_{k}$ 。在这些等价类 中，相互连通的结点属于同一个等价类，不连通的结点属于不同的等价类。由此得到无向图模型的连通分支的概念，具体定义如下：  
【定义8.26】设 $G=\langle V,E\rangle$ 为任一给定的无向图$R$是图$G$结点集合𝑉上的连通性关系，则以关系𝑅的每个等价类为结点集的导出子图都称为图$G$的一个连通分支，并用$p(\mathbf G)$表示图𝐺的连通分支总数。  
由上述定义可知，如果无向图$G=\langle V,E\rangle$的结点连通性关系$R$作为一个等价关系，将结点集𝑉划分为$k$个不同的等价类$V_{1},V_{2},\ldots,V_{k}$，则由它们导出的子图$G(V_{1}),G(V_{2}),\cdots,G(V_{k})$均为图$G$的连通分支。因此，可以根据无向图中结点之间的连通关系实现对图模型的一个分解。显然，若   $p(G)=1$ ，则 $G$ 是连通图。若   $p(G)>1$ ，则   $G$ 是非连通图。  
【定义8.27】对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在结点集𝑉的某个子集 $V^{\prime}\subseteq$$V$ ，使得 $p(G-V^{\prime})>p(G)$ ，且对于 $V^{\prime}$的任何真子集 $V^{\prime\prime}$，有 $p(G-V^{\prime\prime})=p(G)$，则称 $V^{\prime}$为 $G$ 的点割集。如果点割集中只有一个结点 $v$ ，则称 $v$ 为割点。  
由上述定义可知，可通过删除图中适当结点以破坏图结构的方式考察图的连通程度。图中有些结点组成的集合在图的连通性中起着非常关键的作用，删除这些结点后会使得连通图变成非连通图，使得非连通图变得更加不连通，或者增加连通分支的数目。  
显然，对图中的任意一个点割集，该集合中所有结点都是由该点割集增加连通分支时必须同时删除的结点。例如在图8-40 所示的图$G_{1}$中，集合$\{v_{4}\},\{v_{1},v_{3}\}$都是点割集，但$\{v_{1},v_{3},v_{4}\}$则不是点割集，因为要增加图$G_{1}$的连通分支，不必同时删除结点$v_{1},v_{3},v_{4}$。  
需要注意的是，由于删除割点后，割点的邻接边也需要删除，因此我们用虚线表示已删除的边或者结点。同样，对下文所要介绍的边割集也做类似处理。  
同样，可以通过删除图中适当的边以破坏图结构的方式考察图模型的连通程度，由此可以得到边割集的相关概念，具体定义如下：  
【定义8.28】 对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在边集$E$的某个子集 $E^{\prime}\subseteq$$E$ ，使得 $p(G-\ E^{\prime})>p(G)$ ，且对于 $E^{\prime}$的任何真子集 $E^{\prime\prime}$，有 $p(G-\ E^{\prime\prime})=p(G)$，则称$V^{\prime}$为 $G$ 的边割集。如果点割集中只有一个条边  $e$ ，则称 $e$为割边或桥。  
![图8-42 例题8.24 图模型  ](images/6c126be3977ab4a2c63afc18255dc22be84fa010ee39891af7c0eba551970203.jpg)  
关于点割集与边割集，需要注意以下几个要点：  
（1）完全图 $K_{n}$ 无点割集，因为从 $K_{n}$ 中删除 $k\leq n-1$个顶点后，所得图仍然是连通的。  
（2）$n$ 阶零图既无点割集也无边割集。  
（3）对于连通图 $G$，$E^{\prime}$为 $G$ 的边割集，则必有 $p(G-E^{\prime})=2$ 。 因为删除一条边最多只能增加一个连通分支。  
（4）对于连通图 $G\ \ ,V^{\prime}$为 $G$ 的点割集，则 $p(G-V^{\prime})\geq2$，而且可能 $p(G-E^{\prime})>2$因为删除一个结点可能增加多个连通分支。  
从上述例题可以看出，对于任意给定的一个无向连通图，经常会有多个点割集或边割集，而且每个集合中所含元素的个数也不一样。此时，需要重点关注的应该是那些个数最小的集合。因为这些集合刻画了图连通结构中最为薄弱的环节，反映了连通图的最低连通程度。由此得到无向图连通图的点连通度与边连通度的概念，具体定义如下：  
【定义8.29】对于任意给定的一个无向连通图 $G=\langle V,E\rangle$，令：$\kappa(G){=}m i n\{|V^{\prime}||V^{\prime}$为G 的点割集}；$\lambda(\mathbf{G})=\operatorname*{min}\{|E^{\prime}||E^{\prime}$为G 的边割集} 并称 $\kappa(G)$ 为图 $G$ 的点连通度，$\lambda(G)$ 为图 $G$ 的边连通度。  
显然，点连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少结点数，边连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少边数。  
例如，对于图8-44 所示的无向连通图$G$ ，有$\kappa(G)=2$，$\lambda(G)=3$；对于图8-45 所示的彼得森图，有$\kappa(G)=\lambda(G)=3$。  
![图8-44 图的连通度  ](images/28f9ee3f26ab71faac7e5360d73417062a5a59d8421071b9feb627483727c42a.jpg)  
![图8-45  彼得森图  ](images/80ddd389b19bdc8904c989e51a73f2c183cb8c6f73b8b9c479ee3affcb66c7c0.jpg)  
关于无向连通图的点连通度$\kappa(G)$和边连通度$\lambda(\mathrm{G})$，需要注意以下几个要点：  
（1）如果 $G$是平凡图或非连通图，则规定 $\kappa(G)=\lambda(G)=0;$  
（2）如果$G$ 是完全图 $K_{n}$ ，由于 $G$ 中无点割集，当删除 $n-1$个顶点后，$G$ 为平凡图，故 $\kappa(G)=n-1$。  
（3）如果 $G$ 中存在割点，则 $\kappa(G)=1$；如果 $G$ 中存在割边，则 $\lambda(G)=1$。对于任何无向图 $G$ ，其点连通度 $\kappa$ 、边连通度 $\lambda$ 与结点最小度 δ 之间有如下关系：  
【定理8.8】对于任一无向图$G=\langle V,E\rangle$ ，均成立下列不等式：
$$
\kappa(G)\leq\lambda(G)\leq\delta\ (G)
$$"
点着色,概念,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.3.3 着色问题与算法', '一、点着色与边着色']","{'实体类型': '概念', '定义': '对图中每个结点涂上或标注一种颜色，并满足相邻的两个点具有不同的颜色', '特点': '若图G是k-可着色的，但不是(k-1)-可着色的，则称G是一个k-色图，并称k为图G的点色数或色数'}",,4,"首先考察一个实例，我们通常在同一台冰箱内存放不同种类的食物，其中有些食品必须分别保存在不同冰箱隔间以免串味或污染。例如，苹果和鸡蛋应该分开存放、腊肉和蔬菜应该分开存放等等。现有$A,B,C,D,E,F$六种食品，若要求$𝐴$与$𝐵$、$𝐴$与$C$、$𝐴$与$𝐷$、$B$与$C$、$C$与$D$、$C$与$F$、$D$与$E$、$E$与$F$不能放在一起，则至少需要几个隔间才能存放这些食物。  
![图10-56 冰箱中食物存放问题  ](images/557fa53c5bf02920ef35e88225888a1b53ecb35568cc495b689ec5f32f0de05e.jpg)  
可用一个无向图模型表示上述问题，图的每个结点分别代表一种食物，如果两种食物不能放在一起，则在这两种食物之间画一条无向边，如图10-55（a）所示。可通过对该图的结进行着色的方法实现对上述问题的求解。具体地说，就是对图中每个结点分别涂上或者标注一种颜色，并满足相邻的结点之间具有不同的颜色，将相同颜色结点所代表的食物放在同一个隔间，则所需要的最少颜色数目显然就是所求的冰箱隔间数目。  
不难知道，最少需要三种颜色才能实现对图10-55（a）所示无向图全部结点的着色，图10-55（b）表示其中一种着色方案。  
事实上，如果将上述六种食物分别看成是某个工程中的六项不同的任务，将不能存放在同一个隔间的两种食物理解为不能同时执行的两个任务，则可按照图10-55（b）所示的结点着色方案将这些任务以同色为标准分成3 个并行执行的任务集合。因此，无向图的着色理论与方法在并行计算与任务规划等领域具有非常重要的作用。  
对于一个比较复杂的无向图，要实现对该图所有结点的着色，在很多情况下不是一件很显然的事情。下面具体考察点着色问题，首先给出结点着色的定义，具体如下：  
【定义10.11】设$G=\langle V,E\rangle$是任意给定的一个无向图，如果对图𝐺的每个结点都涂上或标注一种颜色，并满足相邻的两个点具有不同的颜色，则称这种操作是对图$G$的结点着色，简称为对图𝐺的点着色。如果这些颜色选自于一个有𝑘种颜色的集合而不管$k$种颜色是否都用到，则称这样的点作色为称为𝒌着色，并称𝐺是${k}$-可着色的。若𝐺是$k{-}$可着色的，但不是$(k-$$1)-$可着色的，则称𝐺是一个${k}$-色图，并称$k$为图𝐺的点色数或色数，记为$𝜒(𝐺)$。  
![](images/53a26dc56eb7520c616c57e24f7d17f1e7686d610feaf89b55e20658f6ec1e28.jpg)  
例如，对于图10-55（a）所示无向图，该图就是一个3-色图，其射数$\chi(G)=3$。再如，图56（a）所示完全图$K_{5}$是一个5-色图；图56（b）所示完全二分图$K_{3,4}$是一个2-色图；图56（c）所示回路$C_{6}$是一个2-色图；图56（d）所示回路$C_{5}$为一个3-色图。  
通过上述例题不难看出，对于$G$的任何子图$H$，均有$\chi(H)\leq\chi(G)$，若$G$是$n$阶完全图，则$\chi(G)=n$；若$G$是至少有一边的二分图，则$\chi(G)=2$；若$G$是长为奇数的圈，则$\chi(G)=3$。一般地，关于无向图$G$的点色数，有如下定理：  
【定理10.19】设$G=\langle V,E\rangle$是任意给定的一个无向图，则有：  
（1）$\chi(G)=1$当且仅当$G$为零图。  
（2）对于完全图$K_{n}$：$\chi(K_{n})=n$。  
（3）$G$是一条回路：则若$|V|$是偶数，$\chi(G)=2$；若$|V|$是奇数，$\chi(G)=3$（4）$G$是一棵非平凡树，则$\chi(G)=2$。  
（5）$\chi(G)=2$的充要条件是：（a）$|E|\ge1$；（b）$G$为二分图。  
（6）对于任意无向线图$G$，若其结点的最大度为$\Delta(G)$  
$$
\chi(G)\leq\Delta(G)+1
$$  
【定理10.20】（布鲁克斯定理）设$G$是一个连通简单图，其结点的最大度为$\Delta(G)$。如果$G$既不是完全图，也不是长度奇数的基本回路，则$\chi(G)\leq\Delta(G)$。  
我们知道，任意一个不是零图的无向图都是由结点和边这两个要素构成，既然可对结点进行着色，自然也可对边进行着色。由此得到如下边着色的相关定义：  
【定义10.12】设$G=\langle V,E\rangle$是任意给定的一个无向图，如果对图$G$的每条边都涂上或标注一种颜色，并满足相邻的两条边具有不同的颜色，则称这种操作是对图$G$的边着色。如果这些颜色选自于一个有$k$种颜色的集合而不管$k$种颜色是否都用到，则称这样的边作色为称为𝒌边着色，并称$G$是$\pmb{k}$-边可着色的。若$G$是$k^{-}$边可着色的，但不是$\,(k-1)$-边可着色的，则称$G$是一个$\pmb{k}$-边色图，并称$k$为图$G$的边色数，记为$\chi^{\prime}(G)$。  
关于边色数的问题, 可以说目前已得到较好的解决。乌克兰数学家维津在1964 年提出的维津定理给出一个比较满意答案，具体如下：  
【定理10.21】（维津定理）设$G=\langle V,E\rangle$是任意给定的一个无向图，则有：  
（1）若图$G$是简单图，图中结点最大度为$\Delta(G)$，则$\chi^{\prime}(G)=\Delta(G)$或$\Delta(G)+1$；  
（2）若图$G$是二分图，图中结点最大度为$\Delta(G)$，则$\chi^{\prime}(G)=\Delta(G)$；  
（3）对于完全图$K_{n}$，若$n(n\neq1)$为奇数，$\chi^{\prime}(K_{n})=n$；若$_{n}$为偶数，$\chi^{\prime}(K_{n})=n-1$"
点连通度,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.3  无向图的连通性']","{'实体类型': '概念', '定义': '产生非连通图或平凡图需要删除的最少结点数'}",,3,"前面我们学习了图的可达性概念及其判定，其描述的是图中两个结点之间是否可以通过一条或者多条通路进行联结，并从图的局部角度分别考察两个结点之间的连通关系。现在我  
们从全局性角度考察整个图中多个结点之间的连通关系，将两个结点之间的可达性概念推广到整个图中任意两个结点之间的可达性，由此得到图的连通性和连通图的相关概念。  
在图的连通性方面，无向图和有向图之间具有很大的差异。因此，我们分别讨论无向图和有向图的连通性。本小节主要介绍和讨论无向图连通性的概念与性质。首先给出无向图连通图的相关概念，具体定义如下：  
【定义8.25】设 $G=\langle V,E\rangle$ 为任一给定的无向图，对于图中的两个结点$v_{i}$ 与 $v_{j}$，如果从$\boldsymbol{v}_{i}$到$v_{j}$是可达的，则称从 $v_{i}$ 到 $v_{j}$是连通的，表示为[ $v_{i}\ \ ,v_{j}]$。规定图中任何结点与其自身是连通的。如果无向图$G$中任何两个结点之间都是连通的，则称该图为无向连通图或连通无向图，简称为连通图；否则，称$G$ 是非连通无向图，简称为非连通图。  
显然，无向图中两个结点之间的连通性是双向的，也就是说两结点之间的连通关系满足对称性，即：若有$v_{i}$ 到 $v_{j}$可达则必有$v_{j}$ 到 $v_{i}$可达。故在无向图中，也可将从${v}_{i}$ 到 $v_{j}$的连通说成$v_{i}$ 与 $v_{j}$连通。另外，注意到平凡图有且只有一个结点，根据无向图中结点连通性的规定，它是一种特殊的连通图。  
下面的定理表明，无向图模型中结点之间的连通性关系是一个等价关系：  
【定理8.7】设 $G=\langle V,E\rangle$ 为任一给定的无向图，其结点集为 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，令$R$ 是集合$\cdot V=\{v_{1},v_{2},\ldots,v_{n}\}$上结点之间的连通关系，即有：  
$R=\{\langle u,v\rangle|u,v\in V\}$, 且从$u$到𝑣连通}       （8-10）  
则$R$是集合𝑉上的一个等价关系。  
既然无向图模型中结点之间的连通性关系$R$是一个等价关系，那么就可以使用等价关系$R$ 将无向图 $G$ 的结点集合 𝑉 划分为若干互不相同的等价类，记为   $V_{1},V_{2},\ldots,V_{k}$ 。在这些等价类 中，相互连通的结点属于同一个等价类，不连通的结点属于不同的等价类。由此得到无向图模型的连通分支的概念，具体定义如下：  
【定义8.26】设 $G=\langle V,E\rangle$ 为任一给定的无向图$R$是图$G$结点集合𝑉上的连通性关系，则以关系𝑅的每个等价类为结点集的导出子图都称为图$G$的一个连通分支，并用$p(\mathbf G)$表示图𝐺的连通分支总数。  
由上述定义可知，如果无向图$G=\langle V,E\rangle$的结点连通性关系$R$作为一个等价关系，将结点集𝑉划分为$k$个不同的等价类$V_{1},V_{2},\ldots,V_{k}$，则由它们导出的子图$G(V_{1}),G(V_{2}),\cdots,G(V_{k})$均为图$G$的连通分支。因此，可以根据无向图中结点之间的连通关系实现对图模型的一个分解。显然，若   $p(G)=1$ ，则 $G$ 是连通图。若   $p(G)>1$ ，则   $G$ 是非连通图。  
【定义8.27】对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在结点集𝑉的某个子集 $V^{\prime}\subseteq$$V$ ，使得 $p(G-V^{\prime})>p(G)$ ，且对于 $V^{\prime}$的任何真子集 $V^{\prime\prime}$，有 $p(G-V^{\prime\prime})=p(G)$，则称 $V^{\prime}$为 $G$ 的点割集。如果点割集中只有一个结点 $v$ ，则称 $v$ 为割点。  
由上述定义可知，可通过删除图中适当结点以破坏图结构的方式考察图的连通程度。图中有些结点组成的集合在图的连通性中起着非常关键的作用，删除这些结点后会使得连通图变成非连通图，使得非连通图变得更加不连通，或者增加连通分支的数目。  
显然，对图中的任意一个点割集，该集合中所有结点都是由该点割集增加连通分支时必须同时删除的结点。例如在图8-40 所示的图$G_{1}$中，集合$\{v_{4}\},\{v_{1},v_{3}\}$都是点割集，但$\{v_{1},v_{3},v_{4}\}$则不是点割集，因为要增加图$G_{1}$的连通分支，不必同时删除结点$v_{1},v_{3},v_{4}$。  
需要注意的是，由于删除割点后，割点的邻接边也需要删除，因此我们用虚线表示已删除的边或者结点。同样，对下文所要介绍的边割集也做类似处理。  
同样，可以通过删除图中适当的边以破坏图结构的方式考察图模型的连通程度，由此可以得到边割集的相关概念，具体定义如下：  
【定义8.28】 对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在边集$E$的某个子集 $E^{\prime}\subseteq$$E$ ，使得 $p(G-\ E^{\prime})>p(G)$ ，且对于 $E^{\prime}$的任何真子集 $E^{\prime\prime}$，有 $p(G-\ E^{\prime\prime})=p(G)$，则称$V^{\prime}$为 $G$ 的边割集。如果点割集中只有一个条边  $e$ ，则称 $e$为割边或桥。  
![图8-42 例题8.24 图模型  ](images/6c126be3977ab4a2c63afc18255dc22be84fa010ee39891af7c0eba551970203.jpg)  
关于点割集与边割集，需要注意以下几个要点：  
（1）完全图 $K_{n}$ 无点割集，因为从 $K_{n}$ 中删除 $k\leq n-1$个顶点后，所得图仍然是连通的。  
（2）$n$ 阶零图既无点割集也无边割集。  
（3）对于连通图 $G$，$E^{\prime}$为 $G$ 的边割集，则必有 $p(G-E^{\prime})=2$ 。 因为删除一条边最多只能增加一个连通分支。  
（4）对于连通图 $G\ \ ,V^{\prime}$为 $G$ 的点割集，则 $p(G-V^{\prime})\geq2$，而且可能 $p(G-E^{\prime})>2$因为删除一个结点可能增加多个连通分支。  
从上述例题可以看出，对于任意给定的一个无向连通图，经常会有多个点割集或边割集，而且每个集合中所含元素的个数也不一样。此时，需要重点关注的应该是那些个数最小的集合。因为这些集合刻画了图连通结构中最为薄弱的环节，反映了连通图的最低连通程度。由此得到无向图连通图的点连通度与边连通度的概念，具体定义如下：  
【定义8.29】对于任意给定的一个无向连通图 $G=\langle V,E\rangle$，令：$\kappa(G){=}m i n\{|V^{\prime}||V^{\prime}$为G 的点割集}；$\lambda(\mathbf{G})=\operatorname*{min}\{|E^{\prime}||E^{\prime}$为G 的边割集} 并称 $\kappa(G)$ 为图 $G$ 的点连通度，$\lambda(G)$ 为图 $G$ 的边连通度。  
显然，点连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少结点数，边连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少边数。  
例如，对于图8-44 所示的无向连通图$G$ ，有$\kappa(G)=2$，$\lambda(G)=3$；对于图8-45 所示的彼得森图，有$\kappa(G)=\lambda(G)=3$。  
![图8-44 图的连通度  ](images/28f9ee3f26ab71faac7e5360d73417062a5a59d8421071b9feb627483727c42a.jpg)  
![图8-45  彼得森图  ](images/80ddd389b19bdc8904c989e51a73f2c183cb8c6f73b8b9c479ee3affcb66c7c0.jpg)  
关于无向连通图的点连通度$\kappa(G)$和边连通度$\lambda(\mathrm{G})$，需要注意以下几个要点：  
（1）如果 $G$是平凡图或非连通图，则规定 $\kappa(G)=\lambda(G)=0;$  
（2）如果$G$ 是完全图 $K_{n}$ ，由于 $G$ 中无点割集，当删除 $n-1$个顶点后，$G$ 为平凡图，故 $\kappa(G)=n-1$。  
（3）如果 $G$ 中存在割点，则 $\kappa(G)=1$；如果 $G$ 中存在割边，则 $\lambda(G)=1$。对于任何无向图 $G$ ，其点连通度 $\kappa$ 、边连通度 $\lambda$ 与结点最小度 δ 之间有如下关系：  
【定理8.8】对于任一无向图$G=\langle V,E\rangle$ ，均成立下列不等式：
$$
\kappa(G)\leq\lambda(G)\leq\delta\ (G)
$$"
爱氏筛法,算法,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.3 素数的性质与查找']","{'实体类型': '算法', '应用': '查找所有不超过N的素数', '方法': '首先把所有不超过N的正整数按从小到大的次序排成一个队列，然后在队列中划去1以及划去一切不超过√N的素数的所有倍数，剩下的数即为所求的素数'}",,3,"通过算术基本定理可以看出，素数是构成所有整数的基本要素，在整个整数理论中占据非常重要的基础性地位。现在我们就来学习有关素数的基本知识，讨论素数的若干基本性质、素数的分布以及相关的查找方法。  
素数的一个非常独特性质是它与其它整数之间具有如下非常简单而直接的关系，这种简单直接的关系是使用素数考察整数性质的基础。  
【定理2.15】假设$p$ 是任意一个给定的素数，则它与其它任意整数$a$ 之间的关系是：要么$p$ 与$a$ 互素，要么$p$ 能够整除$a$。  
可以通过上述定理证明下面结论：  
【定理2.16】假设$p$ 是任意一个给定的素数，$a$ 和$b$ 是任意两个整数，如果$p$ 能整除$a$与$b$ 的乘积，则$p$ 至少能整除$a$ 与$b$ 中的一个。更一般地，假设$a_{1},a_{2},\cdots,a_{k}$是任意给出的$k$个整数，如果素数$p$ 能够整除$a_{1},a_{2},\cdots,a_{k}$，则$p$ 至少能够整除$a_{1},a_{2},\cdots,a_{k}$中的一个。  
下面讨论素数的计数问题。首先考虑在整个正整数集合中，到底有多少个素数？下面的定理给出了答案：  
【定理2.17】正整数集合中的素数有无穷多个。  
下面进一步讨论有限正整数集合中素数的计数与分布情况：  
【定理2.18】设$a$是任意大于1 的整数，则$a$除1 外的最小正因数$q$一定是素数，并且，当$a$是合数时，$q\leq{\sqrt{a}}$，亦即：若$a$ 是合数，则$a$ 必有一个小于等于$\sqrt{a}$的素因子。  
使用上述定理，可以获得一种名为爱氏筛法的素数查找方法。对于任意给定的一个正整数$N$，可以使用该方法找到所有不超过$N$的素数，具体做法如下：  
首先把所有不超过$N$的正整数按从小到大的次序排成一个队列，然后在队列中划去1以及划去一切不超过$\sqrt{N}$的素数的所有倍数，剩下的数即为所求的素数。  
由于有无穷多个素数，因此人们总是希望能够找到尽可能大的素数。300 年来人们找到的最大素数都是$2^{p}-1$这种形式的整数，其中$p$ 也是素数。我们将具有这种形式的素数称为梅森素数，目前有一个名为互联网梅森素数大搜索组织专门搜索大素数，有兴趣的读者可以查阅有关资料了解大素数查找的进展情况。"
特征函数,特殊函数,"['7.3.1 特征函数的概念', '7.3.2 特征函数的运算', '第七章 函数与特殊函数', '§ 7.3 集合的特征函数']","{'实体类型': ['特殊函数', '概念'], '特点': ['用于表示集合的特征', '集合U的任意一个子集A都有一个与之相对应的特征函数χA'], '定义': ['假设U为任一给定的集合，对于U的任一子集A特征函数χA定义为一个从U到集合{0,1}二值函数', '用于表达集合之间关系的函数'], '结论': '空集的特征函数恒为0，U的特征函数恒为1', '应用': '集合之间的运算转化为特征函数之间的运算'}",,1,函数是一个在自然科学、工程技术，甚至在某些社会科学中被广泛应用的数学概念，无论在初等数学还是高等数学中，无论在基础课还是专业课中，大家都会经常与函数打交道，以函数为基本工具解决各种各样的数学问题和专业问题。然而，从严格意义角度给函数下个定义并不是一件容易的事情。有人会说，函数不就是一个集合到另外一个集合的映射吗？或者说，函数就是对于某个集合中的任一元素，在另外一个集合中存在唯一元素与之对应。这不就是函数的定义？如果函数是这样定义的话，那么映射或对应又怎么定义呢？这正是函数定义的困难所在。事实上，自函数概念首次被德国数学家被莱布尼茨提出以来，其定义一直没有得到很好地解决，因为没有人能够准确地回答什么叫映射或者对应。直到在集合论和关系理论出现后，人们才以关系理论为工具完美地解决了函数的定义。具体地说，函数就是一种满足单值性要求的特殊二元关系。通过关系模型定义函数，就用关系模型的特性来诠释映射或对应概念的含义。作为关系模型的一个具体应用，本章将从特殊关系的角度来介绍函数的基本知识及其应用，包括函数的基本概念、函数的基本运算，以及若干重要的特殊函数，例如特征函数、散列函数和置换函数等。
特征函数的运算,定理,"['第七章 函数与特殊函数', '§ 7.3 集合的特征函数', '7.3.2 特征函数的运算']","{'实体类型': '定理', '条件': '给定全集U，A⊆U和B⊆U', '结论': '对所有x⊆U，成立下列关系式：(1)χ_¬A(x)=1-χ_A(x); (2)χ_A∩B(x)=χ_A(x)·χ_B(x)=min{χ_A(x),χ_B(x)}; (3)χ_A∪B(x)=χ_A(x)+χ_B(x)-χ_A∩B(x)=max{χ_A(x),χ_B(x)}; (4)χ_A(x)≤χ_B(x)⇔A⊆B; (5)χ_A(x)=χ_B(x)⇔A=B; (6)χ_A-B(x)=χ_A∩¬B(x)=χ_A(x)·χ_¬B(x)=χ_A(x)-χ_A∩B(x)'}",,3,"有了集合的特征函数之后，集合之间的关系就可以用其特征函数的关系表达，集合之间的运算就转化为其特征函数之间的运算。  
【定理7.9】给定全集$U$，$A\subseteq U$和$B\subseteq U$，则对所有$x\subseteq U$，成立下列关系式：$(1)\chi_{\bar{A}}(x)=1-\chi_{A}(x);~~(2)~~\chi_{A\cap B}(x)=\chi_{A}(x)\cdot\chi_{B}(x)=m i n\{\chi_{A}(x),\chi_{B}(x)\};$ $(3)\chi_{A\cup B}(x)=\chi_{A}(x)+\chi_{B}(x)-\chi_{A\cap B}(x)=m a x\{\chi_{A}(x),\chi_{B}(x)\};$ $(4)\chi_{A}(x)\leq\chi_{B}(x)\Leftrightarrow A\subseteq B;\;\;(5)\chi_{A}(x)=\chi_{B}(x)\Leftrightarrow A=B;$ $(6)\chi_{A-B}(x)=\chi_{A\cap\bar{B}}(x)=\chi_{A}(x)\cdot\chi_{\bar{B}}(x)=\chi_{A}(x)-\chi_{A\cap B}(x)\,。$"
特征方程,概念,"['第一章  集合与计数基础', '§ 1.4 有限集的高级计数技术', '1.4.2 递推关系的求解']","{'实体类型': '概念', '定义': '如下方程：$x^{k}-a_{1}x^{k-1}-a_{2}x^{k-2}-\\cdots-a_{k-1}x-a_{k}=0$称为递推关系式(1 −17)的特征方程', '特点': '其根称为递推关系式(1 −17)的特征根'}",,3,"递推关系是复杂问题和动态问题求解重要工具，要使递推关系在问题求解中发挥作用特别是在计数问题中发挥作用，有时需要实现对递推关系式的求解，也就是说要找到满足递推公式的所有数列或部分数列的显示通项表达式。对递推关系式的求解是一个非常复杂的数学问题，属于离散数学及相关学科的前沿研究课题，有兴趣的读者可以查阅相关资料做进一步深入研究。作为抛砖引玉，我们仅介绍其中两种最常用的基本解法，即针对简单递推关系的迭代求解方法和针对常系数齐次线性递推关系的特征根求解方法。  
迭代求解法是一种最基本的解法，该方法主要用于求解一些比较简单的递推关系式，由如下两个基本步骤构成：  
第一、利用递推关系式对其右边的表达式进行迭代，并推测通项的显示表达式；  
第二、用数学归纳法证明得到的公式。  
目前还没有一个一般性的方法或公式能够实现对任意递推关系式的求解，通常需要针对对递推关系式的具体特点给出相应的求解方法。常系数齐次线性递推关系是一种特殊的递推关系，针对这类递推关系有一套完备可行的求解理论和方法。这套求解理论和方法是求解其它递推关系式的基础，因为很多其它递推关系式都是通过设法将其转化为某种常系数齐次线性递推关系的途径实现求解。下面给出常系数齐次线性递推关系的定义：  
【定义1.27】设$a_{1}$，$a_{2}$，⋯，$a_{k}$是$k$个常数且$a_{k}\neq0$，则下列递推关系：  
$$
u_{n}=a_{1}u_{n-1}+a_{2}u_{n-2}+\cdots+a_{k}u_{n-k}(n\geq k)
$$  
称为$k$阶常系数线性齐次递推关系。  
如果数列 $\{b_{n}\}_{n\geq0}$ 满足 $.b_{n}=a_{1}b_{n-1}+a_{2}b_{n-2}+\cdots+a_{k}b_{n-k}(n\geq k)$ ，则称数列 $\{b_{n}\}_{n\geq O}$ 或 $u_{n}=b_{n}{\big(}n=0,~1,~2,~\cdots{\big)}$是递推关系式(1 −17)的一个解。  
问题：递推关系式(1 −17)有没有解？如果有解，有多少个解？如何求解？下面的定理表明常系数齐次线性递推关系在满足初始条件的情况下有唯一解：  
【定理1.19】任意给出$k$个常数$b_{0}\,,\;\;b_{1}\,,\;\;\cdots\,,\;\;b_{k-1}$，有且仅有唯一一个数列是递推关系式 (1 −17) 满足初始条件 $v_{0}=b_{0}$ ， $v_{1}=b_{1}$ ， ⋯ ， $v_{k-1}=b_{k-1}$ 的解。  
对于常系数齐次线性递推关系的求解，基本思路是采用一种所谓特征根的方法，通过引入特征方程和特征根的概念，巧妙地将递推关系的求解问题转化为求代数方程根的求解问题。为此，我们引入如下特征方程和特征根的定义：  
【定义1.27】如下方程：  
$$
x^{k}-a_{1}x^{k-1}-a_{2}x^{k-2}-\cdots-a_{k-1}x-a_{k}=0
$$  
称为递推关系式(1 −17)的特征方程，它的根称为递推关系式(1 −17)的特征根。  
因为$a_{k}\neq0$，所以0 不是递推关系式(1 −17)的特征根。 下面的定理非常关键，它给出了特征根与常系数齐次线性递推关系解之间的联系：  
【定理1.20】设$q$ 是非0 复数，则$u_{n}=q^{n}$是递推关系式(1 −17)的一个解当且仅当$q$是递推关系式(1 −17)的一个特征根。  
下面定理给出了常系数齐次线性递推关系解的结构特点：  
【定理1.21】设$\cdot u_{n}=g_{i}(n)(i=1,2,\cdots,s)$均为递推关系式(1 −17)的解，$c_{i}(i=1,\!2,\cdots,s)$为任意常数，则有：  
$$
=\sum_{i=1}^{s}c_{i}g_{i}(n)
$$  
也是递推关系式(1 −17)的解。  
【定理1.22】如果递推关系式(1 −17)的$k$ 个特征根$q_{1}\,,\;\;q_{2}\,,\;\;\cdots\,,\;\;q_{k}$彼此相异，则  
$$
u_{n}=c_{1}q_{1}^{n}+c_{2}q_{2}^{n}+\cdots+c_{k}q_{k}^{n}
$$  
是递推关系式(1 −17)的通解。其中$c_{1}\,,\;\;c_{2}\,,\;\;\cdots\,,\;\;c_{k}$为任意常数。"
特性谓词,概念,"['4.1.3  量词与特性谓词', '§ 4.1 个体词、谓词与量词', '第四章  谓词演算与推理', '三、特性谓词及其应用']","{'实体类型': '概念', '作用': '解决具有不同个体域的谓词在逻辑演算时导致的个体域界定上的混乱', '定义': '用于确定个体变量个体域的谓词', '应用': '在谓词表达式中明确个体域', '特点': '与量词类型有密切关系', '方法': {'全称量词': '特性谓词作为蕴含式前件加入', '存在量词': '特性谓词作为合取项加入'}, 'name': '特性谓词'}",,3,不同的谓词，其变量的个体域会有所不同，这些具有不同个体域的谓词在一起进行逻辑演算时往往会导致演算结果在个体域界定上的混乱。通过引入量词和特性谓词，可以较好地解决这个问题。事实上，量词实现了对谓词中个体变量含义的约束，消除了谓词在语义上的抽象性和不确定性，可使谓词成为具有确定真值的命题。
特殊元素,概念,"['第十一章  抽象代数结构通论', '§ 11.2 代数结构的运算性质', '11.2.2 特殊元素']","{'实体类型': '概念', '定义': '代数结构中运算性质非常独特的元素', '类型': '单位元、零元、逆元和幂等元', '特点': '存在与否与代数结构中的具体运算密切相关', '作用': '刻画运算的基本性质和运算结构'}",,3,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)"
特殊关系模型,概念,['第六章 特殊关系模型'],"{'实体类型': '概念', '定义': '以关系模型的五个基本性质为标准，将所有关系按它们对这些基本性质满足程度和状态的不同划分为若干特殊类型', '作用': '构建各种特殊关系模型及相关理论'}",,1,前面学习了关系模型的概念及其五个基本性质。不难发现，日常生活或工作中很多关系虽然从表面上看形态各异、互不相同，但都满足一些相同的基本性质。例如集合之间的相等关系、直线之间的平行关系、多边形之间的全等关系、学生同学关系、整数之间的同余关系等等，它们都满足自反性、对称性和传递性这三条基本性质。我们自然会想到把所有满足这三条性质的关系归为一类特殊关系，并考察这类关系有什么特殊性质和特殊作用，以便在大量错综复杂的具体关系中找到一些共性特征和规律性认识。同样，还有一些关系满足另外一些基本性质，例如集合之间的包含关系、整数之间的整除关系、实数之间的大小关系、英文单词之间的字典排序关系等等，这些关系虽然表面上互不相同、各不相关，但它们都满足自反性、反对称性和传递性这三条基本性质。我们自然会将所有这类关系归为另外一类特殊关系，并考察这类关系有什么相应的特殊性质和特殊作用。通过以上分析，不难得到研究关系的一个普适性方法，就是以关系模型的五个基本性质为标准，将所有关系按它们对这些基本性质满足程度和状态的不同划分为若干特殊类型，然后分门别类地研究同类型关系的共同性质和不同类型关系之间的区别与联系，由此构建各种特殊关系模型及相关理论。显然，通过状态组合构造出的特殊关系有很多，不便一一枚举。作为代表，本章着重介绍其中三种最典型、最基本的特殊关系模型，并分别讨论它们各自的作用，即等价关系模型与元素的分类、相容关系模型与元素的聚类、偏序关系模型与元素的比较。
特殊函数,概念,"['第七章 函数与特殊函数', '§ 7.1 函数的基本概念']","{'实体类型': '概念', '介绍': '包括函数的集合定义、基本类型和一些常用特殊函数'}",,2,"函数概念的来源可以一直追溯到伟大的意大利物理家、天文学家和哲学家伽利略，伽利略在十七世纪就观察到了两个变量之间的制约关系，并用文字和比例的语言表达变量之间的函数关系。笛卡尔在他的解析几何中，已注意到一个变量对另一个变量的依赖关系，但未意识到要提炼函数概念，直到后来莱布尼茨第一个使用函数一词来表示一个量，并将函数值的变化看成是曲线上一个点的运动，才真正诞生函数的概念。人们通常使用的函数符号$f(x)$由欧拉发明。值得一提的是，欧拉是目前世界上最多产的数学家，其数学成果在他去世50 年后才基本上整理完成，但直到现在还没有全部整理完成。  
函数是数学中一个非常重要的内容,既是沟通各种学科之间的桥梁，也是读者今后学习其它相关课程的重要基础。函数方法是实际问题求解的一个基本方法论，在遇到实际问题的时候，很多情况下可以使用函数知识构造出相关的函数模型,进而通过对函数问题的研究实现对实际问题的求解。例如，深度学习中构造分类器的基本策略就是建立一个函数模型并通过数据训练使得该函数模型不断逼近所求的分类器函数。本节主要从集合与关系的角度介绍函数的基本概念，包括函数的集合定义、函数的基本类型和一些常用的特殊函数。"
特殊格,概念,"['第十二章 典型抽象代数结构', '§ 12.5 格的概念与性质']",{'实体类型': '概念'},,2,格是一种非常特殊的代数结构。如前所述，数学主要有偏序、代数、拓扑和测度这四大基本结构，格结构同时具备偏序结构和代数结构，并与拓扑结构具有非常紧密的联系。不过从本质上看，格仍属于代数结构。格结构在密码学、计算机语义学、开关理论、逻辑设计等多个领域都具有非常重要的应用。本节主要介绍格的基本概念与性质，包括偏序格与代数格的概念、格结构的基本性质、格同态与同构以及若干常用的特殊格。
特殊集合,概念,"['第一章  集合与计数基础', '§ 1.1 集合的基本知识', '1.1.2 集合的概念与表示']","{'实体类型': '概念', '定义': '具有特定性质的集合'}",,3,集合论从一个比数更加基本的概念——集合出发，定义出数和数的运算，进而演化出整个数学学科的理论体系。本小节将从集合的基本概念出发，介绍集合论中最为基础的知识，包括集合概念的含义、元素的概念与性质、集合的表示方法、集合之间的相等与包含关系、若干常用的特殊集合等。
环,概念,"['§ 11.1 代数结构的基本概念', '第十二章 典型抽象代数结构', '第十一章  抽象代数结构通论', '12.4.2  域的概念与性质', '12.4.1  环的概念与性质', '11.1.1 数学结构与代数结构', '§ 12.4 环和域的基本知识']","{'实体类型': '概念', '定义': ['含有两个二元运算的抽象代数结构，具有两个二元运算的典型代数结构', '具有两个二元运算的代数系统，满足加法是交换群，乘法是半群，且乘法对加法满足分配律', '由加法子系统和乘法子系统构成的代数结构，其中加法子系统是交换群，乘法子系统是半群或可交换含幺半群'], '基本知识': '环的基本概念与性质', '特点': ['同时具有加法和乘法两个运算', '由加法交换群和乘法半群组成，满足乘法对加法的分配律'], '分类': '含幺环、交换环、含幺交换环', '基本性质': '加法满足交换律、结合律，有单位元0，每个元素都有负元；乘法满足结合律，对加法满足分配律'}",,3,"代数结构作为四大基本数学结构之一，它以运算作为处理机制，在整个数学理论体系和计算机数学建模中占据非常重要的作用。代数结构是一种非常古老的数学结构，具有几千年发展历程，从最初初等代数逐步发展到大代数，然后进一步发展到抽象代数，目前正朝着泛代数的方向发展。本小节主要介绍抽象代数的由来及其基本知识结构。  
用计算机解决实际问题，一般需要对问题进行抽象并建立相应的数学模型，然后在此基础上将对实际问题的求解转化为对数学模型的求解。 因此，数学模型是用计算机解决实际问题的基础。现实问题纷繁复杂、变化万千，所建立的数学模型自然也是五花八门，多种多样，让人无所适从。值得欣慰的是，尽管我们面对的数学模型复杂多样，但从结构上看，所有这些数学模型都建立在四种基本的数学结构基础之上。  
这四种基本数学结构分别为：表示元素之间空间关系的拓扑结构，如图模型、树模型就是一些拓扑结构；表示元素之间运算关系的代数结构，如初等代数、向量代数、矩阵代数、命题代数、集合代数等都是代数结构；表示元素规模度量性质的测度结构，如高等数学里函数的微分和积分都是测度结构，它们主要计算面积、体积、弧长、速度等；表示元素之间次序关系的偏序结构，如整数的整除关系、集合的包含关系等偏序关系都是偏序结构。  
任何一个数学结构都是由载体、处理机制和处理规则这三个基本要素组成：  
（1）载体集合 对于任何一个数学结构，需要定义一些抽象的元素作为处理对象，这些抽象元素组成的集合构成数学结构的载体。载体集合是数学结构存在的基础或平台。  
（2）处理机制 为了实现对数学结构载体中元素的处理，需要定义一些处理机制，不同的数学结构具有不同的处理机制。例如：偏序结构是一种关系结构，它以元素之间的次序关系或者比较关系作为处理机制；代数结构是一种运算结构，它以元素之间的运算作为处理机制；拓扑结构是一种分布结构，它以元素之间的空间分布作为处理机制；测度结构则是一种度量结构，它以元素的规模度量作为处理机制。  
（3）处理规则 为使定义出来的数学结构满足一些合理性要求以及能够在处理实际问题中发挥作用，避免出现一些矛盾或荒诞的处理结果，还必须制定一些处理规则对处理机制做一些必要的限制。在现代数学的公理化系统中，通常称这些处理规则称为公理。不同的数学结构具有不同的处理规则，例如偏序结构限制元素之间的关系必须满足自反性、反对称性和传递性，这些限制或者性质构成了偏序结构公理系统；再如代数结构则是规定元素之间的运算必须满足结合律、交换律、分配律等运算性质。  
数学运算最早起源于算术运算，即使用具体的整数或分数进行四则运算。随着科学技术的不断发展，人们逐步意识到这种方法不能满足对一般性规律的认识。因此，采用抽象的字母来代替具体的整数和分数进行运算以获得通用性结果，并称之为代数运算或简称为代数。在微积分出现之前的数千年历史中，对代数运算的研究一直占据数学研究的核心地位。那时人们普遍信奉一种所谓的万能法则，即世界上所有问题都可以转化为数学问题，所有数学问题都可以转化为代数问题，所有代数问题都可以转化为方程问题。  
因此，在很长一段历史时期内，人们对数学的研究基本上都是对代数学的研究，对代数学的研究基本上是方程或方程组解法的研究。解方程是那个时期内所有数学家的中心任务，大家都非常期望能够通过使用代数运算的方法找到方程或方程组的通用求解公式。这种努力在线性方程组领域取得了非常完美的结果，并由初等代数逐步衍生出线性代数。但是，对于一元高次方程通用求解方法的研究并不是很顺利，对于次数高于四次的一元方程始终找不到通用求解公式或求解方法。一些非常著名的数学家，例如欧拉、高斯、拉格朗日等都对此做了大量非常艰苦的研究，但均告失败。  
在寻求五次方程通用求解方法的过程中，年仅17 岁的法国天才少年伽罗瓦在1828 年提出群的概念，运用群的思想证明了五次方程通用求解公式是不存在的，并给出了五次方程系数在满足一定条件下若干特殊解法，由此一举解决了困扰数学家长达200 多年的数学问题。伽罗瓦取得成功的关键在于不仅将运算对象进行抽象化，而且对运算本身进行抽象，在抽象对象和抽象运算的基础上通过构造一些特殊抽象代数结构进行求解。这个思想在当时实在过于超前以至于没有得到柯西、傅里叶、泊松等著名数学家的认可，泊松的判词是“完全不能理解”。 1832 年5 月31 日年仅21 岁的伽罗瓦死于决斗。在决斗之前，他把关于五次方程代数求解的研究成果写成长信，留给了人类。14 年后，法国数学家刘维尔整理并发表了伽罗瓦的遗作，人们才理解并惊叹他那超越时代的天才思想和巧妙构思。  
至此以后，人们对代数的研究内容由方程或方程组的求解技巧转变为对代数运算性质和运算结构的研究，通过对运算和运算对象进行抽象的方式实现对所有运算依其运算性质进行分类或归类，并将伽罗瓦的群论迅速发展成为一门称之为抽象代数结构的崭新数学分支。 抽象代数结构的诞生，把代数学从传统的初等代数发展到现代的抽象代数，由此打开了现代代数学的大门，开创了代数学研究的新纪元。因此，抽象代数结构通常也称为近世代数以区别于之前的初等代数。若无特别说明，我们通常将抽象代数结构简称为代数结构。  
经过一百多年的发展，抽象代数结构已经形成一个如图11-1 所示的知识体系。对于一个代数系统，我们不仅可以主动设计出它的运算并考察相应的运算规则，而且还可以通过分别对其载体集合进行相关改造或运算得到相应的子代数、积代数和商代数，可以通过映射的方式考察不同代数结构之间的区别与联系，还可根据运算性质对代数结构进行分类，形成若干典型抽象代数系统，如群、环、域、格等。  
![](images/37d476cf884c29ed65924bc021cb612de43bab4df8b1196f64e96cad4f61a01f.jpg)
图11-1 抽象代数结构的知识体系  
代数结构作为一种特殊的数学结构，具有载体、处理机制和处理规则这三个基本要素。如前所述，代数结构的载体就是由一些抽象对象为元素组成的集合，并通过运算机制实现对集合中元素的处理。所谓运算，其实就是通过映射的手段从已有元素中构造出新的元素。载体和运算统称为代数结构的成分。代数结构的处理规则即为运算性质。  
既然代数结构的载体是一个集合，那么就可以考虑通过一定方式由这个集合派生出新的集合并据此构造出新的代数结构。例如，可以考察其子集以及在子集上的运算，得到子代数的概念和性质；可以对作为载体的集合做笛卡尔集构成一个新的集合，并在新集合上定义相关运算，得到积代数的概念和性质；可以通过构造等价关系的方法实现对集合载体的划分，构成一个以等价类为元素的商集，并在这个商集上定义相关运算，得到商代数的概念和性质。子代数、积代数和商代数是构造和研究代数结构的基本方法论。  
当然，还可以考察两个代数结构之间的相似性与差异性。对于任意两个代数系统，可以在这两个代数结构的载体(集合)上建立一种保运算的映射，由此考察代数结构之间的联系。如果存在这种保运算映射，则称这两个代数系统同态。如果这种保运算的映射还是双射，则称这两个代数系统同构。同态和同构是考察代数结构之间联系的基本工具。  
依据代数结构的运算性质，可以将各种具体代数结构划分为若干抽象类型。典型的抽象代数结构类型主要有仅含一个二元运算的半群与群、含有两个二元运算的环与域，以及格与布尔代数。这些典型抽象代数结构构成代数结构知识体系的主要内容。"
环和图,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.2.1 图的基本运算', '一、图的集合运算']","{'实体类型': '概念', '定义': '由两个图模型的并图减去它们的交图后得到的图', '表达方式': 'G1⊕G2=(G1∪G2)-(G1∩G2)'}",,4,"图模型作为一种特殊的集合具有并、交、差、补、环和等集合运算，下面分别介绍这些集合运算及其相关性质。 首先给出两个图不交、不重的定义：  
【定义8.10】假设 $G_{1}=\langle V_{1},E_{1}\rangle$和 $G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，则有：  
（1）如果 $V_{1}\cap V_{2}=\varnothing$，则称 $G_{1}$ 与 $G_{2}$ 是不交的；  
（2）如果 $E_{1}\cap E_{2}=\varnothing$ ，则称 $G_{1}$ 与 $G_{2}$ 是边不交的，或者说是不重的。  
显然，对于任意两个不交的图它们必然是不重的，反之不然。  
下面给出图模型基本集合运算的定义：  
【定义 8.11 】假设   $G_{1}=\langle V_{1},E_{1}\rangle$ 和   $G_{2}=\langle V_{2},E_{2}\rangle$ 分别为不含孤立结点的图模型（它们 同为无向图或者同为有向图）。  
（1）令图 $G_{1}\cup G_{2}=\left\langle V,E\right\rangle$，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的并图，其中：$V=V_{1}\cup V_{2},\;\;E=E_{1}\cup E_{2}$  
当 $G_{1}$ 与 $G_{2}$ 不存在公共的边时，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$  的不重并。  
（2）设图 $G_{1}\cap G_{2}=\langle V,E\rangle$，称 $G_{1}\cap G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的交图，其中：$V=V_{1}\cap V_{2},\,\,\,E=E_{1}\cap E_{2}$  
$G_{1}\cap G_{2}$是由 $G_{1},G_{2}$ 中所有公共的边组成的图。  
（3）设图 $G_{1}-G_{2}=\langle V,E\rangle$，称 $G_{1}-G_{2}$ 为 $G_{1}$ 减 $G_{2}$ 的差图，其中：
$$
V=V_{1},\,\,\,E=E_{1}-E_{2}
$$  
$G_{1}-G_{2}$ 是在图 $G_{1}$ 中减去属于 $G_{2}$ 的边后所剩余的部分组成的图。  
（4）环和图 $G_{1}\oplus G_{2}$ 是由 $G_{1}$ 与 $G_{2}$ 的并图减去 $G_{1}$ 与 $G_{2}$ 的交图后得到的图。
$$
G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})
$$  
从上述定义可以看出，图模型的并、交、差、环和等集合运算其实就是普通集合运算的延伸。 需要注意的是：  
（1）若   $G_{1}=G_{2}$   ，则 $G_{1}\cup G_{2}=G_{1}\cap G_{2}=G_{1}(G_{2}),~~~~~G_{1}-G_{2}=G_{2}-G_{1}=\varnothing\,。$  
（2）$G_{1}$ 与 $G_{2}$ 不重时，$G_{1}\cap G_{2}=\varnothing$，$G_{1}-G_{2}=G_{1}$，  $G_2-G_1=G_2, G_1\oplus G_2=G_1\cup $$G_{2}$。  
（3）两个图的环和可用并、差、交给出，$G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})\,.$"
生成元,概念,"['第十二章 典型抽象代数结构', '§ 12.1 半群的概念与性质', '12.1.2  方幂与循环半群']","{'实体类型': '概念', '定义': '循环半群中能生成所有元素的元素', '性质': '生成集C是所有生成元的集合'}",,3,"我们知道半群和含幺半群都满足结合律，如果对载体集合中任意给定的某个元素进行多次重复运算，那么得到的运算结果与运算次序无关。也就是说，无论以怎样的次序对该元素进行多次重复运算，其结果仅与该元素和运算次数有关。因此，可对半群和含幺半群载体集合中的任意元素定义其方幂运算，具体如下：  
【定义12.6】假设$\langle G,*\rangle$是任意给定的一个半群，对于$\forall a\in G$和正整数$n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个 a}
$$  
如果$\langle G,*\rangle$是一个含幺半群且$e$是其单位元素，则定义$a^{0}=e$。  
例如，对于实数集合上的加法运算构成的含幺半群$\langle R,+\rangle$，显然有：  
$5^{3}=5+5+5=15;\;\;1^{4}=1+1+1+1=4;\;\;5^{0}=1^{0}=0;\;\;0^{0}=0^{1}=0^{2}=0$  
根据上述定义，显然成立方幂运算法则，即对于任意非负整数$ n$和$m$，有：
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
对于任意一个给定的半群或含幺半群$\langle G,*\rangle$，既然可以对其载体中的任意一个元素构造其任何次方幂，并且根据运算$*$在载体集合$ G$上的封闭性知，该元素所有方幂组成的集合必然是$G$的一个子集，那么自然就需要考察该子集以及运算$*$在该子集上的运算性质。下面的定理12.1 表明运算$*$可以在该子集上构成子半群或子含幺半群：  
【定理 12.1 】设 $\langle G,*\rangle$ 是任一给定的半群且对 $\forall a\in G$ ，令 $H=\{a^{n}|n\in Z^{+}\}$ ，则 $\langle H,*\rangle$ 是 $\langle G,*\rangle$的子半群。此时，若$\langle G,*\rangle$是含幺半群，则$\langle H,*\rangle$是$\langle G,*\rangle$的子含幺半群。  
如果$\langle G,*\rangle$是一个含幺半群，设$e$为其单位元。由于$e=a^{0}\in H$，故$e$也是$\langle H,*\rangle$的单位元。因此，$\langle H,*\rangle$也是一个含幺半群。  
从上述定理可知，对于任一给定的半群或含幺半群$\langle G,*\rangle$，载体集合$G$中任一给定元素$a$的所有方幂组成的集合$ H$可与运算$*$一起构成一种半群或含幺半群$\langle H,*\rangle$。事实上，$\langle H,*\rangle$是一种特殊的半群或含幺半群，其特殊性在于载体集合中$H$每个元素都是给定元素$a$的某个方幂。现在考察这种特殊半群或含幺半群的基本概念和性质，首先给出如下定义：  
【定义12.7】设$\langle G,*\rangle$是任一给定的半群，如果$\exists a\in G$，使得$G$中的任意元素$x$都能够写成元素$a$的方幂形式，即对于$\forall x\in G$，$\exists n\in N$,使得$x=a^{n}$，则称$\langle G,*\rangle$是一个循环半群，并称$a$是$\langle G,*\rangle$的一个生成元，$\langle G,*\rangle$的所有生成元组成的集合$C$称为$\langle G,*\rangle$的生成集。此时，如果$\langle G,*\rangle$还是一个含幺半群，则称$\langle G,*\rangle$是一个循环含幺半群。  
【定理 12.2】每个循环半群都是可交换半群。"
生成函数,概念,"['第一章  集合与计数基础', '§ 1.4 有限集的高级计数技术', '1.4.3 生成函数计数法']","{'实体类型': '概念', '定义': '设$x$为一抽象符号，$a_{n}$（$n=0,1,2,\\cdots$）为实数。若函数$F(x)$可表示成$F(x)=a_{0}+a_{1}x+a_{2}x^{2}+\\cdots+a_{n}x^{n}+\\cdots$，则称$F(x)$为数列$a_{n}$的生成函数', '条件': '若某个$a_{i}=0(i=0,1,2,\\cdots)$，则$a_{i}x^{i}$项可以略去'}",,3,"前面我们通过考察数列通项之间的递推关系建立求解问题的动态演化模型并据此实现对有限集合的计数。现在我们仍然以数列为基本工具，通过以数列为系数建立无穷次多项式或幂级数的方式找到联结离散数学与连续数学的桥梁，巧妙地将离散数学中离散量的计数问题转化为连续数学中对幂级数的处理问题。这种幂级数我们称之为数列的生成函数或母函数。生成函数是组合分析与计数的重要工具，运用生成函数求解某些给定条件下的组合数、排列数，以及求解某些递推关系时，有时能获得意想不到的效果。  
【定义1.28】设$\cdot x$为一抽象符号，$a_{n}$（$(n=0{,}1{,}2,\cdots)$）为实数。若函数$F(x)$可表示成  
$$
F(x)=a_{0}+a_{1}x+a_{2}x^{2}+\cdots+a_{n}x^{n}+\cdots
$$  
则称$\cdot F(x)$为数列$a_{n}$$_{\imath}\left(n=0,\!1,\!2,\cdots\right)$）的生成函数。并约定，若某个$\cdot a_{i}=0(i=0,1,2,\cdots)$，则$a_{i}x^{i}$项可以略去。  
比如$|F(x)=1+x+x^{2}+x^{3}+\cdots+x^{n}+\cdots$是无穷序列1，1，1，⋯的生成函数。  
对于一个有限序列$a_{0}\,,\;\;a_{1}\,,\;\;\cdots,\;\;a_{n}\,.$，可以通过将$a_{n}$之后的项定义为0 的方式扩充成一个无限序列，由此定义生成函数。对于有限序列，当$j>n$时没有形如$|a_{j}x^{j}$的项出现，即有：  
$$
G(x)=a_{0}+a_{1}x+\cdots+a_{n}x^{n}
$$  
【定理1.23】无穷重数的$m$元重集$\left\{\infty\cdot a_{1},\ \infty\cdot a_{2},\ \ \cdots,\ \infty\cdot a_{m-1},\ \infty\cdot a_{m}\right\}|$的$r$-组合数的母函数是$f(x)=(1+x+x^{2}+\cdots+x^{n}+\cdots)^{m}$，$f(x)$中$x^{r}$的系数等于上述$r-$组合数。"
生成函数计数法,算法,"['1.4.3 生成函数计数法', '§ 1.4 有限集的高级计数技术', '第一章  集合与计数基础']","{'实体类型': '算法', '特点': ['基于动态演化思想', '是组合分析与计数的重要工具，有时能获得意想不到的效果'], '应用': ['解决具有动态演化性质或复杂问题的计数', '求解给定条件下的组合数、排列数，以及求解某些递推关系'], '定义': '通过以数列为系数建立无穷次多项式或幂级数的方式，将离散数学中离散量的计数问题转化为连续数学中对幂级数的处理问题'}",,2,前述基本计数技术主要基于静态思维，即认为求解问题处在一个相对静止状态，通过一些静态方法将这些状态的相关数量计算出来。如果求解问题在本质上具有动态演化性质，或者问题比较复杂必须考察其演变历史，对这类问题的计数必须考察问题状态的演变过程和规律，此时基于静态思维的基本计数技术就不能满足要求。本节介绍基于动态演化思想的高级计数技术，主要包括递推关系计数法、递推关系求解技术、生成函数计数法。
生成树,概念,['第九章  树的基本理论与算法'],"{'实体类型': '概念', '相关理论': '关于树模型的基本理论'}",,1,"树是大家非常熟悉的一类植物。通过对树的观察，不难发现自然界中的树总是有根、枝和叶，且具有这样一些特点：从根上可以长出枝来，从树杈上可以长出枝或叶，叶梢不长在一起，根、枝、叶之间总是畅通的，但它们之间不能构成圈。从结构上看，树是所有连通无向图中边数最少的图模型，同时也是所有无环无向图中边数最多的图模型。我们不得不惊叹大自然的神奇，竟然创造出如此高效而又和谐的离散结构。对自然界中树的这种特殊离散结构进行抽象，就可得到一种特殊的图模型，即树模型。在所有的图模型中，树模型是一种最简洁的连通无环结构，其中各结点之间有着最直接、最必要的联结关系。这种最简洁的连通结构决定了树在图模型知识体系中占有特别重要的地位。目前，树作为一种特殊图模型已被广泛应用于计算机各个领域，例如操作系统采用树结构来组织文件数据，编译程序采用树表示源程序的语法结构，在数据库系统中树被用来组织信息等等。  
本章主要介绍树模型基本理论及其算法设计的基本知识，首先介绍树模型的基本概念与性质、生成树与最小生成树等关于树模型的基本理论，然后具体讨论根树的概念与算法，包括树的递归遍历算法、森林与树的转换算法、最优树的构造与编码算法等，并在此基础上进一步学习若干典型特殊树模型及其基本算法，包括平衡树、红黑树、$B$树等，最后给出树模型的若干应用实例，包括决策树、博弈树等。"
生成树方法,算法,"['第九章  树的基本理论与算法', '§ 9.4 树模型的应用', '9.4.3 关键道路问题']","{'实体类型': '算法', '应用': '计算源到其他结点的最长道路即关键道路', '步骤': '1. 构造生成树；2. 调整边以优化路径'}",,3,"一项工程往往由许多作业构成，其中某些作业可以同时进行，而某些作业却必须按照一定先后顺序执行。例如，在建筑工程中，一般涉及到采购材料、平整地基、预制构件、埋设管道、砌墙立屋、室内装修等多个作业。其中平整地基和预制构件可以同时进行，而室内装修却必须在砌墙立屋之后才能动工等。这样就存在问题：为了使使得工期最短、成本最低，我们应该采取什么方法安排各个作业实施？  
我们知道，PERT 图模型可以很好地解决这类问题。图9-60 是一个PERT 图，图中不含有向回路。在作业网络中每条有向边表示一个作业，边上的权表示完成该项作业所需要的时间（或者费用）。源点（简称源）$𝑠$表示工程的开始，汇点（简称汇）$𝑡$表示工程的结束，其余结点$V_i$表示以该结点为终点的有向边代表的作业的结束和以该结点为始点的有向边代表的作业的开始。  
![](images/8a39c66fbf3ebe2db46646bd71380173dfca51b0b0532f41788a6ce4873cbcb6.jpg)  
第 8 章采用直接计算各个作业最早完成时间和最晚完成时间的方法计算关键路径，现在采用生成树方法计算源到其它结点的最长道路即关键道路，计算思路如下：  
（1）构造一棵以源 𝑠 为根的生成根树 $T$，且求出$s$到根树的各个结点 $v$ 的距离$L\left(\nu\right)$ 。  
（2）对任何一条权为$𝑊$$(u,v)$的弦$\langle u,v\rangle$，若$L(v)<\ L(u)+\ W(u,v)$，则从$T$中去掉以$v$为终点的有向边，而以有向边$\langle u,v\rangle$代之，同时使以$v$为根的子树中的各结点距离都增加$W(u,v)$，如此反复进行，直到考察完所有的弦。  
【例题9.21】求如图9-60 所示的作业网络的关键路径。  
【解】先构造由源𝑠到各个结点的最长道路的生成根树，即优化生成树，如图9-61 (a)- (d) 所示。再构造各个结点到汇 𝑡 的生成树，如图 $9–61\ (\mathsf{e})\tilde{\mathbf{\tau}}(\mathsf{g})$ 所示，然后在原图各个结点 $v$ 处 标以一个有序对$(a,b)$，其中$a$是图9-61 (d)中各$\mathbf{\nabla}^{\mathcal{V}}$的值，$b$是最长道路的权减去图9-61 (g)中各𝑣的值后的结果，如表9-2 所示。其中$a$与𝑏相等的结点所对应作业即为关键作业，由此可以得到如图9-61 (h)所示的关键路径。  
![](images/afad317ae3fcf5f241994658e1d9b51d47e2a890fb3c403b89c9e67033bfa386.jpg)  
![表 9-2  各个结点对应的有序对 ](images/2a1c04e98ea2f09c56274c954a2e76e48122dca03ff9c00a36aff31b122580fe.jpg)  
从图9-61 可知，$P=s V_{3}V_{1}V_{2}V_{4}t$是关键道路，$P$上的作业是关键作业。不在$P$上的作业都有缓冲期，例如$\langle s,V_{1}\rangle$只需3 个单位时间，在整个工程中它的动工时间为0，最晚完成时间为8，有5 个单位的多余机动时间。又比如作业$\langle V_{5},V_{6}\rangle$其最早动工时间为7，最晚完成时间为17，作业所需的时间为4，因此右6 个单位的机动时间，即使从时间13 开始也能按期完成。通过关键道路算法，重视关键作业的完成并合理利用非关键作业的缓冲期，就能做到整个项目的全盘把握，合理分配使用人力物力资源。"
皮亚诺公理,原理,"['一、皮亚诺公理', '1.2.2 自然数的集合定义', '§ 1.2 可数集与不可数集', '二、自然数的归纳定义', '第一章  集合与计数基础']","{'实体类型': ['原理', '定理'], '内容': ['以0和后继数为基础的5条公理系统', '自然数的集合定义满足皮亚诺提出的5条公理'], '作用': '为自然数的抽象集合定义及相关的算术运算系统构造提供标准', '公理1': '至少存在一个体是自然数，它被记为0', '公理2': '如果n是自然数，那么n必定含有一个直接后继，记为n+', '公理3': '0不是任何自然数的直接后继', '公理4': '如果自然数m,n的直接后继m+, n+相同，那么m=n', '公理5': '不满足上述条件的个体均非自然数', '推演': '自然数的所有运算性质都可从上述5条公理出发推演获得', 'name': '皮亚诺公理'}",,4,"我们知道，自然数是对有限集合中所含元素个数进行度量和比较的一种工具。如果将所含元素个数彼此相等的有限集合抽象成一个抽象集合，或者说从所含元素个数彼此相等的有限集合中选出一个集合作为代表构成抽象集合，那么所有这些抽象集合就可以按其规模的大小排成一个有序序列。因此，从本质上说自然数就是表示这些抽象集合及其有序序列的一种数学符号。例如，可以将自然数3 定义为能够表示所有3 元集合的一种抽象集合、将自然数5 定义为能够表示所有5 元集合的一种抽象集合，等等。自然数的上述本质特征并不难以理解，问题是如何找到一种恰当的方法来定义这种抽象集合。  
1891 年，著名数学家皮亚诺以0 和后继数这两个不定义概念外加5 条公理表述了自然数的上述本质特征，创立了如下关于自然数的皮亚诺公理系统，为自然数的抽象集合定义及相关的算术运算系统构造提供了一个标准.皮亚诺5 公理的具体内容如下：  
公理1：至少存在一个体是自然数，它被记为0； 公理2：如果$n$ 是自然数，那么$n$ 必定含有一个直接后继，记为$|n^{+}$  
公理3：0 不是任何自然数的直接后继； 公理4：如果自然数$m,n$ 的直接后继$m^{+}$, $n^{+}$相同，那么$m{=}n$  
公理5：不满足上述条件的个体均非自然数。  
可以证明，自然数的所有运算性质都可从上述5 条公理出发推演获得。根据上述5 条公理，可以构建一套比较完备的自然数算术运算系统。定义自然数其实就是要找出一系列具体个体，让它们满足这5 条公理，其中关键要点就是要给出0 和后继数的具体定义。"
直接证明法,算法,"['第三章  命题演算与推理', '§ 3.5 命题逻辑的演绎推理', '3.5.3 命题推证的基本策略', '二、直接证明法']","{'实体类型': '算法', '定义': '由一组前提，利用一些公认的推理规则和推理定律进行逻辑推演得到有效结论的方法', '特点': '仅使用P规则和T规则进行证明', '关键': '熟记常用的推理规则'}",,4,直接证明法就是由一组前提，利用一些公认的推理规则和推理定律进行逻辑推演得到有效结论，或者说仅使用$\pmb{P}$规则和𝑻规则进行证明的方法称为直接证明法。该方法的关键是要熟记常用的推理规则。
相关算法,算法,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识']",{'实体类型': '算法'},,2,本节主要介绍整数理论中若干最基本的知识。我们知道，整数相加、相减、相乘的结果都是整数，而除法结果却不一定是整数。因此，整数理论研究的重点自然是运算结果相对比较复杂的除法。通过整数的除法运算可以得到整数的素因数分解，由此我们便可以素数为基本构件来考察或窥探整数的离散结构特征与变化规律。在这个过程中，素数作为构造整数的基本构件，其性质与分布规律自然是整数理论的重要内容。因此，本节内容主要包括整数与整数除法的概念、公因数与公倍数、整数的素因数分解、素数的性质及相关算法等。
相容关系,概念,"['6.2.1 相容关系与相容类', '第六章 特殊关系模型', '6.2.2  集合的覆盖', '§ 6.2 相容关系与元素聚类']","{'实体类型': '概念', '定义': ['一种能求同存异的关系，表示对象之间存在一些相同点或共性', '设𝑅为非空集合𝐴上的关系，若𝑅满足自反性和对称性，则称𝑅为𝐴上的一个相容关系', '集合上的一个关系，若任意两个元素在该关系下都是相容的，则称该关系为相容关系'], '特点': ['对象之间的联系较弱，同一元素可同时属于多个不同相容类', '对象之间有一些共同点但不完全相同，满足自反性和对称性，但不满足传递性', '不一定是等价关系，但等价关系一定是相容关系'], '应用': ['用于计算机数据分析相关领域，如数据挖掘和目标识别中的聚类分析', '人与人之间的朋友关系、英文单词之间存在共同字母的关系等'], 'name': '相容关系'}",,2,"相容关系，顾名思义就是一种能求同存异的关系，表示对象之间存在一些相同点或共性,例如国家之间的共同利益、人与人之间的共同兴趣爱好等。日常工作和生活中人与人之间的朋友关系、英文单词之间存在共同字母的关系等都可看成是相容关系。与等价关系相比，相容关系所表示对象之间的联系显然要弱一些，因为等价关系要求的是对象之间完全相同或相等。类似于等价关系可构造对集合的划分，相容关系则可构造对集合的覆盖。与划分不同的是构成集合覆盖的各个相容类之间的交集可以为非空。也就是说，集合中的同一元素可同时属于多个不同相容类。这相当于对集合中的元素进行聚类,因为在集合元素的聚类过程中，同一元素可同时聚合到多个不同的类别当中。这是元素聚类与元素分类的主要区别。聚类是有别于分类的另外一种非常重要的问题求解方法，可用于计算机数据分析相关的很多领域，例如数据挖掘和目标识别中的聚类分析等等。本节主要介绍相容关系的基本知识，主要包括相容关系与相容类的概念和性质、集合覆盖与完全覆盖的相关知识。"
相容关系模型,概念,['第六章 特殊关系模型'],"{'实体类型': '概念', '作用': '与元素的聚类'}",,1,前面学习了关系模型的概念及其五个基本性质。不难发现，日常生活或工作中很多关系虽然从表面上看形态各异、互不相同，但都满足一些相同的基本性质。例如集合之间的相等关系、直线之间的平行关系、多边形之间的全等关系、学生同学关系、整数之间的同余关系等等，它们都满足自反性、对称性和传递性这三条基本性质。我们自然会想到把所有满足这三条性质的关系归为一类特殊关系，并考察这类关系有什么特殊性质和特殊作用，以便在大量错综复杂的具体关系中找到一些共性特征和规律性认识。同样，还有一些关系满足另外一些基本性质，例如集合之间的包含关系、整数之间的整除关系、实数之间的大小关系、英文单词之间的字典排序关系等等，这些关系虽然表面上互不相同、各不相关，但它们都满足自反性、反对称性和传递性这三条基本性质。我们自然会将所有这类关系归为另外一类特殊关系，并考察这类关系有什么相应的特殊性质和特殊作用。通过以上分析，不难得到研究关系的一个普适性方法，就是以关系模型的五个基本性质为标准，将所有关系按它们对这些基本性质满足程度和状态的不同划分为若干特殊类型，然后分门别类地研究同类型关系的共同性质和不同类型关系之间的区别与联系，由此构建各种特殊关系模型及相关理论。显然，通过状态组合构造出的特殊关系有很多，不便一一枚举。作为代表，本章着重介绍其中三种最典型、最基本的特殊关系模型，并分别讨论它们各自的作用，即等价关系模型与元素的分类、相容关系模型与元素的聚类、偏序关系模型与元素的比较。
相容类,概念,"['第六章 特殊关系模型', '§ 6.2 相容关系与元素聚类', '6.2.1 相容关系与相容类']","{'实体类型': '概念', '定义': '设𝑅是非空集合𝐴上的一个相容关系，集合𝐶是𝐴的某个子集，若对于任意的𝑥,𝑦∈𝐶都有⟨𝑥,𝑦⟩∈𝑅，则称𝐶是由相容关系𝑅的一个相容类'}",,3,"相容关系表示的是一种求同存异的关系，对象之间有一些共同点但不完全相同。现在我们从数学的角度来考察相容关系。如前所述，人与人之间的朋友关系、英文单词之间存在共同字母的关系等都可看成是相容关系。不难发现，这些相容关系都满足自反性和对称性，但不满足传递性。由此得到如下关于相容关系的定义：  
【定义6.5】设$𝑅$为非空集合$𝐴$上的关系，若$R$满足自反性和对称性，则称$𝑅$为$𝐴$上的一个相容关系。此时，对于$𝐴$中任意两个元素$x$和𝑦，若$\langle x,y\rangle\in R$，则称$x$与𝑦相容，记为$x\approx y$。  
根据上述定义，不难发现所有的等价关系都可以看成是一种特殊的相容关系，即满足传递性的相容关系，但相容关系不一定是等价关系。  
与等价关系中等价类的概念类似，对于非空集合$𝐴$上的相容关系$R$，将𝐴中一些彼此具有相容关系$R$的元素放在一起构成𝐴的一个子集，由此得到如下相容类的概念：  
【定义6.6】设$ R$是非空集合$𝐴$上的一个相容关系，集合$C$是$𝐴$的某个子集，若对于任意的$x,y\in C$都有$\langle x,y\rangle\in R$，则称$C$是由相容关系$R$的一个相容类。  
例如，在例题6.16 中，$\{a\},\{a,e\},\{b,c\}$等都是$R$的相容类，$\{b,c\}\cup\{d\}=\{b,c,d\}$也是𝑅的相容类，但$\{a,e\}$与任何非空集合的并集都不再是$R$的相容类，此时称$\{a,e\}$为$R$的一个最大相容类，其具体定义如下：  
【定义6.7】设$R$是非空集合$𝐴$上的一个相容关系，$C$是$R$的一个相容类，若在$C$中添加$𝐴$的任何其他元素后，就不再构成相容类，则称$C$为$R$ 的一个最大相容类，记为$C_{R}$。  
例如，在例题6.16 中，$\{a,e\}$和$\{b,c,d\}$都是$R$ 的一个最大相容类。可用相容关系的简化关系图求最大相容类，具体方法如下：  
（1）图中最大完全多边形顶点构成的集合是最大相容类。  
（2）图中每个孤立结点是构成的集合分别是一个最大相容类。  
（3）如果图中某条边不是任何一个完全多边形的边，则该边的两个端点构成的集合是一个最大相容类。  
【定理6.3】设$R$是非空集合$𝐴$上的一个相容关系， $C$是$R$的一个相容类，那么必存在𝑅的一个最大相容类$C_{R}$，使得$C\subseteq C_{R}$。"
真值表,概念,"['第三章  命题演算与推理', '§ 3.2 命题公式与等值演算', '3.2.1 命题公式的基本知识', '二、命题公式的解释与真值表']","{'实体类型': '概念', '定义': '命题公式的所有解释及在每个解释下真值取值所构成的表格', '特点': '命题变量放在最左边，真值取值结果放在右边并加粗表示'}",,4,"命题公式是由命题变量、，其中命题变量泛指的无确定真值的、抽象的命题。因此，命题公式一般没有确定的真值。但是，如果对命题公式中每个命题变量分别指定确定真值的具体命题，那么命题公式就变成一个具有确定真值的复合命题。由此得到如下关于命题公式解释或赋值的概念：  
【定义3.9】设$P_{1},P_{2},\cdots,P_{n}$是出现在命题公式$G$中所有命题变量，对$P_{1},P_{2},\cdots,P_{n}$分别指定真值，由此得到的一组真值称为命题公式$G$的一个解释或赋值，通常记为$\smash{I_{\circ}}$。  
命题公式中的每个变量都有𝑇和$F$两种真值指定方式，对于$\cdot n$个命题变量的公式就有$\cdot2^{n}$个不同解释。例如，含2 个命题变量公式有4 种不同解释，含有3 个变量公式有8 种不同解释。命题公式在每种解释下都会有相应的真值取值，由此可得如下定义：  
【定义3.10】对于任意一个给定的命题公式$G$，如果该命题公式在某种解释下的真值取值为真，则称该解释为$G$的成真赋值或弄真赋值；如果该命题公式在某种解释下的真值取值为假，则称该解释为$G$的成假赋值或弄假赋值。  
为直观表达命题公式在不同解释下的取值状态，在变量不太多的情况下，可将命题公式在所有不同解释下的取值状态枚举出来，做成一个表格。由此得到如下真值表的概念：  
【定义3.11】对于任意一个含有$\cdot_{n}$个命题变量的命题公式$G$，$G$的所有解释以及在每个解释下真值取值所构成的表格称为$G$的真值表。  
在真值表中，一般将命题公式中的命题变量放在最左边，将命题公式在解释下的真值取值结果放在右边并加粗表示。对于比较复杂的公式，通常将计算命题公式真值的中间结果依次放在表中，或者中间结果放在相关逻辑联结词的下方。此外，为节约篇幅，通常将含有相同命题变量个数的多个命题公式真值取值结果合并到一个真值表中。  
表3-4  例题3.11 的真值表
![](images/b78e9e94318e03b09f7351596ca332bf194681eedad2d1334bdc1ed7b6f02552.jpg)"
真值表法,算法,"['3.5.3 命题推证的基本策略', '（1）真值表法', '§ 3.4 命题公式的范式', '3.4.2 主析取范式', '§ 3.5 命题逻辑的演绎推理', '一、真值表法', '第三章  命题演算与推理', '三、主析取范式构造举例', '三、永真蕴含关系判定法', '3.5.1 永真蕴含关系与判定']","{'实体类型': '算法', '步骤': ['在真值表中选出公式为真的所有行，找到该行解释所对应的小项，将所有这些小项进行析取', '1. 对所有前提为真的行，检查结论是否也为真；2. 对所有结论为假的行，检查前提中是否至少有一个为假'], '应用': '用于判定公式A与公式B之间是否存在蕴含关系', '定义': '通过列出所有可能的解释及对应真值结果来判断命题逻辑关系的方法', 'name': '真值表法'}",,4,"由前面的讨论可知，对于任一给定的命题公式，其主析取范式的构造方法主要有两种，即真值表法和等值演算法。  
真值表法就是在真值表中选出公式为真的所有行，并在选出的每一行中找到该行解释所对应的小项，将所有这些小项进行析取即可得到相应的主析取范式。"
真子集,概念,"['第一章  集合与计数基础', '§ 1.1 集合的基本知识', '1.1.2 集合的概念与表示', '三、集合与集合的关系']","{'实体类型': '概念', '定义': '对于任意两个集合A和B，如果B⊆A且A≠B，则称B是A的真子集，记为B⊂A'}",,4,"如前所述，集合中凡是相同的元素都看成是同一个元素，而且集合中元素之间的排列次序也不加区分，或者说是无序的。如此一来，集合就完全取决于集合中的元素。换句话说，对于任意两个集合，如果这两个集合中具有完全相同的元素，那么这两个集合就是完全一样的。或者说，这两个集合是相等的。于是得到如下关于集合相等的外延性原理：  
【定理1.1】（外延性原理）对于任意的集合$A$ 和集合$B$，$\pmb{A}$ 与$\pmb{B}$ 相等当且仅当两者具有相同元素；或者说，$\pmb{A}$ 与$\pmb{B}$ 相等当且仅当$A$ 中每个元素都属于$B$ 且$B$ 中每个元素都属于$A$。如果集合$A$ 与$B$ 相等，则记为$A=B$；否则，如果$A$ 与$B$ 不相等，则记为$A\ne B$。  
【定理1.2】集合的相等关系具有如下三条基本性质： （1）自反性：对于任意给定的集合$A$，成立$A{=}A$； （2）对称性：对于任意给定的两个集合$A$ 和$B$，若有$A{=}B$，则有$B{=}A$；  
（3）传递性：对于任意三个集合$A$、$B$、$C$，若有$A{=}B$ 且$B{=}C$，则有$_{A=C}$  
由【例题1.9】可以看出，集合$C$ 中的每个元素都是集合$A$ 中的元素，此时$A$ 完全包含了$C$，可将$C$ 看成是$A$ 的一个部分，由此得到如下集合的包含关系和子集的概念：  
【定义1.2】对于任意两个集合$A$ 和$B$，若$B$ 中的每个元素都是$A$ 中的元素，则称$\pmb{B}$ 包含于$\pmb{A}$（或$\pmb{A}$ 包含$\pmb{B}$），记为$B\subseteq A$，亦称$\pmb{B}$ 是$\pmb{A}$ 的子集，称符号$\subseteq$为集合之间的包含关系。如果$B$ 不能被$A$ 所包含，则称$\pmb{B}$ 不是$\pmb{A}$ 的子集，记为$B\nsubseteq A$。  
【定理1.3】集合的包含关系具有如下三条基本性质：（1）自反性：对于任意给定的集合$A$，都成立$A\subseteq A$  
（2）反对称性：对于任意两个集合$A$ 和$B$，$A{=}B$当且仅当$A\subseteq B$且$B\subseteq A$（3）传递性：对于任意三个集合$A$、$B$、$C$，若$A\subseteq B$且$B\subseteq C$，则$A\subseteq C$  
【定义1.3】对于任意两个集合$A$ 和$B$，如果$B\subseteq A$且$A\neq B$，则称$B$ 是$A$ 的真子集，记为$\mathrm{B}\subset\mathrm{A}$，并称符号$\subset$为集合之间的真包含关系。"
着色算法,算法,['第十章  特殊图模型与算法'],"{'实体类型': '算法', '应用': '平面图中的基本算法'}",,1,"如前所述，图模型及其理论是数学家欧拉为解决哥尼斯堡七桥遍历问题而创立。事实上，图模型作为一种由结点和边组成的离散结构是一种非常强大的离散建模工具，除了能够解决哥尼斯堡七桥遍历问题之外，还可解决很多其它实际问题。例如，旅游的路径规划问题、资源分配与匹配问题、图的着色与并行流程的设计问题、最小费用流问题等等。针对不同的问题，通常需要设计出特定的图模型进行建模与求解。例如，解决哥尼斯堡七桥遍历问题需要使用欧拉图及相关理论、解决旅游的路径规划问题需要哈密顿图及相关理论、解决资源分配与匹配问题需要二分图及相关理论、解决图的着色与并行流程的设计问题需要平面图的相关理论、解决最小费用流问题需要网络流图的相关理论等等。由此产生很多种具有特殊结构和性质的图模型，每种特殊图模型都能针对性地有效地解决某一类或某几类特定问题。因此，要想高效合理地使用图模型实现对实际问题的建模与求解，除了掌握前述图模型的一般理论及算法之外，还需要进一步掌握多种特殊图模型的相关理论及算法。  
本章介绍几种重要的特殊图模型及相关算法，包括欧拉图模型的基本理论及边的遍历算法、哈密顿图的基本理论及结点的近似遍历算法、二分图模型的基本理论及匈牙利匹配构造算法、平面图的基本理论及着色算法、网络流图的基本理论及最大流算法，并结合具体实例分析和讨论这些特殊图模型的应用方法。"
着色问题,概念,"['第十章  特殊图模型与算法', '一、点着色与边着色', '三、结点着色算法', '10.3.3 着色问题与算法', '§ 10.2 二分图与匹配问题', '二、平面图的着色问题']","{'实体类型': ['概念', '问题'], '起源': '对平面图（地图）四色猜想', '应用': ['用不同颜色给地图着色，使相互接壤的国家通过不同的颜色进行区分', '用于解决并行计算与任务规划等问题'], '特点': '不局限于平面图，包括结点着色、边着色和面着色问题', '定义': ['对图的顶点或边进行着色，使得相邻的顶点或边具有不同的颜色', '为图的顶点分配颜色，使得相邻顶点颜色不同，且使用的颜色数最小化']}",,3,图的着色问题起源对平面图（地图）四色猜想，即至多用四种不同颜色给地图着色，就可使相互接壤的国家通过不同的颜色进行区分。四色猜想虽然针对平面图的面着色，但图的着色问题并不局限于平面图。事实上，对于一般的非平面图，可以研究其结点着色和边着色问题，对于平面图，可以研究结点着色、边着色和面着色问题。由于边着色和面着色问题可以通过适当方式转化为结点着色问题，故一般仅讨论结点着色算法。本节讨论图的着色问题与算法，主要包括点着色与边着色、面着色与五色定理、结点着色算法。
矛盾公式,概念,"['第四章  谓词演算与推理', '§ 4.2  谓词公式与等值演算', '4.2.3 谓词公式的解释与分类']","{'实体类型': '概念', '定义': '在其所有解释下的真值取值都为假的谓词公式'}",,3,"我们知道，对于一个命题公式，确定其真值取值状态是比较简单的，只需对命题公式中各个变量逐个指派真值便可得到命题公式的真值，而且在命题变量不是太多的情况下还可通过对命题变量真值指派的各种状态进行枚举的方式列出命题公式的真值表。然而，要确定一个谓词公式的真值取值状态，通常就没有这么简单了。  
例如，要确定谓词公式$(\forall x)(H(x){\rightarrow}D(x))$的真值，首先要确定其个体域，然后还要确定谓词$H(x)$和$D(x)$的具体含义。如果使用全总个体域$H(x)$表示 $x$是人$D(x)$表示 $x$会死的，则该谓词公式的取值为真，若将$D(x)$表示为 $x$是勇敢的，则谓词公式的取值为真为假。  
一般来说，对于任意给定的谓词公式，其含义与真值取值不仅依赖于个体域，依赖于公式中各个个体变量的取值状况，还依赖于对公式中谓词符号、函数符号、常量符号具体含义的确认，这些所有的依赖信息构成对谓词公式的解释。如果不对谓词公式中常量符号、变量符号、函数符号、谓词符号进行具体的解释，则公式就没有确定的含义和确定的真值取值.下面给出关于谓词公式解释的具体定义：  
【定义4.15】 谓词公式$G$的每一个解释$I$由如下四个部分组成：  
（1）确定非空的个体域集合$D$；  
（2）确定公式$G$ 中的每个常量符号的含义，即指定$D$ 中的某个特定的元素；  
（3）确定公式$G$ 中的每个$n$元函数的具体形式，即对于公式$G$ 中每个$n$元函数分别指定一个从$D^{n}$ 到$D$ 中的特定函数与之对应；  
（4）确定公式$G$ 中的每个$n$元谓词符号的具体形式，即对于公式$G$ 中每个$n$元谓词符号分别指定一个从$D^{n}$ 到$\{0,1\}$的特定函数与之对应。  
易知，对于任意一个给定的谓词公式，如果该公式是封闭公式，即不含有任何自由个体变量，则该公式在任何解释下均有确定的真值。  
由上述例题可知，与命题公式一样，有些谓词公式在有些解释下为真，在另外一些解释下为假；而有些谓词公式则在所有解释下均为真；还有一些谓词公式在所有解释下均为假。由此可以得到如下有效公式、矛盾公式和可满足公式的定义：  
【定义4.16】 对于任意一个给定的谓词公式$G$，如果$G$ 在其所有的解释$I$下的真值取值为真，则称$G$ 称为有效公式；如果$G$ 在其所有的解释$I$下的真值取值都为假，则称$G$为矛盾公式；如果$G$ 不是矛盾公式，则称其为可满足公式。  
从上述定义可知三种特殊公式之间具有如下关系：有效公式的否定为矛盾公式；矛盾公式的否定为有效公式；有效公式一定为可满足公式。"
矛盾律,性质,"['第一章  集合与计数基础', '§ 1.1 集合的基本知识', '1.1.3 集合的基本运算', '二、差运算与补运算']","{'实体类型': '性质', '条件': '对于任意给定的集合A', '结论': 'A∩A=∅'}",,4,"对于任意给定的两个集合$A$ 和$B$，有时需要将属于$A$ 但不属于$B$ 的所有元素取出来构成一个新的集合，由此得到如下集合差运算的概念：  
【定义1.12】对于任意给定的两个集合$A$ 和$B$，集合$\cdot A-B=\{x|x\in A$并且$x\notin B\}$称为$A$ 与$B$ 的差集，$A-B$亦称为集合𝐴与$B$的差运算；令$U$表示全集，则${\bar{A}}=U-A=\{x|x\in$$U$且$x\notin A\}$称为$A$ 的补集，亦称$\bar{A}$为对集合$A$ 的补运算。  
一般来说，所谓两个对象互补，是指这两个对象之间无共同部分并且若将两者合并则构成一个完整的整体。如果将全集𝑈看成是一个完整的整体，那么任何一个集合与它的补集显然构成一种互补关系。图1-3 为集合差运算和补运算的文氏图。  
![](images/3dd3ff26327d44646f11d3b3940708dbd5563cf42578e139e0a56534e35c5eff.jpg)
图1-3 差、补运算的文氏图  
不难看出，集合的差运算和补运算其实就是实数减法运算在集合论中的推广。根据集合差运算与补运算的定义，不难证明它们满足如下基本运算性质：  
(1) 矛盾律：对于任意给定的集合$A$，有：$A\cap{\bar{A}}=\emptyset$；(2) 排中律：对于任意给定的集合$A$，有：$A\cup\bar{A}=U$  
(3) 双重否定律：对于任意给定的集合$A$，有：$\bar{\bar{A}}=A$  
(4) 德摩根律：对于任意给定的两个集合$A$ 和$B$，有： $\overline{{A\cup B}}=\bar{A}\cap\bar{B},\,\,\,\overline{{A\cap B}}=\bar{A}\cup\bar{B}$  
(5) 对于任意给定的三个集合$A$、$B$ 和$C$，有：  
$A\cup(B\cup C)=(A\cup B)\cup C;\;A\cap(B\cap C)=(A\cap B)\cap C\circ$ $A\cap(B\cup C)=(A\cap B)\cup(A\cap C);\;A\cup(B\cap C)=(A\cup B)\cap(A\cup C)\,.$ $A\cap(A\cup B)=A;\,\,\,A\cup(A\cap B)=A\,.$  
现仅以德摩根律为例给出上述运算性质的证明，读者可自行给出其余证明。【例题1.22】对于任意给定的两个集合$A$ 和$B$，证明如下德摩根律：  
$$
{\overline{{A\cup B}}}={\bar{A}}\cap{\overline{{B}}}\,;\;{\overline{{A\cap B}}}={\bar{A}}\cup{\bar{B}}
$$"
矩阵表示法,方法,"['8.1.3 图的表示方法', '3、矩阵表示法', '5.1.3 关系的表示', '§ 8.1 图的概念与表示', '第五章 关系模型与理论', '§ 5.1 关系的数学模型', '第八章  图的基本理论与算法']","{'实体类型': '方法', '定义': '用矩阵形式表示二元关系', '特点': '矩阵元素仅有0和1两种状态，称为布尔矩阵', '应用': ['用于逻辑演算', '通过矩阵将图模型的逻辑结构转变成可在计算机中存储和运算的形式'], '具体类型': ['邻接矩阵表示法', '关联矩阵表示法', '邻接表表示法']}",,4,"在使用关系的数学模型对实际问题进行建模的时候，通常需要对关系模型进行一些定量的数值计算以实现对实际问题的求解，此时无论是关系的集合表示方法和关系图法，都不方便实现对关系模型定量的数值计算。为此，我们引入二元关系的矩阵表示法。  
假设$\boldsymbol A=\{a_{1},a_{2},\cdots,a_{n}\}$, $B=\{b_{1},b_{2},\cdots,b_{m}\}$是任意给定的两个非空有限集合，$R$是$A$到$B$的一个二元关系，则按下列方式定义的$m\times n$阶矩阵$M_{R}=(r_{i j})_{m\times n}$称为$R$的关系矩阵：
$$
r_{ij}=\begin{cases}1\text{,若}\langle a_i,b_j\rangle\in R\\0\text{,若}\langle a_i,b_j\rangle\not\in R\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-3)}
$$
其中$A$中元素$a_{i\cdot}$序号对应矩阵元素的行下标，$B$中元素$b_{j}$序号对应矩阵元素的列下标。  
值得注意的是：由关系矩阵的定义可知，关系矩阵的元素有且仅有0 和1 这两种状态，这样的矩阵一般称之为布尔矩阵，主要用于一些逻辑演算，在运算规则上与普通矩阵有一些差异。为满足后续内容学习的需要，在此简要介绍布尔矩阵的若干基本运算，具体包括并运算、交运算、补运算和布尔积运算，其具体定义如下：  
【定义5.9】设$A=\left(a_{i j}\right)$和$B=\left(b_{i j}\right)$是两个$m\times n$布尔矩阵，则$𝐴$和$B$的并矩阵定义为如下$m\times n$布尔矩阵：$A\lor B=C=\left(c_{i j}\right)$，其中：  
$c_{ij}=\begin{cases}1\text{,如果}a_{ij}=1\text{ 或}b_{ij}=1\\0\text{,如果}a_{ij}=0\text{ 且}b_{ij}=0\end{cases}(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-4)}$      （5-4）  
【定义5.10】设$A=\left(a_{i j}\right)$和$B=\left(b_{i j}\right)$是两个$m\times n$布尔矩阵，则$A$和$B$的交矩阵定义为如下一个$m\times n$布尔矩阵：$A\land B=C=\left(c_{i j}\right)$，其中：
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=1\text{ 且}b_{ij}=1\\0\text{,如果}a_{ij}=0\text{ 或}b_{ij}=0\end{cases}(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-5)}
$$
【定义5.11】设$A=\left(a_{i j}\right)$任意给定的一个$m\times n$布尔矩阵，则𝐴的补矩阵定义为如下$m\times$$n$布尔矩阵：$\bar{A}=C=\left(c_{i j}\right)$，其中：
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=0\\0\text{,如果}a_{ij}=1\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-6)}
$$
【定义5.12】设$A=\left(a_{i j}\right)$是$m\times p$矩阵，$B=\left(b_{i j}\right)$是$p\times n$矩阵，则$𝐴$和$B$的布尔积矩阵定义为如下$m\times n$布尔矩阵：$A\odot B=C=\left(c_{i j}\right)$，其中：  
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=0\\0\text{,如果}a_{ij}=1\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-6)}
$$
需要注意的是：两个布尔矩阵可进行布尔或和布尔与运算的前提是这两个矩阵具有相同的行数和列数，可进行布尔积运算的前提是前一个矩阵的列数等于后一个矩阵的行数。  
在学习了二元关系的三个基本表示方法后，下面我们考察空关系、完全关系和恒等关系这三个常用特殊关系的关系矩阵和关系图各有什么特点：  
(1) 空关系$\varnothing$  因为$\emptyset\subseteq A\times B$(或$\emptyset\subseteq A\times A)$)，所以$\varnothing$也是一个从$𝐴$到$B$(或$𝐴$上)的关系，称之为空关系，即无任何元素的关系。空关系的关系图中只有结点，无任何边，且关系矩阵中的元素全是0  
(2) 完全关系（全域关系） $A\times B$或(或$A\times A)$本身也是一个从$𝐴$到$B$(或$𝐴$上)的关系，称之为完全关系，即含有全部序偶的关系。完全关系的关系图中所有结点之间都有有向边互联，关系矩阵中的元素全是1。  
(3) 恒等关系 $I_{A}$  $I_{A}\subseteq A\times A$，则$I_{A}=\{\langle x,x\rangle|x\in A\}$为$A$上的恒等关系。完全关系的关系图中所有结点都有一个有向环，不同结点之间无任何有向边联结。  
![](images/9a95167e68610708edb7fef0f0474b8284d349dcc5f3b662d3280809d00fbf1e.jpg)
图5-6 空关系、全关系与恒等关系  
设$A=\left\{1,\ 2,\ 3\right\}$，则$A$ 上的空关系∅、完全关系$A\times A$及恒等关系$I_{A}$的关系图如图5-6 所示，下面三个布尔矩阵分别是它们的关系矩阵：  
$M_{\emptyset}=\left(\begin{array}{ccc}0&0&0\\0&0&0\\0&0&0\end{array}\right)\quad M_{A\times A}=\left(\begin{array}{ccc}1&1&1\\1&1&1\\1&1&1\end{array}\right)\quad M_{I_A}=\left(\begin{array}{ccc}1&0&0\\0&1&0\\0&0&1\end{array}\right)$"
短程线,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.2 可达性及其判定']","{'实体类型': '概念', '定义': '从结点vi到vj可达时，长度最短的通路称为短程线', '属性': '短程线的长度称为从vi到vj的距离'}",,3,"如前所述，对于任意一个给定的线图模型，图中任意两个指定结点之间的通路可能有很多条，有的可能会长一些，有的可能会短一些，此时，一般关心的是哪条通路最短。还有一种情况，就是图中可能存在两个或者多个结点，它们之间根本没有通路相联结，例如，在图8。3。1 表示的城市高铁运输线路图中，北京和台北之间就没有通路联结，这也是一种比较重要的情形。 由此得到如下图中结点可达性及其短程线的相关概念  
【定义8.23】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，对于𝑉中的任意两个结点$v_{i},v_{j}$，如果从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$之间存在长度至少为1 的通路，则称从$v_{i}$到$v_{j}$可达，否则称从$v_{i}$到$v_{j}$不可达。 如果图$G$ 中从$v_{i}$到$v_{j}$可达，则从$v_{i}$到$v_{j}$长度最短的通路称为从$v_{i}$到$v_{j}$的短程线，该短线程的长度称从$\boldsymbol{v}_{i}$到$v_{j}$的距离，记为 $d\big(v_{i},v_{j}\big)$ 。如果从$\boldsymbol{v}_{i}$到$v_{j}$不可达，则记为 $d\bigl(v_{i},v_{j}\bigr)=\infty$ 。  
从上述定义可以看出，结点之间的可达性刻画的是图中两个结点之间的某种连通性关系。对于无向图来说，这种连通性关系显然是双向的，故若从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$ 可达，则从 $v_{j}$ 到 $v_{i}$ 可达，反之亦然；且有 $d\bigl(v_{i},v_{j}\bigr)=d\bigl(v_{j},v_{i}\bigr)$ 。对于有向图来说，这种连通性关系不一定满足对称性，故若从$v_{i}$到$v_{j}$ 可达，则不一定有从 $v_{j}$ 到 $v_{i}$ 可达，也不一定有 $d\big(v_{i},v_{j}\big)=$$d\big(v_{j},v_{i}\big)$ 。  
如前所述，图模型$G=\langle V,E\rangle$中结点之间的通路由该图所表示二元关系不断对其自身作复合运算产生，长度为$k$的通路其实就是二元关系$k$次幂运算的结果。因此，由图$G=\langle V,E\rangle$中结点之间可达性产生的二元关系其实就是图$G=\langle V,E\rangle$所表示二元关系的传递闭包。  
我们知道，对于有限集合$ V=\{v_{1},v_{2},\ldots,v_{n}\}$上的任意一个二元关系，构造其的传递闭包最多只需要进行$\cdot n$次方幂运算就可以了。也就是说，对于任意一个$n$结点的图模型，联结其中两个可达的结点最多只需要做$ n$次方幂运算，亦即对于图中任意两个可达结点，必然存在一条长度不大于$ n$的通路或回路联结这两个结点。  
以上是从二元关系及其传递闭包的角度对图中可达结点的联结通路或回路长度的分析，下面从图模型的角度对上述分析结论进行严格证明。  
【定理8.3】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中两个不同的结点$u$ 和 $v$，存在一条从$u$到 $v$通路，则必然存在一条长度不大于$:n-1$ 的基本通路。  
可类似证明如下基本回路存在性定理：  
【定理8.4】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中结点$v$，存在一条从$v$ 到 $v$回路，则必然存在一条长度不大于$^{\cdot n}$ 的基本回路。  
由以上两个定理可知，对于任意含有$ n$个结点的有向或无向线图$G=\langle V,E\rangle$，如果图从结点$u$ 到${v}$是可达的，那么必然存在从$u$ 到$v$且长度不超过$n$通路或回路。因此，根据通路或回路的计数方法，最多只需计算该图所对应邻接矩阵的$n$幂，即可判定图中任意两个结点之间是否可达。具体地说，假设𝐴是图$G=\langle V,E\rangle$的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则$B_{n}$中的元素为：  
$$
b_{i j}^{(n)}=a_{i j}^{(1)}+a_{i j}^{(2)}+\cdots+a_{i j}^{(n)}
$$  
显然，$b_{i j}^{(n)}$表示图$G$中从结点$v_{i}$到结点$v_{j}$的长度不超过$n$的通路总数，特别地，若$ i=j$，则$b_{i j}^{(n)}$为结点$v_{i}$到自身的长度不超过$n$的回路总数。因此，若$b_{i j}^{(n)}=0$，则结点$v_{i}$到$v_{j}$不可达，否则，结点$v_{i}$到$v_{j}$可达。由此得到有如下定理关于图模型的可达性定理：  
【定理8.5】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，$A=(a_{i j})_{n\times n}$为图 $G$ 的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则当$v_{i}\neq v_{j}$时，若${b_{i j}}^{(n)}>0$，则$v_{i}$到$v_{j}$可达，否则不可达，且有：  
$$
d\big(\boldsymbol{v}_{i},\boldsymbol{v}_{j}\big)==\begin{cases}\infty,&&\text{若}a_{ij}{}^{(1)},a_{ij}{}^{(2)},\cdots,a_{ij}{}^{(n)}\text{均为 0}\\\min\{a_{ij}^{(m)}|m=1,2,\cdots,n\},&&\text{否则}\end{cases}
$$  
在图模型的实际应用过程中，很多时候只需知道结点之间是否可达，而无需知道距离及通路数，由此得到如下可达性矩阵的定义：  
【定义8.24】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，则令$P=(p_{i j})_{n\times n}$是一个$n$阶矩阵，且满足：  
$p_{ij}=\begin{cases}1\:,~~~~~~结点从v_{i}到v_{j}至少存在一条长度不小于1的通路\\0\:,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~否则\end{cases}$    (8-8)  
称矩阵 $P$ 为图 $G$ 的可达性矩阵。  
从上述定义可以看出，可达性矩阵中的元素$\cdot p_{i j}$表示了从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$的可达性关系，表达了结点之间通过结点邻接关系的传递性得到可达性关系。因此，图中结点之间的可达性关系就是该图所表达邻接关系的传递闭包，可达性矩阵其实就是图邻接关系的传递闭包关系矩阵，即为可达性关系的关系矩阵。 显然，无向图的可达性矩阵为对称矩阵。  
若已知$B_{n}$ ，则只需将$B_{n}$中非零元素写成1，便可得到可达性矩阵 $P$，即有：  
$$
p_{i j}=\left\{\!\!\begin{array}{l l}{1,\qquad}&{b_{i j}^{\phantom{}(n)}\neq0}\\ {0,\qquad}&{b_{i j}^{\phantom{}(n)}=0}\end{array}\right.
$$  
由于可达性矩阵$P$是布尔矩阵，矩阵$P$中的元素$p_{i j}$只表示结点$v_{i}$到$v_{j}$是否可达，并不表示至于其通路数目及长度。因此，通过计算矩阵 $B_{n}$获得可达性矩阵$P$的方法效率较低。事实上，可类似于计算二元关系的闭包，使用邻接矩阵𝐴的布尔运算计算可达性矩阵$P$。  
【定理8.6】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，矩阵$A$和$P$分别是图$G$在该结点次序下的邻接矩阵和可达性矩阵，则有：  
$$
P=A^{(1)}\lor A^{(2)}\lor\cdots\lor A^{(k)}\lor\cdots\lor A^{(n)}
$$  
其中$A^{(k)}$表示进行矩阵$A$的$k$次布尔幂运算。"
破圈法,算法,"['第九章  树的基本理论与算法', '§ 9.1 无向树的基本知识', '9.1.2 无向图的生成树']","{'实体类型': '算法', '关键步骤': '判断图中是否有回路，若有则删除回路中的一条边，直到图中无回路为止', '应用': '构造生成树'}",,3,"如前所述，树模型是大自然赐予的一种最简洁最高效的连通无向图，任意两个结点之间有且仅有一条路径联结。因此，在对一般连通无向图进行化简的时候，经常会删除图的一些边将其转化为树结构的生成子图。这种生成子图称为无向图的生成树，其定义如下：  
【定义9.2】假设$G=\langle V,E\rangle$是任意给定的一个无向图模型，若$G$的某个生成子图是树，则称该树为$G$的一个生成树，记为$T_{G}$。生成树$T_{G}$中的每条边均称为树枝；$G$中不在$T_{G}$中的每条边均称为弦；$T_{G}$的所有弦的集合称为生成树的补。  
例如，对于图9-3(a)所示的图$G_{1}$无向图，$G_{2}$和$G_{3}$为该图的两棵不同构的生成树。对于图9-3(b)所示生成树$G_{2}$，边$\mathtt{e}_{2},\mathtt{e}_{3},\mathtt{e}_{4},\mathtt{e}_{5}$ 是其树枝，而$\mathsf{e}_{1},\,\mathsf{e}_{6}$ 是其弦；对于图9-3(c)所示的生成树$G_{3}$，$\mathsf{e}_{1},\mathsf{e}_{2},\mathsf{e}_{4},\mathsf{e}_{5}$ 是其树枝，而$\mathsf{e}_{3},\,\mathsf{e}_{6}$ 是其弦。  
![图9-3 连通无向图及其生成树  ](images/3447e9802eaf794918ba03e412f68817eae23f2621102647ed094020348d10e0.jpg)  
显然，对于一个无向连通图$G$，如果$G$本身就是树，则其生成树就是它自己，因而是唯一的。但是，如果$G$不是树，则其生成树就不是唯一的。下面的定理9.3 保证了无向连通图模型生成树的存在性，为无向连通图的化简提供了坚实的基础：  
【定理9.3】假设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$存在其生成树$T_{G}=\langle V_{T}\,,\,\,\,E_{T}\rangle$的充分必要条件是$G$是连通的。  
事实上，上述定理证明过程给出了构造生成树的一种具体算法，通常称之为破圈法。该算法的关键是判断图$G$中是否有回路。若有回路，则删除回路中的一条边，直到图中无回路为止。假设图$G$中有${n}$个结点和$m$条边，则由生成树结点与边的关系知，要构造该图的生成树，必需删除$m-n+1$条边。  
此外，由于含$_n$个结点和$m$条边无向连通图$G=(n,m)$一定存在生成树，且生成树中必有$n$个顶点，$n-1$条树枝和$m-n+1$条弦。因此，在$G$中选择不构成任何回路的$n-1$条边就一定可以得到$G$的一个生成树。这种构造生成树的方法，通常称为避圈法。  
![图9-4 构造生成树的破圈法与避圈法  ](images/6583966484122e279921cd749c7234aa541872b9fc25864834c494c7d9d17e62.jpg)  
破圈法和避圈法需要找出回路或验证不存在回路，计算量通常较大。由于在对一般连通无向图进行广度遍历搜索的时候，会自然形成一个无回路的连通生成子图，即该图生成树。因此，可以通过广度优先遍历算法构造生成树。该算法无需判断回路，因而具有较高的计算效率，比较适合计算机处理。对于连通图$G=\langle V,E\rangle$，该算法的具体过程如下：  
（1）任选$s\in V$，将$s$标记为0，令$L=\{s\},\;V=V-\{s\},k=0$；  
（2）如果$v=\varnothing$，则转（4），否则令$\cdot k=k+1$；  
（3）依次对$L$中的所有标记为$k-1$的结点$v$，如果它与𝑉中的结点𝑤相连接，则将𝑤标记为$k$，指定$v$为$w$的前驱，令$L=L\cup\{w\}$，转（2）；  
（4）$E_{G}=\big\{(v,w)\big|w\in L-\{s\},v\big\}$𝑤的前驱}结束。"
离散数学,概念,['第一章  集合与计数基础'],"{'实体类型': '概念', '定义': '以各种离散量的概念、关系、结构和运算性质为研究对象', '应用': '支撑计算机相关学科对离散量进行表示和处理的数学需求', '地位': '作为现代信息社会基础的计算机科学的支撑学科', '组成': '由集合论、数理逻辑、图论、数论、组合分析、代数结构等组成'}",,1,离散数学以各种离散量的概念、关系、结构和运算性质为研究对象，以充分满足计算机相关学科对离散量进行表示和处理的数学需求。正如微积分支撑了作为近代工业文明基础的物理学，离散数学支撑了作为现代信息社会基础的计算机科学。事实上，离散数学是一门综合的数学学科，由多个数学分支组成，包括集合论、数理逻辑、图论、数论、组合分析、代数结构等，分别从不同角度出发研究各种离散量之间数与形的关系。本章比较系统地介绍集合论与计数的基础知识， 它们是学习各个离散数学分支所必备的入门基础。 尽管读者可能已 经从其它途径获悉其中某些概念，但是要想掌握作为支撑整个计算机学科基石的离散数学，就必须重新审视和系统地学习这些入门知识。
积代数,概念,"['第十一章  抽象代数结构通论', '§ 11.1 代数结构的基本概念', '11.1.1 数学结构与代数结构']","{'实体类型': '概念', '定义': '由代数结构的笛卡尔积及其上的运算构成的代数结构'}",,3,"代数结构作为四大基本数学结构之一，它以运算作为处理机制，在整个数学理论体系和计算机数学建模中占据非常重要的作用。代数结构是一种非常古老的数学结构，具有几千年发展历程，从最初初等代数逐步发展到大代数，然后进一步发展到抽象代数，目前正朝着泛代数的方向发展。本小节主要介绍抽象代数的由来及其基本知识结构。  
用计算机解决实际问题，一般需要对问题进行抽象并建立相应的数学模型，然后在此基础上将对实际问题的求解转化为对数学模型的求解。 因此，数学模型是用计算机解决实际问题的基础。现实问题纷繁复杂、变化万千，所建立的数学模型自然也是五花八门，多种多样，让人无所适从。值得欣慰的是，尽管我们面对的数学模型复杂多样，但从结构上看，所有这些数学模型都建立在四种基本的数学结构基础之上。  
这四种基本数学结构分别为：表示元素之间空间关系的拓扑结构，如图模型、树模型就是一些拓扑结构；表示元素之间运算关系的代数结构，如初等代数、向量代数、矩阵代数、命题代数、集合代数等都是代数结构；表示元素规模度量性质的测度结构，如高等数学里函数的微分和积分都是测度结构，它们主要计算面积、体积、弧长、速度等；表示元素之间次序关系的偏序结构，如整数的整除关系、集合的包含关系等偏序关系都是偏序结构。  
任何一个数学结构都是由载体、处理机制和处理规则这三个基本要素组成：  
（1）载体集合 对于任何一个数学结构，需要定义一些抽象的元素作为处理对象，这些抽象元素组成的集合构成数学结构的载体。载体集合是数学结构存在的基础或平台。  
（2）处理机制 为了实现对数学结构载体中元素的处理，需要定义一些处理机制，不同的数学结构具有不同的处理机制。例如：偏序结构是一种关系结构，它以元素之间的次序关系或者比较关系作为处理机制；代数结构是一种运算结构，它以元素之间的运算作为处理机制；拓扑结构是一种分布结构，它以元素之间的空间分布作为处理机制；测度结构则是一种度量结构，它以元素的规模度量作为处理机制。  
（3）处理规则 为使定义出来的数学结构满足一些合理性要求以及能够在处理实际问题中发挥作用，避免出现一些矛盾或荒诞的处理结果，还必须制定一些处理规则对处理机制做一些必要的限制。在现代数学的公理化系统中，通常称这些处理规则称为公理。不同的数学结构具有不同的处理规则，例如偏序结构限制元素之间的关系必须满足自反性、反对称性和传递性，这些限制或者性质构成了偏序结构公理系统；再如代数结构则是规定元素之间的运算必须满足结合律、交换律、分配律等运算性质。  
数学运算最早起源于算术运算，即使用具体的整数或分数进行四则运算。随着科学技术的不断发展，人们逐步意识到这种方法不能满足对一般性规律的认识。因此，采用抽象的字母来代替具体的整数和分数进行运算以获得通用性结果，并称之为代数运算或简称为代数。在微积分出现之前的数千年历史中，对代数运算的研究一直占据数学研究的核心地位。那时人们普遍信奉一种所谓的万能法则，即世界上所有问题都可以转化为数学问题，所有数学问题都可以转化为代数问题，所有代数问题都可以转化为方程问题。  
因此，在很长一段历史时期内，人们对数学的研究基本上都是对代数学的研究，对代数学的研究基本上是方程或方程组解法的研究。解方程是那个时期内所有数学家的中心任务，大家都非常期望能够通过使用代数运算的方法找到方程或方程组的通用求解公式。这种努力在线性方程组领域取得了非常完美的结果，并由初等代数逐步衍生出线性代数。但是，对于一元高次方程通用求解方法的研究并不是很顺利，对于次数高于四次的一元方程始终找不到通用求解公式或求解方法。一些非常著名的数学家，例如欧拉、高斯、拉格朗日等都对此做了大量非常艰苦的研究，但均告失败。  
在寻求五次方程通用求解方法的过程中，年仅17 岁的法国天才少年伽罗瓦在1828 年提出群的概念，运用群的思想证明了五次方程通用求解公式是不存在的，并给出了五次方程系数在满足一定条件下若干特殊解法，由此一举解决了困扰数学家长达200 多年的数学问题。伽罗瓦取得成功的关键在于不仅将运算对象进行抽象化，而且对运算本身进行抽象，在抽象对象和抽象运算的基础上通过构造一些特殊抽象代数结构进行求解。这个思想在当时实在过于超前以至于没有得到柯西、傅里叶、泊松等著名数学家的认可，泊松的判词是“完全不能理解”。 1832 年5 月31 日年仅21 岁的伽罗瓦死于决斗。在决斗之前，他把关于五次方程代数求解的研究成果写成长信，留给了人类。14 年后，法国数学家刘维尔整理并发表了伽罗瓦的遗作，人们才理解并惊叹他那超越时代的天才思想和巧妙构思。  
至此以后，人们对代数的研究内容由方程或方程组的求解技巧转变为对代数运算性质和运算结构的研究，通过对运算和运算对象进行抽象的方式实现对所有运算依其运算性质进行分类或归类，并将伽罗瓦的群论迅速发展成为一门称之为抽象代数结构的崭新数学分支。 抽象代数结构的诞生，把代数学从传统的初等代数发展到现代的抽象代数，由此打开了现代代数学的大门，开创了代数学研究的新纪元。因此，抽象代数结构通常也称为近世代数以区别于之前的初等代数。若无特别说明，我们通常将抽象代数结构简称为代数结构。  
经过一百多年的发展，抽象代数结构已经形成一个如图11-1 所示的知识体系。对于一个代数系统，我们不仅可以主动设计出它的运算并考察相应的运算规则，而且还可以通过分别对其载体集合进行相关改造或运算得到相应的子代数、积代数和商代数，可以通过映射的方式考察不同代数结构之间的区别与联系，还可根据运算性质对代数结构进行分类，形成若干典型抽象代数系统，如群、环、域、格等。  
![](images/37d476cf884c29ed65924bc021cb612de43bab4df8b1196f64e96cad4f61a01f.jpg)
图11-1 抽象代数结构的知识体系  
代数结构作为一种特殊的数学结构，具有载体、处理机制和处理规则这三个基本要素。如前所述，代数结构的载体就是由一些抽象对象为元素组成的集合，并通过运算机制实现对集合中元素的处理。所谓运算，其实就是通过映射的手段从已有元素中构造出新的元素。载体和运算统称为代数结构的成分。代数结构的处理规则即为运算性质。  
既然代数结构的载体是一个集合，那么就可以考虑通过一定方式由这个集合派生出新的集合并据此构造出新的代数结构。例如，可以考察其子集以及在子集上的运算，得到子代数的概念和性质；可以对作为载体的集合做笛卡尔集构成一个新的集合，并在新集合上定义相关运算，得到积代数的概念和性质；可以通过构造等价关系的方法实现对集合载体的划分，构成一个以等价类为元素的商集，并在这个商集上定义相关运算，得到商代数的概念和性质。子代数、积代数和商代数是构造和研究代数结构的基本方法论。  
当然，还可以考察两个代数结构之间的相似性与差异性。对于任意两个代数系统，可以在这两个代数结构的载体(集合)上建立一种保运算的映射，由此考察代数结构之间的联系。如果存在这种保运算映射，则称这两个代数系统同态。如果这种保运算的映射还是双射，则称这两个代数系统同构。同态和同构是考察代数结构之间联系的基本工具。  
依据代数结构的运算性质，可以将各种具体代数结构划分为若干抽象类型。典型的抽象代数结构类型主要有仅含一个二元运算的半群与群、含有两个二元运算的环与域，以及格与布尔代数。这些典型抽象代数结构构成代数结构知识体系的主要内容。"
稳定婚配问题,算法,"['第十章  特殊图模型与算法', '§ 10.4 网络流图及其优化问题', '10.5.3 稳定婚配问题']","{'实体类型': '算法', '定义': '在给定男女双方的优先级列表下，寻找一种稳定的配对方案，使得不存在一对男女互相更倾向于对方而抛弃当前伴侣', '特点': '配对方案必须稳定，即对于任何男子，在他心目中比他当前伴侣更好的女性，都不会认为他是该女性一个更好的选择，对于任何一个女子也是这样', '步骤': '初始时所有男士和女士都是自由的，自由男士向优先列表中当前最佳人选求婚，根据女士的回应进行配对或拒绝，最终得到稳定的匹配对集合', '结论': '该算法在有限次迭代后终止，并且得到的匹配是稳定的'}",,3,"在某婚姻介绍所，假设有若干个单身男子和同样多的单身女子前来征婚，并且媒人已知其中每个女孩在每个男孩心目中的排名，以及每个男孩在每个女孩心目中的排名，应该怎样为他们牵线配对呢？最好的方案当然是每个人的另一半正好都是自己的第一选择，但是这通常不能实现。例如，如果男1 号最喜欢的是女1 号，而女1 号的最爱不是男1 号，那么两个人的最佳选择不可能被同时满足。再如，如果好几个男孩最喜欢的都是同一个女孩，那么这几个男孩的首选也不会同时得到满足。那么怎样的配对才合理？  
其实，媒人给客户介绍对象，最关心的是成功率，即婚姻的稳定性。找的对象太完美不见得就稳定。例如，如果男1 号和女1 号各有各的对象，但男1 号觉得女1 号比现女友更好一些；女1 号也发现男1 号比现男友更好。此时，两人就会抛弃各自现在的对象。若出现这种情况，则婚姻搭配是不稳定的。因此，媒人给客户牵线配对时，虽然不能让每个人都得到最满意的，但搭配必须得稳定，即实现稳定的婚配问题。换句话说，对于任何男子，在他心目中比他当前伴侣更好的女性，都不会认为他是该女性一个更好的选择，对于任何一个女子也是这样。这就是稳定婚配问题。下面结合具体实例介绍稳定婚配问题求解算法。  
设有${n}$个男士的集合$X=\{X_{1},X_{2},\cdots X_{n}\}$和${n}$个女士$Y=\{Y_{1},Y_{2},\cdots,Y_{n}\}.$。每个男士有一个排序的列表，把女士按照其结婚对象优先级进行排序。同样，每个女士也有一个关于男士的优先级列表，如表10-4 和表10-5 所示。可用如表10-6 所示的$n$维矩阵表示表10-2 和表$10-$3 的信息，其中$p$行$q$列的的元素包含两个序号，第一个为对应女士在该对应男士的优先列表中的序号，第二个为对应女士在该对应男士的优先列表中的序号。例如，第3 行第2 列的元素2,1 表示，女士$b$是男士𝐶的第二选择，而男士$C$是女士$^{\cdot b}$的第一选择。稳定的婚姻搭配总是存在吗？如果存在，应该怎样设计？  
![表10-4 男士的优先选择      表10-5 女士的优先选择        表10-6 等级矩阵](images/eeb4d95ed93c439b00277ad6b2abb0debc1221b5f2be434ac75d9ca0a75c470d.jpg)  
下面给出稳定婚配算法：  
第一步：初始时，集合𝑋所有男士和集合𝑌中女士都是自由的。  
第二步：如果集合𝑋有自由男士，从中任选一个男士$X_{i}$，然后执行以下步骤：  
求婚：选中的自由男士$X_{i}$向女士$Y_{j}$求婚，其中$Y_{j}$是$X_{i}$的优先列表中当前最佳人选，即当前没有拒绝过他且优先级最高女士。  
回应：如果𝑌𝑗是自由的，则她接受求婚并与$X_{i}$配对。如果𝑌𝑗不是自由的，她将$X_{i}$与其当前的配偶做比较。如果她更喜欢$X_{i}$，则接受$X_{i}$的求婚，她的前配偶就变成自由人。否则，她就拒绝$X_{i}$的求婚，$X_{i}$还是自由的。  
第三步：返回$n$个匹配对的集合。  
很容易得出该算法不超过$ n^{2}$迭代就会终止。  
现以表10-6 所示等级矩阵为例，介绍使用稳定婚姻算法的具体计算过程：  
1） 现有自由男士𝐴，$B$，$C。 A$向当前最佳人选$b$女士求婚，由于$𝑏$是自由的，故$𝑏$接受。如表10-7 所示，其中括号表示被接受的求婚，下划线表示被拒绝的求婚，下同。  
2） 现有自由男士$𝐵$，$𝐶$。$B$当前最佳人选$b$女士求婚，由于$𝑏$不是自由的，她把$𝐵$与当前配偶$𝐴$做比较，由于$𝐴$的优先级较高，故拒绝$B$的求婚，如表10-8 所示：  
3） 现有自由男士$ B$，$C$。$B$向当前最佳人选$c$女士求婚，由于$c$是自由的，故$𝑐$接受。如表10-9 所示：  
表10-7 算法步骤1 效果        表10-8 算法步骤2 效果       表10-9 算法步骤3 效果
![](images/04f6613bd702aca04822bcc29a5b6aa1c146fd849ed7d7f1b4075e32f9ac7c21.jpg)  
4） 现有自由男士𝐶。$C$向其当前最佳人选$c$女士求婚，由于$c$不是自由的，她把𝐶和当前配偶$B$做比较，由于$\cdot B$的优先级较高，故拒绝$𝐶$的求婚。如表10-10 所示：  
5） 现有自由男士$𝐶$。$C$向其当前最佳人选$b$女士求婚，由于$b$不是自由的，她把𝐶和当前配偶$𝐴$做比较，由于$C$的优先级较高，故$𝐶$替换掉$𝐴$。如表10-11 所示：  
6） 现在有自由男士𝐴。𝐴其当前最佳人选$a$女士求婚，由于$a$是自由的，所以$a$接受了。如表10-12 所示：  
![表10-10 算法步骤3 效果       表10-11 算法步骤3 效果        表10-12 算法步骤3 效果 ](images/2f07c86d6a24dc95791ee60bf8db01f7f6a3315e5959c792dba3c38b6b45fab3.jpg)  
下面证明以上的匹配是一个稳定的婚姻匹配$𝑀$：由于该算法在所有$n$个男士和$n$个女士一一配对后停止，故仅需证明$𝑀$的稳定性。用反证法。假设$M$是不稳定的，则必然存在一个男士$𝑋$和一个女士$𝑌$，它们在$𝑀$中没有匹配，但比当前$M$中配偶更倾向于对方。  
因为$𝑋$按照降序对其优先列表中的每个女士求婚，而$𝑌$优先于$𝑋$在$M$中的配偶，$X$一定在某次迭代的时候向$𝑌$求过婚。无论$𝑌$拒绝了$𝑋$的求婚，还是先接受然后又在后面的迭代中用其他人替换掉了$𝑋$，$𝑌$的配偶在$𝑌$中的优先级列表中一定比$𝑋$有更高的优先级。根据前面假设：相对于$𝑋$在𝑀中的配偶，$𝑌$更倾向于$𝑋$，故该结论和假设矛盾。因此，$M$是稳定婚配。"
空关系,概念,"['第五章 关系模型与理论', '§ 5.1 关系的数学模型', '5.1.3 关系的表示', '3、矩阵表示法']","{'实体类型': '概念', '定义': '无任何元素的关系', '特点': '关系图中只有结点，无任何边，关系矩阵元素全是0'}",,4,"在使用关系的数学模型对实际问题进行建模的时候，通常需要对关系模型进行一些定量的数值计算以实现对实际问题的求解，此时无论是关系的集合表示方法和关系图法，都不方便实现对关系模型定量的数值计算。为此，我们引入二元关系的矩阵表示法。  
假设$\boldsymbol A=\{a_{1},a_{2},\cdots,a_{n}\}$, $B=\{b_{1},b_{2},\cdots,b_{m}\}$是任意给定的两个非空有限集合，$R$是$A$到$B$的一个二元关系，则按下列方式定义的$m\times n$阶矩阵$M_{R}=(r_{i j})_{m\times n}$称为$R$的关系矩阵：
$$
r_{ij}=\begin{cases}1\text{,若}\langle a_i,b_j\rangle\in R\\0\text{,若}\langle a_i,b_j\rangle\not\in R\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-3)}
$$
其中$A$中元素$a_{i\cdot}$序号对应矩阵元素的行下标，$B$中元素$b_{j}$序号对应矩阵元素的列下标。  
值得注意的是：由关系矩阵的定义可知，关系矩阵的元素有且仅有0 和1 这两种状态，这样的矩阵一般称之为布尔矩阵，主要用于一些逻辑演算，在运算规则上与普通矩阵有一些差异。为满足后续内容学习的需要，在此简要介绍布尔矩阵的若干基本运算，具体包括并运算、交运算、补运算和布尔积运算，其具体定义如下：  
【定义5.9】设$A=\left(a_{i j}\right)$和$B=\left(b_{i j}\right)$是两个$m\times n$布尔矩阵，则$𝐴$和$B$的并矩阵定义为如下$m\times n$布尔矩阵：$A\lor B=C=\left(c_{i j}\right)$，其中：  
$c_{ij}=\begin{cases}1\text{,如果}a_{ij}=1\text{ 或}b_{ij}=1\\0\text{,如果}a_{ij}=0\text{ 且}b_{ij}=0\end{cases}(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-4)}$      （5-4）  
【定义5.10】设$A=\left(a_{i j}\right)$和$B=\left(b_{i j}\right)$是两个$m\times n$布尔矩阵，则$A$和$B$的交矩阵定义为如下一个$m\times n$布尔矩阵：$A\land B=C=\left(c_{i j}\right)$，其中：
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=1\text{ 且}b_{ij}=1\\0\text{,如果}a_{ij}=0\text{ 或}b_{ij}=0\end{cases}(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-5)}
$$
【定义5.11】设$A=\left(a_{i j}\right)$任意给定的一个$m\times n$布尔矩阵，则𝐴的补矩阵定义为如下$m\times$$n$布尔矩阵：$\bar{A}=C=\left(c_{i j}\right)$，其中：
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=0\\0\text{,如果}a_{ij}=1\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-6)}
$$
【定义5.12】设$A=\left(a_{i j}\right)$是$m\times p$矩阵，$B=\left(b_{i j}\right)$是$p\times n$矩阵，则$𝐴$和$B$的布尔积矩阵定义为如下$m\times n$布尔矩阵：$A\odot B=C=\left(c_{i j}\right)$，其中：  
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=0\\0\text{,如果}a_{ij}=1\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-6)}
$$
需要注意的是：两个布尔矩阵可进行布尔或和布尔与运算的前提是这两个矩阵具有相同的行数和列数，可进行布尔积运算的前提是前一个矩阵的列数等于后一个矩阵的行数。  
在学习了二元关系的三个基本表示方法后，下面我们考察空关系、完全关系和恒等关系这三个常用特殊关系的关系矩阵和关系图各有什么特点：  
(1) 空关系$\varnothing$  因为$\emptyset\subseteq A\times B$(或$\emptyset\subseteq A\times A)$)，所以$\varnothing$也是一个从$𝐴$到$B$(或$𝐴$上)的关系，称之为空关系，即无任何元素的关系。空关系的关系图中只有结点，无任何边，且关系矩阵中的元素全是0  
(2) 完全关系（全域关系） $A\times B$或(或$A\times A)$本身也是一个从$𝐴$到$B$(或$𝐴$上)的关系，称之为完全关系，即含有全部序偶的关系。完全关系的关系图中所有结点之间都有有向边互联，关系矩阵中的元素全是1。  
(3) 恒等关系 $I_{A}$  $I_{A}\subseteq A\times A$，则$I_{A}=\{\langle x,x\rangle|x\in A\}$为$A$上的恒等关系。完全关系的关系图中所有结点都有一个有向环，不同结点之间无任何有向边联结。  
![](images/9a95167e68610708edb7fef0f0474b8284d349dcc5f3b662d3280809d00fbf1e.jpg)
图5-6 空关系、全关系与恒等关系  
设$A=\left\{1,\ 2,\ 3\right\}$，则$A$ 上的空关系∅、完全关系$A\times A$及恒等关系$I_{A}$的关系图如图5-6 所示，下面三个布尔矩阵分别是它们的关系矩阵：  
$M_{\emptyset}=\left(\begin{array}{ccc}0&0&0\\0&0&0\\0&0&0\end{array}\right)\quad M_{A\times A}=\left(\begin{array}{ccc}1&1&1\\1&1&1\\1&1&1\end{array}\right)\quad M_{I_A}=\left(\begin{array}{ccc}1&0&0\\0&1&0\\0&0&1\end{array}\right)$"
空集,概念,"['1.1.2 集合的概念与表示', '四、常用的特殊集合', '1.空集与全集', '§ 1.1 集合的基本知识', '第一章  集合与计数基础']","{'实体类型': '概念', '特点': '具有特殊性质', '定义': '不含任何元素的集合称为空集', '性质': '是一切集合的子集并且是绝对唯一的'}",,4,集合论中有一些非常重要和常用的特殊集合，它们分别具有一些特殊性质。离散数学中很多基本概念的定义及其性质讨论都离不开它们。下面具体介绍这些特殊集合的基本概念及性质，包括空集、全集、有限集、无限集、子集、幂集等。
笛卡尔积,概念,"['第五章 关系模型与理论', '5.1.1  序偶与笛卡尔积', '§ 5.1 关系的数学模型']","{'实体类型': '概念', '作用': '将两个集合组合成一个高维空间的数学机制', '定义': '集合A与B的所有可能的序偶组成的集合，记为A×B', '性质': '运算结果仍是一个集合，每个元素是一个序偶'}",,2,从数学角度看，有些关系比较容易用数学符号表达。例如，自然数集合上自然数的大小比较关系，可用符号≤进行表示。但在很多时候，问题并没有这么简单，例如要表示某班每个学生与其籍贯之间的关系，这就涉及到该班学生集合与地域集合这两个集合元素之间的一种对应关系。此时，要想用数学符号表示这种对应关系，就需要一些巧妙的设计。事实上，可分别将学生集合和地域集合看成是两个在不同维度上的一维空间，并将这两个一维空间进行有序组合张成一个二维空间。此时，对于学生集合中任意一个给定的学生，将这个学生与其籍贯进行有序绑定后，就形成了这个二维空间中的一个点。所有这样的点构成的集合显然就准确地表示了该班每个学生与其籍贯之间的关系。由此可见，我们其实得到一种刻画两个集合中元素之间关系新方法，即首先将这两个集合组合成一个高维空间，然后用高维空间中点的集合来表示两个集合元素之间的关系。显然，这种新方法比前述用符号≤表示大小关系的传统方法更具普适性。本节着重介绍使用这种新方法构建的关系数学模型，为此首先介绍由两个集合组合成一个高维空间的数学机制，即元素的序偶与集合的笛卡尔积。
等价关系,概念,"['第六章 特殊关系模型', '6.4.1 粗集定义问题', '6.1.2 集合的划分与商集', '§ 6.3 偏序关系与元素比较', '§ 6.1 等价关系与元素分类', '6.1.1  等价关系与等价类']","{'实体类型': '概念', '定义': ['表示相同、相等、平等、一致等含义的关系，刻画对象之间在某个方面的无差异性', '假设𝐴是任一给定的非空集合，$R$是$𝐴$上的一个二元关系，如果$𝑅$满足自反性、对称性和传递性，则称$𝑅$是一个等价关系', '非空集合上的关系，满足自反性、对称性和传递性', '个体域上的关系，使得域中的元素可以划分为互不相交的等价类'], '应用': ['将集合中元素进行分类，使得属于同一类的元素彼此之间具有等价关系，而分属不同类型的元素之间不具有等价关系', '用于集合的划分和元素分类'], '特点': ['属于同一类的元素因其相互之间满足等价关系而可将它们看成是一些无差异的个体，进而将这些无差异个体抽象成一个个体或代表元', '关系$R$是等价关系当且仅当$𝑅$同时具备自反性、对称性和传递性；关系$R$不是等价关系当且仅当$𝑅$不具备自反性或对称性或传递性'], '作用': '实现对集合的化简', '领域应用': '在计算机及相关信息领域得到广泛应用'}",,2,等价关系，顾名思义就是表示相同、相等、平等、一致等含义的关系，刻画的是对象之间在某个方面的无差异性。可用等价关系将集合中元素进行分类，使得属于同一类的元素彼此之间具有等价关系，而分属不同类型的元素之间不具有等价关系。属于同一类的元素因其相互之间满足等价关系而可将它们看成是一些无差异的个体，进而将这些无差异个体抽象成一个个体或代表元，由此实现对集合的化简。目前，等价关系可以有效地实现对数据的抽象和化简，已在计算机及相关信息领域得到广泛应用。本节具体介绍等价关系的基本知识，主要包括等价关系与等价类的概念和性质、集合划分与商集的相关知识。
等价关系模型,概念,['第六章 特殊关系模型'],"{'实体类型': '概念', '作用': '与元素的分类'}",,1,前面学习了关系模型的概念及其五个基本性质。不难发现，日常生活或工作中很多关系虽然从表面上看形态各异、互不相同，但都满足一些相同的基本性质。例如集合之间的相等关系、直线之间的平行关系、多边形之间的全等关系、学生同学关系、整数之间的同余关系等等，它们都满足自反性、对称性和传递性这三条基本性质。我们自然会想到把所有满足这三条性质的关系归为一类特殊关系，并考察这类关系有什么特殊性质和特殊作用，以便在大量错综复杂的具体关系中找到一些共性特征和规律性认识。同样，还有一些关系满足另外一些基本性质，例如集合之间的包含关系、整数之间的整除关系、实数之间的大小关系、英文单词之间的字典排序关系等等，这些关系虽然表面上互不相同、各不相关，但它们都满足自反性、反对称性和传递性这三条基本性质。我们自然会将所有这类关系归为另外一类特殊关系，并考察这类关系有什么相应的特殊性质和特殊作用。通过以上分析，不难得到研究关系的一个普适性方法，就是以关系模型的五个基本性质为标准，将所有关系按它们对这些基本性质满足程度和状态的不同划分为若干特殊类型，然后分门别类地研究同类型关系的共同性质和不同类型关系之间的区别与联系，由此构建各种特殊关系模型及相关理论。显然，通过状态组合构造出的特殊关系有很多，不便一一枚举。作为代表，本章着重介绍其中三种最典型、最基本的特殊关系模型，并分别讨论它们各自的作用，即等价关系模型与元素的分类、相容关系模型与元素的聚类、偏序关系模型与元素的比较。
等价类,概念,"['§ 6.1 等价关系与元素分类', '第六章 特殊关系模型', '6.1.1  等价关系与等价类']","{'实体类型': '概念', '相关概念': '等价关系', '定义': '设$R$是非空集合𝐴上的等价关系，对任意$x\\\\in A$，称下列集合：[x]_{R}=\\\\{y|y\\\\in A\\\\land\\\\langle x,y\\\\rangle\\\\in R\\\\}为$𝑥$关于$𝑅$的等价类', '性质': ['等价类产生的前提是关系$R$必须是等价关系', '$𝐴$中所有与$x$有关系$𝑅$的元素$𝑦$构成了$[x]_{R}$', '$𝐴$中任意一个元素一定对应一个由其生成的等价类', '$R$具有自反性意味着对任意$x\\\\in A$，$[x]_{R}$非空', '$R$具有对称性意味着对任意$x,y\\\\in A$，若有 $y\\\\in[x]_{R}$，则有$x\\\\in[y]_{R}$'], 'name': '等价类'}",,2,等价关系，顾名思义就是表示相同、相等、平等、一致等含义的关系，刻画的是对象之间在某个方面的无差异性。可用等价关系将集合中元素进行分类，使得属于同一类的元素彼此之间具有等价关系，而分属不同类型的元素之间不具有等价关系。属于同一类的元素因其相互之间满足等价关系而可将它们看成是一些无差异的个体，进而将这些无差异个体抽象成一个个体或代表元，由此实现对集合的化简。目前，等价关系可以有效地实现对数据的抽象和化简，已在计算机及相关信息领域得到广泛应用。本节具体介绍等价关系的基本知识，主要包括等价关系与等价类的概念和性质、集合划分与商集的相关知识。
等价联结词,概念,"['第三章  命题演算与推理', '§ 3.1 命题的概念与运算', '3.1.3  命题的常用联结词', '三、蕴含与等价联结词']","{'实体类型': '概念', '定义': '表示两个命题同时为真且同时为假的逻辑联结词', '特点': '记作 P↔Q', '真值条件': 'P↔Q 的取值为真，当且仅当 P 与 Q 具有相同的真值'}",,4,"有时候需要构造一个复合命题表示如果某个命题为真，那么另外一个命题必为真的含义，相当于自然语言中“如果…，那么…”的意思，由此得到的逻辑运算称为命题的“蕴涵”运算或者“条件”运算。该运算及其逻辑联结词的具体定义如下：  
【定义3.5】设 $P、 Q$ 是任意两个命题，复合命题$^{\prime\prime}P$ 蕴涵 $Q$ ”称为 $P$ 与 $Q$ 的蕴含式或蕴含运算，记作 $P\rightarrow Q$ ，其中符号$""~\rightarrow~""$称为蕴含联结词（简称为蕴含词），$P$ 称为蕴含式的前提或前件，   $Q$   称为蕴含式的结论或后件。 $P\rightarrow Q$   的真值为假，当且仅当   $P$ 为真且  $Q$ 为假。  
例如，若令 $P$ 表示“我喜欢唱歌”， $Q$表示“我喜欢跳舞”，则蕴涵式 $P\rightarrow Q$ 就表示复合命题“如果我喜欢唱歌，那么必然喜欢跳舞”。其中命题“我喜欢唱歌”是蕴含式的前提或前件，命题“我喜欢跳舞”是蕴含式的结论或后件。  
对于任意两个命题 $P$ 和 $Q$ ，蕴涵运算 $P\rightarrow Q$ 的真值取值规定如表3-2 第3 列所示。  
表${3 -2}\rightarrow,\ \leftrightarrow$的运算表
![](images/920c1058d83ec209cf5c8390304a73d783359e57457ba1d5a111c26950f592f9.jpg)  
由表3-2 可以看出，对于蕴涵运算 $P\rightarrow Q$ 的真值取值，只有当 $P$ 为真， $Q$ 为假时，$P\rightarrow Q$ 的真值才为假，在其余三种情况下 $P\rightarrow Q$ 的真值均为真。也就是说，当 $P$ 为为假时，无论 $Q$ 为真或者为假，$P\rightarrow Q$ 的真值均为真。  
其实，蕴含运算符$""{\rightarrow}""$既可表示充分条件，也可表示必要条件，关键是看哪个作为运算的前件，哪个作为运算的后件。具体地说，对于蕴涵式 $P\rightarrow Q$ ，具有如下结论：  
命题 $P$ 是命题 $Q$ 的充分条件，因为根据蕴涵式的含义有：若 $P$ 为真，则 $Q$ 必为真；  
命题 $Q$ 是命题 $P$ 的必要条件，因为根据蕴涵式的含义有：若 $Q$为假，则 $P$ 必为假。  
自然语言表达充分条件和必要条件的方式有很多种，实际使用的时候应注意区分。例如，若令 $P$ 表示命题“天气好”， $Q$ 表示命题“我去公园”，则对于如下4 个命题：  
（1）如果天气好，我就去公园；（2）只要天气好，我就去公园；  
（3）只有天气好，我才去公园；（4）仅当天气好，我才去公园。  
对于命题（1）2），$P$ 是 $Q$ 的充分条件，$Q$ 是 $P$ 的必要条件，可表示为 $P\rightarrow Q$；  
对于命题（3）4），$P$ 是 $Q$ 的必要条件，$Q$ 是 $P$ 的充分条件，可表示为 $Q\rightarrow P$ 。  
有时需要构造一个复合命题表示两个命题同时为真且同时为假的含义，相当于自然语言中“等价”、“当且仅当”的意思，由此得到的逻辑运算称为命题的“等价”运算或者“双蕴含”运算。该运算及其逻辑联结词的具体定义如下：  
【定义 3.6 】设   $P$ 、 $Q$   是任意两个命题，复合命题 “   $P$   等价   $Q$   ” 称为   $P$   与   $Q$   的等价 式或等价运算，有时也称为双蕴含运算，记作 $P\leftrightarrow Q$ ，其中符号$\leftrightarrow$称为等价联结词(简称为等价词)。$P\leftrightarrow Q$ 的取值为真，当且仅当 $P$ 与 $Q$具有相同的真值。  
例如，若令 $P$ 表示“我喜欢唱歌”，$Q$ 表示“我喜欢跳舞”，则等价式 $P\leftrightarrow Q$ 就表示复合命题“我喜欢唱歌当且仅当我喜欢跳舞”，或者“如果我喜欢唱歌，那么必然喜欢跳舞，并且如果我喜欢跳舞，那么必然喜欢唱歌”。  
对于任意两个命题 $P$ 和 $Q$ ，其等价运算$P\leftrightarrow Q$的真值取值情况如表3-2 第4 列所示。"
等价运算,算法,"['第三章  命题演算与推理', '§ 3.1 命题的概念与运算', '3.1.3  命题的常用联结词', '三、蕴含与等价联结词']","{'实体类型': '算法', '定义': '基于等价联结词的逻辑运算', '应用': '表示两个命题的逻辑等价关系'}",,4,"有时候需要构造一个复合命题表示如果某个命题为真，那么另外一个命题必为真的含义，相当于自然语言中“如果…，那么…”的意思，由此得到的逻辑运算称为命题的“蕴涵”运算或者“条件”运算。该运算及其逻辑联结词的具体定义如下：  
【定义3.5】设 $P、 Q$ 是任意两个命题，复合命题$^{\prime\prime}P$ 蕴涵 $Q$ ”称为 $P$ 与 $Q$ 的蕴含式或蕴含运算，记作 $P\rightarrow Q$ ，其中符号$""~\rightarrow~""$称为蕴含联结词（简称为蕴含词），$P$ 称为蕴含式的前提或前件，   $Q$   称为蕴含式的结论或后件。 $P\rightarrow Q$   的真值为假，当且仅当   $P$ 为真且  $Q$ 为假。  
例如，若令 $P$ 表示“我喜欢唱歌”， $Q$表示“我喜欢跳舞”，则蕴涵式 $P\rightarrow Q$ 就表示复合命题“如果我喜欢唱歌，那么必然喜欢跳舞”。其中命题“我喜欢唱歌”是蕴含式的前提或前件，命题“我喜欢跳舞”是蕴含式的结论或后件。  
对于任意两个命题 $P$ 和 $Q$ ，蕴涵运算 $P\rightarrow Q$ 的真值取值规定如表3-2 第3 列所示。  
表${3 -2}\rightarrow,\ \leftrightarrow$的运算表
![](images/920c1058d83ec209cf5c8390304a73d783359e57457ba1d5a111c26950f592f9.jpg)  
由表3-2 可以看出，对于蕴涵运算 $P\rightarrow Q$ 的真值取值，只有当 $P$ 为真， $Q$ 为假时，$P\rightarrow Q$ 的真值才为假，在其余三种情况下 $P\rightarrow Q$ 的真值均为真。也就是说，当 $P$ 为为假时，无论 $Q$ 为真或者为假，$P\rightarrow Q$ 的真值均为真。  
其实，蕴含运算符$""{\rightarrow}""$既可表示充分条件，也可表示必要条件，关键是看哪个作为运算的前件，哪个作为运算的后件。具体地说，对于蕴涵式 $P\rightarrow Q$ ，具有如下结论：  
命题 $P$ 是命题 $Q$ 的充分条件，因为根据蕴涵式的含义有：若 $P$ 为真，则 $Q$ 必为真；  
命题 $Q$ 是命题 $P$ 的必要条件，因为根据蕴涵式的含义有：若 $Q$为假，则 $P$ 必为假。  
自然语言表达充分条件和必要条件的方式有很多种，实际使用的时候应注意区分。例如，若令 $P$ 表示命题“天气好”， $Q$ 表示命题“我去公园”，则对于如下4 个命题：  
（1）如果天气好，我就去公园；（2）只要天气好，我就去公园；  
（3）只有天气好，我才去公园；（4）仅当天气好，我才去公园。  
对于命题（1）2），$P$ 是 $Q$ 的充分条件，$Q$ 是 $P$ 的必要条件，可表示为 $P\rightarrow Q$；  
对于命题（3）4），$P$ 是 $Q$ 的必要条件，$Q$ 是 $P$ 的充分条件，可表示为 $Q\rightarrow P$ 。  
有时需要构造一个复合命题表示两个命题同时为真且同时为假的含义，相当于自然语言中“等价”、“当且仅当”的意思，由此得到的逻辑运算称为命题的“等价”运算或者“双蕴含”运算。该运算及其逻辑联结词的具体定义如下：  
【定义 3.6 】设   $P$ 、 $Q$   是任意两个命题，复合命题 “   $P$   等价   $Q$   ” 称为   $P$   与   $Q$   的等价 式或等价运算，有时也称为双蕴含运算，记作 $P\leftrightarrow Q$ ，其中符号$\leftrightarrow$称为等价联结词(简称为等价词)。$P\leftrightarrow Q$ 的取值为真，当且仅当 $P$ 与 $Q$具有相同的真值。  
例如，若令 $P$ 表示“我喜欢唱歌”，$Q$ 表示“我喜欢跳舞”，则等价式 $P\leftrightarrow Q$ 就表示复合命题“我喜欢唱歌当且仅当我喜欢跳舞”，或者“如果我喜欢唱歌，那么必然喜欢跳舞，并且如果我喜欢跳舞，那么必然喜欢唱歌”。  
对于任意两个命题 $P$ 和 $Q$ ，其等价运算$P\leftrightarrow Q$的真值取值情况如表3-2 第4 列所示。"
等值关系,概念,"['一、等值关系的基本概念', '§ 3.2 命题公式与等值演算', '三、命题公式的等值演算', '第三章  命题演算与推理', '3.2.2 等值关系与等值演算']","{'实体类型': '概念, 性质', '定义': 'A、B是含命题变元的公式，如不论对命题变元作何种真值指派，都使得A和B的真值相同，则称命题公式A与B等价或等值', '判断方法': '将两个公式的真值表列出，看取值是否一致', '应用': '用于命题公式的等值演算'}",,4,"【定义3.13】𝐴、$B$是含命题变元$P_{1},P_{2},\dots,P_{n}$的公式，如不论对$P_{1},P_{2},\dots,P_{n}$作何种真值指派，都使得𝐴和$B$的真值相同，则称命题公式$A$与$B$等价或等值，记为$A=B$或$A\Leftrightarrow B$。  
判断两个命题公式是否等值，最直观的方法就是将这两个公式的真值表列出，然后看看两者的取值是否一致。  
【定理3.1】对于命题公式$𝐴$和$B$，$A\Leftrightarrow B$的充分必要条件是公式$A\leftrightarrow B\Leftrightarrow T$  
【定理3.2】命题公式的等值满足如下三条性质：  
自反性：即对任意命题公式$𝐴$，$A=A$；  
对称性：即对任意命题公式𝐴和$B$，若$A\Leftrightarrow B$，则$B=A$；  
传递性：即对任意命题公式 𝐴 ， $B$ 和 $C$ ，若 $A\Leftrightarrow B$ ， $B\Leftrightarrow C$ ，则 $A\Leftrightarrow C$"
等值关系的充分必要条件,定理,"['第三章  命题演算与推理', '§ 3.2 命题公式与等值演算', '3.2.2 等值关系与等值演算', '一、等值关系的基本概念']","{'实体类型': '定理', '条件': 'A↔B↔T'}",,4,"【定义3.13】𝐴、$B$是含命题变元$P_{1},P_{2},\dots,P_{n}$的公式，如不论对$P_{1},P_{2},\dots,P_{n}$作何种真值指派，都使得𝐴和$B$的真值相同，则称命题公式$A$与$B$等价或等值，记为$A=B$或$A\Leftrightarrow B$。  
判断两个命题公式是否等值，最直观的方法就是将这两个公式的真值表列出，然后看看两者的取值是否一致。  
【定理3.1】对于命题公式$𝐴$和$B$，$A\Leftrightarrow B$的充分必要条件是公式$A\leftrightarrow B\Leftrightarrow T$  
【定理3.2】命题公式的等值满足如下三条性质：  
自反性：即对任意命题公式$𝐴$，$A=A$；  
对称性：即对任意命题公式𝐴和$B$，若$A\Leftrightarrow B$，则$B=A$；  
传递性：即对任意命题公式 𝐴 ， $B$ 和 $C$ ，若 $A\Leftrightarrow B$ ， $B\Leftrightarrow C$ ，则 $A\Leftrightarrow C$"
等值关系的性质,性质,"['第三章  命题演算与推理', '§ 3.2 命题公式与等值演算', '3.2.2 等值关系与等值演算', '一、等值关系的基本概念']","{'实体类型': '性质', '自反性': '对任意命题公式A，A=A', '对称性': '对任意命题公式A和B，若A↔B，则B=A', '传递性': '对任意命题公式A、B和C，若A↔B，B↔C，则A↔C'}",,4,"【定义3.13】𝐴、$B$是含命题变元$P_{1},P_{2},\dots,P_{n}$的公式，如不论对$P_{1},P_{2},\dots,P_{n}$作何种真值指派，都使得𝐴和$B$的真值相同，则称命题公式$A$与$B$等价或等值，记为$A=B$或$A\Leftrightarrow B$。  
判断两个命题公式是否等值，最直观的方法就是将这两个公式的真值表列出，然后看看两者的取值是否一致。  
【定理3.1】对于命题公式$𝐴$和$B$，$A\Leftrightarrow B$的充分必要条件是公式$A\leftrightarrow B\Leftrightarrow T$  
【定理3.2】命题公式的等值满足如下三条性质：  
自反性：即对任意命题公式$𝐴$，$A=A$；  
对称性：即对任意命题公式𝐴和$B$，若$A\Leftrightarrow B$，则$B=A$；  
传递性：即对任意命题公式 𝐴 ， $B$ 和 $C$ ，若 $A\Leftrightarrow B$ ， $B\Leftrightarrow C$ ，则 $A\Leftrightarrow C$"
等值型范式,概念,"['第四章  谓词演算与推理', '§ 4.3 谓词公式的范式', '4.3.1 等值型范式']","{'实体类型': '概念', '相关概念': '前束范式'}",,3,前束范式是谓词公式中所有范式中唯一满足等值性质的方式。所谓满足等值性质，是指对于任意一个谓词公式，将其做规范化表示后所得到的范式与原谓词公式等值。本小节主要介绍前束范式的概念与构造方法。
等值演算,算法,"['一、等值关系的基本概念', '§ 3.2 命题公式与等值演算', '三、双量词式的等值与蕴含', '三、命题公式的等值演算', '第三章  命题演算与推理', '3.2.2 等值关系与等值演算', '4.2.4 谓词公式的等值与蕴含', '§ 4.2  谓词公式与等值演算', '第四章  谓词演算与推理', '二、基本等值关系']","{'实体类型': ['算法', '原理'], '定义': ['基于命题公式的等值关系进行的演算', '通过基本等值关系以及代入定理和替换定理进行的演算'], '方法': '基于等值关系对命题公式进行演算的方法', '特点': '用于命题公式的解释与分类', '应用': ['简化命题公式的演算过程', '实现对问题的求解', '用于判断谓词公式之间的等价关系'], '目的': ['判定命题公式的基本类型', '证明两个命题公式之间具有等值关系', '对复杂的命题公式进行化简'], '条件': '基于量词的排列和谓词的逻辑关系', '相关内容': '谓词公式的等值关系与演算'}",,2,前面我们学习了命题的基本概念及其若干常用的逻辑运算，要将这些概念和运算应用到计算机系统的设计与开发，必须对其用数学符号的方式进行形式化描述和处理，形成命题演算的数学表达式，使得命题逻辑能够像代数一样进行抽象的符号运算，建立一种命题代数。本节比较系统地介绍这种命题代数的基本理论，包括命题公式的基本概念、命题公式的解释与分类、命题公式的等值关系与等值演算、命题公式的内否式与对偶式等。
等值演算法,算法,"['第三章  命题演算与推理', '§ 3.4 命题公式的范式', '3.4.2 主析取范式', '三、主析取范式构造举例']",{'实体类型': '算法'},,4,"由前面的讨论可知，对于任一给定的命题公式，其主析取范式的构造方法主要有两种，即真值表法和等值演算法。  
真值表法就是在真值表中选出公式为真的所有行，并在选出的每一行中找到该行解释所对应的小项，将所有这些小项进行析取即可得到相应的主析取范式。"
等值表达式,概念,"['第四章  谓词演算与推理', '§ 4.2  谓词公式与等值演算', '4.2.4 谓词公式的等值与蕴含', '一、谓词公式的等值关系']","{'实体类型': '概念', '定义': '若公式G↔H是有效公式，则称公式G和H为等值的，记为G⇔H'}",,4,"谓词公式等值关系的含义与命题公式等值关系很类似，是指两个谓词公式在任意相同的解释下具有完全相同的真值，表达的是两个谓词公式之间的恒等关系。下面借助谓词公式的概念给出谓词公式等值关系的具体定义：  
【定义4.17】 假设$G$ 和$H$ 是任意两个给定的谓词公式，若公式$G\leftrightarrow H$是有效公式，则称公式$G$ 和$H$ 称为等值的，记为$G\Leftrightarrow H$，并称$G\Leftrightarrow H$为等值表达式或等值式。  
由上述定义可知，判断两个谓词公式$G$ 和$H$是否等值，关键在于证明谓词公式$G\leftrightarrow H$为有效公式，这种思路与证明命题公式等值关系的基本思路是一致的。类似于命题公式的等值演算系统，在谓词公式的等值演算系统中，通常也是先证明出一些重要的谓词公式等值式，然后将这些重要谓词等值式作为基本等值式进一步推演出更多的谓词公式等值式，这种推演过程构成了谓词公式等值演算的主要内容。下面不加证明地给出这些重要而基本的谓词公式等值式，读者可自行给出证明。  
第一组  命题公式中永真公式的谓词公式代换实例显然是有效谓词公式。因此，按命题逻辑中24 个基本等值式模式使用谓词公式代换出来的实例必定是谓词公式等值式。例如：  
$\forall x P(x)\Leftrightarrow\neg\neg\forall x P(x);\;\;\forall x\exists y\big(H(x,y)\to R(x,y)\big)\Leftrightarrow\neg\neg\forall x\exists y\big(H(x,y)\to R(x,y)\big)$ 等都是双重否定律的代换实例。再如：  
$$
\forall x(\ P(x)\rightarrow Q(y))\rightarrow\exists z H(z)\Leftrightarrow\lnot\forall x(\ P(x)\rightarrow Q(y))\lor\exists z H(z)
$$  
等都是蕴含等值式的代替实例。  
第二组  关于量词的若干等值式：  
（1）消去量词等值式：设个体域$D$ 为有限集$\{x_{0},x_{1},\cdots,x_{n}\ \}$，则有： $\forall x P(x)\Leftrightarrow P(x_{0})\land P(x_{1})\land\cdots\land P(x_{n});\ \ \exists x P(x)\Leftrightarrow P(x_{0})\lor P(x_{1})\lor\cdots\lor P(x_{n})$  
（2）量词否定等值式：对于含有量词的谓词式$\forall x P(x)$和$\exists x Q(x)$，有：$\lnot\forall x P(x)\Leftrightarrow\exists x\lnot P(x);\;\;\lnot\exists x Q(x)\Leftrightarrow\forall x\lnot Q(x)$  
（3）量词辖域的收缩与扩张等值式：  
$$
\forall x(P(x)\lor S)\Leftrightarrow\forall x P(x)\lor S;\;\;\forall x(P(x)\land S)\Leftrightarrow\forall x P(x)\land S;
$$  
$$
\exists x(P(x)\lor S)\Leftrightarrow\exists x P(x)\lor S;\ \exists x(P(x)\land S)\Leftrightarrow\exists x P(x)\land S;
$$  
$$
\forall x(P(x)\rightarrow S)\Leftrightarrow\exists x P(x)\rightarrow S;\quad\exists x(P(x)\rightarrow S)\Leftrightarrow\forall x P(x)\rightarrow S;
$$  
$$
\forall x(S\rightarrow P(x))\Leftrightarrow S\rightarrow\forall x P(x);\ \exists x(S\rightarrow P(x))\Leftrightarrow S\rightarrow\exists x P(x)\\,
$$  
(4）量词分配等值式  
$$
\forall x(P(x)\land Q(x))\Leftrightarrow\forall x P(x)\land\forall x Q(x);\ \exists x(P(x)\lor Q(x))\Leftrightarrow\exists x P(x)\lor\exists x Q(x);
$$  
上述基本的等值关系式很多可以互相推导。特别是当个体域为有限集时，很容易理解上述等值关系的合理性。  
例如，假设$P(x)$表示$x$ 今天上课，个体域为计算机学院全体学生的集合，则：  
$(\forall x)P(x)$表示今天所有学生都上课了；$\neg(\forall x)P(x)$表示今天不是所有学生上课了；$(\exists x)\lnot P(x)$表示今天有学生没上课。即有：$\lnot(\forall x)P(x)\Leftrightarrow(\exists x)\lnot P(x).$。  
$(\exists x)P(x)$表示今天有学生上课；$\neg(\exists x)P(x)$表示今天没有学生上课；$(\forall x)\neg P(x)$表示今天所有学生都没上课。即有：$\lnot(\exists x)P(x)\Leftrightarrow(\forall x)\lnot P(x)\,$。  
再如，假设谓词$G(x)$表示$x$ 勤奋学习，谓词$H(x)$表示$x$ 喜欢体育运动，个体域是某大学里的全体学生。则有：  
谓词公式$(\forall x)(G(x)\land H(x))$表示：“某大学里的所有学生既勤奋学习又喜欢体育运动”；谓词公式$(\forall x)G(x)\land(\forall x)H(x).$表示：“某大学里的所有学生都勤奋学习且大学里的所有学生都喜欢体育运动”。两者含义显然相同，即有$\forall x(G(x)\land H(x))\Leftrightarrow\forall x G(x)\land\forall x H(x)\,$。  
谓词公式 $(\exists x)(G(x)\lor H(x))$表示：“某大学里有些学生勤奋学习或喜欢体育运动”；谓词公式$(\exists x)G(x)\lor(\exists x)H(x)$表示：“某大学里有些学生勤奋学习或大学里有些学生喜欢体育运动”。两者的含义显然相同，即有$\exists x(G(x)\lor H(x))\Leftrightarrow\exists x G(x)\lor\exists x H(x)\,\mathrm{s}$。"
等级记分,概念,"['第六章 特殊关系模型', '§ 6.3 偏序关系与元素比较', '6.4.2 得分评判问题']","{'实体类型': '概念', '定义': '科学记分方法之一，如“优秀，良好，合格，不合格”四级打分法', '应用': '解决分数基准点不一致的问题'}",,3,"在很多需要排名次的非相互对抗场合，如歌手大赛中的参赛选手、成员的考评、电视节目中主持人大赛中参赛选手的考评等，其评断标准并不像球赛中进球、失球那样准确无误，往往由评判员们分别打分，通过分数计算名次。然而，分数有其不公平的一面。例如，甲、乙、丙三名歌手的得分分别为94 分，92 分，90 分。  
甲的分数-乙的分数$=$乙的分数-丙的分数。  
虽然这两个差相等，但并不能说明甲高出乙的水平等于乙高出丙的水平，因为这里1 分所表示的水平差距并不唯一确定，而是与评判者紧密相关。又如，对于期末考试中某班平均分语文85 分与数学60 分，该班某学生语文80 分，数学70 分，尽管$80>70$，也不能说明这名学生语文学的比数学好。因为这里分数基准点是不一致的。因此有了“标准分”和“等级记分”等科学记分方法，如 “优秀，良好，合格，不合格”四级打分法便是其中一种。  
由偏序关系的定义可知，任何排名次必是一个偏序关系，并且在很大情况下应是线性关系。因此，在上述排名场合（如歌手大赛考评等）可使用“0-1”法记分，并利用偏序关系的反对称性，在比赛过程对选手进行动态排名。下面结合具体实例介绍具体排名过程：  
设有 $A_{1},A_{2},A_{3},A_{4},A_{5},A_{6}$ 这 6  名参赛者，按其下标次序出场比赛。分别为每名评判员准 备一张如表$6–4$ 所示的表格用于对选手进行打分评判。  
表6-4 评判表
![](images/4c85af2d68ddc01acb3d234836cc3dd6fee35852bbb1e27a76917d56b5336e04.jpg)  
每个评判员的打分方法如下：当$A_{2}$参赛结束时，立即把他与$A_{1}$比较，谁更好一些，若$A_{2}$好一些，在表6-4 的$\mathsf{C}_{21}$位置填上1，若$A_{1}$好一些，则在该位置填上0；$A_{3}$参赛结束后，依次与$A_{1}$、$A_{2}$比较谁好一些，好一些为1，差一些为0，并把这两个比较出来的数依次填在${\mathsf C}_{31}$和  
${\mathsf{C}}_{32}$的位置上。如此下去，知道所有的选手参赛结束。即有：  
$$
C_{ij}=\begin{cases}1&\quad\text{当}A_i\text{比}A_j\text{好时}\\0&\quad\text{当}A_i\text{比}A_j\text{好时}\end{cases}\quad(j<i)\quad\text{(6-5)}
$$  
注意的是，当某一位选手比赛结束都要与他参赛的每一名选手比较而且给出谁好谁差的结论(是1 还是0)。也可以利用偏序关系的传递性减少比较次数。如$A_{5}$比$A_{1}$强，而此时已经有$\mathsf{C}_{31}=\mathsf{C}_{41}=0$，则必有${\mathsf{C}}_{53}={\mathsf{C}}_{54}=1$。表6-5 是某一位评判员所裁判的结果。  
表6-5   评判结果
![](images/0095a64294f10a0d76e1eae14906fdb5c9f5e6a5bc895b20e56aa4e7f6a6e039.jpg)  
如$|A_{5}$行说明$A_{5}$比$A_{1}$好，比$A_{2}$差，比$A_{3}$好，比$A_{4}$  
然后对表6-5 进行整理：首先利用偏序关系的反对称性填充表格的上角，上表虚线为对称轴，右上角各个位置(如$\mathsf C_{12}$)看它的对称位置(即$\mathsf{C}_{21}$)上的数，若其对称位置上数为$1\left(\mathbb{C}_{21}=1\right)$,则它为$0\left(\mathsf{C}_{12}=0\right)$)；若其对称位置上的数为1，则它就是0。即有：  
$$
\mathrm{C}_{ij}=\begin{cases}0&\quad\text{当C}_{ji}=1\text{时}\\1&\quad\text{当C}_{ji}=0\text{时}\end{cases}\quad(i<j)\quad\text{(6-6)}
$$  
完成后如表6-6 所示：  
表6-6 对评判结果的整理
![](images/620931865382a676e3093ac6d3295347415e7bef2cda108424f0318f6d3c3129.jpg)  
把表6-6 各行的数字加起来填入总分列中（倒数第二列），这个列中各数分别为其所在行中相应选手的得分。它们不可能有两个相等的数，否则说明评判或填表有误应作废。把这个列的各数相加填入这一列最后一格为总分和$σ$。事实上$σ$是一个固定数$σ=m(m-1)/2$其中$m$为参赛选手的人数。本例中$m=6$，故有$σ=6*(6-1)/2=15$。  
把表6-6 中各列数字加起来，填入最后一行（即总分行）的相应位置上，分别为其所在列上相应选手的失分，以虚线为对称轴和其对称位置上的得分加起来应该等于$m-1$，  
减1 是因为自己不与自己比较，总分行总分和也等于$m(m-1)/2$。表的最后一列是把各选手的得分转化为人们习惯的百分制，本例中用的是$(m-1)*$得分数$+60$，以避免出现低于60 分的情况，最后把所有评判员有效给出的各个选手成绩相应加起来求平均成绩，按平均成绩高低排名次，此时可能出现并列名次。"
简化同余类和简化剩余系,定义,"['第二章  整数与算法设计基础', '§ 2.2 同余算术及其应用', '2.2.1 同余关系及其运算']","{'实体类型': '定义', '内容': '对于正整数m，假设Ri(m)是任意一个模m同余类，若Ri(m)中存在一个整数与m互素，则称Ri(m)是一个模m简化同余类或模m简化剩余类。如果分别从每个模m简化同余类中取出一个整数作为代表xi构成一个有限集合{x0,x1,⋯,xφ(m-1)}，则称该集合为模m的一个简化剩余系，简称为简化系。其中φ(m)称为欧拉函数，表示模m简化剩余类的数目，亦即不超过m且与m互素的正整数个数'}",,3,"在很多场合，我们往往只关心用某一特定正整数除以整数得到的余数。例如，星期日期就是从某个星期日开始经历的天数除以7 得到的余数，通过对天数取以7 为除数的余数，就可以用短短的7 个数字借助以7 为周期的循环机制表示无穷无尽的天数。事实上，取余数是一种以有限驾驭无限的重要智慧，对于任一给定的正整数$m$，通过考察所有整数除以$m$ 所得余数的差异，把所有具有相同余数的整数归为一类，则可将所有整数分为$m$ 个基本类型。若分别从每个类中取一个整数作为代表构成一个$m$ 元有限集，则可将这个有限集看成是对整数集的一个抽象，由此完成了整数集从无限向有限的转化。在这个分类过程中，整数之间是否具有相同余数的关系起着非常关键的作用，由此得到如下同余的概念：  
【定义2.9】假设$m$ 是任一给定的正整数，对于任意两个整数$a$和$b$，它们除以$m$ 后得到的余数分别记为$a({\bmod{\ m}})$和$b({\bmod{\ m}})$，如果这两个余数相等，即有：  
$$
a({\bmod{\ m}})=b({\bmod{\ m}})\tag{2-9}
$$  
则称$a$与$b$具有模$\pmb{m}$同余关系，简称为$a$与$b$模$\pmb{m}$同余或同余，记为$a\equiv b({\bmod{m}})$或$b\equiv$$a({\bmod{\ m}})$；否则称$a$与$b$对于模$\mathbfit{m}$不同余，记为$a\not\equiv b({\bmod{{m}}})$或$b\not\equiv a({\bmod{\ m}})$。  
根据上述定义，不难证明下面关于模$_m$同余的判定定理：  
【定理2.19】假设$m$是任一给定的正整数，任意两个整数$a$和$b$具有模$_m$同余关系，当且仅当$m$能够整除$a-b$。  
【定理2.20】假设$m$ 是任一给定的正整数，任意两个整数$a$ 和$b$ 具有模$m$同余关系，  
当且仅当存在整数$k$，使得整除$a=b+k m$  
下面定理表明了同余关系的保加性和保乘性：  
【定理2.21】设$m$ 是任一正整数，若整数$a$ 与$b$ 模$m$ 同余，整数$c$与$d$ 同余模$m$，则它们的和与积也分别模$m$ 同余。即：若$a\equiv b({\bmod{\ }}m)$，$c\equiv d({\bmod{\pmod{m}}})$，则有：  
$$
a+c\equiv(b+d)(\bmod{\ m}),\ \ a c\equiv b d(\bmod{\ m})
$$  
【定理2.22】假设$m$ 是任一给定的正整数，则对任意两个整数$a$ 和$b$，成立下面两个关于余数的计算公式：  
$$
(a+b){\bmod{\ m}}=((a{\bmod{\ m}})+(b{\bmod{\ m}})){\bmod{\ m}}\tag{2-10}
$$  
$$
ab\ {\bmod{\ m}}=((a{\bmod{\ m}})(b{\bmod{\ m}}))\ {\bmod{\ m}}\tag{2-11}
$$  
例如，对于$7\equiv2{\bmod{\mathrm{~5~}}}$和$11\equiv1{\bmod{\mathrm{~5~}}}$，由定理2.21 知：  
$$
18=7+11\equiv2+1=3({\bmod{\mathrm{~}}}5)
$$  
$$
77=7\cdot11\equiv2\cdot1=2{\pmod{5}}
$$  
再如，对于任意三个数，比如说1, 2 和5，由定理2.22 知存在如下等式：  
$$
(1+2)({\bmod{\ }}5)=((1\ \,({\bmod{\ }}5)+(2\ \,({\bmod{\ }}5))({\bmod{\ }}5)
$$  
$$
2\,\bmod\,5=\left((1\,\bmod\,5)(2\,\bmod\,5)\right)\,(\bmod\,5)
$$  
值得注意的是，同余关系在一般情况下不满足消去律，例如 $8\equiv12({\bmod{\mathrm{~}}}4)$，两边同除以4 后，$2\equiv3({\bmod{\mathrm{~}}}4)$显然是不成立的，但是存在下列性质：  
【定理2.23】若$a c\equiv b c({\bmod{\pmod{m}}})$，且$c$ 与$m$ 互素，则有：$a\equiv b({\bmod{\ }}m)$  
如前所述，使用同余可以实现对整数集合的划分或分类，现在就来讨论这个问题。由同余的定义可知，对于任意给定的正整数$m$，可依照除以$m$ 后的余数值以及模$m$ 同余关系，将所有整数划分为$m$ 个互不相交的子集合。据此，我们引入如下同余类的概念：  
【定义2.10】设$m$ 是任一给定正整数，对于每个整数$i$，$0\leq i<m$，定义如下集合：  
$$
R_{i}(m)=\{n|n\equiv i({\bmod{\pmod{\ m}}},n\in Z\}\tag{2-12}
$$  
则称每个$^{}R_{i}(m)$分别是模$m$ 的一个同余类或剩余类，在不引起混淆的情况下，通常也将$R_{i}(m)$简记为$[i]$，并记为：$Z_{m}=\{[0],[1],\cdots[m-1]\}.$。  
【定理2.24】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m),$所有模$m$ 同余类，则有下述结论成立：  
（1）每个整数$a$ 都恰好属于某个同余类，通常将这个同余类记为$[a]_{m}$或$[a]$  
（2）对于任意的两个整数$a$ 和$b$，它们属于同一个同余类的充分必要条件是：
$$
a\equiv b({\bmod{m}})
$$  
上述定理表明，每个整数必定属于且仅属于其中一个剩余类，属于同一个剩余类的任意两个整数都是模$m$ 同余的，属于不同剩余类的任意两个整数不可能是模$m$ 同余的。  
根据定理，可以在$.Z_{m}=\{[0],[1],\cdots[m-1]\}$上定义关于同余类的加法和乘法运算：  
【定义2.11】假设$m$ 是任一给定的正整数对于任意给定的两个整数$a$和$b$，定义：
$$
[a]_{m}+[b]_{m}=[a+b]_{m}
$$  
$$
[a]_{m}\cdot[b]_{m}=[a\cdot b]_{m}
$$  
【定义2.12】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m)$是所有模$m$ 同余类，如果从每个同余类$R_{i}(m)$中分别取一个整数$x_{i}$构成一个$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$，则称该有限集合为模$m$ 的一个完全剩余系，简称为完全系；称$m$ 元有限集合$\{0,\ 1,\ 2,\ \cdots\ ,$为最小非负完全剩余系。  
对于正整数$m$，假设$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$是模$m$ 的一个完全剩余系，对于其中的任意一个整数$\cdot x_{i}$，如果${\bf\nabla}_{}^{}$与$m$ 互素，则$x_{i}$所在同余类${\mathbf{}}R_{i}(m)$中每个整数$k$ 都与$m$ 互素。这是因为根据$k\equiv x_{i}({\bmod{\pmod{m}}})$，即有$\cdot_{x_{i}}=k+q m$。由此可知，如果$k$ 与$m$有大于1 的公因子，那么$x_{i}$必然与$m$ 有大于1 的公因子。类似地，如果$x_{i}$与$m$ 互素，则$x_{i}$所在同余类$R_{i}(m)$中每个整数$k$ 都与$m$ 不互素。由此得到如下简化同余类和简化剩余系的概念：  
【定义2.13】对于正整数$m$，假设$R_{i}(m)$是任意一个模$m$ 同余类，若$R_{i}(m)$中存在一个整数与 $m$  互素，则称 $\ R_{i}(m)$ 是一个模 $\pmb{m}$  简化同余类或模 $\pmb{m}$  简化剩余类。如果分别从每个模 $m$ 简化同余类中取出一个整数作为代表$x_{i}$构成一个有限集合$\{x_{0},\ x_{1},\ \cdots,x_{\varphi(m-1)}\}$，则称该集合为模$m$ 的一个简化剩余系，简称为简化系。其中$\varphi(m)$称为欧拉函数，表示模$m$ 简化剩余类的数目，亦即不超过$m$ 且与$m$ 互素的正整数个数。  
因为所有模$m$ 同余类构成整数集合的一个划分，所以每个与$m$ 互质的整数仅存在于它  所在的简化同余类中。由此可以看出，简化同余类以及欧拉函数$\varphi(m)$在整数互质性质的研究中具有非常重要的作用，后面将使用这些概念证明欧拉定理和费马小定理。这两个定理不仅是整数理论中非常著名而重要的定理，而且还是现代非对称数论加密算法的基础。"
简单命题函数,概念,"['第四章  谓词演算与推理', '§ 4.1 个体词、谓词与量词', '4.1.2  命题函数与谓词', '二、个体变量与命题函数']","{'实体类型': '概念', '定义': '定义在$D^{n}$上取值于$\\{0,1\\}$的$n$元函数', '示例': '“$P(x)$”和“$x>5$”为一元简单命题函数，“$x+y=10$”和“$x+y<z$”分别是二元和三元简单命题函数'}",,4,"对于任一给定的原子命题，其主语或宾语是一种可以独立存在的确定对象，我们称之为个体常量，将个体常量抽象成含义不确定的变量后，则称之为个体变量。相关定义如下：  
【定义4.1】客观世界中可以独立存在的具体或抽象对象称为个体，表示个体的词称为个体词。若个体词以常量的方式表示特定个体，则称之为个体常量；若个体词以变量的方式泛指不确定的个体，则称之为个体变量。  
例如，前述原子命题“小张是大学生”中的个体为“小张”。再如，命题“电子计算机是科学技术的工具”中的个体为“电子计算机”；命题“张三比李四高”中的个体为：“张三”、“李四”.可用个体常量表示这些确定的个体。  
对于个体常量，通常用带下标或不带下标的英文字母$a$，$b$，$c$，…表示。例如，可用$a$和$b$ 分别表示前述个体“小张”和“电子计算机”。  
对于前述含变量的语句“$x$是大学生”、“$x>5$”、“$x+y=10$”、“$x+y<z$”，其中的x，y，$z$均表示泛指的不确定个体，因而它们都是个体变量。  
对于个体变量，通常用带下标或不带下标的英文字母$x$，y，$z$，…表示。  
个体变量的取值应有一个明确范围，故有如下个体域的概念：  
【定义4.2】个体变量的取值范围称为个体域或论域。宇宙间所有的个体域聚集在一起构成的个体域，称为全总个体域。  
个体变量的个体域可根据问题的实际状况或需要来确定。例如，对于含变量语句“$\cdot_{x}$ 是大学生”，其中个体变量$x$ 的变化范围，可以确定为全体人类，也可以确定为某单位的全体职工，还可以确定为某个大学的全班同学或者某个中学的全班同学，等等。显然，个体变量的个体域的不同，其相应含变量语句的含义也会有所不同。  
现在个体变量与个体域概念基础上，给出命题函数的定义：  
【定义4.3】设$x_{1},x_{2},\cdots x_{n}$为$n$个个体变量，其个体域均为非空集合$D$，则定义在$D^{n}$上取值于$\{0,1\}$的$n$元函数称为$^n$元简单命题函数，记为$P(x_{1},x_{2},\cdots x_{n})$。  
例如，前述表示“$x$ 是大学生”的式子”$P(x)$“，以及“$x>5$”、“$x+y=10$”、“$x+y<z$”，都是简单命题函数。其中”$P(x)$“和“$x>5$”为一元简单命题函数，“$x+y=10$”和“$x+y<z$”分别是二元和三元简单命题函数。  
如同原子命题可以通过联结词进行逻辑演算得到复合命题一样，简单命题函数也可通过联结词的逻辑演算，得到一种更为复杂的表达式，即复合命题函数。其具体定义如下：  
【定义4.4】简单命题函数通过“$\neg$”、“$\land$”、“$\lor$”、“$\rightarrow$”、“$\leftrightarrow$”等联结词进行逻辑演算得到的逻辑表达式，称为复合命题函数。  
例如，对于如下给定的简单命题函数：  
${A(x)\colon x\text{身体好};B(x)\colon x\text{学习好};C(x)\colon x\text{工作好}}$  
复合命题函数：  
$$
\neg A(x)\to(\neg B(x)\land\neg C(x))
$$  
表示如果$x$身体不好，那么学习和工作都不会好。"
简单图,概念,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.2 图的定义与分类']","{'实体类型': '概念', '定义': '无环的线图'}",,3,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)"
算术基本定理,定理,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.2 整数的因数分解', '三、算术基本定理']","{'实体类型': '定理', '内容': '任何大于1的整数可以唯一表示成若干素数的幂的乘积', '重要性': '给出了整数素数分解的存在性与唯一性，在整数理论和初等数学中具有重要地位'}",,4,"对于是任意给定的两个整数$a$ 和$b$，如果$a$ 能够整除$b$，则通过整数$a$ 实现了对整数$b$的一个分解，即将$b$ 分解成$a$ 和另外一个整数的乘积。现在我们从整除的角度讨论整数的分解问题，亦即整数的因数分解问题。  
我们知道，素数是整个整数中不能够再分解的数，因为素数除了±1和其自身之外，没有其它的非平凡因子。因此，在对整数进行因数分解的过程中可以将素数看出是构成整数的最基本的要素或构件。通过对整数进行到素数层次的因数分解，就可以从整除的角度比较完整地考察整数的基本结构，并由此探究整数的基本性质和基本规律。  
【定理2.12】任何大于1 的正整数$a$，或为一素数，或可以写成若干素数的积，即$a=$$p_{1}p_{2}\cdots p_{b}$，其中$p_{i}(1\leq i\leq b)$是素数。  
[定理2.13] (算术基本定理) 任何大于1 的整数$a$可以唯一表示成
$$
a=p_{1}^{a_{1}}p_{2}^{a_{2}}\cdots p_{k}^{a_{k}}\tag{2-4}
$$  
其中$p_{1},p_{2},\cdots,p_{k}$是素数，$p_{1}<p_{2}<\dots<p_{k}$，$a_{1},a_{2},\cdots,a_{k}$是正整数。  
上述定理给出了整数素数分解的存在性与唯一性，称之为算术基本定理。由此可以看出，整数的素数分解在整数理论以及在整数初等数学中的重要性。  
【定义2.8】若$p_{1},p_{2},\cdots,p_{k}$是素数，$p_{1}<p_{2}<\cdots<p_{k},$，$a_{1},a_{2},\cdots,a_{k}$是正整数，那么称  
$$
a=p_{1}^{a_{1}}p_{2}^{a_{2}}\cdots p_{k}^{a_{k}}\tag{2-6}
$$  
是整数$a$ 的素幂分解式，其中$p_{i}$是素数，$p_{1}<p_{2}<\dots<p_{k}$，$a_{i}$是正整数。【例题2.12】写出51480 的素幂分解式。  
整数的素幂分解式给出了整数一种基于素数的结构表达，在数论研究中具有非常重要的作用。例如，下面两个定理表明，可以使用其素幂分解式计算两个整数的最大公约数和最小公倍数，还可以证明最大公约数和最小公倍数之间的关系。  
【定理2.14】设整数$a,~b$ 的素因子分解式分别为：  
$$
a=p_{1}^{a_{1}}\cdots p_{k}^{a_{k}};\,\,\,b=p_{1}^{b_{1}}\cdots p_{k}^{b_{k}}
$$  
其中$p_{1},\cdots,p_{k}$是互不相同的素数，$a_{1},\cdots,a_{k},\;\;b_{1},\cdots,b_{k}$是非负整数。则有：  
$$
{\operatorname*{gcd}(a,b)=p_{1}^{m i n(a_{1},b_{1})}\cdots p_{k}^{m i n(a_{k},b_{k})\tag{2-7}}}
$$  
$$
{\operatorname{lcm}(a,b)=p_{1}^{m a x(a_{1},b_{1})}\cdots p_{k}^{m a x(a_{k},b_{k})}}\tag{2-8}
$$"
算法,概念,"['第二章  整数与算法设计基础', '2.3.1 算法的基本概念', '§ 2.3 算法设计的基本知识']","{'实体类型': '概念', '定义': '通过运算的方式按照机械的步骤逐步实现对问题的求解', '狭义定义': '一个由已知推求未知的过程，对于符合一定规范的输入，它能够在有限的时间内获得所需的输出', '特点': '基于构造性和机械性的运算体系', '应用': '契合计算机的运算特点和需求，广泛应用于计算机科学', '基本性质': ['有穷性：算法中每条指令的执行次数和时间均有限', '确定性：对算法的描述必须无歧义，以保证算法执行结果是确定的', '输入：一个算法有0个或多个输入，以确定运算对象的初始情况', '输出：一个算法有一个或多个输出，以反映对输入数据加工后的结果', '可行性：算法中有待实现的运算都是基本运算，算法原则上要能够精确地运行'], '基本要素': ['基本运算和操作：算术运算、关系运算、逻辑运算、数据操作', '控制结构：顺序结构、选择结构、循环结构', '数据结构：存储结构和逻辑结构'], '表示方法': ['自然语言', '流程图', '伪代码']}",,2,在前面整数理论中有不少关于整数的算法，例如求最大公因数的辗转相除算法、素数查找算法、 凯撒整数加密算法、 RSA  整数加密算法等等。 所谓算法， 简单地说就是算术之法， 也就是说通过运算的方式按照机械的步骤逐步实现对问题的求解。算法的这种基于构造性和机械性的运算体系非常契合计算机的运算特点和需求。因此，随着计算机的诞生和兴起，算法设计理论与技术迅速得到广泛重视和深入研究。目前，除了整数理论之外，在离散数学的其它内容中很多也都是通过一些非常精彩算法形式为计算机提供服务。为更好地学习离散数学及其应用知识，本节简要介绍算法设计的基本知识。
算法效率,概念,"['第二章  整数与算法设计基础', '§ 2.3 算法设计的基本知识', '2.3.2 算法效率的度量']","{'实体类型': '概念', '定义': '对算法利用时间和内存空间的效率进行分析', '特点': '是问题规模的某个函数，函数值随问题规模增长而增长', '分析方法': '使用渐近效率的概念，从极限角度考虑运行时间随输入规模增长'}",,3,"从实际应用考虑，如果一个算法的运行时间过久，比如需要长达数年的时间，那么该算法就不适合用来解决问题。同样，一个算法如果需要占用很大的内存开销，导致系统无法为其它程序提供必须的内存资源，那么这也是不能够接受的。因此，对于设计出来的算法，需要对其利用时间和内存空间的效率进行分析，这就是算法的效率分析。无论是时间效率还是空间效率上看，算法的效率都是问题规模的某个函数，并且函数值随着问题规模的增长而增长。如果函数值随问题规模的增长而增长得很快，则说明算法效率很低，反之，如果函数值随问题规模的增长而增长得很慢，则说明算法效率很高。  
因此，为了更好地分析算法的效率，需要一些合适的方法来描述或度量函数值随自变量增长而增长的速度，如果不能精确地算出函数增长的速度，那么至少也要针对函数增长的不同速度划分出若干性质不同的等级，这就是函数增长的阶。当输入规模足够大时，精确表示的运行时间函数中的常系数和低阶项会被输入规模所掩盖。此时，只需要考虑高阶项即可。比如若复杂度为多项式$x^{2+}\!x$，$x$的复杂度会被$x^{2}$的复杂所吸收，因此只需考虑最高阶。  
事实上，在分析和度量算法效率的时候，重点考虑的是当问题规模充分大时的函数值增长的情况。因此，分析和度量算法效率时，一般都使用渐近效率的概念，即从极限的角度考虑运行时间如何随输入规模的增长而增长。为了更加准确地阐释和度量算法复杂度随问题规模增长而增长的速度，计算机科学家在算法领域引入了一些函数增长符号，其中时间复杂度常用大𝑂符号表述，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。使用这种方式时，时间复杂度可被称为是渐近的，它主要考察当输入值充分大时的情况。  
对于绝大多数算法来说，其复杂度的增长速度还可以使用基本或常用函数增长类型通过示例性的方法来描述或表示，如常数级、对数级、多项式级、指数级、阶乘级增长速度，等等。这些常用函数的增长速度非常直观，以它们增长速度为标准对算法的计算复杂度进行度量，会使得算法复杂度分析变得易于理解。因此，掌握这些常用函数的基本增长类型对算法设计具有非常重要的指导意义，下面对其做简要介绍：  
（1）$\mathrm{O}(1)$：复杂度为常数级，例如从一个数据集中取出第一个元素；  
（2）$\mathrm{O}(\lg n)$：该类型常见于将一个数据集分成两半，然后将其中每一半再分成两半，以此类推。例如对有序数组进行二分查找，其时间复杂度就是$\mathrm{O}(\lg n)$；  
（3）$\mathrm{O}(n)$：该类型常见于数据集中的遍历，例如在线性结构中顺序查找某个元素的算法，其时间复杂度就是$\mathrm{O}(n)$；  
（4）$\mathrm{O}(n\lg n)$：该类型与前面所述的$\mathbf O(1g\ n)$有点类似，常见于将一个数据集分成两半，然后将每一半再分成两半，并且对每一半数据进行遍历，以此类推，例如归并排序时间复杂度就是$\mathrm{O}(n\,1\mathrm{g}\,n)$；  
（5）${\mathrm{O}}(n^{2})$：常见于两重嵌套循环的算法之中，也就是说在遍历一个数据集中的每一个元素的时候同时遍历另一个数量级相同的数据集，基本排序算法（如冒泡排序、直接插入排序、直接选择排序等）的时间复杂度是${\mathrm{O}}(n^{2})$；  
（6）${\mathrm{O}}(n^{3})$：该类型常见于三重嵌套循环的算法之中，在线性代数中，两个$n$阶方阵相乘的时间复杂度就是${\mathrm{O}}(n^{3})$，著名求解最短路径Floyd 算法的时间复杂度也是${\mathrm{O}}(n^{3})$；  
（7）$\mathrm{O}(2^{n})$：为一个数据集生成所有的子集，这种数量级的算法可以说是很低效的，在规模较大的时候是不可行的；  
（8）$\mathrm{O}(n!)$：对具有$n$ 个元素的集合进行全排列时就是该类型的典型例子，这种数量级的算法基本上是不可行的。"
算法设计,概念,"['第二章  整数与算法设计基础', '§ 2.3 算法设计的基本知识']","{'实体类型': ['概念', '原理'], '定义': '基于整数模余运算理论的非对称加密算法', '重要性': '学习与应用离散数学所必备的基本知识', '地位': '随着计算机的诞生和兴起，得到广泛重视和深入研究', '应用': ['在计算机领域发挥重要作用', '为离散数学的其它内容提供算法形式，服务于计算机']}",,1,"整数作为一种最基本的离散量和离散结构不仅是离散数学的研究对象，而且其自身也是研究其它离散结构的一项基本工具，在离散量的度量、计数和算法设计等方面发挥重要的基础性作用。整数是人类最早认识和使用的数，专门研究整数及其性质的整数理论是一个具有几千年历史的非常古老的数学分支。在很长一段时期内，整数理论被认为仅仅是思想的体操、数学思维能力的训练工具，其实用性并没有得到充分重视。著名数学家数学王子高斯就曾给出这样的评价：如果说数学是科学的皇后，那么整数理论则是皇后头上美丽的皇冠。意指其仅仅是漂亮而不够实用。直到20 世纪70 年代基于整数模余运算理论的非对称加密算法被设计出来并取得成功应用，整数理论的实用性才得到广泛重视。事实上，算法概念正是诞生于整数的算术运算，这使得整数理论与计算机算法有着一种天然的紧密联系。计算机学科的诞生与兴起让整数理论这门古老的学科重新焕发出新的生命并得到蓬勃发展。目前，整数理论已经成为算法设计与算法度量的一项基本工具，在散列函数构造、伪随机数生成、信息编码与加密等多个领域得到广泛应用。其实除整数之外，离散数学中很多其它离散结构模型，例如图模型、关系模型、群代数结构模型等，也都是通过相关算法在计算机领域发挥重要作用。因此，算法设计技术是学习与应用离散数学所必备的基本知识。  
综上所述，作为学习离散数学的另一入门基础，本章比较系统地介绍整数理论与算法设计的基本知识，具体包括整除的基本概念与运算性质、模余运算的基础知识、同余方程及其解法、非对称加密算法、算法设计的基本知识、算法设计的基本策略与应用等。"
算法设计策略,概念,"['第二章  整数与算法设计基础', '§ 2.4 算法设计策略与应用']","{'实体类型': '概念', '定义': '计算机问题求解算法遵循的基本设计策略', '特点': '蕴含深刻且普适的求解智慧', '应用': '帮助形成良好的算法思维，理解算法设计精髓'}",,2,计算机问题求解算法虽然千差万别，但都遵循一些基本的设计策略。这些策略蕴含着很多非常深刻而又普适的求解智慧。例如，分治策略把一个问题分解为若干规模较小的子问题，然后以递归的方式求解它们并通过合并它们的解来实现对原问题的求解，而回溯策略则认为对未知世界的探索是一个试错的过程，并给出具体的试错方案，这恰恰是对人类生活经验的一种抽象和总结。不断学习、领会和掌握这些智慧，就可逐步形成良好的算法思维，从而能够更加透彻地从本质上理解算法设计的精髓，为设计出高水平算法打下坚实的基础。本章主要结合具体应用实例介绍和分析算法设计的若干基本策略，包括蛮力与贪心策略、递归与分治策略、回溯与动态规划策略。
粗糙集理论,原理,"['第六章 特殊关系模型', '§ 6.3 偏序关系与元素比较', '6.4.1 粗集定义问题']","{'实体类型': '原理', '应用': '在模式识别、数据挖掘等技术领域得到广泛应用'}",,3,"现实世界中很多对象群体的边界是很模糊或者不确定的，例如，对于“中年人”这样的群体，怎样用集合或者其它数学工具进行描述？如果将“中年人”这个群体看出是一个集合$𝑆$的话，则$𝑆$就不是经典意义下的集合，因为其成员不确定。事实上，可以使用两个经典集合来刻画$𝑆$，一个叫做$𝑆$的上近似集合${S}\uparrow$，一个叫做$𝑆$的下近似集合$ S\downarrow$，让前者$𝑆↑$尽可能的小，后者$𝑆↑$尽可能的大。当$𝑆↑$能够等同于$𝑆↓$时,$S$就是经典集合，当$𝑆↑$不能够等同于$𝑆↓$时，则称$𝑆$是粗糙集或粗集。例如，可以用$S\uparrow=\{x|25\le x\le60\}$，即用25 岁至60 岁的人的集合，表示“中年人的集合”；还可以用$S\downarrow=\{x|30\le x\le50\}$，即用30 岁至50 岁的人的集合，表示“中年人的集合”。由于无法构造适当的“中年人的集合”的上下近似$S\uparrow=S\downarrow$，因此，“中年人的集合”$𝑆$是一个粗糙集。  
那么如何用准确的数学语言来定义粗糙集呢？下面通过等价关系给出粗集准确的数学定义。设$U$是个体域（或全集），$R$是$U$上的等价关系，则可由$R$导出的$U$的一个划分，如图$6-$$24\left(a\right)$所示，每个方格表示划分的一个单元，也就是一个$ R$等价类。  
如图$6–24\left(b\right)$所示，若$𝑆$是粗糙集，则$𝑆$的上下近似分别是两个粗线条勾画出的多边形，其中$S\uparrow$由与$𝑆$交不空方格的并组成，$S\downarrow$由包含于$𝑆$的方格并组成。  
![](images/05225fe2f04f5f432dc9b2bbf25b62263d90d0d724be9df376f08ea318717259.jpg)  
通过以上分析，就可以给出粗糙集𝑆的定义：  
【定义6.18】设$U$是个体域(或全集)，$R$是$U$上的等价关系，已知$𝑆$的成员均在$U$中。令： ${\begin{array}{l l}{S\uparrow=\cup\,\{[x]_{R}|[x]_{R}\cap S\neq\emptyset\}}&{;\;\;S\downarrow=\cup\,\{[x]_{R}|[x]_{R}\subseteq S\}}\end{array}}\quad\text{(6-4)}$  
那么称$S\uparrow$为$𝑆$的上近似，$S\downarrow$为$𝑆$的下近似。当$\textit{S}\uparrow=\textit{S}$↓时，$S$即是$U$的子集；当$S\uparrow\ne\textit{S}\downarrow$时，称 $𝑆$ 是 $U$ 的粗糙子集，简称为粗糙集或粗集。  
例如，表是考生情况调查表，其中$U$为被调查对象，$R$为高考成绩$(A-$优，$B-$良，$C-$中，$D-$差)；$X$为升学情况($+$为上，$/$为未上)。可根据高考成绩和升学状况进行分类，并可分别计算出下近似集、上近似集。  
表6-3 对集合𝑈的两种划分
![](images/23b7c96f86908a1723f3af9fc2fde337caca13329476de93665a25a8e36ee553.jpg)  
![](images/1cdfc65fbfddc11bcd85c455f6521676d2bf7ff363efa7f28d82ea21a3e04ed5.jpg)  
事实上，可分别按成绩和升学对$U$进行划分：  
$U/R=\{\{1,6\},\{2\},\{3,5\},\{4\}\}=\{Y_{1},Y_{2},Y_{3},Y_{4}\};\quad U/X=\{\{2,3,5,6\},\{1,4\}\}=\{X_{1},X_{2}\}$ 分别得到粗糙集$S$的上近似和下近似集合：  
$$
S(X_{1})\uparrow=Y_{1}\cup Y_{2}\cup Y_{3}=\{1,2,3,5,6\}\;\;;\;\;\;S(X_{2})\uparrow=Y_{1}\cup Y_{4}=\{1,4,6\};
$$  
$$
S(X_{1})\downarrow=Y_{2}\cup Y_{3}=\{2,3,5\}\;\;;\;\;\;S(X_{2})\downarrow=\;\;Y_{4}=\{4\}。
$$  
粗糙集可以表示含义模糊且不太确定的概念，大大拓广了经典集合的概念和应用范围，更为重要的是，粗糙集可由经典集合借助等价关系进行定义，具有坚实的理论基础。目前，粗糙集理论在模式识别、数据挖掘等技术领域得到广泛应用。"
粗集,概念,"['第六章 特殊关系模型', '§ 6.3 偏序关系与元素比较', '6.4.1 粗集定义问题']","{'实体类型': '概念', '定义': '无法用经典集合精确描述的集合，通过上近似和下近似集合来刻画', '特点': '成员不确定，边界模糊', '应用': '用于表示含义模糊且不太确定的概念，拓广了经典集合的概念和应用范围', '理论基础': '可由经典集合借助等价关系进行定义'}",,3,"现实世界中很多对象群体的边界是很模糊或者不确定的，例如，对于“中年人”这样的群体，怎样用集合或者其它数学工具进行描述？如果将“中年人”这个群体看出是一个集合$𝑆$的话，则$𝑆$就不是经典意义下的集合，因为其成员不确定。事实上，可以使用两个经典集合来刻画$𝑆$，一个叫做$𝑆$的上近似集合${S}\uparrow$，一个叫做$𝑆$的下近似集合$ S\downarrow$，让前者$𝑆↑$尽可能的小，后者$𝑆↑$尽可能的大。当$𝑆↑$能够等同于$𝑆↓$时,$S$就是经典集合，当$𝑆↑$不能够等同于$𝑆↓$时，则称$𝑆$是粗糙集或粗集。例如，可以用$S\uparrow=\{x|25\le x\le60\}$，即用25 岁至60 岁的人的集合，表示“中年人的集合”；还可以用$S\downarrow=\{x|30\le x\le50\}$，即用30 岁至50 岁的人的集合，表示“中年人的集合”。由于无法构造适当的“中年人的集合”的上下近似$S\uparrow=S\downarrow$，因此，“中年人的集合”$𝑆$是一个粗糙集。  
那么如何用准确的数学语言来定义粗糙集呢？下面通过等价关系给出粗集准确的数学定义。设$U$是个体域（或全集），$R$是$U$上的等价关系，则可由$R$导出的$U$的一个划分，如图$6-$$24\left(a\right)$所示，每个方格表示划分的一个单元，也就是一个$ R$等价类。  
如图$6–24\left(b\right)$所示，若$𝑆$是粗糙集，则$𝑆$的上下近似分别是两个粗线条勾画出的多边形，其中$S\uparrow$由与$𝑆$交不空方格的并组成，$S\downarrow$由包含于$𝑆$的方格并组成。  
![](images/05225fe2f04f5f432dc9b2bbf25b62263d90d0d724be9df376f08ea318717259.jpg)  
通过以上分析，就可以给出粗糙集𝑆的定义：  
【定义6.18】设$U$是个体域(或全集)，$R$是$U$上的等价关系，已知$𝑆$的成员均在$U$中。令： ${\begin{array}{l l}{S\uparrow=\cup\,\{[x]_{R}|[x]_{R}\cap S\neq\emptyset\}}&{;\;\;S\downarrow=\cup\,\{[x]_{R}|[x]_{R}\subseteq S\}}\end{array}}\quad\text{(6-4)}$  
那么称$S\uparrow$为$𝑆$的上近似，$S\downarrow$为$𝑆$的下近似。当$\textit{S}\uparrow=\textit{S}$↓时，$S$即是$U$的子集；当$S\uparrow\ne\textit{S}\downarrow$时，称 $𝑆$ 是 $U$ 的粗糙子集，简称为粗糙集或粗集。  
例如，表是考生情况调查表，其中$U$为被调查对象，$R$为高考成绩$(A-$优，$B-$良，$C-$中，$D-$差)；$X$为升学情况($+$为上，$/$为未上)。可根据高考成绩和升学状况进行分类，并可分别计算出下近似集、上近似集。  
表6-3 对集合𝑈的两种划分
![](images/23b7c96f86908a1723f3af9fc2fde337caca13329476de93665a25a8e36ee553.jpg)  
![](images/1cdfc65fbfddc11bcd85c455f6521676d2bf7ff363efa7f28d82ea21a3e04ed5.jpg)  
事实上，可分别按成绩和升学对$U$进行划分：  
$U/R=\{\{1,6\},\{2\},\{3,5\},\{4\}\}=\{Y_{1},Y_{2},Y_{3},Y_{4}\};\quad U/X=\{\{2,3,5,6\},\{1,4\}\}=\{X_{1},X_{2}\}$ 分别得到粗糙集$S$的上近似和下近似集合：  
$$
S(X_{1})\uparrow=Y_{1}\cup Y_{2}\cup Y_{3}=\{1,2,3,5,6\}\;\;;\;\;\;S(X_{2})\uparrow=Y_{1}\cup Y_{4}=\{1,4,6\};
$$  
$$
S(X_{1})\downarrow=Y_{2}\cup Y_{3}=\{2,3,5\}\;\;;\;\;\;S(X_{2})\downarrow=\;\;Y_{4}=\{4\}。
$$  
粗糙集可以表示含义模糊且不太确定的概念，大大拓广了经典集合的概念和应用范围，更为重要的是，粗糙集可由经典集合借助等价关系进行定义，具有坚实的理论基础。目前，粗糙集理论在模式识别、数据挖掘等技术领域得到广泛应用。"
素因数分解,概念,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识']","{'实体类型': '概念', '作用': '以素数为基本构件来考察或窥探整数的离散结构特征与变化规律'}",,2,本节主要介绍整数理论中若干最基本的知识。我们知道，整数相加、相减、相乘的结果都是整数，而除法结果却不一定是整数。因此，整数理论研究的重点自然是运算结果相对比较复杂的除法。通过整数的除法运算可以得到整数的素因数分解，由此我们便可以素数为基本构件来考察或窥探整数的离散结构特征与变化规律。在这个过程中，素数作为构造整数的基本构件，其性质与分布规律自然是整数理论的重要内容。因此，本节内容主要包括整数与整数除法的概念、公因数与公倍数、整数的素因数分解、素数的性质及相关算法等。
素幂分解式,定义,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.2 整数的因数分解', '三、算术基本定理']","{'实体类型': '定义', '内容': '整数表示成若干素数的幂的乘积的形式', '作用': '在数论研究中具有重要作用，可用于计算最大公约数和最小公倍数'}",,4,"对于是任意给定的两个整数$a$ 和$b$，如果$a$ 能够整除$b$，则通过整数$a$ 实现了对整数$b$的一个分解，即将$b$ 分解成$a$ 和另外一个整数的乘积。现在我们从整除的角度讨论整数的分解问题，亦即整数的因数分解问题。  
我们知道，素数是整个整数中不能够再分解的数，因为素数除了±1和其自身之外，没有其它的非平凡因子。因此，在对整数进行因数分解的过程中可以将素数看出是构成整数的最基本的要素或构件。通过对整数进行到素数层次的因数分解，就可以从整除的角度比较完整地考察整数的基本结构，并由此探究整数的基本性质和基本规律。  
【定理2.12】任何大于1 的正整数$a$，或为一素数，或可以写成若干素数的积，即$a=$$p_{1}p_{2}\cdots p_{b}$，其中$p_{i}(1\leq i\leq b)$是素数。  
[定理2.13] (算术基本定理) 任何大于1 的整数$a$可以唯一表示成
$$
a=p_{1}^{a_{1}}p_{2}^{a_{2}}\cdots p_{k}^{a_{k}}\tag{2-4}
$$  
其中$p_{1},p_{2},\cdots,p_{k}$是素数，$p_{1}<p_{2}<\dots<p_{k}$，$a_{1},a_{2},\cdots,a_{k}$是正整数。  
上述定理给出了整数素数分解的存在性与唯一性，称之为算术基本定理。由此可以看出，整数的素数分解在整数理论以及在整数初等数学中的重要性。  
【定义2.8】若$p_{1},p_{2},\cdots,p_{k}$是素数，$p_{1}<p_{2}<\cdots<p_{k},$，$a_{1},a_{2},\cdots,a_{k}$是正整数，那么称  
$$
a=p_{1}^{a_{1}}p_{2}^{a_{2}}\cdots p_{k}^{a_{k}}\tag{2-6}
$$  
是整数$a$ 的素幂分解式，其中$p_{i}$是素数，$p_{1}<p_{2}<\dots<p_{k}$，$a_{i}$是正整数。【例题2.12】写出51480 的素幂分解式。  
整数的素幂分解式给出了整数一种基于素数的结构表达，在数论研究中具有非常重要的作用。例如，下面两个定理表明，可以使用其素幂分解式计算两个整数的最大公约数和最小公倍数，还可以证明最大公约数和最小公倍数之间的关系。  
【定理2.14】设整数$a,~b$ 的素因子分解式分别为：  
$$
a=p_{1}^{a_{1}}\cdots p_{k}^{a_{k}};\,\,\,b=p_{1}^{b_{1}}\cdots p_{k}^{b_{k}}
$$  
其中$p_{1},\cdots,p_{k}$是互不相同的素数，$a_{1},\cdots,a_{k},\;\;b_{1},\cdots,b_{k}$是非负整数。则有：  
$$
{\operatorname*{gcd}(a,b)=p_{1}^{m i n(a_{1},b_{1})}\cdots p_{k}^{m i n(a_{k},b_{k})\tag{2-7}}}
$$  
$$
{\operatorname{lcm}(a,b)=p_{1}^{m a x(a_{1},b_{1})}\cdots p_{k}^{m a x(a_{k},b_{k})}}\tag{2-8}
$$"
素数,概念,"['2.1.3 素数的性质与查找', '第二章  整数与算法设计基础', '2.1.1 整数与整数除法', '§ 2.1 整数的基本知识']","{'实体类型': '概念', '地位': '素数是构成整数的基本要素，在整数理论中具有极其重要的地位，在整个整数理论中占据非常重要的基础性地位', '内容': '其性质与分布规律是整数理论的重要内容', '定义': '对于任意一个给定的非零整数a，若a≠±1且没有非平凡因子，则称a为素数或质数，构成所有整数的基本要素', '应用': '后续相关内容中详细讨论素数的性质与应用', '性质': '与其它整数之间具有简单直接的关系'}",,2,本节主要介绍整数理论中若干最基本的知识。我们知道，整数相加、相减、相乘的结果都是整数，而除法结果却不一定是整数。因此，整数理论研究的重点自然是运算结果相对比较复杂的除法。通过整数的除法运算可以得到整数的素因数分解，由此我们便可以素数为基本构件来考察或窥探整数的离散结构特征与变化规律。在这个过程中，素数作为构造整数的基本构件，其性质与分布规律自然是整数理论的重要内容。因此，本节内容主要包括整数与整数除法的概念、公因数与公倍数、整数的素因数分解、素数的性质及相关算法等。
素数的性质,性质,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.3 素数的性质与查找']","{'实体类型': '性质', '内容': '要么与其它整数互素，要么能够整除其它整数'}",,3,"通过算术基本定理可以看出，素数是构成所有整数的基本要素，在整个整数理论中占据非常重要的基础性地位。现在我们就来学习有关素数的基本知识，讨论素数的若干基本性质、素数的分布以及相关的查找方法。  
素数的一个非常独特性质是它与其它整数之间具有如下非常简单而直接的关系，这种简单直接的关系是使用素数考察整数性质的基础。  
【定理2.15】假设$p$ 是任意一个给定的素数，则它与其它任意整数$a$ 之间的关系是：要么$p$ 与$a$ 互素，要么$p$ 能够整除$a$。  
可以通过上述定理证明下面结论：  
【定理2.16】假设$p$ 是任意一个给定的素数，$a$ 和$b$ 是任意两个整数，如果$p$ 能整除$a$与$b$ 的乘积，则$p$ 至少能整除$a$ 与$b$ 中的一个。更一般地，假设$a_{1},a_{2},\cdots,a_{k}$是任意给出的$k$个整数，如果素数$p$ 能够整除$a_{1},a_{2},\cdots,a_{k}$，则$p$ 至少能够整除$a_{1},a_{2},\cdots,a_{k}$中的一个。  
下面讨论素数的计数问题。首先考虑在整个正整数集合中，到底有多少个素数？下面的定理给出了答案：  
【定理2.17】正整数集合中的素数有无穷多个。  
下面进一步讨论有限正整数集合中素数的计数与分布情况：  
【定理2.18】设$a$是任意大于1 的整数，则$a$除1 外的最小正因数$q$一定是素数，并且，当$a$是合数时，$q\leq{\sqrt{a}}$，亦即：若$a$ 是合数，则$a$ 必有一个小于等于$\sqrt{a}$的素因子。  
使用上述定理，可以获得一种名为爱氏筛法的素数查找方法。对于任意给定的一个正整数$N$，可以使用该方法找到所有不超过$N$的素数，具体做法如下：  
首先把所有不超过$N$的正整数按从小到大的次序排成一个队列，然后在队列中划去1以及划去一切不超过$\sqrt{N}$的素数的所有倍数，剩下的数即为所求的素数。  
由于有无穷多个素数，因此人们总是希望能够找到尽可能大的素数。300 年来人们找到的最大素数都是$2^{p}-1$这种形式的整数，其中$p$ 也是素数。我们将具有这种形式的素数称为梅森素数，目前有一个名为互联网梅森素数大搜索组织专门搜索大素数，有兴趣的读者可以查阅有关资料了解大素数查找的进展情况。"
素数的计数问题,问题,"['第二章  整数与算法设计基础', '§ 2.1 整数的基本知识', '2.1.3 素数的性质与查找']","{'实体类型': '问题', '结论': '正整数集合中的素数有无穷多个'}",,3,"通过算术基本定理可以看出，素数是构成所有整数的基本要素，在整个整数理论中占据非常重要的基础性地位。现在我们就来学习有关素数的基本知识，讨论素数的若干基本性质、素数的分布以及相关的查找方法。  
素数的一个非常独特性质是它与其它整数之间具有如下非常简单而直接的关系，这种简单直接的关系是使用素数考察整数性质的基础。  
【定理2.15】假设$p$ 是任意一个给定的素数，则它与其它任意整数$a$ 之间的关系是：要么$p$ 与$a$ 互素，要么$p$ 能够整除$a$。  
可以通过上述定理证明下面结论：  
【定理2.16】假设$p$ 是任意一个给定的素数，$a$ 和$b$ 是任意两个整数，如果$p$ 能整除$a$与$b$ 的乘积，则$p$ 至少能整除$a$ 与$b$ 中的一个。更一般地，假设$a_{1},a_{2},\cdots,a_{k}$是任意给出的$k$个整数，如果素数$p$ 能够整除$a_{1},a_{2},\cdots,a_{k}$，则$p$ 至少能够整除$a_{1},a_{2},\cdots,a_{k}$中的一个。  
下面讨论素数的计数问题。首先考虑在整个正整数集合中，到底有多少个素数？下面的定理给出了答案：  
【定理2.17】正整数集合中的素数有无穷多个。  
下面进一步讨论有限正整数集合中素数的计数与分布情况：  
【定理2.18】设$a$是任意大于1 的整数，则$a$除1 外的最小正因数$q$一定是素数，并且，当$a$是合数时，$q\leq{\sqrt{a}}$，亦即：若$a$ 是合数，则$a$ 必有一个小于等于$\sqrt{a}$的素因子。  
使用上述定理，可以获得一种名为爱氏筛法的素数查找方法。对于任意给定的一个正整数$N$，可以使用该方法找到所有不超过$N$的素数，具体做法如下：  
首先把所有不超过$N$的正整数按从小到大的次序排成一个队列，然后在队列中划去1以及划去一切不超过$\sqrt{N}$的素数的所有倍数，剩下的数即为所求的素数。  
由于有无穷多个素数，因此人们总是希望能够找到尽可能大的素数。300 年来人们找到的最大素数都是$2^{p}-1$这种形式的整数，其中$p$ 也是素数。我们将具有这种形式的素数称为梅森素数，目前有一个名为互联网梅森素数大搜索组织专门搜索大素数，有兴趣的读者可以查阅有关资料了解大素数查找的进展情况。"
红黑树,概念,"['第九章  树的基本理论与算法', '9.3.2 红黑树模型', '§ 9.3 特殊根数与算法']","{'实体类型': '概念', '相关算法': '典型特殊树模型及其基本算法', '定义': '一种自平衡二叉查找树', '特点': '在每个结点上增加一个存储位来表示结点的颜色，可以是红色或黑色', '性质': ['每个结点是红色或者是黑色', '根结点是黑色', '每个叶结点，即空结点（NIL）是黑色的', '如果一个结点是红色，那么它的两个子结点都是黑色', '对每个结点，从该结点到其所有后代叶结点的所有路径上包含相同数目的黑结点'], '应用': '设计高效的查找算法'}",,1,"树是大家非常熟悉的一类植物。通过对树的观察，不难发现自然界中的树总是有根、枝和叶，且具有这样一些特点：从根上可以长出枝来，从树杈上可以长出枝或叶，叶梢不长在一起，根、枝、叶之间总是畅通的，但它们之间不能构成圈。从结构上看，树是所有连通无向图中边数最少的图模型，同时也是所有无环无向图中边数最多的图模型。我们不得不惊叹大自然的神奇，竟然创造出如此高效而又和谐的离散结构。对自然界中树的这种特殊离散结构进行抽象，就可得到一种特殊的图模型，即树模型。在所有的图模型中，树模型是一种最简洁的连通无环结构，其中各结点之间有着最直接、最必要的联结关系。这种最简洁的连通结构决定了树在图模型知识体系中占有特别重要的地位。目前，树作为一种特殊图模型已被广泛应用于计算机各个领域，例如操作系统采用树结构来组织文件数据，编译程序采用树表示源程序的语法结构，在数据库系统中树被用来组织信息等等。  
本章主要介绍树模型基本理论及其算法设计的基本知识，首先介绍树模型的基本概念与性质、生成树与最小生成树等关于树模型的基本理论，然后具体讨论根树的概念与算法，包括树的递归遍历算法、森林与树的转换算法、最优树的构造与编码算法等，并在此基础上进一步学习若干典型特殊树模型及其基本算法，包括平衡树、红黑树、$B$树等，最后给出树模型的若干应用实例，包括决策树、博弈树等。"
红黑树删除操作,算法,"['第九章  树的基本理论与算法', '§ 9.3 特殊根数与算法', '9.3.2 红黑树模型']","{'实体类型': '算法', '步骤': ['查找要删除结点的位置', '用其后继替换该结点', '若替换结点为黑色，则需重新调整树模型使其重新成为红黑树'], '调整情况': ['结点S是红色的', '结点S及其的孩子全是黑色的', 'S是黑色的，S的左孩子是红色，右孩子是黑色', 'S是黑色的，S的右孩子是红色']}",,3,"红黑树是一种自平衡二叉查找树。与其他二叉查找树的不同，红黑树在每个结点上增加一个存储位来表示结点的颜色，可以是红色或黑色，通过自动控制红色和黑色这两种颜色的结点分布，以保证树的高度达到近似平衡，从而能够得到比较高的算法效率。  
一棵红黑树需要满足以下五条性质：（1）每个结点是红色或者是黑色；（2）根结点是黑色；（3）每个叶结点，即空结点（NIL）是黑色的；（4）如果一个结点是红色，那么它的两个子结点都是黑色；（5）对每个结点，从该结点到其所有后代叶结点的所有路径上包含相同数目的黑结点。  
其中性质（4）保证了红黑树中任何一条简单路径上不可能出现两个相邻的红色结点，因此最短路径上可能全为黑色结点，最长路径可能为相互交替的红色和黑色结点；性质（5）决定了所有最长的路径都包含相同数目的黑色结点。这两个性质表明，在红黑树中，从根到叶子的最长路径长度不大于最短的路径的两倍，这样就有效地限制了红黑树的高度。由此可以设计出高效的查找算法。  
在对红黑树进行插入和删除等操作时，可能会破坏红黑树的性质，需要及时对红黑树进行调整，以继续保持或恢复红黑树的性质。具体调整方法包括对结点重新着色，以及对树进行旋转操作，即：通过修改某些结点的颜色及指针结构，使得红黑树在插入或删除结点等操作后仍能保持其性质或平衡。下面具体介绍红黑树插入和删除操作算法。  
插入操作主要为以下3 个基本步骤：  
步骤1： 查找要插入的位置；  
步骤2： 将新结点的颜色域赋值为红色；  
步骤3： 自下而上重新调整该树为红黑树；  
在步骤1 中，查找方法与一般二叉查找树类似，不再赘述；在步骤2 中，把新结点的颜色赋值为红色的原因是：如果将其颜色赋值为黑色，将会使得从根到叶子的路径中有一条路上会出现一个额外的黑色结点，这个在后续的修改中难以调整。相反，将其赋值为红色，尽管可能会出现连续两个红色结点的情况，但是这种情况可以在后续的修改中通过旋转和颜色变换进行调整，而且比较容易。下面着重讨论步骤3 的具体实现方法：  
假设要插入的结点为𝑁，其父亲结点为𝑃，$P$的兄弟结点为𝑈。考虑以下两类情况：  
（1）如果𝑃是黑色的，那么整棵树已经是红黑树不需要再进行调整。  
（2）如果𝑃是红色的，那么插入$N$后，将与第4 条性质不符，这时需要进行旋转调整。具体的调整方法又可以分为以下3 种情况：  
![图9-34 红黑树插入操作  ](images/8bd6c0a70e2a8649a7fb851c10f9905d23db3b6c289402fd8842f4278893f2b7.jpg)  
![图9-35 红黑树插入操作-2  ](images/f808bae43e7a0570870b22efe58b1909de1a064dbbaead3d369a5aec53c4e236.jpg)  
1）如图9-34 所示，$N$的叔叔$U$是红色（图中使用阴影表示红色），将结点$P$和结点𝑈的定义为黑色并定义结点𝐺为红色。此时，插入结点𝑁的父亲结点𝑃为黑色。因为通过父结点$P$或结点$U$的任何路径都必定通过结点$G$，而在这些路径上黑色结点的数目没有改变。但是，结点$G$的父结也可能是红色的，因此需要以结点$G$向上递归调整结点颜色。  
2）如图9-35 所示，$N$的叔叔$𝑈$是黑色的，且$N$是右孩子，此时对结点$P$进行一次左旋转调换，然后按情形3）的方法处理。  
3）如图9-36 所示，$N$的叔叔𝑈是黑色的，且$N$是左孩子，此时需对结点$G$ 做一次右旋转调换，使得在变换后的树中结点$P$是新结点𝑁和结点$G$ 的父结点，然后调换之前的结点$P$和结点𝐺的颜色，使之满足第4 和第5 条性质。  
![图9-36 红黑树插入操作-3  ](images/da48b9badf77a4563a4cf7fd2e71f030801d96719268fe4da2f52d1d425a5d37.jpg)  
下面介绍红黑树的删除操作算法。  
红黑树结点删除方法和二叉搜索树的删除方法基本相同，分如下三种情况：若结点没有子女，则直接删除该结点；若结点只有一个子女，则修改它的父结点，使父结点直接连接其子结点；若结点有两个子女的话，则可以找到该结点的前驱或者后继，然后更换两个结点的值，再将前驱或者后继结点删除（由于任意一个结点的前驱或者后继都必定至多只有一个非空子结点，因而删除这样的结点就可以按照前两种情形进行处理）。  
由上分析可知，红黑树删除操作分为以下三个基本步骤：  
(1) 查找要删除结点的位置；  
(2) 用其后继替换该结点；  
(3) 若替换结点为黑色，则需重新调整树模型使其重新成为红黑树。  
其中：步骤1 中查找方法和一般二叉查找树类似，不再赘述；步骤2 使用后继结点替换被删除结点，可保证该结点以上部分仍为红黑树；在步骤3 中，若被删除结点为红色，则其父结点和孩子结点全为黑，此时可直接删除该结点，若被删除结点为黑色，则要分以下四种情况分别进行处理：  
设被删除的结点为$N$，其父结点为$𝑃$，其兄弟结点为$𝑆$。由于结点$𝑁$是黑色的，则结点$P$和$𝑆$都有可能是黑色或红色。  
（1）结点$𝑆$是红色的。此时结点$𝑃$肯定是黑色。对结点$𝑁$的父结点$P$做左旋转，然后把红色兄弟结点转换成结点$𝑁$的祖父。接着转换结点$𝑁$的父亲和祖父的颜色。接下去按 第二、第三或第四种情况来处理，如图9-37 所示。  
（2）结点$𝑆$及其的孩子全是黑色的。这种情况下，结点$𝑃$可能是黑色也可能是红色的。此时，首先把结点$𝑆$赋值为红色。然后要调整以$𝑃$作为$𝑁$递归调整树，如图9-8 所示。  
![图9-37 红黑树删除操作  ](images/b3460c71a5b1c7c1c9b4c9242d7893ecef8d9825641f105235f110c638e75690.jpg)  
![图9-38 红黑树删除操作-2  ](images/6d059b6e8bbc9c108767847f20d92206bfe3e6857f8c49ababf7c2b4c9137a93.jpg)  
（3）$𝑆$是黑色的，$𝑆$的左孩子是红色，右孩子是黑色。这种情况下，对结点$𝑆$做右旋转，这样 $S$ 的左孩子就成为 $S$ 的父亲和$𝑁$的新兄弟。这样就将问题转化到第四种情况。此时${\mathbf{}}N$和它的父结点都不受这个变换的影响，如图9-39 所示。  
（4）$𝑆$是黑色的，$𝑆$的右孩子是红色。这种情况下，对$𝑁$的父结点做左旋转，这样$𝑆$成为$𝑁$的父结点和$𝑆$右儿子父结点。接着交换$𝑁$的父结点和$𝑆$的颜色，并使$𝑆$的右儿子为黑色。此时，$N$增加了一个黑色祖先: 要么$𝑁$的父结点变成黑色，要么它是黑色而$𝑆$增加了一个黑色祖父。所以，通过$𝑁$的路径都增加了一个黑色结点，如图9-40 所示。  
![图9-39 红黑树删除操作](images/363e7f72d31896e14f6e326b2edde90d72e436cd1e992a4ca212937b247077c0.jpg)  
![图9-40 红黑树删除操作-4  ](images/8107cf243ab295d16e40201bcd4c536b2bfa28c0236bf69abebf9defaea42241.jpg)"
红黑树插入操作,算法,"['第九章  树的基本理论与算法', '§ 9.3 特殊根数与算法', '9.3.2 红黑树模型']","{'实体类型': '算法', '步骤': ['查找要插入的位置', '将新结点的颜色域赋值为红色', '自下而上重新调整该树为红黑树'], '调整方法': '对结点重新着色，以及对树进行旋转操作'}",,3,"红黑树是一种自平衡二叉查找树。与其他二叉查找树的不同，红黑树在每个结点上增加一个存储位来表示结点的颜色，可以是红色或黑色，通过自动控制红色和黑色这两种颜色的结点分布，以保证树的高度达到近似平衡，从而能够得到比较高的算法效率。  
一棵红黑树需要满足以下五条性质：（1）每个结点是红色或者是黑色；（2）根结点是黑色；（3）每个叶结点，即空结点（NIL）是黑色的；（4）如果一个结点是红色，那么它的两个子结点都是黑色；（5）对每个结点，从该结点到其所有后代叶结点的所有路径上包含相同数目的黑结点。  
其中性质（4）保证了红黑树中任何一条简单路径上不可能出现两个相邻的红色结点，因此最短路径上可能全为黑色结点，最长路径可能为相互交替的红色和黑色结点；性质（5）决定了所有最长的路径都包含相同数目的黑色结点。这两个性质表明，在红黑树中，从根到叶子的最长路径长度不大于最短的路径的两倍，这样就有效地限制了红黑树的高度。由此可以设计出高效的查找算法。  
在对红黑树进行插入和删除等操作时，可能会破坏红黑树的性质，需要及时对红黑树进行调整，以继续保持或恢复红黑树的性质。具体调整方法包括对结点重新着色，以及对树进行旋转操作，即：通过修改某些结点的颜色及指针结构，使得红黑树在插入或删除结点等操作后仍能保持其性质或平衡。下面具体介绍红黑树插入和删除操作算法。  
插入操作主要为以下3 个基本步骤：  
步骤1： 查找要插入的位置；  
步骤2： 将新结点的颜色域赋值为红色；  
步骤3： 自下而上重新调整该树为红黑树；  
在步骤1 中，查找方法与一般二叉查找树类似，不再赘述；在步骤2 中，把新结点的颜色赋值为红色的原因是：如果将其颜色赋值为黑色，将会使得从根到叶子的路径中有一条路上会出现一个额外的黑色结点，这个在后续的修改中难以调整。相反，将其赋值为红色，尽管可能会出现连续两个红色结点的情况，但是这种情况可以在后续的修改中通过旋转和颜色变换进行调整，而且比较容易。下面着重讨论步骤3 的具体实现方法：  
假设要插入的结点为𝑁，其父亲结点为𝑃，$P$的兄弟结点为𝑈。考虑以下两类情况：  
（1）如果𝑃是黑色的，那么整棵树已经是红黑树不需要再进行调整。  
（2）如果𝑃是红色的，那么插入$N$后，将与第4 条性质不符，这时需要进行旋转调整。具体的调整方法又可以分为以下3 种情况：  
![图9-34 红黑树插入操作  ](images/8bd6c0a70e2a8649a7fb851c10f9905d23db3b6c289402fd8842f4278893f2b7.jpg)  
![图9-35 红黑树插入操作-2  ](images/f808bae43e7a0570870b22efe58b1909de1a064dbbaead3d369a5aec53c4e236.jpg)  
1）如图9-34 所示，$N$的叔叔$U$是红色（图中使用阴影表示红色），将结点$P$和结点𝑈的定义为黑色并定义结点𝐺为红色。此时，插入结点𝑁的父亲结点𝑃为黑色。因为通过父结点$P$或结点$U$的任何路径都必定通过结点$G$，而在这些路径上黑色结点的数目没有改变。但是，结点$G$的父结也可能是红色的，因此需要以结点$G$向上递归调整结点颜色。  
2）如图9-35 所示，$N$的叔叔$𝑈$是黑色的，且$N$是右孩子，此时对结点$P$进行一次左旋转调换，然后按情形3）的方法处理。  
3）如图9-36 所示，$N$的叔叔𝑈是黑色的，且$N$是左孩子，此时需对结点$G$ 做一次右旋转调换，使得在变换后的树中结点$P$是新结点𝑁和结点$G$ 的父结点，然后调换之前的结点$P$和结点𝐺的颜色，使之满足第4 和第5 条性质。  
![图9-36 红黑树插入操作-3  ](images/da48b9badf77a4563a4cf7fd2e71f030801d96719268fe4da2f52d1d425a5d37.jpg)  
下面介绍红黑树的删除操作算法。  
红黑树结点删除方法和二叉搜索树的删除方法基本相同，分如下三种情况：若结点没有子女，则直接删除该结点；若结点只有一个子女，则修改它的父结点，使父结点直接连接其子结点；若结点有两个子女的话，则可以找到该结点的前驱或者后继，然后更换两个结点的值，再将前驱或者后继结点删除（由于任意一个结点的前驱或者后继都必定至多只有一个非空子结点，因而删除这样的结点就可以按照前两种情形进行处理）。  
由上分析可知，红黑树删除操作分为以下三个基本步骤：  
(1) 查找要删除结点的位置；  
(2) 用其后继替换该结点；  
(3) 若替换结点为黑色，则需重新调整树模型使其重新成为红黑树。  
其中：步骤1 中查找方法和一般二叉查找树类似，不再赘述；步骤2 使用后继结点替换被删除结点，可保证该结点以上部分仍为红黑树；在步骤3 中，若被删除结点为红色，则其父结点和孩子结点全为黑，此时可直接删除该结点，若被删除结点为黑色，则要分以下四种情况分别进行处理：  
设被删除的结点为$N$，其父结点为$𝑃$，其兄弟结点为$𝑆$。由于结点$𝑁$是黑色的，则结点$P$和$𝑆$都有可能是黑色或红色。  
（1）结点$𝑆$是红色的。此时结点$𝑃$肯定是黑色。对结点$𝑁$的父结点$P$做左旋转，然后把红色兄弟结点转换成结点$𝑁$的祖父。接着转换结点$𝑁$的父亲和祖父的颜色。接下去按 第二、第三或第四种情况来处理，如图9-37 所示。  
（2）结点$𝑆$及其的孩子全是黑色的。这种情况下，结点$𝑃$可能是黑色也可能是红色的。此时，首先把结点$𝑆$赋值为红色。然后要调整以$𝑃$作为$𝑁$递归调整树，如图9-8 所示。  
![图9-37 红黑树删除操作  ](images/b3460c71a5b1c7c1c9b4c9242d7893ecef8d9825641f105235f110c638e75690.jpg)  
![图9-38 红黑树删除操作-2  ](images/6d059b6e8bbc9c108767847f20d92206bfe3e6857f8c49ababf7c2b4c9137a93.jpg)  
（3）$𝑆$是黑色的，$𝑆$的左孩子是红色，右孩子是黑色。这种情况下，对结点$𝑆$做右旋转，这样 $S$ 的左孩子就成为 $S$ 的父亲和$𝑁$的新兄弟。这样就将问题转化到第四种情况。此时${\mathbf{}}N$和它的父结点都不受这个变换的影响，如图9-39 所示。  
（4）$𝑆$是黑色的，$𝑆$的右孩子是红色。这种情况下，对$𝑁$的父结点做左旋转，这样$𝑆$成为$𝑁$的父结点和$𝑆$右儿子父结点。接着交换$𝑁$的父结点和$𝑆$的颜色，并使$𝑆$的右儿子为黑色。此时，$N$增加了一个黑色祖先: 要么$𝑁$的父结点变成黑色，要么它是黑色而$𝑆$增加了一个黑色祖父。所以，通过$𝑁$的路径都增加了一个黑色结点，如图9-40 所示。  
![图9-39 红黑树删除操作](images/363e7f72d31896e14f6e326b2edde90d72e436cd1e992a4ca212937b247077c0.jpg)  
![图9-40 红黑树删除操作-4  ](images/8107cf243ab295d16e40201bcd4c536b2bfa28c0236bf69abebf9defaea42241.jpg)"
红黑树模型,模型,"['第九章  树的基本理论与算法', '§ 9.3 特殊根数与算法']","{'实体类型': '模型', '特点': '特殊根树模型之一'}",,2,根树是一类非常重要的树模型，能够对很多复杂的数据信息进行表示和处理，广泛应用于程序设计、数据结构、算法设计与分析、操作系统等多门后续课程。根树的种类很多，可以针对不同类型的问题或数据建立相应类型的根树模型。本节着重介绍三种最为典型的特殊根树模型，即平衡树模型、红黑树模型和𝐵树模型，并分析和讨论这些模型的插入、删除、更改、旋转等基本算法，旨在为后续相关专业课程的学习打下良好的基础。
约束变量,定义,"['第四章  谓词演算与推理', '§ 4.2  谓词公式与等值演算', '4.2.2 变量的自由与约束']","{'实体类型': '定义', '内容': '受到量词约束的命题变量，含义明确具体'}",,3,"如前所述，量词实现了对谓词中个体变量含义的约束，消除了谓词在语义上的抽象性和不确定性，对于一个$\cdot n$元谓词，如果其中每个变量都分别受到量词的约束，那么它就不再是一个命题函数而蜕化一个具体命题。因此，对于任意一个$\cdot n$元谓词，可将其中所以命题变量分为两种具体不同性质的基本类型：一种是受到量词约束的命题变量，其含义是明确具体的，不再具有自由诠释的性质；另外一种是没有受到量词约束的命题变量，是传统意义上的命题变量，其含义是泛指某个不确定的个体对象，具有自由诠释的性质。这两种变量在谓词公式及谓词演算中扮演着完全不同的角色，在具体的表示形式上必须有明确的区分。本节主要介绍具体的区分方法，首先给出量词辖域的相关概念。  
【定义4.12】假设$G(x)$是任意一个含有命题变量$x$的谓词，在公式$(\forall x)G(x)$或$(\exists x)G(x)$中，$(\forall x)$或$(\exists x)$的作用变量$x$ 在$G(x)$中存在的范围称为量词$(\forall x)$或$(\exists x)$的辖域。如果辖域不是原子谓词公式，其两侧必须有括号，否则不应有括号。  
例如：在谓词公式$\exists x(P(x,y)\rightarrow Q(x,y))\vee P(y,z)$中，$\exists x$的辖域是$(P(x,y)\to Q(x,y))$  
在谓词公式$\forall x P(x)\rightarrow Q(x)$中，$\forall x$的辖域是$P(x)$。  
一般来说，一个量词的辖域是某个谓词公式的子公式。因此，确定一个量词的辖域就是要找出位于该量词之后与之相邻接的子公式，具体方法如下：  
（1）若量词后面有括弧，则括弧内的子公式就是该量词的辖域；  
（2）若量词后面无括弧，则与该量词邻接的子公式为该量词的辖域。  
下面在量词辖域的基础上给出自由变量和约束变量的定义：  
【定义4.13】假设𝐺是任一谓词公式，$x$是𝐺的任意一个命题变量，如果$x$出现在以它为作用变量的量词辖域之内，则称$x$的出现为约束出现，称变量$x$为约束变量；如果$x$不是约束出现，则称其为自由出现，此时称$x$为自由变量。  
从上述定义不难看出，所谓约束变量，就是其含义受到量词约束的命题变量。约束变量的含义是明确具体的，不再具有自由诠释的性质。自由变量则是含义没有受到量词约束的命题变量，是传统意义上的命题变量，可以对其含义进行自由诠释。  
如果谓词公式中所有命题变量都受到量词约束，则称其为封闭公式，具体定义如下：  
【定义4.14】若谓词公式$G$ 中不含自由变量，则称该公式为封闭公式或闭式。  
例如，$(\forall x)(P(x)\rightarrow(\exists y)R(x,y))$就是一个闭式。显然，要想使得含有$n$个自由变量的谓词公式变成闭式，需要添加$|n$个量词。  
从上述例题不难看出，有时候在同一个谓词公式中同一个命题变量既可以约束出现也可以自由出现，例如对于如下谓词公式：  
$(\forall x)(P(x)\rightarrow R(x))\land(\exists y)Q(x,y)$  
该式中个体变量$\cdot x$既是约束变量又是自由变量。这很容易引起在概念理解上的歧义或混乱，需要通过一些方法对这种变量进行换名，使得同一个个体变量在同一个谓词公式中要么自由出现，要么约束出现，不能兼而有之，避免个体变量在概念理解上的歧义或混乱。下面介绍具体的个体变量改名方法。  
对于任意一个含有量词的谓词公式，以约束方式出现的个体变量到底用哪一个字母表示其实是无关紧要的。事实上，用其它任意字母表示这个约束变量都不会改变谓词公式的含义。由此可得如下约束变量的换名规则：  
（1）将量词中出现的变量以及该量词辖域中此变量的所有约束出现都替换为新的变量；  
（2）新变量名一定要有别于辖域中的所有其它变量名。  
为使一个个体变量在同一个谓词公式中只以一种方式出现，还可以使用一定的规则实现对自由变量换名。该规则称为自由变量的代入规则，具体内容如下：  
（1）将公式中出现该自由变量的每一处都用新的变量替换；  
（2）新变量不允许在原公式中以任何约束形式出现。"
约束变量换名规则,算法,"['第四章  谓词演算与推理', '§ 4.2  谓词公式与等值演算', '4.2.2 变量的自由与约束']","{'实体类型': '算法', '步骤': '将量词中出现的变量及其辖域中的所有约束出现替换为新的变量，新变量名需有别于辖域中的其他变量名'}",,3,"如前所述，量词实现了对谓词中个体变量含义的约束，消除了谓词在语义上的抽象性和不确定性，对于一个$\cdot n$元谓词，如果其中每个变量都分别受到量词的约束，那么它就不再是一个命题函数而蜕化一个具体命题。因此，对于任意一个$\cdot n$元谓词，可将其中所以命题变量分为两种具体不同性质的基本类型：一种是受到量词约束的命题变量，其含义是明确具体的，不再具有自由诠释的性质；另外一种是没有受到量词约束的命题变量，是传统意义上的命题变量，其含义是泛指某个不确定的个体对象，具有自由诠释的性质。这两种变量在谓词公式及谓词演算中扮演着完全不同的角色，在具体的表示形式上必须有明确的区分。本节主要介绍具体的区分方法，首先给出量词辖域的相关概念。  
【定义4.12】假设$G(x)$是任意一个含有命题变量$x$的谓词，在公式$(\forall x)G(x)$或$(\exists x)G(x)$中，$(\forall x)$或$(\exists x)$的作用变量$x$ 在$G(x)$中存在的范围称为量词$(\forall x)$或$(\exists x)$的辖域。如果辖域不是原子谓词公式，其两侧必须有括号，否则不应有括号。  
例如：在谓词公式$\exists x(P(x,y)\rightarrow Q(x,y))\vee P(y,z)$中，$\exists x$的辖域是$(P(x,y)\to Q(x,y))$  
在谓词公式$\forall x P(x)\rightarrow Q(x)$中，$\forall x$的辖域是$P(x)$。  
一般来说，一个量词的辖域是某个谓词公式的子公式。因此，确定一个量词的辖域就是要找出位于该量词之后与之相邻接的子公式，具体方法如下：  
（1）若量词后面有括弧，则括弧内的子公式就是该量词的辖域；  
（2）若量词后面无括弧，则与该量词邻接的子公式为该量词的辖域。  
下面在量词辖域的基础上给出自由变量和约束变量的定义：  
【定义4.13】假设𝐺是任一谓词公式，$x$是𝐺的任意一个命题变量，如果$x$出现在以它为作用变量的量词辖域之内，则称$x$的出现为约束出现，称变量$x$为约束变量；如果$x$不是约束出现，则称其为自由出现，此时称$x$为自由变量。  
从上述定义不难看出，所谓约束变量，就是其含义受到量词约束的命题变量。约束变量的含义是明确具体的，不再具有自由诠释的性质。自由变量则是含义没有受到量词约束的命题变量，是传统意义上的命题变量，可以对其含义进行自由诠释。  
如果谓词公式中所有命题变量都受到量词约束，则称其为封闭公式，具体定义如下：  
【定义4.14】若谓词公式$G$ 中不含自由变量，则称该公式为封闭公式或闭式。  
例如，$(\forall x)(P(x)\rightarrow(\exists y)R(x,y))$就是一个闭式。显然，要想使得含有$n$个自由变量的谓词公式变成闭式，需要添加$|n$个量词。  
从上述例题不难看出，有时候在同一个谓词公式中同一个命题变量既可以约束出现也可以自由出现，例如对于如下谓词公式：  
$(\forall x)(P(x)\rightarrow R(x))\land(\exists y)Q(x,y)$  
该式中个体变量$\cdot x$既是约束变量又是自由变量。这很容易引起在概念理解上的歧义或混乱，需要通过一些方法对这种变量进行换名，使得同一个个体变量在同一个谓词公式中要么自由出现，要么约束出现，不能兼而有之，避免个体变量在概念理解上的歧义或混乱。下面介绍具体的个体变量改名方法。  
对于任意一个含有量词的谓词公式，以约束方式出现的个体变量到底用哪一个字母表示其实是无关紧要的。事实上，用其它任意字母表示这个约束变量都不会改变谓词公式的含义。由此可得如下约束变量的换名规则：  
（1）将量词中出现的变量以及该量词辖域中此变量的所有约束出现都替换为新的变量；  
（2）新变量名一定要有别于辖域中的所有其它变量名。  
为使一个个体变量在同一个谓词公式中只以一种方式出现，还可以使用一定的规则实现对自由变量换名。该规则称为自由变量的代入规则，具体内容如下：  
（1）将公式中出现该自由变量的每一处都用新的变量替换；  
（2）新变量不允许在原公式中以任何约束形式出现。"
线图,概念,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.2 图的定义与分类']","{'实体类型': '概念', '定义': '非多重图'}",,3,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)"
组合分析,概念,['第一章  集合与计数基础'],"{'实体类型': '概念', '地位': '离散数学的分支之一'}",,1,离散数学以各种离散量的概念、关系、结构和运算性质为研究对象，以充分满足计算机相关学科对离散量进行表示和处理的数学需求。正如微积分支撑了作为近代工业文明基础的物理学，离散数学支撑了作为现代信息社会基础的计算机科学。事实上，离散数学是一门综合的数学学科，由多个数学分支组成，包括集合论、数理逻辑、图论、数论、组合分析、代数结构等，分别从不同角度出发研究各种离散量之间数与形的关系。本章比较系统地介绍集合论与计数的基础知识， 它们是学习各个离散数学分支所必备的入门基础。 尽管读者可能已 经从其它途径获悉其中某些概念，但是要想掌握作为支撑整个计算机学科基石的离散数学，就必须重新审视和系统地学习这些入门知识。
组合计数,概念,"['第一章  集合与计数基础', '§ 1.3 有限集的基本计数技术', '1.3.3 排列计数与组合计数']","{'实体类型': '概念', '定义': '根据从集合中选择元素的有序与无序、是否允许重复等限制条件进行计数的问题', '基本类型': '不重复的组合、可重复的组合'}",,3,排列与组合是两类比较基本的计数问题，根据从集合中选择元素的有序与无序、是否允许重复等限制条件，可将这两类问题进一步划分为四种基本类型，即不重复的排列、不重复的组合、可重复的排列和可重复的组合。
组合逻辑电路,概念,"['第三章  命题演算与推理', '§ 3.6 命题逻辑的应用', '3.6.2 组合逻辑电路设计']","{'实体类型': '概念', '组成': '由最基本的与门、或门和非门电路组成', '特点': '输出值仅依赖于其输入变量的当前值，与输入变量的过去值无关，不具记忆和存储功能'}",,3,"逻辑电路，又分为逻辑电路和时序逻辑电路。前者由最基本的“与门”、“或门”和“非门”电路组成，其输出值仅依赖于其输入变量的当前值，与输入变量的过去值无关—即不具记忆和存储功能；后者也由上述基本逻辑门电路组成，但存在反馈回路—它的输出值不仅依赖于输入变量的当前值， 也依赖于输入变量的过去值。 命题逻辑是组合逻辑电路设计的理论基础 和基本工具。如图3-10 所示，组合逻辑电路中的 “非门”、 “与门”、 “或门”，即为命题逻辑的“与”、“或”、“非”三种运算。通过利用这三种门，就可以构造出各种组合逻辑电路。  
![](images/e4f21b269b175874de7115f5156d6a3c1eb9e6666a1338dc9d4727bc0ca3ab30.jpg)
图3-10 基本类型的门  
“与门”和“或门”允许有多个输入，具有 $n$个输入的“与门”和“或门”如图3-11 所示。  
![](images/b8e3cbd2c8e7532c3d5f1acea4bd76306cd188918c6130d6354e264b174b34dc.jpg)
图3-11 具有 $n$ 个输入的门"
结合律,性质,"['第十一章  抽象代数结构通论', '§ 11.2 代数结构的运算性质', '11.2.1  二元算律']","{'实体类型': '性质', '定义': '在二元代数结构中，对于任意元素x,y,z，成立(x*y)*z=x*(y*z)', '应用': '实数加法与乘法运算、矩阵的加法与乘法运算、关系与函数的复合运算、整数集合上的模余运算、幂集合的交运算与并运算', '重要性': '定义方幂运算的基础'}",,3,"现在我们介绍和讨论二元运算律。一共有六个二元运算律，即结合律、交换律、幂等律、消去律、分配律和吸收率。其中前面四个基于单个二元运算，后面两个基于两个二元运算。下面分别讨论这些运算律，首先讨论结合律。  
结合律是大家非常熟悉也是非常重要的一个二元运算律，实数加法与乘法运算、矩阵的加法与乘法运算、关系与函数的复合运算、整数集合上的模余运算、幂集合的交运算与并运算等都满足结合律。结合律的具体定义如下：  
【定义11.5】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由$𝐴$和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$，成立$(x*y)*z=x*(y*z)$，则称$\langle A,*\rangle$的运算 $^*$ 在 𝐴 上是可结合的，或者说 $\langle A,*\rangle$ 的运算 $^*$ 在 𝐴 上满足结合律。  
对于任意给定的集合𝐴，由于𝐴上的二元运算${\ast}$满足封闭性，故对于$\forall x,y,z\in A$，有${x\ *}$$y\in A$且$y*z\in A$。因此，$(x*y)*z$和$x*(y*z)$都是有意义的算式，如果$*$满足结合律，则表达式$x*y*z$就有一个确定的计算结果，即有：  
$$
x*y*z=(x*y)*z=x*(y*z)
$$  
如果 $*$ 不满足结合律，则有可能有 $(x*y)*z\neq x*(y*z).$ 。   此时，表达式 $x*y*z$ 的含义就有歧义。因此，只有当某个运算$*$满足结合律时，才能定义其方幂运算。在后续半群与群中元素方幂的的定义中，其元素运算的结合律起着基础性的支撑作用。  
下面考察运算的交换律，首先给出交换律的定义，具体如下：  
【定义11.6】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y\in A$，成立$x*y=y*x$，则称$\langle A,\ *\rangle$的运算$^*$在𝐴上是可交换的，或者说$\langle A,\ *\rangle$的运算$^*$在𝐴上满足交换律。  
交换律表示代数结构载体集合中的任意两个元素在运算时都可以交换次序。 例如，实数加法与乘法运算、矩阵的加法、整数集合上的模余运算、幂集合的交运算与并运算等都满足交换律。 但是，矩阵的乘法运算、关系与函数的复合运算等都不满足交换律。  
【定义11.7】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，若存在某个元素$a\in A$，满足 a$*$$a=a$，则称$a$是$\langle A,\ *\rangle$的一个幂等元。 如果𝐴中的每个元素都是$\langle A,\ *\rangle$的幂等元，则称$\langle A,\ *\rangle$的运算$*$在𝐴上满足幂等律。  
从上述定义可以看出，所谓幂等元，就是该元素与其自身运算之后仍然等于其自身。例如，对于某个幂集合上的交运算和并运算，幂集合中每个元素显然都是幂等元，因此，幂集合上的交运算和并运算均满足幂等性。但是，对于整数上的加法运算，除了整数0 之外，其余整数显然都不是幂等元，因此,整数上的加法运算不满足幂等律。  
【定义11.8】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$：  
（1）若$z*y=z*x$，有$y=x$，则称运算$*$在𝐴上是可左消去的，或者说运算$∗$在𝐴上满足左消去律，并称$\cdot z$是$A$中关于运算$^*$的左可消去元；  
（2）若$y*z=x*z$，有$y=x$，则称运算$^*$在𝐴上是可右消去的，或者说运算$^*$在𝐴上满足右消去律，并称𝑧是$A$中关于运算$^*$的右可消去元。  
（3）若上述两种情况均满足，则称运算$*$在𝐴上满足消去律，并称$z$是𝐴中关于运算$*$的可消去元。  
下面介绍基于两个二元运算的运算律，即分配律和吸收律。首先给出分配律的定义：  
【定义11.9】假设𝐴是任意给定的一个非空集合，$^*$和$\Delta$均为𝐴上的二元运算，在由$𝐴$、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y,z\in A$：  
若有$x*(y\Delta z)=(x*y)\Delta(x*z)$，则称运算$*$对$\Delta$在𝐴上满足左分配律。  
若有$(y\Delta z)*x=(y*x)\Delta(z*x)$，则称运算$*$对$\Delta$在𝐴上满足右分配律。  
若运算$*$对$\Delta$在𝐴上同时满足左右分配律，则称运算$*$对$\Delta$在𝐴上满足分配律。  
例如，实数集合上的普通乘法对加法满足分配律，$M_{n}(R)$上的矩阵乘法对加法满足分配律，幂集$P(B)$上的集合交运算对并运算满足分配律，并且并运算对交运算也满足分配律。  
将上述关于集合的吸收律推广到一般运算对象和一般运算，得到一个新的运算律，即吸收律。其具体定义如下：  
【定义11.10】设𝐴是任意给定的一个非空集合，$*$和$\Delta$均为为𝐴上二元运算，在由𝐴、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y\in A$，成立：  
$$
x*(y\Delta z)=x,\;\;x\Delta(y*z)=x
$$  
则称 $*$ 和 $\Delta$ 在 A  上满足吸收律。"
结点,概念,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.2 图的定义与分类']","{'实体类型': '概念', '定义': '图中的事物对象'}",,3,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)"
结点度,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.2.2 图模型的度结构']","{'实体类型': '概念', '定义': '对于任意给定的一个图模型，只要该图不是零图，总会有一些点与一些边相互联结。对于图中的每个结点，都定义一个数来描述该结点所关联边的个数', '应用': '通过对图中每个结点所关联边数进行统计分析来考察图模型的结构特征'}",,3,"现在我们考察图模型的结构特征。从结构上看，对于任意给定的一个图模型，只要该图不是零图，总会有一些点与一些边相互联结。从生成子图的概念可以看出，图的结点构成了图模型的骨架或主体结构，因此，我们主要从结点出发考察每个结点所关联的边关联多少条边。为此，对于图中的每个结点，都定义一个数来描述该结点所关联边的个数，这就是结点度的概念，其具体定义如下：  
【定义8.16】假设图 $G=\langle V,E\rangle$是任意给定的一个无向图，对于$G$中任意一个结点 $v$ ，与该结点关联边的条数称为该结点的度数，简称为度，记为 ${\sf d e g}(v)$。图$G$中各个结点度数的最大值称为图$G$的最大度，记为$\Delta(G)$；图$G$中各个结点度数的最小值称为图$G$的最小度，记为$\delta(G)$ $\Delta(\mathrm{G})=\mathrm{max}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\};\,\,\,\delta(\mathrm{G})=\mathrm{min}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\}\,.$  
【定义8.17】设图 $G=\langle V,E\rangle$是任意给定的一个有向图，$v$是$G$中任一结点，则有：  
（1）以该结点为起点的有向边的条数，称为该结点的出度，记为$\deg^{+}(v)$；以该结点为终点的有向边的条数，称为该结点的入度，记为 $\deg^{-}(v)$。  
（2）该结点的出度与入度之和称为该结点的度，记为${\sf d e g}(v)$。 即有：  
$$
\deg(v)=\deg^{+}(v)+\deg^{-}(v)
$$  
（3）图$G$中各个结点出度与入度的最大值分别称为图$G$的最大出度和最大入度，分别记为$\Delta^{+}(\mathsf{G})$和 $\Delta^{-}(\mathsf{G})$；图$G$中各个结点出度与入度的最小值分别称为图$G$的最小出度和最小入度，分别记为$\Delta^{+}(\mathbf{G})$和 $\Delta^{-}(\mathsf{G})$，即有：  
$\Delta^{+}(\mathrm{G})=\operatorname*{max}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\Delta^{-}(\mathrm{G})=\operatorname*{max}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$ $\delta^{+}(\mathrm{G})=\operatorname*{min}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\delta^{-}(\mathrm{G})=\operatorname*{min}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$  
从上述定义可以看出，引入度结点度概念的目的主要是通过对图中每个结点所关联边数进行统计分析来考察图模型的结构特征。  
【定义8.18】对于任意一个给定的有向图或无向图  $G=\langle V,E\rangle$ ，图中度数为1 的结点称为该图的悬挂结点，图中以悬挂结点为端点的边称为该图的悬挂边。如果图$G$中各个结点的度数均相同，则称该图正则图，各结点度均为$\ k$的正则图称为$\pmb{k}$-正则图。  
下面我们考察图的邻接矩阵与图中结点度之间的关系。  
假设 $G=\langle V,E\rangle$是任意给定的一个有向图或无向图，其中$V=\{v_{1},v_{2},\ldots,v_{n}\}$，$E=$$\{e_{1},e_{2},\ldots,e_{m}\}$。 $G$的邻接矩阵为：  
$$
A=(a_{i j})_{n\times n}=\left(\!\!{\begin{array}{c c c c}{a_{11}}&{a_{12}}&{\ldots}&{a_{1n}}\\ {a_{21}}&{a_{22}}&{\ldots}&{a_{2n}}\\ {\vdots}&{\ddots}&{\vdots}\\ {a_{n1}}&{a_{n2}}&{\ldots}&{a_{n n}}\end{array}}\!\!\right)
$$  
则有如下结论：  
（1）如果$G$是无向图，那么邻接矩阵𝐴中第𝑖行元素之和表示结点$v_{i}$的度数，第𝑗列元素之和表示结点$v_{j}$的度数。即有：  
$$
\deg(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};~~~~\deg\bigl(v_{j}\bigr)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（2）若G是有向图，那么邻接矩阵$A$中第𝑖行元素之和表示结点$v_{i}$的出度，第$j$列元素之和表示结点$v_{j}$的入度。简单地说，就是竖入横出。即有：  
$$
\deg^{-}(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};\qquad\deg^{+}\!\left(v_{j}\right)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（3）对于有向图G，注意到：  
$$
\sum_{j=1}^{n}\;\deg^{-}\!\left(v_{j}\right)=\sum_{i=1}^{n}\sum_{j=1}^{n}a_{i j}=\sum_{i=1}^{n}\deg^{+}\!\left(v_{i}\right)
$$  
因此，有向图中所有入度之和等于所有出度之和，这个和其实就是图的边数$m$。因为有向图的每条边均产生且仅产生一个出度和一个入度。  
对于图8-19 所示图模型$G$及如下邻接矩阵$A_{G}$，容易验证，结点度与邻接矩阵之间的数量关系。例如，$A_{G}$中第三行元素之和为3，即$v_{3}$的出度为3。
$$
\begin{gathered}v_{1}\quad v_{2}\quad v_{3}\quad v_{4}\quad v_{5}\\A_{G}=\begin{matrix}v_{1}\\v_{2}\\v_{3}\\v_{4}\end{matrix}\begin{pmatrix}0&1&0&0&0\\0&1&1&0&0\\1&1&0&1&0\\0&0&0&0&0\\0&0&0&0&0\end{pmatrix}\end{gathered}
$$  
关于图中结点度数与边的关系，有如下著名的图论基本定理：  
【定理8.1】（握手定理）假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，则该图中结点度数的总和等于边数的二倍，即有：  
$$
\sum_{v\in V}\deg(v)=2|E|
$$  
【推论8.1】图中度数为奇数的结点个数必为偶数。  
从以上定理及例题可以看出，图模型中结点的度从一种定量的角度反映了图中结点与边之间的制约关系，在一定程度上刻画了图模型的结构特征。为了更加方便地描述图模型中各个结点的度结构信息，下面给出度序列的概念：  
【定义8.19】假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，图中每个结点的图构成的自然数序列称为$G$的度序列。也就是说，若 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，则称序列：  
$$
(\deg(v_{1})\,,\deg(v_{2})\,,\cdots,\deg(v_{n}))
$$  
为图 $G$ 的度数序列，简称为度序列。 此外，对于任意一个给定的自然数序列，如果该序列能够成为某个图的度序列，则称该序列为可图化序列。  
例如，对于图8-22 所示图 $G$ ，其度数序列为 (2,3,3,4)  
![图8-22 图 $G$ ](images/77ba680d9b589e032065b86071c3f75473dc0d06736af0deb36aa2115de43d51.jpg)  
由于图模型的度要满足握手定理等基本约束要求，而且对于不同类型的图，其度序列也会有一些相应的数据特征。因此，并不是任意的自然数序列都可以构成图模型的度序列。对于任意给定的自然数序列，需要通过分析其数据特征来判断其是否为可图化序列。若是可图化序列，则可依据该序列数据来分析其所对应图的结构特征。"
结点的删除运算,算法,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.2.1 图的基本运算', '二、图结构修改运算']","{'实体类型': '算法', '定义': '从图中删除一个或多个结点及与之关联的所有边的操作', '条件': '删除任意一个结点或若干结点组成的集合'}",,4,"对于一个给定的图模型，有时会根据实际问题的需要对图的结构进行化简或修改，主要是添加或者删除图中的某个或某些边、将图中两个结点进行合并、删除图中的某个或某些结点等，由此得到如下四个常用的图结构修改运算或操作，即：边的添加运算（也称为加新边运算）、边的删除运算、边的收缩运算以及结点的删除运算。其具体定义如下：  
【定义8.12】设图 $G=\langle V,E\rangle$是一个任意给定的图模型（有向图或无向图），则$G=\langle V,E\rangle$的四个常用图结构修改运算定义如下：  
（1）加新边运算：设$u,v$是 图$G=\langle V,E\rangle$的任意两个结点，即 $u,v\in V$，将这两个结点构成的边$e$边添加到图 $G$ 的边集$E$中构成一个新图$G^{\prime}=\langle V,E\cup\{e\}\rangle$。  
（2）边的删除运算：设$e$是图$G=\langle V,E\rangle$的任意一条边，即 $e\in E$ ，从 $G$ 中删除边 $e$ 得到一个新图$G^{\prime}=\langle V,E-\{e\}\rangle$，记为 $G-e$ ；又$E^{\prime}$是图$G$中若干边组成的集合，即$E^{\prime}\subseteq E$从 $G$ 中删除 $\mathrm{E^{\prime}}$中所有边得到一个新图$G^{\prime}=\langle V,E-E^{\prime}\rangle$，记为 $G-E^{\prime}$ 。  
（3）边的收缩运算：设$.e$是图$G=\langle V,E\rangle$的任意一条边且该边关联的两个结点为$u,v$，从图中删除边$e$并将该边的两个端点$u,v$合并成一个新的结点$w$，使得结点$w$关联除$e$以外的$u$和$v$所关联的一切边，得到一个新图$G^{\prime}$，记为$G\backslash{\mathbf{e}}$  
（4）结点的删除运算：设$_v$是 图$G=\langle V,E\rangle$的任意一个结点，即 $v\in V$，从 $G$ 中删除 $v$及与𝑣相关联的所有边，得到一个新图$G^{\prime}$，记为 $G-v$，又设 $V^{\prime}\subseteq V$ ，从 $G$ 中删除 $V^{\prime}$中所有顶点及与这些顶点关联的所有边，得到一个新图$G^{\prime}$，记为 $G-V^{\prime}$。  
从上述定义可以看出，要删除边，则直接在图中将改变去掉即可；要删除结点，在去掉该结点的同时，还要去掉该结点关联的所有边；边的收缩实际上就是将改变的长度变为0，使其两个端点重叠，用一个新的结点𝑤代替，其它边不变，即$w$关联该边的两个端点关联的除该边外的一切边，不过，需要注意的是，边的收缩可能会产生自环或平行边；所谓加新边运算，就是在图中的两个结点之间直接拉一条边。"
结点的近似遍历算法,算法,['第十章  特殊图模型与算法'],"{'实体类型': '算法', '应用': '哈密顿图中的基本算法'}",,1,"如前所述，图模型及其理论是数学家欧拉为解决哥尼斯堡七桥遍历问题而创立。事实上，图模型作为一种由结点和边组成的离散结构是一种非常强大的离散建模工具，除了能够解决哥尼斯堡七桥遍历问题之外，还可解决很多其它实际问题。例如，旅游的路径规划问题、资源分配与匹配问题、图的着色与并行流程的设计问题、最小费用流问题等等。针对不同的问题，通常需要设计出特定的图模型进行建模与求解。例如，解决哥尼斯堡七桥遍历问题需要使用欧拉图及相关理论、解决旅游的路径规划问题需要哈密顿图及相关理论、解决资源分配与匹配问题需要二分图及相关理论、解决图的着色与并行流程的设计问题需要平面图的相关理论、解决最小费用流问题需要网络流图的相关理论等等。由此产生很多种具有特殊结构和性质的图模型，每种特殊图模型都能针对性地有效地解决某一类或某几类特定问题。因此，要想高效合理地使用图模型实现对实际问题的建模与求解，除了掌握前述图模型的一般理论及算法之外，还需要进一步掌握多种特殊图模型的相关理论及算法。  
本章介绍几种重要的特殊图模型及相关算法，包括欧拉图模型的基本理论及边的遍历算法、哈密顿图的基本理论及结点的近似遍历算法、二分图模型的基本理论及匈牙利匹配构造算法、平面图的基本理论及着色算法、网络流图的基本理论及最大流算法，并结合具体实例分析和讨论这些特殊图模型的应用方法。"
结点着色算法,算法,"['§ 10.2 二分图与匹配问题', '三、结点着色算法', '10.3.3 着色问题与算法', '第十章  特殊图模型与算法']","{'实体类型': '算法', '定义': '用于解决图的结点着色问题的算法', '特点': '将图的边着色和面着色问题转化为结点着色问题', '应用': '解决图的边着色和面着色问题', 'name': '结点着色算法'}",,3,图的着色问题起源对平面图（地图）四色猜想，即至多用四种不同颜色给地图着色，就可使相互接壤的国家通过不同的颜色进行区分。四色猜想虽然针对平面图的面着色，但图的着色问题并不局限于平面图。事实上，对于一般的非平面图，可以研究其结点着色和边着色问题，对于平面图，可以研究结点着色、边着色和面着色问题。由于边着色和面着色问题可以通过适当方式转化为结点着色问题，故一般仅讨论结点着色算法。本节讨论图的着色问题与算法，主要包括点着色与边着色、面着色与五色定理、结点着色算法。
维津定理,定理,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.3.3 着色问题与算法', '一、点着色与边着色']","{'实体类型': '定理', '结论': ""设G=⟨V,E⟩是任意给定的一个无向图，则有：(1)若图G是简单图，图中结点最大度为Δ(G)，则χ'(G)=Δ(G)或Δ(G)+1；(2)若图G是二分图，图中结点最大度为Δ(G)，则χ'(G)=Δ(G)；(3)对于完全图Kn，若n(n≠1)为奇数，χ'(Kn)=n；若n为偶数，χ'(Kn)=n-1""}",,4,"首先考察一个实例，我们通常在同一台冰箱内存放不同种类的食物，其中有些食品必须分别保存在不同冰箱隔间以免串味或污染。例如，苹果和鸡蛋应该分开存放、腊肉和蔬菜应该分开存放等等。现有$A,B,C,D,E,F$六种食品，若要求$𝐴$与$𝐵$、$𝐴$与$C$、$𝐴$与$𝐷$、$B$与$C$、$C$与$D$、$C$与$F$、$D$与$E$、$E$与$F$不能放在一起，则至少需要几个隔间才能存放这些食物。  
![图10-56 冰箱中食物存放问题  ](images/557fa53c5bf02920ef35e88225888a1b53ecb35568cc495b689ec5f32f0de05e.jpg)  
可用一个无向图模型表示上述问题，图的每个结点分别代表一种食物，如果两种食物不能放在一起，则在这两种食物之间画一条无向边，如图10-55（a）所示。可通过对该图的结进行着色的方法实现对上述问题的求解。具体地说，就是对图中每个结点分别涂上或者标注一种颜色，并满足相邻的结点之间具有不同的颜色，将相同颜色结点所代表的食物放在同一个隔间，则所需要的最少颜色数目显然就是所求的冰箱隔间数目。  
不难知道，最少需要三种颜色才能实现对图10-55（a）所示无向图全部结点的着色，图10-55（b）表示其中一种着色方案。  
事实上，如果将上述六种食物分别看成是某个工程中的六项不同的任务，将不能存放在同一个隔间的两种食物理解为不能同时执行的两个任务，则可按照图10-55（b）所示的结点着色方案将这些任务以同色为标准分成3 个并行执行的任务集合。因此，无向图的着色理论与方法在并行计算与任务规划等领域具有非常重要的作用。  
对于一个比较复杂的无向图，要实现对该图所有结点的着色，在很多情况下不是一件很显然的事情。下面具体考察点着色问题，首先给出结点着色的定义，具体如下：  
【定义10.11】设$G=\langle V,E\rangle$是任意给定的一个无向图，如果对图𝐺的每个结点都涂上或标注一种颜色，并满足相邻的两个点具有不同的颜色，则称这种操作是对图$G$的结点着色，简称为对图𝐺的点着色。如果这些颜色选自于一个有𝑘种颜色的集合而不管$k$种颜色是否都用到，则称这样的点作色为称为𝒌着色，并称𝐺是${k}$-可着色的。若𝐺是$k{-}$可着色的，但不是$(k-$$1)-$可着色的，则称𝐺是一个${k}$-色图，并称$k$为图𝐺的点色数或色数，记为$𝜒(𝐺)$。  
![](images/53a26dc56eb7520c616c57e24f7d17f1e7686d610feaf89b55e20658f6ec1e28.jpg)  
例如，对于图10-55（a）所示无向图，该图就是一个3-色图，其射数$\chi(G)=3$。再如，图56（a）所示完全图$K_{5}$是一个5-色图；图56（b）所示完全二分图$K_{3,4}$是一个2-色图；图56（c）所示回路$C_{6}$是一个2-色图；图56（d）所示回路$C_{5}$为一个3-色图。  
通过上述例题不难看出，对于$G$的任何子图$H$，均有$\chi(H)\leq\chi(G)$，若$G$是$n$阶完全图，则$\chi(G)=n$；若$G$是至少有一边的二分图，则$\chi(G)=2$；若$G$是长为奇数的圈，则$\chi(G)=3$。一般地，关于无向图$G$的点色数，有如下定理：  
【定理10.19】设$G=\langle V,E\rangle$是任意给定的一个无向图，则有：  
（1）$\chi(G)=1$当且仅当$G$为零图。  
（2）对于完全图$K_{n}$：$\chi(K_{n})=n$。  
（3）$G$是一条回路：则若$|V|$是偶数，$\chi(G)=2$；若$|V|$是奇数，$\chi(G)=3$（4）$G$是一棵非平凡树，则$\chi(G)=2$。  
（5）$\chi(G)=2$的充要条件是：（a）$|E|\ge1$；（b）$G$为二分图。  
（6）对于任意无向线图$G$，若其结点的最大度为$\Delta(G)$  
$$
\chi(G)\leq\Delta(G)+1
$$  
【定理10.20】（布鲁克斯定理）设$G$是一个连通简单图，其结点的最大度为$\Delta(G)$。如果$G$既不是完全图，也不是长度奇数的基本回路，则$\chi(G)\leq\Delta(G)$。  
我们知道，任意一个不是零图的无向图都是由结点和边这两个要素构成，既然可对结点进行着色，自然也可对边进行着色。由此得到如下边着色的相关定义：  
【定义10.12】设$G=\langle V,E\rangle$是任意给定的一个无向图，如果对图$G$的每条边都涂上或标注一种颜色，并满足相邻的两条边具有不同的颜色，则称这种操作是对图$G$的边着色。如果这些颜色选自于一个有$k$种颜色的集合而不管$k$种颜色是否都用到，则称这样的边作色为称为𝒌边着色，并称$G$是$\pmb{k}$-边可着色的。若$G$是$k^{-}$边可着色的，但不是$\,(k-1)$-边可着色的，则称$G$是一个$\pmb{k}$-边色图，并称$k$为图$G$的边色数，记为$\chi^{\prime}(G)$。  
关于边色数的问题, 可以说目前已得到较好的解决。乌克兰数学家维津在1964 年提出的维津定理给出一个比较满意答案，具体如下：  
【定理10.21】（维津定理）设$G=\langle V,E\rangle$是任意给定的一个无向图，则有：  
（1）若图$G$是简单图，图中结点最大度为$\Delta(G)$，则$\chi^{\prime}(G)=\Delta(G)$或$\Delta(G)+1$；  
（2）若图$G$是二分图，图中结点最大度为$\Delta(G)$，则$\chi^{\prime}(G)=\Delta(G)$；  
（3）对于完全图$K_{n}$，若$n(n\neq1)$为奇数，$\chi^{\prime}(K_{n})=n$；若$_{n}$为偶数，$\chi^{\prime}(K_{n})=n-1$"
缓冲时间,概念,"['第八章  图的基本理论与算法', '§ 8.5 图模型的应用', '8.5.2 作业规划问题']","{'实体类型': '概念', '定义': 'τi-πi，用于判断顶点vi是否为关键路径上的顶点', '特点': '在关键路径上，各顶点的缓冲时间均为0'}",,3,"生活中有着多种多样的工程，而每一项工程往往都是由多种不同的活动相互组合而成，这些活动中，有的可以并行执行，而有的活动却必须要等到前面的准备活动都做好之后才能开始进行。例如，在一个软件开发项目中，包括以下几个阶段：需求分析，系统设计，模块代码编写，单元测试，软件维护。其中代码编写和单元测试可以同时进行，但是代码编写却一定要在需求分析和系统设计完成之后才行，需求分析和系统设计构成了代码编写的准备工作。既然存在这样的现象，那么在一项很复杂的工程中，如何合理的安排活动的进行，能够使得整个工程完成时间最早呢？其实，这就是关键路径问题。在求解关键路径问题之前，我们有必要先了解下PERT 图的相关概念。  
PERT 图是一个有向连通图$G=\langle V,E\rangle$，且  
（1）每条边表示一个作业（工序），边的非负实数权表示完成该作业所需的时间；  
（2）每个顶点表示以该顶点为起点的作业开始，也表示以该顶点为终点的作业结束；  
（3）作业开始条件：某条有向边$e=\langle v,u\rangle$所代表的作业可以开始 当且仅当 以v为终点的有向边所代表的作业全部完成；  
（4）G没有有向回路，也没有环；  
（5）G中有且仅有一个顶点的入度为0，称该顶点为源点；同时G中有且禁言一个顶点的出度为0，称该顶点为汇点。  
对于给定的PERT 图$G=\langle V,E\rangle$，我们主要关心其关键路径，以及每个作业的最早开始时间和最晚开始时间。关于PERT 图，有如下定义：  
（1）关键路径：G中从源点到汇点最长带权路径路径称为关键路径。关键路径的长度T为完成整个任务（即包括所有作业）所必需的最少时间。  
（2）关键作业：关键路径上的边所代表的作业称为关键作业。  
（3）最早启动时间：对于某个作业${e}=\left<v_{i},-\right>$，源点到该作业起点$v_{i}$的最长路径长度$\pi_{i}$称为该作业的最早启动时间。  
（4）最晚启动时间：设$v_{i}$到汇点${v}_{n}$的最长路径长度为$\pi_{i}^{\prime}$，则该作业可最晚于$\mathsf{\Delta}\mathsf{T}_{i}=\mathsf{T}-$$\uppi_{i}^{\prime}$时间启动而不影响整个任务完成的预期时间T，$\uptau_{i}$称为该作业的最晚启动时间。  
显然，作业${e}=\langle v_{i},-\rangle$是关键作业当且仅当$\pi_{i}=\uptau_{i}$，因为这时e是处于源点到汇点最长带权路径上。故可通过求每个作业的最早启动时间和最晚启动时间而得到PERT 图的关键路径。那么如何求解作业的最早启动时间和最晚启动时间呢？下面给出了求解方法：  
设PERT 图$G=\langle V,E\rangle$的顶点编号$v_{1},v_{2},\dots,v_{n}$，使得边$e=\langle v_{i},v_{j}\rangle\in E$蕴含$i<j$  
令$\pi_{1}=0$，$\pi_{j}=m a x\{\pi_{m}+w(v_{m},v_{j})|1\leq m<j\}$，则$\pi_{i}(1\leq i\leq n)$是作业$e=\langle v_{i},v_{j}\rangle$的最早启动时间。这里$w(v_{m},v_{j})$定义为：  
$w(v_m,v_j)=\begin{cases}\text{边}\langle v_m,v_j\rangle\text{的非负实数权,~~~~~~~~若}\langle v_m,v_j\rangle\in E;\\-\infty,&\text{否则}\end{cases}\text{(8-18)}$  
令$\tau_{n}=\pi_{n}$，$\tau_{k}=m a x\{\tau_{k},\tau_{k}-w(v_{k},v_{m})|k<m\leq n\}$，则$\tau_{i}(1\leq i\leq n)$是作业$e=$$\langle v_{i},v_{j}\rangle$的最晚启动时间。  
由于某顶点的最早启动时间（最晚启动时间）就是所有以该顶点为起点的作业的最早启动时间（最晚启动时间）。因此求解关键路径，可以通过计算每个顶点的最早启动时间和最晚启动时间来确定。  
另外，为了更方便的判断顶点$v_{i}$是否为关键路径上的顶点，在此定义$v_{i}$的缓冲时间$S_{i}=$$\tau_{i}-\pi_{i}$。在关键路径上，各顶点的缓冲时间𝑆均为0，任何关键作业如果耽误了时间𝑡，整个工程就耽误了时间𝑡。下面给出求解关键路径的具体例子。"
网络切割,概念,"['第十章  特殊图模型与算法', '§ 10.4 网络流图及其优化问题']","{'实体类型': '概念', '介绍': '网络流图的基本概念之一', '属性': '具有基本性质'}",,2,对交通运输、网络通信和管道运输等实际问题的建模，不仅需要图模型，而且不可避免地涉及到车流、水流、人流、信息流等流的概念与计算。将图模型与流进行整合，就形成了一个新的数学模型——网络流模型。该模型是一种有向带权图，要求每条边都有一定容量限制，边的流量数不能超过其容量，而且除源点和汇点外，每道流进入某结点的流量数必须等于离开该结点的流量数。目前，随着增益流、多终端流、多商品流以及各种网络流的出现，网络流模型及算法已普遍应用到通讯、运输、电力、工程规划、任务分派、设备更新等诸多领域。本节介绍网络流图的基本概念及算法，主要包括流网络的基本概念、网络切割的基本概念与性质、网络最大流求解算法。
网络最大流求解算法,算法,"['第十章  特殊图模型与算法', '§ 10.4 网络流图及其优化问题']","{'实体类型': '算法', '介绍': '用于求解网络最大流的算法'}",,2,对交通运输、网络通信和管道运输等实际问题的建模，不仅需要图模型，而且不可避免地涉及到车流、水流、人流、信息流等流的概念与计算。将图模型与流进行整合，就形成了一个新的数学模型——网络流模型。该模型是一种有向带权图，要求每条边都有一定容量限制，边的流量数不能超过其容量，而且除源点和汇点外，每道流进入某结点的流量数必须等于离开该结点的流量数。目前，随着增益流、多终端流、多商品流以及各种网络流的出现，网络流模型及算法已普遍应用到通讯、运输、电力、工程规划、任务分派、设备更新等诸多领域。本节介绍网络流图的基本概念及算法，主要包括流网络的基本概念、网络切割的基本概念与性质、网络最大流求解算法。
网络流图,概念,"['10.5.3 稳定婚配问题', '第十章  特殊图模型与算法', '10.5.1 鼓轮设计问题', '10.4.3 最大流求解算法', '10.5.3 最优路线问题', '§ 10.4 网络流图及其优化问题']","{'实体类型': '概念', '应用': ['解决最小费用流问题', '解决在一定约束条件下，网络中流的总量最大化问题'], '相关理论': '网络流图的相关理论', '定义': ['用于解决最大网络流问题的图模型', '用于表示网络中流量分布和优化问题的图模型'], 'name': '网络流图'}",,1,"如前所述，图模型及其理论是数学家欧拉为解决哥尼斯堡七桥遍历问题而创立。事实上，图模型作为一种由结点和边组成的离散结构是一种非常强大的离散建模工具，除了能够解决哥尼斯堡七桥遍历问题之外，还可解决很多其它实际问题。例如，旅游的路径规划问题、资源分配与匹配问题、图的着色与并行流程的设计问题、最小费用流问题等等。针对不同的问题，通常需要设计出特定的图模型进行建模与求解。例如，解决哥尼斯堡七桥遍历问题需要使用欧拉图及相关理论、解决旅游的路径规划问题需要哈密顿图及相关理论、解决资源分配与匹配问题需要二分图及相关理论、解决图的着色与并行流程的设计问题需要平面图的相关理论、解决最小费用流问题需要网络流图的相关理论等等。由此产生很多种具有特殊结构和性质的图模型，每种特殊图模型都能针对性地有效地解决某一类或某几类特定问题。因此，要想高效合理地使用图模型实现对实际问题的建模与求解，除了掌握前述图模型的一般理论及算法之外，还需要进一步掌握多种特殊图模型的相关理论及算法。  
本章介绍几种重要的特殊图模型及相关算法，包括欧拉图模型的基本理论及边的遍历算法、哈密顿图的基本理论及结点的近似遍历算法、二分图模型的基本理论及匈牙利匹配构造算法、平面图的基本理论及着色算法、网络流图的基本理论及最大流算法，并结合具体实例分析和讨论这些特殊图模型的应用方法。"
网络流模型,概念,"['第十章  特殊图模型与算法', '§ 10.4 网络流图及其优化问题']","{'实体类型': '概念', '定义': '将图模型与流进行整合形成的数学模型', '特点': '有向带权图，每条边有容量限制，流量数不能超过容量，除源点和汇点外，流入某结点的流量数等于流出该结点的流量数', '应用': '通讯、运输、电力、工程规划、任务分派、设备更新等领域'}",,2,对交通运输、网络通信和管道运输等实际问题的建模，不仅需要图模型，而且不可避免地涉及到车流、水流、人流、信息流等流的概念与计算。将图模型与流进行整合，就形成了一个新的数学模型——网络流模型。该模型是一种有向带权图，要求每条边都有一定容量限制，边的流量数不能超过其容量，而且除源点和汇点外，每道流进入某结点的流量数必须等于离开该结点的流量数。目前，随着增益流、多终端流、多商品流以及各种网络流的出现，网络流模型及算法已普遍应用到通讯、运输、电力、工程规划、任务分派、设备更新等诸多领域。本节介绍网络流图的基本概念及算法，主要包括流网络的基本概念、网络切割的基本概念与性质、网络最大流求解算法。
罗素悖论,性质,"['第一章  集合与计数基础', '§ 1.1 集合的基本知识', '1.1.2 集合的概念与表示', '一、集合与元素的概念']","{'实体类型': '性质', '产生原因': '集合的定义不受限制', '解决方法': '公理化集合论限制集合成为它自己的元素'}",,4,"我们知道，如果要定义一个概念，必须要使用其它概念。例如，在“边长相等的三角形是等边三角形”这个定义中，就要用到边长、相等、三角形等概念。而要定义其它概念就必须使用另外其它的概念，而且不能循环使用。如此下去，必然会存在一些最原始的概念作为一切概念的出发点，只能使用这些原始概念来定义其它概念而不能用其它概念来定义这些原始概念。也就是说，这些原始概念的含义是不言自明的，只能通过其它的概念去理解或解释其含义，而不能对其下严格的定义。例如，几何学中的点、线、面的概念就是原始概念，我们都知道这些概念的具体含义，但它们是没有定义的。  
集合就是这样一种没有定义的原始概念，我们可对其含义进行如下描述或理解：  
所谓集合，就是在指定范围内满足给定条件、能相互区分的所有对象构成的总体，集合中每个对象称为该集合的元素。  
（1） 硬币有两面——正面和反面，“正面、反面”构成一集合。（2） 计算机内存的全体单元构成一集合。 （3） 所有三角形构成的三角形集合。 （4） 所有正整数的集合。  
根据集合概念的上述解释，不难看出元素与集合之间的归属关系是明确的：对于任意一个集合和任意一个对象，该对象要么属于这个集合，要么不属于这个集合，两者必居其一且仅居其一。除此之外，还可看出集合中每个元素必须满足如下三条基本性质：  
1。互异性：集合中的每个元素都是互不相同的，凡是相同的元素都视为同一元素。例如集合{5, 5, 6}应该理解为$\{5,\,6\}$。  
2。可分性：集合中的每个元素都是可以明确加以区分的对象。3。无序性：集合中的元素之间是没有次序的。例如：{5, 6}和{6, 5}应视为同一集合。  
通常用带下标或不带下标的大写英文字母$A$，$B$，$C$，…表示集合，用带下标或不带下标的小写英文字母$x$，y，$z$，…表示集合中的对象或元素。  
【定义1.1】对于任意一个对象$x$ 和任意一个集合𝐴，当对象$x$ 是集合$\cdot A$中元素时，称$x$属于𝑨，记为$x\in A$；当对象$x$ 不是集合$A$ 中元素时，称$_x$ 不属于$A$，记为$x\notin A$。  
罗素悖论产生的原因是集合的定义不受限制。经过研究发现如果允许将集合作为其自身的元素，则会产生一些矛盾或悖论.因此，德国数学家康托之后创立的许多公理化集合论都直接或间接地限制集合成为它自己的元素，有效避免了罗素悖论。"
置换函数,特殊函数,"['7.4.3  置换的轮换分解', '§ 7.4 有限集的置换函数', '7.4.1  置换函数的概念', '第七章 函数与特殊函数', '7.4.2 置换函数的运算']","{'实体类型': ['特殊函数', '概念'], '特点': ['用于数据的置换操作', '表示有限集合上元素的全排列', '关于函数的求逆运算和复合运算在置换中完全适用', '置换数目的增长速度为排列元素数目的阶乘'], '定义': ['设A是一个有限集合，从A到A的双射函数称为A上的一个置换函数，简称为置换或排列', '一种特殊的双射函数', '对有限集合上的元素进行重新排列的函数'], '记法': 'P: A → A', '阶': 'A的基数n称为置换的阶', '性质': 'F_A = {f | f是A中的置换}', '逆运算': '将置换的上下两排元素进行颠倒排放，按第一个元素的升序排列', '复合运算': '与一般函数的复合运算本质相同，但表达形式上有所差异，运算次序相反'}",,1,函数是一个在自然科学、工程技术，甚至在某些社会科学中被广泛应用的数学概念，无论在初等数学还是高等数学中，无论在基础课还是专业课中，大家都会经常与函数打交道，以函数为基本工具解决各种各样的数学问题和专业问题。然而，从严格意义角度给函数下个定义并不是一件容易的事情。有人会说，函数不就是一个集合到另外一个集合的映射吗？或者说，函数就是对于某个集合中的任一元素，在另外一个集合中存在唯一元素与之对应。这不就是函数的定义？如果函数是这样定义的话，那么映射或对应又怎么定义呢？这正是函数定义的困难所在。事实上，自函数概念首次被德国数学家被莱布尼茨提出以来，其定义一直没有得到很好地解决，因为没有人能够准确地回答什么叫映射或者对应。直到在集合论和关系理论出现后，人们才以关系理论为工具完美地解决了函数的定义。具体地说，函数就是一种满足单值性要求的特殊二元关系。通过关系模型定义函数，就用关系模型的特性来诠释映射或对应概念的含义。作为关系模型的一个具体应用，本章将从特殊关系的角度来介绍函数的基本知识及其应用，包括函数的基本概念、函数的基本运算，以及若干重要的特殊函数，例如特征函数、散列函数和置换函数等。
置换函数乘积运算,定义,"['第七章 函数与特殊函数', '§ 7.4 有限集的置换函数', '7.4.2 置换函数的运算']","{'实体类型': '定义', '定义': '设A的任意两个n阶置换函数π和τ，其乘积π·τ定义为π(τ(a_1))到π(τ(a_n))的排列', '特点': '与复合运算没有本质区别，表达形式上有所差异，运算次序相反'}",,3,"置换是一种特殊的双射函数，关于函数的求逆运算和复合运算在置换中完全适用。因此，可直接将一般函数的逆运算和复合运算作为置换函数的逆运算和复合运算。  
从上例子可知，集合$𝐴$中置换函数的逆运算和复合运算结果还是$𝐴$的一个置换。从排列的角度看，置换函数的逆运算其实就是将置换的上下两排元素进行颠倒排放，即将下面一排移到上面，同时将上面一排移到下面，然后将数对按第一个元素（上面元素）的升序排列。  
虽然可以直接将一般函数的复合运算作为置换函数的复合运算，但是从排列的角度看，直接使用置换函数的复合运算会对排列的分析带来一些不便。为此，我们对置换函数的复合运算规则稍加调整，得到如下置换函数乘积运算的概念：  
【定义7.13】设$A=\{a_{1},a_{2},\cdots,a_{n}\}$的任意两个$n$阶置换函数$\pi$和$\tau$ ：  
$\begin{gathered}\pi=\begin{pmatrix}a_1&a_2&a_3&\cdots&a_n\\\pi(a_1)&\pi(a_2)&\pi(a_3)&\cdots&\pi(a_n)\end{pmatrix}\\\tau=\begin{pmatrix}a_1&a_2&a_3&\cdots&a_n\\\tau(a_1)&\tau(a_2)&\tau(a_3)&\cdots&\tau(a_n)\end{pmatrix}\end{gathered}$  
则$\pi$和$\tau$的乘积$\pi\cdot\tau$定义为：  
$\pi\cdot\tau=\begin{pmatrix}a_1&a_2&a_3&\cdots&a_n\\\pi(\tau(a_1))&\pi(\tau(a_2))&\pi(\tau(a_3))&\cdots&\pi(\tau(a_n))\end{pmatrix}\quad\text{(7-8)}$  
在不引起混淆的情况下，通常省略乘法符号，即将$\pi\cdot\tau$简写为$\pi\tau$  
从上述定义可以看出，置换函数乘积运算与复合运算之间没有本质上的区别，只是表达形式上有所差异，具体地说，就是它们之间的运算次序正好相反，即$\pi\cdot\tau=\tau\circ\pi$。"
置换群,概念,"['第十二章 典型抽象代数结构', '§ 12.2 群结构的基本知识', '12.2.3 循环群与置换群']","{'实体类型': '概念', '定义': '有限集上置换函数集合与函数复合运算构成的群', '特点': '任何一个有限群都与一个置换群同构', '应用': '在信息压缩与编码、形式语言自动机、几何变换与图形算法设计等多个领域具有重要的实用价值', '定理': ['给定集合上全体一一变换集合与变换乘法构成的二元代数结构是一个群', '任意给定的群与某个变换群同构，有限群与某个置换群同构']}",,3,"本节主要介绍两种重要的特殊群结构，即循环群和置换群。循环群是以某个元素的全部方幂载体集合的群，是目前研究最彻底的一种群。基于普通加法的整数加群$\langle Z,+\rangle$和基于模加运算的剩余类加群$\langle\underline{{n}},+_{n}\rangle$都是循环群。事实上，从同构角度看，循环群也只有$\langle Z,+\rangle$。和$\langle\underline{{n}},+_{n}\rangle$这两种不同的群。置换群则是有限集上置换函数集合与函数复合运算构成的群，是以置换函数及其运算为研究对象的群。置换群的重要性主要在于任何一个有限群都与一个置换群同构，换句话说，从同构的角度看，所有的有限群都是置换群。此外，循环群和置换群的实用性都非常强，是很多理论问题证明和求解的重要工具，在信息压缩与编码、形式语言自动机、几何变换与图形算法设计等多个领域具有重要的实用价值。  
一、循环群  
前面我们已经学过循环半群和循环含幺半群，现将其直接推广到群结构，由此得到循环群的概念，具体如下：  
【定义12.13】设$\langle G,*\rangle$是任意给定的群，若存在$a\in G$ 使得  
$$
G=\{a^{k}\big|k\in Z\}=\langle a\rangle
$$  
则称 $\langle G,*\rangle$ 为循环群，记作 $\langle\langle a\rangle_{*}\rangle$ ，并称 $a$ 是 $G$ 的生成元。此时，若 $|a|=n$ ，则称 $\langle\langle a\rangle{,*}\rangle$ 为 ${n}$ 阶 循环群，若$|a|$为无穷大，则称$\langle\langle a\rangle{,*}\rangle$为无限阶循环群。  
【定理12.15】假设$\langle G,*\rangle$是任意给定的一个循环群，则该群一定是交换群。  
【定理12.17】设$\langle G,*\rangle$是以$a$为生成元的循环群，即$G=\langle a\rangle$，则  
（1）若$G$是无限群，则$G$与整数加法群$\langle Z,+\rangle$同构；  
（2）若$G$是无限群是有限群且$|G|=n$，则$G$与$n$阶剩余类加群$\langle n,+_{n}\rangle$同构。  
二、 置换群  
在前面我们已经学习置换函数及其乘法的有关知识，现在从群的角度来考察置换函数及其乘法的运算性质。我们知道，置换函数其实就是有限集合上的的双射函数。为了能够更为一般的概念和性质，现从更为一般的角度考察双射函数，即一般集合上的双射函数及其乘法运算，由此得到如下变换及变换乘法的概念：  
【定义12.14】设$𝐴$是任意给定的一个非空集合，$A$集合上的映射$ f$：$A\rightarrow A$称为$𝐴$的一个变换。若该映射$f$是双射，则称$f$为$𝐴$上的一个一一变换。  
例如$f$：$Z\rightarrow Z$，$f(x)=x$和$g$：$Z\rightarrow Z$，$f(x)=-x$都是𝑍上的一一变换。  
【定义12.15】设$f,g$是𝐴上的变换，$f$和$g$的复合称为$f$与$g$的乘积，记作$f\circ g$  。  
不难证明，$f\circ g$也是$𝐴$上的一个变换。如果$f$和$g$都是$𝐴$上的一一变换，则乘积$f\circ g$也是$𝐴$上的一个一一变换。  
下面的定理12.18 表明：以给定集合上全体一一变换集合为载体、以变换乘法∘为运算构成的二元代数结构是一个群，由此可以从群的角度考察一一变换及其乘法运算性质。  
【定理12.18】假设$𝐴$是任意给定的一个非空集合，$E(A)$是$𝐴$上的全体一一变换构成的集合，则$E(A)$与其上一一变换的乘法运算∘构成的二元代数结构$\langle E(A),\circ\rangle$是一个群。  
【定义12.16】假设$𝐴$是任意给定的一个非空集合，$E(A)$是𝐴上的全体一一变换构成的集合，则$E(A)$与其上一一变换的乘法运算∘构成的群$\langle E(A),\circ\rangle$称为变换群，当$𝐴$是有限集合时，称变换群$\langle E(A),\circ\rangle$为对称群，对称群的任何一个子群称为置换群。  
从上述定义可以看出，变换群的载体集合$ E(A)$可以是有限集合也可以是无限集合，或者说变换群可以是有限群也可以是无限群。对称群则是一种特殊的变换群，要求变换群的载体集合必须是有限集合，因此，对称群一定是有限群。置换群则是变换群的子群，当然对称群作为其自身的平凡子群是一种特殊的置换群，但置换群不一定是对称群。因此，置换群比对称群具有更加广泛的含义，一般主要考察置换群。  
我们知道，对于任意给定的一个有限集合$𝐴$，该集合上的一一变换称为$𝐴$上的置换。当$|A|=n$时称$𝐴$上的置换为${n}$元置换。为了叙述上的方便，常将$A$记作$\{1,2,\cdots,n\}$，这样就可以将$𝐴$上的$n$元置换$p$记作：  
$$
\pi={\binom{a_{1},\ldots a_{n}}{b_{1},\ldots b_{n}}}\,,b_{i}=\sigma(a_{i}),\qquad\qquad\qquad i=1,2,\cdots,n
$$  
易见$.\pi(1)\,\,\,\pi(2)\,\,\,\,\,\cdots\pi(n)$恰恰为${1,\,,2,\cdots,n}$的一个排列。在$𝐴$上的所有置换和$𝐴$的所有排列之间存在着一一对应，$n$元集有$n!$个排列，故有${n}$!个$n$ 元置换。所有这些置换的集合记作$S_{n}$，则$\langle S_{n},\circ\rangle$就是一个对称群。  
具体地说，设$A=\{1,\!2\}$，那么$𝐴$上有两个置换：  
$$
p_1=\binom{1\quad2}{1\quad2},\quad p_2=\binom{1\quad2}{2\quad1}
$$  
当$A=\{1,\!2,\!3\}$时，$A$上有6 个置换：  
$$
\pi_1=\begin{pmatrix}1&2&3\\1&2&3\end{pmatrix},\pi_2=\begin{pmatrix}1&2&3\\2&1&3\end{pmatrix},\pi_3=\begin{pmatrix}1&2&3\\3&2&1\end{pmatrix}
$$  
$$
\pi_1=\begin{pmatrix}1&2&3\\1&3&2\end{pmatrix},\pi_2=\begin{pmatrix}1&2&3\\2&3&1\end{pmatrix},\pi_3=\begin{pmatrix}1&2&3\\3&1&2\end{pmatrix}
$$  
一般地，$A=\{a_{1},a_{2},\dots a_{n}\}$时，$A$上有$n!$个置换。如有$\pi(a_{i})=a_{j_{i}}$时，则$\pi$可表示为：  
$$
\pi={\binom{a_{1},\,\dots\,a_{n}}{a_{j_{1}},\,\dots\,a_{j_{n}}}}
$$  
置换乘法运算或者复合运算通常用∘表示，置换乘法可以像计算两个关系的合成那样进行。需要特别注意的是，置换乘法或复合运算与通常函数的复合运算次序相反。例如：  
$$
\pi_6\circ\pi_4=\begin{pmatrix}1&2&3\\3&1&2\end{pmatrix}\cdot\begin{pmatrix}1&2&3\\1&3&2\end{pmatrix}=\begin{pmatrix}1&2&3\\2&1&3\end{pmatrix}
$$  
即有：$(\pi_{6}\circ\pi_{4})(x)=\pi_{4}(\pi_{6}(x))$  。  
下面考察置换群的几何意义，首先考察三元对称群：  
设$A=\{1,\!2,\!3\}$，则$A$上的6 个置换$S_{3}=\{\pi_{1},\pi_{2},\pi_{3},\pi_{4},\pi_{5},\pi_{6}\}$关于其乘法运算∘构成一个群$\langle S_{3},\circ\rangle$，并称之为三次对称群。其中$\pi_{1}$是恒等置换为群中的单位元，且有：  
$$
{p_{2}}^{-1}=p_{2};~~{p_{3}}^{-1}=p_{3};~~{p_{4}}^{-1}=p_{5};~~{p_{5}}^{-1}=p_{4};~~{p_{6}}^{-1}=p_{6}
$$  
其实，还可以从另一个角度也可得到这个群：用数字1,2,3 标记正三角形的三个顶点，如图12-3 所示。现将三角形以其中心O 为中心轴分别旋转$\sigma_{0},\sigma_{1},\sigma_{2}$（旋转$\cdot0^{\circ},120^{\circ},240^{\circ})$），或分别按直线$l_{1}l_{2}l_{3}$位对称轴进行翻转$(\sigma_{3},\sigma_{4},\sigma_{5})$，则每次旋转或翻转显然都都对应于三角形顶点数字的的一个置换，具体对应关系如下：  
$\sigma_{0}$（旋转$0^{\circ}$）        $p_1=\begin{pmatrix}1&2&3\\1&2&3\end{pmatrix};\quad\sigma_1\bigl(\text{旋转}120^\circ\bigr)\quad p_2=\bigl(\begin{matrix}1&2&3\\2&1&3\end{matrix}\bigr)$  
$\sigma_2\bigl(\text{旋转 240°}\bigr)\quad p_3=\bigl(\begin{matrix}1&2&3\\3&2&1\end{matrix}\bigr);\quad\sigma_3\bigl(\text{绕}l_3\text{翻转}\bigr)$$\quad\quad\quad p_4=\begin{pmatrix}1&2&3\\1&3&2\end{pmatrix}$  
$\sigma_4\big(\text{绕}l_2\text{翻转}\big)\quad p_5=\big(\begin{matrix}1&2&3\\2&3&1\end{matrix}\big);\quad\sigma_5\big(\text{绕}l_1\text{翻转}\big)\quad p_6=(\begin{matrix}1&2&3\\3&1&2\end{matrix})$  
不难看出：$\langle\{\sigma_{0},\sigma_{1},\sigma_{2},\sigma_{3},\sigma_{4},\sigma_{5}\},\circledast\rangle$构成一个群，其中$\circledast$表示旋转或翻转的操作的复合操作，并且与群$\langle\{\pi_{1},\pi_{2},\pi_{3},\pi_{4},\pi_{5},\pi_{6}\},\circ\rangle$同构。  
![](images/e6cbfb18c66c7d99640531f391a63f4a34c10b210258fb0a56bb479a832c31f2.jpg)  
图12-3 三角形的对称轴和对称中心  
![](images/c11de4754b3535d3b87f562740b93b202d5ef5e49fd3a0cb5d9d33538b6831cb.jpg)  
图12-4正方形的对称轴和对称中心  
下面进一步考察四元对称群的几何意义：令$A=\{1,\!2,\!3,\!4\}$，$S_{4}=\{p|p$为A 上的置换}，因此，$\langle S_{4},\circ\rangle$为四元对称群。现用数字1,2,3,4 分别标记正方形的4 个顶点，如图12-4 所示，$\sigma_{0},\sigma_{1},\sigma_{2},\sigma_{3},\sigma_{4},\sigma_{5},\sigma_{6},\sigma_{7}$分别表示正方形以其中心为中心轴进行旋转或按对称轴进行翻转，则它们分别对应与A 上的一个置换，具体如下：  
$ \sigma_0\big(\text{旋转 }0^\circ\big)\quad p_1=\begin{pmatrix}1&2&3&4\\1&2&3&4\end{pmatrix};\quad\sigma_1\big(\text{旋转 }90^\circ\big)\quad p_2=\begin{pmatrix}1&2&3&4\\2&3&4&1\end{pmatrix}$  
$\sigma_2\big(\text{旋转 180°}\big)\quad p_3=\begin{pmatrix}1&2&3&4\\3&4&1&2\end{pmatrix};\quad\sigma_3\big(\text{旋转 270°}\big)\quad p_4=(\begin{matrix}1&2&3&4\\4&1&2&3\end{matrix})$  
$\sigma_4(\text{绕}l_1\text{翻转})\quad p_5=\begin{pmatrix}1&2&3&4\\4&3&2&1\end{pmatrix};\quad\sigma_5(\text{绕}l_2\text{翻转})\quad p_6=(\begin{matrix}1&2&3&4\\1&4&3&2\end{matrix})$  
$\sigma_6(\text{绕}l_3\text{翻转})\quad p_7=\begin{pmatrix}1&2&3&4\\1&4&3&2\end{pmatrix};\quad\sigma_7(\text{绕}l_4\text{翻转})\quad p_8=(\begin{matrix}1&2&3&4\\1&4&3&2\end{matrix})$  
不难看出：$\langle\{\sigma_{0},\sigma_{1},\sigma_{2},\sigma_{3},\sigma_{4},\sigma_{5},\sigma_{6},\sigma_{7}\},\circledast\rangle$构成一个群，其中$\circledast$表示旋转或翻转的操作的复合操作，具体定义如表12-1 所示。  
表12-1 $\circledast$的运算表
![](images/0d658bbe39ea00a7b3a2683e4707c30ed3115f5772998f1ac1c9608422308ecc.jpg)  
由于$\langle\{\sigma_{0},\sigma_{1},\cdots,\sigma_{7}\},\circledast\rangle$与$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$同构，故$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$也是群，它是$\langle S_{4},\circ\rangle$的一个真子群，因为四元对称群$\langle S_{4},\circ\rangle$有24 个置换，而$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$仅有8 个置换。也就是说，群$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$是一个8 阶4 元置换群，但不是4 元对称群。  
【定理12.19】假设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$与某个变换群同构，如果$\langle G,*\rangle$是一个有限群，则$\langle G,*\rangle$与某个置换群同构。  
上述定理12.19 表明，变换群和对称群的重要性在于其作为两种具体的特殊群与一般的抽象群有着非常密切的联系。具体地说，每个群均同构于一个变换群，特别地，每个有限群均同构于一个置换群。因此，从同构的角度看，所有的群都可以看成是变换群，所有的有限群都可以看成是置换群。"
群,概念,"['§ 11.1 代数结构的基本概念', '第十二章 典型抽象代数结构', '§ 12.1 半群的概念与性质', '第十一章  抽象代数结构通论', '11.1.1 数学结构与代数结构']","{'实体类型': '概念', '定义': ['仅含一个二元运算的抽象代数结构', '在含幺半群的基础上再增加存在逆元的限制，即要求半群不仅含有单位元，而且还必须保证载体集合中每个元素都必须含有逆元'], '来源': '由伽罗瓦提出的伽罗瓦群衍生而成', '重要性': '最早发明也是最重要的抽象代数结构', '应用领域': '数字加密与编码、形式语言与自动机、组合计算与分析', '影响': '对抽象代数其它分支的研究具有非常重要的影响', '特点': '只含一个二元运算'}",,3,"代数结构作为四大基本数学结构之一，它以运算作为处理机制，在整个数学理论体系和计算机数学建模中占据非常重要的作用。代数结构是一种非常古老的数学结构，具有几千年发展历程，从最初初等代数逐步发展到大代数，然后进一步发展到抽象代数，目前正朝着泛代数的方向发展。本小节主要介绍抽象代数的由来及其基本知识结构。  
用计算机解决实际问题，一般需要对问题进行抽象并建立相应的数学模型，然后在此基础上将对实际问题的求解转化为对数学模型的求解。 因此，数学模型是用计算机解决实际问题的基础。现实问题纷繁复杂、变化万千，所建立的数学模型自然也是五花八门，多种多样，让人无所适从。值得欣慰的是，尽管我们面对的数学模型复杂多样，但从结构上看，所有这些数学模型都建立在四种基本的数学结构基础之上。  
这四种基本数学结构分别为：表示元素之间空间关系的拓扑结构，如图模型、树模型就是一些拓扑结构；表示元素之间运算关系的代数结构，如初等代数、向量代数、矩阵代数、命题代数、集合代数等都是代数结构；表示元素规模度量性质的测度结构，如高等数学里函数的微分和积分都是测度结构，它们主要计算面积、体积、弧长、速度等；表示元素之间次序关系的偏序结构，如整数的整除关系、集合的包含关系等偏序关系都是偏序结构。  
任何一个数学结构都是由载体、处理机制和处理规则这三个基本要素组成：  
（1）载体集合 对于任何一个数学结构，需要定义一些抽象的元素作为处理对象，这些抽象元素组成的集合构成数学结构的载体。载体集合是数学结构存在的基础或平台。  
（2）处理机制 为了实现对数学结构载体中元素的处理，需要定义一些处理机制，不同的数学结构具有不同的处理机制。例如：偏序结构是一种关系结构，它以元素之间的次序关系或者比较关系作为处理机制；代数结构是一种运算结构，它以元素之间的运算作为处理机制；拓扑结构是一种分布结构，它以元素之间的空间分布作为处理机制；测度结构则是一种度量结构，它以元素的规模度量作为处理机制。  
（3）处理规则 为使定义出来的数学结构满足一些合理性要求以及能够在处理实际问题中发挥作用，避免出现一些矛盾或荒诞的处理结果，还必须制定一些处理规则对处理机制做一些必要的限制。在现代数学的公理化系统中，通常称这些处理规则称为公理。不同的数学结构具有不同的处理规则，例如偏序结构限制元素之间的关系必须满足自反性、反对称性和传递性，这些限制或者性质构成了偏序结构公理系统；再如代数结构则是规定元素之间的运算必须满足结合律、交换律、分配律等运算性质。  
数学运算最早起源于算术运算，即使用具体的整数或分数进行四则运算。随着科学技术的不断发展，人们逐步意识到这种方法不能满足对一般性规律的认识。因此，采用抽象的字母来代替具体的整数和分数进行运算以获得通用性结果，并称之为代数运算或简称为代数。在微积分出现之前的数千年历史中，对代数运算的研究一直占据数学研究的核心地位。那时人们普遍信奉一种所谓的万能法则，即世界上所有问题都可以转化为数学问题，所有数学问题都可以转化为代数问题，所有代数问题都可以转化为方程问题。  
因此，在很长一段历史时期内，人们对数学的研究基本上都是对代数学的研究，对代数学的研究基本上是方程或方程组解法的研究。解方程是那个时期内所有数学家的中心任务，大家都非常期望能够通过使用代数运算的方法找到方程或方程组的通用求解公式。这种努力在线性方程组领域取得了非常完美的结果，并由初等代数逐步衍生出线性代数。但是，对于一元高次方程通用求解方法的研究并不是很顺利，对于次数高于四次的一元方程始终找不到通用求解公式或求解方法。一些非常著名的数学家，例如欧拉、高斯、拉格朗日等都对此做了大量非常艰苦的研究，但均告失败。  
在寻求五次方程通用求解方法的过程中，年仅17 岁的法国天才少年伽罗瓦在1828 年提出群的概念，运用群的思想证明了五次方程通用求解公式是不存在的，并给出了五次方程系数在满足一定条件下若干特殊解法，由此一举解决了困扰数学家长达200 多年的数学问题。伽罗瓦取得成功的关键在于不仅将运算对象进行抽象化，而且对运算本身进行抽象，在抽象对象和抽象运算的基础上通过构造一些特殊抽象代数结构进行求解。这个思想在当时实在过于超前以至于没有得到柯西、傅里叶、泊松等著名数学家的认可，泊松的判词是“完全不能理解”。 1832 年5 月31 日年仅21 岁的伽罗瓦死于决斗。在决斗之前，他把关于五次方程代数求解的研究成果写成长信，留给了人类。14 年后，法国数学家刘维尔整理并发表了伽罗瓦的遗作，人们才理解并惊叹他那超越时代的天才思想和巧妙构思。  
至此以后，人们对代数的研究内容由方程或方程组的求解技巧转变为对代数运算性质和运算结构的研究，通过对运算和运算对象进行抽象的方式实现对所有运算依其运算性质进行分类或归类，并将伽罗瓦的群论迅速发展成为一门称之为抽象代数结构的崭新数学分支。 抽象代数结构的诞生，把代数学从传统的初等代数发展到现代的抽象代数，由此打开了现代代数学的大门，开创了代数学研究的新纪元。因此，抽象代数结构通常也称为近世代数以区别于之前的初等代数。若无特别说明，我们通常将抽象代数结构简称为代数结构。  
经过一百多年的发展，抽象代数结构已经形成一个如图11-1 所示的知识体系。对于一个代数系统，我们不仅可以主动设计出它的运算并考察相应的运算规则，而且还可以通过分别对其载体集合进行相关改造或运算得到相应的子代数、积代数和商代数，可以通过映射的方式考察不同代数结构之间的区别与联系，还可根据运算性质对代数结构进行分类，形成若干典型抽象代数系统，如群、环、域、格等。  
![](images/37d476cf884c29ed65924bc021cb612de43bab4df8b1196f64e96cad4f61a01f.jpg)
图11-1 抽象代数结构的知识体系  
代数结构作为一种特殊的数学结构，具有载体、处理机制和处理规则这三个基本要素。如前所述，代数结构的载体就是由一些抽象对象为元素组成的集合，并通过运算机制实现对集合中元素的处理。所谓运算，其实就是通过映射的手段从已有元素中构造出新的元素。载体和运算统称为代数结构的成分。代数结构的处理规则即为运算性质。  
既然代数结构的载体是一个集合，那么就可以考虑通过一定方式由这个集合派生出新的集合并据此构造出新的代数结构。例如，可以考察其子集以及在子集上的运算，得到子代数的概念和性质；可以对作为载体的集合做笛卡尔集构成一个新的集合，并在新集合上定义相关运算，得到积代数的概念和性质；可以通过构造等价关系的方法实现对集合载体的划分，构成一个以等价类为元素的商集，并在这个商集上定义相关运算，得到商代数的概念和性质。子代数、积代数和商代数是构造和研究代数结构的基本方法论。  
当然，还可以考察两个代数结构之间的相似性与差异性。对于任意两个代数系统，可以在这两个代数结构的载体(集合)上建立一种保运算的映射，由此考察代数结构之间的联系。如果存在这种保运算映射，则称这两个代数系统同态。如果这种保运算的映射还是双射，则称这两个代数系统同构。同态和同构是考察代数结构之间联系的基本工具。  
依据代数结构的运算性质，可以将各种具体代数结构划分为若干抽象类型。典型的抽象代数结构类型主要有仅含一个二元运算的半群与群、含有两个二元运算的环与域，以及格与布尔代数。这些典型抽象代数结构构成代数结构知识体系的主要内容。"
群结构,概念,"['§ 12.2 群结构的基本知识', '12.2.1 群的基本概念', '第十二章 典型抽象代数结构']","{'实体类型': '概念', '提出者': '法国数学家伽罗瓦', '提出目的': '解决五次代数方程通用求根公式', '定义': ['具有运算及其逆运算的完备代数结构', '假设⟨G,*⟩是任意给定的一个二元代数结构，如果⟨G,*⟩满足如下性质：（1）结合律；（2）含单位元；（3）运算*可逆。则称⟨G,*⟩是一个群代数结构，简称为群结构或群。'], '特点': '仅含单个运算的抽象代数结构', '应用领域': '代数编码与数字通信、形式语言与自动机', '主要内容': '群的基本概念与性质、子群的概念与判定、群的同态与同构关系', '充分必要条件': '封闭性、结合律、含幺性和可逆性', '应用示例': '实数集合及其上的普通加法运算构成的代数结构⟨R,+⟩'}",,2,"群的概念最初由法国数学家伽罗瓦为解决五次代数方程通用求根公式而提出。要使用前述含幺半群结构$\langle G,*\rangle$解决代数方程求根等问题，显然必须在$\langle G,*\rangle$中进一步引入运算$*$的逆运算，也就是要求载体集合$G$中每个元素均有逆元素，使得$\langle G,*\rangle$构成一个相对完备的代数结构，这种完备的代数结构就是群结构。事实上，群结构作为一种仅含单个运算的抽象代数结构，具有一套比较完备的理论，在代数编码与数字通信、形式语言与自动机等多个领域都具有非常重要的应用价值。本节主要介绍群结构的基本知识，主要包括群的基本概念与性质、子群的概念与判定、群的同态与同构关系。"
联结词的完备集,概念,"['3.3.2 联结词的完备性', '第三章  命题演算与推理', '3.3.1  联结词的枚举', '§ 3.3 联结词的完备集']","{'实体类型': '概念', '定义': ['至少需要多少种运算联结词才能表示任意命题公式', '包含足够多的联结词以表达所有可能的命题公式的集合', '假设𝑆是一个由逻辑运算联结词组成的集合，如果对于任意一个命题公式，都有由𝑆中联结词表示出来的命题公式与之等值，则称𝑆是一个完备的联结词集合，或者说𝑆是一个联结词的完备集'], '问题': '这五个常用联结词是否可以表示任意命题公式', '特点': ['通过有限个联结词可以构造出所有命题公式', '可能存在联结词的冗余'], '应用': '方便进行命题公式演算', 'name': '联结词的完备集'}",,2,前面学习了五个常用逻辑运算联结词。细心的读者可能会想到下面两个问题：一是联结词的枚举问题，或者说除了这五个常用联结词之外，还有哪些运算联结词？二是联结词的完备集问题，亦即：这五个常用联结词是否可以表示任意命题公式，至少需要多少种运算联结词才能表示任意命题公式？本节主要考察这两个问题。
联结词的枚举,算法,"['第三章  命题演算与推理', '§ 3.3 联结词的完备集', '3.3.1  联结词的枚举']","{'实体类型': '算法', '描述': '对命题运算联结词进行计数和枚举的方法', '步骤': '将彼此等值的命题公式视为同一种类型，计算类型的数目'}",,3,"不难看出，每个运算联结词分别对应一个命题公式，且彼此不同的运算联结词所对应的命题公式也互不相同。尽管可以通过命题公式的定义构造出无穷多个形态各异的命题公式，但是这些命题公式中有很多是彼此等值的。因此，如果我们将彼此等值命题公式视为同一种类型并且能够计算出类型的数目，那么命题运算联结词的枚举问题便迎刃而解。  
对于任意一个含有$\cdot_{n}$个命题变量的命题公式，都可以将它看成是一个由这$n$个变量为自变量的𝑛元函数。显然，每个自变量的取值以及函数值的取值均为{真，假}或{0, 1}，故有如下𝑛元真值函数的相关定义：  
【定义3.17】假设𝐺是一个含有$\cdot_{n}$个命题变元的命题公式，则称𝐺是一个$\mathbfit{n}$元真值函数。在所有的$n$元真值函数中，将相互等值的真值函数归为一类，并从每个类中分别选取一个$_{n}$元真值函数作为该的类代表，称这种具有代表性质的真值函数为$\mathbfit{n}$元真值函项。  
显然，$n$元真值函数的种类数就是$n$元真值函项的个数。因此，下面着重考察如何对n 元真值函项进行计数和枚举。  
对于一元真值函数$G(P)$，它只含有一个命题变元𝑃。由于$P$只有$T$和$F$两种取值状态且对于每种状态，$G(P)$都只有$T$和$F$两种不同取值方式，由计数的乘法原理知，$G(P)$有且仅有有4 种不同的表现形式，如表3-13 所示。  
表3-13  一元真值函数
![](images/7e299ca38127d46167de49648c7ba3b93226e9a0d0de2bd6d7016fad80f5bc00.jpg)  
从表3-13 中可以看出，一元真值函数$G(P)$有且仅有4 种不同类型。由此可以得到如下全部四个不同的一元真值函项：  
$$
G_{1}(P)\Leftrightarrow T;\,\,\,G_{2}(P)\Leftrightarrow P;\,\,\,G_{3}(P)\Leftrightarrow\neg P\,;\,\,\,\,\,G_{4}(P)\Leftrightarrow F
$$  
由此可见，非平凡的一元逻辑运算联结词只有$\neg$运算，即 $G_{3}(P)=\neg P$  
下面考察二元真值函数$G(P,Q)$：由于每个命题变量分别取T和F两种状态，故$P$与$Q$的取值状态组合数为4。对于$\cdot P$与$Q$每一种组合状态，$G(P,Q)$都有$T$和$F$这两种取值状态，由计数的乘法原理知，$G(P,Q)$有且仅有有$2^{4}{=}16$ 种不同表现形式，如表3-14 所示。  
![](images/07f980b35eb2afa32c89cb472f39cdcc1aa211c2d1dac882499a493bebe3a0fa.jpg)  
从表3-14 中可以看出，二元真值函数$G(P,Q)$有且仅有16 种不同类型。由此可以得到如下全部16 个不同的二元真值函项：  
$G_{1}(P,Q)\Leftrightarrow P\land\lnot P;\,\,\,G_{2}(P,Q)\Leftrightarrow P\land Q;\,\,\,G_{3}(P,Q)\Leftrightarrow\lnot(P\to Q)\,;\quad G_{4}(P,Q)\Leftrightarrow P\,;$ $G_{5}(P,Q)\Leftrightarrow\neg(Q\to P);\;\;G_{6}(P,Q)\Leftrightarrow Q;\;\;G_{7}(P,Q)\Leftrightarrow\neg(P\leftrightarrow Q);\quad G_{8}(P,Q)\Leftrightarrow P\lor Q;$ $G_{9}(P,Q)\Leftrightarrow\neg(P\vee Q);\;\;G_{10}(P,Q)\Leftrightarrow P\leftrightarrow Q;\;\;G_{11}(P,Q)\Leftrightarrow\neg Q;\quad G_{12}(P,Q)\Leftrightarrow Q\rightarrow P$ $G_{13}(P,Q)\Leftrightarrow\neg P;\;\;G_{14}(P,Q)\Leftrightarrow P\rightarrow Q;\;\;G_{15}(P,Q)\Leftrightarrow\neg(P\wedge Q);\quad\;G_{16}(P,Q)\Leftrightarrow P\vee\neg P$  
由此可见，非平凡二元逻辑运算联结词一共有9 个，除了前面已学的5 个常用联结词$\neg，\wedge，\vee，\rightarrow，\leftrightarrow$之外，还有如下4 个新的运算联结词，即：$\overline{{\mathsf{V}}}\,,\,\nrightarrow\,\uparrow\,,\,\downarrow$。这4 种联结词的真值取值规则如表3-15 和表3-16 所示。  
表3-15  4 种新联结词的含义与表示
![](images/06836354c54edf7769126bc450a894d316d020c9711d3c09afa06457b363815b.jpg)  
表3-16  4 种新联结词的真值
![](images/731846b634a2ef84c0898fbd837a1e716d721d529b86c9bb6916ff3a66582dbc.jpg)  
由表3-15 和表3-16 真可知：  
$P\;{\overline{{\lor}}}\;Q\Leftrightarrow\neg(P\leftrightarrow Q)\colon\;P\nrightarrow Q\Leftrightarrow\neg(P\rightarrow Q)\colon\;P\uparrow Q\Leftrightarrow\neg(P\wedge Q)\colon\;P\downarrow Q\Leftrightarrow\neg(P\vee Q)$  
对于一般$_{n}$元真值函数$G(P_{1},P_{2},\cdots,P_{n})$，其$.n$个命题变量$P_{1},P_{2},\cdots,P_{n}$的取值状态组合数为$2^{n}$。对于每个取值状态的组合，$G(P_{1},P_{2},\cdots,P_{n})$均有$T$和$F$这两种取值。因此，$G(P_{1},P_{2},\cdots,P_{n})$有且仅有$2^{2^{n}}$种不同表现形式，即有且仅有$\cdot2^{2^{n}}$个$_{n}$元真值函项。例如，当$n=3$时，有且仅有$2^{8}{=}256$ 个真值函项，由此可得到所有非平凡三元逻辑运算联结词，具体不再赘述。"
自反关系,性质,"['第五章 关系模型与理论', '§ 5.3 关系的基本性质', '5.3.1 关系的自反与反自反']","{'实体类型': '性质', '定义': '设R是集合A上的关系，若对任意x属于A，都有<x,x>属于R，则称R在A上是自反关系，或称R具有自反性', '特点': '每个元素都与其自身之间具有这种关系', '结论': '如果关系R是自反的，那么该关系一定不是反自反的；关系R是自反的，当且仅当系图中每个结点都有一个自环；关系R是自反的，当且仅当其关系矩阵的主对角线上全为1'}",,3,"日常生活和工作中的很多关系，如同学关系、实数的相等关系、正整数的整除关系等，每个元素都与其自身之间具有这种关系，此时称这些关系具有自反性质。具体定义如下：  
【定义5.17】设$R$ 是集合$A$ 上的关系，若对$\forall x\in A$，都有$\langle x,x\rangle\in R$，则称$R$ 在$A$ 上是自反关系，或称$R$ 具有自反性。即：  
$(\forall x)(x\in A\to\langle x,x\rangle\in R)\Leftrightarrow R\text{为自反关系}\quad\text{(5-10)} $  
与之相反的是，对于有些关系，例如父子关系、实数的小于关系、夫妻关系等，每个元素都不可能与其自身之间具有这种关系，此时称这些关系具有反自反性质。具体定义如下：  
【定义5.18】设$R$ 是集合$A$ 上的关系，若对$\forall x\in A$，都有$\langle x,x\rangle\notin R$，则称$R$ 在$A$ 上是反自反关系，或称$R$ 具有反自反性。即：  
通过上述例题，不难得出如下结论：  
（1）如果关系$R$ 是自反的，那么该关系一定不是反自反的；关系$R$ 是反自反的，则该关系一定不是自反的。  
（2）存在既不是自反也不是反自反的关系；  
（3）关系$R$ 是自反的，当且仅当系图中每个结点都有一个自环；关系$R$ 是反自反的，当且仅当图中每个结点都没有自环；  
（4）关系$R$ 是自反的，当且仅当其关系矩阵的主对角线上全为1；关系$R$ 是反自反的，当且仅当其关系矩阵的主对角线上全为0。"
自反性,性质,"['§ 5.4 关系的性质闭包', '第六章 特殊关系模型', '第五章 关系模型与理论', '5.3.4 关系性质的判定', '§ 5.3 关系的基本性质']","{'实体类型': '性质', '定义': '关系中的每个元素都与其自身相关联', '判定条件': 'R 是自反的当且仅当 I_A 包含于 R', '重要性': '关系的重要性质', '应用场景': '在很多关系问题的求解过程中需要用到'}",,2,现实世界中的关系错综复杂、种类繁多，这给我们使用关系的数学模型表示和解决关系问题带来一定的困难。因此，为了比较方便地研究和使用关系的数学模型，本节建立考察关系特性的若干标准并将这些标准看成是关系的基本性质。对于任意给定的一个关系，就可以使用这些标准来考察或评判该关系满足或不满足这几个标准中的哪几条，换句话说，就是考察该或评判该关系具有哪些基本性质。这样就可以依据这些标准将所有的关系划分为若干类型进行分门别类的研究。关系的这些考察标准或基本性质一共有五个，即自反性、反自反性、对称性、反对称性和传递性，本节具体介绍这些基本性质的概念及判定方法。
自反闭包,概念,"['第五章 关系模型与理论', '§ 5.4 关系的性质闭包', '5.4.1  关系闭包的概念']","{'实体类型': '概念', '定义': ""若存在关系R'，满足R'是自反的，且对任何自反关系R''，若R⊆R''，则R'⊆R''，则称R'为R的自反闭包"", '构造方法': 'r(R)=R∪R^0'}",,3,"首先，我们考察关系的自反闭包。假设$R$ 是集合$A$ 上的二元关系，如果$R$ 不满足自反性，就说明集合$A$ 中存在某个元素$a.$,使得$\langle a,a\rangle\not\in R$，此时可以将关系R 进行调整或修改，避免这种情况的发生。具体地说，就是将序偶$\langle a,a\rangle$纳入到关系$R$ 由此产生一个新的关系$R^{\prime}$。一般地，如果对于$A$ 中的每个元素${x}$，都将$\langle x,x\rangle$纳入到关系$R$，由此产生新的关系$R^{\prime}$必然满足自反性。事实上，关系$R^{\prime}$是对关系$R$ 的一种扩充，使得扩充后的关系能够满足自反性。若能证明这种扩充是满足扩充目的最小扩充，则$R^{\prime}$就是关系$R$ 的自反闭包。  
可同理考察对称闭包。假设$R$ 是集合$A$ 上的二元关系，如果$R$ 不满足对称性，就说明集合$A$ 中存在两个元素$a$和$b$使得$\langle a,b\rangle\in R$，但$\langle b,a\rangle\not\in R$。此时，只需将$\langle b,a\rangle$纳入$R$ 中就可避免这种情况发生。因此，可以对$R$ 进行适当扩充构成其对称闭包。  
可类似考虑传递闭包的基本思想，不再赘述。下面给出这三个闭包的具体定义：  
【定义5.22】设$R$ 是集合$A$ 上的关系，若存在$A$ 上的另一个关系$R^{\prime}$，满足：  
（1）$R^{\prime}$是自反的（对称的、或传递的）  
（2）对$A$ 上任何自反（对称的、或传递）关系$R^{\prime\prime}$，如果$R\subseteq R^{\prime\prime}$，那么$R^{\prime}\subseteq R^{\prime\prime}$，则称${R^{\prime}}$为$R$的自反闭包（对称闭包或传递闭包），记为$r(R)(s(R)$或$t(R))$。  
下面定理给出了自反闭包和传递闭包的构造方法：  
【定理5.12】设$R$ 是非空集合$A$ 上的关系，则有：  
$r(R)=R\cup R^{0};\,\,\,s(R)=R\cup R^{-1}$  
由上述例题可得利用关系图求关系$R$ 闭包的方法：  
（1）检查$R$ 的关系图，在没有自环的结点处加上自环，可得$r(R)$的关系图；  
（2）检查$R$ 的关系图，将每条单向边全部改成双向边，可得$s(R)$的关系图；  
（3）检查$R$ 的关系图，从每个结点出发，找到其终点，如果该结点到其终点没有边相连，就加上此边，由此可得$t(R)$的关系图。"
自然数子集的最大数和最小数,定义,"['第一章  集合与计数基础', '§ 1.2 可数集与不可数集', '1.2.2 自然数的集合定义', '二、自然数的归纳定义']","{'实体类型': '定义', '最大数': '在自然数子集K中，不小于K中其它数的数', '最小数': '在自然数子集K中，没有其它数小于它的数'}",,4,"1923 年，著名数学家冯·诺依曼用集合给定义了0 和后继数的概念，并由此通过归纳的方式实现自然数和自然数集合的完美定义。  
【定义1.16】对于任意一个给定的集合$A$，称集合$\cdot A^{+}=A\cup\{A\}$为$A$ 的直接后继。  
【定义1.17】对于任意给定的集合$N$，若它满足如下两个条件，则称其为自然数集合：  
（1）基础条款：空集属于集合$N$，即有$\emptyset\in N$，并将$\emptyset$定义为自然数0； （2）归纳条款：对于任意一个集合$A$，若有$A\in N$，则必有$A^{+}=A\cup\{A\}\in N.$  
上述自然数集合的归纳定义是一种构造性定义方法，通过基础条款和归纳条款构造出自然数集的全部元素 . 基础条款决定了自然数集合为非空集合并确定了集合的初始元素，即自 然数0；归纳条款则以初始元素为出发点通过构造后继元素的方式不断产生新的元素。  
具体地说，按以上定义，自然数集合由如下形式的元素构成：  
$$
\emptyset,\ \{\emptyset\},\ \{\emptyset,\ \{\emptyset\}\},\ \{\emptyset,\ \{\emptyset\},\ \{\emptyset,\ \{\emptyset\}\},\ \{\emptyset,\ \{\emptyset\},\ \{\emptyset,\ \{\emptyset\}\}\}\},\ \cdots
$$  
根据等势的定义，$\{\emptyset\}$与所有含有1 个元素的集合等势，可以看成是这些集合的代表，令其为自然数1；同理有：$\{\varnothing,\;\;\{\varnothing\}\}$与所有含有2 个元素的集合等势，可以看成是这些集合的代表，令其为自然数2；$\{\varnothing,\;\;\{\varnothing\}$，$\{\varnothing,\;\;\{\varnothing\}\}$与所有含有3 个元素的集合等势，可以看成是这些集合的代表，令其为自然数3；$\{\emptyset,\ \{\emptyset\},\ \{\emptyset,\ \{\emptyset\}\}\}$与所有含有4 个元素的集合等势，可以看成是这些集合的代表，令其为自然数4；如此下去，便可得到所有自然数：0, 1, 2, 3, 4，…，并显然成立如下递推关系：  
$$
0\!\!=\!\!\emptyset;\;\;1\!\!=\!\!\{0\};\;\;2\!\!=\!\!\{0\,,\;\;1\};\;\;3\!\!=\!\!\{0\,,\;\;1\,,\;\;2\};\;\;4\!\!=\!\!\{0\,,\;\;1\,,\;\;2\,,\;\,3\};\;\;\cdots
$$  
一般地，有：  
$$
n=\{0\,,\ 1\,,\ 2\,,\ \dots\ \,,\ n-1\}
$$  
下述定理表明上述自然数定义满足皮亚诺公理系统的要求：【定理1.6】自然数的集合定义满足皮亚诺提出的5 条公理。  
有了自然数，便可以定义自然数集合上的各种运算、函数和特殊自然数，这里就不再一一赘述，下面仅给出自然数子集上最大数和最小数的相关定义：  
【定义1.18】如果对$x$ 作不少于一次的后继运算后得到$y$，那么称$x<y$。如果$x$在自然数子集$K$ 中，$K$ 中没有其它数小于$x$，那么称$x$ 是子集$K$ 中的最小数，如果$x$ 在自然数子集$K$ 中，$x$ 不小于$K$中其它数，那么称$x$ 是子集$K$ 中的最大数。  
根据上述定义，在由单个自然数$a$ 组成自然数子集$\{a\}$中，$a$ 既是最小数也是最大数。下面定理给出了自然数子集中最小值和最大值的存在性：  
【定理1.7】自然数集合具有如下三个基本性质：  
（1）0 是自然数集合的最小数。  
（2）自然数集合的所有非空子集具有最小数（最小数原理），从而正整数集合的所有非空子集均有最小数。  
（3）自然数集合的所有非空有限子集均有最大数，从而正整数集合的所有非空有限子集均有最大数。"
自然数的归纳定义,定义,"['第一章  集合与计数基础', '§ 1.2 可数集与不可数集', '1.2.2 自然数的集合定义', '二、自然数的归纳定义']","{'实体类型': '定义', '方法': '通过基础条款和归纳条款构造自然数集', '基础条款': '空集属于自然数集合，定义为自然数0', '归纳条款': '若集合A属于自然数集合，则其直接后继A+也属于自然数集合'}",,4,"1923 年，著名数学家冯·诺依曼用集合给定义了0 和后继数的概念，并由此通过归纳的方式实现自然数和自然数集合的完美定义。  
【定义1.16】对于任意一个给定的集合$A$，称集合$\cdot A^{+}=A\cup\{A\}$为$A$ 的直接后继。  
【定义1.17】对于任意给定的集合$N$，若它满足如下两个条件，则称其为自然数集合：  
（1）基础条款：空集属于集合$N$，即有$\emptyset\in N$，并将$\emptyset$定义为自然数0； （2）归纳条款：对于任意一个集合$A$，若有$A\in N$，则必有$A^{+}=A\cup\{A\}\in N.$  
上述自然数集合的归纳定义是一种构造性定义方法，通过基础条款和归纳条款构造出自然数集的全部元素 . 基础条款决定了自然数集合为非空集合并确定了集合的初始元素，即自 然数0；归纳条款则以初始元素为出发点通过构造后继元素的方式不断产生新的元素。  
具体地说，按以上定义，自然数集合由如下形式的元素构成：  
$$
\emptyset,\ \{\emptyset\},\ \{\emptyset,\ \{\emptyset\}\},\ \{\emptyset,\ \{\emptyset\},\ \{\emptyset,\ \{\emptyset\}\},\ \{\emptyset,\ \{\emptyset\},\ \{\emptyset,\ \{\emptyset\}\}\}\},\ \cdots
$$  
根据等势的定义，$\{\emptyset\}$与所有含有1 个元素的集合等势，可以看成是这些集合的代表，令其为自然数1；同理有：$\{\varnothing,\;\;\{\varnothing\}\}$与所有含有2 个元素的集合等势，可以看成是这些集合的代表，令其为自然数2；$\{\varnothing,\;\;\{\varnothing\}$，$\{\varnothing,\;\;\{\varnothing\}\}$与所有含有3 个元素的集合等势，可以看成是这些集合的代表，令其为自然数3；$\{\emptyset,\ \{\emptyset\},\ \{\emptyset,\ \{\emptyset\}\}\}$与所有含有4 个元素的集合等势，可以看成是这些集合的代表，令其为自然数4；如此下去，便可得到所有自然数：0, 1, 2, 3, 4，…，并显然成立如下递推关系：  
$$
0\!\!=\!\!\emptyset;\;\;1\!\!=\!\!\{0\};\;\;2\!\!=\!\!\{0\,,\;\;1\};\;\;3\!\!=\!\!\{0\,,\;\;1\,,\;\;2\};\;\;4\!\!=\!\!\{0\,,\;\;1\,,\;\;2\,,\;\,3\};\;\;\cdots
$$  
一般地，有：  
$$
n=\{0\,,\ 1\,,\ 2\,,\ \dots\ \,,\ n-1\}
$$  
下述定理表明上述自然数定义满足皮亚诺公理系统的要求：【定理1.6】自然数的集合定义满足皮亚诺提出的5 条公理。  
有了自然数，便可以定义自然数集合上的各种运算、函数和特殊自然数，这里就不再一一赘述，下面仅给出自然数子集上最大数和最小数的相关定义：  
【定义1.18】如果对$x$ 作不少于一次的后继运算后得到$y$，那么称$x<y$。如果$x$在自然数子集$K$ 中，$K$ 中没有其它数小于$x$，那么称$x$ 是子集$K$ 中的最小数，如果$x$ 在自然数子集$K$ 中，$x$ 不小于$K$中其它数，那么称$x$ 是子集$K$ 中的最大数。  
根据上述定义，在由单个自然数$a$ 组成自然数子集$\{a\}$中，$a$ 既是最小数也是最大数。下面定理给出了自然数子集中最小值和最大值的存在性：  
【定理1.7】自然数集合具有如下三个基本性质：  
（1）0 是自然数集合的最小数。  
（2）自然数集合的所有非空子集具有最小数（最小数原理），从而正整数集合的所有非空子集均有最小数。  
（3）自然数集合的所有非空有限子集均有最大数，从而正整数集合的所有非空有限子集均有最大数。"
自然数的归纳证明,方法,"['第一章  集合与计数基础', '§ 1.2 可数集与不可数集', '1.2.2 自然数的集合定义', '三、自然数的归纳证明']","{'实体类型': '方法', '特点': '基于数学归纳法第一原理和数学归纳法第二原理', '应用': '证明关于自然数的命题'}",,4,"使用归纳法不仅可以实现对自然数集合的一种构造性定义，而且还提供了关于自然数命题的一种有效证明方法，即自然数的归纳证明法。这种证明法两种具体形式，分别基于数学归纳法第一原理和数学归纳法第二原理。  
【数学归纳法第一原理】假设$P(n)$是一个关于自然数$n$ 的命题，若有：  
（1）基础步骤：$P(0)$为真；  
（2）归纳步骤：对于任意正整数$k$，如果$P(k)$为真，则$P(k{+}1)$为真。则$P(n)$对一切自然数$n$ 均为真。  
【证明】假设已经对$P(n)$完成了基础步骤和归纳步骤的证明，但是存在某个自然数$m_{0}$使得 $P(m_{0})$为假。令集合$S$ 为所有使得$P(n)$为假的自然数组成的集合，即：  
$S=\{m|m为自然数且P(m)为假\} $  
由于$\cdot m_{0}\in S$，故𝑆为非空集合，根据定理1.7 中的最小数原理知，$S$中必然存在最小的自然数$s$。由于$P(0)$为真，故$s\neq0$。因此，$s-1$为自然数且不在集合𝑆中，即$P(s-1)$为真。根据归纳假设有$P(s)$为真，这与$s\in S$矛盾！故$P(n)$对一切自然数$n$ 均为真。□  
使用数学归纳法第一原理完成证明的关键在于：首先需要假定对任意一个正整数$k$，$P(\mathrm{k})$为真，然后在此假定下证明$P(k{+}1)$必为真。如果用数学归纳法完成了上述原理中的两  
个步骤，那么就证明了对所有自然数而言$P(n)$为真。  
【数学归纳法第二原理】假设$P(n)$是一个关于自然数$n$ 的命题，若有：  
1）基础步骤：$P(1)$为真；  
（ 2 ）归纳步骤：对于任意正整数 $k$ ，若 $P(1),P(2),\dots,P(k)$ 均为真，则 $P(k{+}1)$ 为真。 则$P(n)$对一切自然数$n$ 均为真。"
自然数的集合定义,定义,"['三、自然数的归纳证明', '一、皮亚诺公理', '1.2.2 自然数的集合定义', '§ 1.2 可数集与不可数集', '二、自然数的归纳定义', '第一章  集合与计数基础']","{'实体类型': '定义', '描述': '自然数是对有限集合中所含元素个数进行度量和比较的一种工具', '本质': '表示抽象集合及其有序序列的数学符号', '基础条款': '空集属于集合N，即有∅∈N，并将∅定义为自然数0', '归纳条款': '对于任意一个集合A，若有A∈N，则必有A+=A∪{A}∈N', '特点': '通过基础条款和归纳条款构造出自然数集的全部元素', '内容': '使用归纳法实现对自然数集合的构造性定义'}",,4,"我们知道，自然数是对有限集合中所含元素个数进行度量和比较的一种工具。如果将所含元素个数彼此相等的有限集合抽象成一个抽象集合，或者说从所含元素个数彼此相等的有限集合中选出一个集合作为代表构成抽象集合，那么所有这些抽象集合就可以按其规模的大小排成一个有序序列。因此，从本质上说自然数就是表示这些抽象集合及其有序序列的一种数学符号。例如，可以将自然数3 定义为能够表示所有3 元集合的一种抽象集合、将自然数5 定义为能够表示所有5 元集合的一种抽象集合，等等。自然数的上述本质特征并不难以理解，问题是如何找到一种恰当的方法来定义这种抽象集合。  
1891 年，著名数学家皮亚诺以0 和后继数这两个不定义概念外加5 条公理表述了自然数的上述本质特征，创立了如下关于自然数的皮亚诺公理系统，为自然数的抽象集合定义及相关的算术运算系统构造提供了一个标准.皮亚诺5 公理的具体内容如下：  
公理1：至少存在一个体是自然数，它被记为0； 公理2：如果$n$ 是自然数，那么$n$ 必定含有一个直接后继，记为$|n^{+}$  
公理3：0 不是任何自然数的直接后继； 公理4：如果自然数$m,n$ 的直接后继$m^{+}$, $n^{+}$相同，那么$m{=}n$  
公理5：不满足上述条件的个体均非自然数。  
可以证明，自然数的所有运算性质都可从上述5 条公理出发推演获得。根据上述5 条公理，可以构建一套比较完备的自然数算术运算系统。定义自然数其实就是要找出一系列具体个体，让它们满足这5 条公理，其中关键要点就是要给出0 和后继数的具体定义。"
自然数集,概念,"['第一章  集合与计数基础', '§ 1.2 可数集与不可数集', '1.2.2 自然数的集合定义']","{'实体类型': '概念', '地位': '刻画或度量无限集的一种最小单位', '应用': '解决无限集的度量问题'}",,3,"对于任意一个无限集合$A$，从中任取一个元素做为第一个元素，记为$\vert x_{1}$；然后再从𝐴−$\{x_{1}\}$中任取一个元素作为第二个元素，记为$x_{2}$；如此下去，…。由于$A$ 是一个无限集，故此这个过程可以无限进行下去，从而得到$A$ 的一个子集合$\{x_{1},x_{2},\ldots,x_{n},\ldots\}$。  
由以上分析可知，对于任意一个无限集合，都可找到它的一个子集与自然数集等势。因此，自然数集应当是刻画或度量无限集的一种最小单位。要解决无限集的度量问题，首先必须搞清楚什么是自然数和自然数集合。"
自然数集合,概念,"['第一章  集合与计数基础', '§ 1.2 可数集与不可数集', '1.2.1 无限集的度量问题']","{'实体类型': '概念', '地位': '作为无限集规模度量的基准'}",,3,"现考察集合规模的度量问题。直观上看，集合中元素数目越多集合的规模就越大。关键是如何界定集合中元素数目的多少？对于有限集，这个不成问题，可通过对集合中元素进行计数的方法解决。然而，对于无限集来说，问题就没这么简单了。例如对于下列问题：  
正整数集合$\{1,2,3,\ \cdots\ \}$和正整数平方集合$\{1^{2},2^{2},3^{2},\ \cdots\ \}$，哪个集合的元素更多？  
显然，正整数平方集合是正整数集合的一个真子集，因此正整数集合似乎应该更大一些。但这两个集合元素之间又显然存在一一对应关系。从传统有限集合计数的观点看，两者的数目又必定是相等的。这似乎存在一种矛盾。事实上，早在1638 年，意大利物理学家伽利略也发现了类似于这样的问题，但是他无法解决并感到困惑，便提出了所谓的伽利略悖论。  
其实，无限集所具有的无限延展特性使其与有限集合有着本质性差异，对有限集合进行精确计数的方式不再适用于对无限集合的度量。因此，必须采用同时适合有限集与无限集的新方法来实现对集合规模的度量。由此得到如下关于集合等势的概念：  
【定义1.15】设$A$ 和$B$ 是任意两个集合，如果$A$ 和$B$ 之间存在一一对应的关系：  
$$
\psi{\colon}A\to B
$$  
则称$\pmb{A}$ 与$\pmb{B}$ 等势，记为：$A^{\circ}B$  
显然，若 $\scriptstyle A=B$ ，则 $A^{\scriptscriptstyle\frown}B$ ，反之不然。  
【定理1.5】集合的等势满足如下三条基本性质：（1）自反性：对于任意集合$A$，有$A{\sim}A$；（2）对称性：对于任意两个集合$A$ 和$B$，如果$A{\sim}B$，则有$B{\sim}A$（3）传递性：对于任意三个集合$A$、$B$ 和$C$，如果$A{\sim}B$ 且$B{\sim}C$，则有$A{\sim}C$  
上述等势概念表达的仅仅是集合在数量规模上次序比较关系，要真正实现对无限集规模的度量，还需确定一个基本的规模度量单位作为度量标准或基准。显然，任何无限集都可生成一个子集与自然数集等势，因此可将自然数集合作为无限集规模度量的一种基准。下面着重介绍自然数的基本概念与性质。"
自然数集合的基本性质,性质,"['第一章  集合与计数基础', '§ 1.2 可数集与不可数集', '1.2.2 自然数的集合定义', '二、自然数的归纳定义']","{'实体类型': '性质', '性质1': '0是自然数集合的最小数', '性质2': '自然数集合的所有非空子集具有最小数', '性质3': '自然数集合的所有非空有限子集均有最大数'}",,4,"1923 年，著名数学家冯·诺依曼用集合给定义了0 和后继数的概念，并由此通过归纳的方式实现自然数和自然数集合的完美定义。  
【定义1.16】对于任意一个给定的集合$A$，称集合$\cdot A^{+}=A\cup\{A\}$为$A$ 的直接后继。  
【定义1.17】对于任意给定的集合$N$，若它满足如下两个条件，则称其为自然数集合：  
（1）基础条款：空集属于集合$N$，即有$\emptyset\in N$，并将$\emptyset$定义为自然数0； （2）归纳条款：对于任意一个集合$A$，若有$A\in N$，则必有$A^{+}=A\cup\{A\}\in N.$  
上述自然数集合的归纳定义是一种构造性定义方法，通过基础条款和归纳条款构造出自然数集的全部元素 . 基础条款决定了自然数集合为非空集合并确定了集合的初始元素，即自 然数0；归纳条款则以初始元素为出发点通过构造后继元素的方式不断产生新的元素。  
具体地说，按以上定义，自然数集合由如下形式的元素构成：  
$$
\emptyset,\ \{\emptyset\},\ \{\emptyset,\ \{\emptyset\}\},\ \{\emptyset,\ \{\emptyset\},\ \{\emptyset,\ \{\emptyset\}\},\ \{\emptyset,\ \{\emptyset\},\ \{\emptyset,\ \{\emptyset\}\}\}\},\ \cdots
$$  
根据等势的定义，$\{\emptyset\}$与所有含有1 个元素的集合等势，可以看成是这些集合的代表，令其为自然数1；同理有：$\{\varnothing,\;\;\{\varnothing\}\}$与所有含有2 个元素的集合等势，可以看成是这些集合的代表，令其为自然数2；$\{\varnothing,\;\;\{\varnothing\}$，$\{\varnothing,\;\;\{\varnothing\}\}$与所有含有3 个元素的集合等势，可以看成是这些集合的代表，令其为自然数3；$\{\emptyset,\ \{\emptyset\},\ \{\emptyset,\ \{\emptyset\}\}\}$与所有含有4 个元素的集合等势，可以看成是这些集合的代表，令其为自然数4；如此下去，便可得到所有自然数：0, 1, 2, 3, 4，…，并显然成立如下递推关系：  
$$
0\!\!=\!\!\emptyset;\;\;1\!\!=\!\!\{0\};\;\;2\!\!=\!\!\{0\,,\;\;1\};\;\;3\!\!=\!\!\{0\,,\;\;1\,,\;\;2\};\;\;4\!\!=\!\!\{0\,,\;\;1\,,\;\;2\,,\;\,3\};\;\;\cdots
$$  
一般地，有：  
$$
n=\{0\,,\ 1\,,\ 2\,,\ \dots\ \,,\ n-1\}
$$  
下述定理表明上述自然数定义满足皮亚诺公理系统的要求：【定理1.6】自然数的集合定义满足皮亚诺提出的5 条公理。  
有了自然数，便可以定义自然数集合上的各种运算、函数和特殊自然数，这里就不再一一赘述，下面仅给出自然数子集上最大数和最小数的相关定义：  
【定义1.18】如果对$x$ 作不少于一次的后继运算后得到$y$，那么称$x<y$。如果$x$在自然数子集$K$ 中，$K$ 中没有其它数小于$x$，那么称$x$ 是子集$K$ 中的最小数，如果$x$ 在自然数子集$K$ 中，$x$ 不小于$K$中其它数，那么称$x$ 是子集$K$ 中的最大数。  
根据上述定义，在由单个自然数$a$ 组成自然数子集$\{a\}$中，$a$ 既是最小数也是最大数。下面定理给出了自然数子集中最小值和最大值的存在性：  
【定理1.7】自然数集合具有如下三个基本性质：  
（1）0 是自然数集合的最小数。  
（2）自然数集合的所有非空子集具有最小数（最小数原理），从而正整数集合的所有非空子集均有最小数。  
（3）自然数集合的所有非空有限子集均有最大数，从而正整数集合的所有非空有限子集均有最大数。"
自然映射,概念,"['第七章 函数与特殊函数', '§ 7.1 函数的基本概念', '7.1.3 常用特殊函数']","{'实体类型': '概念', '定义': '设R是A上的等价关系，A/R是A在关系R上的商集，令g\\colon A\\to A/R，g(x)=[x]_{R}则称g是从A到A/R的自然映射'}",,3,"数学中常用的特殊函数有很多，在初等数学和高等数学中都有大量的分析讨论，例如三角函数、指数函数等基本初等函数，不再一一赘述。在此，我们主要介绍在计算机科学应用中经常使用的一些函数，例如恒等函数、常函数、取整函数、布尔函数、自然映射函数等。下面给出这些常用特殊函数的定义。  
【定义7.6】设$𝐴$和$B$是任意给定的两个非空集合：  
（1）设$f\colon A\to B$，若有$c\in B$，对$\forall x\in A$都有$f(x)=c$，则称$f\colon A\to B$是常函数。  
（2）$𝐴$上的恒等函数就是$𝐴$的恒等关系$I_{A}$，对$\forall x\in A$，有$I_{A}(x)=x$。  
（3）对实数 $x$ ， $f(x)$ 取不小于 $ x$ 的最小整数，则称 $f(x)$ 为上取整函数， 记为 $f(x)=\left\lceil x\right\rceil$  
（4）对实数$x$，$f(x)$取不大于$ x$的最大整数，则称$f(x)$为下取整函数，记为$f(x)=\lfloor x\rfloor$  
（5）如果$f(x)$是从集合$𝐴$到$B=\{0,1\}$上的函数，则称$f(x)$为布尔函数。  
（6）设$R$是$𝐴$上的等价关系，$A/R$是$𝐴$在关系$R$上的商集，令$g\colon A\to A/R$，$g(x)=[x]_{R}$则称$g$是从$A$到$A/R$的自然映射。"
自环,概念,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.2 图的定义与分类']","{'实体类型': '概念', '定义': '两个端点相同的边'}",,3,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)"
自由变量,定义,"['第四章  谓词演算与推理', '§ 4.2  谓词公式与等值演算', '4.2.2 变量的自由与约束']","{'实体类型': '定义', '内容': '未受到量词约束的命题变量，含义不确定'}",,3,"如前所述，量词实现了对谓词中个体变量含义的约束，消除了谓词在语义上的抽象性和不确定性，对于一个$\cdot n$元谓词，如果其中每个变量都分别受到量词的约束，那么它就不再是一个命题函数而蜕化一个具体命题。因此，对于任意一个$\cdot n$元谓词，可将其中所以命题变量分为两种具体不同性质的基本类型：一种是受到量词约束的命题变量，其含义是明确具体的，不再具有自由诠释的性质；另外一种是没有受到量词约束的命题变量，是传统意义上的命题变量，其含义是泛指某个不确定的个体对象，具有自由诠释的性质。这两种变量在谓词公式及谓词演算中扮演着完全不同的角色，在具体的表示形式上必须有明确的区分。本节主要介绍具体的区分方法，首先给出量词辖域的相关概念。  
【定义4.12】假设$G(x)$是任意一个含有命题变量$x$的谓词，在公式$(\forall x)G(x)$或$(\exists x)G(x)$中，$(\forall x)$或$(\exists x)$的作用变量$x$ 在$G(x)$中存在的范围称为量词$(\forall x)$或$(\exists x)$的辖域。如果辖域不是原子谓词公式，其两侧必须有括号，否则不应有括号。  
例如：在谓词公式$\exists x(P(x,y)\rightarrow Q(x,y))\vee P(y,z)$中，$\exists x$的辖域是$(P(x,y)\to Q(x,y))$  
在谓词公式$\forall x P(x)\rightarrow Q(x)$中，$\forall x$的辖域是$P(x)$。  
一般来说，一个量词的辖域是某个谓词公式的子公式。因此，确定一个量词的辖域就是要找出位于该量词之后与之相邻接的子公式，具体方法如下：  
（1）若量词后面有括弧，则括弧内的子公式就是该量词的辖域；  
（2）若量词后面无括弧，则与该量词邻接的子公式为该量词的辖域。  
下面在量词辖域的基础上给出自由变量和约束变量的定义：  
【定义4.13】假设𝐺是任一谓词公式，$x$是𝐺的任意一个命题变量，如果$x$出现在以它为作用变量的量词辖域之内，则称$x$的出现为约束出现，称变量$x$为约束变量；如果$x$不是约束出现，则称其为自由出现，此时称$x$为自由变量。  
从上述定义不难看出，所谓约束变量，就是其含义受到量词约束的命题变量。约束变量的含义是明确具体的，不再具有自由诠释的性质。自由变量则是含义没有受到量词约束的命题变量，是传统意义上的命题变量，可以对其含义进行自由诠释。  
如果谓词公式中所有命题变量都受到量词约束，则称其为封闭公式，具体定义如下：  
【定义4.14】若谓词公式$G$ 中不含自由变量，则称该公式为封闭公式或闭式。  
例如，$(\forall x)(P(x)\rightarrow(\exists y)R(x,y))$就是一个闭式。显然，要想使得含有$n$个自由变量的谓词公式变成闭式，需要添加$|n$个量词。  
从上述例题不难看出，有时候在同一个谓词公式中同一个命题变量既可以约束出现也可以自由出现，例如对于如下谓词公式：  
$(\forall x)(P(x)\rightarrow R(x))\land(\exists y)Q(x,y)$  
该式中个体变量$\cdot x$既是约束变量又是自由变量。这很容易引起在概念理解上的歧义或混乱，需要通过一些方法对这种变量进行换名，使得同一个个体变量在同一个谓词公式中要么自由出现，要么约束出现，不能兼而有之，避免个体变量在概念理解上的歧义或混乱。下面介绍具体的个体变量改名方法。  
对于任意一个含有量词的谓词公式，以约束方式出现的个体变量到底用哪一个字母表示其实是无关紧要的。事实上，用其它任意字母表示这个约束变量都不会改变谓词公式的含义。由此可得如下约束变量的换名规则：  
（1）将量词中出现的变量以及该量词辖域中此变量的所有约束出现都替换为新的变量；  
（2）新变量名一定要有别于辖域中的所有其它变量名。  
为使一个个体变量在同一个谓词公式中只以一种方式出现，还可以使用一定的规则实现对自由变量换名。该规则称为自由变量的代入规则，具体内容如下：  
（1）将公式中出现该自由变量的每一处都用新的变量替换；  
（2）新变量不允许在原公式中以任何约束形式出现。"
自由变量代入规则,算法,"['第四章  谓词演算与推理', '§ 4.2  谓词公式与等值演算', '4.2.2 变量的自由与约束']","{'实体类型': '算法', '步骤': '将公式中出现的自由变量替换为新的变量，新变量不允许在原公式中以任何约束形式出现'}",,3,"如前所述，量词实现了对谓词中个体变量含义的约束，消除了谓词在语义上的抽象性和不确定性，对于一个$\cdot n$元谓词，如果其中每个变量都分别受到量词的约束，那么它就不再是一个命题函数而蜕化一个具体命题。因此，对于任意一个$\cdot n$元谓词，可将其中所以命题变量分为两种具体不同性质的基本类型：一种是受到量词约束的命题变量，其含义是明确具体的，不再具有自由诠释的性质；另外一种是没有受到量词约束的命题变量，是传统意义上的命题变量，其含义是泛指某个不确定的个体对象，具有自由诠释的性质。这两种变量在谓词公式及谓词演算中扮演着完全不同的角色，在具体的表示形式上必须有明确的区分。本节主要介绍具体的区分方法，首先给出量词辖域的相关概念。  
【定义4.12】假设$G(x)$是任意一个含有命题变量$x$的谓词，在公式$(\forall x)G(x)$或$(\exists x)G(x)$中，$(\forall x)$或$(\exists x)$的作用变量$x$ 在$G(x)$中存在的范围称为量词$(\forall x)$或$(\exists x)$的辖域。如果辖域不是原子谓词公式，其两侧必须有括号，否则不应有括号。  
例如：在谓词公式$\exists x(P(x,y)\rightarrow Q(x,y))\vee P(y,z)$中，$\exists x$的辖域是$(P(x,y)\to Q(x,y))$  
在谓词公式$\forall x P(x)\rightarrow Q(x)$中，$\forall x$的辖域是$P(x)$。  
一般来说，一个量词的辖域是某个谓词公式的子公式。因此，确定一个量词的辖域就是要找出位于该量词之后与之相邻接的子公式，具体方法如下：  
（1）若量词后面有括弧，则括弧内的子公式就是该量词的辖域；  
（2）若量词后面无括弧，则与该量词邻接的子公式为该量词的辖域。  
下面在量词辖域的基础上给出自由变量和约束变量的定义：  
【定义4.13】假设𝐺是任一谓词公式，$x$是𝐺的任意一个命题变量，如果$x$出现在以它为作用变量的量词辖域之内，则称$x$的出现为约束出现，称变量$x$为约束变量；如果$x$不是约束出现，则称其为自由出现，此时称$x$为自由变量。  
从上述定义不难看出，所谓约束变量，就是其含义受到量词约束的命题变量。约束变量的含义是明确具体的，不再具有自由诠释的性质。自由变量则是含义没有受到量词约束的命题变量，是传统意义上的命题变量，可以对其含义进行自由诠释。  
如果谓词公式中所有命题变量都受到量词约束，则称其为封闭公式，具体定义如下：  
【定义4.14】若谓词公式$G$ 中不含自由变量，则称该公式为封闭公式或闭式。  
例如，$(\forall x)(P(x)\rightarrow(\exists y)R(x,y))$就是一个闭式。显然，要想使得含有$n$个自由变量的谓词公式变成闭式，需要添加$|n$个量词。  
从上述例题不难看出，有时候在同一个谓词公式中同一个命题变量既可以约束出现也可以自由出现，例如对于如下谓词公式：  
$(\forall x)(P(x)\rightarrow R(x))\land(\exists y)Q(x,y)$  
该式中个体变量$\cdot x$既是约束变量又是自由变量。这很容易引起在概念理解上的歧义或混乱，需要通过一些方法对这种变量进行换名，使得同一个个体变量在同一个谓词公式中要么自由出现，要么约束出现，不能兼而有之，避免个体变量在概念理解上的歧义或混乱。下面介绍具体的个体变量改名方法。  
对于任意一个含有量词的谓词公式，以约束方式出现的个体变量到底用哪一个字母表示其实是无关紧要的。事实上，用其它任意字母表示这个约束变量都不会改变谓词公式的含义。由此可得如下约束变量的换名规则：  
（1）将量词中出现的变量以及该量词辖域中此变量的所有约束出现都替换为新的变量；  
（2）新变量名一定要有别于辖域中的所有其它变量名。  
为使一个个体变量在同一个谓词公式中只以一种方式出现，还可以使用一定的规则实现对自由变量换名。该规则称为自由变量的代入规则，具体内容如下：  
（1）将公式中出现该自由变量的每一处都用新的变量替换；  
（2）新变量不允许在原公式中以任何约束形式出现。"
良序关系,概念,"['第六章 特殊关系模型', '§ 6.3 偏序关系与元素比较', '6.3.3  全序与良序']","{'实体类型': '概念', '定义': '对于偏序集，如果任意一个非空子集都含有最小元素，则称该偏序关系为良序关系', '特点': '良序关系一定是偏序关系和全序关系，但偏序关系和全序关系不一定是良序关系'}",,3,"前述集合$𝐴$上偏序关系并不保证$𝐴$上的任何两个元素之间都是可比的，也是就是说并不保证任何两个元素之间都存在序关系。然而，在很多场合我们都需要对所关心的所有对象排个次序，例如体育比赛中的种子选手排名、全国各高校的综合排名、大会嘉宾代表的入场次序等等，都需要对所有对象进行排序。现有偏序关系模型显然不能正确表示和处理这类问题。故须加强偏序关系约束条件，在偏序关系基础上引入全序关系，其具体定义如下：  
【定义6.14】对于偏序集$\langle A,\preccurlyeq\rangle$，如果$𝐴$中任意两个元素${x}$和$\boldsymbol{y}$都是可比的，即$x\preccurlyeq y$或者$y\preccurlyeq x$，则称该偏序关系为全序关系或线序关系，简称为全序或线序。并称$\langle A,\preccurlyeq\rangle$为全序集或线序集，也可称为集合$𝐴$的链。  
由上述定义可知，全序关系必定是偏序关系，偏序关系则不一定是全序关系。  
可用全序的概念定义偏序集$\langle A,\preccurlyeq\rangle$的一些特殊子集合，具体定义如下：  
【定义6.15】设$\langle A,\preccurlyeq\rangle$是一个偏序集，$B$是$𝐴$的任一子集，如果$𝐵$中任意两个元素都是可比的，则称$B$是$𝐴$的一条链，$B$中元素的个数称为该链的长度；反之，如果$B$中任意两个元素都是不可比的，则称 $B$是$𝐴$的一条反链，$B$中元素的个数称为该反链的长度。对于$𝐴$中由单个元素组成的集合，规定它既是链也是反链。  
例如，在偏序集〈{1,2,3,4,5,6,7,8,9}, |〉中，{1,2,4,8}是一条长度为4 的链，{2,4}是一条长度为2 的链，{2,3}则是一条长度为2 的反链。  
偏序集中的链表达了偏序集中部分元素之间存在全序关系，反链则表达了偏序集中部分元素相互之间不存在任何序关系。显然，链表达的是一种串行执行结构，反链表达的是一种并行执行结构。因此，可以使用偏序集中链和反链的概念优化实际问题求解的业务流程，有效提高问题求解的工作效率。  
![](images/18f7caa4d0b707d1ff49eb6f7a547c82b50926bf7ba3ab409aa786a7fcff2f4c.jpg)
图6-22 保险索赔业务流程  
例如，图6-22 是一个关于保险索赔的流程图。图中方框代表处理流程中业务，圆圈代表某种分支选择。将流程中循环抽象成一个单一的结点，如用单个结点𝑇代替流程图中业务$T_{7}$、$T_{8}$及其后的分支结点。由此得到的所有结点构成集合$𝐴$，在该集合元素之间定义如下偏序关系≼：对$\forall x,y\in A$，当且仅当$x=y$或者$𝑦$必须在$x$完成后才能开始时，成立$x\preccurlyeq y$。如此，集合$𝐴$与其上的偏序关系$\preccurlyeq$便构成一个偏序集$\langle A,\preccurlyeq\rangle$，  
图6.23 为其哈斯图。  
考虑偏序集中的链，最长链有4 条，其中2 条分别是：  
$\{T_1,T_2,T_3,S_1,T_6,,S_2,T,T_{10}\}; \{T_1,T_2,T_3,S_1,T_6,,S_2,T_9,T_{10}\}$  
长度都是8。显然，最长链的长度代表了整个流程中必须顺序执行的任务最多有多少个。如果完成每项任务的时间差距不大，那么这种最长链就反映了完成整个任务的最少时间。  
![](images/598fd43b47030dd50e3aa3bc789da0841fc0eb2b823d2c8cd7d0b88fecfb1eab.jpg)
图6-23 业务关系哈斯图  
并行执行业务是提供效率的一种有效途径。在一个偏序集中，如果能够将业务按照不相交的链进行分解，那么这些不相交的链就可在一定程度上并行执行。另一方面，如果把偏序集分解成不相交的反链，那么最长的反链长度则代表了在某个时间区间极大可并行的任务数。下面定理刻画了偏序集的分解与反链之间的关系：  
【定义6.16】设$\langle A,\preccurlyeq\rangle$为偏序集，如果$𝐴$中最长的链长度为$n$，则该偏序集可以分解为$𝑛$条不相交的反链。  
我们知道，对于一个偏序集合$\langle A,\preccurlyeq\rangle$，其任何子集${B}$上的最大值和最小值不一定存在或者不一定都存在。如果我们把偏序集合$\langle A,\preccurlyeq\rangle$的约束条件加强，要求$𝐴$的任何子集$𝐵$上的必须存在最小值，则得到如下良序关系的概念：  
【定义6.17】对于偏序集$\langle A,\preccurlyeq\rangle$，如果$𝐴$的任意一个非空子集$B$中都含有最小元素，则称该偏序关系为良序关系，简称为良序。称$\langle A,\preccurlyeq\rangle$为良序集。  
由上述定义可知，良序关系一定是偏序关系和全序关系，但偏序关系和全序关系不一定是良序关系。例如，实数集合上的小于等于关系显然是全序关系，但不是良序关系，因为开区间(0,1)没有最小值。不过有限的全序集一定是良序集。对于任何一个有限偏序集，可以通过适当排序将其改造成为一个全序集，从而使其成为良序集。"
苏格拉底三段论,概念,"['第四章  谓词演算与推理', '§ 4.1 个体词、谓词与量词', '4.1.1  逻辑与谓词逻辑']","{'实体类型': '概念', '定义': '一种经典的逻辑推理形式', '示例': '所有人都是要死的；苏格拉底是人；所以，苏格拉底是要死的'}",,3,"我们知道，命题是一个具有确切真假含义的陈述句，一般由主语和谓语这两个基本部分组成。例如对于如下命题：  
小张是合肥工业大学学生；小李是合肥工业大学学生。  
小张”、“小李”都是主语，“是合肥工业大学的学生”是谓语。  
从命题逻辑的角度看，上述两个命题都是原子命题，它们之间没有任何联系。但是，事实上这两个命题之间显然有着“是合肥工业大学学生”这一共同特性。由此可知，命题逻辑无法表达这种概念层次上的共同特性。值得注意的是，重的问题，甚至导致无法进行一些非常简单的推理。例如，对于如下苏格拉底三段论：  
所有的人都是要死的；苏格拉底是人；所以，苏格拉底是要死的。  
显然这三个命题之间具有紧密联系，若前两个命题为真，则最后一个命题必为真。用命题逻辑表示这个三段论推理，令$P$，$\mathcal{Q}$，$R$ 分别表示上述三个命题，则有 $P\Lambda Q\Rightarrow R$ 。根据命题逻辑永真蕴含的性质，可知 $P\Lambda Q\to R$ 为永真公式，这显然是不可能的。  
产生这种错误结果的根本原因在于这三个命题之间的逻辑关系并不是体现在命题与命题之间的层次，而是体现在命题内部的概念层次上。命题逻辑以原子命题为基本单元来研究命题的性质和逻辑推演，对于这种命题内部成分之间的联系自然是无能为力的，既不能将前两个命题中关于“人”的共同概念表达出来，也不能将第一个和第三个命题中关于“死”的共同概念表达出来。因此，命题逻辑无法解决苏格拉底三段论推理问题。  
通过以上讨论可以看出，仅在命题层次上研究逻辑推演问题是不够的，必须对原子命题做进一步分解，研究命题在更深层结构上的性质和关系。例如，可将命题“所有的人都是要死的”，分解成“所有的”，“人”和“要死的”这三个部分，分别对其做进一步分析，研究其概念性质、形式结构和逻辑关系，形成有效的推演形式和规则，这正是谓词逻辑的基本内容。事实上，这三个部分分别对应于谓词逻辑中三个最基本的概念，即量词、个体词和谓词，整个谓词逻辑的理论体系基本上由这三个概念衍生而成。"
范式,概念,"['第三章  命题演算与推理', '§ 3.4 命题公式的范式', '3.4.1 范式的基本概念', '二、析取范式与合取范式']","{'实体类型': '概念', '定义': '析取范式与合取范式统称为范式'}",,4,"合取式是一个只有否定层与合取运算层的两层结构表达式，如果在其外层增加一个析取运算层，则得到所谓的析取范式；同样，析取式是一个只有否定层与析取运算层的两层结构表达式，如果在其外层增加一个合取运算层，则得到所谓的合取范式。  
【定义3.22】有限个短语的析取式称为析取范式；有限个子句的合取式称为合取范式。析取范式与合取范式统称为范式。 也就是说，一个命题公式为析取范式，当且仅当它具有形式：$A_{1}\lor A_{2}\lor\ldots\lor A_{n}$。其中，$A_{1}$，$A_{2}$，… ，$A_{n}$均为由命题变元或其否定所组成的合取式。  
例如，$(P\land\neg Q\land R)\lor(\neg P\land Q)\lor\neg R$是析取范式。  
同样地，一个命题公式称为合取范式，当且仅当该命题具形式：$B_{1}\wedge B_{2}\wedge\cdots\wedge B_{n}$。其中，$B_{1}$，$B_{2}$，⋯，$B_{n}$均为由命题变元或其否定所组成的析取式。  
例如，$(P\lor\neg Q\lor R)\land(\neg P\lor Q)\land\neg R$是合取范式。  
注意：①一个命题的析取范式或合取范式不唯一；②形如$P\land\neg Q\land R$的公式既可看成是由一个合取式构成的析取范式，也可以看成是由3 个析取式构成的合取范式，但是公式$(P\land$$\neg Q\land R)$只能将其看成是析取范式；③形如$P\lor\neg Q\lor R$的公式既是合取范式，又是析取范式，但$(P\lor\neg Q\lor R)$仅是合取范式。  
对于任意一个命题公式，下面定理保证了其析取范式和合取范式的存在性：  
【定理3.8】对于任意命题公式，都存在与其等值的析取范式和合取范式。"
蕴含联结词,概念,"['第三章  命题演算与推理', '§ 3.1 命题的概念与运算', '3.1.3  命题的常用联结词', '三、蕴含与等价联结词']","{'实体类型': '概念', '定义': '表示如果某个命题为真，那么另外一个命题必为真的逻辑联结词', '特点': '记作 P→Q，其中 P 为前提，Q 为结论', '真值条件': 'P→Q 的真值为假，当且仅当 P 为真且 Q 为假'}",,4,"有时候需要构造一个复合命题表示如果某个命题为真，那么另外一个命题必为真的含义，相当于自然语言中“如果…，那么…”的意思，由此得到的逻辑运算称为命题的“蕴涵”运算或者“条件”运算。该运算及其逻辑联结词的具体定义如下：  
【定义3.5】设 $P、 Q$ 是任意两个命题，复合命题$^{\prime\prime}P$ 蕴涵 $Q$ ”称为 $P$ 与 $Q$ 的蕴含式或蕴含运算，记作 $P\rightarrow Q$ ，其中符号$""~\rightarrow~""$称为蕴含联结词（简称为蕴含词），$P$ 称为蕴含式的前提或前件，   $Q$   称为蕴含式的结论或后件。 $P\rightarrow Q$   的真值为假，当且仅当   $P$ 为真且  $Q$ 为假。  
例如，若令 $P$ 表示“我喜欢唱歌”， $Q$表示“我喜欢跳舞”，则蕴涵式 $P\rightarrow Q$ 就表示复合命题“如果我喜欢唱歌，那么必然喜欢跳舞”。其中命题“我喜欢唱歌”是蕴含式的前提或前件，命题“我喜欢跳舞”是蕴含式的结论或后件。  
对于任意两个命题 $P$ 和 $Q$ ，蕴涵运算 $P\rightarrow Q$ 的真值取值规定如表3-2 第3 列所示。  
表${3 -2}\rightarrow,\ \leftrightarrow$的运算表
![](images/920c1058d83ec209cf5c8390304a73d783359e57457ba1d5a111c26950f592f9.jpg)  
由表3-2 可以看出，对于蕴涵运算 $P\rightarrow Q$ 的真值取值，只有当 $P$ 为真， $Q$ 为假时，$P\rightarrow Q$ 的真值才为假，在其余三种情况下 $P\rightarrow Q$ 的真值均为真。也就是说，当 $P$ 为为假时，无论 $Q$ 为真或者为假，$P\rightarrow Q$ 的真值均为真。  
其实，蕴含运算符$""{\rightarrow}""$既可表示充分条件，也可表示必要条件，关键是看哪个作为运算的前件，哪个作为运算的后件。具体地说，对于蕴涵式 $P\rightarrow Q$ ，具有如下结论：  
命题 $P$ 是命题 $Q$ 的充分条件，因为根据蕴涵式的含义有：若 $P$ 为真，则 $Q$ 必为真；  
命题 $Q$ 是命题 $P$ 的必要条件，因为根据蕴涵式的含义有：若 $Q$为假，则 $P$ 必为假。  
自然语言表达充分条件和必要条件的方式有很多种，实际使用的时候应注意区分。例如，若令 $P$ 表示命题“天气好”， $Q$ 表示命题“我去公园”，则对于如下4 个命题：  
（1）如果天气好，我就去公园；（2）只要天气好，我就去公园；  
（3）只有天气好，我才去公园；（4）仅当天气好，我才去公园。  
对于命题（1）2），$P$ 是 $Q$ 的充分条件，$Q$ 是 $P$ 的必要条件，可表示为 $P\rightarrow Q$；  
对于命题（3）4），$P$ 是 $Q$ 的必要条件，$Q$ 是 $P$ 的充分条件，可表示为 $Q\rightarrow P$ 。  
有时需要构造一个复合命题表示两个命题同时为真且同时为假的含义，相当于自然语言中“等价”、“当且仅当”的意思，由此得到的逻辑运算称为命题的“等价”运算或者“双蕴含”运算。该运算及其逻辑联结词的具体定义如下：  
【定义 3.6 】设   $P$ 、 $Q$   是任意两个命题，复合命题 “   $P$   等价   $Q$   ” 称为   $P$   与   $Q$   的等价 式或等价运算，有时也称为双蕴含运算，记作 $P\leftrightarrow Q$ ，其中符号$\leftrightarrow$称为等价联结词(简称为等价词)。$P\leftrightarrow Q$ 的取值为真，当且仅当 $P$ 与 $Q$具有相同的真值。  
例如，若令 $P$ 表示“我喜欢唱歌”，$Q$ 表示“我喜欢跳舞”，则等价式 $P\leftrightarrow Q$ 就表示复合命题“我喜欢唱歌当且仅当我喜欢跳舞”，或者“如果我喜欢唱歌，那么必然喜欢跳舞，并且如果我喜欢跳舞，那么必然喜欢唱歌”。  
对于任意两个命题 $P$ 和 $Q$ ，其等价运算$P\leftrightarrow Q$的真值取值情况如表3-2 第4 列所示。"
蕴涵运算,算法,"['第三章  命题演算与推理', '§ 3.1 命题的概念与运算', '3.1.3  命题的常用联结词', '三、蕴含与等价联结词']","{'实体类型': '算法', '定义': '基于蕴含联结词的逻辑运算', '应用': '表示充分条件和必要条件'}",,4,"有时候需要构造一个复合命题表示如果某个命题为真，那么另外一个命题必为真的含义，相当于自然语言中“如果…，那么…”的意思，由此得到的逻辑运算称为命题的“蕴涵”运算或者“条件”运算。该运算及其逻辑联结词的具体定义如下：  
【定义3.5】设 $P、 Q$ 是任意两个命题，复合命题$^{\prime\prime}P$ 蕴涵 $Q$ ”称为 $P$ 与 $Q$ 的蕴含式或蕴含运算，记作 $P\rightarrow Q$ ，其中符号$""~\rightarrow~""$称为蕴含联结词（简称为蕴含词），$P$ 称为蕴含式的前提或前件，   $Q$   称为蕴含式的结论或后件。 $P\rightarrow Q$   的真值为假，当且仅当   $P$ 为真且  $Q$ 为假。  
例如，若令 $P$ 表示“我喜欢唱歌”， $Q$表示“我喜欢跳舞”，则蕴涵式 $P\rightarrow Q$ 就表示复合命题“如果我喜欢唱歌，那么必然喜欢跳舞”。其中命题“我喜欢唱歌”是蕴含式的前提或前件，命题“我喜欢跳舞”是蕴含式的结论或后件。  
对于任意两个命题 $P$ 和 $Q$ ，蕴涵运算 $P\rightarrow Q$ 的真值取值规定如表3-2 第3 列所示。  
表${3 -2}\rightarrow,\ \leftrightarrow$的运算表
![](images/920c1058d83ec209cf5c8390304a73d783359e57457ba1d5a111c26950f592f9.jpg)  
由表3-2 可以看出，对于蕴涵运算 $P\rightarrow Q$ 的真值取值，只有当 $P$ 为真， $Q$ 为假时，$P\rightarrow Q$ 的真值才为假，在其余三种情况下 $P\rightarrow Q$ 的真值均为真。也就是说，当 $P$ 为为假时，无论 $Q$ 为真或者为假，$P\rightarrow Q$ 的真值均为真。  
其实，蕴含运算符$""{\rightarrow}""$既可表示充分条件，也可表示必要条件，关键是看哪个作为运算的前件，哪个作为运算的后件。具体地说，对于蕴涵式 $P\rightarrow Q$ ，具有如下结论：  
命题 $P$ 是命题 $Q$ 的充分条件，因为根据蕴涵式的含义有：若 $P$ 为真，则 $Q$ 必为真；  
命题 $Q$ 是命题 $P$ 的必要条件，因为根据蕴涵式的含义有：若 $Q$为假，则 $P$ 必为假。  
自然语言表达充分条件和必要条件的方式有很多种，实际使用的时候应注意区分。例如，若令 $P$ 表示命题“天气好”， $Q$ 表示命题“我去公园”，则对于如下4 个命题：  
（1）如果天气好，我就去公园；（2）只要天气好，我就去公园；  
（3）只有天气好，我才去公园；（4）仅当天气好，我才去公园。  
对于命题（1）2），$P$ 是 $Q$ 的充分条件，$Q$ 是 $P$ 的必要条件，可表示为 $P\rightarrow Q$；  
对于命题（3）4），$P$ 是 $Q$ 的必要条件，$Q$ 是 $P$ 的充分条件，可表示为 $Q\rightarrow P$ 。  
有时需要构造一个复合命题表示两个命题同时为真且同时为假的含义，相当于自然语言中“等价”、“当且仅当”的意思，由此得到的逻辑运算称为命题的“等价”运算或者“双蕴含”运算。该运算及其逻辑联结词的具体定义如下：  
【定义 3.6 】设   $P$ 、 $Q$   是任意两个命题，复合命题 “   $P$   等价   $Q$   ” 称为   $P$   与   $Q$   的等价 式或等价运算，有时也称为双蕴含运算，记作 $P\leftrightarrow Q$ ，其中符号$\leftrightarrow$称为等价联结词(简称为等价词)。$P\leftrightarrow Q$ 的取值为真，当且仅当 $P$ 与 $Q$具有相同的真值。  
例如，若令 $P$ 表示“我喜欢唱歌”，$Q$ 表示“我喜欢跳舞”，则等价式 $P\leftrightarrow Q$ 就表示复合命题“我喜欢唱歌当且仅当我喜欢跳舞”，或者“如果我喜欢唱歌，那么必然喜欢跳舞，并且如果我喜欢跳舞，那么必然喜欢唱歌”。  
对于任意两个命题 $P$ 和 $Q$ ，其等价运算$P\leftrightarrow Q$的真值取值情况如表3-2 第4 列所示。"
蛮力与贪心策略,算法,"['第二章  整数与算法设计基础', '§ 2.4 算法设计策略与应用']","{'实体类型': '算法', '应用': '算法设计的基本策略之一'}",,2,计算机问题求解算法虽然千差万别，但都遵循一些基本的设计策略。这些策略蕴含着很多非常深刻而又普适的求解智慧。例如，分治策略把一个问题分解为若干规模较小的子问题，然后以递归的方式求解它们并通过合并它们的解来实现对原问题的求解，而回溯策略则认为对未知世界的探索是一个试错的过程，并给出具体的试错方案，这恰恰是对人类生活经验的一种抽象和总结。不断学习、领会和掌握这些智慧，就可逐步形成良好的算法思维，从而能够更加透彻地从本质上理解算法设计的精髓，为设计出高水平算法打下坚实的基础。本章主要结合具体应用实例介绍和分析算法设计的若干基本策略，包括蛮力与贪心策略、递归与分治策略、回溯与动态规划策略。
蛮力法,算法,"['第二章  整数与算法设计基础', '§ 2.4 算法设计策略与应用', '2.4.1 蛮力与贪心']","{'实体类型': '算法', '定义': '枚举出所有可能状态，然后在这些状态中找到所需的解', '优点': '普适性高，几乎可以解决任何问题', '缺点': '计算量太大，很多情况下不可行', '特点': '算法思想简单，易于理解，存在明显的局限性'}",,3,计算机处理的对象及其结构都是离散的，对这种离散对象与结构的求解，显然有一种最直观、最基本的方法，就是枚举出所有可能状态，然后在这些状态中找到所需的解。这就是蛮力法。该方法最大优点就是普适性高，几乎可以解决任何问题，最大的缺点就是计算量太大，很多情况下不可行。此外，还有一种非常直观的、非常基本的方法，那就是贪心法。该方法在每一步都获得当前状态下最好的结果，通过使用局部最优解步步逼近的方式获得问题全局最优解。贪心法的优点是思想直观，易于理解，缺点是算法没有总体控制机制，缺少远见和大局观，有时难以保证算法的正确性。蛮力法和贪心法的共同特点是算法思想简单，易于理解，但都存在比较明显的局限性，在很多情况下难以直接使用。
蛮力策略,算法,"['第二章  整数与算法设计基础', '§ 2.4 算法设计策略与应用', '2.4.1 蛮力与贪心', '一、蛮力策略']","{'实体类型': '算法', '定义': '用最原始、最暴力的方式解决问题，基本思路是以扫描的模式依次处理问题域所有元素，并将所有可能的结果枚举出来，进而实现对问题的求解', '特点': '直接基于问题的描述和所涉及概念的定义来解决问题，即用最直接的方式解决问题', '地位': '在算法设计策略中占据着不可替代的重要地位', '应用条件': '在可枚举的离散结构中，是一种几乎可以解决任何问题的一般性方法；若问题规模不大，且使用蛮力法的效率可以接受，可直接使用蛮力法；可作为基准，衡量同样问题更高效的算法', '基本步骤': '找到枚举范围：分析问题，找到所涉及的每一种情况；找到约束条件：解析约束条件，并用逻辑表达式表示'}",,4,"【定义2.18】蛮力策略或蛮力法，亦称为穷举法或暴力法，就是用最原始、最暴力的方式解决问题，基本思路是以扫描的模式依次处理问题域所有元素，并将所有可能的结果枚举出来，进而实现对问题的求解。  
从算法思想的角度来看，蛮力法直接基于问题的描述和所涉及概念的定义来解决问题，即用最直接的方式解决问题。例如：求$.1+{\begin{array}{l}{2+3+\cdots+n}\end{array}}$的结果。蛮力法就是逐次将$n$个元素一个一个累加起来得到结果。  
蛮力法的设计一般没有技巧性，因此巧妙和高效的算法很少来自蛮力法。但是，蛮力法在算法设计策略中仍然占据着不可替代的重要地位，原因在于：  
（1）在可枚举的离散结构中，蛮力法是一种几乎可以解决任何问题的一般性方法。  
（2）若要解决的问题规模不大，且使用蛮力法的效率可以接受，就可直接使用蛮力法。此时，设计一个更高效算法所花费的代价很可能是不值得的。  
（3）可将蛮力法作为一个基准，来衡量同样问题更高效的算法，为研究提供服务。蛮力法的求解一般由如下两个基本步骤组成：  
1）找到枚举范围：分析问题，找到所涉及的每一种情况。  
2）找到约束条件：解析约束条件，并用逻辑表达式表示。"
补图,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.2.1 图的基本运算', '三、子图与补图运算']","{'实体类型': '概念', '定义': '设 $G=\\\\langle V,E\\\\rangle$ 是 $n$ 阶简单图，以 $V$ 为顶点集，以所有能使 $G$ 成为完全图 $K_{n}$ 的新加边为边集的图称为 $G$ 相对于 $K_{n}$ 的补图', '记法': '记为$\\\\bar{G}$', '特点': '若图$G$的邻接矩阵为$A_{G}=(a_{i j})_{n\\\\times n}$，则其补图$\\\\bar{G}$的邻接矩阵为$A_{\\\\bar{G}}=(\\\\bar{a}_{i j})_{n\\\\times n}$'}",,4,"在使用图模型对实际问题建模和求解的过程中，经常需要分析考察图的某个特定部分的结构，将图中某个或某些特定的部分提取出来作为一个图模型进行研究，由此得到如下关于图模型的子图运算的若干概念，具体如下：  
【定义8.13】设 $G=\langle V,E\rangle$，$G^{\prime}=\langle V^{\prime},E^{\prime}\rangle$是两个图（同为无向图或者有向图），则有：  
（1）若 $V^{\prime}\subseteq V$且 $E^{\prime}\subseteq E$，则称 $G^{\prime}$是 $G$ 的子图，$G$ 是 $G^{\prime}$的母图，记为 $G^{\prime}\subseteq\mathbf{G}$ 。若 $G^{\prime}\subseteq\mathbf{G}$且 $G^{\prime}\neq{\bf G}$（即$V^{\prime}\subset V$或 $E^{\prime}\subset\mathbf{E})$），则称 $G^{\prime}$ 是 $G$ 的真子图；若 $G^{\prime}\subseteq G$且 $V^{\prime}=V$，则称 $G^{\prime}$是 $G$ 的生成子图。  
（2）设$V_{1}$是𝑉的非空子集，即 $\varnothing\neq V_{1}\subseteq V$，则以 $V_{1}$ 为结点集，以两个端点均在 $V_{1}$ 中的全体边为边集的 $G$ 的子图称为由$V_{1}$导出的导出子图，记为 $G[V_{1}]$。  
（3）设$E_{1}$是$E$的非空子集，设$\varnothing\neq E_{1}\subseteq E$，以 $E_{1}$为边集，以 $E_{1}$ 中所有边关联的全部结点为结点集的 $G$ 的子图成为由 $E_{1}$导出的导出子图，记为 $G[\ E_{1}]$。  
由上述定义可以看出，生成子图与其母图具有相同的结点集合。因此，一个图的生成子图一般是该图的主体结构。对于一个复杂的图模型，一般通过采用适当的方法构造其符合要求的生成子图实现对模型的化简和对问题的求解。  
不难看出，对于任一给定非空有限结点集合，由这些结点构成的零图和完全图分别表达了两个极端构图情形，两者之间具有互补性，相当于集合论中的空集和全集。 由此可以得到图模型补运算的概念。 首先给出如下关于完全图的定义：  
【定义8.14】假设$G=\langle V,E\rangle$是一个具有$\cdot_{n}$个结点的无向简单图，如果图中任意两个结点之间都有边相联结，则称该图为$^n$阶无向完全图，简称为完全图，记为$K_{n}$；假设$G=\langle V,E\rangle$是一个具有$\cdot_{n}$个结点的有向简单图，如果图中任意两个结点之间都有方向相反的两条边相联结，则称该图为$n$阶有向完全图，在不发生混淆的情况下也记为$K_{n}$。  
由上述定义可知，对于完全图来说，其邻接矩阵除主对角线上元素均为0 之外，其余元素均为1。显然，$n$阶无向完全图的边数为$n(n-1)/2$ ，$n$阶有向完全图的边数为$\ n(n-1)$。 图8-17 给出了无向完全图$K_{3}$，$K_{4}$，$K_{5}$和有向图$K_{3}$。  
下面给出图模型补运算的定义：  
【定义8.15】设 $G=\langle V,E\rangle$ 是 $n$ 阶简单图，以 $V$ 为顶点集，以所有能使 $G$ 成为完全图 $K_{n}$ 的新加边为边集的图称为 $G$ 相对于 $K_{n}$ 的补图，简称为 $G$ 的补图，记为$\bar{G}$。  
显然，若图$G$的邻接矩阵为$A_{G}=(a_{i j})_{n\times n}$，则其补图$\bar{G}$的邻接矩阵为$A_{\bar{G}}=(\bar{a}_{i j})_{n\times n}$为：  
$$
\\\bar{a}_{i j}=f(x)=\left\{\begin{array}{r l r}&{~~~~~~~~1-a_{i j},~i\neq j}&\\ &{0,~~~~~~~~~~~~~~~~~~i=j}&\end{array}\right.
$$  
例如，对于图8-18 所示的图 $G_{1}$和图 $G_{2}$，图 $G_{1}$ 是图 $G_{2}$ 的补图，图 $G_{2}$ 也是图 $G_{1}$的补图。显然， $K_{n}$ 的补图是 $n$ 阶零图，反之亦然。  
![图8-18 补图运算 ](images/bc253e401f30298f9209681ddc8b93ec627ca9bfb8d5b9c17929af79e1390112.jpg)"
补运算,概念,"['第一章  集合与计数基础', '§ 1.1 集合的基本知识', '1.1.3 集合的基本运算', '二、差运算与补运算']","{'实体类型': '概念', '定义': '令U表示全集，则A的补集U-A={x|x∈U且x∉A}称为A的补集，亦称A为对集合A的补运算', '特点': '与全集构成互补关系'}",,4,"对于任意给定的两个集合$A$ 和$B$，有时需要将属于$A$ 但不属于$B$ 的所有元素取出来构成一个新的集合，由此得到如下集合差运算的概念：  
【定义1.12】对于任意给定的两个集合$A$ 和$B$，集合$\cdot A-B=\{x|x\in A$并且$x\notin B\}$称为$A$ 与$B$ 的差集，$A-B$亦称为集合𝐴与$B$的差运算；令$U$表示全集，则${\bar{A}}=U-A=\{x|x\in$$U$且$x\notin A\}$称为$A$ 的补集，亦称$\bar{A}$为对集合$A$ 的补运算。  
一般来说，所谓两个对象互补，是指这两个对象之间无共同部分并且若将两者合并则构成一个完整的整体。如果将全集𝑈看成是一个完整的整体，那么任何一个集合与它的补集显然构成一种互补关系。图1-3 为集合差运算和补运算的文氏图。  
![](images/3dd3ff26327d44646f11d3b3940708dbd5563cf42578e139e0a56534e35c5eff.jpg)
图1-3 差、补运算的文氏图  
不难看出，集合的差运算和补运算其实就是实数减法运算在集合论中的推广。根据集合差运算与补运算的定义，不难证明它们满足如下基本运算性质：  
(1) 矛盾律：对于任意给定的集合$A$，有：$A\cap{\bar{A}}=\emptyset$；(2) 排中律：对于任意给定的集合$A$，有：$A\cup\bar{A}=U$  
(3) 双重否定律：对于任意给定的集合$A$，有：$\bar{\bar{A}}=A$  
(4) 德摩根律：对于任意给定的两个集合$A$ 和$B$，有： $\overline{{A\cup B}}=\bar{A}\cap\bar{B},\,\,\,\overline{{A\cap B}}=\bar{A}\cup\bar{B}$  
(5) 对于任意给定的三个集合$A$、$B$ 和$C$，有：  
$A\cup(B\cup C)=(A\cup B)\cup C;\;A\cap(B\cap C)=(A\cap B)\cap C\circ$ $A\cap(B\cup C)=(A\cap B)\cup(A\cap C);\;A\cup(B\cap C)=(A\cup B)\cap(A\cup C)\,.$ $A\cap(A\cup B)=A;\,\,\,A\cup(A\cap B)=A\,.$  
现仅以德摩根律为例给出上述运算性质的证明，读者可自行给出其余证明。【例题1.22】对于任意给定的两个集合$A$ 和$B$，证明如下德摩根律：  
$$
{\overline{{A\cup B}}}={\bar{A}}\cap{\overline{{B}}}\,;\;{\overline{{A\cap B}}}={\bar{A}}\cup{\bar{B}}
$$"
解释,概念,"['第四章  谓词演算与推理', '§ 4.2  谓词公式与等值演算', '4.2.3 谓词公式的解释与分类']","{'实体类型': '概念', '定义': '对谓词公式中常量符号、变量符号、函数符号、谓词符号进行具体解释，使其具有确定的含义和真值取值', '组成': '确定非空的个体域集合、常量符号的含义、函数的具体形式、谓词符号的具体形式'}",,3,"我们知道，对于一个命题公式，确定其真值取值状态是比较简单的，只需对命题公式中各个变量逐个指派真值便可得到命题公式的真值，而且在命题变量不是太多的情况下还可通过对命题变量真值指派的各种状态进行枚举的方式列出命题公式的真值表。然而，要确定一个谓词公式的真值取值状态，通常就没有这么简单了。  
例如，要确定谓词公式$(\forall x)(H(x){\rightarrow}D(x))$的真值，首先要确定其个体域，然后还要确定谓词$H(x)$和$D(x)$的具体含义。如果使用全总个体域$H(x)$表示 $x$是人$D(x)$表示 $x$会死的，则该谓词公式的取值为真，若将$D(x)$表示为 $x$是勇敢的，则谓词公式的取值为真为假。  
一般来说，对于任意给定的谓词公式，其含义与真值取值不仅依赖于个体域，依赖于公式中各个个体变量的取值状况，还依赖于对公式中谓词符号、函数符号、常量符号具体含义的确认，这些所有的依赖信息构成对谓词公式的解释。如果不对谓词公式中常量符号、变量符号、函数符号、谓词符号进行具体的解释，则公式就没有确定的含义和确定的真值取值.下面给出关于谓词公式解释的具体定义：  
【定义4.15】 谓词公式$G$的每一个解释$I$由如下四个部分组成：  
（1）确定非空的个体域集合$D$；  
（2）确定公式$G$ 中的每个常量符号的含义，即指定$D$ 中的某个特定的元素；  
（3）确定公式$G$ 中的每个$n$元函数的具体形式，即对于公式$G$ 中每个$n$元函数分别指定一个从$D^{n}$ 到$D$ 中的特定函数与之对应；  
（4）确定公式$G$ 中的每个$n$元谓词符号的具体形式，即对于公式$G$ 中每个$n$元谓词符号分别指定一个从$D^{n}$ 到$\{0,1\}$的特定函数与之对应。  
易知，对于任意一个给定的谓词公式，如果该公式是封闭公式，即不含有任何自由个体变量，则该公式在任何解释下均有确定的真值。  
由上述例题可知，与命题公式一样，有些谓词公式在有些解释下为真，在另外一些解释下为假；而有些谓词公式则在所有解释下均为真；还有一些谓词公式在所有解释下均为假。由此可以得到如下有效公式、矛盾公式和可满足公式的定义：  
【定义4.16】 对于任意一个给定的谓词公式$G$，如果$G$ 在其所有的解释$I$下的真值取值为真，则称$G$ 称为有效公式；如果$G$ 在其所有的解释$I$下的真值取值都为假，则称$G$为矛盾公式；如果$G$ 不是矛盾公式，则称其为可满足公式。  
从上述定义可知三种特殊公式之间具有如下关系：有效公式的否定为矛盾公式；矛盾公式的否定为有效公式；有效公式一定为可满足公式。"
解释或赋值,定义,"['第三章  命题演算与推理', '§ 3.2 命题公式与等值演算', '3.2.1 命题公式的基本知识', '二、命题公式的解释与真值表']","{'实体类型': '定义', '定义': '对命题公式中每个命题变量分别指定真值，得到的一组真值'}",,4,"命题公式是由命题变量、，其中命题变量泛指的无确定真值的、抽象的命题。因此，命题公式一般没有确定的真值。但是，如果对命题公式中每个命题变量分别指定确定真值的具体命题，那么命题公式就变成一个具有确定真值的复合命题。由此得到如下关于命题公式解释或赋值的概念：  
【定义3.9】设$P_{1},P_{2},\cdots,P_{n}$是出现在命题公式$G$中所有命题变量，对$P_{1},P_{2},\cdots,P_{n}$分别指定真值，由此得到的一组真值称为命题公式$G$的一个解释或赋值，通常记为$\smash{I_{\circ}}$。  
命题公式中的每个变量都有𝑇和$F$两种真值指定方式，对于$\cdot n$个命题变量的公式就有$\cdot2^{n}$个不同解释。例如，含2 个命题变量公式有4 种不同解释，含有3 个变量公式有8 种不同解释。命题公式在每种解释下都会有相应的真值取值，由此可得如下定义：  
【定义3.10】对于任意一个给定的命题公式$G$，如果该命题公式在某种解释下的真值取值为真，则称该解释为$G$的成真赋值或弄真赋值；如果该命题公式在某种解释下的真值取值为假，则称该解释为$G$的成假赋值或弄假赋值。  
为直观表达命题公式在不同解释下的取值状态，在变量不太多的情况下，可将命题公式在所有不同解释下的取值状态枚举出来，做成一个表格。由此得到如下真值表的概念：  
【定义3.11】对于任意一个含有$\cdot_{n}$个命题变量的命题公式$G$，$G$的所有解释以及在每个解释下真值取值所构成的表格称为$G$的真值表。  
在真值表中，一般将命题公式中的命题变量放在最左边，将命题公式在解释下的真值取值结果放在右边并加粗表示。对于比较复杂的公式，通常将计算命题公式真值的中间结果依次放在表中，或者中间结果放在相关逻辑联结词的下方。此外，为节约篇幅，通常将含有相同命题变量个数的多个命题公式真值取值结果合并到一个真值表中。  
表3-4  例题3.11 的真值表
![](images/b78e9e94318e03b09f7351596ca332bf194681eedad2d1334bdc1ed7b6f02552.jpg)"
评判表,工具,"['第六章 特殊关系模型', '§ 6.3 偏序关系与元素比较', '6.4.2 得分评判问题']","{'实体类型': '工具', '定义': '用于对选手进行打分评判的表格', '应用': '记录评判员对选手的比较结果'}",,3,"在很多需要排名次的非相互对抗场合，如歌手大赛中的参赛选手、成员的考评、电视节目中主持人大赛中参赛选手的考评等，其评断标准并不像球赛中进球、失球那样准确无误，往往由评判员们分别打分，通过分数计算名次。然而，分数有其不公平的一面。例如，甲、乙、丙三名歌手的得分分别为94 分，92 分，90 分。  
甲的分数-乙的分数$=$乙的分数-丙的分数。  
虽然这两个差相等，但并不能说明甲高出乙的水平等于乙高出丙的水平，因为这里1 分所表示的水平差距并不唯一确定，而是与评判者紧密相关。又如，对于期末考试中某班平均分语文85 分与数学60 分，该班某学生语文80 分，数学70 分，尽管$80>70$，也不能说明这名学生语文学的比数学好。因为这里分数基准点是不一致的。因此有了“标准分”和“等级记分”等科学记分方法，如 “优秀，良好，合格，不合格”四级打分法便是其中一种。  
由偏序关系的定义可知，任何排名次必是一个偏序关系，并且在很大情况下应是线性关系。因此，在上述排名场合（如歌手大赛考评等）可使用“0-1”法记分，并利用偏序关系的反对称性，在比赛过程对选手进行动态排名。下面结合具体实例介绍具体排名过程：  
设有 $A_{1},A_{2},A_{3},A_{4},A_{5},A_{6}$ 这 6  名参赛者，按其下标次序出场比赛。分别为每名评判员准 备一张如表$6–4$ 所示的表格用于对选手进行打分评判。  
表6-4 评判表
![](images/4c85af2d68ddc01acb3d234836cc3dd6fee35852bbb1e27a76917d56b5336e04.jpg)  
每个评判员的打分方法如下：当$A_{2}$参赛结束时，立即把他与$A_{1}$比较，谁更好一些，若$A_{2}$好一些，在表6-4 的$\mathsf{C}_{21}$位置填上1，若$A_{1}$好一些，则在该位置填上0；$A_{3}$参赛结束后，依次与$A_{1}$、$A_{2}$比较谁好一些，好一些为1，差一些为0，并把这两个比较出来的数依次填在${\mathsf C}_{31}$和  
${\mathsf{C}}_{32}$的位置上。如此下去，知道所有的选手参赛结束。即有：  
$$
C_{ij}=\begin{cases}1&\quad\text{当}A_i\text{比}A_j\text{好时}\\0&\quad\text{当}A_i\text{比}A_j\text{好时}\end{cases}\quad(j<i)\quad\text{(6-5)}
$$  
注意的是，当某一位选手比赛结束都要与他参赛的每一名选手比较而且给出谁好谁差的结论(是1 还是0)。也可以利用偏序关系的传递性减少比较次数。如$A_{5}$比$A_{1}$强，而此时已经有$\mathsf{C}_{31}=\mathsf{C}_{41}=0$，则必有${\mathsf{C}}_{53}={\mathsf{C}}_{54}=1$。表6-5 是某一位评判员所裁判的结果。  
表6-5   评判结果
![](images/0095a64294f10a0d76e1eae14906fdb5c9f5e6a5bc895b20e56aa4e7f6a6e039.jpg)  
如$|A_{5}$行说明$A_{5}$比$A_{1}$好，比$A_{2}$差，比$A_{3}$好，比$A_{4}$  
然后对表6-5 进行整理：首先利用偏序关系的反对称性填充表格的上角，上表虚线为对称轴，右上角各个位置(如$\mathsf C_{12}$)看它的对称位置(即$\mathsf{C}_{21}$)上的数，若其对称位置上数为$1\left(\mathbb{C}_{21}=1\right)$,则它为$0\left(\mathsf{C}_{12}=0\right)$)；若其对称位置上的数为1，则它就是0。即有：  
$$
\mathrm{C}_{ij}=\begin{cases}0&\quad\text{当C}_{ji}=1\text{时}\\1&\quad\text{当C}_{ji}=0\text{时}\end{cases}\quad(i<j)\quad\text{(6-6)}
$$  
完成后如表6-6 所示：  
表6-6 对评判结果的整理
![](images/620931865382a676e3093ac6d3295347415e7bef2cda108424f0318f6d3c3129.jpg)  
把表6-6 各行的数字加起来填入总分列中（倒数第二列），这个列中各数分别为其所在行中相应选手的得分。它们不可能有两个相等的数，否则说明评判或填表有误应作废。把这个列的各数相加填入这一列最后一格为总分和$σ$。事实上$σ$是一个固定数$σ=m(m-1)/2$其中$m$为参赛选手的人数。本例中$m=6$，故有$σ=6*(6-1)/2=15$。  
把表6-6 中各列数字加起来，填入最后一行（即总分行）的相应位置上，分别为其所在列上相应选手的失分，以虚线为对称轴和其对称位置上的得分加起来应该等于$m-1$，  
减1 是因为自己不与自己比较，总分行总分和也等于$m(m-1)/2$。表的最后一列是把各选手的得分转化为人们习惯的百分制，本例中用的是$(m-1)*$得分数$+60$，以避免出现低于60 分的情况，最后把所有评判员有效给出的各个选手成绩相应加起来求平均成绩，按平均成绩高低排名次，此时可能出现并列名次。"
谓词,概念,"['4.1.3  量词与特性谓词', '4.5.1 摘香蕉问题', '§ 4.5 谓词逻辑的应用', '三、谓词与谓词填式', '三、特性谓词及其应用', '一、含变量的语句', '第五章 关系模型与理论', '5.5.2 关系演算模型', '第四章  谓词演算与推理', '§ 4.1 个体词、谓词与量词', '4.1.1  逻辑与谓词逻辑', '§ 5.5 关系模型的应用', '4.1.2  命题函数与谓词']","{'实体类型': '概念', '定义': ['表示对象的属性或对象之间的联系，相当于陈述句中的谓语部分；命题中的谓语部分', '原子命题中的谓语部分不做任何抽象或改变而直接继承到命题函数之中', '表示对象性质或关系的词', '简单命题函数中具有实质性含义的部分，刻画了命题函数中个体变量的性质与联系', '描述个体性质或关系的表达式', '用于表示二维表的多元谓词，其中个体变元是表的属性，元组是使谓词为真的赋值'], '特点': ['用于描述对象的性质或关系', '刻画了变量的性质和变量之间的联系', '通常指含有个体变元的谓词，即n元谓词', '不同谓词的个体变量和个体域经常会有所不同', '描述事实性知识和过程性知识'], '应用': ['描述个体的性质或者个体之间的联系', '用于关系表的数据操作，如插入、删除和查询优化'], 'name': '谓词'}",,2,谓词逻辑的核心思想是将作为命题的陈述句分解成个体词与谓词这两个更为基本的要素。个体词表示各种具体或抽象的对象，相当于陈述句中的主语或宾语部分；谓词则表示对象的属性或对象之间的联系，相当于陈述句中的谓语部分。不同个体词会使命题产生不同含义以至于形成不同真值，同一个体词使用场合的不同也可能使命题的真值产生变化。为此，谓词逻辑引入量词概念，并通过将其与谓词相结合实现对个体词含义的准确限定。个体词、谓词和量词是谓词逻辑中最核心、最基本的概念，本节通过讨论这三个概念及其性质比较系统地介绍谓词逻辑中最基本的知识，包括谓词逻辑的由来、命题函数与谓词的概念、量词与特性谓词的概念、谓词逻辑的符号化等。
谓词公式,概念,"['4.2.2 变量的自由与约束', '5.5.2 关系演算模型', '第五章 关系模型与理论', '三、双量词式的等值与蕴含', '4.2.1 谓词公式的概念', '4.2.4 谓词公式的等值与蕴含', '§ 5.5 关系模型的应用', '4.2.3 谓词公式的解释与分类', '§ 4.2  谓词公式与等值演算', '第四章  谓词演算与推理', '二、谓词公式的蕴含关系']","{'实体类型': '概念', '定义': ['通过符号化将现实问题抽象成谓词符号形式，采用谓词公式的方式实现对谓词符号的表达，比命题公式更加复杂，深入到概念层次，需要用到更多种类的特殊符号来表达命题在概念层次上的各种组件；含有命题变量的表达式，通过量词实现对变量的约束；由个体变量、谓词符号、函数符号和常量符号组成的表达式', '由谓词、量词和逻辑联结词组成的表达式', '包含量词和谓词的数学表达式'], '核心内容': '谓词符号的表达系统和演算机制', '组成': '个体常量符号、个体变量符号、个体函数符号、谓词符号', '特点': ['具有强大的表达能力，能有效地表达个体以及个体之间的复杂映射关系；真值取值依赖于个体域、个体变量的取值状况以及对谓词符号、函数符号、常量符号的具体含义的确认', '可以包含多个量词，量词的排列影响公式的含义'], '变量类型': '分为自由变量和约束变量两种类型', '应用': ['用于逻辑演算与推理', '通过析取运算实现数据插入，合取运算实现数据删除，推理实现查询优化'], 'name': '谓词公式'}",,2,谓词逻辑的问题求解思路与命题逻辑类似，首先通过符号化将现实问题抽象成谓词符号形式，然后使用谓词逻辑的符号演算机制实现对问题的求解。因此，谓词符号的表达系统和演算机制是谓词逻辑理论的核心内容。本节着重学习这些内容，包括谓词公式的概念、自由变元与约束变元、谓词公式的解释与分类、谓词公式的等值关系与演算等。
"谓词公式$H$是谓词公式$G_{1},G_{2}\\cdots G_{n}$的逻辑结论",定理,"['第四章  谓词演算与推理', '§ 4.4 谓词逻辑的推理', '4.4.1 谓词公式推演系统']","{'实体类型': '定理', '条件': '当且仅当下式：$G_{1}\\\\wedge G_{2}\\\\wedge\\\\cdots\\\\wedge G_{n}\\\\to H$为有效公式'}",,3,"谓词公式的推演系统与命题公式的推演系统非常类似，主要由有效推理的基本概念、事实库、公理库和推理规则这几个部分组成。事实库和公理库构成谓词公式推理的基本依据，推理规则是谓词公式推理的核心机制。谓词公式推演系统的公理库和推理规则不仅涵盖了命题公式的推演系统的所有相关内容，而且更加丰富、复杂。  
谓词公式有效推理的概念与命题逻辑推理非常相似，具体定义如下：  
【定义4.22】设$G_{1},G_{2}\cdots G_{n}$，$\mathrm{H}$ 是一些谓词公式，如果它们满足下列性质：对于这些公式的任意一个解释I，$G_{1},G_{2}\cdots G_{n}$在该解释下同时为真的情况下$H$在该解释下也为真，则称公式$G_{1},G_{2}\cdots G_{n}$可有效推出公式$\mathrm{H}$，或称由$G_{1},G_{2}\cdots G_{n}$得到H 的逻辑推理为有效推理，记为$G_{1},G_{2}\cdots G_{n}\Rightarrow H$，并称$G_{1},G_{2}\cdots G_{n}$为推理前提，$\mathrm{H}$ 为$G_{1},G_{2}\cdots G_{n}$的逻辑结论。  
从上述定义不难看出，谓词逻辑推理的形式结构与命题逻辑推理的形式结构一致，是命题逻辑推理的自然推广。  
【定理4.6】谓词公式$H$是谓词公式$G_{1},G_{2}\cdots G_{n}$的逻辑结论，当且仅当下式：  
$$
G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\to H\tag{4-14}
$$  
为有效公式。  
上述定理表明谓词逻辑有效推理的过程就是证明谓词逻辑蕴含式的过程，这与命题逻辑的有效推理完全一致。  
谓词公式的推理依据主要是谓词公式推演系统中的事实库和公理库。事实库由具体谓词逻辑推理实例的所有前提条件以及推理过程中产生的有效中间结论组成；公理库不仅包含命题逻辑推演系统的公理库，即关于命题公式的24 个基本等值式和9 个基本永真蕴含式，而且还包含了关于谓词公式的所有基本等值式和基本逻辑蕴含式，具体可参加本章4.2.4 节中相关内容，这里不再一一罗列。  
现在着重介绍谓词公式的推理规则。由于在谓词合式公式中含有大量的量词，直接对其进行推理显然十分不便。为此，谓词公式推演系统引入一些专门处理量词的规则，以便在需要的时候可以方便地增加或消除量词。谓词逻辑中主要有全称特指、存在特指、全称推广和存在推广这四条基本的量词处理规则，其中全称特指和存在特指消除量词的规则，全称推广和存在推广则是添加量词的规则。下面具体介绍这些规则：  
1．全称特指规则(简称US 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)\forall x\ P(x)\Rightarrow\ P(y);\ (2)\forall x\ P(x){\Rightarrow}\ P(c)
$$  
US 规则的基本含义是：如果$\forall x\;\;P(x)$为真，那么对于论域中任何指定的个体$.c$，必有${P(c)}$为真。其中，$P$ 是谓词，(1)中的$y$ 是任意不在$P(x)$中约束出现的个体变量；(2)中的c为个体域中任意指定的一个个体常量。  
当谓词公式$P(x)$中不含任何量词和其它个体变量时，$US $规则显然不需要附加任何限制条件。但是，若$P(x)$中包含量词或其它个体变量时，(1)式中的约束“$y$ 是任意不在$P(x)$中约束出现的个体变量”就是必须的。例如，设$P(x)=\exists y(x<y)$，则$P(x)$在实数域上显然是真命题。但是，当$P(x)$中的$x$取𝑦时得到的$P(y)=\exists y(y<y)$显然是假命题。因此，限制引入的变量“不是在$P(x)$中约束出现的个体变量”是任何规则在引入变量时必需遵守的约定。  
2．存在特指规则(简称ES 规则)
$$
\exists x\ P(x)\Rightarrow\ P(c)
$$  
ES 规则的基本含义是：如果$\exists x$ $P(x)$为真，那么在个体域中必然至少存在某一个个体𝑐，使得$P(c)$为真。其中，$c$ 为个体域中使$P$ 成立的特定个体常量。  
当谓词公式$P(x)$中自由变量只是$x$的时候，上述规定可以保证使用ES 规则引入个体符号$c$ 的正确性。但是，如果谓词公式$P(x)$还含有其它自由个体变量，例如还有自由变量𝑦，那么使用ES 规则引入的符号c必须是以𝑦为自变量的个体函数，即$C(y)$。此外，还应当注意，在应用ES 规则时，其指定的个体$c$ 并不是任意含义下的自由变量，$c$ 的本质含义是某个或某些个体。因此，每次使用ES 规则指定的特定个体不能用之前的ES 规则或US 规则确定的个体替代，否则就会引起个体指代的混淆和错误。因为通常不能保证某次ES 指定的个体能够与其它次ES 或US 指定的个体之间具有必然的联系。  
3．全称推广规则(简称UG 规则)：  
$$
P(\boldsymbol{y})\Rightarrow\ \forall\boldsymbol{x}\ \ P(\boldsymbol{x})
$$
UG 规则的基本含义是：如果个体变量$y$在个体域内取到每一个个体时都有$P(y)$为真，那么必有$\forall x\;\;P(x)$为真。这里要求$x$既不是$P(y)$中约束变量也不是$P(y)$中的自由变量，即要求个体变量$x$不能在$P(y)$中出现。  
4．存在推广规则(简称EG 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)P(y)\Rightarrow\ \exists x\ P(x);\ (2)P(c)\Rightarrow\ \exists x\ P(x)
$$  
UG 规则的基本含义是：如果对于个体域中某个或某些指定的个体$.c$满足$P(c)$为真，那么必有 $\exists x P(x)$为真。其中，(1)式要求$P(y)$中无自由变量$x$；(2)式中要求$c$为个体域中的某个或某些个体常量。  
由以上分析可知，上述四个规则表面上看起来非常简单，但要能够做到真正理解并正确使用则不是一件容易的事情，实际使用时往往稍不注意就会出现错误。下面举例说明："
谓词公式推演系统,概念,"['第四章  谓词演算与推理', '§ 4.4 谓词逻辑的推理', '4.4.1 谓词公式推演系统']","{'实体类型': '概念', '组成部分': '有效推理的基本概念、事实库、公理库和推理规则', '基本依据': '事实库和公理库', '核心机制': '推理规则', '特点': '涵盖了命题公式的推演系统的所有相关内容，且更加丰富、复杂'}",,3,"谓词公式的推演系统与命题公式的推演系统非常类似，主要由有效推理的基本概念、事实库、公理库和推理规则这几个部分组成。事实库和公理库构成谓词公式推理的基本依据，推理规则是谓词公式推理的核心机制。谓词公式推演系统的公理库和推理规则不仅涵盖了命题公式的推演系统的所有相关内容，而且更加丰富、复杂。  
谓词公式有效推理的概念与命题逻辑推理非常相似，具体定义如下：  
【定义4.22】设$G_{1},G_{2}\cdots G_{n}$，$\mathrm{H}$ 是一些谓词公式，如果它们满足下列性质：对于这些公式的任意一个解释I，$G_{1},G_{2}\cdots G_{n}$在该解释下同时为真的情况下$H$在该解释下也为真，则称公式$G_{1},G_{2}\cdots G_{n}$可有效推出公式$\mathrm{H}$，或称由$G_{1},G_{2}\cdots G_{n}$得到H 的逻辑推理为有效推理，记为$G_{1},G_{2}\cdots G_{n}\Rightarrow H$，并称$G_{1},G_{2}\cdots G_{n}$为推理前提，$\mathrm{H}$ 为$G_{1},G_{2}\cdots G_{n}$的逻辑结论。  
从上述定义不难看出，谓词逻辑推理的形式结构与命题逻辑推理的形式结构一致，是命题逻辑推理的自然推广。  
【定理4.6】谓词公式$H$是谓词公式$G_{1},G_{2}\cdots G_{n}$的逻辑结论，当且仅当下式：  
$$
G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\to H\tag{4-14}
$$  
为有效公式。  
上述定理表明谓词逻辑有效推理的过程就是证明谓词逻辑蕴含式的过程，这与命题逻辑的有效推理完全一致。  
谓词公式的推理依据主要是谓词公式推演系统中的事实库和公理库。事实库由具体谓词逻辑推理实例的所有前提条件以及推理过程中产生的有效中间结论组成；公理库不仅包含命题逻辑推演系统的公理库，即关于命题公式的24 个基本等值式和9 个基本永真蕴含式，而且还包含了关于谓词公式的所有基本等值式和基本逻辑蕴含式，具体可参加本章4.2.4 节中相关内容，这里不再一一罗列。  
现在着重介绍谓词公式的推理规则。由于在谓词合式公式中含有大量的量词，直接对其进行推理显然十分不便。为此，谓词公式推演系统引入一些专门处理量词的规则，以便在需要的时候可以方便地增加或消除量词。谓词逻辑中主要有全称特指、存在特指、全称推广和存在推广这四条基本的量词处理规则，其中全称特指和存在特指消除量词的规则，全称推广和存在推广则是添加量词的规则。下面具体介绍这些规则：  
1．全称特指规则(简称US 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)\forall x\ P(x)\Rightarrow\ P(y);\ (2)\forall x\ P(x){\Rightarrow}\ P(c)
$$  
US 规则的基本含义是：如果$\forall x\;\;P(x)$为真，那么对于论域中任何指定的个体$.c$，必有${P(c)}$为真。其中，$P$ 是谓词，(1)中的$y$ 是任意不在$P(x)$中约束出现的个体变量；(2)中的c为个体域中任意指定的一个个体常量。  
当谓词公式$P(x)$中不含任何量词和其它个体变量时，$US $规则显然不需要附加任何限制条件。但是，若$P(x)$中包含量词或其它个体变量时，(1)式中的约束“$y$ 是任意不在$P(x)$中约束出现的个体变量”就是必须的。例如，设$P(x)=\exists y(x<y)$，则$P(x)$在实数域上显然是真命题。但是，当$P(x)$中的$x$取𝑦时得到的$P(y)=\exists y(y<y)$显然是假命题。因此，限制引入的变量“不是在$P(x)$中约束出现的个体变量”是任何规则在引入变量时必需遵守的约定。  
2．存在特指规则(简称ES 规则)
$$
\exists x\ P(x)\Rightarrow\ P(c)
$$  
ES 规则的基本含义是：如果$\exists x$ $P(x)$为真，那么在个体域中必然至少存在某一个个体𝑐，使得$P(c)$为真。其中，$c$ 为个体域中使$P$ 成立的特定个体常量。  
当谓词公式$P(x)$中自由变量只是$x$的时候，上述规定可以保证使用ES 规则引入个体符号$c$ 的正确性。但是，如果谓词公式$P(x)$还含有其它自由个体变量，例如还有自由变量𝑦，那么使用ES 规则引入的符号c必须是以𝑦为自变量的个体函数，即$C(y)$。此外，还应当注意，在应用ES 规则时，其指定的个体$c$ 并不是任意含义下的自由变量，$c$ 的本质含义是某个或某些个体。因此，每次使用ES 规则指定的特定个体不能用之前的ES 规则或US 规则确定的个体替代，否则就会引起个体指代的混淆和错误。因为通常不能保证某次ES 指定的个体能够与其它次ES 或US 指定的个体之间具有必然的联系。  
3．全称推广规则(简称UG 规则)：  
$$
P(\boldsymbol{y})\Rightarrow\ \forall\boldsymbol{x}\ \ P(\boldsymbol{x})
$$
UG 规则的基本含义是：如果个体变量$y$在个体域内取到每一个个体时都有$P(y)$为真，那么必有$\forall x\;\;P(x)$为真。这里要求$x$既不是$P(y)$中约束变量也不是$P(y)$中的自由变量，即要求个体变量$x$不能在$P(y)$中出现。  
4．存在推广规则(简称EG 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)P(y)\Rightarrow\ \exists x\ P(x);\ (2)P(c)\Rightarrow\ \exists x\ P(x)
$$  
UG 规则的基本含义是：如果对于个体域中某个或某些指定的个体$.c$满足$P(c)$为真，那么必有 $\exists x P(x)$为真。其中，(1)式要求$P(y)$中无自由变量$x$；(2)式中要求$c$为个体域中的某个或某些个体常量。  
由以上分析可知，上述四个规则表面上看起来非常简单，但要能够做到真正理解并正确使用则不是一件容易的事情，实际使用时往往稍不注意就会出现错误。下面举例说明："
谓词公式有效推理,定义,"['第四章  谓词演算与推理', '§ 4.4 谓词逻辑的推理', '4.4.1 谓词公式推演系统']","{'实体类型': '定义', '内容': '设$G_{1},G_{2}\\\\cdots G_{n}$，$\\\\mathrm{H}$ 是一些谓词公式，如果它们满足下列性质：对于这些公式的任意一个解释I，$G_{1},G_{2}\\\\cdots G_{n}$在该解释下同时为真的情况下$H$在该解释下也为真，则称公式$G_{1},G_{2}\\\\cdots G_{n}$可有效推出公式$\\\\mathrm{H}$，或称由$G_{1},G_{2}\\\\cdots G_{n}$得到H 的逻辑推理为有效推理，记为$G_{1},G_{2}\\\\cdots G_{n}\\\\Rightarrow H$，并称$G_{1},G_{2}\\\\cdots G_{n}$为推理前提，$\\\\mathrm{H}$ 为$G_{1},G_{2}\\\\cdots G_{n}$的逻辑结论'}",,3,"谓词公式的推演系统与命题公式的推演系统非常类似，主要由有效推理的基本概念、事实库、公理库和推理规则这几个部分组成。事实库和公理库构成谓词公式推理的基本依据，推理规则是谓词公式推理的核心机制。谓词公式推演系统的公理库和推理规则不仅涵盖了命题公式的推演系统的所有相关内容，而且更加丰富、复杂。  
谓词公式有效推理的概念与命题逻辑推理非常相似，具体定义如下：  
【定义4.22】设$G_{1},G_{2}\cdots G_{n}$，$\mathrm{H}$ 是一些谓词公式，如果它们满足下列性质：对于这些公式的任意一个解释I，$G_{1},G_{2}\cdots G_{n}$在该解释下同时为真的情况下$H$在该解释下也为真，则称公式$G_{1},G_{2}\cdots G_{n}$可有效推出公式$\mathrm{H}$，或称由$G_{1},G_{2}\cdots G_{n}$得到H 的逻辑推理为有效推理，记为$G_{1},G_{2}\cdots G_{n}\Rightarrow H$，并称$G_{1},G_{2}\cdots G_{n}$为推理前提，$\mathrm{H}$ 为$G_{1},G_{2}\cdots G_{n}$的逻辑结论。  
从上述定义不难看出，谓词逻辑推理的形式结构与命题逻辑推理的形式结构一致，是命题逻辑推理的自然推广。  
【定理4.6】谓词公式$H$是谓词公式$G_{1},G_{2}\cdots G_{n}$的逻辑结论，当且仅当下式：  
$$
G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\to H\tag{4-14}
$$  
为有效公式。  
上述定理表明谓词逻辑有效推理的过程就是证明谓词逻辑蕴含式的过程，这与命题逻辑的有效推理完全一致。  
谓词公式的推理依据主要是谓词公式推演系统中的事实库和公理库。事实库由具体谓词逻辑推理实例的所有前提条件以及推理过程中产生的有效中间结论组成；公理库不仅包含命题逻辑推演系统的公理库，即关于命题公式的24 个基本等值式和9 个基本永真蕴含式，而且还包含了关于谓词公式的所有基本等值式和基本逻辑蕴含式，具体可参加本章4.2.4 节中相关内容，这里不再一一罗列。  
现在着重介绍谓词公式的推理规则。由于在谓词合式公式中含有大量的量词，直接对其进行推理显然十分不便。为此，谓词公式推演系统引入一些专门处理量词的规则，以便在需要的时候可以方便地增加或消除量词。谓词逻辑中主要有全称特指、存在特指、全称推广和存在推广这四条基本的量词处理规则，其中全称特指和存在特指消除量词的规则，全称推广和存在推广则是添加量词的规则。下面具体介绍这些规则：  
1．全称特指规则(简称US 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)\forall x\ P(x)\Rightarrow\ P(y);\ (2)\forall x\ P(x){\Rightarrow}\ P(c)
$$  
US 规则的基本含义是：如果$\forall x\;\;P(x)$为真，那么对于论域中任何指定的个体$.c$，必有${P(c)}$为真。其中，$P$ 是谓词，(1)中的$y$ 是任意不在$P(x)$中约束出现的个体变量；(2)中的c为个体域中任意指定的一个个体常量。  
当谓词公式$P(x)$中不含任何量词和其它个体变量时，$US $规则显然不需要附加任何限制条件。但是，若$P(x)$中包含量词或其它个体变量时，(1)式中的约束“$y$ 是任意不在$P(x)$中约束出现的个体变量”就是必须的。例如，设$P(x)=\exists y(x<y)$，则$P(x)$在实数域上显然是真命题。但是，当$P(x)$中的$x$取𝑦时得到的$P(y)=\exists y(y<y)$显然是假命题。因此，限制引入的变量“不是在$P(x)$中约束出现的个体变量”是任何规则在引入变量时必需遵守的约定。  
2．存在特指规则(简称ES 规则)
$$
\exists x\ P(x)\Rightarrow\ P(c)
$$  
ES 规则的基本含义是：如果$\exists x$ $P(x)$为真，那么在个体域中必然至少存在某一个个体𝑐，使得$P(c)$为真。其中，$c$ 为个体域中使$P$ 成立的特定个体常量。  
当谓词公式$P(x)$中自由变量只是$x$的时候，上述规定可以保证使用ES 规则引入个体符号$c$ 的正确性。但是，如果谓词公式$P(x)$还含有其它自由个体变量，例如还有自由变量𝑦，那么使用ES 规则引入的符号c必须是以𝑦为自变量的个体函数，即$C(y)$。此外，还应当注意，在应用ES 规则时，其指定的个体$c$ 并不是任意含义下的自由变量，$c$ 的本质含义是某个或某些个体。因此，每次使用ES 规则指定的特定个体不能用之前的ES 规则或US 规则确定的个体替代，否则就会引起个体指代的混淆和错误。因为通常不能保证某次ES 指定的个体能够与其它次ES 或US 指定的个体之间具有必然的联系。  
3．全称推广规则(简称UG 规则)：  
$$
P(\boldsymbol{y})\Rightarrow\ \forall\boldsymbol{x}\ \ P(\boldsymbol{x})
$$
UG 规则的基本含义是：如果个体变量$y$在个体域内取到每一个个体时都有$P(y)$为真，那么必有$\forall x\;\;P(x)$为真。这里要求$x$既不是$P(y)$中约束变量也不是$P(y)$中的自由变量，即要求个体变量$x$不能在$P(y)$中出现。  
4．存在推广规则(简称EG 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)P(y)\Rightarrow\ \exists x\ P(x);\ (2)P(c)\Rightarrow\ \exists x\ P(x)
$$  
UG 规则的基本含义是：如果对于个体域中某个或某些指定的个体$.c$满足$P(c)$为真，那么必有 $\exists x P(x)$为真。其中，(1)式要求$P(y)$中无自由变量$x$；(2)式中要求$c$为个体域中的某个或某些个体常量。  
由以上分析可知，上述四个规则表面上看起来非常简单，但要能够做到真正理解并正确使用则不是一件容易的事情，实际使用时往往稍不注意就会出现错误。下面举例说明："
谓词公式的推理依据,概念,"['第四章  谓词演算与推理', '§ 4.4 谓词逻辑的推理', '4.4.1 谓词公式推演系统']","{'实体类型': '概念', '内容': '主要是谓词公式推演系统中的事实库和公理库'}",,3,"谓词公式的推演系统与命题公式的推演系统非常类似，主要由有效推理的基本概念、事实库、公理库和推理规则这几个部分组成。事实库和公理库构成谓词公式推理的基本依据，推理规则是谓词公式推理的核心机制。谓词公式推演系统的公理库和推理规则不仅涵盖了命题公式的推演系统的所有相关内容，而且更加丰富、复杂。  
谓词公式有效推理的概念与命题逻辑推理非常相似，具体定义如下：  
【定义4.22】设$G_{1},G_{2}\cdots G_{n}$，$\mathrm{H}$ 是一些谓词公式，如果它们满足下列性质：对于这些公式的任意一个解释I，$G_{1},G_{2}\cdots G_{n}$在该解释下同时为真的情况下$H$在该解释下也为真，则称公式$G_{1},G_{2}\cdots G_{n}$可有效推出公式$\mathrm{H}$，或称由$G_{1},G_{2}\cdots G_{n}$得到H 的逻辑推理为有效推理，记为$G_{1},G_{2}\cdots G_{n}\Rightarrow H$，并称$G_{1},G_{2}\cdots G_{n}$为推理前提，$\mathrm{H}$ 为$G_{1},G_{2}\cdots G_{n}$的逻辑结论。  
从上述定义不难看出，谓词逻辑推理的形式结构与命题逻辑推理的形式结构一致，是命题逻辑推理的自然推广。  
【定理4.6】谓词公式$H$是谓词公式$G_{1},G_{2}\cdots G_{n}$的逻辑结论，当且仅当下式：  
$$
G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\to H\tag{4-14}
$$  
为有效公式。  
上述定理表明谓词逻辑有效推理的过程就是证明谓词逻辑蕴含式的过程，这与命题逻辑的有效推理完全一致。  
谓词公式的推理依据主要是谓词公式推演系统中的事实库和公理库。事实库由具体谓词逻辑推理实例的所有前提条件以及推理过程中产生的有效中间结论组成；公理库不仅包含命题逻辑推演系统的公理库，即关于命题公式的24 个基本等值式和9 个基本永真蕴含式，而且还包含了关于谓词公式的所有基本等值式和基本逻辑蕴含式，具体可参加本章4.2.4 节中相关内容，这里不再一一罗列。  
现在着重介绍谓词公式的推理规则。由于在谓词合式公式中含有大量的量词，直接对其进行推理显然十分不便。为此，谓词公式推演系统引入一些专门处理量词的规则，以便在需要的时候可以方便地增加或消除量词。谓词逻辑中主要有全称特指、存在特指、全称推广和存在推广这四条基本的量词处理规则，其中全称特指和存在特指消除量词的规则，全称推广和存在推广则是添加量词的规则。下面具体介绍这些规则：  
1．全称特指规则(简称US 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)\forall x\ P(x)\Rightarrow\ P(y);\ (2)\forall x\ P(x){\Rightarrow}\ P(c)
$$  
US 规则的基本含义是：如果$\forall x\;\;P(x)$为真，那么对于论域中任何指定的个体$.c$，必有${P(c)}$为真。其中，$P$ 是谓词，(1)中的$y$ 是任意不在$P(x)$中约束出现的个体变量；(2)中的c为个体域中任意指定的一个个体常量。  
当谓词公式$P(x)$中不含任何量词和其它个体变量时，$US $规则显然不需要附加任何限制条件。但是，若$P(x)$中包含量词或其它个体变量时，(1)式中的约束“$y$ 是任意不在$P(x)$中约束出现的个体变量”就是必须的。例如，设$P(x)=\exists y(x<y)$，则$P(x)$在实数域上显然是真命题。但是，当$P(x)$中的$x$取𝑦时得到的$P(y)=\exists y(y<y)$显然是假命题。因此，限制引入的变量“不是在$P(x)$中约束出现的个体变量”是任何规则在引入变量时必需遵守的约定。  
2．存在特指规则(简称ES 规则)
$$
\exists x\ P(x)\Rightarrow\ P(c)
$$  
ES 规则的基本含义是：如果$\exists x$ $P(x)$为真，那么在个体域中必然至少存在某一个个体𝑐，使得$P(c)$为真。其中，$c$ 为个体域中使$P$ 成立的特定个体常量。  
当谓词公式$P(x)$中自由变量只是$x$的时候，上述规定可以保证使用ES 规则引入个体符号$c$ 的正确性。但是，如果谓词公式$P(x)$还含有其它自由个体变量，例如还有自由变量𝑦，那么使用ES 规则引入的符号c必须是以𝑦为自变量的个体函数，即$C(y)$。此外，还应当注意，在应用ES 规则时，其指定的个体$c$ 并不是任意含义下的自由变量，$c$ 的本质含义是某个或某些个体。因此，每次使用ES 规则指定的特定个体不能用之前的ES 规则或US 规则确定的个体替代，否则就会引起个体指代的混淆和错误。因为通常不能保证某次ES 指定的个体能够与其它次ES 或US 指定的个体之间具有必然的联系。  
3．全称推广规则(简称UG 规则)：  
$$
P(\boldsymbol{y})\Rightarrow\ \forall\boldsymbol{x}\ \ P(\boldsymbol{x})
$$
UG 规则的基本含义是：如果个体变量$y$在个体域内取到每一个个体时都有$P(y)$为真，那么必有$\forall x\;\;P(x)$为真。这里要求$x$既不是$P(y)$中约束变量也不是$P(y)$中的自由变量，即要求个体变量$x$不能在$P(y)$中出现。  
4．存在推广规则(简称EG 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)P(y)\Rightarrow\ \exists x\ P(x);\ (2)P(c)\Rightarrow\ \exists x\ P(x)
$$  
UG 规则的基本含义是：如果对于个体域中某个或某些指定的个体$.c$满足$P(c)$为真，那么必有 $\exists x P(x)$为真。其中，(1)式要求$P(y)$中无自由变量$x$；(2)式中要求$c$为个体域中的某个或某些个体常量。  
由以上分析可知，上述四个规则表面上看起来非常简单，但要能够做到真正理解并正确使用则不是一件容易的事情，实际使用时往往稍不注意就会出现错误。下面举例说明："
谓词公式的等值关系,性质,"['第四章  谓词演算与推理', '§ 4.2  谓词公式与等值演算', '4.2.4 谓词公式的等值与蕴含', '二、谓词公式的蕴含关系']","{'实体类型': '性质', '特点': '谓词公式之间在逻辑上等价'}",,4,"如同多项式演算不仅要用到恒等式，还经常用到不等式，谓词公式的逻辑演算与推理也是不仅要用到谓词公式之间的等值关系，而且还需要用到谓词公式之间的蕴含关系。谓词公式之间的蕴含关系如同多项式代数系统中多项式之间的小于或等于关系， 具体地说， 所谓两 个谓词公式之间存在蕴含关系，其实就是两个谓词公式在任何解释下，其中一个谓词公式的真值永远不会大于另外一个谓词公式的真值。下面借助有效公式的概念给出具体定义：  
【定义4.18】假设$G$和$H$是任意两个谓词公式，如果谓词公式$G\rightarrow H$是有效公式，则称谓词公式$\pmb{G}$逻辑蕴含谓词公式$\pmb{H}$，亦称$G$ 与$H$之间具有逻辑蕴含关系，通常简称为蕴含关系，记作$G\Rightarrow H$，并称该式为谓词公式的逻辑蕴含式，通常简称为蕴含式。  
由上述定义可知，判断两个谓词公式$G$ 和$H$ 是否具有逻辑蕴含关系，关键在于证明谓词公式$G\rightarrow H$为有效公式，这种思路与证明命题公式永真蕴含关系的基本思路是一致的。类似于命题公式的永真蕴含演算系统，在谓词公式的逻辑蕴含演算系统中，通常也是先证明出一些重要的谓词公式蕴含式，然后将这些重要谓词蕴含式作为基本蕴含式进一步推演出更多的谓词公式蕴含式，这种推演过程构成了谓词公式蕴含演算的主要内容。下面不加证明地给出这些重要而基本的谓词公式蕴含式，读者可自行给出证明。  
由于谓词公式的逻辑蕴含式依据谓词公式的有效公式定义，而命题公式中永真公式的谓词公式代换实例显然是有效谓词公式，因此与前述谓词公式的等值式类似，前述命题逻辑中15 个基本永真蕴含式经过谓词公式代换后，就可以得到相应的谓词公式基本逻辑蕴含式。当然，由前述每组谓词公式基本等值式显然都可以得到两组相应的基本逻辑蕴含式，这里不再一一赘述。这里主要介绍如下与量词有关的逻辑蕴含式。  
【定理4.1】假设$G(x)$和$H(x)$是任意两个谓词公式，则存在如下逻辑蕴含关系：  
$$
\forall x G(x)\lor\forall x H(x)\Rightarrow\forall x(G(x)\lor H(x))\tag{4-7}
$$  
$$
\exists x(G(x)\land H(x))\Rightarrow\exists x G(x)\land\exists x H(x)\tag{4-8}
$$  
不难看出，上述定理的两个式子仅仅是蕴含式而不是等值式。例如对于（1）式如下解释，由这些人都跳舞或这些人都唱歌，可以推出这些人都跳舞或唱歌。但是反之不然，由这些人都跳舞或唱歌不能推出这些人都跳舞或这些人都唱歌。（2）式可做类似理解。"
谓词公式的范式,概念,"['二、无∃型前束范式', '§ 4.3 谓词公式的范式', '第四章  谓词演算与推理', '4.3.2 非等值型范式']","{'实体类型': '概念', '定义': ['谓词逻辑中谓词公式的统一表达方式', '谓词公式的一种规范形式', '谓词公式的一种标准形式'], '特点': ['比命题公式的范式复杂，不满足唯一性要求', '量词排列规整'], '性质': '除前束范式外，其它范式不满足等值性', '应用': '用于谓词逻辑推理，保持永真性或永假性'}",,2,"命题逻辑中每个命题公式都有一种统一的范式表达方式，当考察一个命题公式性质时，其范式表达方式通常起着非常重要的作用，有时候甚至是决定性作用。类似于命题逻辑，谓  
词逻辑也希望建立谓词公式的范式。由于谓词公式中存在个体变量和量词，因此其范式的建立比命题公式要复杂得多，而且所建立范式不满足唯一性要求，有的范式甚至不能满足等值。事实上，除了前束范式满足等值性之外，其它谓词公式范式均不满足等值性。值得注意的是，不满足等值性的范式有时也非常有用。例如斯科伦范式虽然不满足等值性，但对保持永真性或永假性具有保持性，可用于谓词逻辑推理。本节主要介绍两类典型的谓词公式范式，一类满足等值性，另一类不满足等值性。"
谓词公式的蕴含关系,性质,"['第四章  谓词演算与推理', '§ 4.2  谓词公式与等值演算', '4.2.4 谓词公式的等值与蕴含', '二、谓词公式的蕴含关系']","{'实体类型': '性质', '定义': '两个谓词公式在任何解释下，其中一个谓词公式的真值永远不会大于另外一个谓词公式的真值', '判断方法': '证明谓词公式G→H为有效公式'}",,4,"如同多项式演算不仅要用到恒等式，还经常用到不等式，谓词公式的逻辑演算与推理也是不仅要用到谓词公式之间的等值关系，而且还需要用到谓词公式之间的蕴含关系。谓词公式之间的蕴含关系如同多项式代数系统中多项式之间的小于或等于关系， 具体地说， 所谓两 个谓词公式之间存在蕴含关系，其实就是两个谓词公式在任何解释下，其中一个谓词公式的真值永远不会大于另外一个谓词公式的真值。下面借助有效公式的概念给出具体定义：  
【定义4.18】假设$G$和$H$是任意两个谓词公式，如果谓词公式$G\rightarrow H$是有效公式，则称谓词公式$\pmb{G}$逻辑蕴含谓词公式$\pmb{H}$，亦称$G$ 与$H$之间具有逻辑蕴含关系，通常简称为蕴含关系，记作$G\Rightarrow H$，并称该式为谓词公式的逻辑蕴含式，通常简称为蕴含式。  
由上述定义可知，判断两个谓词公式$G$ 和$H$ 是否具有逻辑蕴含关系，关键在于证明谓词公式$G\rightarrow H$为有效公式，这种思路与证明命题公式永真蕴含关系的基本思路是一致的。类似于命题公式的永真蕴含演算系统，在谓词公式的逻辑蕴含演算系统中，通常也是先证明出一些重要的谓词公式蕴含式，然后将这些重要谓词蕴含式作为基本蕴含式进一步推演出更多的谓词公式蕴含式，这种推演过程构成了谓词公式蕴含演算的主要内容。下面不加证明地给出这些重要而基本的谓词公式蕴含式，读者可自行给出证明。  
由于谓词公式的逻辑蕴含式依据谓词公式的有效公式定义，而命题公式中永真公式的谓词公式代换实例显然是有效谓词公式，因此与前述谓词公式的等值式类似，前述命题逻辑中15 个基本永真蕴含式经过谓词公式代换后，就可以得到相应的谓词公式基本逻辑蕴含式。当然，由前述每组谓词公式基本等值式显然都可以得到两组相应的基本逻辑蕴含式，这里不再一一赘述。这里主要介绍如下与量词有关的逻辑蕴含式。  
【定理4.1】假设$G(x)$和$H(x)$是任意两个谓词公式，则存在如下逻辑蕴含关系：  
$$
\forall x G(x)\lor\forall x H(x)\Rightarrow\forall x(G(x)\lor H(x))\tag{4-7}
$$  
$$
\exists x(G(x)\land H(x))\Rightarrow\exists x G(x)\land\exists x H(x)\tag{4-8}
$$  
不难看出，上述定理的两个式子仅仅是蕴含式而不是等值式。例如对于（1）式如下解释，由这些人都跳舞或这些人都唱歌，可以推出这些人都跳舞或唱歌。但是反之不然，由这些人都跳舞或唱歌不能推出这些人都跳舞或这些人都唱歌。（2）式可做类似理解。"
谓词公式等值关系,概念,"['4.2.4 谓词公式的等值与蕴含', '一、谓词公式的等值关系', '§ 4.2  谓词公式与等值演算', '第四章  谓词演算与推理']","{'实体类型': '概念', '定义': ['谓词公式之间的等值关系', '两个谓词公式在任意相同的解释下具有完全相同的真值，表达的是两个谓词公式之间的恒等关系'], '作用': '实现对谓词公式进行化简或适当的变形', '判断条件': '证明谓词公式G↔H为有效公式'}",,3,在命题逻辑中，命题公式之间的等值关系和永真蕴含关系是两种非常重要的基本关系，使用这两种关系，我们不仅可以对命题公式进行化简和适当的变形，而且还可以进行有效的命题推理。类似于命题逻辑，在谓词逻辑中也需要定义谓词公式之间的等值关系和永真蕴含关系来实现对谓词公式进行化简或适当的变形，更需要这两种关系进行谓词逻辑的推理。为此，本小节着重介绍和讨论谓词公式的等值关系和永真蕴含关系。
谓词公式等值演算系统,算法,"['第四章  谓词演算与推理', '§ 4.2  谓词公式与等值演算', '4.2.4 谓词公式的等值与蕴含', '一、谓词公式的等值关系']","{'实体类型': '算法', '主要内容': '先证明出一些重要的谓词公式等值式，然后将这些重要谓词等值式作为基本等值式进一步推演出更多的谓词公式等值式'}",,4,"谓词公式等值关系的含义与命题公式等值关系很类似，是指两个谓词公式在任意相同的解释下具有完全相同的真值，表达的是两个谓词公式之间的恒等关系。下面借助谓词公式的概念给出谓词公式等值关系的具体定义：  
【定义4.17】 假设$G$ 和$H$ 是任意两个给定的谓词公式，若公式$G\leftrightarrow H$是有效公式，则称公式$G$ 和$H$ 称为等值的，记为$G\Leftrightarrow H$，并称$G\Leftrightarrow H$为等值表达式或等值式。  
由上述定义可知，判断两个谓词公式$G$ 和$H$是否等值，关键在于证明谓词公式$G\leftrightarrow H$为有效公式，这种思路与证明命题公式等值关系的基本思路是一致的。类似于命题公式的等值演算系统，在谓词公式的等值演算系统中，通常也是先证明出一些重要的谓词公式等值式，然后将这些重要谓词等值式作为基本等值式进一步推演出更多的谓词公式等值式，这种推演过程构成了谓词公式等值演算的主要内容。下面不加证明地给出这些重要而基本的谓词公式等值式，读者可自行给出证明。  
第一组  命题公式中永真公式的谓词公式代换实例显然是有效谓词公式。因此，按命题逻辑中24 个基本等值式模式使用谓词公式代换出来的实例必定是谓词公式等值式。例如：  
$\forall x P(x)\Leftrightarrow\neg\neg\forall x P(x);\;\;\forall x\exists y\big(H(x,y)\to R(x,y)\big)\Leftrightarrow\neg\neg\forall x\exists y\big(H(x,y)\to R(x,y)\big)$ 等都是双重否定律的代换实例。再如：  
$$
\forall x(\ P(x)\rightarrow Q(y))\rightarrow\exists z H(z)\Leftrightarrow\lnot\forall x(\ P(x)\rightarrow Q(y))\lor\exists z H(z)
$$  
等都是蕴含等值式的代替实例。  
第二组  关于量词的若干等值式：  
（1）消去量词等值式：设个体域$D$ 为有限集$\{x_{0},x_{1},\cdots,x_{n}\ \}$，则有： $\forall x P(x)\Leftrightarrow P(x_{0})\land P(x_{1})\land\cdots\land P(x_{n});\ \ \exists x P(x)\Leftrightarrow P(x_{0})\lor P(x_{1})\lor\cdots\lor P(x_{n})$  
（2）量词否定等值式：对于含有量词的谓词式$\forall x P(x)$和$\exists x Q(x)$，有：$\lnot\forall x P(x)\Leftrightarrow\exists x\lnot P(x);\;\;\lnot\exists x Q(x)\Leftrightarrow\forall x\lnot Q(x)$  
（3）量词辖域的收缩与扩张等值式：  
$$
\forall x(P(x)\lor S)\Leftrightarrow\forall x P(x)\lor S;\;\;\forall x(P(x)\land S)\Leftrightarrow\forall x P(x)\land S;
$$  
$$
\exists x(P(x)\lor S)\Leftrightarrow\exists x P(x)\lor S;\ \exists x(P(x)\land S)\Leftrightarrow\exists x P(x)\land S;
$$  
$$
\forall x(P(x)\rightarrow S)\Leftrightarrow\exists x P(x)\rightarrow S;\quad\exists x(P(x)\rightarrow S)\Leftrightarrow\forall x P(x)\rightarrow S;
$$  
$$
\forall x(S\rightarrow P(x))\Leftrightarrow S\rightarrow\forall x P(x);\ \exists x(S\rightarrow P(x))\Leftrightarrow S\rightarrow\exists x P(x)\\,
$$  
(4）量词分配等值式  
$$
\forall x(P(x)\land Q(x))\Leftrightarrow\forall x P(x)\land\forall x Q(x);\ \exists x(P(x)\lor Q(x))\Leftrightarrow\exists x P(x)\lor\exists x Q(x);
$$  
上述基本的等值关系式很多可以互相推导。特别是当个体域为有限集时，很容易理解上述等值关系的合理性。  
例如，假设$P(x)$表示$x$ 今天上课，个体域为计算机学院全体学生的集合，则：  
$(\forall x)P(x)$表示今天所有学生都上课了；$\neg(\forall x)P(x)$表示今天不是所有学生上课了；$(\exists x)\lnot P(x)$表示今天有学生没上课。即有：$\lnot(\forall x)P(x)\Leftrightarrow(\exists x)\lnot P(x).$。  
$(\exists x)P(x)$表示今天有学生上课；$\neg(\exists x)P(x)$表示今天没有学生上课；$(\forall x)\neg P(x)$表示今天所有学生都没上课。即有：$\lnot(\exists x)P(x)\Leftrightarrow(\forall x)\lnot P(x)\,$。  
再如，假设谓词$G(x)$表示$x$ 勤奋学习，谓词$H(x)$表示$x$ 喜欢体育运动，个体域是某大学里的全体学生。则有：  
谓词公式$(\forall x)(G(x)\land H(x))$表示：“某大学里的所有学生既勤奋学习又喜欢体育运动”；谓词公式$(\forall x)G(x)\land(\forall x)H(x).$表示：“某大学里的所有学生都勤奋学习且大学里的所有学生都喜欢体育运动”。两者含义显然相同，即有$\forall x(G(x)\land H(x))\Leftrightarrow\forall x G(x)\land\forall x H(x)\,$。  
谓词公式 $(\exists x)(G(x)\lor H(x))$表示：“某大学里有些学生勤奋学习或喜欢体育运动”；谓词公式$(\exists x)G(x)\lor(\exists x)H(x)$表示：“某大学里有些学生勤奋学习或大学里有些学生喜欢体育运动”。两者的含义显然相同，即有$\exists x(G(x)\lor H(x))\Leftrightarrow\exists x G(x)\lor\exists x H(x)\,\mathrm{s}$。"
谓词合式公式,概念,"['第四章  谓词演算与推理', '§ 4.2  谓词公式与等值演算', '4.2.1 谓词公式的概念']","{'实体类型': '概念', '定义': '按递归方式定义，包括原子谓词公式、联结词、量词、圆括号和逗号按规则组成的符号串', '特点': '命题公式是谓词公式的一个特例'}",,3,"类似于命题逻辑，谓词逻辑采用谓词公式的方式实现对谓词符号的表达。但谓词公式的定义比命题公式更加复杂，因为谓词公式的表达要深入到概念层次，需要用到更多种类的特殊符号来表达命题在概念层次上的各种组件。具体地说，除了前述两种量词符号之外，还有四种特殊符号，即：表示个体的个体常量符号、个体变量符号、个体函数符号，以及表示谓词的谓词符号。这四种符号的表达方式如下：  
（1）个体常量符号：用带或不带下标的小写英文字母$a,b,c,\cdots$表示个体常量。  
（2）个体变量符号：用带或不带下标的小写英文字母$x,y,z,$…表示个体变量。  
（3）个体函数符号：用带或不带下标的小写英文字母$f,\,g,\,h,\cdots$表示个体函数。所谓个体函数，就是个体与个体之间的映射关系。  
（4）谓词符号：用带或不带下标的大写英文字母$P,Q,R,\cdots$表示谓词。  
个体函数表示谓词逻辑中个体与个体之间的映射关系。例如，对于命题：小张的爸爸是教授。如果设立如下谓词和个体函数：  
$P(x)$:$x$是教授；$f(x)$:$x$的爸爸  
则该命题的谓词式可表示为：$P(f(x))$  
个体函数的使用为谓词逻辑中个体之间映射关系的表达带来了很大的方便，大大提升了谓词逻辑符号系统的表达能力。基于个体函数，可按如下方式定义一个称之为个体项的概念来专门表达谓词逻辑中的个体之间复杂的映射关系：  
【定义4.9】谓词逻辑中的个体项，被递归地定义为：  
（1）个体常量符号是个体项；  
（2）个体变量符号是个体项；  
（3）若$f(x_{1}\,,\ x_{2}\,,\ \ \dots\,,\ x_{n})$是$.n$元函数，$t_{1}$，$t_{2}$，… ，$t_{n}$是个体项，则$f(t_{1}\,,\,\,\,t_{2}\,,\,\,\,\dots\,,\,\,\,t_{n})$是个体项；  
（4）所有个体项都是有限次使用(1)，(2)，(3)生成的符号串。  
由定义可知，个体项具有非常强大的表达能力，能有效地表达个体以及个体之间的复杂的映射关系，谓词中的个体常量、个体变量和个体函数都可以统一用个体项的概念进行表达。例如复合函数$f(g(x,y),\ h(a,g(x,y),z))$都是个体项；再如，令$f(x)$表示“$x$ 的叔叔”；$P(x)$表示“$x$ 是医生”；$c$ 表示“周红”，则$f(c)$是一个体项，此时$P(f(c))$表示命题“周红的叔叔是医生”。有了个体项的概念，就可在$n$元谓词的基础上得到如下原子谓词公式的定义：  
【定义4.10】设$P(x_{1}\,,\ x_{2}\,,\ \ \dots\,,\ x_{n})$是$n$元谓词公式，$t_{1}\,,\,\,\,t_{2}\,,\,\,\,\dots\,,\,\,\,t_{n}$是个体项，则称$P(t_{1},\ t_{2},\ \dots,\ t_{n})$为谓词演算的原子公式，简称为原子谓词公式。  
可原子谓词公式的基础上进一步得到如下谓词合式公式的定义：  
【定义4.11】谓词合式公式亦称为谓词公式，它按下列递归方式定义：  
（1）原子谓词公式是谓词公式；  
（2）若$G$，$H$是谓词公式，则$(\neg G)$$),\;(G\!\!\lor \!\!H),\;(G\!\!\ \ \wedge  H),\;(G\!\!\to\!\!H),\;$$(G{\leftrightarrow}H)$是合式公式；  
（3）若$G$ 是谓词公式，$x$是$G$ 中的自由变量，则$\forall x G$，$\exists x G$都是谓词公式；  
（4）所有谓词公式都是有限次使用（1），（2），（3）生成的符号串。  
由上述定义可知，谓词公式是原子谓词公式、联结词、量词、圆括号和逗号按上述规则组成的符号串，且命题公式是谓词公式的一个特例。为方便起见，谓词公式中的括号可以像命题公式那样省略最外层括号。  
例如：$(\forall x)(\forall y)(P(x,y)\rightarrow(Q(x,y)\vee\neg R(x,a,f(z)))), (\forall x)(P(x)\vee(\exists y)R(x,y))$等都是谓词公式；$(\forall x)(P(x)\to R(x),\ (\exists y)(\forall x)(\lor P(x,y))$等则都不是公式，前者括号不配对，后者联结词无联结对象。"
谓词填式,概念,"['第四章  谓词演算与推理', '§ 4.1 个体词、谓词与量词', '4.1.2  命题函数与谓词', '三、谓词与谓词填式']","{'实体类型': '概念', '定义': '对于n元谓词P(x1,x2,...xn)，若将其中每个个体变量分别指定具体的个体，由此得到的命题P(a1,a2,...an)', '特点': '具有谓词的形式结构但不再含有个体变量，可以看成是零元谓词'}",,4,"从结构上看，简单命题函数主要通过将原子命题中的个体常量泛化为个体变量的方式实现对命题结构的分解和对命题含义的抽象。在这个分解与抽象过程中，原子命题中表示个体性质与联系的谓语部分则不做任何抽象和改变而直接继承下来成为命题函数的函数名，并称之为谓词。谓词是简单命题函数中具有实质性含义的部分，刻画了命题函数中个体变量的性质与联系，构成了简单命题函数的主体。从本质上看，含有变元的简单命题函数其实就是含有变元的谓词。因此，通常将$_{\cdot n}$元简单命题函数称为$^n$元谓词。具体定义如下：  
【定义4.5】对于$\cdot n$元简单命题函数$P(x_{1},x_{2},\cdots x_{n})$，将其中的函数名$P$ 称为谓词，将$n$元简单命题函数$P(x_{1},x_{2},\cdots x_{n})$称为$n$元谓词。  
单纯的个体词或单纯的谓词都无法完成一个完整的逻辑含义，只有将它们结合起来才能构成完整独立的逻辑断言。因此，除非特别说明，通常情况下我们所说的谓词指的就是含有个体变元的谓词，即$n$元谓词。  
通过以上例题可以看出$n$元谓词主要用来描述个体的性质或者个体之间的联系。当$n=$1时，谓词描述的是个体的性质；当$n>1$时，谓词描述的是个体之间的联系。  
$n$元谓词$P(x_{1},x_{2},\cdots x_{n})$是表示含有$\cdot_{n}$个个体变量的语句。变量对个体指定的不确定性使得语句无法确定具体的真值，因而不是命题。当这些变量$x_{1},x_{2},\cdots x_{n}$均得到具体赋值或通过其它方式受到约束而获得明确具体的含义时，$P(x_{1},x_{2},\cdots x_{n})$就表示一个具体命题。  
例如，令一元谓词$P(x)$表示“$\cdot_{x}$ 是大学生”，则$P($小张)就是一个具体命题：小张是大学生。同样，$P($小李)也表示一个具体命题：小李是大学生。  
给$n$元谓词的个体变量赋值是一种最简单的约束方式，由此得到谓词填式的概念：  
【定义4.6】对于$\cdot n$元谓词$P(x_{1},x_{2},\cdots x_{n})$，若将其中每个个体变量$\cdot x_{1},x_{2},\cdots x_{n}$分别指定具体的个体，由此得到的命题$P(a_{1},a,\cdots a_{n})$，称为谓词填式，也称为命题的谓词式。  
谓词填式具有谓词的形式结构但不再含有个体变量，可以看成是零元谓词，是具体命题的谓词表示形式。例如：$P($小张)就是一个0 元谓词。因此，命题其实就是一种特殊的零元谓词，谓词逻辑是命题逻辑的一种自然推广。"
谓词演算,原理,"['一、含变量的语句', '4.1.2  命题函数与谓词', '4.4.2 谓词推证的基本方法', '§ 4.1 个体词、谓词与量词', '§ 4.4 谓词逻辑的推理', '第四章  谓词演算与推理']","{'实体类型': '原理', '应用': '用于数学计算、计算机程序等领域', '推证过程': '必须注意遵守所使用各项推理规则的限制条件，正确合理地使用推理规则'}",,4,"对于“小张是大学生”这个原子命题，可将其主语“小张”进行抽象，得到如下语句：  
某某是大学生  
上述语句表示的不是一个具体的命题，因为其主语“某某”的指代是不确定的，语句真值会随着“某某”的不同指代而有所不同。事实上，该语句表示的是一类命题，每给“某某”一个确定的取值，就会得到一个具有确定真值的具体命题，例如“小张是大学生”、 “小李是大学生”等。因此，可将“某某是大学生”看成是一种含变量的语句。  
令$x$ 表示“某某”，则可将上述含变量的语句表示为：$x$是大学生”。若再令$P$ 表示谓语部分“是大学生”，则可将其表示为$P(x)$，即：$P(x)$：$x$ 是大学生。事实上，在数学计算、计算机程序等领域存在大量类似于这种含变量的语句，例如：  
“$x>5$”、“$x+y=10$”、“$x+y<z$”  
对于这些含有变量的语句，当句中变量没有给定具体取值时，语句的真值是不确定的因而不是命题。只有当这些语句中所有变量均获得具体赋值时，它们才变成具有确定真值的命题。因此，可将这些含有变量的语句看成是以这些变量为自变量的命题函数。下面给出命题函数及其相关概念定义与性质。"
谓词演算与推理,概念,['第四章  谓词演算与推理'],"{'实体类型': '概念', '定义': '在命题逻辑基础上引入个体词、谓词、量词与约束变元等概念，进行更为深入复杂的逻辑演算与推理', '应用': '数据库与网络通信协议的模型设计、词法分析与代码编译、知识发现与数据挖掘、专家系统的知识表示与推理、自然语言理解与人机交互等多个领域', '特点': '提供了比命题逻辑更加丰富、更加深刻的信息表达与符号计算方法'}",,1,"前面我们学习了命题逻辑的基本理论及其应用，可以看出命题逻辑具有一整套非常完备的演算与推理理论体系，并且在数字电路设计与优化等多个领域有着广泛应用。但不可否认的是命题逻辑以命题为基本单位考察命题之间的逻辑关系，不能深入到命题内部从概念这个更加基本的层次上进行逻辑演算与推理。当两个命题之间在概念层次上具有某些共同特征或具有某种逻辑上的联系时，命题逻辑则无法揭示这些特征与联系。这不能不说是逻辑学和数理逻辑理论的重大局限。为此，著名数学家弗雷格在1879 年出版了一部名为《概念文字：一种模仿算术语言构造的纯思维形式语言》的天才著作，提出一整套相对完备的谓词逻辑演算与推理理论， 轰动了整个逻辑学界和数理逻辑学界， 被誉为自亚里士多德以来人类在逻辑 学方面取得的最大进展。弗雷格通过在命题逻辑中引入个体词、谓词、量词与约束变元等概念，在保持命题逻辑知识体系架构基本不变的情况下，将命题层次上的逻辑演算与推理，推进到更为深入复杂的概念层次，使得数理逻辑能够在概念层次上进行更为精细复杂的推演.如果说布尔是初步实现了莱布尼茨梦想，那么弗雷格则是基本上实现了莱布尼茨梦想。  
谓词逻辑能够有效实现对概念的数学表达和逻辑推演，提供了比命题逻辑更加丰富、更加深刻的信息表达与符号计算方法，在数据库与网络通信协议的模型设计、词法分析与代码编译、知识发现与数据挖掘、专家系统的知识表示与推理、自然语言理解与人机交互等多个领域都有着广泛应用，是计算机研发人员必须掌握的基础知识。本章比较系统地介绍谓词演算与推理的基本知识，包括谓词和量词的基本概念与性质、谓词公式与等值演算、谓词公式的范式、谓词逻辑的推理理论与方法等。"
谓词逻辑,原理,"['4.5.1 摘香蕉问题', '§ 4.5 谓词逻辑的应用', '4.1.2  命题函数与谓词', '4.4.3  谓词推理实例选讲', '4.4.2 谓词推证的基本方法', '§ 4.1 个体词、谓词与量词', '§ 4.4 谓词逻辑的推理', '4.1.1  逻辑与谓词逻辑', '4.5.2 水容器问题', '第四章  谓词演算与推理']","{'实体类型': ['原理', '概念'], '定义': ['通过引入个体词、谓词、量词与约束变元等概念，在概念层次上进行逻辑演算与推理', '对原子命题进行进一步分解，研究命题在更深层结构上的性质和关系', '通过对原子命题中的主语和宾语指代对象进行抽象和泛化，形成一种含有变量的语句来表示一类命题', '命题逻辑的一种自然扩展', '使用抽象数学符号在概念、判断和推理这三个层次上表达人类思维的基本规律', '基于逻辑推理规则，研究命题、谓词、推理等'], '应用': ['数据库与网络通信协议的模型设计、词法分析与代码编译、知识发现与数据挖掘、专家系统的知识表示与推理、自然语言理解与人机交互等多个领域', '解决命题逻辑无法表达的复杂推理问题', '谓词逻辑的推理', '对实际问题进行推理', '在计算机相关学科的众多领域都发挥着重要的基础性作用，是计算机进行智能信息处理的基本工具和理论基础；在人工智能与知识工程领域进行知识表示和推理；在数据库核心技术中用于表示和处理关系的增删查改等基本操作；用于机器证明和自动问题求解', '问题表示和求解', '解决水容器问题'], '地位': ['是计算机研发人员必须掌握的基础知识', '是当前能够表达人类思维基本规律的一种最精确的形式语言'], '核心思想': '将作为命题的陈述句分解成个体词与谓词', '基本概念': '个体词、谓词和量词', '内容': ['包括谓词逻辑的由来、命题函数与谓词的概念、量词与特性谓词的概念、谓词逻辑的符号化', '研究量词、个体词和谓词的概念性质、形式结构和逻辑关系'], '特点': ['随着变量的不同指派得到各自相应的具体命题', '引进了个体域、个体词、量词，以及由此而产生的约束变量和自由变量', '提供概念层次上的信息或知识表达方式，实现比命题逻辑更精细、更深刻、更复杂的逻辑推理', '具有一套比较完备严谨的理论体系', '使用谓词表示容器状态，基于逻辑推理得出结论'], '符号化处理': '确定个体域，选择适当的量词和谓词进行符号化描述'}",,1,"前面我们学习了命题逻辑的基本理论及其应用，可以看出命题逻辑具有一整套非常完备的演算与推理理论体系，并且在数字电路设计与优化等多个领域有着广泛应用。但不可否认的是命题逻辑以命题为基本单位考察命题之间的逻辑关系，不能深入到命题内部从概念这个更加基本的层次上进行逻辑演算与推理。当两个命题之间在概念层次上具有某些共同特征或具有某种逻辑上的联系时，命题逻辑则无法揭示这些特征与联系。这不能不说是逻辑学和数理逻辑理论的重大局限。为此，著名数学家弗雷格在1879 年出版了一部名为《概念文字：一种模仿算术语言构造的纯思维形式语言》的天才著作，提出一整套相对完备的谓词逻辑演算与推理理论， 轰动了整个逻辑学界和数理逻辑学界， 被誉为自亚里士多德以来人类在逻辑 学方面取得的最大进展。弗雷格通过在命题逻辑中引入个体词、谓词、量词与约束变元等概念，在保持命题逻辑知识体系架构基本不变的情况下，将命题层次上的逻辑演算与推理，推进到更为深入复杂的概念层次，使得数理逻辑能够在概念层次上进行更为精细复杂的推演.如果说布尔是初步实现了莱布尼茨梦想，那么弗雷格则是基本上实现了莱布尼茨梦想。  
谓词逻辑能够有效实现对概念的数学表达和逻辑推演，提供了比命题逻辑更加丰富、更加深刻的信息表达与符号计算方法，在数据库与网络通信协议的模型设计、词法分析与代码编译、知识发现与数据挖掘、专家系统的知识表示与推理、自然语言理解与人机交互等多个领域都有着广泛应用，是计算机研发人员必须掌握的基础知识。本章比较系统地介绍谓词演算与推理的基本知识，包括谓词和量词的基本概念与性质、谓词公式与等值演算、谓词公式的范式、谓词逻辑的推理理论与方法等。"
谓词逻辑推理,算法,"['第四章  谓词演算与推理', '§ 4.4 谓词逻辑的推理', '4.4.2 谓词推证的基本方法']","{'实体类型': '算法', '基本方法': '首先根据US和ES规则消除谓词公式中的量词，把谓词公式的推理问题转化为命题公式的推理问题，再根据具体需要使用UG和EG规则，将基于命题公式的推理结论还原成谓词公式的推理结论', '推理规则': '可以引用命题演算中的P规则和T规则，如果结论是以蕴涵形式或析取形式给出，还可使用CP规则', '注意事项': '必须注意遵守所使用各项推理规则的限制条件，正确合理地使用推理规则'}",,3,"我们知道，谓词逻辑是命题逻辑的一种自然扩展，谓词逻辑的知识体系完全涵盖了命题逻辑的知识体系，或者说命题逻辑是谓词逻辑的一种特例。因此，命题逻辑推演系统的全部知识完全可以照搬到命题逻辑推演系统之中，可以将命题推理的T 规则、 规则和CP 规则，以及命题推理的基本策略例如直接证明法和间接证明法等，直接应用于谓词逻辑的推理。  
另外一方面，我们也应该注意到谓词逻辑与命题逻辑之间最大的区别在于谓词逻辑引进了个体域、个体词、量词，以及由此而产生的约束变量和自由变量。因此，在考虑和处理谓词推理问题时，不能单纯地将其看成是命题逻辑推理，还需要根据谓词逻辑的特点采用适当的方法。其中最为关键的是如下几个基本要点：  
第一、在谓词逻辑中，一般无法在不同个体域基础上衡量两个谓词公式之间的等值关系或逻辑蕴含关系，就像两种不同类型的东西无法进行比较一样。因此，在谓词逻辑演算和推理过程中，我们总是假定所有的谓词公式具有相同的个体域，一般默认为全总个体域。  
第二、谓词逻辑推演的基本思路，一般是首先根据$US$和$E S$ 规则消除谓词公式中的量词，把谓词公式的推理问题转化为命题公式的推理问题，在使用命题公式的推理策略和方法完成相关的推理后，再根据具体需要使用UG 和$E G$规则，将基于命题公式的推理结论还原成谓词公式的推理结论。  
第三、在谓词逻辑的推演过程中，可以引用命题演算中的$P$ 规则和$T$ 规则，如果结论是以蕴涵形式或析取形式给出，还可使用$C P$ 规则。对含有量词的公式可以引用谓词中的基本等值公式和基本蕴涵公式，对于已经消去量词的谓词公式或谓词公式中不含量词的子公式，完全可以引用命题演算中的基本等价公式和基本蕴涵公式。  
下面结合实例介绍谓词逻辑推证的基本方法。首先，我们使用谓词逻辑推理来解决在本章开头提及的苏格拉底三段论问题：  
从以上例题的证明过程可以看出，在谓词演算的推证过程中，必须注意遵守所使用各项推理规则的限制条件，正确合理地使用推理规则。当既需要消除存在量词，由需要消除全称量词的时候，一般都是先消除存在量词，后消除全称量词，被消除或新添加的量词必须位于谓词公式的最左边。当需要推证的结论为蕴含式的时候，可以考虑使用附加前提证明法。当证明给出的前提条件较少且多为蕴含式或析取式时，会感到无从下手，此时可以考虑使用反证法，将结论的否定作为附加前提引入，以增加可用的前提。"
谓词逻辑推理的形式结构,性质,"['第四章  谓词演算与推理', '§ 4.4 谓词逻辑的推理', '4.4.1 谓词公式推演系统']","{'实体类型': '性质', '特点': '与命题逻辑推理的形式结构一致，是命题逻辑推理的自然推广'}",,3,"谓词公式的推演系统与命题公式的推演系统非常类似，主要由有效推理的基本概念、事实库、公理库和推理规则这几个部分组成。事实库和公理库构成谓词公式推理的基本依据，推理规则是谓词公式推理的核心机制。谓词公式推演系统的公理库和推理规则不仅涵盖了命题公式的推演系统的所有相关内容，而且更加丰富、复杂。  
谓词公式有效推理的概念与命题逻辑推理非常相似，具体定义如下：  
【定义4.22】设$G_{1},G_{2}\cdots G_{n}$，$\mathrm{H}$ 是一些谓词公式，如果它们满足下列性质：对于这些公式的任意一个解释I，$G_{1},G_{2}\cdots G_{n}$在该解释下同时为真的情况下$H$在该解释下也为真，则称公式$G_{1},G_{2}\cdots G_{n}$可有效推出公式$\mathrm{H}$，或称由$G_{1},G_{2}\cdots G_{n}$得到H 的逻辑推理为有效推理，记为$G_{1},G_{2}\cdots G_{n}\Rightarrow H$，并称$G_{1},G_{2}\cdots G_{n}$为推理前提，$\mathrm{H}$ 为$G_{1},G_{2}\cdots G_{n}$的逻辑结论。  
从上述定义不难看出，谓词逻辑推理的形式结构与命题逻辑推理的形式结构一致，是命题逻辑推理的自然推广。  
【定理4.6】谓词公式$H$是谓词公式$G_{1},G_{2}\cdots G_{n}$的逻辑结论，当且仅当下式：  
$$
G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\to H\tag{4-14}
$$  
为有效公式。  
上述定理表明谓词逻辑有效推理的过程就是证明谓词逻辑蕴含式的过程，这与命题逻辑的有效推理完全一致。  
谓词公式的推理依据主要是谓词公式推演系统中的事实库和公理库。事实库由具体谓词逻辑推理实例的所有前提条件以及推理过程中产生的有效中间结论组成；公理库不仅包含命题逻辑推演系统的公理库，即关于命题公式的24 个基本等值式和9 个基本永真蕴含式，而且还包含了关于谓词公式的所有基本等值式和基本逻辑蕴含式，具体可参加本章4.2.4 节中相关内容，这里不再一一罗列。  
现在着重介绍谓词公式的推理规则。由于在谓词合式公式中含有大量的量词，直接对其进行推理显然十分不便。为此，谓词公式推演系统引入一些专门处理量词的规则，以便在需要的时候可以方便地增加或消除量词。谓词逻辑中主要有全称特指、存在特指、全称推广和存在推广这四条基本的量词处理规则，其中全称特指和存在特指消除量词的规则，全称推广和存在推广则是添加量词的规则。下面具体介绍这些规则：  
1．全称特指规则(简称US 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)\forall x\ P(x)\Rightarrow\ P(y);\ (2)\forall x\ P(x){\Rightarrow}\ P(c)
$$  
US 规则的基本含义是：如果$\forall x\;\;P(x)$为真，那么对于论域中任何指定的个体$.c$，必有${P(c)}$为真。其中，$P$ 是谓词，(1)中的$y$ 是任意不在$P(x)$中约束出现的个体变量；(2)中的c为个体域中任意指定的一个个体常量。  
当谓词公式$P(x)$中不含任何量词和其它个体变量时，$US $规则显然不需要附加任何限制条件。但是，若$P(x)$中包含量词或其它个体变量时，(1)式中的约束“$y$ 是任意不在$P(x)$中约束出现的个体变量”就是必须的。例如，设$P(x)=\exists y(x<y)$，则$P(x)$在实数域上显然是真命题。但是，当$P(x)$中的$x$取𝑦时得到的$P(y)=\exists y(y<y)$显然是假命题。因此，限制引入的变量“不是在$P(x)$中约束出现的个体变量”是任何规则在引入变量时必需遵守的约定。  
2．存在特指规则(简称ES 规则)
$$
\exists x\ P(x)\Rightarrow\ P(c)
$$  
ES 规则的基本含义是：如果$\exists x$ $P(x)$为真，那么在个体域中必然至少存在某一个个体𝑐，使得$P(c)$为真。其中，$c$ 为个体域中使$P$ 成立的特定个体常量。  
当谓词公式$P(x)$中自由变量只是$x$的时候，上述规定可以保证使用ES 规则引入个体符号$c$ 的正确性。但是，如果谓词公式$P(x)$还含有其它自由个体变量，例如还有自由变量𝑦，那么使用ES 规则引入的符号c必须是以𝑦为自变量的个体函数，即$C(y)$。此外，还应当注意，在应用ES 规则时，其指定的个体$c$ 并不是任意含义下的自由变量，$c$ 的本质含义是某个或某些个体。因此，每次使用ES 规则指定的特定个体不能用之前的ES 规则或US 规则确定的个体替代，否则就会引起个体指代的混淆和错误。因为通常不能保证某次ES 指定的个体能够与其它次ES 或US 指定的个体之间具有必然的联系。  
3．全称推广规则(简称UG 规则)：  
$$
P(\boldsymbol{y})\Rightarrow\ \forall\boldsymbol{x}\ \ P(\boldsymbol{x})
$$
UG 规则的基本含义是：如果个体变量$y$在个体域内取到每一个个体时都有$P(y)$为真，那么必有$\forall x\;\;P(x)$为真。这里要求$x$既不是$P(y)$中约束变量也不是$P(y)$中的自由变量，即要求个体变量$x$不能在$P(y)$中出现。  
4．存在推广规则(简称EG 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)P(y)\Rightarrow\ \exists x\ P(x);\ (2)P(c)\Rightarrow\ \exists x\ P(x)
$$  
UG 规则的基本含义是：如果对于个体域中某个或某些指定的个体$.c$满足$P(c)$为真，那么必有 $\exists x P(x)$为真。其中，(1)式要求$P(y)$中无自由变量$x$；(2)式中要求$c$为个体域中的某个或某些个体常量。  
由以上分析可知，上述四个规则表面上看起来非常简单，但要能够做到真正理解并正确使用则不是一件容易的事情，实际使用时往往稍不注意就会出现错误。下面举例说明："
谓词逻辑的推理,原理,"['第四章  谓词演算与推理', '§ 4.4 谓词逻辑的推理']","{'实体类型': '原理', '目的': '学习和研究谓词逻辑的主要目的', '方法': '谓词逻辑的推理演算方法是命题逻辑推理演算方法的自然延伸', '应用': '命题逻辑推理系统中的概念、等值式、永真蕴含式、推理规则和推证策略在谓词逻辑推理中直接应用或类似应用', '特点': '谓词公式中含有个体词、谓词、量词等新概念，表达形式比命题公式更加丰富、深刻、复杂', '需求': '需要引入新的规则来处理新概念，得到比命题逻辑推理更加精细的推理结论', '内容': '包括谓词公式的推演系统、谓词推证的基本方法以及谓词推理实例选讲'}",,2,与命题逻辑类似，谓词逻辑的演绎推理是学习和研究谓词逻辑的主要目的。谓词逻辑的推理演算方法可以看成是命题逻辑推理演算方法的自然延伸。命题逻辑推理系统中的很多概念、等值式、永真蕴含式、推理规则和推证策略都可以在谓词逻辑推理中得到直接应用或类似应用。与命题逻辑推理不同的是，谓词公式中含有个体词、谓词、量词等新概念，具有比命题公式更加丰富、深刻、复杂的表达形式。因此，谓词逻辑推理需要引入一些新的规则来处理这些概念，从而得到比命题逻辑推理更加精细的推理结论。本节主要介绍谓词逻辑推理的基本知识，包括谓词公式的推演系统、谓词推证的基本方法以及谓词推理实例选讲。
谓词逻辑运算,原理,"['第四章  谓词演算与推理', '§ 4.1 个体词、谓词与量词', '4.1.3  量词与特性谓词', '三、特性谓词及其应用']","{'实体类型': '原理', '问题': '个体域确定带来混乱和困难', '解决方案': '采用全总个体域和特性谓词'}",,4,"我们知道，谓词中含有个体变量，不同谓词的个体变量和个体域经常会有所不同。此时会给谓词逻辑运算结果的个体域确定带来混乱和困难。例如符号化下面两个命题：  
设立如下谓词：$P(x)$：$X$吃人；$Q(x)$：$X$ 登上过月球。则可将上述两个命题符号化为：  
$$
(\,1\,)\ \forall x P(x),\ \operatorname{x}\!\in\!\ \{ 老虎\};\ (\,2\,)\ \exists x Q(x),\ \operatorname{x}\!\in\!\{人\}
$$  
上述符号化表示，对每个表达式都注明了个体域。如果需要对上述两个命题的谓词式进行合取运算，得可到如下新命题的谓词式：$\forall x P(x)\land\exists x Q(x)$。则该谓词式的个体域就比较含糊和混乱。如果有多个类似的命题谓词式进行复杂的逻辑运算，那么对运算结果个体域的确定显然是一件非常麻烦的事情。  
另一方面，对于一个命题的谓词表达式，其个体域的确定又是非常重要的。因为个体域的差异往往会导致其真值取值的不同。例如对于命题“所有人都是大学生”，如果个体域是某大学的某个班，那么该命题显然为真；如果个体域是某中学的某个班，那么该命题显然为假；如果个体域为某电影院某场电影的全体观众，那么命题的真值就比较难以确定。  
因此，命题的谓词表达式不能采用对每个表达式分别指定个体域的方式。事实上，可以让所有的谓词和命题函数共用全总个体域作为一种统一的个体域，不同的个体变量可以通过设立与其含义相对应的特性谓词来确定其个体域。  
例如，可以设定特性谓词$U(x)$表示：$x$是老虎，则命题“所有的老虎都吃人”，就可完整地符号化为：$\forall x(U(x)\rightarrow P(x))$。该谓词式准确而完整地表达了命题的含义，可理解为：对于全总个体域中的每个$x$，如果$x$ 是老虎，则$x$一定吃人。  
如果将命题“所有的老虎都吃人” 符号化为：$(\forall x)(U(x)\ \land\ P(x))$。则这种表达显然是错误的，因为该式的含义是：“对于任意的一个对象$x,\ x$ 是老虎，并且$x$ 会吃人”，这与命题所表达的逻辑含义不符。  
同理，可以设定特性谓词$H(x)$表示：$x$是人，则命题“有些人登上过月球”，就可以完整地符号化为：$\exists x(H(x)\land Q(x))$。该谓词式准确而完整地表达了命题的含义，可理解为：在全总个体域中存在一些$x$，这些$x$ 不仅是人，而且登上过月球。  
如果将命题“有些人登上过月球”符号化为：$(\exists x)~(H(x)~\rightarrow~S(x))$。则这种表达显然是错误的，因为该式的含义是：“存在一些对象$x$，只要$x$ 是人，则$x$一定登上过月球”，这与命题所表达的逻辑含义不符。  
由此可知，特性谓词的使用与量词类型有着密切关系，具体方法如下：  
（1）对于全称量词$\forall x$，刻画其作用变量$x$ 个体域的特性谓词作为蕴含式前件加入；  
（2）对于存在量词$\exists x$，刻画其作用变量$x$ 个体域的特性谓词作为合取项加入。"
贝尔格定理,定理,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.2.3 最大匹配判定与构造']","{'实体类型': '定理', '内容': '一个匹配是最大匹配的充要条件是该图中不存在可增广道'}",,3,"对于任意给定的一个二分图，首先讨论如何判断该图中某个给定的匹配是否为最大匹配。为此，引入交错道和可增广道的概念，具体如下：  
【定义10.5】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图， $M$是图$G$的某个匹配，若从𝐺中的某个结点到另一个结点之间存在一条通路，且该通路由属于$\cdot M$和不属于$M$的边交替构成，则称此通路为 𝑴 交错道。若 $M$ 交错道的两端点均为 $M$ 非饱和点，则称其为 𝑴 可增广道。  
例如，对于图10-35（a）所示匹配，$P=y_{1}x_{2}y_{5}x_{4}y_{3}x_{1}$是一条交错道，对于图10-35（b）所示匹配，$P=y_{1}x_{2}y_{5}x_{4}y_{3}x_{1}$则是一条可增广道，具体见图10-35（b）的粗线部分。  
![图10-35  交错道与可增广道  ](images/f5e335487e12a671cc013f6ede9981700aa6193018e616b34157cc9869d086b6.jpg)  
在1957 年，法国著名数学家贝尔格给出了判定某个匹配是最大匹配的充分必要条件。这就是著名的贝尔格定理，具体如下：  
【定理10.10】（贝尔格定理）设$G=\langle X,E,Y\rangle$是任意给定的一个二分图， 𝑀是图𝐺的某个匹配，则$M$是图$G$最大匹配的充要条件是$G$中不存在$M$可增广道。  
在1965 年，匈牙利的著名数学家埃德蒙兹基于贝尔格定理提出构造二分图最大匹配的著名算法，为纪念他的祖国，将该算法命名为匈牙利算法。算法基本思路如下：  
假设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，如果对于该图的某个匹配𝑀，结点集合𝑋的每个结点都是饱和结点，则该匹配就是最大匹配。否则，任取𝑋中的某个非饱和结点为起点做匹配$M$的交错道。此时，如果该交错道最后一个结点是饱和结点，如图10-36 中$P_{1}$所示，则匹配$M$就是最大匹配。否则，如果该交错道最后一个结点也是一个非饱和结点，则得到一条可增广道，如图10-36 中$P_{2}$所示。  
![图 10-36   对可增广道的增广 ](images/18f50be9390d6af7d21020996653e950e5f8bda427f6af3f0640cd631a139c62.jpg)  
不难看出，该交错道$P_{2}$中不属于$M$的所有边数比属于属于$M$的边数多一个，而且交错道中不属于$M$的所有边数也是互不相邻的，故可由这些边构成一个新的匹配$M^{*}$。由于${\mathbf{\nabla}}^{*}$的边数比$M$的边数多一个，故称$M^{*}$是对$M$的一个增广。继续上述过程，直到图中没有可增广道路为止，此时的匹配就是所求的最大匹配。  
从上述讨论不难发现，匈牙利算法的核心思想就是首先在当前匹配基础上寻找可增广道，找到可增广道后，就通过对该可增广道上所有边的匹配属性取反，即对可增广道上所有边的集合$ E(P)$与匹配$M$做集合的对称差运算$\oplus$，由此得到新的集合就是一个规模更大的新匹配，然后在这个新匹配的基础上继续寻找新可增广道，如此下去，直到没有可增广道路为止。  
对于任意给定的二分图$G=\langle X,E,Y\rangle$，匈牙利算法的具体计算流程如下：  
（1）任给初始匹配$M$；  
（2）若𝑋中任一结点均饱和，则$M$即为所求，算法结束，否则转（3）；  
（3）在𝑋中找到一非$M$饱和点$x$，置$S=\{x\}$，$T=\varnothing$；  
（4）若$N_{G}(S)=T$，则停止，否则任选一点$y\in N_{G}(S)-T$；  
（5）若𝑦为$M$饱和点转（6），否则：求一条从$x$到𝑦的$M$可增广路$P$，置$M=M\oplus P$，转（2）  
（6）由于$ y$是$M$饱和点，故$M$中有一边 $(y,u)$，置$S=S\cup\{u\}$，$T=T\cup\{y\}$，转（4）。算法中$N_{G}(S)$表示 $G$上与$S$中任一结点相邻的所有结点组成的集合，$\oplus$表示集合的对称差运算。下面以图10-37 为例，详细介绍匈牙利算法的具体执行过程：  
![图10-37 二分图 ](images/e75e6b51eaa2d7dcbd869cabf1198a4ab254d8c498cf74b11e8db5905f80f0b4.jpg)  
![图10-38 步骤1 效果图 ](images/a85e16b732f3f408c1a3f889dd66171d41954384c66b3a6769a239cb765226ce.jpg)  
（1）首先任给一个初始匹配$M=\{(x_{1},y_{1}),\;\;(x_{3},y_{5}),\;\;(x_{5},y_{3})\}$，如图10-38 所示。  
（2）$x_{2},x_{4}$非饱和，故$X$非饱和。确定其中一个非饱和点$x_{2}$，令${S}=\{x_{2}\}$，$T=\varnothing$。  
（3）$S$邻接结点集${N}_{G}(S)=\{y_{2},y_{3}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{3}\}$，选择$y_{3}$  
（4）$y_{3}$已饱和，因$M$中有边$(y_{3},x_{5})$，故令：  
$$
S=S\cup\{x_{5}\}=\{x_{2},x_{5}\},\ T=T\cup\{y_{3}\}=\{y_{3}\}
$$  
（5）因为$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{4},y_{5}\}$，选择${{y}}_{5}$  
（6）$y_{5}$已饱和，因为$M$存在边$(y_{5},x_{3})$，故令：
$$
S=S\cup\{x_{3}\}=\{x_{2},x_{3},x_{5}\},\,\,\,T=T\cup\{y_{5}\}=\{y_{3},y_{5}\}
$$  
（7）$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{4}\},$,选择$y_{2}$  
（8）$y_{2}$不饱和，故存在从$x_{2}$到$y_{2}$的可增广道$P$。对于当前匹配$M=\{(x_{1},y_{1}),(x_{3},y_{5}),$$(x_{5},y_{3})\}$，求得可增广路$P$如图10 −39 加粗部分所示，得到$P$的边集：  
$$
E(P)=\{(x_{2},y_{3}),(y_{3},x_{5}),(x_{5},y_{5}),(y_{5},x_{3}),(x_{3},y_{2})\}
$$  
按下十重新调整匹配$M$，得到如图10 −40 所示一个新匹配$M$  
$$
M=M\oplus E(P)=\{(x_{1},y_{1}),(x_{2},y_{3}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
10-39 步骤8 过程图  
图10-40 步骤8 过程图2  
（9）在新匹配下继续查找可增广道。查看$ X$是否饱和，显然${{x}}_{4}$非饱和，选择该非饱和点$x_{4}$，并令$S=\{x_{4}\}$，$T=\varnothing$。  
（10）$N_{G}(S)=\{y_{3}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{3}\}$，选择$y_{3}$  
（11）$y_{3}$已饱和，因为匹配$M$中存在$(y_{3},x_{2})$，故令：
$$
S=S\cup\{x_{2}\}=\{x_{2},x_{4}\},\,\,\,T=T\cup\{y_{3}\}=\{y_{3}\}
$$  
（12）$N_{G}(S)=\{y_{2},y_{3}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{2}\}$，选择$y_{2}$（13）$y_{2}$已饱和，因为匹配$M$中存在$(y_{2},x_{3})$，故令：  
$$
S=S\cup\{x_{3}\}=\{x_{2},x_{3},x_{4}\},\,\,\,T=T\cup\{y_{2}\}=\{y_{2},y_{3}\}
$$  
（14）$N_{G}(S)=\{y_{2},y_{3},y_{5}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{5}\}$，选择$y_{5}$（15）$y_{5}$已饱和，因为匹配$M$中存在了$(y_{5},x_{5})$，故令：  
$$
S=S\cup\{x_{5}\}=\{x_{2},x_{3},x_{4},x_{5}\},\,\,\,T=T\cup\{y_{5}\}=\{y_{2},y_{3},y_{5}\}
$$  
（16 ）$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{4}\}$，选择${\cdot}y_{4}$（17）$y_{4}$不饱和，故可求一条从$x_{4}$到$y_{4}$的可增广路$ P$。对于当前匹配：  
$$
M=\{(x_{1},y_{1}),(x_{2},y_{3}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
求得如图10 −41 加粗部分所示的可增广道路$P$， $P$的边集为：  
$$
E(P)=\{(x_{4},y_{3}),(y_{3},x_{2}),(x_{2},y_{2}),(y_{2},x_{3}),(x_{3},y_{5}),(y_{5},x_{5}),(x_{5},y_{4})\}
$$  
按下式重新调整匹配$M$，得到如图10 −43 所示的一个新匹配  
![](images/ee96514b37bbad784ca2a76b1641bd0dbdac20d6a3f2ab76c80847e37bff2151.jpg)  
至此，集合$\cdot X$已经饱和，求得的如下最大匹配：  
$$
M=\{(x_{1},y_{1}),(x_{2},y_{2}),(x_{3},y_{5}),(x_{4},y_{3}),(x_{5},y_{4})\}
$$  
设二分图$G$有${n}$个结点$m$条边，使用匈牙利算法最大匹配时，初始匹配可以空，故算法最多找$n$条可增广道，每找一条可增广路，最多比较$m$条边。因此，匈牙利算法的最坏时间复杂度为$O(m n)$。由此可见，匈牙利算法是一个有效算法。"
货郎担问题,问题,"['第十章  特殊图模型与算法', '§ 10.4 网络流图及其优化问题', '10.5.3 最优路线问题']","{'实体类型': '问题', '定义': '在多个地点间寻找总路程最短的遍历路线问题', '特点': 'NP-hard问题', '求解方法': '近似算法如最近邻算法、抄近路算法、动态规划算法、模拟退火算法、遗传算法、蚁群算法'}",,3,"如果想在较短的时间内旅游较多的景点，则需要确定一个合理的路线，尽量缩短旅游的路程，使总路程最短。该问题可用哈密顿图模型求解。  
首先，将旅游线路模型化。把每个旅游景点分别看作是加权无向图中的一个结点，各景点之间的直达公路看作加权无向图中对应结点间的边，将各条公路的长度分别看作其对应边上的权。有的景点之间尽管没有直达的公路，但是它们加权无向图中对应结点之间也要用边相连，而这条边的含义是：从其中一个景点出发，通过中转站到达另一景点所需的最短距离。  
此时，旅游景点之间的公路网就转化为加权无向图，寻找旅游各个景点近似最佳旅行线路问题就转化为：在给定的加权无向图中，寻找从给定的结点出发，行遍所有结点仅一次再回到该指定的结点，使得总权数最小，即总路程最短。可以运用图论中的最邻近插入法来寻找近似最佳旅游线路和路程。算法的基本步骤如下：  
步骤1：用沃舍尔∙弗洛伊德算法求出加权无向图中任意两点之间的最短路程，形成仅含一条边的初始道路$\left\langle i,j\right\rangle$，权$w(i,j)$表示道路$\langle i,j\rangle$的长度。  
步骤2：设$x$表示最新加到这道路$\langle i,j\rangle$上的景点，从不属于该条道路上所有景点中选一个与景点$x$距离最近的景点𝑦，把连接景点$x$与景点𝑦的边加到$\langle i,j\rangle$上。重复这个步骤，直到加权无向图中所有景点都包含到$\left\langle i,j\right\rangle$这条路上。  
步骤3：将连接起点与最后加入景点之间的边加到这条路上，就得到一个总权数最小的汉密尔顿回路。  
![](images/3eb5c42c98242b09cf1d107a9f19a39189dbcd95c1ca7e77768503681d0519c4.jpg)  
下面结合具体实例说明寻找近似最佳旅行线路的具体构造过程。  
从上述讨论和例题10.18 可以看出，遍历多个景点的最短旅游路线问题，其实就是从具有$n$个结点的无向带权完全图中寻找一条哈密顿回路的问题。如果景点个数较多的时候，比如说几十个或者上百个，则上述算法就非常复杂甚至不可行。  
这其实是图论中的一个著名问题，通常称之为货郎担问题。因为该问题也可以描述为：某地区共有${n}$个村庄，某售货员从他所在的某个村庄出发，前往其它$𝑛$−1个村庄一次且恰好一次，最后返回到他所在的村庄，求一条满足上述要求且总路程最短的回路。  
货郎担问题是一个十分有趣而且具有实用价值的问题，很多数学家和计算机科学家对该问题做了大量的研究，取得了丰硕的研究成果。但是，遗憾的是至今无法找到一个有效的精  
确算法，这显然是一个 NP-hard 问题，当图中结点较多时，精确算法由于计算量过于巨大而变得不可行。目前，对该问题的求解主要采用近似算法，例如在例题10.18 中使用的最近邻算法，除此之外还有抄近路算法、动态规划算法、模拟退火算法、遗传算法、蚁群算法等等，读者可参阅相关的资料进一步深入学习。"
贪心法,算法,"['第二章  整数与算法设计基础', '§ 2.4 算法设计策略与应用', '2.4.1 蛮力与贪心']","{'实体类型': '算法', '定义': '在每一步都获得当前状态下最好的结果，通过使用局部最优解步步逼近的方式获得问题全局最优解', '优点': '思想直观，易于理解', '缺点': '算法没有总体控制机制，缺少远见和大局观，有时难以保证算法的正确性', '特点': '算法思想简单，易于理解，存在明显的局限性'}",,3,计算机处理的对象及其结构都是离散的，对这种离散对象与结构的求解，显然有一种最直观、最基本的方法，就是枚举出所有可能状态，然后在这些状态中找到所需的解。这就是蛮力法。该方法最大优点就是普适性高，几乎可以解决任何问题，最大的缺点就是计算量太大，很多情况下不可行。此外，还有一种非常直观的、非常基本的方法，那就是贪心法。该方法在每一步都获得当前状态下最好的结果，通过使用局部最优解步步逼近的方式获得问题全局最优解。贪心法的优点是思想直观，易于理解，缺点是算法没有总体控制机制，缺少远见和大局观，有时难以保证算法的正确性。蛮力法和贪心法的共同特点是算法思想简单，易于理解，但都存在比较明显的局限性，在很多情况下难以直接使用。
贪心策略着色算法,算法,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.3.3 着色问题与算法', '三、结点着色算法']","{'实体类型': '算法', '计算思路': '对每个结点构造一个颜色集合，通过贪心策略逐步优化和排除颜色集合，得到优化的着色方案'}",,4,"如前所述，图的边着色和面着色问题都可转化为对图的结点着色问题。因此，如果掌握了对一个图的结点进行着色的具体设计方法，则边着色和面着色的设计问题便可迎刃而解。因此，我们仅给出结点着色算法。首先介绍一种比较直观的基于贪心策略的着色算法，然后介绍比较巧妙的韦尔奇•鲍威尔着色算法。  
基于贪心策略的着色算法的计算思路比较直观，首先对每个结点构造一个颜色集合，然后通过贪心策略逐步对颜色集合进行优化和排除，最后得到一种优化的着色方案。  
设$G=\langle V,E\rangle$是任意给定的一个连通无向图，令$\{c_{1},c_{2},\cdots,c_{n}\}$为全部可选颜色的集合，$V=\{v_{1},v_{2},\cdots,v_{n}\}$。则基于贪心策略的着色算法具体步骤如下：  
1）对$i=1,2,\cdots,n$，作集合$C_{i}=\{c_{1},c_{2},\cdots,c_{i}\}$。  
2）给结点$v_{i}(i=1,2,\cdots,n)$标上颜色集$C_{i}$的第一种颜色$c_{k}$  
3）对点$v_{i}$的所有邻接点$v_{j}(j>1)$，作$C_{j}=C_{j}-\{c_{k}\}$。  
4）转到步骤2），直到所有结点都着色为止。  
例如，图10-66（a）所示的无向图$G$，使用上述基于贪心策略的着色算法，不难得到如图10-66（b）所示的着色结果。  
![图10-66 无向图𝐺及其结点着色  ](images/0f362f12a7e52ba554944661d9c9e977185a05cbdb94dab0ac96e78d08f2908c.jpg)  
韦尔奇•鲍威尔算法是一个非常著名的结点着色算法。该算法的基本思路如下：首先将图$G$中的结点按度数的递减顺序进行排列；然后用第一种颜色对结点着色，并按排列顺序对与前面着色结点不邻接的每一结点着上同样的颜色；最后用第二种颜色对尚未着色的结点重复前一步骤，并用第三种颜色继续这种做法，直到所有的结点全部着色为止。  
设$G=\langle V,E\rangle$是任意给定的一个连通无向图，令$\cdot V=\{v_{1},v_{2},\cdots,v_{n}\}$且所有结点中共有𝑠种不同的度数，则韦尔奇•鲍威尔结点着色算法的具体步骤如下：  
1）图$G$的所有结点按其度数从大到小进行排列，度数相同的结点次序不究，得到：并设初值$i=j=k=1$，$B=\emptyset$，其中$B$表示已着色结点集合。  
2）用第𝑖种颜色对结点$v_{j k}$进行着色，并按次序对与$v_{j k}$不相邻的结点着同一颜色，将与$v_{j k}$着同色的所有结点放入$B$集合。  
3 ）若 $\,\!V(G)-B=\varnothing$ ，则停止，此时每个结点都已被着色。否则 $i=i+1$ ，取结点 $v_{j k}\in$ $V(G)-B$，且$\deg\!\left(v_{j k}\right)=\operatorname*{max}\{\deg\!\left(v_{x y}\right)\!,v_{x y}\in V(G)-B\}$，转去执行2）。"
贪心算法,算法,"['第二章  整数与算法设计基础', '§ 2.4 算法设计策略与应用', '2.4.1 蛮力与贪心', '二、贪心策略']","{'实体类型': '算法', '定义': '从问题的某个初始解出发，通过在每一步构造当前状态下局部最优解的方式，一步一步地向全局最优解逼近，最终获取全局最优解', '优点': '思维复杂度低、代码量小、运行效率高、空间复杂度低', '局限性': '每一步的局部最优解不一定能逼近到全局最优解，称为非完美性', '本质特点': '缺少大局观思想', '应用特点': '虽然不是所有问题都能获得整体最优解，但至少可以得到一个近似最优解'}",,4,"【定义2.19】贪心算法，就是从问题的某个初始解出发，通过在每一步构造当前状态下局部最优解的方式（即在每个局部阶段都贪心地做出当前状态下一个最优决策），一步一步地向全局最优解逼近，最终获取全局最优解。  
从算法设计的角度看，贪心算法具有思维复杂度低、代码量小、运行效率高、空间复杂度低等优点。但是，其局限性也是很明显的：贪心算法合理性的前提是每一步的局部最优解一定能够逼近到全局最优解，有时很难保证能够做到这一点，这称为贪心算法的非完美性。贪心算法从本质上缺少大局观思想，会给我们直接使用贪心算法带来很大的困难，因为有时很难找到一个简单可行并具有完美性的贪心思路，即使找到一个看上去很完美的贪心思路，也需要严格地证明其正确性。不过值得庆幸的是，虽然并不是所有问题都可通过贪心算法获得整体最优解，但是由此至少可以得到一个近似最优解。"
费马小定理,定理,"['第二章  整数与算法设计基础', '§ 2.2 同余算术及其应用', '2.2.3 整数加密算法']","{'实体类型': '定理', '内容': '假设p是一个任意给定的素数，则对于任意整数a，有a^p≡a(mod p)，特别地，当a与p互素时，有a^(p-1)≡1(mod p)'}",,3,"为防止机密信息被泄露或破坏，需采用数据加密技术对其进行保护。数据加密的基本思想是对原始数据加以伪装，使非法接入者无法理解信息的真正含义，基本过程就是对原来为明文信息或数据按某种算法进行处理，使其成为不可读的一段代码，称为密文，使其只能在输入相应密钥之后才能显示出本来内容。数据加密通常分为对称式加密和非对称式加密两大类。本节介绍两种基于整数理论的经典加密算法，一种是名为仿射加密算法的对称加密算法，另一种是名为RSA 的非对称加密算法。  
仿射加密算法又称为凯撒加密算法，是一种简单且广为人知的加密技术。它是一种替换加密技术，基本思想如下：首先使用0 到25 之间的数字表示A 到Z 这26 个字母。然后，对于每个不大于25 的非负整数$\cdot p$，定义其加密函数值$f(p)$为$\{0,1,2,\ \cdots,25\}$中某个数字。加密函数$f(p)$的有多种定义方法，例如可采用如下加密函数：  
$$
f(p)=(p+3)\;{\bmod{\,}}26
$$  
对于上述加密函数，此时用整数$(p+3)\,\mathrm{mod}\,26$代表的字母替代由整数$p$表示的字母实现加密。例如，对“WELCOME TO HEFEI”进行加密，首先用数字代替字母，然后使用加密函数$f(p)=(p+3)\mod 26$ 代替$p$，翻译成字母后，得到获得到的加密信息为：“ZHOFRPH VR KHIHL”具体过程如下：  
表2-3 凯撒密码的加密过程
![](images/168580ee1913d8c32220b048da1875515ce367981f5bce7472f95af1471231b8.jpg)  
解密则需要使用加密函数的$f(p)$反函数 $f^{-1}(p)$  
$$
f^{-1}(p)=(p-3){\bmod{\,}}26
$$  
解密时需将加密信息转换成数字，然后使用$f^{-1}(p)$把$\{0,1,2,\ \cdots,25\}$中整数$\cdot p$恢复成信息原文对应的整数，之后再将数字装换成字母获得原文。  
RSA 算法由三位数学家Rivest、Shamir 和Adleman 于1977 年共同提出，是至今最为广泛使用的非对称加密算法，特别适合于对通过互联网传送的数据进行加密，通常于数字签名等场合。RSA 算法使用整数模余运算性质生成公钥和私钥，并进行加密和解密。RSA 算法原理基于欧拉定理和费马小定理，为此首先介绍这两个定理。  
【定理2.29】（欧拉定理）设$m$ 是任一正整数，$a$ 是任一与$m$ 互素的整数，则有：  
$$
a^{\varphi(m)}\equiv1({\bmod{\ m}})\tag{2-15}
$$  
其中$\varphi(m)$是欧拉函数。  
如果上述猜想能够成立，则提供了一个非常有效的素数判定方法。但是遗憾的是，上述猜想并不成立。事实上，$p$ 为只要是素数，则其必满足上式，但反之不然。法国数学家给出了如下称之为费马小定理更一般结论：  
【定理2.30】（费马小定理）假设$p$ 是一个任意给定的素数，则对于任意整数$a$，有：  
$$
a^{p}\equiv a({\bmod{\ p}})\tag{2-16}
$$  
特别地，当$a$与$p$ 互素时，有：$a^{p-1}\equiv1({\bmod{\ p}})$。  
下面介绍RSA 算法的基本原理和具体计算过程。RSA 算法理论基础是同余算术以及欧拉定理和费马小定理，其安全性依赖于大整数素因子分解的困难性，即已知整数$n$ 是两个大素数$p$ 和$q$ 的乘积，则难以在可接受的时间范围内通过$n$ 的素因子分解方法获得$p$ 和$q$ 的取值。RSA 算法的密钥生成、加密、解密的具体过程如下：  
1） 密钥的生成  
首先生成两个互不相同的大素数$p$ 和$q$，并令$n=p\cdot q$。其中$p$ 和$q$ 是属于解密信息，不可对外公开，整数$n$ 属于加密信息，需要对外公开。  
然后，令$\varphi(n)=(p-1)(q-1)$，并任意选择一个与$\varphi(n)$互素的正整数$e$，满足：  
$2\leq e\leq\varphi(n)$  
其中$\varphi(n)$不可对外公开，$e$ 为加密密钥，需要对外公开。  
由于$p$ 和$q$ 都是素数，故小于$p$ 且与$p$ 互素的非负整数的个数为$(p-1)$个，小于$q$ 且与$q$ 互素的非负整数的个数为$(q-1)$个。注意到$n=p\cdot q$，由计数的乘法原理及素数的性质可知，小于$\cdot n$且与$n$互素的非负整数的个数为$(p-1)$ $(q-1)$个，因此，$\varphi(n)=(p-1)(q-$1)其实就是欧拉函数。  
由于$e$ 的模$\varphi(n)$互素，因此$e$ 的模$\varphi(n)$同余逆$d$存在且唯一。算出$e$ 的模$\varphi(n)$同余逆$d$，使其满足：  
$$
e d\equiv1({\bmod{\ }}\varphi(n))\tag{2-17}
$$  
整数$d$ 属于解密密钥，不可对外公开。  
由此得到RSA 加密算法中作为公钥的加密密钥$e$，作为私钥的解密密钥$d$。  
2） 加密过程  
在RSA 加密算法中，要将明文信息转化成若干组整数序列。为此，首先将每个字母翻译成相应的整数，例如可以使用前述的凯撒加密算法完成这项工作。然后，将这些由明文字母对应的整数合并成若干组，每个组分别形成一个大整数，代表一个字母段。  
RSA 加密过程其实就是每个表示明文字母段的大整数$M$逐个转化为表示密文字母段的大整数$C$，具体转化公式如下：  
$$
C=M^{e}{\pmod{n}}\tag{2-18}
$$  
在转化过程中总是假定$M<n$。如果$M\geq n$，则需要对表示明文的所有整数重新进行分组以确保每个字母段对应的大整数小于$n$。  
3） 解密过程  
由于$d$ 是$e$ 的模$\varphi(n)$逆，即是$e$ 的模$(p-1)(q-1)$逆，故有：  
$$
e d\equiv1(\bmod(p-1)(q-1))\tag{2-19}
$$  
也就是说，$_{e d}$除以$(p-1)(q-1)$的余数为1，故存在整数$k$，使得：  
$$
e d={\begin{array}{l}{(p-1)(q-1)k+1}\end{array}}
$$  
故有：  
$$
C^{d}\equiv(M^{e})^{d}\equiv M^{e d}\equiv M^{(p-1)(q-1)k+1}\,({\mathrm{mod}}\,\,n)
$$  
假定$M$与$p$ 和$q$ 均为互素，则根据费马小定理有：  
$$
M^{p-1}\equiv1(\mathrm{\;mod}\;\left(p\right))\mathcal{X}M^{p-1}\equiv1(\mathrm{\;mod}\;\,q)
$$  
从而有：  
$$
\begin{array}{r}{C^{d}\equiv M^{(p-1)(q-1)k+1}\equiv\!\!M\!\cdot\!(M^{p-1})^{k(q-1)}\!\!\equiv\!\!M\!\cdot\!1\!\equiv\!\!M\,(\mathrm{mod}\,p)}\\ {C^{d}\equiv M^{(p-1)(q-1)k+1}\equiv\!\!M\!\cdot\!(M^{q-1})^{k(p-1)}\!\!\equiv\!\!M\!\cdot\!1\!\equiv\!\!M\,(\mathrm{mod}\,q)}\end{array}
$$  
由于$p$ 与$q$ 互素，则根据中国余数定理，有：  
$$
C^{d}\equiv M\,({\sf m o d}\,\,\,p\cdot q)\mathbb{\bar{X}}C^{d}\equiv M\,({\sf m o d}\,\,\,n)
$$  
由于$M<n$，故必有：$M=C^{d}\;({\mathsf{m o d}}\;\,n)$  
因此，若已知解密密钥$d$，就可使用公式$M=C^{d}\,({\sf m o d}\,n),$对密文$C$ 进行解密。  
在RSA 加密和解密算法中，如果$p,\ q$ 被信息窃取者获得，则可算出$(p-1)(q-1).$。由于$e$ 是公开密钥，且$d$是$e$ 关于关于模$(p-1)(q-1)$的逆，则不难求出$d$，如此RSA 系统便被完全攻破，信息窃取者就会很容易获得加密的信息。  
RSA 算法中的素数都是十进制整数，怎样才能选择好的$p$ 和$q$，这是$R S A$ 加密算法最关键的问题。针对素数$p$ 和$q$ 的选择，1978 年Rivest 等人在关于RSA 公开密钥的论文中，建议对素数$p$ 和$q$ 的选择应当满足：  
1）$p$ 和$q$ 要足够长，在长度上应相差几位，且二者之差与$p$ 和$q$ 位数相近；  
2）$p{-}1$ 和$q{-}1$ 的最大公约数$\operatorname*{gcd}(p -1\,,\,\,\,q-\!\!1)$要尽量小；  
3）$p{-}1$ 和$q{-}1$ 均应至少含有一个大的素数因子。  
并把满足这些条件的素数称为安全素数。  
从实用的观点看，如果加密后的信息能够保证在足够长的时间内不能被破解，则认为这个加密方法是安全的。相对于RSA 加密算法而言，如果整数$n$ 不是足够大，例如只有10 位，那么按照计算机目前的计算能力，几乎可以立刻求出其所有素因子实现对RSA 加密算法的破解。如果计算机的计算能力得到进一步的提高，则或许能够破解200 位的整数$n$。但是，如果使用200 素数$p$ 和200 位素数$q$ 构成400 位整数$n$，则计算机无法破解由此设计的RSA加密算法。因此，就目前以及今后一段时间而言，RSA 加密算法具有较好的安全性。"
赋权图,概念,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.2 图的定义与分类']","{'实体类型': '概念', '定义': '边或结点有权重的图，记为三重组<V,E,g>'}",,3,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)"
路径记录矩阵,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.4.4 多源最短路径']","{'实体类型': '概念', '定义': '记录图中每对结点之间当前最短路径中必经的一个中间点的矩阵', '用途': '用于在算法过程中更新和记录路径中间点'}",,3,"迪杰斯特拉算法解决的是单源最短路径问题，只能求出单独某个源点到其它结点最短路径，然而沃舍尔∙弗洛伊德算法则是求得这个图中任意对结点之间的最短路径长度。  
沃舍尔∙弗洛伊德算法的基本思想是通过逐次增加中介结点的途径，不断优化和更新图中每对结点之间的路径长度。首先，将$v_{1}$作为中介结点，据此更新图中仅以$v_{1}$作为中介结点的路径长度以及相应的路径记录。然后在$v_{1}$的基础上，进一步引入${{v}}_{2}$作为新增的中介结点，并更新图中仅以$v_{1}v_{2}$作为中介结点的路径长度和路径记录。依次类推，在$v_{1}v_{2}v_{3}\ldots v_{k}$作为中介结点的基础上，以$v_{k}$作为新增中介结点计算并更新图中以$v_{1}v_{2}v_{3}\ldots v_{k}$为中介结点的每对结点之间路径长度和路径记录。这样当$k=n$(𝑛为结点个数)时，便可求出图中每对结点的最短路径长度及其相应的路径记录。  
从上面描述的基本思想可以知道，在整个问题解决中有两个点非常重要，一个是路径长度，一个是路径记录，为了方便叙述，我们分别定义相应的矩阵用于记录数据，$D^{(k)}(v_{i},v_{j})$表示在考虑了$v_{1}v_{2}v_{3}\ldots v_{k}$作为中介结点的基础上，结点$v_{i}$与$v_{j}$的当前最短路径长度。$R^{(k)}(v_{i},v_{j})$ 是一个包含结点元素的矩阵，表示在考虑了$v_{1}v_{2}v_{3}\ldots v_{k}$作为中介结点的基础上，结点$v_{i}$与$v_{j}$的当前最短路径长度中必经的一个中间点。  
需要注意的是，在还没有考虑中介结点的最初情况时，应该按如下方法初始化$D$和$R$矩阵元素值，对于图中任意两个相邻结点$v_{i}$和$v_{j}$，即存在一条边$(v_{i},v_{j})$，边上权值为$w(v_{i},v_{j})$，那其长度为$D^{(0)}\big(v_{i},v_{j}\big)=w(v_{i},v_{j})$，否则规定$v_{i}$与$v_{j}$存在一条假想边$(v_{i},v_{j})$，令其长度为无穷大。另外，在尚未开始算法迭代时，将$\cdot R$矩阵每行内容分别置为$v_{j}(j=1,2,3\ldots n)$。  
下面以结点$v_{i}$到$v_{j}$为代表，详细介绍具体计算过程：  
首先，将$v_{1}$作为从$v_{i}$到$v_{j}$的中介结点，进行比较路径$\left(v_{i},v_{j}\right)$和$(v_{i},v_{1},v_{j})$长度的大小，若路径$\left(v_{i},v_{j}\right)$的长度不大于$\left(v_{i},v_{1},v_{j}\right)$的长度，那么取$(v_{i},v_{j})$为从$v_{i}$到$v_{j}$的当前最短路径，即$D^{(1)}\big(v_{i},v_{j}\big)=w(v_{i},v_{j})$，此时不需要更新路径记录矩阵$R$；若是路径$\left(v_{i},v_{1},v_{j}\right)$的长度较小，则取$\left(v_{i},v_{1},v_{j}\right)$为从$v_{i}$到$v_{j}$的当前最短路径，即：  
$$
D^{(1)}\big(v_{i},v_{j}\big)=w(v_{i},v_{1})+w\big(v_{1},v_{j}\big)
$$  
并将$v_{1}$暂时作为$v_{i}$到$v_{j}$的中间点，即$R^{(1)}{\bigl(}v_{i},v_{j}{\bigr)}=v_{1}.$。需要注意的是，当前最短路径中介结点序号不大于1，即当前最短路径只可能经由中介点$v_{1}$。  
对$v_{i}$到$v_{j}$的中介结点集合，再引入结点$v_{2}$，即$v_{i}$到$v_{j}$的中介结点为${v}_{1}$和$v_{2}$。首先确定$(v_{i},\ldots,v_{2})$和$(v_{2},\ldots,v_{j})$分别是当前找到的最短路径（只可能经由中介结点$v_{1}$），则$\left(v_{i},\ldots,v_{2},\ldots,v_{j}\right)$有可能是从$v_{i}$到$v_{j}$的最短路径（只可能经由中介结点$v_{1}$和$v_{2}$）。将其与当前从$v_{i}$到$v_{j}$的最短路径$(v_{i},\ldots,v_{j})$进行比较（只可能经由中介结点$v_{1}$），从中选出从${v}_{i}$到$v_{j}$的最短路径（此时只可能经由中介结点$v_{1}$和$v_{2}$），并按照上述的原则更新相应的$D$和$R$。如此下去，直到将图中所有结点加入${v}_{i}$到$v_{j}$的中介结点集合。  
对于一般情形， $(v_{i},\ldots,v_{k})$和$(v_{k},\ldots,v_{j})$分别是从${v}_{i}$到$v_{k}$和从${{v}}_{k}$到$v_{j}$的当前最短路径(中间路径只可能经过$v_{1}v_{2}v_{3}\ldots v_{k-1})$，则将$\left(v_{i},\ldots,v_{k},\ldots,v_{j}\right)$与从$v_{i}$到$v_{j}$的当前最短路径$\left(v_{i},\ldots,v_{j}\right)$（中间路径只可能经过$v_{1}v_{2}v_{3}\ldots v_{k-1})$）进行比较，其长度较短者便是从${v}_{i}$到$v_{j}$的当前最短路径（此时引入了$v_{k}$，故中间路径可能经由$v_{1}v_{2}v_{3}\ldots v_{k})$。若$(v_{i},\ldots,v_{k})$和$(v_{k},\ldots,v_{j})$ 组合起来的路径 $\left(v_{i},\ldots,v_{k},\ldots,v_{j}\right)$ 不大于引入中介结点 $v_{k}$ 的路径长度， 则当前路径长度矩阵 $.D$ 和路径记录矩阵$R$不做任何更新。否则：$\begin{array}{r}{D^{(k)}\big(v_{i},v_{j}\big)=w(v_{i},v_{k})+w\big(v_{k},v_{j}\big),\;\;R^{(k)}\big(v_{i},v_{j}\big)=}\end{array}$$v_{k}$。  
在中介结点集合中增加所有可能的中介结点后，最后求得最短路径的必然是从${v}_{i}$到$v_{j}$的最短路径。由$v_{i}$和$v_{j}$的任意性，可求得各对结点间的最短路径。  
具体地说，沃舍尔∙弗洛伊德算法的基本步骤如下：  
（1）首先进行初始化操作。  
![](images/81a82f8a70a1c69c5768fae83738a36908b9e06f149f4c5733693401ae15cac2.jpg)  
$$
R^{(0)}\big(v_{i},v_{j}\big)=v_{j}
$$  
（2）按如下的原则，将图中的每个结点$v_{k}(k=1,\!2,\dots,n)$分别作为中介结点，更新$D$和$R$矩阵，依次获得矩阵$D^{(1)},D^{(2)},\dots,D^{(n)}$和$R^{(1)},R^{(2)},\ldots,R^{(n)}$。  
(i)若$D^{(k-1)}\big(v_{i},v_{j}\big)>D^{(k-1)}(v_{i},v_{k})+D^{(k-1)}\big(v_{k},v_{j}\big),$  则，  
$$
D^{(k)}\!\left(v_{i},v_{j}\right)\!\!=\!\!D^{(k-1)}(v_{i},v_{k})\!+\!D^{(k-1)}\!\left(v_{k},v_{j}\right)\!;\,\,\,R^{(k)}\!\left(v_{i},v_{j}\right)=v_{k}
$$  
(ii)  若 $ D^{(k-1)}\!\left(v_{i},v_{j}\right)\leq D^{(k-1)}\!\left(v_{k},v_{j}\right)\!+\!D^{(k-1)}\!\left(v_{k},v_{j}\right)$ ，则，   $D^{(k)}\!\left(v_{i},v_{j}\right)\!\!=\!\!D^{(k-1)}\!\left(v_{i},v_{j}\right)\!;\,\,\,R^{(k)}\!\left(v_{i},v_{j}\right)=R^{(k-1)}\!\left(v_{i},v_{j}\right)$  
（3）根据矩阵${ D}^{(n)}$和$R^{(n)}$，计算任意结点之间的最短路径长度和路径序列。以$v_{i}$和$v_{j}$为例计算两者的最短路径序列：若$R^{(n)}=v_{k}$，则在$v_{i}$到$v_{j}$的最短路径中必有中间结点$v_{k}$，那么根据如下规则，分别向$v_{k}$两头追溯一定可以得到$v_{i}$到$v_{j}$的最短路径：  
(i) 向点$v_{i}$方向追溯可以得到：  
$$
R^{(n)}(v_{i},v_{k})=v_{k-1},\ R(v_{i},v_{k-1})=v_{k-2},...,\ R^{(n)}(v_{i},v_{k-m})=v_{i}
$$  
(ii) 向点$v_{j}$方向追溯可以得到：  
$$
R^{(n)}\big(v_{k},v_{j}\big)=v_{k+1},\ R^{(n)}\big(v_{k+1},v_{j}\big)=v_{k+2},...,\ R^{(n)}(v_{i},v_{k+s})=v_{j}
$$  
追溯方向图，如下图8-61 所示。  
![图8-61 通过路径矩阵寻找具体的最短路径  ](images/6a3ea39179dd4fb30e351249de4e2648087eaf5e2356569531de0cb959af6180.jpg)  
由此可见，通过路径长度矩阵$D$和路径记录矩阵$R$，可以求出图中任意一对结点之间的最短路径。"
路径长度矩阵,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.4.4 多源最短路径']","{'实体类型': '概念', '定义': '记录图中每对结点之间当前最短路径长度的矩阵', '用途': '用于在算法过程中更新和记录路径长度'}",,3,"迪杰斯特拉算法解决的是单源最短路径问题，只能求出单独某个源点到其它结点最短路径，然而沃舍尔∙弗洛伊德算法则是求得这个图中任意对结点之间的最短路径长度。  
沃舍尔∙弗洛伊德算法的基本思想是通过逐次增加中介结点的途径，不断优化和更新图中每对结点之间的路径长度。首先，将$v_{1}$作为中介结点，据此更新图中仅以$v_{1}$作为中介结点的路径长度以及相应的路径记录。然后在$v_{1}$的基础上，进一步引入${{v}}_{2}$作为新增的中介结点，并更新图中仅以$v_{1}v_{2}$作为中介结点的路径长度和路径记录。依次类推，在$v_{1}v_{2}v_{3}\ldots v_{k}$作为中介结点的基础上，以$v_{k}$作为新增中介结点计算并更新图中以$v_{1}v_{2}v_{3}\ldots v_{k}$为中介结点的每对结点之间路径长度和路径记录。这样当$k=n$(𝑛为结点个数)时，便可求出图中每对结点的最短路径长度及其相应的路径记录。  
从上面描述的基本思想可以知道，在整个问题解决中有两个点非常重要，一个是路径长度，一个是路径记录，为了方便叙述，我们分别定义相应的矩阵用于记录数据，$D^{(k)}(v_{i},v_{j})$表示在考虑了$v_{1}v_{2}v_{3}\ldots v_{k}$作为中介结点的基础上，结点$v_{i}$与$v_{j}$的当前最短路径长度。$R^{(k)}(v_{i},v_{j})$ 是一个包含结点元素的矩阵，表示在考虑了$v_{1}v_{2}v_{3}\ldots v_{k}$作为中介结点的基础上，结点$v_{i}$与$v_{j}$的当前最短路径长度中必经的一个中间点。  
需要注意的是，在还没有考虑中介结点的最初情况时，应该按如下方法初始化$D$和$R$矩阵元素值，对于图中任意两个相邻结点$v_{i}$和$v_{j}$，即存在一条边$(v_{i},v_{j})$，边上权值为$w(v_{i},v_{j})$，那其长度为$D^{(0)}\big(v_{i},v_{j}\big)=w(v_{i},v_{j})$，否则规定$v_{i}$与$v_{j}$存在一条假想边$(v_{i},v_{j})$，令其长度为无穷大。另外，在尚未开始算法迭代时，将$\cdot R$矩阵每行内容分别置为$v_{j}(j=1,2,3\ldots n)$。  
下面以结点$v_{i}$到$v_{j}$为代表，详细介绍具体计算过程：  
首先，将$v_{1}$作为从$v_{i}$到$v_{j}$的中介结点，进行比较路径$\left(v_{i},v_{j}\right)$和$(v_{i},v_{1},v_{j})$长度的大小，若路径$\left(v_{i},v_{j}\right)$的长度不大于$\left(v_{i},v_{1},v_{j}\right)$的长度，那么取$(v_{i},v_{j})$为从$v_{i}$到$v_{j}$的当前最短路径，即$D^{(1)}\big(v_{i},v_{j}\big)=w(v_{i},v_{j})$，此时不需要更新路径记录矩阵$R$；若是路径$\left(v_{i},v_{1},v_{j}\right)$的长度较小，则取$\left(v_{i},v_{1},v_{j}\right)$为从$v_{i}$到$v_{j}$的当前最短路径，即：  
$$
D^{(1)}\big(v_{i},v_{j}\big)=w(v_{i},v_{1})+w\big(v_{1},v_{j}\big)
$$  
并将$v_{1}$暂时作为$v_{i}$到$v_{j}$的中间点，即$R^{(1)}{\bigl(}v_{i},v_{j}{\bigr)}=v_{1}.$。需要注意的是，当前最短路径中介结点序号不大于1，即当前最短路径只可能经由中介点$v_{1}$。  
对$v_{i}$到$v_{j}$的中介结点集合，再引入结点$v_{2}$，即$v_{i}$到$v_{j}$的中介结点为${v}_{1}$和$v_{2}$。首先确定$(v_{i},\ldots,v_{2})$和$(v_{2},\ldots,v_{j})$分别是当前找到的最短路径（只可能经由中介结点$v_{1}$），则$\left(v_{i},\ldots,v_{2},\ldots,v_{j}\right)$有可能是从$v_{i}$到$v_{j}$的最短路径（只可能经由中介结点$v_{1}$和$v_{2}$）。将其与当前从$v_{i}$到$v_{j}$的最短路径$(v_{i},\ldots,v_{j})$进行比较（只可能经由中介结点$v_{1}$），从中选出从${v}_{i}$到$v_{j}$的最短路径（此时只可能经由中介结点$v_{1}$和$v_{2}$），并按照上述的原则更新相应的$D$和$R$。如此下去，直到将图中所有结点加入${v}_{i}$到$v_{j}$的中介结点集合。  
对于一般情形， $(v_{i},\ldots,v_{k})$和$(v_{k},\ldots,v_{j})$分别是从${v}_{i}$到$v_{k}$和从${{v}}_{k}$到$v_{j}$的当前最短路径(中间路径只可能经过$v_{1}v_{2}v_{3}\ldots v_{k-1})$，则将$\left(v_{i},\ldots,v_{k},\ldots,v_{j}\right)$与从$v_{i}$到$v_{j}$的当前最短路径$\left(v_{i},\ldots,v_{j}\right)$（中间路径只可能经过$v_{1}v_{2}v_{3}\ldots v_{k-1})$）进行比较，其长度较短者便是从${v}_{i}$到$v_{j}$的当前最短路径（此时引入了$v_{k}$，故中间路径可能经由$v_{1}v_{2}v_{3}\ldots v_{k})$。若$(v_{i},\ldots,v_{k})$和$(v_{k},\ldots,v_{j})$ 组合起来的路径 $\left(v_{i},\ldots,v_{k},\ldots,v_{j}\right)$ 不大于引入中介结点 $v_{k}$ 的路径长度， 则当前路径长度矩阵 $.D$ 和路径记录矩阵$R$不做任何更新。否则：$\begin{array}{r}{D^{(k)}\big(v_{i},v_{j}\big)=w(v_{i},v_{k})+w\big(v_{k},v_{j}\big),\;\;R^{(k)}\big(v_{i},v_{j}\big)=}\end{array}$$v_{k}$。  
在中介结点集合中增加所有可能的中介结点后，最后求得最短路径的必然是从${v}_{i}$到$v_{j}$的最短路径。由$v_{i}$和$v_{j}$的任意性，可求得各对结点间的最短路径。  
具体地说，沃舍尔∙弗洛伊德算法的基本步骤如下：  
（1）首先进行初始化操作。  
![](images/81a82f8a70a1c69c5768fae83738a36908b9e06f149f4c5733693401ae15cac2.jpg)  
$$
R^{(0)}\big(v_{i},v_{j}\big)=v_{j}
$$  
（2）按如下的原则，将图中的每个结点$v_{k}(k=1,\!2,\dots,n)$分别作为中介结点，更新$D$和$R$矩阵，依次获得矩阵$D^{(1)},D^{(2)},\dots,D^{(n)}$和$R^{(1)},R^{(2)},\ldots,R^{(n)}$。  
(i)若$D^{(k-1)}\big(v_{i},v_{j}\big)>D^{(k-1)}(v_{i},v_{k})+D^{(k-1)}\big(v_{k},v_{j}\big),$  则，  
$$
D^{(k)}\!\left(v_{i},v_{j}\right)\!\!=\!\!D^{(k-1)}(v_{i},v_{k})\!+\!D^{(k-1)}\!\left(v_{k},v_{j}\right)\!;\,\,\,R^{(k)}\!\left(v_{i},v_{j}\right)=v_{k}
$$  
(ii)  若 $ D^{(k-1)}\!\left(v_{i},v_{j}\right)\leq D^{(k-1)}\!\left(v_{k},v_{j}\right)\!+\!D^{(k-1)}\!\left(v_{k},v_{j}\right)$ ，则，   $D^{(k)}\!\left(v_{i},v_{j}\right)\!\!=\!\!D^{(k-1)}\!\left(v_{i},v_{j}\right)\!;\,\,\,R^{(k)}\!\left(v_{i},v_{j}\right)=R^{(k-1)}\!\left(v_{i},v_{j}\right)$  
（3）根据矩阵${ D}^{(n)}$和$R^{(n)}$，计算任意结点之间的最短路径长度和路径序列。以$v_{i}$和$v_{j}$为例计算两者的最短路径序列：若$R^{(n)}=v_{k}$，则在$v_{i}$到$v_{j}$的最短路径中必有中间结点$v_{k}$，那么根据如下规则，分别向$v_{k}$两头追溯一定可以得到$v_{i}$到$v_{j}$的最短路径：  
(i) 向点$v_{i}$方向追溯可以得到：  
$$
R^{(n)}(v_{i},v_{k})=v_{k-1},\ R(v_{i},v_{k-1})=v_{k-2},...,\ R^{(n)}(v_{i},v_{k-m})=v_{i}
$$  
(ii) 向点$v_{j}$方向追溯可以得到：  
$$
R^{(n)}\big(v_{k},v_{j}\big)=v_{k+1},\ R^{(n)}\big(v_{k+1},v_{j}\big)=v_{k+2},...,\ R^{(n)}(v_{i},v_{k+s})=v_{j}
$$  
追溯方向图，如下图8-61 所示。  
![图8-61 通过路径矩阵寻找具体的最短路径  ](images/6a3ea39179dd4fb30e351249de4e2648087eaf5e2356569531de0cb959af6180.jpg)  
由此可见，通过路径长度矩阵$D$和路径记录矩阵$R$，可以求出图中任意一对结点之间的最短路径。"
轮换,概念,"['第七章 函数与特殊函数', '§ 7.4 有限集的置换函数', '7.4.3  置换的轮换分解']","{'实体类型': '概念', '定义': '设A是任一非空有限集合，如果A上的某个置换P把元素a1变成a2, a2变成a3, ..., ak变成a1(k≤n)，但别的元素都不变，则称P是一个长度为k的轮换', '特点': '以元素变化次序为序，描述一种轮换过程', '性质': '轮换的乘法不满足交换律'}",,3,"细心的读者可能会发现，前面几个置换函数例题的排列元素都只有3 个，这是主要因为置换数目的增长速度为排列元素数目的阶乘${n!}$，如果$n$比较大，则问题的规模会迅速增大而变得不可行。因此，对于有限集合$A=\{a_{1},a_{2},\cdots,a_{n}\}$上的置换，当$n$比较大时，就必须置换进行分解。现在我们考察对置换进行分解的具体方法。  
首先考察一种特殊的置换，在这种置换中的一些元素的函数映射呈现出一种循环的状态，而其余元素则的映射为恒等映射。例如，对于如下置换：  
$\begin{pmatrix}1&2&3&4&5&6&7&8\\4&3&5&2&1&6&7&8\end{pmatrix}$  
元素1 映射到4，元素4 映射到2，元素2 映射到3，元素3 映射到5，元素5 映射到1，然后循环。置换中这5 个元素1, 4, 2, 3, 5形成一个循环，而其余元素6, 7, 8则保持恒等映射，此时称这样的置换为长度为5 的轮换，记为(1, 4, 2, 3, 5),即有：  
$\begin{pmatrix}1&2&3&4&5&6&7&8\\4&3&5&2&1&6&7&8\end{pmatrix}=(1,4,2,3,5)  $  
轮换的具体定义如下：  
【定义7.14】设$A=\{a_{1},a_{2},\cdots,a_{n}\}$是任一非空有限集合，如果$𝐴$上的某个置换$P$把元素$a_{1}$变成$a_{2}$, $a_{2}$变成$a_{3},\ \cdots,a_{k-1}$变成$a_{k}$，又把$a_{k}$变成$a_{1}(k\leq n)$，但别的元素（如果有的话）都不变，则称$ P$是一个长度为$k$的轮换，简称为$\pmb{k}{-}$轮换，并将其记为$(a_{1},a_{2},\cdots,a_{k})$。其中长度为2 的轮换称为对换。  
由上述定义可知，轮换是置换另一种表达方式，它以元素变化次序为序，描述一种轮换过程$(a_{1},a_{2},\cdots,a_{k})=(a_{2},a_{3},\cdots,a_{k}a_{1})=\cdots=(a_{k},a_{1},\cdots,a_{k-1})。$例如对于轮换$(1,4, 2, 3, 5)$，有：$(1,4,2,3,5)=(\begin{array}{ccc}4,2,3,5,1)=(&2,3,5,1,4)=\cdots=(5,1,4,2,3)。\end{array}$  
值得注意的是，虽然轮换表达方式比置换更加简洁，轮换不能表达其所在置换的元素数目，需要采用其它方式说明置换的元素数目。  
现在考察轮换的运算。由于轮换是一种特殊的置换，故可像置换那样进行乘法运算。例如，对于集合$ A=\{1,2,3,4,5,6\}$上的两个轮换$(4,1,3,5)$和$(5,6,3)$，则可计算它们的乘积：  
$(4,1,3,5)\cdot(5,6,3)=\begin{pmatrix}1&2&3&4&5&&6\\3&2&5&1&4&&6\end{pmatrix}\cdot\begin{pmatrix}1&2&3&4&5&&6\\1&2&5&4&6&&3\end{pmatrix}$  
$=\begin{pmatrix}1&2&3&4&5&&6\\3&2&4&1&6&&5\end{pmatrix}$  
$\begin{aligned}(5,6,3)\cdot(4,1,3,5)&=\begin{pmatrix}1&2&3&4&5&6\\1&2&5&4&6&3\end{pmatrix}\cdot\begin{pmatrix}1&2&3&4&5&6\\3&2&5&1&4&6\end{pmatrix}.\\&=\begin{pmatrix}1&2&3&4&5&6\\5&2&6&1&4&3\end{pmatrix}\end{aligned}$  
可以看出$(4,\!1,\!3,\!5)\cdot(5,\!6,\!3)\neq(5,\!6,\!3)\cdot(4,\!1,\!3,\!5)$。因此，轮换的乘法不满足交换律。 显然，并不是每个置换都能成为轮换。例如，对于如下8 阶置换：  
$$
\tau=\begin{pmatrix}1&2&3&4&5&6&7\\3&5&6&4&2&1&7\end{pmatrix}
$$  
其不可能是轮换。但我们发现：  
$$
\tau=\begin{pmatrix}1&2&3&4&5&6&7\\3&5&6&4&2&1&7\end{pmatrix}
$$  
$$
=\bigl(\begin{matrix}1&2&3&4&5&6&7\\3&2&6&4&5&1&7\end{matrix}\bigr)\bigl(\begin{matrix}1&2&3&4&5&6&7\\1&5&3&4&2&6&7\end{matrix}\bigr)
$$  
$\quad\quad\quad\quad\quad=(\begin{matrix}1&3&6\\\end{matrix})(\begin{matrix}2&5\\\end{matrix})$  
由此可见，$\tau$虽不是轮换，但它可分解成是轮换的乘积。这为解决置换分解问题提供了一个思路。下面考虑对任意置换的轮换分解问题。首先给从下列定义：  
【定义7.15】设$\pi=(i_{1},i_{2},\cdots,i_{t})$和$\tau=(j_{1},j_{2},\cdots,j_{s})$都是轮换，如果$\pi$和$\cdot_{\tau}$不含相同的元素，则称$\pi$与$\tau$是不相交的。  
例如，集合$A=\{1,\!2,\!3,\!4,\!5,\!6\}$上的两个轮换(1,2,5)和(3,4,6)之间是不相交的，而轮换(1,2,5)和(2,4,6)之间则是相交的。  
下面给出对任意置换的轮换分解定理：  
【定理7.10】（轮换分解定理）任一$ n$元置换都可写成若干个不相交轮换的乘积。"
轮换分解定理,定理,"['第七章 函数与特殊函数', '§ 7.4 有限集的置换函数', '7.4.3  置换的轮换分解']","{'实体类型': '定理', '结论': '任一n元置换都可写成若干个不相交轮换的乘积'}",,3,"细心的读者可能会发现，前面几个置换函数例题的排列元素都只有3 个，这是主要因为置换数目的增长速度为排列元素数目的阶乘${n!}$，如果$n$比较大，则问题的规模会迅速增大而变得不可行。因此，对于有限集合$A=\{a_{1},a_{2},\cdots,a_{n}\}$上的置换，当$n$比较大时，就必须置换进行分解。现在我们考察对置换进行分解的具体方法。  
首先考察一种特殊的置换，在这种置换中的一些元素的函数映射呈现出一种循环的状态，而其余元素则的映射为恒等映射。例如，对于如下置换：  
$\begin{pmatrix}1&2&3&4&5&6&7&8\\4&3&5&2&1&6&7&8\end{pmatrix}$  
元素1 映射到4，元素4 映射到2，元素2 映射到3，元素3 映射到5，元素5 映射到1，然后循环。置换中这5 个元素1, 4, 2, 3, 5形成一个循环，而其余元素6, 7, 8则保持恒等映射，此时称这样的置换为长度为5 的轮换，记为(1, 4, 2, 3, 5),即有：  
$\begin{pmatrix}1&2&3&4&5&6&7&8\\4&3&5&2&1&6&7&8\end{pmatrix}=(1,4,2,3,5)  $  
轮换的具体定义如下：  
【定义7.14】设$A=\{a_{1},a_{2},\cdots,a_{n}\}$是任一非空有限集合，如果$𝐴$上的某个置换$P$把元素$a_{1}$变成$a_{2}$, $a_{2}$变成$a_{3},\ \cdots,a_{k-1}$变成$a_{k}$，又把$a_{k}$变成$a_{1}(k\leq n)$，但别的元素（如果有的话）都不变，则称$ P$是一个长度为$k$的轮换，简称为$\pmb{k}{-}$轮换，并将其记为$(a_{1},a_{2},\cdots,a_{k})$。其中长度为2 的轮换称为对换。  
由上述定义可知，轮换是置换另一种表达方式，它以元素变化次序为序，描述一种轮换过程$(a_{1},a_{2},\cdots,a_{k})=(a_{2},a_{3},\cdots,a_{k}a_{1})=\cdots=(a_{k},a_{1},\cdots,a_{k-1})。$例如对于轮换$(1,4, 2, 3, 5)$，有：$(1,4,2,3,5)=(\begin{array}{ccc}4,2,3,5,1)=(&2,3,5,1,4)=\cdots=(5,1,4,2,3)。\end{array}$  
值得注意的是，虽然轮换表达方式比置换更加简洁，轮换不能表达其所在置换的元素数目，需要采用其它方式说明置换的元素数目。  
现在考察轮换的运算。由于轮换是一种特殊的置换，故可像置换那样进行乘法运算。例如，对于集合$ A=\{1,2,3,4,5,6\}$上的两个轮换$(4,1,3,5)$和$(5,6,3)$，则可计算它们的乘积：  
$(4,1,3,5)\cdot(5,6,3)=\begin{pmatrix}1&2&3&4&5&&6\\3&2&5&1&4&&6\end{pmatrix}\cdot\begin{pmatrix}1&2&3&4&5&&6\\1&2&5&4&6&&3\end{pmatrix}$  
$=\begin{pmatrix}1&2&3&4&5&&6\\3&2&4&1&6&&5\end{pmatrix}$  
$\begin{aligned}(5,6,3)\cdot(4,1,3,5)&=\begin{pmatrix}1&2&3&4&5&6\\1&2&5&4&6&3\end{pmatrix}\cdot\begin{pmatrix}1&2&3&4&5&6\\3&2&5&1&4&6\end{pmatrix}.\\&=\begin{pmatrix}1&2&3&4&5&6\\5&2&6&1&4&3\end{pmatrix}\end{aligned}$  
可以看出$(4,\!1,\!3,\!5)\cdot(5,\!6,\!3)\neq(5,\!6,\!3)\cdot(4,\!1,\!3,\!5)$。因此，轮换的乘法不满足交换律。 显然，并不是每个置换都能成为轮换。例如，对于如下8 阶置换：  
$$
\tau=\begin{pmatrix}1&2&3&4&5&6&7\\3&5&6&4&2&1&7\end{pmatrix}
$$  
其不可能是轮换。但我们发现：  
$$
\tau=\begin{pmatrix}1&2&3&4&5&6&7\\3&5&6&4&2&1&7\end{pmatrix}
$$  
$$
=\bigl(\begin{matrix}1&2&3&4&5&6&7\\3&2&6&4&5&1&7\end{matrix}\bigr)\bigl(\begin{matrix}1&2&3&4&5&6&7\\1&5&3&4&2&6&7\end{matrix}\bigr)
$$  
$\quad\quad\quad\quad\quad=(\begin{matrix}1&3&6\\\end{matrix})(\begin{matrix}2&5\\\end{matrix})$  
由此可见，$\tau$虽不是轮换，但它可分解成是轮换的乘积。这为解决置换分解问题提供了一个思路。下面考虑对任意置换的轮换分解问题。首先给从下列定义：  
【定义7.15】设$\pi=(i_{1},i_{2},\cdots,i_{t})$和$\tau=(j_{1},j_{2},\cdots,j_{s})$都是轮换，如果$\pi$和$\cdot_{\tau}$不含相同的元素，则称$\pi$与$\tau$是不相交的。  
例如，集合$A=\{1,\!2,\!3,\!4,\!5,\!6\}$上的两个轮换(1,2,5)和(3,4,6)之间是不相交的，而轮换(1,2,5)和(2,4,6)之间则是相交的。  
下面给出对任意置换的轮换分解定理：  
【定理7.10】（轮换分解定理）任一$ n$元置换都可写成若干个不相交轮换的乘积。"
轮流摸牌问题,问题,"['第九章  树的基本理论与算法', '§ 9.4 树模型的应用', '9.4.2 轮流摸牌问题']","{'实体类型': '问题', '描述': '两个选手轮流从多堆扑克牌中取牌，最后取牌者胜', '解决方法': '采用博弈树分析'}",,3,"生活中，下棋、打牌、竞技等一类竞争性的活动称为博弈。对垒的双方轮流采取行动，博弈的结果仅有三种：胜、败、平局。在对垒过程中，任何一方都了解当前的格局及过去的历史。任何一方在采取行动前都要根据当前的实际情况，进行得失分析，选取对自己有利而对对方最为不利的对策，不存在掷骰子之类的破运气因素，双方必须很明智的决定自己的行为。轮流摸牌问题，作为一种经典的博奕类游戏，问题的具体描述如下：  
桌上有𝑀堆扑克牌，每堆牌的数量分别为$N_{i}(i=1,2,\dots,M)$。现有两个选手，分别记为先手和后手，轮流进行摸牌，每一次摸牌可以任意选择一堆并取走其中的任意张牌，规定每次至少取一张，多者不限；桌上的扑克牌全部取光，则游戏结束，那么最后一次摸牌的选手即为胜者。现在问题如下：先手如果想赢，第一步有几种选择?  
轮流摸牌问题可以采用博弈树解决。博弈树是一种特殊的树模型，它的每个结点表示游戏进行时的一种局面，用每条边表示这些局面之间合乎规则的演变或移动。博弈树通常比较庞大，通常需要对其进行化简才能高效地使用。  
图9-58 所示为初始的三堆扑克牌数量。第一堆和第二堆的扑克牌数量都为3 张，第三 堆扑克牌的数量为1 张，组成了初始状态(3，3，1)。  
![图9-57  大小排序决策树 ](images/f1b07d5e01fd3916fd51d458c21160476d888d5cdc01f2f4b52f54e88d66df57.jpg)  
![图9-58 三堆扑克牌  ](images/785c75f0b4653bbc64b450a41c28647f0642a850ef357c53771601a74297ee17.jpg)  
图9-58 所示的博弈树表示轮流摸扑克牌游戏在给定初始状态（3，3，1）扩展下的所 有对弈策略。用不同堆中扑克牌数组成的无序序列表示每个局面（堆的顺序无关紧要）。先手第一次可以从有3 张扑克牌的堆中摸1 张牌（剩下包含3 张、2 张、1 张扑克牌的3堆）；也可以从有3 张扑克牌的堆中取3 张（剩下包含3 张、1 张扑克牌的2 堆）；也可以从有1 张扑克牌的堆中取1 张（剩下包含3 张扑克牌的2 堆）。当扑克牌被最后一个选手取完了，下一个选手就无法再继续摸牌，这样的局面就是终局。轮流摸扑克牌游戏是非胜即负的游戏，规定用$F$ 标记表示先手获胜，用$L$ 标记表示后手获胜。  
![图9-59 轮流取扑克牌游戏的博弈树 ](images/3e2c6b2d2a79242f7f10f5a0e2d1714f56d6c5d793d99a4f5932038bcf4cd8fa.jpg)  
根据图9-59，我们可以发现，先手如果想必赢，第一步只有一种选择，即只能从有1 张扑克牌的堆中取1 张，而不能从其它堆中摸扑克牌。  
进一步对图9-59 进行分析，可知：  
1）状态（3，3，1）必胜点，那么先手取完棋子后，后手必落在必败点；  
2）若初始状态下，只有一堆扑克牌，先手必胜； 3）若有$𝑀$堆扑克牌，每堆只有一张扑克牌，$M$为奇数时，先手必胜；  
4）若有𝑀堆扑克牌，每堆只有$k$张扑克牌，$M$为奇数时，先手必胜；  
5）先手摸𝑘张扑克牌，轮到对手时，若对手取$𝑘$张，则先手也取$𝑘$张；若对手取$x<k$张，则先手也取另外一堆的$𝑥$张。因为剩下的是偶数堆，则先手也取$𝑘$张扑克牌，总能将剩下的堆变成若干个两两相等的堆。只要始终保持这种取法，先手总能取到最后的扑克牌。  
可以将上述局面推广至一般：若某个初始局面为先手必胜，那么每走一步都必须使后首落在必败点。因此对于每一个局面，要么为胜局面，要么为负局面。用非0 表示表示胜局面，0 表示负局面。对于某一个局面，若为非0 局面，它的任务就是要寻找某一种取法，使局面变为 0  局面。那么其对手无论怎么取，都会使局面又变为 0  局面。  
那么这种对弈有什么规律呢？  
如果一个局面为先手必胜，就称这为$N$局面；反之称之为$ P$局面。对于一个局面，令$S=$$P_{1}\oplus P_{2}\oplus\ldots\oplus P_{n}$。若$S=0$则为$ P$局面，否则就为$ N$局面（⊕为异或）。  
对于图9-4-5，我们将3 堆扑克牌数异或，即$3{\oplus}3{\oplus}1{=}011{\oplus}011{\oplus}001{=}1$，异或结果为非0，那么先手将赢得这局游戏。因此先手第一步需要从第三堆中摸一张扑克牌。  
下面我们考虑下4 堆扑克牌对弈策略。其中各堆的大小分别为4，5，9，15。用二进制表示各数分别为0100，0101，1001，1111。表4-1 为各堆数量对应的二进制数。  
将这四堆扑克牌数进行异或，得到0100⊕0101⊕1001⊕1111=0111。结果非0，那么先手会赢。因此先手可以从大小为4 的堆中取走1 张牌剩下3 张，后者从大小为5 的堆中取走 3  张牌剩下 2  张，再或者从大小为 15  的堆中取走 7  张牌剩下 8  张。  
轮流摸扑克牌游戏为典型的尼姆博弈问题。尼姆博弈的关键在于游戏开始时游戏处于何种状态（平衡或非平衡）和先手是否能够按照取子游戏的获胜策略来进行游戏。  
![表9-1  各堆数量对应的二进制数 ](images/621116a8789d5d8ecab422f6290df5764c10b51f7ad37caba7ad4b05a6de41e9.jpg)  
实际生活中还有许多有益的博弈，比如一字棋、国际象棋和方棋格等等。此外，这种博弈的方法已经应用到很多的计算机程序研究中。某些博弈程序都能做到与人类选手进行对决，比如国际象棋等，可以看到如何将树应用到博弈策略的研究中具有重要的现实意义.有关博弈策略的更多内容，读者可以查阅相关资料进一步学习，这里不再赘述。"
边,概念,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.2 图的定义与分类']","{'实体类型': '概念', '定义': '连接结点的线，表示对象之间的联系'}",,3,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)"
边不交的图,性质,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.2.1 图的基本运算', '一、图的集合运算']","{'实体类型': '性质', '定义': '如果两个图模型的边集合交集为空，则称它们是边不交的，或者说是不重的'}",,4,"图模型作为一种特殊的集合具有并、交、差、补、环和等集合运算，下面分别介绍这些集合运算及其相关性质。 首先给出两个图不交、不重的定义：  
【定义8.10】假设 $G_{1}=\langle V_{1},E_{1}\rangle$和 $G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，则有：  
（1）如果 $V_{1}\cap V_{2}=\varnothing$，则称 $G_{1}$ 与 $G_{2}$ 是不交的；  
（2）如果 $E_{1}\cap E_{2}=\varnothing$ ，则称 $G_{1}$ 与 $G_{2}$ 是边不交的，或者说是不重的。  
显然，对于任意两个不交的图它们必然是不重的，反之不然。  
下面给出图模型基本集合运算的定义：  
【定义 8.11 】假设   $G_{1}=\langle V_{1},E_{1}\rangle$ 和   $G_{2}=\langle V_{2},E_{2}\rangle$ 分别为不含孤立结点的图模型（它们 同为无向图或者同为有向图）。  
（1）令图 $G_{1}\cup G_{2}=\left\langle V,E\right\rangle$，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的并图，其中：$V=V_{1}\cup V_{2},\;\;E=E_{1}\cup E_{2}$  
当 $G_{1}$ 与 $G_{2}$ 不存在公共的边时，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$  的不重并。  
（2）设图 $G_{1}\cap G_{2}=\langle V,E\rangle$，称 $G_{1}\cap G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的交图，其中：$V=V_{1}\cap V_{2},\,\,\,E=E_{1}\cap E_{2}$  
$G_{1}\cap G_{2}$是由 $G_{1},G_{2}$ 中所有公共的边组成的图。  
（3）设图 $G_{1}-G_{2}=\langle V,E\rangle$，称 $G_{1}-G_{2}$ 为 $G_{1}$ 减 $G_{2}$ 的差图，其中：
$$
V=V_{1},\,\,\,E=E_{1}-E_{2}
$$  
$G_{1}-G_{2}$ 是在图 $G_{1}$ 中减去属于 $G_{2}$ 的边后所剩余的部分组成的图。  
（4）环和图 $G_{1}\oplus G_{2}$ 是由 $G_{1}$ 与 $G_{2}$ 的并图减去 $G_{1}$ 与 $G_{2}$ 的交图后得到的图。
$$
G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})
$$  
从上述定义可以看出，图模型的并、交、差、环和等集合运算其实就是普通集合运算的延伸。 需要注意的是：  
（1）若   $G_{1}=G_{2}$   ，则 $G_{1}\cup G_{2}=G_{1}\cap G_{2}=G_{1}(G_{2}),~~~~~G_{1}-G_{2}=G_{2}-G_{1}=\varnothing\,。$  
（2）$G_{1}$ 与 $G_{2}$ 不重时，$G_{1}\cap G_{2}=\varnothing$，$G_{1}-G_{2}=G_{1}$，  $G_2-G_1=G_2, G_1\oplus G_2=G_1\cup $$G_{2}$。  
（3）两个图的环和可用并、差、交给出，$G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})\,.$"
边割集,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.3  无向图的连通性']","{'实体类型': '概念', '定义': '删除后增加连通分支数的边集', '特点': '集合中所有边必须同时删除以增加连通分支'}",,3,"前面我们学习了图的可达性概念及其判定，其描述的是图中两个结点之间是否可以通过一条或者多条通路进行联结，并从图的局部角度分别考察两个结点之间的连通关系。现在我  
们从全局性角度考察整个图中多个结点之间的连通关系，将两个结点之间的可达性概念推广到整个图中任意两个结点之间的可达性，由此得到图的连通性和连通图的相关概念。  
在图的连通性方面，无向图和有向图之间具有很大的差异。因此，我们分别讨论无向图和有向图的连通性。本小节主要介绍和讨论无向图连通性的概念与性质。首先给出无向图连通图的相关概念，具体定义如下：  
【定义8.25】设 $G=\langle V,E\rangle$ 为任一给定的无向图，对于图中的两个结点$v_{i}$ 与 $v_{j}$，如果从$\boldsymbol{v}_{i}$到$v_{j}$是可达的，则称从 $v_{i}$ 到 $v_{j}$是连通的，表示为[ $v_{i}\ \ ,v_{j}]$。规定图中任何结点与其自身是连通的。如果无向图$G$中任何两个结点之间都是连通的，则称该图为无向连通图或连通无向图，简称为连通图；否则，称$G$ 是非连通无向图，简称为非连通图。  
显然，无向图中两个结点之间的连通性是双向的，也就是说两结点之间的连通关系满足对称性，即：若有$v_{i}$ 到 $v_{j}$可达则必有$v_{j}$ 到 $v_{i}$可达。故在无向图中，也可将从${v}_{i}$ 到 $v_{j}$的连通说成$v_{i}$ 与 $v_{j}$连通。另外，注意到平凡图有且只有一个结点，根据无向图中结点连通性的规定，它是一种特殊的连通图。  
下面的定理表明，无向图模型中结点之间的连通性关系是一个等价关系：  
【定理8.7】设 $G=\langle V,E\rangle$ 为任一给定的无向图，其结点集为 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，令$R$ 是集合$\cdot V=\{v_{1},v_{2},\ldots,v_{n}\}$上结点之间的连通关系，即有：  
$R=\{\langle u,v\rangle|u,v\in V\}$, 且从$u$到𝑣连通}       （8-10）  
则$R$是集合𝑉上的一个等价关系。  
既然无向图模型中结点之间的连通性关系$R$是一个等价关系，那么就可以使用等价关系$R$ 将无向图 $G$ 的结点集合 𝑉 划分为若干互不相同的等价类，记为   $V_{1},V_{2},\ldots,V_{k}$ 。在这些等价类 中，相互连通的结点属于同一个等价类，不连通的结点属于不同的等价类。由此得到无向图模型的连通分支的概念，具体定义如下：  
【定义8.26】设 $G=\langle V,E\rangle$ 为任一给定的无向图$R$是图$G$结点集合𝑉上的连通性关系，则以关系𝑅的每个等价类为结点集的导出子图都称为图$G$的一个连通分支，并用$p(\mathbf G)$表示图𝐺的连通分支总数。  
由上述定义可知，如果无向图$G=\langle V,E\rangle$的结点连通性关系$R$作为一个等价关系，将结点集𝑉划分为$k$个不同的等价类$V_{1},V_{2},\ldots,V_{k}$，则由它们导出的子图$G(V_{1}),G(V_{2}),\cdots,G(V_{k})$均为图$G$的连通分支。因此，可以根据无向图中结点之间的连通关系实现对图模型的一个分解。显然，若   $p(G)=1$ ，则 $G$ 是连通图。若   $p(G)>1$ ，则   $G$ 是非连通图。  
【定义8.27】对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在结点集𝑉的某个子集 $V^{\prime}\subseteq$$V$ ，使得 $p(G-V^{\prime})>p(G)$ ，且对于 $V^{\prime}$的任何真子集 $V^{\prime\prime}$，有 $p(G-V^{\prime\prime})=p(G)$，则称 $V^{\prime}$为 $G$ 的点割集。如果点割集中只有一个结点 $v$ ，则称 $v$ 为割点。  
由上述定义可知，可通过删除图中适当结点以破坏图结构的方式考察图的连通程度。图中有些结点组成的集合在图的连通性中起着非常关键的作用，删除这些结点后会使得连通图变成非连通图，使得非连通图变得更加不连通，或者增加连通分支的数目。  
显然，对图中的任意一个点割集，该集合中所有结点都是由该点割集增加连通分支时必须同时删除的结点。例如在图8-40 所示的图$G_{1}$中，集合$\{v_{4}\},\{v_{1},v_{3}\}$都是点割集，但$\{v_{1},v_{3},v_{4}\}$则不是点割集，因为要增加图$G_{1}$的连通分支，不必同时删除结点$v_{1},v_{3},v_{4}$。  
需要注意的是，由于删除割点后，割点的邻接边也需要删除，因此我们用虚线表示已删除的边或者结点。同样，对下文所要介绍的边割集也做类似处理。  
同样，可以通过删除图中适当的边以破坏图结构的方式考察图模型的连通程度，由此可以得到边割集的相关概念，具体定义如下：  
【定义8.28】 对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在边集$E$的某个子集 $E^{\prime}\subseteq$$E$ ，使得 $p(G-\ E^{\prime})>p(G)$ ，且对于 $E^{\prime}$的任何真子集 $E^{\prime\prime}$，有 $p(G-\ E^{\prime\prime})=p(G)$，则称$V^{\prime}$为 $G$ 的边割集。如果点割集中只有一个条边  $e$ ，则称 $e$为割边或桥。  
![图8-42 例题8.24 图模型  ](images/6c126be3977ab4a2c63afc18255dc22be84fa010ee39891af7c0eba551970203.jpg)  
关于点割集与边割集，需要注意以下几个要点：  
（1）完全图 $K_{n}$ 无点割集，因为从 $K_{n}$ 中删除 $k\leq n-1$个顶点后，所得图仍然是连通的。  
（2）$n$ 阶零图既无点割集也无边割集。  
（3）对于连通图 $G$，$E^{\prime}$为 $G$ 的边割集，则必有 $p(G-E^{\prime})=2$ 。 因为删除一条边最多只能增加一个连通分支。  
（4）对于连通图 $G\ \ ,V^{\prime}$为 $G$ 的点割集，则 $p(G-V^{\prime})\geq2$，而且可能 $p(G-E^{\prime})>2$因为删除一个结点可能增加多个连通分支。  
从上述例题可以看出，对于任意给定的一个无向连通图，经常会有多个点割集或边割集，而且每个集合中所含元素的个数也不一样。此时，需要重点关注的应该是那些个数最小的集合。因为这些集合刻画了图连通结构中最为薄弱的环节，反映了连通图的最低连通程度。由此得到无向图连通图的点连通度与边连通度的概念，具体定义如下：  
【定义8.29】对于任意给定的一个无向连通图 $G=\langle V,E\rangle$，令：$\kappa(G){=}m i n\{|V^{\prime}||V^{\prime}$为G 的点割集}；$\lambda(\mathbf{G})=\operatorname*{min}\{|E^{\prime}||E^{\prime}$为G 的边割集} 并称 $\kappa(G)$ 为图 $G$ 的点连通度，$\lambda(G)$ 为图 $G$ 的边连通度。  
显然，点连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少结点数，边连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少边数。  
例如，对于图8-44 所示的无向连通图$G$ ，有$\kappa(G)=2$，$\lambda(G)=3$；对于图8-45 所示的彼得森图，有$\kappa(G)=\lambda(G)=3$。  
![图8-44 图的连通度  ](images/28f9ee3f26ab71faac7e5360d73417062a5a59d8421071b9feb627483727c42a.jpg)  
![图8-45  彼得森图  ](images/80ddd389b19bdc8904c989e51a73f2c183cb8c6f73b8b9c479ee3affcb66c7c0.jpg)  
关于无向连通图的点连通度$\kappa(G)$和边连通度$\lambda(\mathrm{G})$，需要注意以下几个要点：  
（1）如果 $G$是平凡图或非连通图，则规定 $\kappa(G)=\lambda(G)=0;$  
（2）如果$G$ 是完全图 $K_{n}$ ，由于 $G$ 中无点割集，当删除 $n-1$个顶点后，$G$ 为平凡图，故 $\kappa(G)=n-1$。  
（3）如果 $G$ 中存在割点，则 $\kappa(G)=1$；如果 $G$ 中存在割边，则 $\lambda(G)=1$。对于任何无向图 $G$ ，其点连通度 $\kappa$ 、边连通度 $\lambda$ 与结点最小度 δ 之间有如下关系：  
【定理8.8】对于任一无向图$G=\langle V,E\rangle$ ，均成立下列不等式：
$$
\kappa(G)\leq\lambda(G)\leq\delta\ (G)
$$"
边界,概念,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.3.1  平面图的概念与性质']","{'实体类型': '概念', '定义': '包围面的所有边构成的回路'}",,3,"所谓平面图，直观地说就是可以将该图嵌入到某个平面上。如图10-46（a）所示，图模型的边有时不仅在结点处相交，而且还在某些非结点处有交叉，这些非结点处交叉点的边重叠特征显然会导致图模型不能嵌入在同一个平面上。因此，为了将图模型嵌入平面，首先必须适当调整该图中边的走向，以保证任意两条边不会在非结点处有交叉，如图10-46（b）所示。由此得到可平面图和平面图的相关概念。  
【定义10.6】设$G=\langle V,E\rangle$是任意给定的一个图模型，如果该图中有两条边在非结点处有交叉，则称这两条边为该图的交叉边，交叉的具体位置称为交叉点。如果可将图𝐺画在同一个平面上，并且所有边除在结点处之外均不交叉，则称图𝐺可嵌入平面，或称𝐺为可平面图，否则称该图为不可平面图或非平面图。对于可平面图𝐺，将其边不交叉的画法称为𝐺的平面嵌入表示。以平面嵌入方式表示的图可平面图𝐺称为平面图。对于一个平面图𝐺，若对其再加一条边就变成不可平面图，则称𝐺为最大平面图。  
![](images/ad5984e0ab09600028eb4068193d74e75743de0f027a20b4d084511a312873d4.jpg)  
![（a）完全二分图$K_{3,3}$  （b）无法消除交叉  ](images/aa69f9dcec49f0e95a534b493200688a98dae4f4be8a347fbd35c04b8c21413b.jpg)  
例如，对于图10-46（a）所示的图，该图有三对交叉边，即$(v_{1},v_{4})$和$(v_{2},v_{3}),~(v_{1},v_{4})$和$(v_{2},v_{5})$、$(v_{1},v_{5})$和$(v_{2},v_{3})$。由于可将该图表示成图10-46（b）的形式，故该图是一个可平面图。图10-46（b）所示的图就是一个平面图。显然，如果在该平面图上增加一条边，则该图就变成一个不可平面图，故该是一个最大平面图。再如，对于图10-47（a）所示的图模型，无论怎么调整边的走向都不能将其以平面嵌入方式表示，如图10-47（b）所示。故图10-47（a）所示的图模型为不可平面图或非平面图。  
在没有特别要求的情况下，通常将可平面图与平面图不加区分地统称为平面图。与一般图模型显著不同的是，平面图模型除了具有结点和边这两个基本构件之外，还有一般图模型所没有的面的概念，并且由进一步面衍生出边界的概念。因此，平面图是一类非常重要的特殊图模型，无论在理论上还是在应用方面都具有非常重要的价值，在印刷电路板的设计、城市管网设计与规划等多个领域得到实际应用。  
图论之父欧拉对平面图有着比较深刻的研究，发现并论证了平面图的结点、边和面之间的数量关系，提出了著名的欧拉公式。下面给出平面图中面的相关概念：  
【定义10.7】设$G=\langle V,E\rangle$是任意给定的一个平面图，由𝐺中边所包围且内部不包含结点与边的区域，称为$G$的一个面。区域面积有限的面称为有限面，区域面积无限的面称为无限面。对于$G$的任意一个面$R$，包围面$R$的所有边构成的回路称为面𝑅的边界，面𝑅边界中边的个数称为面$R$的次数或度，记为${\bf d e g}(R)$。  
通俗地说，如果把一个平面图画在平面上，然后用小刀沿着图的边将平面切开，那么整个平面就被切成若干块，其中每一块就是图的一个面。或者说，平面图的一个面就是平面中一个以边为界线不能再分割的区域块。例如，对于图10-46（b）所示的平面图，一共有六个面，其中有一个面是无限面，其余五个是有限面。需要注意的是，对于任何一个平面图，该图有且仅有一个无限面。下面的定理10.11 给出了平面图中面数与边数的数量关系：  
【定理10.11】平面图中所有面的次数之和等于边数的两倍。  
下面定理10.12 是著名的欧拉公式，给出了平面图中结点、边和面之间的数量关系：  
【定理10.12】设$G=\langle V,E\rangle$是任意给定的一个连通平面图，若它有$n$个结点、$m$条边、$r$ 个面，则有  
$$
n-m+r=2\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
【定理10.13】如果平面连通图$G$每个面的次数均为$l(l\geq3)$，则有：  
$$
m=l(n-2)/(l-2)
$$  
其中$m$为$G$的边数，$n$为$G$的结点数。  
【定理10.14】设$G$是一个$(n,m)$简单连通平面图，若$m>1$，则有：  
$$
m\leq3n-6\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
由定理10.4 的逆命题不成立，也就是说满足不等式$m\leq3n-6$的简单连通图不一定是平面图。但是对于一个简单连通图，若不满足$m\leq3n-6$，则一定是非平面图。因此，可用定理10.4 的结论证明某个简单连通图不是非平面图。  
【定理10.15】设$G$为一平面连通简单图，其结点数$n\geq4$，边数为$m$，且$G$不以$K_{3}$为其子图，则有$m\leq2n-4$。  
【定义10.8】对于是任意给定的一个图模型$G=\langle V,E\rangle$  
设$e=(u,v)$是$G$的任意一条边，如果在图$G$中删除该边并新增一个结点$w$及两条边$e_{1}=$$(u,w)$、$e_{2}=(w,v)$ ，则称该操作为对图$G$的边切割操作；  
设𝑤是$G$中任意一个度数为2 的结点，且是边${e_{1}=(u,w)}$和$e_{2}=(w,v)$的公共结点，如果在图$G$中删除结点$w$及边$e_{1},\,e_{2}$，并增加边$e=(u,v)$，则称该操作为对图$G$的结点贯通操作；  
对图$G$的边切割操作和结点贯通操作统称为对图$G$的同胚操作。  
显然，边切割操作和结点贯通操作是一对互逆操作。例如，对于图10-48 所示的两个图模型，可通过对边的切割操作将$G_{1}$变成$G_{2}$，也可通过对结点做贯通操作将$G_{2}$变成$G_{1}$。  
![图10-48  图的同胚操作与同胚关系  ](images/17b45e1706460a818a5492fb4df19f0ddd6b072e9cf57afef7db0852f0c58237.jpg)  
下面在同胚操作的基础上，引入如下两个图之间的同胚关系：  
【定义10.9】设$G_{1}=\langle V_{1},E_{1}\rangle$和$G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，如果可用同胚操作将其中一个转化为另外一个，则称$G_{1}$与$G_{2}$具有同胚关系，简称为$G_{1}$与$G_{2}$同胚。  
根据上述同胚的概念，可以得到如下关于平面图判定的库拉托夫斯基定理：  
【定理10.16】（库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是$G$的任何子图都不同胚于$K_{5}$或$K_{3,3}$。  
【定理10.17】(库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是𝐺的任何子图都不能通过边的收缩得到$K_{5}$或$K_{3,3}$。  
![图10-51 彼得森图收缩为$ K_{5}$](images/b6cd48c8bf37519af48b0cc187afdf1adc13d2c5e160a08fe418ce5c94762fd6.jpg)  
库拉托夫斯基定理是一个非常著名定理，通常将$K_{5}$和$K_{3,3}$称为库拉托夫斯基图。可以使用该定理判定一个图是否为平面图。例如，对于图$10{-}51\mathrm{a}$）所示的彼得森图，收缩其边$(v_{i},u_{i})(i=1,2,3,4,5)$，则可得到图$K_{5}$，见图10-51b)。故彼得森图不是平面图。  
值得注意的是，虽然库拉托夫斯基定理给出了平面图判定的充分必要条件，但是目前还没有基于该定理得到一个有效的判定算法。因此，对于一个比较复杂的图模型，要判定其是否为平面图，有时并不是一件容易的事情。"
边的删除运算,算法,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.2.1 图的基本运算', '二、图结构修改运算']","{'实体类型': '算法', '定义': '从图中删除一条或多条边的操作', '条件': '删除任意一条边或若干边组成的集合'}",,4,"对于一个给定的图模型，有时会根据实际问题的需要对图的结构进行化简或修改，主要是添加或者删除图中的某个或某些边、将图中两个结点进行合并、删除图中的某个或某些结点等，由此得到如下四个常用的图结构修改运算或操作，即：边的添加运算（也称为加新边运算）、边的删除运算、边的收缩运算以及结点的删除运算。其具体定义如下：  
【定义8.12】设图 $G=\langle V,E\rangle$是一个任意给定的图模型（有向图或无向图），则$G=\langle V,E\rangle$的四个常用图结构修改运算定义如下：  
（1）加新边运算：设$u,v$是 图$G=\langle V,E\rangle$的任意两个结点，即 $u,v\in V$，将这两个结点构成的边$e$边添加到图 $G$ 的边集$E$中构成一个新图$G^{\prime}=\langle V,E\cup\{e\}\rangle$。  
（2）边的删除运算：设$e$是图$G=\langle V,E\rangle$的任意一条边，即 $e\in E$ ，从 $G$ 中删除边 $e$ 得到一个新图$G^{\prime}=\langle V,E-\{e\}\rangle$，记为 $G-e$ ；又$E^{\prime}$是图$G$中若干边组成的集合，即$E^{\prime}\subseteq E$从 $G$ 中删除 $\mathrm{E^{\prime}}$中所有边得到一个新图$G^{\prime}=\langle V,E-E^{\prime}\rangle$，记为 $G-E^{\prime}$ 。  
（3）边的收缩运算：设$.e$是图$G=\langle V,E\rangle$的任意一条边且该边关联的两个结点为$u,v$，从图中删除边$e$并将该边的两个端点$u,v$合并成一个新的结点$w$，使得结点$w$关联除$e$以外的$u$和$v$所关联的一切边，得到一个新图$G^{\prime}$，记为$G\backslash{\mathbf{e}}$  
（4）结点的删除运算：设$_v$是 图$G=\langle V,E\rangle$的任意一个结点，即 $v\in V$，从 $G$ 中删除 $v$及与𝑣相关联的所有边，得到一个新图$G^{\prime}$，记为 $G-v$，又设 $V^{\prime}\subseteq V$ ，从 $G$ 中删除 $V^{\prime}$中所有顶点及与这些顶点关联的所有边，得到一个新图$G^{\prime}$，记为 $G-V^{\prime}$。  
从上述定义可以看出，要删除边，则直接在图中将改变去掉即可；要删除结点，在去掉该结点的同时，还要去掉该结点关联的所有边；边的收缩实际上就是将改变的长度变为0，使其两个端点重叠，用一个新的结点𝑤代替，其它边不变，即$w$关联该边的两个端点关联的除该边外的一切边，不过，需要注意的是，边的收缩可能会产生自环或平行边；所谓加新边运算，就是在图中的两个结点之间直接拉一条边。"
边的收缩运算,算法,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.2.1 图的基本运算', '二、图结构修改运算']","{'实体类型': '算法', '定义': '删除边并将该边的两个端点合并成一个新的结点的操作', '条件': '边关联的两个结点合并', '特点': '可能产生自环或平行边'}",,4,"对于一个给定的图模型，有时会根据实际问题的需要对图的结构进行化简或修改，主要是添加或者删除图中的某个或某些边、将图中两个结点进行合并、删除图中的某个或某些结点等，由此得到如下四个常用的图结构修改运算或操作，即：边的添加运算（也称为加新边运算）、边的删除运算、边的收缩运算以及结点的删除运算。其具体定义如下：  
【定义8.12】设图 $G=\langle V,E\rangle$是一个任意给定的图模型（有向图或无向图），则$G=\langle V,E\rangle$的四个常用图结构修改运算定义如下：  
（1）加新边运算：设$u,v$是 图$G=\langle V,E\rangle$的任意两个结点，即 $u,v\in V$，将这两个结点构成的边$e$边添加到图 $G$ 的边集$E$中构成一个新图$G^{\prime}=\langle V,E\cup\{e\}\rangle$。  
（2）边的删除运算：设$e$是图$G=\langle V,E\rangle$的任意一条边，即 $e\in E$ ，从 $G$ 中删除边 $e$ 得到一个新图$G^{\prime}=\langle V,E-\{e\}\rangle$，记为 $G-e$ ；又$E^{\prime}$是图$G$中若干边组成的集合，即$E^{\prime}\subseteq E$从 $G$ 中删除 $\mathrm{E^{\prime}}$中所有边得到一个新图$G^{\prime}=\langle V,E-E^{\prime}\rangle$，记为 $G-E^{\prime}$ 。  
（3）边的收缩运算：设$.e$是图$G=\langle V,E\rangle$的任意一条边且该边关联的两个结点为$u,v$，从图中删除边$e$并将该边的两个端点$u,v$合并成一个新的结点$w$，使得结点$w$关联除$e$以外的$u$和$v$所关联的一切边，得到一个新图$G^{\prime}$，记为$G\backslash{\mathbf{e}}$  
（4）结点的删除运算：设$_v$是 图$G=\langle V,E\rangle$的任意一个结点，即 $v\in V$，从 $G$ 中删除 $v$及与𝑣相关联的所有边，得到一个新图$G^{\prime}$，记为 $G-v$，又设 $V^{\prime}\subseteq V$ ，从 $G$ 中删除 $V^{\prime}$中所有顶点及与这些顶点关联的所有边，得到一个新图$G^{\prime}$，记为 $G-V^{\prime}$。  
从上述定义可以看出，要删除边，则直接在图中将改变去掉即可；要删除结点，在去掉该结点的同时，还要去掉该结点关联的所有边；边的收缩实际上就是将改变的长度变为0，使其两个端点重叠，用一个新的结点𝑤代替，其它边不变，即$w$关联该边的两个端点关联的除该边外的一切边，不过，需要注意的是，边的收缩可能会产生自环或平行边；所谓加新边运算，就是在图中的两个结点之间直接拉一条边。"
边的遍历算法,算法,['第十章  特殊图模型与算法'],"{'实体类型': '算法', '应用': '欧拉图模型中的基本算法'}",,1,"如前所述，图模型及其理论是数学家欧拉为解决哥尼斯堡七桥遍历问题而创立。事实上，图模型作为一种由结点和边组成的离散结构是一种非常强大的离散建模工具，除了能够解决哥尼斯堡七桥遍历问题之外，还可解决很多其它实际问题。例如，旅游的路径规划问题、资源分配与匹配问题、图的着色与并行流程的设计问题、最小费用流问题等等。针对不同的问题，通常需要设计出特定的图模型进行建模与求解。例如，解决哥尼斯堡七桥遍历问题需要使用欧拉图及相关理论、解决旅游的路径规划问题需要哈密顿图及相关理论、解决资源分配与匹配问题需要二分图及相关理论、解决图的着色与并行流程的设计问题需要平面图的相关理论、解决最小费用流问题需要网络流图的相关理论等等。由此产生很多种具有特殊结构和性质的图模型，每种特殊图模型都能针对性地有效地解决某一类或某几类特定问题。因此，要想高效合理地使用图模型实现对实际问题的建模与求解，除了掌握前述图模型的一般理论及算法之外，还需要进一步掌握多种特殊图模型的相关理论及算法。  
本章介绍几种重要的特殊图模型及相关算法，包括欧拉图模型的基本理论及边的遍历算法、哈密顿图的基本理论及结点的近似遍历算法、二分图模型的基本理论及匈牙利匹配构造算法、平面图的基本理论及着色算法、网络流图的基本理论及最大流算法，并结合具体实例分析和讨论这些特殊图模型的应用方法。"
边着色,概念,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.3.3 着色问题与算法', '一、点着色与边着色']","{'实体类型': '概念', '定义': '对图G的每条边都涂上或标注一种颜色，并满足相邻的两条边具有不同的颜色', '特点': '若G是k-边可着色的，但不是(k-1)-边可着色的，则称G是一个k-边色图，并称k为图G的边色数'}",,4,"首先考察一个实例，我们通常在同一台冰箱内存放不同种类的食物，其中有些食品必须分别保存在不同冰箱隔间以免串味或污染。例如，苹果和鸡蛋应该分开存放、腊肉和蔬菜应该分开存放等等。现有$A,B,C,D,E,F$六种食品，若要求$𝐴$与$𝐵$、$𝐴$与$C$、$𝐴$与$𝐷$、$B$与$C$、$C$与$D$、$C$与$F$、$D$与$E$、$E$与$F$不能放在一起，则至少需要几个隔间才能存放这些食物。  
![图10-56 冰箱中食物存放问题  ](images/557fa53c5bf02920ef35e88225888a1b53ecb35568cc495b689ec5f32f0de05e.jpg)  
可用一个无向图模型表示上述问题，图的每个结点分别代表一种食物，如果两种食物不能放在一起，则在这两种食物之间画一条无向边，如图10-55（a）所示。可通过对该图的结进行着色的方法实现对上述问题的求解。具体地说，就是对图中每个结点分别涂上或者标注一种颜色，并满足相邻的结点之间具有不同的颜色，将相同颜色结点所代表的食物放在同一个隔间，则所需要的最少颜色数目显然就是所求的冰箱隔间数目。  
不难知道，最少需要三种颜色才能实现对图10-55（a）所示无向图全部结点的着色，图10-55（b）表示其中一种着色方案。  
事实上，如果将上述六种食物分别看成是某个工程中的六项不同的任务，将不能存放在同一个隔间的两种食物理解为不能同时执行的两个任务，则可按照图10-55（b）所示的结点着色方案将这些任务以同色为标准分成3 个并行执行的任务集合。因此，无向图的着色理论与方法在并行计算与任务规划等领域具有非常重要的作用。  
对于一个比较复杂的无向图，要实现对该图所有结点的着色，在很多情况下不是一件很显然的事情。下面具体考察点着色问题，首先给出结点着色的定义，具体如下：  
【定义10.11】设$G=\langle V,E\rangle$是任意给定的一个无向图，如果对图𝐺的每个结点都涂上或标注一种颜色，并满足相邻的两个点具有不同的颜色，则称这种操作是对图$G$的结点着色，简称为对图𝐺的点着色。如果这些颜色选自于一个有𝑘种颜色的集合而不管$k$种颜色是否都用到，则称这样的点作色为称为𝒌着色，并称𝐺是${k}$-可着色的。若𝐺是$k{-}$可着色的，但不是$(k-$$1)-$可着色的，则称𝐺是一个${k}$-色图，并称$k$为图𝐺的点色数或色数，记为$𝜒(𝐺)$。  
![](images/53a26dc56eb7520c616c57e24f7d17f1e7686d610feaf89b55e20658f6ec1e28.jpg)  
例如，对于图10-55（a）所示无向图，该图就是一个3-色图，其射数$\chi(G)=3$。再如，图56（a）所示完全图$K_{5}$是一个5-色图；图56（b）所示完全二分图$K_{3,4}$是一个2-色图；图56（c）所示回路$C_{6}$是一个2-色图；图56（d）所示回路$C_{5}$为一个3-色图。  
通过上述例题不难看出，对于$G$的任何子图$H$，均有$\chi(H)\leq\chi(G)$，若$G$是$n$阶完全图，则$\chi(G)=n$；若$G$是至少有一边的二分图，则$\chi(G)=2$；若$G$是长为奇数的圈，则$\chi(G)=3$。一般地，关于无向图$G$的点色数，有如下定理：  
【定理10.19】设$G=\langle V,E\rangle$是任意给定的一个无向图，则有：  
（1）$\chi(G)=1$当且仅当$G$为零图。  
（2）对于完全图$K_{n}$：$\chi(K_{n})=n$。  
（3）$G$是一条回路：则若$|V|$是偶数，$\chi(G)=2$；若$|V|$是奇数，$\chi(G)=3$（4）$G$是一棵非平凡树，则$\chi(G)=2$。  
（5）$\chi(G)=2$的充要条件是：（a）$|E|\ge1$；（b）$G$为二分图。  
（6）对于任意无向线图$G$，若其结点的最大度为$\Delta(G)$  
$$
\chi(G)\leq\Delta(G)+1
$$  
【定理10.20】（布鲁克斯定理）设$G$是一个连通简单图，其结点的最大度为$\Delta(G)$。如果$G$既不是完全图，也不是长度奇数的基本回路，则$\chi(G)\leq\Delta(G)$。  
我们知道，任意一个不是零图的无向图都是由结点和边这两个要素构成，既然可对结点进行着色，自然也可对边进行着色。由此得到如下边着色的相关定义：  
【定义10.12】设$G=\langle V,E\rangle$是任意给定的一个无向图，如果对图$G$的每条边都涂上或标注一种颜色，并满足相邻的两条边具有不同的颜色，则称这种操作是对图$G$的边着色。如果这些颜色选自于一个有$k$种颜色的集合而不管$k$种颜色是否都用到，则称这样的边作色为称为𝒌边着色，并称$G$是$\pmb{k}$-边可着色的。若$G$是$k^{-}$边可着色的，但不是$\,(k-1)$-边可着色的，则称$G$是一个$\pmb{k}$-边色图，并称$k$为图$G$的边色数，记为$\chi^{\prime}(G)$。  
关于边色数的问题, 可以说目前已得到较好的解决。乌克兰数学家维津在1964 年提出的维津定理给出一个比较满意答案，具体如下：  
【定理10.21】（维津定理）设$G=\langle V,E\rangle$是任意给定的一个无向图，则有：  
（1）若图$G$是简单图，图中结点最大度为$\Delta(G)$，则$\chi^{\prime}(G)=\Delta(G)$或$\Delta(G)+1$；  
（2）若图$G$是二分图，图中结点最大度为$\Delta(G)$，则$\chi^{\prime}(G)=\Delta(G)$；  
（3）对于完全图$K_{n}$，若$n(n\neq1)$为奇数，$\chi^{\prime}(K_{n})=n$；若$_{n}$为偶数，$\chi^{\prime}(K_{n})=n-1$"
边连通度,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.3  无向图的连通性']","{'实体类型': '概念', '定义': '产生非连通图或平凡图需要删除的最少边数'}",,3,"前面我们学习了图的可达性概念及其判定，其描述的是图中两个结点之间是否可以通过一条或者多条通路进行联结，并从图的局部角度分别考察两个结点之间的连通关系。现在我  
们从全局性角度考察整个图中多个结点之间的连通关系，将两个结点之间的可达性概念推广到整个图中任意两个结点之间的可达性，由此得到图的连通性和连通图的相关概念。  
在图的连通性方面，无向图和有向图之间具有很大的差异。因此，我们分别讨论无向图和有向图的连通性。本小节主要介绍和讨论无向图连通性的概念与性质。首先给出无向图连通图的相关概念，具体定义如下：  
【定义8.25】设 $G=\langle V,E\rangle$ 为任一给定的无向图，对于图中的两个结点$v_{i}$ 与 $v_{j}$，如果从$\boldsymbol{v}_{i}$到$v_{j}$是可达的，则称从 $v_{i}$ 到 $v_{j}$是连通的，表示为[ $v_{i}\ \ ,v_{j}]$。规定图中任何结点与其自身是连通的。如果无向图$G$中任何两个结点之间都是连通的，则称该图为无向连通图或连通无向图，简称为连通图；否则，称$G$ 是非连通无向图，简称为非连通图。  
显然，无向图中两个结点之间的连通性是双向的，也就是说两结点之间的连通关系满足对称性，即：若有$v_{i}$ 到 $v_{j}$可达则必有$v_{j}$ 到 $v_{i}$可达。故在无向图中，也可将从${v}_{i}$ 到 $v_{j}$的连通说成$v_{i}$ 与 $v_{j}$连通。另外，注意到平凡图有且只有一个结点，根据无向图中结点连通性的规定，它是一种特殊的连通图。  
下面的定理表明，无向图模型中结点之间的连通性关系是一个等价关系：  
【定理8.7】设 $G=\langle V,E\rangle$ 为任一给定的无向图，其结点集为 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，令$R$ 是集合$\cdot V=\{v_{1},v_{2},\ldots,v_{n}\}$上结点之间的连通关系，即有：  
$R=\{\langle u,v\rangle|u,v\in V\}$, 且从$u$到𝑣连通}       （8-10）  
则$R$是集合𝑉上的一个等价关系。  
既然无向图模型中结点之间的连通性关系$R$是一个等价关系，那么就可以使用等价关系$R$ 将无向图 $G$ 的结点集合 𝑉 划分为若干互不相同的等价类，记为   $V_{1},V_{2},\ldots,V_{k}$ 。在这些等价类 中，相互连通的结点属于同一个等价类，不连通的结点属于不同的等价类。由此得到无向图模型的连通分支的概念，具体定义如下：  
【定义8.26】设 $G=\langle V,E\rangle$ 为任一给定的无向图$R$是图$G$结点集合𝑉上的连通性关系，则以关系𝑅的每个等价类为结点集的导出子图都称为图$G$的一个连通分支，并用$p(\mathbf G)$表示图𝐺的连通分支总数。  
由上述定义可知，如果无向图$G=\langle V,E\rangle$的结点连通性关系$R$作为一个等价关系，将结点集𝑉划分为$k$个不同的等价类$V_{1},V_{2},\ldots,V_{k}$，则由它们导出的子图$G(V_{1}),G(V_{2}),\cdots,G(V_{k})$均为图$G$的连通分支。因此，可以根据无向图中结点之间的连通关系实现对图模型的一个分解。显然，若   $p(G)=1$ ，则 $G$ 是连通图。若   $p(G)>1$ ，则   $G$ 是非连通图。  
【定义8.27】对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在结点集𝑉的某个子集 $V^{\prime}\subseteq$$V$ ，使得 $p(G-V^{\prime})>p(G)$ ，且对于 $V^{\prime}$的任何真子集 $V^{\prime\prime}$，有 $p(G-V^{\prime\prime})=p(G)$，则称 $V^{\prime}$为 $G$ 的点割集。如果点割集中只有一个结点 $v$ ，则称 $v$ 为割点。  
由上述定义可知，可通过删除图中适当结点以破坏图结构的方式考察图的连通程度。图中有些结点组成的集合在图的连通性中起着非常关键的作用，删除这些结点后会使得连通图变成非连通图，使得非连通图变得更加不连通，或者增加连通分支的数目。  
显然，对图中的任意一个点割集，该集合中所有结点都是由该点割集增加连通分支时必须同时删除的结点。例如在图8-40 所示的图$G_{1}$中，集合$\{v_{4}\},\{v_{1},v_{3}\}$都是点割集，但$\{v_{1},v_{3},v_{4}\}$则不是点割集，因为要增加图$G_{1}$的连通分支，不必同时删除结点$v_{1},v_{3},v_{4}$。  
需要注意的是，由于删除割点后，割点的邻接边也需要删除，因此我们用虚线表示已删除的边或者结点。同样，对下文所要介绍的边割集也做类似处理。  
同样，可以通过删除图中适当的边以破坏图结构的方式考察图模型的连通程度，由此可以得到边割集的相关概念，具体定义如下：  
【定义8.28】 对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在边集$E$的某个子集 $E^{\prime}\subseteq$$E$ ，使得 $p(G-\ E^{\prime})>p(G)$ ，且对于 $E^{\prime}$的任何真子集 $E^{\prime\prime}$，有 $p(G-\ E^{\prime\prime})=p(G)$，则称$V^{\prime}$为 $G$ 的边割集。如果点割集中只有一个条边  $e$ ，则称 $e$为割边或桥。  
![图8-42 例题8.24 图模型  ](images/6c126be3977ab4a2c63afc18255dc22be84fa010ee39891af7c0eba551970203.jpg)  
关于点割集与边割集，需要注意以下几个要点：  
（1）完全图 $K_{n}$ 无点割集，因为从 $K_{n}$ 中删除 $k\leq n-1$个顶点后，所得图仍然是连通的。  
（2）$n$ 阶零图既无点割集也无边割集。  
（3）对于连通图 $G$，$E^{\prime}$为 $G$ 的边割集，则必有 $p(G-E^{\prime})=2$ 。 因为删除一条边最多只能增加一个连通分支。  
（4）对于连通图 $G\ \ ,V^{\prime}$为 $G$ 的点割集，则 $p(G-V^{\prime})\geq2$，而且可能 $p(G-E^{\prime})>2$因为删除一个结点可能增加多个连通分支。  
从上述例题可以看出，对于任意给定的一个无向连通图，经常会有多个点割集或边割集，而且每个集合中所含元素的个数也不一样。此时，需要重点关注的应该是那些个数最小的集合。因为这些集合刻画了图连通结构中最为薄弱的环节，反映了连通图的最低连通程度。由此得到无向图连通图的点连通度与边连通度的概念，具体定义如下：  
【定义8.29】对于任意给定的一个无向连通图 $G=\langle V,E\rangle$，令：$\kappa(G){=}m i n\{|V^{\prime}||V^{\prime}$为G 的点割集}；$\lambda(\mathbf{G})=\operatorname*{min}\{|E^{\prime}||E^{\prime}$为G 的边割集} 并称 $\kappa(G)$ 为图 $G$ 的点连通度，$\lambda(G)$ 为图 $G$ 的边连通度。  
显然，点连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少结点数，边连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少边数。  
例如，对于图8-44 所示的无向连通图$G$ ，有$\kappa(G)=2$，$\lambda(G)=3$；对于图8-45 所示的彼得森图，有$\kappa(G)=\lambda(G)=3$。  
![图8-44 图的连通度  ](images/28f9ee3f26ab71faac7e5360d73417062a5a59d8421071b9feb627483727c42a.jpg)  
![图8-45  彼得森图  ](images/80ddd389b19bdc8904c989e51a73f2c183cb8c6f73b8b9c479ee3affcb66c7c0.jpg)  
关于无向连通图的点连通度$\kappa(G)$和边连通度$\lambda(\mathrm{G})$，需要注意以下几个要点：  
（1）如果 $G$是平凡图或非连通图，则规定 $\kappa(G)=\lambda(G)=0;$  
（2）如果$G$ 是完全图 $K_{n}$ ，由于 $G$ 中无点割集，当删除 $n-1$个顶点后，$G$ 为平凡图，故 $\kappa(G)=n-1$。  
（3）如果 $G$ 中存在割点，则 $\kappa(G)=1$；如果 $G$ 中存在割边，则 $\lambda(G)=1$。对于任何无向图 $G$ ，其点连通度 $\kappa$ 、边连通度 $\lambda$ 与结点最小度 δ 之间有如下关系：  
【定理8.8】对于任一无向图$G=\langle V,E\rangle$ ，均成立下列不等式：
$$
\kappa(G)\leq\lambda(G)\leq\delta\ (G)
$$"
运算,概念,"['第十一章  抽象代数结构通论', '§ 11.1 代数结构的基本概念', '11.1.2 运算的定义与表示']","{'实体类型': '概念', '定义': '通过某种机制由两个运算对象构造出一个确定的新的对象，或按照某种既定的规则根据两个输入得到一个唯一确定的输出', '特点': '可以看成是一种特殊的二元映射或二元函数', '应用': '在关系数据库的多元关系演算等领域具有重要的应用价值'}",,3,"所以代数结构，本质上就是由一个运算对象的集合和若干运算构成的系统。要学好代数结构，首先必须掌握运算的概念和性质。  
对于运算这个概念，其实我们并不陌生。例如实数的加、减、乘、除等二元运算。这些二元运算通过某种机制由两个运算对象构造出一个确定的新的对象，或者说按照某种既定的规则根据两个输入得到一个唯一确定的输出。因此，二元运算可以看成是一种特殊的二元映射或二元函数，具体定义如下：  
【定义11.1】假设$𝐴,B,C$任意给定的三个非空集合，则从$A\times B$到$C$上的二元映射$f$，称为一个从$A\times B$到$C$的二元运算，即有$f：A\times B\to C$。当$A=B=C$时，称$f：A\times A\to A$为$𝑨$上的二元运算。  
【定义11.2】设$A_{1},A_{2},\cdots,A_{n},A$均为一个非空集合，从集合$A_{1}\times A_{2}\times\cdots\times A_{n}$到集合$A$的映射$f$称为一个从集合$A_{1}\times A_{2}\times\cdots\times A_{n}$到集合𝐴的$\pmb{n}$元运算，即有：$f$：$A_{1}\times A_{2}\times\cdots\times$$A_{n}\to A$。若有$\  A_{1}=A_{2}=\cdots=A_{n}=A$，则称$f$：$A\times A\times\cdots\times A\to A$为集合𝑨上的一个$n$元运算。当$n=1$时，称$f$：$A\rightarrow A$为集合𝑨上的一元运算。  
从上述定义可以看出，多元运算其实就是一类特殊的多元函数。 例如，三元函数：  
$$
*\!:R^{3}\rightarrow R\,,\,\,\,*\left(x,y,z\right)=z\,,\,\,\,\forall x,y,z\in R
$$  
就是一个三元运算，该运算表示三维空间上的点$(x,y,z)$到$z$轴上的投影。  
目前，多元运算在关系数据库的多元关系演算等领域具有重要的应用价值。 不过，多元运算是对二元关系的自然推广，与二元关系没有本质上的差异。  因此，我们主要考察一元运算和二元运算的概念与性质。  例如，整数集合$Z$ 上求相反数运算、幂集合上的求补运算、实矩阵集合上的求矩阵转置运算、命题集合中的非运算等等，都是一元运算。  与二元运算的情形完全相同，可以使用运算符或运算表表示一元运算，这里不再赘述。"
连通分支,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.3  无向图的连通性']","{'实体类型': '概念', '定义': '以连通性关系等价类为结点集的导出子图', '特点': '相互连通的结点属于同一个等价类'}",,3,"前面我们学习了图的可达性概念及其判定，其描述的是图中两个结点之间是否可以通过一条或者多条通路进行联结，并从图的局部角度分别考察两个结点之间的连通关系。现在我  
们从全局性角度考察整个图中多个结点之间的连通关系，将两个结点之间的可达性概念推广到整个图中任意两个结点之间的可达性，由此得到图的连通性和连通图的相关概念。  
在图的连通性方面，无向图和有向图之间具有很大的差异。因此，我们分别讨论无向图和有向图的连通性。本小节主要介绍和讨论无向图连通性的概念与性质。首先给出无向图连通图的相关概念，具体定义如下：  
【定义8.25】设 $G=\langle V,E\rangle$ 为任一给定的无向图，对于图中的两个结点$v_{i}$ 与 $v_{j}$，如果从$\boldsymbol{v}_{i}$到$v_{j}$是可达的，则称从 $v_{i}$ 到 $v_{j}$是连通的，表示为[ $v_{i}\ \ ,v_{j}]$。规定图中任何结点与其自身是连通的。如果无向图$G$中任何两个结点之间都是连通的，则称该图为无向连通图或连通无向图，简称为连通图；否则，称$G$ 是非连通无向图，简称为非连通图。  
显然，无向图中两个结点之间的连通性是双向的，也就是说两结点之间的连通关系满足对称性，即：若有$v_{i}$ 到 $v_{j}$可达则必有$v_{j}$ 到 $v_{i}$可达。故在无向图中，也可将从${v}_{i}$ 到 $v_{j}$的连通说成$v_{i}$ 与 $v_{j}$连通。另外，注意到平凡图有且只有一个结点，根据无向图中结点连通性的规定，它是一种特殊的连通图。  
下面的定理表明，无向图模型中结点之间的连通性关系是一个等价关系：  
【定理8.7】设 $G=\langle V,E\rangle$ 为任一给定的无向图，其结点集为 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，令$R$ 是集合$\cdot V=\{v_{1},v_{2},\ldots,v_{n}\}$上结点之间的连通关系，即有：  
$R=\{\langle u,v\rangle|u,v\in V\}$, 且从$u$到𝑣连通}       （8-10）  
则$R$是集合𝑉上的一个等价关系。  
既然无向图模型中结点之间的连通性关系$R$是一个等价关系，那么就可以使用等价关系$R$ 将无向图 $G$ 的结点集合 𝑉 划分为若干互不相同的等价类，记为   $V_{1},V_{2},\ldots,V_{k}$ 。在这些等价类 中，相互连通的结点属于同一个等价类，不连通的结点属于不同的等价类。由此得到无向图模型的连通分支的概念，具体定义如下：  
【定义8.26】设 $G=\langle V,E\rangle$ 为任一给定的无向图$R$是图$G$结点集合𝑉上的连通性关系，则以关系𝑅的每个等价类为结点集的导出子图都称为图$G$的一个连通分支，并用$p(\mathbf G)$表示图𝐺的连通分支总数。  
由上述定义可知，如果无向图$G=\langle V,E\rangle$的结点连通性关系$R$作为一个等价关系，将结点集𝑉划分为$k$个不同的等价类$V_{1},V_{2},\ldots,V_{k}$，则由它们导出的子图$G(V_{1}),G(V_{2}),\cdots,G(V_{k})$均为图$G$的连通分支。因此，可以根据无向图中结点之间的连通关系实现对图模型的一个分解。显然，若   $p(G)=1$ ，则 $G$ 是连通图。若   $p(G)>1$ ，则   $G$ 是非连通图。  
【定义8.27】对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在结点集𝑉的某个子集 $V^{\prime}\subseteq$$V$ ，使得 $p(G-V^{\prime})>p(G)$ ，且对于 $V^{\prime}$的任何真子集 $V^{\prime\prime}$，有 $p(G-V^{\prime\prime})=p(G)$，则称 $V^{\prime}$为 $G$ 的点割集。如果点割集中只有一个结点 $v$ ，则称 $v$ 为割点。  
由上述定义可知，可通过删除图中适当结点以破坏图结构的方式考察图的连通程度。图中有些结点组成的集合在图的连通性中起着非常关键的作用，删除这些结点后会使得连通图变成非连通图，使得非连通图变得更加不连通，或者增加连通分支的数目。  
显然，对图中的任意一个点割集，该集合中所有结点都是由该点割集增加连通分支时必须同时删除的结点。例如在图8-40 所示的图$G_{1}$中，集合$\{v_{4}\},\{v_{1},v_{3}\}$都是点割集，但$\{v_{1},v_{3},v_{4}\}$则不是点割集，因为要增加图$G_{1}$的连通分支，不必同时删除结点$v_{1},v_{3},v_{4}$。  
需要注意的是，由于删除割点后，割点的邻接边也需要删除，因此我们用虚线表示已删除的边或者结点。同样，对下文所要介绍的边割集也做类似处理。  
同样，可以通过删除图中适当的边以破坏图结构的方式考察图模型的连通程度，由此可以得到边割集的相关概念，具体定义如下：  
【定义8.28】 对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在边集$E$的某个子集 $E^{\prime}\subseteq$$E$ ，使得 $p(G-\ E^{\prime})>p(G)$ ，且对于 $E^{\prime}$的任何真子集 $E^{\prime\prime}$，有 $p(G-\ E^{\prime\prime})=p(G)$，则称$V^{\prime}$为 $G$ 的边割集。如果点割集中只有一个条边  $e$ ，则称 $e$为割边或桥。  
![图8-42 例题8.24 图模型  ](images/6c126be3977ab4a2c63afc18255dc22be84fa010ee39891af7c0eba551970203.jpg)  
关于点割集与边割集，需要注意以下几个要点：  
（1）完全图 $K_{n}$ 无点割集，因为从 $K_{n}$ 中删除 $k\leq n-1$个顶点后，所得图仍然是连通的。  
（2）$n$ 阶零图既无点割集也无边割集。  
（3）对于连通图 $G$，$E^{\prime}$为 $G$ 的边割集，则必有 $p(G-E^{\prime})=2$ 。 因为删除一条边最多只能增加一个连通分支。  
（4）对于连通图 $G\ \ ,V^{\prime}$为 $G$ 的点割集，则 $p(G-V^{\prime})\geq2$，而且可能 $p(G-E^{\prime})>2$因为删除一个结点可能增加多个连通分支。  
从上述例题可以看出，对于任意给定的一个无向连通图，经常会有多个点割集或边割集，而且每个集合中所含元素的个数也不一样。此时，需要重点关注的应该是那些个数最小的集合。因为这些集合刻画了图连通结构中最为薄弱的环节，反映了连通图的最低连通程度。由此得到无向图连通图的点连通度与边连通度的概念，具体定义如下：  
【定义8.29】对于任意给定的一个无向连通图 $G=\langle V,E\rangle$，令：$\kappa(G){=}m i n\{|V^{\prime}||V^{\prime}$为G 的点割集}；$\lambda(\mathbf{G})=\operatorname*{min}\{|E^{\prime}||E^{\prime}$为G 的边割集} 并称 $\kappa(G)$ 为图 $G$ 的点连通度，$\lambda(G)$ 为图 $G$ 的边连通度。  
显然，点连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少结点数，边连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少边数。  
例如，对于图8-44 所示的无向连通图$G$ ，有$\kappa(G)=2$，$\lambda(G)=3$；对于图8-45 所示的彼得森图，有$\kappa(G)=\lambda(G)=3$。  
![图8-44 图的连通度  ](images/28f9ee3f26ab71faac7e5360d73417062a5a59d8421071b9feb627483727c42a.jpg)  
![图8-45  彼得森图  ](images/80ddd389b19bdc8904c989e51a73f2c183cb8c6f73b8b9c479ee3affcb66c7c0.jpg)  
关于无向连通图的点连通度$\kappa(G)$和边连通度$\lambda(\mathrm{G})$，需要注意以下几个要点：  
（1）如果 $G$是平凡图或非连通图，则规定 $\kappa(G)=\lambda(G)=0;$  
（2）如果$G$ 是完全图 $K_{n}$ ，由于 $G$ 中无点割集，当删除 $n-1$个顶点后，$G$ 为平凡图，故 $\kappa(G)=n-1$。  
（3）如果 $G$ 中存在割点，则 $\kappa(G)=1$；如果 $G$ 中存在割边，则 $\lambda(G)=1$。对于任何无向图 $G$ ，其点连通度 $\kappa$ 、边连通度 $\lambda$ 与结点最小度 δ 之间有如下关系：  
【定理8.8】对于任一无向图$G=\langle V,E\rangle$ ，均成立下列不等式：
$$
\kappa(G)\leq\lambda(G)\leq\delta\ (G)
$$"
连通性定理,定理,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.4 有向图的连通性']","{'实体类型': '定理', '内容': '有向图是强连通图的充要条件是存在一条经过所有结点的回路；有向图是单连通图的充要条件是存在一条经过所有结点的通路'}",,3,"现在讨论有向图的连通性。与无向图不同的是，有向图中的每条边都具有方向性，结点之间的可达性关系不一定满足对称性。因此，有向图的连通性质比无向图更加复杂，一般要分为强连通、单向连通和弱连通这三种基本情况讨论，其具体定义如下：  
【定义8.30】假设$G=\langle V,E\rangle$任意给定的一个有向图，则有：如果图 $G$中任意两个结点之间都是相互可达的，则称 $G$ 是强连通图；如果图 $G$ 中任意两个结点中至少有一个结点到另一个结点可达，则称 $G$ 是单向连通图，简称为单连通图；对于略去图 $G$ 中各边的方向得到的无向图 $G^{\prime}$，如果 $G^{\prime}$ 是无向连通图，则称 $G$ 是弱连通图，简称为连通图。  
从上述定义可以看出，在没有特别说明的情况下，连通的有向图一般意指为弱连通的有向图。显然，如果一个有向图 $G$ 是强连通的，那么它一定是单连通的，反之不然；如果一个有向图 $G$ 是单向连通图的，那么它一定是弱连通的，反之不然。  
例如，图8-47 所示的三个图模型$G_{1}$, $G_{2}$和$G_{3}$分别是强连通图，单连通图和弱连通图。其中$G_{1}$既是强连通图也是单连通图，$G_{2}$是单连通图也是弱连通图。  
![图8-47 强连通图、单向连通图、弱连通图  ](images/bb31206be85b6681e4bfdebf210d613d4577ab233c09b6ccf50f1f6eb3389294.jpg)  
【定理8.9】（连通性定理）有向图 $G$ 是强连通图的充要条件是存在一条经过图$G$所有结点的回路；有向图 $G$ 是单连通图的充要条件是存在一条经过图𝐺所有结点的通路。  
类似于无向图的连通分支的概念，可分别根据有向图的强连通、单向连通、弱连通概念定义相应的连通分支，得到强分图、单向分图、弱分图的概念，具体定义如下：  
【定义8.31】假设$G=\langle V,E\rangle$任意给定的一个有向图，设 $G^{\prime}$是 $G$ 的一个子图，如果$G^{\prime}$是强连通的（单向连通的、弱连通的），并且对 $\forall G^{\prime\prime}\subseteq G$，若$G^{\prime}\subset G^{\prime\prime}$，则 $G^{\prime\prime}$不是强连通的（单向连通的、弱连通的），则称 $G^{\prime}$ 为 $G$ 的强连通分支（单向连通分支、弱连通分支），简称为强分图（单分图、弱分图）。  
显然，强分图、单分图、弱分图都是 $G$ 的子图，可以用结点集合𝑉的子集导出。显然，强分图是单分图和弱分图，单分图一定是弱分图，但是为了强调它们之间的差异性，一般不再将强分图称为单分图或弱分图，也不再将单分图称为弱分图。  
从上述定义及例题不难看出，可分别通过强分图、单分图、弱分图的概念对有向图中所有结点进行分组。具体地说：  
（1）对于由强连通关系产生的强分图，由于有向图结点之间的强连通关系显然满足自反性、对称性和传递性，因此这种强连通关系是一种等价关系，从而可由此等价关系实现对图中所有结点的划分。显然，每个强分图其实就是一个等价类或者划分块，图中所有的强分图就是构成了所有的划分块。 因此，有向图的任何一个结点属于且仅属于一个强分图。  
（2）对于由弱连通关系产生的弱分图，可类似于无向图的方法进行讨论。事实上，不难看出，弱分图其实就是有向图所导出无向图中的连通分支。因此，所有的弱分图也构成了有向图中所有结点的一种划分，有向图的任何一个结点属于且仅属于一个若分图。  
（3）对于由单向连通关系产生的单分图，不难证明，有向图结点之间的单连通关系满足自反性、对称性，但不满足传递性，因而是一种相容关系。可由此相容关系实现对图中所有结点的最大覆盖。显然，每个强分图其实就是一个最大相容类，图中所有的单分图就是构成了所有的最大相容类。因此，有向图的任何一个结点至少属于一个强分图。  
类似地，可分别通过强分图、单分图、弱分图的概念对有向图中所有边进行分组。 不难发现：对于任何一个给定的有向图，它的每条边至多属于一个其强分图，至少属于一个其单分图，属于且仅属于一个其弱分图。  
例如，对于例题8.30 中的强分图、单分图和弱分图，不难看出它们均满足上述所有关于结点和边分组性质。"
迪杰斯特拉算法,算法,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.4.3 单源最短路径']","{'实体类型': '算法', '基本思想': '通过两个集合A和B，逐步找到最短路径并更新路径长度', '步骤': '初始化、找最近、更新、重复直到B集合为空'}",,3,"最短路径，顾名思义就是图中一个结点到另一个结点的之间最短的距离。在日常生活之中，涉及到最短路径计算问题的实际案例有很多，比如在地图上查找两地之间最短路径，为大家的出行提供方便；另外，在路由选择中，从一个路由器出发查找距离目的地最近的一条路径等。最短路径的求解主要有两种算法，一种是单源最短路径算法，即一个结点到其他所有剩余结点的最短路径，代表算法是迪杰斯特拉算法；另一种是求整个图中所有结点之间的最短距离，代表算法是沃舍尔∙弗洛伊德算法。  
因此，给定简单无向赋权图 $G=\langle V,E\rangle$ ，从顶点 $v_{1}$ 到 $v_{n}$ 的最短路径可应用迪杰斯特拉算法算法进行求解。迪杰斯特拉算法的基本思想如下：  
假定有两个集合 $A$ 和 $B$ ，$A$ 集合中存放已找到最短路径的结点$B$集合中存放的是剩余结点。初始状态下，集合 $A$ 中包含默认的源点 $v_{1}$ ，然后从集合 $B$ 中选取到结点$v_{1}$最近的那个结点，记为 $v_{2}$，将 $v_{2}$ 放入集合 $A$ 中，并对$ v_{2}$到$v_{1}$的距离进行永久性标注，然后再以 $v_{2}$ 为中介点，更新 $v_{1}$ 到其他剩余结点的最短路径临时值。然后再从集合B中选取最近的结点，并入集合 $A$ 中，并对该结点到$v_{1}$的最短路径临时值进行永久性标注，使得该临时值变成永久值，重复以上过程，直到将集合B中的所有结点全部并入集合 $A$ 中并得到永久性标注。  
迪杰斯特拉算法的数学描述如下：  
（1）初始化：$A=\{v_1\},d(v_1)=0,B=\{v_i|v_i\in V,i\neq1\}$,即 $B=V-A$,且有
$$d(v_i)=\begin{cases}\omega(v_1,v_i),~~~~~~~若(v_1,v_i)\in E\\\infty,~~~~~~~~~~~~~~~~~若(v_1,v_i)\notin E\end{cases}$$              (8-13)  
（2）找最近：在 $B$ 集合中寻找离顶点 $v_{1}$ 最近的结点。若为 $v_{k}$ ，则将 $v_{k}$ 添加到集合 $A$ 中，并在 $B$ 集合中删除 $v_{k}$ ，即 $A=A\cup\{v_{k}\}$，$B=B-\{v_{k}\}$  
（3）更新：以 $v_{k}$ 为中介点，更新 $v_{1}$ 到 $B$ 集合中剩余结点的最短路径长度。$\forall$$v_{i}\in$$B$，  
$d(v_{i})={\left\{\begin{array}{l l}{d(v_{k})+\omega(v_{k},v_{i}),~~~~~~~~~~~~~~若\dot{}d(v_{k})+\omega(v_{k},v_{i})<d(v_{i})}\\ {\qquad d(v_{i}),~~~~~~~~~~~~~~~~~~~~~~~否则}\end{array}\right.}$      （8 −14）  
（4）重复（2）和（3），直到 $B$ 集合为空为止。  
实际上，当 $v_{n}$ 归入集合 $A$ ，且正好 $A=V$，不仅求出了从 $v_{1}$ 到 $v_{n}$ 的最短路径，而且求出了从 $v_{1}$ 到所有顶点的最短路径。  
上述算法的正确性是显然的。因为每一步中，集合 $A$中的每一个元素（顶点）都是 $v_{1}$ 到该元素（顶点）的最短路径，因此只要证明上述 $d(v_{i})$ 是从 $v_{1}$ 到 $v_{i}$ 的最短路径即可。  
事实上，任何一条从 $v_{1}$ 到 $v_{i}$ 的路径，若通过集合 $B$ 中的第一个顶点是 $v_{p}$，且 $v_{p}\neq$$v_{i}$ ，显然这种路径的长度不会比 $d(v_{i})$小（因为所有边的权值为非负）。"
迭代求解法,算法,"['第一章  集合与计数基础', '§ 1.4 有限集的高级计数技术', '1.4.2 递推关系的求解']","{'实体类型': '算法', '特点': '用于求解简单的递推关系式', '步骤': '利用递推关系式进行迭代，推测通项的显示表达式；用数学归纳法证明得到的公式'}",,3,"递推关系是复杂问题和动态问题求解重要工具，要使递推关系在问题求解中发挥作用特别是在计数问题中发挥作用，有时需要实现对递推关系式的求解，也就是说要找到满足递推公式的所有数列或部分数列的显示通项表达式。对递推关系式的求解是一个非常复杂的数学问题，属于离散数学及相关学科的前沿研究课题，有兴趣的读者可以查阅相关资料做进一步深入研究。作为抛砖引玉，我们仅介绍其中两种最常用的基本解法，即针对简单递推关系的迭代求解方法和针对常系数齐次线性递推关系的特征根求解方法。  
迭代求解法是一种最基本的解法，该方法主要用于求解一些比较简单的递推关系式，由如下两个基本步骤构成：  
第一、利用递推关系式对其右边的表达式进行迭代，并推测通项的显示表达式；  
第二、用数学归纳法证明得到的公式。  
目前还没有一个一般性的方法或公式能够实现对任意递推关系式的求解，通常需要针对对递推关系式的具体特点给出相应的求解方法。常系数齐次线性递推关系是一种特殊的递推关系，针对这类递推关系有一套完备可行的求解理论和方法。这套求解理论和方法是求解其它递推关系式的基础，因为很多其它递推关系式都是通过设法将其转化为某种常系数齐次线性递推关系的途径实现求解。下面给出常系数齐次线性递推关系的定义：  
【定义1.27】设$a_{1}$，$a_{2}$，⋯，$a_{k}$是$k$个常数且$a_{k}\neq0$，则下列递推关系：  
$$
u_{n}=a_{1}u_{n-1}+a_{2}u_{n-2}+\cdots+a_{k}u_{n-k}(n\geq k)
$$  
称为$k$阶常系数线性齐次递推关系。  
如果数列 $\{b_{n}\}_{n\geq0}$ 满足 $.b_{n}=a_{1}b_{n-1}+a_{2}b_{n-2}+\cdots+a_{k}b_{n-k}(n\geq k)$ ，则称数列 $\{b_{n}\}_{n\geq O}$ 或 $u_{n}=b_{n}{\big(}n=0,~1,~2,~\cdots{\big)}$是递推关系式(1 −17)的一个解。  
问题：递推关系式(1 −17)有没有解？如果有解，有多少个解？如何求解？下面的定理表明常系数齐次线性递推关系在满足初始条件的情况下有唯一解：  
【定理1.19】任意给出$k$个常数$b_{0}\,,\;\;b_{1}\,,\;\;\cdots\,,\;\;b_{k-1}$，有且仅有唯一一个数列是递推关系式 (1 −17) 满足初始条件 $v_{0}=b_{0}$ ， $v_{1}=b_{1}$ ， ⋯ ， $v_{k-1}=b_{k-1}$ 的解。  
对于常系数齐次线性递推关系的求解，基本思路是采用一种所谓特征根的方法，通过引入特征方程和特征根的概念，巧妙地将递推关系的求解问题转化为求代数方程根的求解问题。为此，我们引入如下特征方程和特征根的定义：  
【定义1.27】如下方程：  
$$
x^{k}-a_{1}x^{k-1}-a_{2}x^{k-2}-\cdots-a_{k-1}x-a_{k}=0
$$  
称为递推关系式(1 −17)的特征方程，它的根称为递推关系式(1 −17)的特征根。  
因为$a_{k}\neq0$，所以0 不是递推关系式(1 −17)的特征根。 下面的定理非常关键，它给出了特征根与常系数齐次线性递推关系解之间的联系：  
【定理1.20】设$q$ 是非0 复数，则$u_{n}=q^{n}$是递推关系式(1 −17)的一个解当且仅当$q$是递推关系式(1 −17)的一个特征根。  
下面定理给出了常系数齐次线性递推关系解的结构特点：  
【定理1.21】设$\cdot u_{n}=g_{i}(n)(i=1,2,\cdots,s)$均为递推关系式(1 −17)的解，$c_{i}(i=1,\!2,\cdots,s)$为任意常数，则有：  
$$
=\sum_{i=1}^{s}c_{i}g_{i}(n)
$$  
也是递推关系式(1 −17)的解。  
【定理1.22】如果递推关系式(1 −17)的$k$ 个特征根$q_{1}\,,\;\;q_{2}\,,\;\;\cdots\,,\;\;q_{k}$彼此相异，则  
$$
u_{n}=c_{1}q_{1}^{n}+c_{2}q_{2}^{n}+\cdots+c_{k}q_{k}^{n}
$$  
是递推关系式(1 −17)的通解。其中$c_{1}\,,\;\;c_{2}\,,\;\;\cdots\,,\;\;c_{k}$为任意常数。"
逆元,概念,"['11.2.2 特殊元素', '§ 11.2 代数结构的运算性质', '12.2.1 群的基本概念', '第十二章 典型抽象代数结构', '§ 12.2 群结构的基本知识', '第十一章  抽象代数结构通论']","{'实体类型': '概念', '定义': ['存在元素y，使得y与任意x运算结果为单位元', '对于∀x∈G，都存在x^{-1}∈G，使得x^{-1}*x=x*x^{-1}=e'], '例子': '相反数（加法）、倒数（乘法）、反函数（复合运算）、逆矩阵（矩阵乘法）'}",,3,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)"
逆关系,概念,"['第五章 关系模型与理论', '§ 5.2 关系的基本运算', '5.2.3 幂关系与逆关系']","{'实体类型': '概念', '定义': '设A, B是任意两个集合，R是A到B的关系，则从B到A的关系R^{-1}={⟨b,a⟩|⟨a,b⟩∈R}称为R的逆关系，运算“-1”称为关系的逆运算', '要点': '关系是序偶的集合，逆关系也是序偶的集合；如果R是一个关系，则其逆关系R^{-1}和补关系R¯都是关系，但是两者是完全不同的两个关系；显然有(R^{-1})^{-1}=R, ∅^{-1}=∅'}",,3,"如前所述，关系的复合运算满足结合律。也就是说，如果有多个关系进行复合运算，只要不交换它们的运算次序，不管哪个先参与合成，最后结果都一样。由此可见，对于某个集合上的一个二元关系，如果它可以不断地与自己做复合运算，那么运算结果只与该关系以及复合运算次数有关，而与复合的次序无光。由此可得如下关系方幂运算的概念：  
【定义5.15】设$R$ 是集合$A$ 上的关系，则可归纳定义$R$ 的$n$次方幂${R^{n}}$运算如下：  
$（1）R^{0}=I_{A}=\left\{\langle a,\ a\rangle\big|a\in A\right\};\quad(\,2\,)\,\ R^{1}=R;\ (\,3\,)\,\ R^{n+1}=R^{n}\circ R=R\circ R^{n}\circ R.$    方幂运算的结果也显然也是$A$ 上的二元关系，即对于任何自然数$k$，有$R^{k}\subseteq A\times A$。通常称为$R$的方幂关系或幂关系，不难证明方幂运算满足如下运算法则：
$$
R^{m}\circ R^{n}=R^{m+n};\,\,\,(R^{m})^{n}=R^{m n}
$$  
由上述例题可以看出：  
（1）幂集$R^{n}$的基数$\vert{R}^{n}\vert$并非随着$n$ 的增加而增加，而是呈递减趋势；  
（2）当$n\geq|A|$时，则$R^{n}$出现循环取值或退化为空关系。 下面的定理给出了上述结论的一个解释：  
【定理5.7】设𝐴是一个具有${n}$个元素的有限集合，$R$ 是$𝐴$上的二元关系，则必存在自然数$s$ 和$t$，使得$R^{s}=R^{t}$，$0\leq s<t\leq2^{n^{2}}$。  
上述定理表明，对于任意一个有限集合，该集合上的二元关系总共只有有限多个，而对于该集合上的二元关系，其方幂运算则可以无限地进行下去且运算结果均为该集合上的二元关系。因此，在一定次数的方幂运算之后，后续的方幂运算结果自然是以某种循环的方式出现，或者以恒等于某个特定关系的方式出现。  
【定义5.16】设$A,\ B$ 是任意两个集合，$R$ 是$A$ 到$B$ 的关系，则从$B$ 到$A$ 的关系：
$$
R^{-1}=\{\langle b,a\rangle|\langle a,b\rangle\in R\}\quad\text{(5-9)}
$$
称为$R$ 的逆关系，运算“-1”称为关系的逆运算。  
关于逆关系概念的理解，需要注意如下几个要点：（1）关系是序偶的集合，逆关系也是序偶的集合；（2）如果$R$ 是一个关系，则其逆关系$R^{-1}$和补关系$\bar{R}$都是关系，但是两者是完全不同的两个关系，千万不要混淆；（3）显然有$(R^{-1})^{-1}=R$，$\varnothing^{-1}=\varnothing$。  
【定理5.8】设$A$，$B$ 和$C$是任意三个集合，$R$，$S$ 分别是从$A$ 到$B$ 和$B$ 到$C$的二元关系，则有：$(R\circ S)^{-1}=S^{-1}\circ R^{-1}$  
可以看出，复合关系的逆关系等于它们逆关系的反复合。要注意$(R\circ S)^{-1}\neq R^{-1}\circ S^{-1}$，因为$R^{-1}$是从$B$ 到$A$ 的关系，而$S^{-1}$是从$C$ 到$B$ 的关系，因此$S^{-1}$与$R^{-1}$之间是可复合的，而$R^{-1}$与$S^{-1}$之间是不可复合的。  
下面定理给出了关系逆运算与关系集合运算之间的分配运算律：  
【定理5.9】设$R,\ S$是从集合$A$ 到集合$B$ 的关系，则有如下分配律：
$$
(R\cup S)^{-1}=R^{-1}\cup S^{-1};\;\;(R\cup S)^{-1}=R^{-1}\cup S^{-1};\;\;(R-S)^{-1}=R^{-1}-S^{-1}
$$  
对于任意给定的集合𝐴和$B$，目前所讨论的二元关系有两种基本类型，一种是集合$𝐴$到集合$ B$上的二元关系，另外一种是集合𝐴上的二元关系。事实上，这两种关系没有本质上的区别，因为若令$C=A\cup B$，则集合$𝐴$到集合$B$上的二元关系就可以看成是$C\times C$的几个子集合，或者说是$C$上的二元关系。因此，在后续内容中所说的关系，若非特别说明，均为某个集合上的关系而不是从某个集合到另外一个集合上的关系。"
逆函数,概念,"['第七章 函数与特殊函数', '§ 7.2 函数的基本运算', '7.2.2 函数的逆运算']","{'实体类型': '概念', '特点': '如果函数f可逆，则f^{-1}作为一个从B到A的函数，集合B中每个元素都有f^{-1}下的像，而根据逆关系的定义，B中每个元素在函数f^{-1}下的像其实就是该元素在函数f下的原像，故f是从A到B的满射。另一方面，f^{-1}作为一个函数，集合B中每个元素都有A中唯一的元素与之对应。从函数f的角度看，就是A中不同的元素对应不同的像，因此，函数f是单射'}",,3,"在一般关系$𝑅$的求逆运算中，任意关系都可进行求逆运算而得到其逆关系，但是对于任意一个函数$𝑓$来说，只能保证它的逆$f^{-1}$是一个二元关系，并不能保证$f^{-1}$一定是函数关系。因此，在求一个函数的逆运算时，必须对该函数做一些特殊的要求。  
【定义7.7】设$f\colon A\to B$的函数关系，如果其逆关系：  
$$
f^{-1}=\{\langle y,x\rangle|x\in A\land y\in B\land\langle x,y\rangle\in f\}\quad\text{(7-2)}
$$  
是一个从$B$到$𝐴$的函数关系，则函数$f$可逆，并称$f^{-1}$是函数$f$的逆函数或反函数。  
由上述定义可可知，如果函数$f$可逆，则$f^{-1}$作为一个从$B$到$𝐴$的函数，集合$ B$中每个元素都有$ f^{-1}$下的像，而根据逆关系的定义，$B$中每个元素在函数$f^{-1}$下的像其实就是该元素在函数$f$下的原像，故$f$是从$𝐴$到$B$的满射。另一方面，$f^{-1}$作为一个函数，集合$ B$中每个元素都有$A$中唯一的元素与之对应。从函数$ f$的角度看，就是$𝐴$中不同的元素对应不同的像，因此，函数$f$是单射。综上所述，函数$f$存在逆函数$f^{-1}$当且仅当$f$是双射。  
【定理7.7】设$f\colon A\to B$的双射函数，则$f$的逆函数$f^{-1}$也是从$B$到$𝐴$的双射函数。  
下面定理给出了任一双射函数与其函数反函数及恒等函数之间的关系：  
【定理7.8】设$𝑓$:$A\rightarrow B$的双射函数，则有：  
$$
(1)f^{-1}\circ f=I_{B};\mathrm{~(~2~)~}\,f\circ f^{-1}=I_{A};\mathrm{~(~3~)~}\,I_{A}\circ f=f\circ I_{B}=f。
$$  
其中$I_{A}$和$I_{B}$分别表示集合$𝐴$和集合 $B$上的恒等函数。"
选排列,概念,"['第一章  集合与计数基础', '§ 1.3 有限集的基本计数技术', '1.3.3 排列计数与组合计数', '一、不重复的排列与组合']","{'实体类型': '概念', '定义': 'r<n时构成的排列为选排列'}",,4,"首先考察如下排列问题：  
某班有35 名同学，现从中选出15 名同学排成一排，问有多少种排列方式？  
这个问题有如下两个关键要点：第一、在排列中每位同学最多只能出现一次，也就是无重复性；第二、不同的次序构成不同的排列。由此得到如下不重复排列的概念：  
【定义1.21】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中依次取出$r$ 个不同元素并将其按取出的次序排成一排，由此形成的一个有序排列称之为不重复$r\cdot$-排列，简称为$r\cdot$-排列或排列，不重复$r\cdot$-排列的个数称为不重复$r\cdot$-排列数，简称为$r\cdot$-排列数或排列数，记为${P}_{n}^{r}$或$P(n,r)$。称$r=n$时构成的排列称为全排列，$r<n$时构成的排列为选排列。  
根据乘法原理，显然可以得到如下结论：  
【定理1.13】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r\cdot$-排列数计算公式：  
$P(n,r)=n(n-1)(n-2)\cdots(n-r+1)\ \ ={\frac{n!}{(n-r)!}}$ 其中：$n!=n(n-1)(n-2)\cdots2\cdot1$  
【定义1.22】假设$S$是由$n$ 个不同的元素组成的集合，从$S$ 中依次取出$r$ 个不同元素并将其按取出的次序排成一个圆圈，由此形成的一个有序圆排列称之为不重复$r\cdot$-圆排列，简称为$r\cdot$-圆排列或圆排列，不重复$r\cdot$圆排列的个数称为不重复$r\cdot$-圆排列数，简称为$r\cdot$-圆排列数或圆排列数，记为${\cal P}_{c}(n,r)$。  
相对于上述圆排列的概念，有时亦将$r\cdot$-排列称为$r$-线排列或线排列。由前面分析不难看出，如果将每个$r\cdot$-线排列的首尾相连构成一个$r\cdot$-圆排列，则由此构成的所有圆排列必然有$r$倍的重复数。故有如下$r\cdot$-圆排列计算公式：  
【定理1.14】对于任意给定的两个正整数$n$ 和$r$，且$r\leq n$，其$r\cdot$-圆排列数为$P_{c}(n,r)$：  
$$
P_{c}(n,r)=\frac{P(n,r)}{r}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r}=\frac{n!}{r(n-r)!}
$$  
以上例子的共有特点是所有选出的元素都有一定的次序。事实上，很多情况下并不需要选出的元素具有有次序。  
考察如下组合问题：  
某班有35 名同学，现从中任意选出15 名同学参加问卷活动，问有多少种选择方式？  
与前述$r$-排列问题不同的是，这个问题只考虑抽取的是哪15 名同学，并不考虑抽取次序以及与之相关的排列问题。由此得到如下不重复组合及相关组合数的概念：  
【定义1.23】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中任意取出$r$ 个不同元素组成一个子集合，称每一个这样的子集合为一个不重复$r$-组合，简称为$r\cdot$-组合或组合，不重复$r$-组合的个数称为不重复$r\cdot$-组合数，简称为$r\cdot$-组合数或组合数，记为$C_{n}^{r}$或$C(n,r)$。  
显然， $r$ - 组合与 $r$ - 排列的区别在于 $r\cdot$ 组合不考虑组合中元素的排列次序， $r\cdot$ - 排列必须考 虑排列中各元素的排列次序。如果两个$r\cdot$-排列所含的元素完全相同，仅仅是排列次序不同，两个$r\cdot$-排列是同一个组合，由此得到有如下组合数计算公式：  
【定理1.15】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r-$组合数计算公式：  
$$
C(n,r)=\frac{P(n,r)}{r!}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r!}=\frac{n!}{r!(n-r)!}
$$"
递归,算法,"['第二章  整数与算法设计基础', '§ 2.4 算法设计策略与应用', '一、递归策略', '2.4.2 递归与分治']","{'实体类型': '算法', '定义': '把一个问题归结为一个或多个规模更小的子问题，然后用同样的方法解规模更小的子问题，直到子问题的规模小到可以直接求解为止；若一个算法通过把问题转化到带更小输入的相同问题的实例，来求解原来的问题，则这个算法称为递归的', '特点': '子问题与原问题保持同一类型以保证可用同样方法求解', '算法思想': '把求解的问题转化成规模较小的子问题，然后，再把该子问题继续转化为更小的子问题，通过多次转化，使得问题的规模小到可以直接求解，并得到最小解，然后将最小解逐层向上返回调用，最终得到整个问题的解', '基本要求': ['递归中每次循环都必须使问题规模变小', '递归操作中每相邻两步都是紧密关联的，在递归返回到上一层的操作中，前一次的输出便是后一次的输入', '当子问题的规模足够小时，必须能够直接求出该子问题的解，也就是说必须具备结束递归的初始条件']}",,3,递归是算法设计中一项非常重要的策略，其基本思想是把一个问题归结为一个或多个规模更小的子问题，然后用同样的方法解规模更小的子问题，要求子问题与原问题保持同一类型以保证可用同样方法求解，如此下去，直到子问题的规模小到可以直接求解为止。分治策略的思想则是将一个难以解决的大问题，分割成一些与原问题相同的、规模较小的子问题，以便分而治之，然后递归地解决子问题，最后把子问题的解组合成原问题的解。递归和分治就像一对孪生兄弟，经常同时应用在算法设计之中，并由此形成很多高效的算法。
递归与分治策略,算法,"['第二章  整数与算法设计基础', '§ 2.4 算法设计策略与应用']","{'实体类型': '算法', '应用': '算法设计的基本策略之一'}",,2,计算机问题求解算法虽然千差万别，但都遵循一些基本的设计策略。这些策略蕴含着很多非常深刻而又普适的求解智慧。例如，分治策略把一个问题分解为若干规模较小的子问题，然后以递归的方式求解它们并通过合并它们的解来实现对原问题的求解，而回溯策略则认为对未知世界的探索是一个试错的过程，并给出具体的试错方案，这恰恰是对人类生活经验的一种抽象和总结。不断学习、领会和掌握这些智慧，就可逐步形成良好的算法思维，从而能够更加透彻地从本质上理解算法设计的精髓，为设计出高水平算法打下坚实的基础。本章主要结合具体应用实例介绍和分析算法设计的若干基本策略，包括蛮力与贪心策略、递归与分治策略、回溯与动态规划策略。
递归运算,概念,"['第七章 函数与特殊函数', '§ 7.2 函数的基本运算', '7.2.3 函数的递归运算']","{'实体类型': '概念', '定义': '对于某一函数f(x)，其定义域是集合A，那么若对于A集合中的某一个值x_n，其函数值f(x_n)由以f(x_{n-1}), f(x_{n-2}), ..., f(x_{n-k})变量的某个表达式确定，则称f(x)为一个k阶递归函数', '特点': '将复杂问题分解成若干简单且相同的子问题，通过简单子问题的机械重复得到复杂问题的解', '应用': '递归方法是算法与程序设计的一个有效方法，使用递归方法能使程序变得简洁和清晰', '条件': '函数存在递归结束条件及结束时的值，称之为递归出口；函数能够用递归形式表示，且递归向终止条件发展，称递归表达式为递归体'}",,3,"前面从二元关系的角度讨论了函数关系的复合运算和逆运算，我们还可以将关系的幂运算引入函数关系之中。如前所述，关系的幂运算是一种特殊的复合运算，就是关系通过不断地与其自身进行复合从而产生新的关系。由于关系的复合运算满足结合律，故给定次数下的复合运算结果是唯一确定的。同样，一个函数关系也可以通过不断与其自身进行复合运算产生新的函数关系，由此可得函数迭代与递归运算的概念。  
【定义7.8】假设$𝐴$是任一给定的非空集合，$f(x)$是$A$上的某个函数，$n$个相同函数$f(x)$的复合运算称为对$f(x)$的$n$次迭代运算，运算结果记为$f^{n}(x)$，称为$f(x)$的$n$次迭代函数，并约定$f(x)$的0 次迭代函数为其自变量$x$，即有：  
$$
f^{(n)}(x)=f(f^{(n-1)}(x))\wedge f^{(0)}(x)\quad\text{(7-3)}
$$  
其中$f^{(0)}(x)=x。$  
迭代是函数的一个非常重要的运算，在很多情况下可使用函数迭代得到新的函数。例如，假设$f(x)$是自然数集上的后继函数，即有$f(x)=x+1$，则有$f^{(n)}(x)=~x+n$。还可以使用迭代方法解方程或方程组，例如牛顿迭代法、雅可比迭代法、高斯迭代法等等，有兴趣的读者可以数值分析的课程的相关内容，这里不再赘述。下面将函数迭代的概念做进一步推广，给出并讨论函数递归运算的概念。  
首先看一个引例。西萨·班·达依尔发明了国际象棋，国王问他需要什么奖赏，他说：“陛下，请您在这张棋盘的第1 个小格里赏给我一粒麦子，在第2 个小格里给2 粒，第3 个小格给4 粒，以后每一小格都比前一小格加一倍，直到摆满这64 个棋盘格”  
那么需要多少粒麦子呢？可以按如下方法计算：  
$$
f(1)=1;f(2)=2;f(3)=4;\cdots\cdots;f(n)=2*f(n-1)
$$  
最后得到：$f(64)=2^{64-1}=18446744073709551615.$是一个非常大的数字。  
上面的算式$f(n)=2*f(n-1)$表达的就是一个递归运算。该算式采用以步长为1 的逐步推进的方式，通过以$f(n-1)$为变量的某个具体表达式计算$f(n)$。  
下面给出函数递归运算的具体定义：  
【定义7.9】对于某一函数$f(x)$，其定义域是集合$𝐴$，那么若对于$𝐴$集合中的某一个值$x_{n}$，其函数值$f(x_{n})$由以$f(x_{n-1}),f(x_{n-2}),\cdots,f(x_{n-k})$变量的某个表达式确定决定，即有：  
$$
f(x_{n})=S(f(x_{n-1}),f(x_{n-2}),\cdots,f(x_{n-k}))\quad\text{(7-4)}
$$  
则称$f(x)$为一个$k$阶递归函数。  
递归函数的思想就是将复杂问题分解成若干简单且相同的子问题，将复杂的原问题转换为简单子问题的某种重复，通过简单子问题的机械重复得到复杂问题的解。  
例如，下列两个函数均为递归函数。  
（1）阶乘函数：  
$$
Fact(n)=\left\{\begin{matrix}1&&n=0\\&n*Fact(n-1)&&n>0\end{matrix}\right.
$$  
（2）2 阶的Fibonacci 数列：  
$$
Fib(n)=\begin{cases}0&\quad&n=0\\1&\quad&n=1\\&\quad&Fib(n-1)+Fib(n-2)&\quad\text{否则}\end{cases}
$$  
递归函数的上述思想非常符合计算机程序设计的思维方式。因此，递归方法是算法与程序设计的一个有效方法,使用递归方法能使程序变得简洁和清晰。  
值得注意的是，并不是任何函数都适合采用递归的形式进行计算。使用递归方式计算函  
数必须具备如下两个基本条件：  
（1）函数存在递归结束条件及结束时的值，称之为递归出口；  
（2）函数能够用递归形式表示，且递归向终止条件发展，称递归表达式为递归体。"
递推公式,原理,"['第七章 函数与特殊函数', '§ 7.4 有限集的置换函数', '7.5.2 宽带分配问题']","{'实体类型': '原理', '应用': '用于计算最佳分配的优先级收益', '步骤': '逐步计算并存储中间结果，最终得到最优解'}",,3,"随着互联网上语音视频业务的飞速增长，宽带成了影响服务质量的主要因素。一般来说，用户使用的宽带分成两部分：静态宽带和动态宽带。静态宽带是运营商承诺的最小宽带，已经预留给每个用户；动态宽带被所有的用户共享，根据需求进行分配。语音视频业务服务过程一般分成三步：建立连接、进行语音视频传输、结束服务。对于已经建立连接并正在进行传输的服务，运营商应该保证其所需要的宽带。而在连接阶段，如果所有客户申请的宽带总量超过运营商所提供的宽带时，则进行宽带分配。用户的优先级通常他可使用的最大宽带与已占有的宽带之比，需求量越大，被满足的宽带越小，则优先级越高。  
假设已知每一项业务所申请的宽带大小，在保证分配的宽带之和不超过网络总宽带的条件下，如何选择业务，以使得业务优先级收益（即所有业务的优先级之和）达到最大？  
可以用集合与函数对这个问题进行建模。设用户集合是$\{1,2,\cdots,n\}$，用户$𝑖$提出了$t_{i}$个宽带申请，其第$𝑗$个申请的宽带是$r(i,j)$，这里$i=1,\!2,\cdots,n,\:\:\:\mathrm{j}=1,\!2,\cdots,t_{i}.$。假设此刻运营商能提供的动态宽带总量是$B$用户$i$已使用的宽带为$C_{i j}$，可使用的最大宽带为，那么$C_{i j}\leq M_{i j}$。用户$i$的优先级函数记作$P(i,j)$，其中：$P(i,j)=C_{i j}/M_{i j}$。  
用函数$X(i,j)$表示对用户$i$的第𝑗个申请的分配结果$X(i,j)=1$表示分配$X(i,j)=0$表示不分配，那么问题的优化目标是使得下述函数，即优先级利益：  
$$
\sum_{i=1}^{n}\sum_{j=1}^{t_{i}}X(i,j)\cdot P(i,j)\quad\text{(7-9)}
$$  
达到最大，同时满足不超过总宽带的约束条件，即：  
$$
\sum_{i=1}^{n}\sum_{j=1}^{t_{i}}X(i,j)\cdot r(i,j)\leq B\quad\text{(7-10)}
$$  
这是个典型的组合优化问题，$n$个用户总计有$t_{1}+t_{2}+\cdots+t_{n}=m$个宽带请求，分别标号为${1,2,\cdots,m}$。在考虑前$n$项宽带请求$k=(1,\!2,\cdots,m)$，总宽带限制为$l(l=1,\!2,\cdots,B)$的情况下，设最佳分配的优先级收益为$v(k,l)$。  
如果此时把宽带分配给第$k$项业务（可能是第$𝑖$个用户的第$𝑗$个申请），该业务所需宽带是$r(k)$（在$r(k)=r(i,j)\leq l$的情况下），优先级收益是$P(k)=P(i,j)$。那么，剩下的宽带是$l-$$r(k)$。这些宽带将在${1,2,\cdots,k-1}$项业务中分配，所得到的优先级收益将是$v(k-1,l-r(k))$，因此总的优先级收益是$v(k-1,l-r(k)+P(k))\mathrm{v}$。相反，如果不把宽带分配给第$k$项业务，那么全部宽带𝑙将在${1,2,\cdots,k-1}$项业务中分配，总收益为$v(k-1,l)$为了使得优先级的总收益最大，只要在上述两个收益中选择最大的即可。  
上述分析可以总结成下面的递推公式，即$\forall k(0\leq k\leq m),\forall l(0\leq l\leq B)$，有  
$v(k,l)$  
![](images/ca1bba9e9c93f3e9595cc988da9323614b05bd9b58074b31eaf8aa4a7e6c05f3.jpg)  
根据这个公式：  
第一步先计算$k=1,\mathsf{l}=1,2,\cdots,B$的$v(1,l)$值，并把它们存到一个表中；  
第二步计算$k=2,\mathsf{l}=1,2,\cdots,B$的$v(2,l)$值，再把得到的值存到这个表中。  
每步计算若用到的较小的$v(k,l)$值，就到表中去取。照此做下去，直到计算出$k=m,l=$${1,2,\cdots,B}$的$v(m,l)$值为止，其中的$v(m,B)$就是最佳分配的优化函数值，即最大优先级收益。  
上述计算完成后，再根据$v(m,B)$的值逐步向前追溯，就可以找到最佳分配方案。先看$v(m,B)$是等于$v(m-1,B)$，还是等于$v\bigl(m-1,B-r(m)\bigr)+P(m)\,?$若等于前者，则没有选择第$m$项业务；若等于后者，则选择了第$m$项业务。然后根据剩下的部分是$v(m-1,B)$还是$v\big(m-1,B-r(m)\big)$来追溯第$m-1$项业务是否被选到。照此下去，直到$m$项业务都考察到，就得到问题的解。如果在计算每一项$v(k,l)$的时刻就把是否选择第$k$项业务记录下来，则就可以省略追溯过程，只需查一下全部记录，就能得到了问题的解。"
递推关系,概念,"['1.4.2 递推关系的求解', '1.4.1 递推关系计数法', '§ 1.4 有限集的高级计数技术', '第一章  集合与计数基础']","{'实体类型': '概念', '定义': ['假设数列的通项可由其前若干项计算出来，则称该计算表达式为递推公式或递推关系式', '复杂问题和动态问题求解的重要工具'], '初值': '递推公式中一个或多个初始项的值', '特解': '如果一个数列的各项都满足递推关系，则称该数列为该递推关系的一个特解', '应用': ['求解组合计算问题的重要工具，在几乎所有的数学分支中都有着十分重要的作用', '计数问题中发挥作用'], '特点': '需要找到满足递推公式的所有数列或部分数列的显示通项表达式', '求解方法': ['迭代求解法', '特征根求解法']}",,3,"我们都学过数列知识，对于一个通项为$a_{n}$的数列$\left\{a_{n}\right\}$，其取值随着下标$n$ 变化而变化，表达的是一个动态演变过程。在很多情况下很难直接得到$a_{n}$的具体表达式，难以直接考察数列的动态演变过程。此时，为揭示数列中各项的动态演变规律，我们通常考察通项$a_{n}$与其前若干项之间的联系，或者说在通项与其前若干项之间建立一种确定的计算表达式，明确给出通项的具体构造过程，实现对动态过程的建模。由此得到如下递推关系的概念：  
【定义1.26】假设$\left\{a_{n}\right\}$是任一通项为$a_{n}$的数列，如果$a_{n}$可由其前若干项计算出来，则称该计算表达式为一个递推公式或递推关系式。为使递推公式能够进行递推计算，通常需要确定公式中一个或多个初始项的值，称这些初始项的值为递推公式的初值。如果一个数列的各项都满足递推关系，则称该数列为该递推关系的一个特解。  
例如，等差数列和等比数列都可用递推公式表示：对于公差为$d$的等差数列$\left\{a_{n}\right\}$，其递  
推公式为：$a_{n}=a_{n-1}+d$；公比$q$的等比数列$\left\{b_{n}\right\}$，其递推公式为$b_{n}=b_{n-1}q$。  
递推关系是求解组合计算问题的重要工具，在几乎所有的数学分支中都有着十分重要的作用。要使用递推关系解决有限集合的计数问题，首先必须针对求解问题演化规律建立相应的递推关系式，然后以递推关系式作为基本工具逐步实现对有限集合的计数。"
递推关系求解技术,算法,"['第一章  集合与计数基础', '§ 1.4 有限集的高级计数技术']","{'实体类型': '算法', '特点': '基于动态演化思想', '应用': '解决具有动态演化性质或复杂问题的计数'}",,2,前述基本计数技术主要基于静态思维，即认为求解问题处在一个相对静止状态，通过一些静态方法将这些状态的相关数量计算出来。如果求解问题在本质上具有动态演化性质，或者问题比较复杂必须考察其演变历史，对这类问题的计数必须考察问题状态的演变过程和规律，此时基于静态思维的基本计数技术就不能满足要求。本节介绍基于动态演化思想的高级计数技术，主要包括递推关系计数法、递推关系求解技术、生成函数计数法。
递推关系计数法,算法,"['第一章  集合与计数基础', '§ 1.4 有限集的高级计数技术']","{'实体类型': '算法', '特点': '基于动态演化思想', '应用': '解决具有动态演化性质或复杂问题的计数'}",,2,前述基本计数技术主要基于静态思维，即认为求解问题处在一个相对静止状态，通过一些静态方法将这些状态的相关数量计算出来。如果求解问题在本质上具有动态演化性质，或者问题比较复杂必须考察其演变历史，对这类问题的计数必须考察问题状态的演变过程和规律，此时基于静态思维的基本计数技术就不能满足要求。本节介绍基于动态演化思想的高级计数技术，主要包括递推关系计数法、递推关系求解技术、生成函数计数法。
通路,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.1 通路的概念与计数']","{'实体类型': '概念', '定义': '设G=⟨V,E⟩是任意给定的一个有向图或者无向图，T为图G中顶点和边的相继交替出现的序列，即Γ=v₀e₁v₁e₂v₂…eₖvₖ。如果对于i=1,2,⋯,k，均有vᵢ₋₁和vᵢ是eᵢ的两个端点（当G为有向图时，要求vᵢ₋₁为eᵢ的始点，vᵢ为eᵢ的终点），则称Γ为结点v₀到结点vₖ的一条通路，v₀和vₗ分别称为该通路的始点和终点，统称为通路的端点。通路T中所含边的数目k称为T的长度。当v₀=vₖ时，称该通路称为回路。', '特点': '通路中边和结点构成联结两个结点的间接联系', '分类': '简单通路、基本通路、复杂通路'}",,3,"前面我们讨论的图模型结构主要是图中结点与边的性质与联系，考察结点之间是否有边联结，换句话说，就是考察图中结点与结点之间的直接联系或直接关系。事实上，在很多情况下，图中结点之间的存在一些以其它一些中间结点为传递媒介的间接联系或间接关系。 例如，在现实世界中，常常考虑这样的问题：一个旅客如何乘高铁从一个城市经过若干个城市到达另一个目的地城市。 将这类问题进行抽象就成为如图8-28 所示图模型的问题，即如何从图中的一个给定结点开始，沿着多个边和结点连续移动到另一个指定的结点。  
![图8-28 部分城市高铁连接图  ](images/696b1dc16cae3150101fa23827543d58e80eb5b132e5b733a120daf06e5316d0.jpg)  
由以上分析可知，图模型中结点之间存在着经由多个边和多个结点的间接联系。对于存在间接联系的两个结点，可以从其中的一个结点出发，沿着作为其联系媒介的多个边和多个结点之间移动，就可达到另外一个结点。显然，这些边和结点构成了联结这两个结点的一个通路。由此得到图模型中通路的相关概念，具体定义如下：  
【定义8.21】设$G=\langle V,E\rangle$ 是任意给定的一个有向图或者无向图，$\boldsymbol{T}$为图$G$ 中顶点和边的相继交替出现的序列，即$\varGamma=v_{0}e_{1}v_{1}e_{2}v_{2}\ldots e_{k}v_{k}\,$。如果对于$i=1,2,\cdots,k$，均有${v_{i-1}}$ 和 $v_{i}$ 是 $e_{i}$ 的两个端点（当 $G$ 为有向图时，要求 $v_{i-1}$ 为 $e_{i}$ 的始点，${v}_{i}$ 为 $e_{i}$ 的终点），则称 $\varGamma$为结点 $v_{0}$ 到结点 $v_{k}$ 的一条通路，$v_{0}$ 和 $v_{l}$ 分别称为该通路的始点和终点，统称为通路的端点。通路$T$ 中所含边的数目 $k$称为$ T$ 的长度。当 $v_{0}=v_{k}$ 时，称该通路称为回路。  
![图8-29 图模型的通路  ](images/1d1c6154df6373d2cdb3faac71f53b624b61d1aa104aceed6cc19294e272f07e.jpg)  
例如，对于如图8-29 (a)所示的无向图，$v_{1}e_{1}v_{2}e_{2}v_{5}e_{6}v_{3}$便是一条通路$\Gamma$，$v_{1}$ 是该通路$\Gamma$的始点$v_{3}$ 是该通路$\Gamma$的终点$v_{1}$ 和 $v_{3}$ 都称为通路$\Gamma$的端点。其中通路$\Gamma$的长度为3。 特别地，对于通路$\ v_{1}e_{1}v_{2}e_{2}v_{5}e_{6}v_{3}e_{3}v_{1}$，则是回路。  
同样，对于如图8-29 (b)所示的有向图，$v_{1}e_{3}v_{2}e_{4}v_{5}e_{8}v_{4}e_{10}v_{3}e_{6}v_{6}$便是一条通路$\Gamma$，$v_{1}$ 是该通路$\Gamma$的始点，$v_{6}$ 是该通路$\Gamma$的终点，$v_{1}$ 和 $v_{6}$ 都称为通路$\Gamma$的端点。其中通路$\Gamma$的长度为5。 特别地，对于通路$\cdot v_{5}e_{9}v_{4}e_{10}v_{3}e_{5}v_{5}$，则是回路。  
在上述定义中，回路是一种特殊的通路，即起点等于终点的通路。但是，在习惯上我们所说的通路一般都不包含回路，也就是说不是回路的通路。因此，以后除非特别说明，我们所说的通路均是指不是回路的通路。  
下面定义通路和回路的各种类型：  
【定义8.22】设$G=\langle V,E\rangle$ 是任意给定的一个有向图或者无向图，$\boldsymbol{T}$为图$G$ 中分别以$v_{0}$和$v_{k}$为起点和终点的通路，即$\varGamma=v_{0}e_{1}v_{1}e_{2}v_{2}\ldots e_{k}v_{k}$，则有：  
（1）若 $\Gamma$ 中所有边各异，则称 $\Gamma$为简单通路或简单路径；若 $$\Gamma$$ 中所有边各异且$\boldsymbol{v}_{0}=$$\boldsymbol{v}_{k}$ 时，称 $$\Gamma$$为简单回路。  
（2）若 $\Gamma$中除 $v_{0},v_{k}$ 以外的所有结点各异（从而所有边也各异），则称 $$\Gamma$$  为基本通路或者基本路径。若 $v_{0}=v_{k}$ 且除 $v_{0},v_{k}$ 以外的所有结点各异，则称 $$\Gamma$$  为基本回路或者圈。  
（3）若 $\Gamma$  中有边重复出现，则称其为复杂通路，若还有 $v_{0}=v_{k}$ ，则称其为复杂回路。  
显然，基本通路必定是简单通路，基本回路必定是简单回路，反之不然。  
![图8-30 例图8.17 图模型  ](images/dd241eacc3384b3e855e4a8d2722d1e202b87f4bc0f4c935a9dc90df2ad5dde3.jpg)  
![图8-31 例8-18 图模型](images/9bbcb6a24cd69b076108d52999957fe02f755ca4cbb4868bf787f729d7371e2f.jpg)  
类似地，不难发现邻接矩阵𝐴的 $m$次方幂$A^{m}$在图模型中表示的含义。具体地说，就是$A^{m}$中元素$a_{i j}^{(m)}$的含义就是图中从$\boldsymbol{v}_{i}$出发到$v_{j}$且长度为$m$的路径数目。由此得到如下关于图模型中路径计数的基本定理：  
【定理8.2】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或者无向线图，并且其结点集合为  
$V=\{v_{1},v_{2},\ldots,v_{n}\}$，矩阵$A=(a_{i j})_{n\times n}$是图 $G$ 的邻接矩阵，则对于$A$的$m$次幂$A^{m}=$$({a_{i j}}^{})_{n\times n},m=1,2,\cdots,n,$，其元素 ${a_{i j}}^{(m)}$ 表示从结点 $v_{i}$ 到 $v_{j}$ 且长度为 $m$ 的通路数目；  
${a_{i i}}^{(m)}$表示从结点 $v_{i}$ 到其自身长度为 $m$ 的回路数目；$\begin{array}{r}{\sum_{i=1}^{n}\sum_{j=1}^{n}{a_{i j}}^{(m)}}\end{array}$为图G中长度为 $m$ 的通路（包括回路）总数。  
根据以上分析和讨论，我们可以得出这样的结论：对于任意一个有向或者无向的线图，都根据其邻接矩阵的方幂运算获得任意两个结点在任意指定长度下的通路和回路的数目。因此，关于线图模型的通路计数问题得到了很好的解决。"
通路计数定理,定理,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.1 通路的概念与计数']","{'实体类型': '定理', '内容': '假设G=⟨V,E⟩为任意给定的一个有向或者无向线图，并且其结点集合为V={v₁,v₂,⋯,vₙ}，矩阵A=(aᵢⱼ)ₙₓₙ是图G的邻接矩阵，则对于A的m次幂Aᵐ=({aᵢⱼ}^{})ₙₓₙ,m=1,2,⋯,n，其元素aᵢⱼʳᵐ表示从结点vᵢ到vⱼ且长度为m的通路数目；aᵢᵢʳᵐ表示从结点vᵢ到其自身长度为m的回路数目；∑ᵢ₌₁ⁿ∑ⱼ₌₁ⁿaᵢⱼʳᵐ为图G中长度为m的通路（包括回路）总数。', '结论': '任意一个有向或者无向的线图，都可根据其邻接矩阵的方幂运算获得任意两个结点在任意指定长度下的通路和回路的数目'}",,3,"前面我们讨论的图模型结构主要是图中结点与边的性质与联系，考察结点之间是否有边联结，换句话说，就是考察图中结点与结点之间的直接联系或直接关系。事实上，在很多情况下，图中结点之间的存在一些以其它一些中间结点为传递媒介的间接联系或间接关系。 例如，在现实世界中，常常考虑这样的问题：一个旅客如何乘高铁从一个城市经过若干个城市到达另一个目的地城市。 将这类问题进行抽象就成为如图8-28 所示图模型的问题，即如何从图中的一个给定结点开始，沿着多个边和结点连续移动到另一个指定的结点。  
![图8-28 部分城市高铁连接图  ](images/696b1dc16cae3150101fa23827543d58e80eb5b132e5b733a120daf06e5316d0.jpg)  
由以上分析可知，图模型中结点之间存在着经由多个边和多个结点的间接联系。对于存在间接联系的两个结点，可以从其中的一个结点出发，沿着作为其联系媒介的多个边和多个结点之间移动，就可达到另外一个结点。显然，这些边和结点构成了联结这两个结点的一个通路。由此得到图模型中通路的相关概念，具体定义如下：  
【定义8.21】设$G=\langle V,E\rangle$ 是任意给定的一个有向图或者无向图，$\boldsymbol{T}$为图$G$ 中顶点和边的相继交替出现的序列，即$\varGamma=v_{0}e_{1}v_{1}e_{2}v_{2}\ldots e_{k}v_{k}\,$。如果对于$i=1,2,\cdots,k$，均有${v_{i-1}}$ 和 $v_{i}$ 是 $e_{i}$ 的两个端点（当 $G$ 为有向图时，要求 $v_{i-1}$ 为 $e_{i}$ 的始点，${v}_{i}$ 为 $e_{i}$ 的终点），则称 $\varGamma$为结点 $v_{0}$ 到结点 $v_{k}$ 的一条通路，$v_{0}$ 和 $v_{l}$ 分别称为该通路的始点和终点，统称为通路的端点。通路$T$ 中所含边的数目 $k$称为$ T$ 的长度。当 $v_{0}=v_{k}$ 时，称该通路称为回路。  
![图8-29 图模型的通路  ](images/1d1c6154df6373d2cdb3faac71f53b624b61d1aa104aceed6cc19294e272f07e.jpg)  
例如，对于如图8-29 (a)所示的无向图，$v_{1}e_{1}v_{2}e_{2}v_{5}e_{6}v_{3}$便是一条通路$\Gamma$，$v_{1}$ 是该通路$\Gamma$的始点$v_{3}$ 是该通路$\Gamma$的终点$v_{1}$ 和 $v_{3}$ 都称为通路$\Gamma$的端点。其中通路$\Gamma$的长度为3。 特别地，对于通路$\ v_{1}e_{1}v_{2}e_{2}v_{5}e_{6}v_{3}e_{3}v_{1}$，则是回路。  
同样，对于如图8-29 (b)所示的有向图，$v_{1}e_{3}v_{2}e_{4}v_{5}e_{8}v_{4}e_{10}v_{3}e_{6}v_{6}$便是一条通路$\Gamma$，$v_{1}$ 是该通路$\Gamma$的始点，$v_{6}$ 是该通路$\Gamma$的终点，$v_{1}$ 和 $v_{6}$ 都称为通路$\Gamma$的端点。其中通路$\Gamma$的长度为5。 特别地，对于通路$\cdot v_{5}e_{9}v_{4}e_{10}v_{3}e_{5}v_{5}$，则是回路。  
在上述定义中，回路是一种特殊的通路，即起点等于终点的通路。但是，在习惯上我们所说的通路一般都不包含回路，也就是说不是回路的通路。因此，以后除非特别说明，我们所说的通路均是指不是回路的通路。  
下面定义通路和回路的各种类型：  
【定义8.22】设$G=\langle V,E\rangle$ 是任意给定的一个有向图或者无向图，$\boldsymbol{T}$为图$G$ 中分别以$v_{0}$和$v_{k}$为起点和终点的通路，即$\varGamma=v_{0}e_{1}v_{1}e_{2}v_{2}\ldots e_{k}v_{k}$，则有：  
（1）若 $\Gamma$ 中所有边各异，则称 $\Gamma$为简单通路或简单路径；若 $$\Gamma$$ 中所有边各异且$\boldsymbol{v}_{0}=$$\boldsymbol{v}_{k}$ 时，称 $$\Gamma$$为简单回路。  
（2）若 $\Gamma$中除 $v_{0},v_{k}$ 以外的所有结点各异（从而所有边也各异），则称 $$\Gamma$$  为基本通路或者基本路径。若 $v_{0}=v_{k}$ 且除 $v_{0},v_{k}$ 以外的所有结点各异，则称 $$\Gamma$$  为基本回路或者圈。  
（3）若 $\Gamma$  中有边重复出现，则称其为复杂通路，若还有 $v_{0}=v_{k}$ ，则称其为复杂回路。  
显然，基本通路必定是简单通路，基本回路必定是简单回路，反之不然。  
![图8-30 例图8.17 图模型  ](images/dd241eacc3384b3e855e4a8d2722d1e202b87f4bc0f4c935a9dc90df2ad5dde3.jpg)  
![图8-31 例8-18 图模型](images/9bbcb6a24cd69b076108d52999957fe02f755ca4cbb4868bf787f729d7371e2f.jpg)  
类似地，不难发现邻接矩阵𝐴的 $m$次方幂$A^{m}$在图模型中表示的含义。具体地说，就是$A^{m}$中元素$a_{i j}^{(m)}$的含义就是图中从$\boldsymbol{v}_{i}$出发到$v_{j}$且长度为$m$的路径数目。由此得到如下关于图模型中路径计数的基本定理：  
【定理8.2】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或者无向线图，并且其结点集合为  
$V=\{v_{1},v_{2},\ldots,v_{n}\}$，矩阵$A=(a_{i j})_{n\times n}$是图 $G$ 的邻接矩阵，则对于$A$的$m$次幂$A^{m}=$$({a_{i j}}^{})_{n\times n},m=1,2,\cdots,n,$，其元素 ${a_{i j}}^{(m)}$ 表示从结点 $v_{i}$ 到 $v_{j}$ 且长度为 $m$ 的通路数目；  
${a_{i i}}^{(m)}$表示从结点 $v_{i}$ 到其自身长度为 $m$ 的回路数目；$\begin{array}{r}{\sum_{i=1}^{n}\sum_{j=1}^{n}{a_{i j}}^{(m)}}\end{array}$为图G中长度为 $m$ 的通路（包括回路）总数。  
根据以上分析和讨论，我们可以得出这样的结论：对于任意一个有向或者无向的线图，都根据其邻接矩阵的方幂运算获得任意两个结点在任意指定长度下的通路和回路的数目。因此，关于线图模型的通路计数问题得到了很好的解决。"
逻辑,原理,"['第三章  命题演算与推理', '§ 3.1 命题的概念与运算', '3.1.1  逻辑与命题逻辑']","{'实体类型': '原理', '特点': '推理符合思维的基本形式、基本规则和基本规律', '地位': '形式逻辑是正确思维的基础'}",,3,"正确的思维是人们在日常学习、工作和生活中避免犯错的基础。所谓正确的思维，其实就是概念清晰、判断正确、推理合乎逻辑。这里的逻辑主要是指形式逻辑，意思是说推理要符合思维的基本形式、基本规则和基本规律。英国哲学家弗朗西斯·培根曾经说过：“逻辑是不可战胜的，因为反对逻辑的时候必须要使用逻辑”。这句话尽管有些极端，却很好地说明了逻辑的重要性。形式逻辑最初由古希腊哲学家亚里士多德创立，旨在通过研究人类思维的基本形式、基本规则和基本规律为政治家、哲学家、社会活动价的辩论提供理论指导。因此，历史上著名的政治家、哲学家和社会活动家在逻辑学方面一般都具有很深的造诣。  
用自然语言表达和处理逻辑问题虽然易于理解，但是自然语言与生俱来的歧义性使其难以满足逻辑表达在严密性方面的需求，制约了逻辑学的进一步发展。因此，德国著名数学家莱布尼茨提出一个关于数理逻辑的构想，意思是通过引入一套形式化符号系统来表示和处理逻辑问题，使得逻辑能够像代数一样进行演算、像几何一样可以画图，在发生意见分歧的时无需争论，只需说：让我们坐下来算一算吧，看谁正确。这就是著名的莱布尼茨梦想。1847年，英国数学家乔治∙布尔出版了第一部数理逻辑著作《逻辑学的数学分析》，创立一套以命题符号演算与推理为处理对象的布尔代数系统，初步实现了莱布尼茨梦想，使数理逻辑由一个初步的设想变成一套相对完整的数学理论体系。布尔代数以命题作为基本处理单元，故亦称为命题代数或命题逻辑。其实，与布尔同时代的数学家德摩根也几乎独立地在命题逻辑方面做了大量研究工作，并取得了丰硕的成果。可以这样说，数学家德摩根正式启动了将经典逻辑学大部分研究内容纳入数学范畴的任务，数学家布尔则是完成了这项任务。命题逻辑的现有知识体系基本上涵盖了这两位数学家的相关成果。"
逻辑蕴含式,概念,"['第四章  谓词演算与推理', '§ 4.2  谓词公式与等值演算', '4.2.4 谓词公式的等值与蕴含', '二、谓词公式的蕴含关系']","{'实体类型': '概念', '定义': '谓词公式G逻辑蕴含谓词公式H的式子，记作G⇒H'}",,4,"如同多项式演算不仅要用到恒等式，还经常用到不等式，谓词公式的逻辑演算与推理也是不仅要用到谓词公式之间的等值关系，而且还需要用到谓词公式之间的蕴含关系。谓词公式之间的蕴含关系如同多项式代数系统中多项式之间的小于或等于关系， 具体地说， 所谓两 个谓词公式之间存在蕴含关系，其实就是两个谓词公式在任何解释下，其中一个谓词公式的真值永远不会大于另外一个谓词公式的真值。下面借助有效公式的概念给出具体定义：  
【定义4.18】假设$G$和$H$是任意两个谓词公式，如果谓词公式$G\rightarrow H$是有效公式，则称谓词公式$\pmb{G}$逻辑蕴含谓词公式$\pmb{H}$，亦称$G$ 与$H$之间具有逻辑蕴含关系，通常简称为蕴含关系，记作$G\Rightarrow H$，并称该式为谓词公式的逻辑蕴含式，通常简称为蕴含式。  
由上述定义可知，判断两个谓词公式$G$ 和$H$ 是否具有逻辑蕴含关系，关键在于证明谓词公式$G\rightarrow H$为有效公式，这种思路与证明命题公式永真蕴含关系的基本思路是一致的。类似于命题公式的永真蕴含演算系统，在谓词公式的逻辑蕴含演算系统中，通常也是先证明出一些重要的谓词公式蕴含式，然后将这些重要谓词蕴含式作为基本蕴含式进一步推演出更多的谓词公式蕴含式，这种推演过程构成了谓词公式蕴含演算的主要内容。下面不加证明地给出这些重要而基本的谓词公式蕴含式，读者可自行给出证明。  
由于谓词公式的逻辑蕴含式依据谓词公式的有效公式定义，而命题公式中永真公式的谓词公式代换实例显然是有效谓词公式，因此与前述谓词公式的等值式类似，前述命题逻辑中15 个基本永真蕴含式经过谓词公式代换后，就可以得到相应的谓词公式基本逻辑蕴含式。当然，由前述每组谓词公式基本等值式显然都可以得到两组相应的基本逻辑蕴含式，这里不再一一赘述。这里主要介绍如下与量词有关的逻辑蕴含式。  
【定理4.1】假设$G(x)$和$H(x)$是任意两个谓词公式，则存在如下逻辑蕴含关系：  
$$
\forall x G(x)\lor\forall x H(x)\Rightarrow\forall x(G(x)\lor H(x))\tag{4-7}
$$  
$$
\exists x(G(x)\land H(x))\Rightarrow\exists x G(x)\land\exists x H(x)\tag{4-8}
$$  
不难看出，上述定理的两个式子仅仅是蕴含式而不是等值式。例如对于（1）式如下解释，由这些人都跳舞或这些人都唱歌，可以推出这些人都跳舞或唱歌。但是反之不然，由这些人都跳舞或唱歌不能推出这些人都跳舞或这些人都唱歌。（2）式可做类似理解。"
避圈法,算法,"['第九章  树的基本理论与算法', '§ 9.1 无向树的基本知识', '9.1.2 无向图的生成树']","{'实体类型': '算法', '关键步骤': '选择不构成任何回路的n-1条边', '应用': '构造生成树'}",,3,"如前所述，树模型是大自然赐予的一种最简洁最高效的连通无向图，任意两个结点之间有且仅有一条路径联结。因此，在对一般连通无向图进行化简的时候，经常会删除图的一些边将其转化为树结构的生成子图。这种生成子图称为无向图的生成树，其定义如下：  
【定义9.2】假设$G=\langle V,E\rangle$是任意给定的一个无向图模型，若$G$的某个生成子图是树，则称该树为$G$的一个生成树，记为$T_{G}$。生成树$T_{G}$中的每条边均称为树枝；$G$中不在$T_{G}$中的每条边均称为弦；$T_{G}$的所有弦的集合称为生成树的补。  
例如，对于图9-3(a)所示的图$G_{1}$无向图，$G_{2}$和$G_{3}$为该图的两棵不同构的生成树。对于图9-3(b)所示生成树$G_{2}$，边$\mathtt{e}_{2},\mathtt{e}_{3},\mathtt{e}_{4},\mathtt{e}_{5}$ 是其树枝，而$\mathsf{e}_{1},\,\mathsf{e}_{6}$ 是其弦；对于图9-3(c)所示的生成树$G_{3}$，$\mathsf{e}_{1},\mathsf{e}_{2},\mathsf{e}_{4},\mathsf{e}_{5}$ 是其树枝，而$\mathsf{e}_{3},\,\mathsf{e}_{6}$ 是其弦。  
![图9-3 连通无向图及其生成树  ](images/3447e9802eaf794918ba03e412f68817eae23f2621102647ed094020348d10e0.jpg)  
显然，对于一个无向连通图$G$，如果$G$本身就是树，则其生成树就是它自己，因而是唯一的。但是，如果$G$不是树，则其生成树就不是唯一的。下面的定理9.3 保证了无向连通图模型生成树的存在性，为无向连通图的化简提供了坚实的基础：  
【定理9.3】假设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$存在其生成树$T_{G}=\langle V_{T}\,,\,\,\,E_{T}\rangle$的充分必要条件是$G$是连通的。  
事实上，上述定理证明过程给出了构造生成树的一种具体算法，通常称之为破圈法。该算法的关键是判断图$G$中是否有回路。若有回路，则删除回路中的一条边，直到图中无回路为止。假设图$G$中有${n}$个结点和$m$条边，则由生成树结点与边的关系知，要构造该图的生成树，必需删除$m-n+1$条边。  
此外，由于含$_n$个结点和$m$条边无向连通图$G=(n,m)$一定存在生成树，且生成树中必有$n$个顶点，$n-1$条树枝和$m-n+1$条弦。因此，在$G$中选择不构成任何回路的$n-1$条边就一定可以得到$G$的一个生成树。这种构造生成树的方法，通常称为避圈法。  
![图9-4 构造生成树的破圈法与避圈法  ](images/6583966484122e279921cd749c7234aa541872b9fc25864834c494c7d9d17e62.jpg)  
破圈法和避圈法需要找出回路或验证不存在回路，计算量通常较大。由于在对一般连通无向图进行广度遍历搜索的时候，会自然形成一个无回路的连通生成子图，即该图生成树。因此，可以通过广度优先遍历算法构造生成树。该算法无需判断回路，因而具有较高的计算效率，比较适合计算机处理。对于连通图$G=\langle V,E\rangle$，该算法的具体过程如下：  
（1）任选$s\in V$，将$s$标记为0，令$L=\{s\},\;V=V-\{s\},k=0$；  
（2）如果$v=\varnothing$，则转（4），否则令$\cdot k=k+1$；  
（3）依次对$L$中的所有标记为$k-1$的结点$v$，如果它与𝑉中的结点𝑤相连接，则将𝑤标记为$k$，指定$v$为$w$的前驱，令$L=L\cup\{w\}$，转（2）；  
（4）$E_{G}=\big\{(v,w)\big|w\in L-\{s\},v\big\}$𝑤的前驱}结束。"
邻接点,概念,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.2 图的定义与分类']","{'实体类型': '概念', '定义': '若两个结点u和v是边e的端点，则称u与v互为邻接点'}",,3,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)"
邻接矩阵,概念,"['8.1.3 图的表示方法', '§ 8.2 图的运算与结构', '§ 8.1 图的概念与表示', '8.3.2 可达性及其判定', '一、邻接矩阵表示法', '第八章  图的基本理论与算法']","{'实体类型': '概念', '定义': '表示图结点间邻接关系的矩阵，图G的邻接矩阵表示图中结点之间的邻接关系', '特点': '矩阵元素表示图中结点之间是否有边相连', '条件': '首先必须对图中的所有结点进行编号', '应用': '通过计算邻接矩阵的幂判定结点之间是否可达', 'name': '邻接矩阵'}",,4,"邻接矩阵是表示图结点间邻接关系的矩阵，即表示图模型中的各个结点之间是否有边的联结关系的关系矩阵。邻接矩阵的具体定义如下：  
【定义8.7】设$G=\langle V,E\rangle$是任一给定的图模型 ，其中结点集合$\ V=\{v_{1},v_{2},\ldots,v_{n}\}$，边集合$E=\{e_{1},e_{2},\dots,e_{m}\}$。称 $n$ 阶方阵 $A_{G}=(a_{i j})_{n\times n}$为图 $G$ 的邻接矩阵，如果矩阵元素 $a_{i j}$ 表示图中结点$v_{i}$ 和 $v_{j}$ 之间是否有边相连：若有则$a_{i j}$为边数$k$，否则$a_{i j}=0$。即有：  
$$
a_{i j}={\left\{\begin{array}{l l}{k,}&{{\mathbb{若}}(v_{i},v_{j}){\in}E{\mathbb{或}}\langle v_{i},v_{j}\rangle{\in}E}\\ {0,}&{{\mathbb{否则}}}\end{array}\right.}\quad\quad\quad\quad(i,j=1,2,3,\cdots,n)
$$ {      }  
从上述定义可以看出，如果图$G=\langle V,E\rangle$是一个线图，则其邻接矩阵为布尔矩阵。此外，需要注意的是，要确定一个图的邻接矩阵，首先必须对图中的所有结点进行编号，邻接矩阵的表示与结点编号的次序紧密相关，不同的结点编号对应于不同的邻接矩阵，结点编号次序的交换对应于邻接矩阵行列的交换。  
图8-8 所示有向图 $G$ 在 $v_{1},v_{2},v_{3},v_{4}$的结点次序下的邻接矩阵为：  
$$
\begin{gathered}v_{1}\quad v_{2}\quad v_{3}\quad v_{4}\\A_{G}=(a_{ij})_{n\times n}=\begin{matrix}v_{2}\\v_{3}\\v_{4}\end{matrix}\begin{pmatrix}0&1&0&1\\1&0&1&1\\1&0&0&0\\0&0&1&0\end{pmatrix}.\end{gathered}
$$  
事实上，无向图和有向图的关联矩阵有一些差异。例如，无向图的每条边不带方向，或理解为每条边同时具有两个方向，故其表示的二元关系具有对称性。因此，关系矩阵或者说图的关联矩阵是一个对称矩阵。对于有向图，其表示的二元关系不一定具有对称性，故其关联矩阵不一定是对称矩阵。因此，通常分别讨论无向图和有向图的邻接矩阵。"
邻接矩阵与结点度关系,结论,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.2.2 图模型的度结构']","{'实体类型': '结论', '内容': '如果 $G$ 是无向图，那么邻接矩阵 $A$ 中第 $i$ 行元素之和表示结点 $v_{i}$ 的度数，第 $j$ 列元素之和表示结点 $v_{j}$ 的度数。若 $G$ 是有向图，那么邻接矩阵 $A$ 中第 $i$ 行元素之和表示结点 $v_{i}$ 的出度，第 $j$ 列元素之和表示结点 $v_{j}$ 的入度'}",,3,"现在我们考察图模型的结构特征。从结构上看，对于任意给定的一个图模型，只要该图不是零图，总会有一些点与一些边相互联结。从生成子图的概念可以看出，图的结点构成了图模型的骨架或主体结构，因此，我们主要从结点出发考察每个结点所关联的边关联多少条边。为此，对于图中的每个结点，都定义一个数来描述该结点所关联边的个数，这就是结点度的概念，其具体定义如下：  
【定义8.16】假设图 $G=\langle V,E\rangle$是任意给定的一个无向图，对于$G$中任意一个结点 $v$ ，与该结点关联边的条数称为该结点的度数，简称为度，记为 ${\sf d e g}(v)$。图$G$中各个结点度数的最大值称为图$G$的最大度，记为$\Delta(G)$；图$G$中各个结点度数的最小值称为图$G$的最小度，记为$\delta(G)$ $\Delta(\mathrm{G})=\mathrm{max}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\};\,\,\,\delta(\mathrm{G})=\mathrm{min}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\}\,.$  
【定义8.17】设图 $G=\langle V,E\rangle$是任意给定的一个有向图，$v$是$G$中任一结点，则有：  
（1）以该结点为起点的有向边的条数，称为该结点的出度，记为$\deg^{+}(v)$；以该结点为终点的有向边的条数，称为该结点的入度，记为 $\deg^{-}(v)$。  
（2）该结点的出度与入度之和称为该结点的度，记为${\sf d e g}(v)$。 即有：  
$$
\deg(v)=\deg^{+}(v)+\deg^{-}(v)
$$  
（3）图$G$中各个结点出度与入度的最大值分别称为图$G$的最大出度和最大入度，分别记为$\Delta^{+}(\mathsf{G})$和 $\Delta^{-}(\mathsf{G})$；图$G$中各个结点出度与入度的最小值分别称为图$G$的最小出度和最小入度，分别记为$\Delta^{+}(\mathbf{G})$和 $\Delta^{-}(\mathsf{G})$，即有：  
$\Delta^{+}(\mathrm{G})=\operatorname*{max}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\Delta^{-}(\mathrm{G})=\operatorname*{max}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$ $\delta^{+}(\mathrm{G})=\operatorname*{min}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\delta^{-}(\mathrm{G})=\operatorname*{min}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$  
从上述定义可以看出，引入度结点度概念的目的主要是通过对图中每个结点所关联边数进行统计分析来考察图模型的结构特征。  
【定义8.18】对于任意一个给定的有向图或无向图  $G=\langle V,E\rangle$ ，图中度数为1 的结点称为该图的悬挂结点，图中以悬挂结点为端点的边称为该图的悬挂边。如果图$G$中各个结点的度数均相同，则称该图正则图，各结点度均为$\ k$的正则图称为$\pmb{k}$-正则图。  
下面我们考察图的邻接矩阵与图中结点度之间的关系。  
假设 $G=\langle V,E\rangle$是任意给定的一个有向图或无向图，其中$V=\{v_{1},v_{2},\ldots,v_{n}\}$，$E=$$\{e_{1},e_{2},\ldots,e_{m}\}$。 $G$的邻接矩阵为：  
$$
A=(a_{i j})_{n\times n}=\left(\!\!{\begin{array}{c c c c}{a_{11}}&{a_{12}}&{\ldots}&{a_{1n}}\\ {a_{21}}&{a_{22}}&{\ldots}&{a_{2n}}\\ {\vdots}&{\ddots}&{\vdots}\\ {a_{n1}}&{a_{n2}}&{\ldots}&{a_{n n}}\end{array}}\!\!\right)
$$  
则有如下结论：  
（1）如果$G$是无向图，那么邻接矩阵𝐴中第𝑖行元素之和表示结点$v_{i}$的度数，第𝑗列元素之和表示结点$v_{j}$的度数。即有：  
$$
\deg(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};~~~~\deg\bigl(v_{j}\bigr)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（2）若G是有向图，那么邻接矩阵$A$中第𝑖行元素之和表示结点$v_{i}$的出度，第$j$列元素之和表示结点$v_{j}$的入度。简单地说，就是竖入横出。即有：  
$$
\deg^{-}(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};\qquad\deg^{+}\!\left(v_{j}\right)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（3）对于有向图G，注意到：  
$$
\sum_{j=1}^{n}\;\deg^{-}\!\left(v_{j}\right)=\sum_{i=1}^{n}\sum_{j=1}^{n}a_{i j}=\sum_{i=1}^{n}\deg^{+}\!\left(v_{i}\right)
$$  
因此，有向图中所有入度之和等于所有出度之和，这个和其实就是图的边数$m$。因为有向图的每条边均产生且仅产生一个出度和一个入度。  
对于图8-19 所示图模型$G$及如下邻接矩阵$A_{G}$，容易验证，结点度与邻接矩阵之间的数量关系。例如，$A_{G}$中第三行元素之和为3，即$v_{3}$的出度为3。
$$
\begin{gathered}v_{1}\quad v_{2}\quad v_{3}\quad v_{4}\quad v_{5}\\A_{G}=\begin{matrix}v_{1}\\v_{2}\\v_{3}\\v_{4}\end{matrix}\begin{pmatrix}0&1&0&0&0\\0&1&1&0&0\\1&1&0&1&0\\0&0&0&0&0\\0&0&0&0&0\end{pmatrix}\end{gathered}
$$  
关于图中结点度数与边的关系，有如下著名的图论基本定理：  
【定理8.1】（握手定理）假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，则该图中结点度数的总和等于边数的二倍，即有：  
$$
\sum_{v\in V}\deg(v)=2|E|
$$  
【推论8.1】图中度数为奇数的结点个数必为偶数。  
从以上定理及例题可以看出，图模型中结点的度从一种定量的角度反映了图中结点与边之间的制约关系，在一定程度上刻画了图模型的结构特征。为了更加方便地描述图模型中各个结点的度结构信息，下面给出度序列的概念：  
【定义8.19】假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，图中每个结点的图构成的自然数序列称为$G$的度序列。也就是说，若 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，则称序列：  
$$
(\deg(v_{1})\,,\deg(v_{2})\,,\cdots,\deg(v_{n}))
$$  
为图 $G$ 的度数序列，简称为度序列。 此外，对于任意一个给定的自然数序列，如果该序列能够成为某个图的度序列，则称该序列为可图化序列。  
例如，对于图8-22 所示图 $G$ ，其度数序列为 (2,3,3,4)  
![图8-22 图 $G$ ](images/77ba680d9b589e032065b86071c3f75473dc0d06736af0deb36aa2115de43d51.jpg)  
由于图模型的度要满足握手定理等基本约束要求，而且对于不同类型的图，其度序列也会有一些相应的数据特征。因此，并不是任意的自然数序列都可以构成图模型的度序列。对于任意给定的自然数序列，需要通过分析其数据特征来判断其是否为可图化序列。若是可图化序列，则可依据该序列数据来分析其所对应图的结构特征。"
邻接矩阵的方幂,原理,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.1 通路的概念与计数']","{'实体类型': '原理', '含义': 'Aᵐ中元素aᵢⱼʳᵐ表示图中从vᵢ出发到vⱼ且长度为m的路径数目'}",,3,"前面我们讨论的图模型结构主要是图中结点与边的性质与联系，考察结点之间是否有边联结，换句话说，就是考察图中结点与结点之间的直接联系或直接关系。事实上，在很多情况下，图中结点之间的存在一些以其它一些中间结点为传递媒介的间接联系或间接关系。 例如，在现实世界中，常常考虑这样的问题：一个旅客如何乘高铁从一个城市经过若干个城市到达另一个目的地城市。 将这类问题进行抽象就成为如图8-28 所示图模型的问题，即如何从图中的一个给定结点开始，沿着多个边和结点连续移动到另一个指定的结点。  
![图8-28 部分城市高铁连接图  ](images/696b1dc16cae3150101fa23827543d58e80eb5b132e5b733a120daf06e5316d0.jpg)  
由以上分析可知，图模型中结点之间存在着经由多个边和多个结点的间接联系。对于存在间接联系的两个结点，可以从其中的一个结点出发，沿着作为其联系媒介的多个边和多个结点之间移动，就可达到另外一个结点。显然，这些边和结点构成了联结这两个结点的一个通路。由此得到图模型中通路的相关概念，具体定义如下：  
【定义8.21】设$G=\langle V,E\rangle$ 是任意给定的一个有向图或者无向图，$\boldsymbol{T}$为图$G$ 中顶点和边的相继交替出现的序列，即$\varGamma=v_{0}e_{1}v_{1}e_{2}v_{2}\ldots e_{k}v_{k}\,$。如果对于$i=1,2,\cdots,k$，均有${v_{i-1}}$ 和 $v_{i}$ 是 $e_{i}$ 的两个端点（当 $G$ 为有向图时，要求 $v_{i-1}$ 为 $e_{i}$ 的始点，${v}_{i}$ 为 $e_{i}$ 的终点），则称 $\varGamma$为结点 $v_{0}$ 到结点 $v_{k}$ 的一条通路，$v_{0}$ 和 $v_{l}$ 分别称为该通路的始点和终点，统称为通路的端点。通路$T$ 中所含边的数目 $k$称为$ T$ 的长度。当 $v_{0}=v_{k}$ 时，称该通路称为回路。  
![图8-29 图模型的通路  ](images/1d1c6154df6373d2cdb3faac71f53b624b61d1aa104aceed6cc19294e272f07e.jpg)  
例如，对于如图8-29 (a)所示的无向图，$v_{1}e_{1}v_{2}e_{2}v_{5}e_{6}v_{3}$便是一条通路$\Gamma$，$v_{1}$ 是该通路$\Gamma$的始点$v_{3}$ 是该通路$\Gamma$的终点$v_{1}$ 和 $v_{3}$ 都称为通路$\Gamma$的端点。其中通路$\Gamma$的长度为3。 特别地，对于通路$\ v_{1}e_{1}v_{2}e_{2}v_{5}e_{6}v_{3}e_{3}v_{1}$，则是回路。  
同样，对于如图8-29 (b)所示的有向图，$v_{1}e_{3}v_{2}e_{4}v_{5}e_{8}v_{4}e_{10}v_{3}e_{6}v_{6}$便是一条通路$\Gamma$，$v_{1}$ 是该通路$\Gamma$的始点，$v_{6}$ 是该通路$\Gamma$的终点，$v_{1}$ 和 $v_{6}$ 都称为通路$\Gamma$的端点。其中通路$\Gamma$的长度为5。 特别地，对于通路$\cdot v_{5}e_{9}v_{4}e_{10}v_{3}e_{5}v_{5}$，则是回路。  
在上述定义中，回路是一种特殊的通路，即起点等于终点的通路。但是，在习惯上我们所说的通路一般都不包含回路，也就是说不是回路的通路。因此，以后除非特别说明，我们所说的通路均是指不是回路的通路。  
下面定义通路和回路的各种类型：  
【定义8.22】设$G=\langle V,E\rangle$ 是任意给定的一个有向图或者无向图，$\boldsymbol{T}$为图$G$ 中分别以$v_{0}$和$v_{k}$为起点和终点的通路，即$\varGamma=v_{0}e_{1}v_{1}e_{2}v_{2}\ldots e_{k}v_{k}$，则有：  
（1）若 $\Gamma$ 中所有边各异，则称 $\Gamma$为简单通路或简单路径；若 $$\Gamma$$ 中所有边各异且$\boldsymbol{v}_{0}=$$\boldsymbol{v}_{k}$ 时，称 $$\Gamma$$为简单回路。  
（2）若 $\Gamma$中除 $v_{0},v_{k}$ 以外的所有结点各异（从而所有边也各异），则称 $$\Gamma$$  为基本通路或者基本路径。若 $v_{0}=v_{k}$ 且除 $v_{0},v_{k}$ 以外的所有结点各异，则称 $$\Gamma$$  为基本回路或者圈。  
（3）若 $\Gamma$  中有边重复出现，则称其为复杂通路，若还有 $v_{0}=v_{k}$ ，则称其为复杂回路。  
显然，基本通路必定是简单通路，基本回路必定是简单回路，反之不然。  
![图8-30 例图8.17 图模型  ](images/dd241eacc3384b3e855e4a8d2722d1e202b87f4bc0f4c935a9dc90df2ad5dde3.jpg)  
![图8-31 例8-18 图模型](images/9bbcb6a24cd69b076108d52999957fe02f755ca4cbb4868bf787f729d7371e2f.jpg)  
类似地，不难发现邻接矩阵𝐴的 $m$次方幂$A^{m}$在图模型中表示的含义。具体地说，就是$A^{m}$中元素$a_{i j}^{(m)}$的含义就是图中从$\boldsymbol{v}_{i}$出发到$v_{j}$且长度为$m$的路径数目。由此得到如下关于图模型中路径计数的基本定理：  
【定理8.2】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或者无向线图，并且其结点集合为  
$V=\{v_{1},v_{2},\ldots,v_{n}\}$，矩阵$A=(a_{i j})_{n\times n}$是图 $G$ 的邻接矩阵，则对于$A$的$m$次幂$A^{m}=$$({a_{i j}}^{})_{n\times n},m=1,2,\cdots,n,$，其元素 ${a_{i j}}^{(m)}$ 表示从结点 $v_{i}$ 到 $v_{j}$ 且长度为 $m$ 的通路数目；  
${a_{i i}}^{(m)}$表示从结点 $v_{i}$ 到其自身长度为 $m$ 的回路数目；$\begin{array}{r}{\sum_{i=1}^{n}\sum_{j=1}^{n}{a_{i j}}^{(m)}}\end{array}$为图G中长度为 $m$ 的通路（包括回路）总数。  
根据以上分析和讨论，我们可以得出这样的结论：对于任意一个有向或者无向的线图，都根据其邻接矩阵的方幂运算获得任意两个结点在任意指定长度下的通路和回路的数目。因此，关于线图模型的通路计数问题得到了很好的解决。"
邻接表表示法,算法,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.3 图的表示方法', '三、邻接表表示法']","{'实体类型': '算法', '定义': '对图G中每个结点vi建立一个单链表，表头存放结点vi信息，其余单元存放与vi相关联边的信息', '结构': '由顶点表和边表两部分组成', '实现方式': '通过指针串接各个存储单元'}",,4,"对于一个图模型$G=\langle V,E\rangle$，当图中的边数较多时，邻接矩阵和关联矩阵都是比较有效的表示方法。然而，当图$G$中的边数较少时，邻接矩阵和关联矩阵的的表示方法就比较浪费资源。此时，可采用邻接表的方法表示图模型。  
邻接表分别对图$G=\langle V,E\rangle$中每个结点$v_{i}$建立一个单链表。对于结点$v_{i}$的单链表，该表的第一个存储单元为表头，存放结点$v_{i}$的有关信息，表中其它存储单元存放与所有结点$v_{i}$相关联边的信息。因此，每个单链表中都存放着图的某个结点及与该结点相关联的所有边，表中各个存储单元通过指针进行串接。图$G$中所有结点的单链表就构成图$G$的邻接表，该表是由单链表的表头形成的顶点表和单链表其余结点形成的边表两部分组成。"
邻接边,概念,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.2 图的定义与分类']","{'实体类型': '概念', '定义': '具有公共结点的两条边'}",,3,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)"
重要的联结词完备集,性质,"['第三章  命题演算与推理', '§ 3.3 联结词的完备集', '3.3.2 联结词的完备性']","{'实体类型': '性质', '内容': '$\\\\{\\\\neg, \\\\ \\\\vee\\\\}$, $\\\\{\\\\neg, \\\\ \\\\land\\\\}$, $\\\\{\\\\neg, \\\\ \\\\rightarrow\\\\}$, $\\\\{\\\\neg, \\\\ \\\\nrightarrow\\\\}$, $\\\\{\\\\uparrow\\\\}$ 都是极小完备集，$\\\\left\\\\{\\\\neg, \\\\ \\\\lor\\\\ , \\\\ \\\\land\\\\right\\\\}$ 是一个完备的联结词集合'}",,3,"现在我们进一步考察联结词的表示功能的完备性问题，即至少需要多少种运算联结词才能表示任意命题公式？首先给出如下联结词功能完备集的概念：  
【定义3.18】假设𝑆是一个由逻辑运算联结词组成的集合，如果对于任意一个命题公式，都有由𝑆中联结词表示出来的命题公式与之等值，则称𝑆是一个完备的联结词集合，或者说𝑆是一个联结词的完备集。  
由联结词的枚举可知联结词的数量或种类有很多，其实不难发现其中有很多联结词之间是可以互推的，或者说可以相互表示。因此，对于一个联结词的完备集，其中可能会存在联结词的冗余，有时需要消除这种冗余，故有如下极小完备联结词集合的概念：  
【定义3.19】假设𝑆是一个任意给定的联结词的完备集，从𝑆中任意删除一个联结词后得到新的联结词集合$\boldsymbol{\cdot}\boldsymbol{S}^{*}$，则$S^{*}$不是联结词的完备集，也就是说，至少有一个命题公式不能等价于由$S^{*}$中联结词表示的任一公式，此时称𝑆是一个极小完备联结词集合。  
通常都需要选用适当的联结词完备集以更加方便地进行命题公式演算。由于命题公式的归纳定义仅涉及一元联结词和二元联结词，故仅需考察由一元联结词和二元联结词为元素组成的联结词集合。下面给出一些重要的联结词完备集：  
由于：$P\rightarrow Q\Leftrightarrow\neg P\rightarrow Q,\,\,\,P\leftrightarrow Q\Leftrightarrow(\neg P\lor Q)\land(\neg Q\lor P),\,\,\,P\land Q\Leftrightarrow\neg(\neg P\lor\neg Q)$。所以$\{\neg,\ \vee\}$可构成极小完备集，同理$\{\neg,\ \land\}$也可以构成极小完备集。  
由于：$P\vee Q\Leftrightarrow\neg P\rightarrow Q， \Rightarrow\neg P\to Q\ ,\ \ P\land Q\Leftrightarrow\neg(\neg P\lor\neg Q)\Leftrightarrow\neg(P\to\neg Q)\ ,\ \ P\leftrightarrow Q\Leftrightarrow(P\to Q)\land$  
$(Q\rightarrow P)$。所以$\{\neg,\ \ \rightarrow\}$可以构成极小完备集。  
由于$P\land Q\Leftrightarrow\neg(\neg P\lor\neg Q)\Leftrightarrow\neg(P\to\neg Q)\Leftrightarrow P\nRightarrow\neg Q$，故$\{\neg,\quad\nrightarrow\}$可构成极小完备集。  
由于$\neg P\Leftrightarrow\neg(P\land P)\Leftrightarrow P\uparrow P,$，$P\land Q\Leftrightarrow\neg\neg(P\land Q)\Leftrightarrow\neg\ P\uparrow Q$，故{↑}可构成极小完备集。同理，$\{\downarrow\}$可构成极小完备集。↑和↓在大规模集成电路中具有广泛应用。  
由以上的分析可知， $\{\neg,\ \ \vee\},\ \{\neg,\ \ \wedge\},\ \{\neg,\ \ \rightarrow\},\ \ \{\neg,\ \ \nrightarrow\},\ \ \{\uparrow\} \},$都是极小完备集，$\left\{\neg,\ \ \lor\ ,\ \ \land\right\}$是一个完备的联结词集合。但是$\{\lor\},\ \{\land\},\ \{\lor,\ \land\}$等都不是极小完备集"
重集,概念,"['第一章  集合与计数基础', '§ 1.3 有限集的基本计数技术', '1.3.3 排列计数与组合计数', '二、可重复的排列']","{'实体类型': '概念', '定义': '在指定范围内满足给定条件、且允许多个相同对象同时出现的所有对象构成的总体', '特点': '重集中每个对象称为元素，相同元素的个数称为元素的重数'}",,4,"现考察这样一个问题：用1、2、3 这3 个数字可以构成多少种不同的5 位数字？  
使用乘法原理不难知道该问题解为$\ 13^{5}=243$种。这显然是一个元素可以重复的排列问题，现具体讨论这类问题。我们知道，在经典集合论中，集合中元素是不可重复的。为解决集合中重复元素的表示问题，现引入重集的概念。与集合的概念一样，重集也是一个没有具体定义的原始概念，只有通过如下方式对其含义进行描述或理解：  
所谓重集，就是在指定范围内满足给定条件、且允许多个相同对象同时出现的所有对象构成的总体，重集中每个对象仍然称为该集合的元素，重集中相同元素的个数称为元素的重数。具体地说，如果一个重集中含有 $\cdot_{n_{1}}$ 个 $\cdot a_{1}$ ， $n_{2}$ 个 $a_{2}$ ， ⋯ ， $n_{m}$ 个 $a_{m}$ ，且 $n_{1}+n_{2}+\cdots+n_{m}=$ $n$，则称该重集为含有$n$个元素的$m$元重集，记为：$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}.$。  
约定：$\infty\cdot a$表示元素$a$可在重集中出现任意多次；$\{\infty\cdot a_{1},\infty\cdot a_{2},\cdots,\infty\cdot a_{m}\}$则表示重集中所有元素均可出现任意多次，称其为无穷重$\pmb{m}$ 元重集。  
事实上，可将$m$ 元重集看成是由$m$ 个容器组成的容器组，其中第一个容器可以放入（或取出）$n_{1}$个元素$a_{1}$，第二个容器可以放入（或取出）$n_{2}$个元素$a_{2}$，…，第$m$个容器可以放入（或取出）$n_{m}$个元素$a_{m}$.对于$\infty\cdot a$，则可将其理解为可以放入（或取出）无穷多个元素$a$的容器.需要注意的是，通常认为重集不是集合，但可将集合看成是重集的特例。  
显然，用1、2、3 这个数字构成5 位数字，就是一个无穷重3 元重集中取出5 个元素的排列问题。一般地，这种重集排列问题或可重复排列问题的定义如下：  
【定义1.24】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的重集，从该重集中依次取出$r$ 个元素并将其按取出的次序排成一排，由此形成的一个有序排列称之为可重复$r$-排列，可重复$r\mathbf{\cdot}$-排列的个数称为可重复$r$-排列数；令$\cdot n_{1}+n_{2}+\cdots n_{m}=n$，则称$\cdot r=n$时构成的排列称为全排列，$r<n$时构成的排列为选排列。  
通过乘法原理不难得到如下无穷重$m$ 元重集的可重复$r\mathbf{\cdot}$-排列数计算公式  
【定理1.16】假设$\{\infty\cdot a_{1},\infty\cdot a_{2},\cdots,\infty\cdot a_{m}\}$是任意一个给定的无穷重$m$ 元重集，该重集下可重复$r$-排列数为$m^{r}$。  
【证明】无穷重数$m$ 元重集$\{\infty\cdot a_{1}$，$\infty\cdot a_{2}$，⋯，$\infty\cdot a_{m}\}$ $r$-排列的每一个位置上，均有$m$  种选择方案，故而 $r$ - 排列数为 $\ \ \cdot m^{r}$ 。□  
【例题1.57】（1）用7 颗六彩珠串成长链，可串出多少种不同长链（假定六彩珠取之不尽，且不考虑链子的反转）？（2）至少用两种颜色的六彩珠串成7 珠环链，求环链的种数（假定六彩的珠子取之不尽，且不考虑链子的反转）？  
![](images/3f1e76f81dba91759e05f5e7aace97377518f23c7e8ea20e34523f4359261b28.jpg)
图1-8 4-圆排列  
有穷集$m$ 元重集上可重复$r\mathbf{\cdot}$-排列数的计算是一个比较复杂的问题，有兴趣的同学可以查阅相关资料，不再赘述。在此仅考虑如下比较简单的全排列数的计算问题：  
【定理1.17】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的含有$n$ 个元素的有限$m$元重集，从该重集中依次取出$n$ 个元素的全排列数为：  
$$
\frac{n!}{n_{1}!\cdot n_{2}!\cdot\dots\cdot n_{m}!}
$$  
【例题1.58】EXCELLENT 单词含有9 个字母，若重新排序字母顺序，请问能构成多少个不同字符串？"
量词,概念,"['4.1.3  量词与特性谓词', '一、量词的概念', '一、含变量的语句', '4.1.2  命题函数与谓词', '三、特性谓词及其应用', '§ 4.1 个体词、谓词与量词', '4.1.1  逻辑与谓词逻辑', '第四章  谓词演算与推理']","{'实体类型': '概念', '定义': ['用于准确限定个体词含义的概念', '用于表示数量的词', '表示数量或范围的词', '实现对谓词中个体变量含义的约束', '能够对谓词中变量进行约束或限定的词', '用于限定个体变量的范围'], '作用': ['与谓词相结合实现对个体词含义的准确限定', '消除谓词在语义上的抽象性和不确定性'], '特点': '如“所有的”等，用于限定个体词的范围', '全称量化定义': '对于给定的谓词P(x)，若个体变量x在其个体域内的所有赋值都使得P(x)的取值为真，则称P(x)得到全称量化，记为：∀x P(x)', '存在量化定义': '对于给定的谓词P(x)，若个体变量x在其个体域内至少存在一个赋值都使得P(x)的谓词填式取值为真，则称P(x)得到存在量化，记为：∃x P(x)', '应用': '在谓词逻辑中确定个体域'}",,2,谓词逻辑的核心思想是将作为命题的陈述句分解成个体词与谓词这两个更为基本的要素。个体词表示各种具体或抽象的对象，相当于陈述句中的主语或宾语部分；谓词则表示对象的属性或对象之间的联系，相当于陈述句中的谓语部分。不同个体词会使命题产生不同含义以至于形成不同真值，同一个体词使用场合的不同也可能使命题的真值产生变化。为此，谓词逻辑引入量词概念，并通过将其与谓词相结合实现对个体词含义的准确限定。个体词、谓词和量词是谓词逻辑中最核心、最基本的概念，本节通过讨论这三个概念及其性质比较系统地介绍谓词逻辑中最基本的知识，包括谓词逻辑的由来、命题函数与谓词的概念、量词与特性谓词的概念、谓词逻辑的符号化等。
量词分配等值式,性质,"['第四章  谓词演算与推理', '§ 4.2  谓词公式与等值演算', '4.2.4 谓词公式的等值与蕴含', '一、谓词公式的等值关系']","{'实体类型': '性质', '定义': '∀x(P(x)∧Q(x))⇔∀xP(x)∧∀xQ(x); ∃x(P(x)∨Q(x))⇔∃xP(x)∨∃xQ(x)'}",,4,"谓词公式等值关系的含义与命题公式等值关系很类似，是指两个谓词公式在任意相同的解释下具有完全相同的真值，表达的是两个谓词公式之间的恒等关系。下面借助谓词公式的概念给出谓词公式等值关系的具体定义：  
【定义4.17】 假设$G$ 和$H$ 是任意两个给定的谓词公式，若公式$G\leftrightarrow H$是有效公式，则称公式$G$ 和$H$ 称为等值的，记为$G\Leftrightarrow H$，并称$G\Leftrightarrow H$为等值表达式或等值式。  
由上述定义可知，判断两个谓词公式$G$ 和$H$是否等值，关键在于证明谓词公式$G\leftrightarrow H$为有效公式，这种思路与证明命题公式等值关系的基本思路是一致的。类似于命题公式的等值演算系统，在谓词公式的等值演算系统中，通常也是先证明出一些重要的谓词公式等值式，然后将这些重要谓词等值式作为基本等值式进一步推演出更多的谓词公式等值式，这种推演过程构成了谓词公式等值演算的主要内容。下面不加证明地给出这些重要而基本的谓词公式等值式，读者可自行给出证明。  
第一组  命题公式中永真公式的谓词公式代换实例显然是有效谓词公式。因此，按命题逻辑中24 个基本等值式模式使用谓词公式代换出来的实例必定是谓词公式等值式。例如：  
$\forall x P(x)\Leftrightarrow\neg\neg\forall x P(x);\;\;\forall x\exists y\big(H(x,y)\to R(x,y)\big)\Leftrightarrow\neg\neg\forall x\exists y\big(H(x,y)\to R(x,y)\big)$ 等都是双重否定律的代换实例。再如：  
$$
\forall x(\ P(x)\rightarrow Q(y))\rightarrow\exists z H(z)\Leftrightarrow\lnot\forall x(\ P(x)\rightarrow Q(y))\lor\exists z H(z)
$$  
等都是蕴含等值式的代替实例。  
第二组  关于量词的若干等值式：  
（1）消去量词等值式：设个体域$D$ 为有限集$\{x_{0},x_{1},\cdots,x_{n}\ \}$，则有： $\forall x P(x)\Leftrightarrow P(x_{0})\land P(x_{1})\land\cdots\land P(x_{n});\ \ \exists x P(x)\Leftrightarrow P(x_{0})\lor P(x_{1})\lor\cdots\lor P(x_{n})$  
（2）量词否定等值式：对于含有量词的谓词式$\forall x P(x)$和$\exists x Q(x)$，有：$\lnot\forall x P(x)\Leftrightarrow\exists x\lnot P(x);\;\;\lnot\exists x Q(x)\Leftrightarrow\forall x\lnot Q(x)$  
（3）量词辖域的收缩与扩张等值式：  
$$
\forall x(P(x)\lor S)\Leftrightarrow\forall x P(x)\lor S;\;\;\forall x(P(x)\land S)\Leftrightarrow\forall x P(x)\land S;
$$  
$$
\exists x(P(x)\lor S)\Leftrightarrow\exists x P(x)\lor S;\ \exists x(P(x)\land S)\Leftrightarrow\exists x P(x)\land S;
$$  
$$
\forall x(P(x)\rightarrow S)\Leftrightarrow\exists x P(x)\rightarrow S;\quad\exists x(P(x)\rightarrow S)\Leftrightarrow\forall x P(x)\rightarrow S;
$$  
$$
\forall x(S\rightarrow P(x))\Leftrightarrow S\rightarrow\forall x P(x);\ \exists x(S\rightarrow P(x))\Leftrightarrow S\rightarrow\exists x P(x)\\,
$$  
(4）量词分配等值式  
$$
\forall x(P(x)\land Q(x))\Leftrightarrow\forall x P(x)\land\forall x Q(x);\ \exists x(P(x)\lor Q(x))\Leftrightarrow\exists x P(x)\lor\exists x Q(x);
$$  
上述基本的等值关系式很多可以互相推导。特别是当个体域为有限集时，很容易理解上述等值关系的合理性。  
例如，假设$P(x)$表示$x$ 今天上课，个体域为计算机学院全体学生的集合，则：  
$(\forall x)P(x)$表示今天所有学生都上课了；$\neg(\forall x)P(x)$表示今天不是所有学生上课了；$(\exists x)\lnot P(x)$表示今天有学生没上课。即有：$\lnot(\forall x)P(x)\Leftrightarrow(\exists x)\lnot P(x).$。  
$(\exists x)P(x)$表示今天有学生上课；$\neg(\exists x)P(x)$表示今天没有学生上课；$(\forall x)\neg P(x)$表示今天所有学生都没上课。即有：$\lnot(\exists x)P(x)\Leftrightarrow(\forall x)\lnot P(x)\,$。  
再如，假设谓词$G(x)$表示$x$ 勤奋学习，谓词$H(x)$表示$x$ 喜欢体育运动，个体域是某大学里的全体学生。则有：  
谓词公式$(\forall x)(G(x)\land H(x))$表示：“某大学里的所有学生既勤奋学习又喜欢体育运动”；谓词公式$(\forall x)G(x)\land(\forall x)H(x).$表示：“某大学里的所有学生都勤奋学习且大学里的所有学生都喜欢体育运动”。两者含义显然相同，即有$\forall x(G(x)\land H(x))\Leftrightarrow\forall x G(x)\land\forall x H(x)\,$。  
谓词公式 $(\exists x)(G(x)\lor H(x))$表示：“某大学里有些学生勤奋学习或喜欢体育运动”；谓词公式$(\exists x)G(x)\lor(\exists x)H(x)$表示：“某大学里有些学生勤奋学习或大学里有些学生喜欢体育运动”。两者的含义显然相同，即有$\exists x(G(x)\lor H(x))\Leftrightarrow\exists x G(x)\lor\exists x H(x)\,\mathrm{s}$。"
量词否定等值式,性质,"['第四章  谓词演算与推理', '§ 4.2  谓词公式与等值演算', '4.2.4 谓词公式的等值与蕴含', '一、谓词公式的等值关系']","{'实体类型': '性质', '定义': '对于含有量词的谓词式∀xP(x)和∃xQ(x)，有：¬∀xP(x)⇔∃x¬P(x); ¬∃xQ(x)⇔∀x¬Q(x)'}",,4,"谓词公式等值关系的含义与命题公式等值关系很类似，是指两个谓词公式在任意相同的解释下具有完全相同的真值，表达的是两个谓词公式之间的恒等关系。下面借助谓词公式的概念给出谓词公式等值关系的具体定义：  
【定义4.17】 假设$G$ 和$H$ 是任意两个给定的谓词公式，若公式$G\leftrightarrow H$是有效公式，则称公式$G$ 和$H$ 称为等值的，记为$G\Leftrightarrow H$，并称$G\Leftrightarrow H$为等值表达式或等值式。  
由上述定义可知，判断两个谓词公式$G$ 和$H$是否等值，关键在于证明谓词公式$G\leftrightarrow H$为有效公式，这种思路与证明命题公式等值关系的基本思路是一致的。类似于命题公式的等值演算系统，在谓词公式的等值演算系统中，通常也是先证明出一些重要的谓词公式等值式，然后将这些重要谓词等值式作为基本等值式进一步推演出更多的谓词公式等值式，这种推演过程构成了谓词公式等值演算的主要内容。下面不加证明地给出这些重要而基本的谓词公式等值式，读者可自行给出证明。  
第一组  命题公式中永真公式的谓词公式代换实例显然是有效谓词公式。因此，按命题逻辑中24 个基本等值式模式使用谓词公式代换出来的实例必定是谓词公式等值式。例如：  
$\forall x P(x)\Leftrightarrow\neg\neg\forall x P(x);\;\;\forall x\exists y\big(H(x,y)\to R(x,y)\big)\Leftrightarrow\neg\neg\forall x\exists y\big(H(x,y)\to R(x,y)\big)$ 等都是双重否定律的代换实例。再如：  
$$
\forall x(\ P(x)\rightarrow Q(y))\rightarrow\exists z H(z)\Leftrightarrow\lnot\forall x(\ P(x)\rightarrow Q(y))\lor\exists z H(z)
$$  
等都是蕴含等值式的代替实例。  
第二组  关于量词的若干等值式：  
（1）消去量词等值式：设个体域$D$ 为有限集$\{x_{0},x_{1},\cdots,x_{n}\ \}$，则有： $\forall x P(x)\Leftrightarrow P(x_{0})\land P(x_{1})\land\cdots\land P(x_{n});\ \ \exists x P(x)\Leftrightarrow P(x_{0})\lor P(x_{1})\lor\cdots\lor P(x_{n})$  
（2）量词否定等值式：对于含有量词的谓词式$\forall x P(x)$和$\exists x Q(x)$，有：$\lnot\forall x P(x)\Leftrightarrow\exists x\lnot P(x);\;\;\lnot\exists x Q(x)\Leftrightarrow\forall x\lnot Q(x)$  
（3）量词辖域的收缩与扩张等值式：  
$$
\forall x(P(x)\lor S)\Leftrightarrow\forall x P(x)\lor S;\;\;\forall x(P(x)\land S)\Leftrightarrow\forall x P(x)\land S;
$$  
$$
\exists x(P(x)\lor S)\Leftrightarrow\exists x P(x)\lor S;\ \exists x(P(x)\land S)\Leftrightarrow\exists x P(x)\land S;
$$  
$$
\forall x(P(x)\rightarrow S)\Leftrightarrow\exists x P(x)\rightarrow S;\quad\exists x(P(x)\rightarrow S)\Leftrightarrow\forall x P(x)\rightarrow S;
$$  
$$
\forall x(S\rightarrow P(x))\Leftrightarrow S\rightarrow\forall x P(x);\ \exists x(S\rightarrow P(x))\Leftrightarrow S\rightarrow\exists x P(x)\\,
$$  
(4）量词分配等值式  
$$
\forall x(P(x)\land Q(x))\Leftrightarrow\forall x P(x)\land\forall x Q(x);\ \exists x(P(x)\lor Q(x))\Leftrightarrow\exists x P(x)\lor\exists x Q(x);
$$  
上述基本的等值关系式很多可以互相推导。特别是当个体域为有限集时，很容易理解上述等值关系的合理性。  
例如，假设$P(x)$表示$x$ 今天上课，个体域为计算机学院全体学生的集合，则：  
$(\forall x)P(x)$表示今天所有学生都上课了；$\neg(\forall x)P(x)$表示今天不是所有学生上课了；$(\exists x)\lnot P(x)$表示今天有学生没上课。即有：$\lnot(\forall x)P(x)\Leftrightarrow(\exists x)\lnot P(x).$。  
$(\exists x)P(x)$表示今天有学生上课；$\neg(\exists x)P(x)$表示今天没有学生上课；$(\forall x)\neg P(x)$表示今天所有学生都没上课。即有：$\lnot(\exists x)P(x)\Leftrightarrow(\forall x)\lnot P(x)\,$。  
再如，假设谓词$G(x)$表示$x$ 勤奋学习，谓词$H(x)$表示$x$ 喜欢体育运动，个体域是某大学里的全体学生。则有：  
谓词公式$(\forall x)(G(x)\land H(x))$表示：“某大学里的所有学生既勤奋学习又喜欢体育运动”；谓词公式$(\forall x)G(x)\land(\forall x)H(x).$表示：“某大学里的所有学生都勤奋学习且大学里的所有学生都喜欢体育运动”。两者含义显然相同，即有$\forall x(G(x)\land H(x))\Leftrightarrow\forall x G(x)\land\forall x H(x)\,$。  
谓词公式 $(\exists x)(G(x)\lor H(x))$表示：“某大学里有些学生勤奋学习或喜欢体育运动”；谓词公式$(\exists x)G(x)\lor(\exists x)H(x)$表示：“某大学里有些学生勤奋学习或大学里有些学生喜欢体育运动”。两者的含义显然相同，即有$\exists x(G(x)\lor H(x))\Leftrightarrow\exists x G(x)\lor\exists x H(x)\,\mathrm{s}$。"
量词德摩根律,定理,"['第四章  谓词演算与推理', '§ 4.1 个体词、谓词与量词', '4.1.3  量词与特性谓词', '二、量词的展开与否定']","{'实体类型': '定理', '定义': '全称量词的否定转换为存在量词，存在量词的否定转换为全称量词', '规则': '对于含有量词的谓词式，其否定式的量词转换规则为：¬∀x P(x)↔∃x ¬P(x)；¬∃x Q(x)↔∀x ¬Q(x)'}",,4,"假设$P(x)$是关于个体变量$x$的一元谓词，$D$ 是$x$ 的个体域，现讨论全称量词的性质：  
由全称量词定义可知，$\forall x P(x)$表示这样的一个命题：“对于$D$ 中任意一个个体$x$，$P(x)$均为真”。因此，$\forall x P(x)$作为一个具体命题，其真值应按如下方式确定：  
$\forall x P(x)$取值为真，当且仅当对于$D$ 中任意一个个体$x$，都使得$P(x)$的取值均为真；  
$\forall x P(x)$取值为假，当且仅当$D$ 中至少存在一个个体$x_{0}$，使得$P(x_{0})$的取值为假。  
即有：
$$
\forall x P(x)=\left\{\!\!\begin{array}{l l}{1,\,\,\forall x\in D,\,\,\,\,\,\,\,\,\,P(x)=1}\\ {0,\,\,\exists x_{0}\in D,\,\,\,P(x_{0})=0}\end{array}\right.\tag{4-1}
$$  
下面讨论存在量词的性质，由存在量词定义可知，$\exists x P(x)$表示这样的一个命题：$^{\cdot}\!D$中至少一个个体$x_{0}$，使得$P(x_{0})$的取值为真”。因此，$\exists x P(x)$作为一个具体命题，其真值应按如下方式确定：  
$\exists x P(x)$取值为真，当且仅当$D$ 中至少存在一个个体$x_{0}$，使得$P(x_{0})$的取值为真；  
$\exists x P(x)$取值为假，当且仅当对于$D$ 中任意一个个体$x$，都使得 $P(x)$的取值为假。  
即有：
$$
\exists x P(x)=\left\{\!\!\begin{array}{l l}{1,\ \exists x_{0}\in D,\quad\quad P(x_{0})=1}\\ {0,\ \forall x\in D,\quad\quad\quad P(x)=0}\end{array}\!\!\right.\tag{4-2}
$$  
当$D$ 为有限集$\{x_{0},x_{1},\cdots,x_{n}\}$时$\forall x P(x)$和$\exists x P(x)$的可分别用如下与之等价的命题逻辑运算表示：  
$$
\forall x P(x)\Leftrightarrow P(x_{0})\land P(x_{1})\land\cdots\land P(x_{n})\tag{4-3}
$$  
$$
\exists x P(x)\Leftrightarrow P(x_{0})\lor P(x_{1})\lor\cdots\lor P(x_{n})\tag{4-4}
$$  
上式为量词的展开式，可根据实际问题需使用上式添加或消除量词。  
由以上讨论分析可知，对于一个$_{n}$元谓词，如果其中每个变量都分别受到量词约束，那么它就不再是一个命题函数，而是蜕化为一个具体的命题。但是，这些由$n$元谓词蜕化而来命题与命题逻辑中的命题还是有所不同。因为这些命题里含有变量，但这些变量与命题函数中的变量也有所不同。我们将在后续相关部分对此做进一步分析讨论。  
有时需要对量词含义进行否定。例如，对命题“每个老虎都吃人”的否定，就是命题“不是每个老虎都吃人”或者“至少存在一个老虎不吃人”；对命题“至少有一个人登上过月球”的否定，就是命题“所有人都没有登上过月球”。  
由此可见，全称量词否定就变成存在量词，存在量词否定就变成全称量词。这种量词否定的转换规则称为量词德摩根律。具体地说，对于含有量词的谓词式$\forall x P(x)$和$\exists x Q(x)$，其否定式的量词德摩根转换规则如下：  
$$
\lnot\forall x P(x)\Leftrightarrow\exists x\lnot P(x);\;\;\lnot\exists x Q(x)\Leftrightarrow\forall x\lnot Q(x)
$$  
量词德摩根律的具体逻辑含义由如表4-1 所示：  
表4-1 量词的德摩根律
![](images/2e2c83ee13b235854c72d43e04351502ef18cc9745bc1007f7d5f66d67c0c3ec.jpg)  
当个体变量$x$ 的个体域$D$ 为有限集$\{x_{0},x_{1},\cdots,x_{n}$}时，显然有：  
$$
\lnot\forall x P(x)\Leftrightarrow\lnot P(x_{0})\lor\lnot P(x_{1})\lor\cdots\lor\lnot P(x_{n})
$$  
$$
\lnot\exists x Q(x)\Leftrightarrow\lnot Q(x_{0})\land\lnot Q(x_{1})\land\cdots\land\lnot Q(x_{n})
$$"
量词的展开,原理,"['第四章  谓词演算与推理', '§ 4.1 个体词、谓词与量词', '4.1.3  量词与特性谓词', '二、量词的展开与否定']","{'实体类型': '原理', '定义': '将量词表示的命题转换为等价的命题逻辑运算', '应用': '根据实际问题需要添加或消除量词'}",,4,"假设$P(x)$是关于个体变量$x$的一元谓词，$D$ 是$x$ 的个体域，现讨论全称量词的性质：  
由全称量词定义可知，$\forall x P(x)$表示这样的一个命题：“对于$D$ 中任意一个个体$x$，$P(x)$均为真”。因此，$\forall x P(x)$作为一个具体命题，其真值应按如下方式确定：  
$\forall x P(x)$取值为真，当且仅当对于$D$ 中任意一个个体$x$，都使得$P(x)$的取值均为真；  
$\forall x P(x)$取值为假，当且仅当$D$ 中至少存在一个个体$x_{0}$，使得$P(x_{0})$的取值为假。  
即有：
$$
\forall x P(x)=\left\{\!\!\begin{array}{l l}{1,\,\,\forall x\in D,\,\,\,\,\,\,\,\,\,P(x)=1}\\ {0,\,\,\exists x_{0}\in D,\,\,\,P(x_{0})=0}\end{array}\right.\tag{4-1}
$$  
下面讨论存在量词的性质，由存在量词定义可知，$\exists x P(x)$表示这样的一个命题：$^{\cdot}\!D$中至少一个个体$x_{0}$，使得$P(x_{0})$的取值为真”。因此，$\exists x P(x)$作为一个具体命题，其真值应按如下方式确定：  
$\exists x P(x)$取值为真，当且仅当$D$ 中至少存在一个个体$x_{0}$，使得$P(x_{0})$的取值为真；  
$\exists x P(x)$取值为假，当且仅当对于$D$ 中任意一个个体$x$，都使得 $P(x)$的取值为假。  
即有：
$$
\exists x P(x)=\left\{\!\!\begin{array}{l l}{1,\ \exists x_{0}\in D,\quad\quad P(x_{0})=1}\\ {0,\ \forall x\in D,\quad\quad\quad P(x)=0}\end{array}\!\!\right.\tag{4-2}
$$  
当$D$ 为有限集$\{x_{0},x_{1},\cdots,x_{n}\}$时$\forall x P(x)$和$\exists x P(x)$的可分别用如下与之等价的命题逻辑运算表示：  
$$
\forall x P(x)\Leftrightarrow P(x_{0})\land P(x_{1})\land\cdots\land P(x_{n})\tag{4-3}
$$  
$$
\exists x P(x)\Leftrightarrow P(x_{0})\lor P(x_{1})\lor\cdots\lor P(x_{n})\tag{4-4}
$$  
上式为量词的展开式，可根据实际问题需使用上式添加或消除量词。  
由以上讨论分析可知，对于一个$_{n}$元谓词，如果其中每个变量都分别受到量词约束，那么它就不再是一个命题函数，而是蜕化为一个具体的命题。但是，这些由$n$元谓词蜕化而来命题与命题逻辑中的命题还是有所不同。因为这些命题里含有变量，但这些变量与命题函数中的变量也有所不同。我们将在后续相关部分对此做进一步分析讨论。  
有时需要对量词含义进行否定。例如，对命题“每个老虎都吃人”的否定，就是命题“不是每个老虎都吃人”或者“至少存在一个老虎不吃人”；对命题“至少有一个人登上过月球”的否定，就是命题“所有人都没有登上过月球”。  
由此可见，全称量词否定就变成存在量词，存在量词否定就变成全称量词。这种量词否定的转换规则称为量词德摩根律。具体地说，对于含有量词的谓词式$\forall x P(x)$和$\exists x Q(x)$，其否定式的量词德摩根转换规则如下：  
$$
\lnot\forall x P(x)\Leftrightarrow\exists x\lnot P(x);\;\;\lnot\exists x Q(x)\Leftrightarrow\forall x\lnot Q(x)
$$  
量词德摩根律的具体逻辑含义由如表4-1 所示：  
表4-1 量词的德摩根律
![](images/2e2c83ee13b235854c72d43e04351502ef18cc9745bc1007f7d5f66d67c0c3ec.jpg)  
当个体变量$x$ 的个体域$D$ 为有限集$\{x_{0},x_{1},\cdots,x_{n}$}时，显然有：  
$$
\lnot\forall x P(x)\Leftrightarrow\lnot P(x_{0})\lor\lnot P(x_{1})\lor\cdots\lor\lnot P(x_{n})
$$  
$$
\lnot\exists x Q(x)\Leftrightarrow\lnot Q(x_{0})\land\lnot Q(x_{1})\land\cdots\land\lnot Q(x_{n})
$$"
量词辖域,定义,"['第四章  谓词演算与推理', '§ 4.2  谓词公式与等值演算', '4.2.2 变量的自由与约束']","{'实体类型': '定义', '内容': '量词作用变量在谓词公式中存在的范围'}",,3,"如前所述，量词实现了对谓词中个体变量含义的约束，消除了谓词在语义上的抽象性和不确定性，对于一个$\cdot n$元谓词，如果其中每个变量都分别受到量词的约束，那么它就不再是一个命题函数而蜕化一个具体命题。因此，对于任意一个$\cdot n$元谓词，可将其中所以命题变量分为两种具体不同性质的基本类型：一种是受到量词约束的命题变量，其含义是明确具体的，不再具有自由诠释的性质；另外一种是没有受到量词约束的命题变量，是传统意义上的命题变量，其含义是泛指某个不确定的个体对象，具有自由诠释的性质。这两种变量在谓词公式及谓词演算中扮演着完全不同的角色，在具体的表示形式上必须有明确的区分。本节主要介绍具体的区分方法，首先给出量词辖域的相关概念。  
【定义4.12】假设$G(x)$是任意一个含有命题变量$x$的谓词，在公式$(\forall x)G(x)$或$(\exists x)G(x)$中，$(\forall x)$或$(\exists x)$的作用变量$x$ 在$G(x)$中存在的范围称为量词$(\forall x)$或$(\exists x)$的辖域。如果辖域不是原子谓词公式，其两侧必须有括号，否则不应有括号。  
例如：在谓词公式$\exists x(P(x,y)\rightarrow Q(x,y))\vee P(y,z)$中，$\exists x$的辖域是$(P(x,y)\to Q(x,y))$  
在谓词公式$\forall x P(x)\rightarrow Q(x)$中，$\forall x$的辖域是$P(x)$。  
一般来说，一个量词的辖域是某个谓词公式的子公式。因此，确定一个量词的辖域就是要找出位于该量词之后与之相邻接的子公式，具体方法如下：  
（1）若量词后面有括弧，则括弧内的子公式就是该量词的辖域；  
（2）若量词后面无括弧，则与该量词邻接的子公式为该量词的辖域。  
下面在量词辖域的基础上给出自由变量和约束变量的定义：  
【定义4.13】假设𝐺是任一谓词公式，$x$是𝐺的任意一个命题变量，如果$x$出现在以它为作用变量的量词辖域之内，则称$x$的出现为约束出现，称变量$x$为约束变量；如果$x$不是约束出现，则称其为自由出现，此时称$x$为自由变量。  
从上述定义不难看出，所谓约束变量，就是其含义受到量词约束的命题变量。约束变量的含义是明确具体的，不再具有自由诠释的性质。自由变量则是含义没有受到量词约束的命题变量，是传统意义上的命题变量，可以对其含义进行自由诠释。  
如果谓词公式中所有命题变量都受到量词约束，则称其为封闭公式，具体定义如下：  
【定义4.14】若谓词公式$G$ 中不含自由变量，则称该公式为封闭公式或闭式。  
例如，$(\forall x)(P(x)\rightarrow(\exists y)R(x,y))$就是一个闭式。显然，要想使得含有$n$个自由变量的谓词公式变成闭式，需要添加$|n$个量词。  
从上述例题不难看出，有时候在同一个谓词公式中同一个命题变量既可以约束出现也可以自由出现，例如对于如下谓词公式：  
$(\forall x)(P(x)\rightarrow R(x))\land(\exists y)Q(x,y)$  
该式中个体变量$\cdot x$既是约束变量又是自由变量。这很容易引起在概念理解上的歧义或混乱，需要通过一些方法对这种变量进行换名，使得同一个个体变量在同一个谓词公式中要么自由出现，要么约束出现，不能兼而有之，避免个体变量在概念理解上的歧义或混乱。下面介绍具体的个体变量改名方法。  
对于任意一个含有量词的谓词公式，以约束方式出现的个体变量到底用哪一个字母表示其实是无关紧要的。事实上，用其它任意字母表示这个约束变量都不会改变谓词公式的含义。由此可得如下约束变量的换名规则：  
（1）将量词中出现的变量以及该量词辖域中此变量的所有约束出现都替换为新的变量；  
（2）新变量名一定要有别于辖域中的所有其它变量名。  
为使一个个体变量在同一个谓词公式中只以一种方式出现，还可以使用一定的规则实现对自由变量换名。该规则称为自由变量的代入规则，具体内容如下：  
（1）将公式中出现该自由变量的每一处都用新的变量替换；  
（2）新变量不允许在原公式中以任何约束形式出现。"
量词辖域的收缩与扩张等值式,性质,"['第四章  谓词演算与推理', '§ 4.2  谓词公式与等值演算', '4.2.4 谓词公式的等值与蕴含', '一、谓词公式的等值关系']","{'实体类型': '性质', '定义': '包括多个具体的等值式，如∀x(P(x)∨S)⇔∀xP(x)∨S; ∃x(P(x)∨S)⇔∃xP(x)∨S等'}",,4,"谓词公式等值关系的含义与命题公式等值关系很类似，是指两个谓词公式在任意相同的解释下具有完全相同的真值，表达的是两个谓词公式之间的恒等关系。下面借助谓词公式的概念给出谓词公式等值关系的具体定义：  
【定义4.17】 假设$G$ 和$H$ 是任意两个给定的谓词公式，若公式$G\leftrightarrow H$是有效公式，则称公式$G$ 和$H$ 称为等值的，记为$G\Leftrightarrow H$，并称$G\Leftrightarrow H$为等值表达式或等值式。  
由上述定义可知，判断两个谓词公式$G$ 和$H$是否等值，关键在于证明谓词公式$G\leftrightarrow H$为有效公式，这种思路与证明命题公式等值关系的基本思路是一致的。类似于命题公式的等值演算系统，在谓词公式的等值演算系统中，通常也是先证明出一些重要的谓词公式等值式，然后将这些重要谓词等值式作为基本等值式进一步推演出更多的谓词公式等值式，这种推演过程构成了谓词公式等值演算的主要内容。下面不加证明地给出这些重要而基本的谓词公式等值式，读者可自行给出证明。  
第一组  命题公式中永真公式的谓词公式代换实例显然是有效谓词公式。因此，按命题逻辑中24 个基本等值式模式使用谓词公式代换出来的实例必定是谓词公式等值式。例如：  
$\forall x P(x)\Leftrightarrow\neg\neg\forall x P(x);\;\;\forall x\exists y\big(H(x,y)\to R(x,y)\big)\Leftrightarrow\neg\neg\forall x\exists y\big(H(x,y)\to R(x,y)\big)$ 等都是双重否定律的代换实例。再如：  
$$
\forall x(\ P(x)\rightarrow Q(y))\rightarrow\exists z H(z)\Leftrightarrow\lnot\forall x(\ P(x)\rightarrow Q(y))\lor\exists z H(z)
$$  
等都是蕴含等值式的代替实例。  
第二组  关于量词的若干等值式：  
（1）消去量词等值式：设个体域$D$ 为有限集$\{x_{0},x_{1},\cdots,x_{n}\ \}$，则有： $\forall x P(x)\Leftrightarrow P(x_{0})\land P(x_{1})\land\cdots\land P(x_{n});\ \ \exists x P(x)\Leftrightarrow P(x_{0})\lor P(x_{1})\lor\cdots\lor P(x_{n})$  
（2）量词否定等值式：对于含有量词的谓词式$\forall x P(x)$和$\exists x Q(x)$，有：$\lnot\forall x P(x)\Leftrightarrow\exists x\lnot P(x);\;\;\lnot\exists x Q(x)\Leftrightarrow\forall x\lnot Q(x)$  
（3）量词辖域的收缩与扩张等值式：  
$$
\forall x(P(x)\lor S)\Leftrightarrow\forall x P(x)\lor S;\;\;\forall x(P(x)\land S)\Leftrightarrow\forall x P(x)\land S;
$$  
$$
\exists x(P(x)\lor S)\Leftrightarrow\exists x P(x)\lor S;\ \exists x(P(x)\land S)\Leftrightarrow\exists x P(x)\land S;
$$  
$$
\forall x(P(x)\rightarrow S)\Leftrightarrow\exists x P(x)\rightarrow S;\quad\exists x(P(x)\rightarrow S)\Leftrightarrow\forall x P(x)\rightarrow S;
$$  
$$
\forall x(S\rightarrow P(x))\Leftrightarrow S\rightarrow\forall x P(x);\ \exists x(S\rightarrow P(x))\Leftrightarrow S\rightarrow\exists x P(x)\\,
$$  
(4）量词分配等值式  
$$
\forall x(P(x)\land Q(x))\Leftrightarrow\forall x P(x)\land\forall x Q(x);\ \exists x(P(x)\lor Q(x))\Leftrightarrow\exists x P(x)\lor\exists x Q(x);
$$  
上述基本的等值关系式很多可以互相推导。特别是当个体域为有限集时，很容易理解上述等值关系的合理性。  
例如，假设$P(x)$表示$x$ 今天上课，个体域为计算机学院全体学生的集合，则：  
$(\forall x)P(x)$表示今天所有学生都上课了；$\neg(\forall x)P(x)$表示今天不是所有学生上课了；$(\exists x)\lnot P(x)$表示今天有学生没上课。即有：$\lnot(\forall x)P(x)\Leftrightarrow(\exists x)\lnot P(x).$。  
$(\exists x)P(x)$表示今天有学生上课；$\neg(\exists x)P(x)$表示今天没有学生上课；$(\forall x)\neg P(x)$表示今天所有学生都没上课。即有：$\lnot(\exists x)P(x)\Leftrightarrow(\forall x)\lnot P(x)\,$。  
再如，假设谓词$G(x)$表示$x$ 勤奋学习，谓词$H(x)$表示$x$ 喜欢体育运动，个体域是某大学里的全体学生。则有：  
谓词公式$(\forall x)(G(x)\land H(x))$表示：“某大学里的所有学生既勤奋学习又喜欢体育运动”；谓词公式$(\forall x)G(x)\land(\forall x)H(x).$表示：“某大学里的所有学生都勤奋学习且大学里的所有学生都喜欢体育运动”。两者含义显然相同，即有$\forall x(G(x)\land H(x))\Leftrightarrow\forall x G(x)\land\forall x H(x)\,$。  
谓词公式 $(\exists x)(G(x)\lor H(x))$表示：“某大学里有些学生勤奋学习或喜欢体育运动”；谓词公式$(\exists x)G(x)\lor(\exists x)H(x)$表示：“某大学里有些学生勤奋学习或大学里有些学生喜欢体育运动”。两者的含义显然相同，即有$\exists x(G(x)\lor H(x))\Leftrightarrow\exists x G(x)\lor\exists x H(x)\,\mathrm{s}$。"
链,概念,"['第六章 特殊关系模型', '§ 6.3 偏序关系与元素比较', '6.3.3  全序与良序']","{'实体类型': '概念', '定义': '偏序集的子集，其中任意两个元素都是可比的', '特点': '表达了一种串行执行结构'}",,3,"前述集合$𝐴$上偏序关系并不保证$𝐴$上的任何两个元素之间都是可比的，也是就是说并不保证任何两个元素之间都存在序关系。然而，在很多场合我们都需要对所关心的所有对象排个次序，例如体育比赛中的种子选手排名、全国各高校的综合排名、大会嘉宾代表的入场次序等等，都需要对所有对象进行排序。现有偏序关系模型显然不能正确表示和处理这类问题。故须加强偏序关系约束条件，在偏序关系基础上引入全序关系，其具体定义如下：  
【定义6.14】对于偏序集$\langle A,\preccurlyeq\rangle$，如果$𝐴$中任意两个元素${x}$和$\boldsymbol{y}$都是可比的，即$x\preccurlyeq y$或者$y\preccurlyeq x$，则称该偏序关系为全序关系或线序关系，简称为全序或线序。并称$\langle A,\preccurlyeq\rangle$为全序集或线序集，也可称为集合$𝐴$的链。  
由上述定义可知，全序关系必定是偏序关系，偏序关系则不一定是全序关系。  
可用全序的概念定义偏序集$\langle A,\preccurlyeq\rangle$的一些特殊子集合，具体定义如下：  
【定义6.15】设$\langle A,\preccurlyeq\rangle$是一个偏序集，$B$是$𝐴$的任一子集，如果$𝐵$中任意两个元素都是可比的，则称$B$是$𝐴$的一条链，$B$中元素的个数称为该链的长度；反之，如果$B$中任意两个元素都是不可比的，则称 $B$是$𝐴$的一条反链，$B$中元素的个数称为该反链的长度。对于$𝐴$中由单个元素组成的集合，规定它既是链也是反链。  
例如，在偏序集〈{1,2,3,4,5,6,7,8,9}, |〉中，{1,2,4,8}是一条长度为4 的链，{2,4}是一条长度为2 的链，{2,3}则是一条长度为2 的反链。  
偏序集中的链表达了偏序集中部分元素之间存在全序关系，反链则表达了偏序集中部分元素相互之间不存在任何序关系。显然，链表达的是一种串行执行结构，反链表达的是一种并行执行结构。因此，可以使用偏序集中链和反链的概念优化实际问题求解的业务流程，有效提高问题求解的工作效率。  
![](images/18f7caa4d0b707d1ff49eb6f7a547c82b50926bf7ba3ab409aa786a7fcff2f4c.jpg)
图6-22 保险索赔业务流程  
例如，图6-22 是一个关于保险索赔的流程图。图中方框代表处理流程中业务，圆圈代表某种分支选择。将流程中循环抽象成一个单一的结点，如用单个结点𝑇代替流程图中业务$T_{7}$、$T_{8}$及其后的分支结点。由此得到的所有结点构成集合$𝐴$，在该集合元素之间定义如下偏序关系≼：对$\forall x,y\in A$，当且仅当$x=y$或者$𝑦$必须在$x$完成后才能开始时，成立$x\preccurlyeq y$。如此，集合$𝐴$与其上的偏序关系$\preccurlyeq$便构成一个偏序集$\langle A,\preccurlyeq\rangle$，  
图6.23 为其哈斯图。  
考虑偏序集中的链，最长链有4 条，其中2 条分别是：  
$\{T_1,T_2,T_3,S_1,T_6,,S_2,T,T_{10}\}; \{T_1,T_2,T_3,S_1,T_6,,S_2,T_9,T_{10}\}$  
长度都是8。显然，最长链的长度代表了整个流程中必须顺序执行的任务最多有多少个。如果完成每项任务的时间差距不大，那么这种最长链就反映了完成整个任务的最少时间。  
![](images/598fd43b47030dd50e3aa3bc789da0841fc0eb2b823d2c8cd7d0b88fecfb1eab.jpg)
图6-23 业务关系哈斯图  
并行执行业务是提供效率的一种有效途径。在一个偏序集中，如果能够将业务按照不相交的链进行分解，那么这些不相交的链就可在一定程度上并行执行。另一方面，如果把偏序集分解成不相交的反链，那么最长的反链长度则代表了在某个时间区间极大可并行的任务数。下面定理刻画了偏序集的分解与反链之间的关系：  
【定义6.16】设$\langle A,\preccurlyeq\rangle$为偏序集，如果$𝐴$中最长的链长度为$n$，则该偏序集可以分解为$𝑛$条不相交的反链。  
我们知道，对于一个偏序集合$\langle A,\preccurlyeq\rangle$，其任何子集${B}$上的最大值和最小值不一定存在或者不一定都存在。如果我们把偏序集合$\langle A,\preccurlyeq\rangle$的约束条件加强，要求$𝐴$的任何子集$𝐵$上的必须存在最小值，则得到如下良序关系的概念：  
【定义6.17】对于偏序集$\langle A,\preccurlyeq\rangle$，如果$𝐴$的任意一个非空子集$B$中都含有最小元素，则称该偏序关系为良序关系，简称为良序。称$\langle A,\preccurlyeq\rangle$为良序集。  
由上述定义可知，良序关系一定是偏序关系和全序关系，但偏序关系和全序关系不一定是良序关系。例如，实数集合上的小于等于关系显然是全序关系，但不是良序关系，因为开区间(0,1)没有最小值。不过有限的全序集一定是良序集。对于任何一个有限偏序集，可以通过适当排序将其改造成为一个全序集，从而使其成为良序集。"
间接证明法,算法,"['第三章  命题演算与推理', '§ 3.5 命题逻辑的演绎推理', '3.5.3 命题推证的基本策略', '三、间接证明法']","{'实体类型': '算法', '定义': '使用P规则、T规则、反证法或CP规则的推理方法', '应用': '推导过程中利用矛盾式的概念，常被称为反证法'}",,4,"间接证明法不仅使用$P$规则，$T$规则，还使用反证法或$C P$规则的推理方法。在引入间接证明法之前，首先给出公式组相容概念：  
【定义3.30】假设$G_{1},G_{2},\cdots,G_{n}$是一组命题公式，$P_{1},P_{2},\cdots,P_{n}$是出现在$G_{1},G_{2},\cdots,G_{n}$中的一切命题变元，若有解释I使$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}$取值为“真”，则称公式$G_{1},G_{2},\cdots,G_{n}$是一致的或相容的，否则称公式$G_{1},G_{2},\cdots,G_{n}$为不一致的，或者说$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}$是一个矛盾式。  
利用矛盾式的概念，可以给出一种推导过程，这个过程通常称为矛盾法或间接证明法，常被称为反证法。下面给出反证法的证明。  
【定理3.15】如果命题公式集合$\{G_{1},G_{2},\cdots,G_{n}\}$是相容的，那么从前提集合$\{G_{1},G_{2},\cdots,G_{n}\}$可以逻辑推出公式$\cdot H$，即$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\Rightarrow H$，的充要条件是从前提集合$\{G_{1},G_{2},\cdots,G_{n},\lnot H\}$出发，可以逻辑推出一个矛盾（永假）式来，即$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\wedge\neg H\Rightarrow F_{\circ}$。"
限制性命题公式,概念,"['第三章  命题演算与推理', '§ 3.2 命题公式与等值演算', '3.2.3 公式的内否与对偶']","{'实体类型': '概念', '定义': '仅出现命题变量、命题常量，以及命题联结词“否定”、“合取”、“析取”的命题公式'}",,3,"前面学习了 “否定”、 “合取”、 “析取”、 “蕴涵”和“等价”这五个常用命题联结词，其中最常用的是“否定”、 “合取”、 “析取”这三个联结词。事实上，后面将会证明仅使用这三个最常用联结词就可以任意的命题公式。本小节主要考察仅由这三个联结词构成的命题公式，首先给出如下限制性命题公式的定义：  
【定义3.14】如果一个命题公式$G$中仅出现命题变量、命题常量，以及命题联结词“$\neg$”、“ $\wedge$“、”$\lor$“，则称$G$为限制性命题公式。  
例如公式$\neg Q\lor R\,\lor\,\neg(P\lor Q)\lor(Q\lor P)\,\lor\,G\lor(H\land S)$都是限制性命题公式。  
限制性命题公式中只有“$\neg$”、“ $\wedge$“、”$\lor$“这三种运算，其中”$\neg$”为一元运算，“ $\wedge$“和“$\lor$”均为二元运算。对于任意一个限制性命题公式，可以使用规律性修改其运算联结词的方式构造出与之相对应的新的命题公式。例如，对于“$\neg$”运算，可将命题公式中所有变量取反，即由$P$ 换成$\neg\mathrm{P}$，便可得到一个新的公式。由此得到如下内否公式的定义：  
【定义3.15】设$G\Leftrightarrow G(P_{1},P_{2},\cdots P_{n})$是任一限制性命题公式，$P_{1},P_{2},\cdots P_{n}$是其所有命题变量，则称$G(\neg P_{1},\neg P_{2},\cdots\neg P_{n})$是$G(P_{1},P_{2},\cdots P_{n})$的内否公式，记为$G^{\neg}$。  
例如：若 $G=\ \lnot P\lor Q$，则$G^{\neg}=P\lor\neg Q$。  
不难看出，$\wedge$和$\lor$运算具有一定的对等性。也就是说 $\wedge$运算具有的性质，$\lor$运算也都有，反之亦然。因此，对于任意一个限制性命题公式，可将其中 $\wedge$换成$\lor$、$\lor$换成$\wedge$、$T$换成$F$、$F$换成$T$，则可得到一个与之相关的新公式。由此得到如下命题公式对偶式的概念：  
【定义3.16】对于任意一个限制性命题公式$G$，将其中 $\wedge$换成$\lor$、$\vee$换成 $\wedge$、$T$换成$F$、$F$换成$T$，得到的新公式称为$G$的对偶式，记为$G^{*}$。  
例如：
$$
(1)G\Leftrightarrow(P\land F);\quad G^{*}=P\lor T_{\circ}\;\;(\,2\,)\;\;G\Leftrightarrow(P\lor Q)\land R;\;\;G^{*}\Leftrightarrow(P\land Q)\lor R\,_{\circ}
$$  
下面两个定理分别给出了内否式和对偶式的基本性质于基本关系：  
【定理3.5】假设$G$和$H$都是限制性命题公式，则成立下列等值式：  
$\begin{aligned}&(1) (G^{*})^{*}\Leftrightarrow G, (G^{\neg})^{\neg}\Leftrightarrow G; (2) (G\vee H)^{*}\Leftrightarrow G^{*}\wedge H^{*}; (G\vee H)^{\neg}\Leftrightarrow G^{\neg}\vee H^{\neg};\\&(3) (G\wedge H)^{*}\Leftrightarrow G^{*}\vee H^{*}; (G\wedge H)^{\neg}\Leftrightarrow G^{\neg}\wedge H^{\neg}。\end{aligned}$  
【定理3.6】设$G$和$G^{*}$互为对偶式，$P_{1},P_{2},\cdots P_{n}$是出现在$G$和$G^{*}$中的全部命题变项，将$G$和$G^{*}$写成$\mathsf{n}$ 元函数形式，则有：
$$
(1)\neg G(P_{1},P_{2},\cdots,P_{n})\Leftrightarrow G^{*}(\neg P_{1},\neg P_{2},\cdots,\neg P_{n})\Leftrightarrow(G^{\neg})^{*}(P_{1},\cdots,P_{n})\tag{3-1}
$$  
$$
G^{\neg}(P_{1},P_{2},\cdots,P_{n})\Leftrightarrow G(\neg P_{1},\neg P_{2},\cdots,\neg P_{n})\Leftrightarrow\neg G^{*}(P_{1},P_{2},\cdots,P_{n})\tag{3-2}
$$  
上述定理的第（1）条表明命题公式$G$的否定与其命题变元否定的对偶式，即与该公式内否式的对偶式等值；第（2）条表明命题公式$G$的内否式与该公式对偶式的否定等值。  
【定理3.7】（对偶原理）假设$P_{1},P_{2},\cdots,P_{n}$是出现在命题公式$P$和$Q$中的所有原子变元，如果$P\Leftrightarrow Q$，那么$P^{*}\Leftrightarrow Q^{*}$。  
对偶原理表明命题公式之间所有等值关系都是成对的。也就是说，对于任意一个等值式，都可由对偶原理构造一个与之对偶的等值式。例如，对于等值式$P\to Q\Leftrightarrow\neg P\lor Q$，则可构造出其对偶等值式$\neg P\land Q\Leftrightarrow\neg(\neg P\rightarrow\neg Q)$。因为$\neg P\land Q\Leftrightarrow\neg(P\lor\neg Q)\Leftrightarrow\neg(\neg P\to\neg Q)$。"
除留余数法,算法,"['第七章 函数与特殊函数', '§ 7.4 有限集的置换函数', '7.5.1 哈希查找问题']","{'实体类型': '算法', '定义': '取关键字被某个不大于哈希表表长的数除后所得余数为哈希地址的方法', '特点': '最简单且常用的构造哈希函数的方法', '注意': '对除数的选择很重要，一般选为质数或不包含小于20的质因素的合数'}",,3,"在计算机系统中，数据的存放位置和时间都不能完全确定，此时需要一种有效的方法在有限的存储空间中合理存放数据并且能够实现快速定位查找。此时，如果建立一个关于存储位置和数据关键字的对应关系$f$，就能找给定值$k e y$的像$f(k e y)$。这里的对应关系$f$通常称为哈希函数，这种数据查找方法称为哈希查找。  
例如，如果要建立一张学生成绩表，最简单的方法是以学生的学号作为关键字，1 号学生的记录位置放在第一条，10 号学生的记录位置放在第10 条，以此类推。此时，如果要查看的学号为5 的学生的成绩，则只要取出第5 条记录就可以了.这样建立的表实际上就是一张简单的哈希表，其哈希函数为$f(k e y){=}\ k e y$。然而很多情况下的哈希函数并不如此简单。为了查看的方便，可能会以学生的名字作为关键字。此时，为了能够根据学生的名字直接定位出相应记录所在的位置，需要将这些名字转化为数字，构造出相应的哈希函数，下面给出两个不同的哈希函数：  
（1）考察学生名字的汉语拼音，将其中第一个字母在英语字母表中的序号作为哈希函数值。例如：“蔡军”的汉语拼音第一个字母为字母$C$，因此取03 作为其哈希值。  
（2）考察学生名字的汉语拼音，将其中第一个字母和最后一个字母在英语字母表中的序号之和作为哈希函数值。例如，“蔡军”的汉语拼音第一个字母和最后一个字母分别为$𝐶$和$N$，因此取17 作为其哈希值。  
分别应用这两个哈希函数，成绩表中部分学生名字不同的哈希函数值如表7-7 所示。  
表 7-7
![](images/a45025876fc98ab470bf113421a83e13ab1997baea6e789cdbd16990f25f7ba0.jpg)  
![](images/0f18f81e6e78fd7fb2b0f104794c8a798e21b0531706abe9d65a4f9970f2f012.jpg)  
在哈希表的构造过程中，可能会出现不同的关键字映射到同一地址的情况，即$k e y_{1}\neq$$k e y_{2}$，但$f(k e y_{1})=f(k e y_{2})$，也将这种现象称为冲突和碰撞。实际上，由于哈希函数是把任意长度的字符串映射为固定长度的字符串，冲突必然存在，只能尽可能减少。常见的构造哈希函数的方法有以下几种：  
（1）数字分析法。数字分析法适合于关键字由若干数码组成，同时各数码的分布规律事先知道的情况。具体方法是：分析关键字集合中每个关键字中的每一位数码的分布情况，找出数码分布均匀的若干位作为关键字的存储地址。例如，一个由80 个结点组成的结构，其关键字为6 位十进制数。选择哈希表长度为100，则可取关键字中的两位十进制数作为结点的存储地址。具体采用哪两位数码，需要用数字分析法对关键字中的数码分布情况进行分析。假设结点中有一部分关键字如下：  
$k e y_{1}=301514\;\;;\;\;\;k e y_{2}=303027;\;\;k e y_{3}=301103;\;\;\;k e y_{4}=308329;$ $k e y_{5}=300287;\;\;k e y_{6}=305939;\;\;k e y_{7}=300792;\;\;k e y_{8}=300463\circ878.$  
对上述关键字分析可以发现，关键字的第一位均是3，第二位均是0，分布集中，不适合作为存储地址。而第4 位和第5 位分布均匀，所以该哈希函数可以构造为取第4,5 位作为结点的存储地址。上述8 个节点的散列地址为：  
$f(k e y_{1})=51~~~~f(k e y_{2})=02~~~~f(k e y_{3})=10~~~~f(k e y_{4})=32$ $f(k e y_{5})=28\;\;\;\;\;f(k e y_{6})=93\;\;\;\;\;f(k e y_{7})=79\;\;\;\;\;f(k e y_{8})=46$  
（2）平方取中法。平方取中法是一种比较常用的构造哈希函数的方法，具体是：将关键字求平方后，取其中间的几位数字作为散列地址。由于关键字平方后的中间几位数字和组成关键字的每一位数字都有关，因此产生冲突的可能性较小，最后究竟取几位数字作为散列地址需要由散列表的长度决定。例如，若结构的存储地址范围是1\~999，则取平方值的中间三位，如表7-8 所示。  
表7-8  平方取中法
![](images/3bce2eeb41624a2b374dfdbdb4f5d0a22039c970673844c48a904ace588c42b7.jpg)  
（3）除留余数法。除留余数法取关键字被某个不大于哈希表表长$m$的数$ p$除后所得余数为哈希地址，即$f(k e y)=k e y({\bmod{\ p}})$，其中$p\leq m$。这是一种最简单也是最常用的构造哈希函数的方法。它不仅可以对关键字直接取模（mod），也可在平方取中等运算之后取模。值得注意的是，在使用除留余数法时，对$ p$的选择很重要。若$p$选的不好，容易产生同义词。由经验得知：一般情况下可以选$p$为质数或不包含小于20 的质因素的合数。  
哈希函数中会不可避免的存在冲突。因此，在建造哈希函数时不仅要设定一个“好”的哈希函数，而且要设定一种处理冲突的方法。假设哈希表地址集为$\!\sim\!(n-1)$，冲突是指由关键字得到的哈希地址为𝑗$(0\leq j\leq n-1)$的位置上已有记录，则“处理冲突”就是为该关键字的记录找到另一个“空”的哈希地址。  
在处理冲突的过程中可能得到一个地址序列$h_{i}$，其中，$h_{i}\in[0,\mathfrak{n}-1],\mathrm{i}=1,2,\cdots,\mathtt{k}$。即  
在处理哈希地址的冲突时，若得到的另一个哈希地址${\bf h}_{1}$ 仍然发生冲突，则再求下一个地址$h_{2}$，若$ h_{2}$仍然冲突，再求得$h_{3}$，依此类推，直至$h_{k}$不发生冲突为止，则$h_{k}$为记录在表中的地址。处理冲突的具体方法通常有开放定址法、再哈希法和拉链法，这里不再赘述。"
陪集,概念,"['第十二章 典型抽象代数结构', '§ 12.3 同余关系与商群', '12.3.1 同余关系与陪集']","{'实体类型': '概念', '定义': '设⟨G,*⟩是任意给定的一个群，⟨H,*⟩是⟨G,*⟩的任一子群，则对于∀a∈G，称集合aH={a*h|h∈H}为子群⟨H,*⟩在群⟨G,*⟩中的一个左陪集，集合Ha={h*a|h∈H}为子群⟨H,*⟩在群⟨G,*⟩中的一个右陪集，元素a为aH和Ha的代表元'}",,3,"现在我们在群结构的场合考察二元代数结构的同余关系。首先看下面具体实例：  
对于整数加群$\langle Z,+\rangle$，易知$\langle Z_{m},+\rangle$是$\langle Z,+\rangle$一个子群。其中$Z_{m}=\{k m|k\in Z\}$，$m$是任意给定的正整数。我们知道，任意两个整数$a$和$b$具有模$m$同余关系当且仅当$a-b\in Z_{m}$。  
对上述整数加群$\langle Z,+\rangle$上模$m$同余关系进行抽象，就得到如下群上的同余关系：  
【定义12.17】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，对于$\forall a,b\in G$,若有$a*b^{-1}\in H$，则称$a$与$b$具有模${H}$同余关系，记为$a\equiv b({mod{H}})$。  
下面的定理12.3.1 表明模$H$同余关系的确是一个同余关系，即要证明该关系不仅是一个等价关系，而且还对运算$*$具有保持性。  
【定理12.20】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则模${H}$同余关系是$G$上的一个等价关系且对运算${\ast}$具有保持性，即对于$\forall a,b,c\in G$，如果$a\equiv b({\bmod{\ H}})$，则有$a*c\equiv b*c({\bmod{\ H}})$。  
对于群$\langle G,*\rangle$的任意一个子群$\langle H,*\rangle$，既然模$H$同余关系是$G$上的一个等价关系，那么该关系必然确定一个对集合$G$的划分，每个划分块就是该等价关系的一个等价类。由于该等价关系显然由子群$\langle H,*\rangle$确定，因此，对集合的$G$划分也应由子群$\langle H,*\rangle$。为便于考察子群$\langle H,*\rangle$与集合划分的关系，现引入子群$\langle H,*\rangle$陪集的概念，并考察$\langle H,*\rangle$的左右陪集与模${H}$同余关系所确定等价类之间的联系。具体如下：  
【定义12.18】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则对于$\forall a\in G$，称集合$a$ $H=\{a*h|h\in H\}$为子群$\langle H,*\rangle$在群$\langle G,*\rangle$中的一个左陪集，集合$H a=\{h*a|h\in H\}$为子群$\langle H,*\rangle$在群$\langle G,*\rangle$中的一个右陪集，元素$a$为$𝑎$ $H$和$H a$的代表元。  
现在考察如何使用左右陪集实现对群的分解，为此首先引入如下定理：  
【定理12.21】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则对于$\forall a\in G$，其关于$\langle H,*\rangle$的左右陪集的基数相等且等于$ H$的基数，即有$\left|a H\right|=\left|H\right|=\left|H a\right|$。  
由此可见，对于群$\langle G,*\rangle$中的任意一个元素，其关于子群$\langle H,*\rangle$的左右陪集的基数相等且是一个仅与子集$H$有关的常数，即为$|H|$。由此可得如下关于群分解的拉格朗日定理：  
【定理12.22】（拉格朗日定理）设$\langle G,*\rangle$是任意给定的一个有限群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则群$\langle G,*\rangle$的阶一定是其子群$\langle H,*\rangle$阶的倍数，即有$k=|G|/|H|$，其中$k$为正整数且为子群$\langle H,*\rangle$的一切不同左（右）陪集个数。  
拉格朗日定理定理告诉我们：若$\langle G,*\rangle$是有限群，则其子群的阶是群$\langle G,*\rangle$阶的因子。因此，可以通过群与其子群阶的关系考察群的结构及其子群的个数。  
【推论12. 1】假设$\langle G,*\rangle$是一个$ n$阶有限群，则$G$中每个元素的阶均是${n}$的因子且对于$\forall a\in$$G$有$a^{n}=e$.  
【推论12.2】阶为素数的有限群是循环群."
集合,概念,"['二、集合的表示方法', '三、集合与集合的关系', '§ 1.1 集合的基本知识', '1.1.2 集合的概念与表示', '四、常用的特殊集合', '一、集合与元素的概念', '4.文氏图法', '第一章  集合与计数基础']","{'实体类型': '概念', '定义': ['比数更加基本的概念，定义出数和数的运算，演化出整个数学学科的理论体系', '在指定范围内满足给定条件、能相互区分的所有对象构成的总体', '由确定的元素构成的整体', '由相同元素组成的无序集合', '离散数学中很多基本概念的定义及其性质讨论都离不开它们'], '特点': ['元素与集合之间的归属关系是明确的', '元素相同且无序'], '基本性质': ['互异性：集合中的每个元素都是互不相同的', '可分性：集合中的每个元素都是可以明确加以区分的对象', '无序性：集合中的元素之间是没有次序的'], '表示方法': ['通常用带下标或不带下标的大写英文字母表示集合，用带下标或不带下标的小写英文字母表示集合中的对象或元素', '包括列举法、描述法、文氏图法等'], '包含内容': ['集合概念的含义', '元素的概念与性质', '集合的表示方法', '集合之间的相等与包含关系', '若干常用的特殊集合'], '属性': ['包括数学危机与集合论的由来', '集合的概念与表示', '集合的基本运算及运算性质']}",,2,集合论是整个数学的基础和出发点， 当然也是离散数学的基础和出发点， 要学好离散数 学，首先必须学习集合论的有关知识。学习集合论还有一个非常重要的原因，那就是计算机的各个领域都与集合论有着极其密切的关系。因为集合不仅可以表示数值信息，而且还可表示和处理各种非数值信息，例如对各种数据的增删查改、对数据之间关系的描述等等，甚至可以让这些数据信息像数值一样进行运算。在本节，我们将学习集合论的基本知识，包括数学危机与集合论的由来、集合的概念与表示、集合的基本运算及运算性质等。
集合之间的相等与包含关系,性质,"['第一章  集合与计数基础', '§ 1.1 集合的基本知识', '1.1.2 集合的概念与表示']","{'实体类型': '性质', '定义': '描述集合之间是否相等或包含的关系'}",,3,集合论从一个比数更加基本的概念——集合出发，定义出数和数的运算，进而演化出整个数学学科的理论体系。本小节将从集合的基本概念出发，介绍集合论中最为基础的知识，包括集合概念的含义、元素的概念与性质、集合的表示方法、集合之间的相等与包含关系、若干常用的特殊集合等。
集合交运算,概念,"['第一章  集合与计数基础', '§ 1.1 集合的基本知识', '1.1.3 集合的基本运算', '一、交运算与并运算']","{'实体类型': '概念', '定义': '对于任意两个集合A和B，A∩B={x|x∈A并且x∈B}称为A和B的交集，亦称A∩B为集合A和B的交运算', '特点': '将两个集合中的共同部分取出来构成一个新的集合', '性质': ['幂等律：A∩A=A', '交换律：A∩B=B∩A', '结合律：(A∩B)∩C=A∩(B∩C)', '同一律：A∩U=A', '零律：A∩∅=∅', '分配律：A∪(B∩C)=(A∪B)∩(A∪C)', '吸收律：A∩(A∪B)=A', '包含关系：A⊆B当且仅当A∩B=A']}",,4,"有时候需要将两个集合的中的元素合并起来构成一个新的集合，由此得到集合并运算的概念；有时需要将两个集合中的共同部分取出来构成一个新的集合，由此得到集合交运算的概念。这两个运算的具体定义如下：  
【定义1.10】对于任意两个集合$A$ 和$B$， $A\cup B=\left\{x\middle|x\in A\right.$或者$\cdot x\in B\}$称为$A$ 和$B$ 并集，亦称$A\cup B$为集合$A$ 和$B$ 的并运算；$A\cap B=\{x|x\in A$并且$x\in B.$}称为$A$ 和$B$ 交集，亦  称$A\cap B$为集合$A$ 和$B$ 的交运算。  
由上述定义可知，对于任意两个集合$A$ 和$B$，两者并运算的结果产生一个新集合，该集合是由$A$ 和$B$ 中元素合并而成，如图$1{\cdot}2(a)$所示；两者交运算结果产生另外一个新集合，该集合由$A$ 和$B$ 的共同部分组成，或者说由同时属于$A$ 和$B$ 的元素组成，如图1-2(b)所示。  
![](images/4fb6199ac21b049856dda6721c89f3d4f0739da1971ad0bbc7426e82d630f6b5.jpg)
图1-2 并、交运算的文氏图  
不难看出，并运算和交运算其实分别就是实数加法和乘法在集合论领域的推广。根据并运算与交运算的定义，不难证明它们满足如下基本运算性质：  
(1) 幂等律：对于任意集合$A$，有：$A\cup A=A$；$A\cap A=A$ (2) 交换律：对于任意两个集合$A$ 和$B$，有：$A\cup B=B\cup A$；$A\cap B=B\cap A$ (3) 结合律：对于任意三个集合$A,\ B$ 和$C$，有：  
$$
(A\cup B)\cup C=A\cup(B\cup C);\;\;(A\cap B)\cap C=A\cap(B\cap C)
$$  
(4) 同一律：对于任意集合$A$，有：$A\cup\varnothing=A$；$A\cap U=A$(5) 零  律：对于任意集合$A$，有：$A\cup U=U$；$A\cap\varnothing=\varnothing$(6) 分配律：对于任意三个集合$A,\ B$ 和$C$，有：  
$$
\begin{array}{r}{A\cap(B\cup C)=(A\cap B)\cup(A\cap C)}\\ {A\cup(B\cap C)=(A\cup B)\cap(A\cup C)}\end{array}
$$  
(7) 吸收律：对于任意两个集合$A$ 和$B$，有：  
$$
A\cup(A\cap B)=A;\,\,\,A\cap(A\cup B)=A
$$  
(8) 对于任意两个集合$A$ 和$B$，有：  
$A\subseteq B$当且仅当$A\cup B=B$ $A\subseteq B$当且仅当$A\cap B=A$  
其中$U$和$\varnothing$分别表示全集和空集。  
上述性质既可根据文氏图简单直观地得到，也可根据集合相等的定义给出数学证明。现仅以分配律为例进行证明，读者可自行给出其余性质的证明。  
上述两个集合的并与交运算可以推广到如下多个集合的情形：  
【定义1.11】对于任意$n$ 个集合$A_{1},A_{2},\ldots,A_{n}$，其交运算和并运算分别为：  
$A_{1}\cap A_{2}\cap,\ldots,\cap A_{n}=\{x|x\in A_{1}$ 或 ${\boldsymbol{x}}\in A_{2}$ 或 …  或 $\textstyle{\boldsymbol{x}}\in A_{n}]$ }   $A_{1}\cup A_{2}\cup,\ldots,\cup A_{n}=\{x|x\in A_{1}$ 且 $x\in A_{2}$ 且 …  且 $x\in A_{n}\}$"
集合代数,概念,"['第十一章  抽象代数结构通论', '§ 11.1 代数结构的基本概念']","{'实体类型': '概念', '运算': '交、并、补运算'}",,2,抽象代数结构的基本思想是以主动的方式定义一个由若干抽象对象为元素构成的集合，并在这个集合上定义一个或多个抽象运算，由此形成一个抽象的代数运算系统，然后通过研究和讨论这个代数运算系统的运算性质获得该运算系统的结构。相对于传统的初等代数，这是一种全新的思维方式和观察问题的角度。从这个角度看过去，会得到很多令人惊讶的新认识。例如，集合代数有交、并、补运算，命题代数有与、或、非运算，从抽象代数结构上看，两者的运算性质完全相同，或者说两者是同一抽象代数不同表现形式；再如，实数集合上的加法和正实数上的乘法也是本质相同外表不同，加法中的0 其实就是乘法中的1。
集合划分,概念,"['§ 6.1 等价关系与元素分类', '6.1.2 集合的划分与商集', '第六章 特殊关系模型']","{'实体类型': '概念', '相关概念': '等价关系', '定义': '将非空集合划分为若干非空子集，满足子集互不相交且并集等于原集合', '特点': '实现对集合中元素的一种分类', '应用': '分类问题求解策略，如人工智能中的分类器设计'}",,2,等价关系，顾名思义就是表示相同、相等、平等、一致等含义的关系，刻画的是对象之间在某个方面的无差异性。可用等价关系将集合中元素进行分类，使得属于同一类的元素彼此之间具有等价关系，而分属不同类型的元素之间不具有等价关系。属于同一类的元素因其相互之间满足等价关系而可将它们看成是一些无差异的个体，进而将这些无差异个体抽象成一个个体或代表元，由此实现对集合的化简。目前，等价关系可以有效地实现对数据的抽象和化简，已在计算机及相关信息领域得到广泛应用。本节具体介绍等价关系的基本知识，主要包括等价关系与等价类的概念和性质、集合划分与商集的相关知识。
集合基数,概念,"['第一章  集合与计数基础', '§ 1.1 集合的基本知识', '1.1.2 集合的概念与表示', '四、常用的特殊集合', '2.有限集与无限集']","{'实体类型': '概念', '定义': '对于任意集合A，A中所含元素的个数称为A的基数，记为|A|'}",,5,"在集合的理论研究和实际应用中，经常需要对集合中元素的数量规模进行度量，由此得到集合基数的概念，具体定义如下：  
【定义1.6】对于任意集合$A$，$A$ 中所含元素的个数称为$A$ 的基数，记为$|A|\circ$  
【定义1.7】对于任意给定的集合$A$，如果它的基数是一个有限数，则称该集合是一个有限集，否则称之为无限集。  
有限集中元素的个数是有限的，无限集中元素的个数是无限的。无论从概念上还是方法看，有限集和无限集的规模度量或计数都有着本质上的区别，我们将在后续相关内容中对此做具体介绍和分析。"
集合并运算,概念,"['第一章  集合与计数基础', '§ 1.1 集合的基本知识', '1.1.3 集合的基本运算', '一、交运算与并运算']","{'实体类型': '概念', '定义': '对于任意两个集合A和B，A∪B={x|x∈A或者x∈B}称为A和B的并集，亦称A∪B为集合A和B的并运算', '特点': '将两个集合中的元素合并起来构成一个新的集合', '性质': ['幂等律：A∪A=A', '交换律：A∪B=B∪A', '结合律：(A∪B)∪C=A∪(B∪C)', '同一律：A∪∅=A', '零律：A∪U=U', '分配律：A∩(B∪C)=(A∩B)∪(A∩C)', '吸收律：A∪(A∩B)=A', '包含关系：A⊆B当且仅当A∪B=B']}",,4,"有时候需要将两个集合的中的元素合并起来构成一个新的集合，由此得到集合并运算的概念；有时需要将两个集合中的共同部分取出来构成一个新的集合，由此得到集合交运算的概念。这两个运算的具体定义如下：  
【定义1.10】对于任意两个集合$A$ 和$B$， $A\cup B=\left\{x\middle|x\in A\right.$或者$\cdot x\in B\}$称为$A$ 和$B$ 并集，亦称$A\cup B$为集合$A$ 和$B$ 的并运算；$A\cap B=\{x|x\in A$并且$x\in B.$}称为$A$ 和$B$ 交集，亦  称$A\cap B$为集合$A$ 和$B$ 的交运算。  
由上述定义可知，对于任意两个集合$A$ 和$B$，两者并运算的结果产生一个新集合，该集合是由$A$ 和$B$ 中元素合并而成，如图$1{\cdot}2(a)$所示；两者交运算结果产生另外一个新集合，该集合由$A$ 和$B$ 的共同部分组成，或者说由同时属于$A$ 和$B$ 的元素组成，如图1-2(b)所示。  
![](images/4fb6199ac21b049856dda6721c89f3d4f0739da1971ad0bbc7426e82d630f6b5.jpg)
图1-2 并、交运算的文氏图  
不难看出，并运算和交运算其实分别就是实数加法和乘法在集合论领域的推广。根据并运算与交运算的定义，不难证明它们满足如下基本运算性质：  
(1) 幂等律：对于任意集合$A$，有：$A\cup A=A$；$A\cap A=A$ (2) 交换律：对于任意两个集合$A$ 和$B$，有：$A\cup B=B\cup A$；$A\cap B=B\cap A$ (3) 结合律：对于任意三个集合$A,\ B$ 和$C$，有：  
$$
(A\cup B)\cup C=A\cup(B\cup C);\;\;(A\cap B)\cap C=A\cap(B\cap C)
$$  
(4) 同一律：对于任意集合$A$，有：$A\cup\varnothing=A$；$A\cap U=A$(5) 零  律：对于任意集合$A$，有：$A\cup U=U$；$A\cap\varnothing=\varnothing$(6) 分配律：对于任意三个集合$A,\ B$ 和$C$，有：  
$$
\begin{array}{r}{A\cap(B\cup C)=(A\cap B)\cup(A\cap C)}\\ {A\cup(B\cap C)=(A\cup B)\cap(A\cup C)}\end{array}
$$  
(7) 吸收律：对于任意两个集合$A$ 和$B$，有：  
$$
A\cup(A\cap B)=A;\,\,\,A\cap(A\cup B)=A
$$  
(8) 对于任意两个集合$A$ 和$B$，有：  
$A\subseteq B$当且仅当$A\cup B=B$ $A\subseteq B$当且仅当$A\cap B=A$  
其中$U$和$\varnothing$分别表示全集和空集。  
上述性质既可根据文氏图简单直观地得到，也可根据集合相等的定义给出数学证明。现仅以分配律为例进行证明，读者可自行给出其余性质的证明。  
上述两个集合的并与交运算可以推广到如下多个集合的情形：  
【定义1.11】对于任意$n$ 个集合$A_{1},A_{2},\ldots,A_{n}$，其交运算和并运算分别为：  
$A_{1}\cap A_{2}\cap,\ldots,\cap A_{n}=\{x|x\in A_{1}$ 或 ${\boldsymbol{x}}\in A_{2}$ 或 …  或 $\textstyle{\boldsymbol{x}}\in A_{n}]$ }   $A_{1}\cup A_{2}\cup,\ldots,\cup A_{n}=\{x|x\in A_{1}$ 且 $x\in A_{2}$ 且 …  且 $x\in A_{n}\}$"
集合的二进制表示,概念,"['第一章  集合与计数基础', '§ 1.1 集合的基本知识', '1.1.4 集合的二进制表示']","{'实体类型': '概念', '定义': '将集合中的元素顺序存放在计算机中，用比特串表示集合元素的存在与否', '应用': '提高集合交、并、差等运算的效率，广泛应用于数据库记录的增、删、改计算', '特点': '通过布尔乘、布尔加运算实现集合交、并操作，补集编码通过比特串的0和1互换实现'}",,3,"集合在计算机中有着广泛的应用，一般都是将集合中的元素顺序的存放在计算机中，但这种存储方式会使得在计算集合的交、并、差等运算时需要对元素进行搜索，随之而来的是不必要的时间开销。为了避免这个问题，现在介绍一种比较有效的存储方法。  
假设全集$U$是有限集合，$A{=}\{a_{1},a_{2},{\ldots},a_{n}\}$是$U$的一个子集且对应一个长度为$n$的比特串$B{=}b_{1}b_{2}{...}b_{n}$。串$B$ 的每一位数字按如下方式取值：如果$a_{i}{\in}A$，则$b_{i}{=}1$，否则$b_{i}{=}0$。此时对于全集$U$ 的任意两个子集合，它们之间的交、并运算就可以按二进制数的布尔乘、布尔加运算进行，即：两个子集交的编码是两个子集编码对应位置的布尔乘；两个子集并的编码是两个子集编码对应位置的布尔加。布尔乘、布尔加的具体运算规则如下：  
$\begin{array}{r l r}{0+0=0}&{{}}&{0+1=1+0=1+1=1}\end{array}$ $\begin{array}{r l r}{1\times1=1}&{{}}&{0\times1=1\times0=0\times0=0}\end{array}$  
下面进一步考察集合补运算的二进制编码表示.假设集合$A{=}\{a_{1},\,a_{2},\,...,a_{n}\}$对应长度为$n$的比特串为$B{=}b_{1}b_{2}{\ldots}.b_{n}$，则集合$A$ 的补集的二进制编码只需要简单地把$B{=}b_{1}b_{2}{\ldots}b_{n}$ 中每个1换成0，每个0 换成1 即可。  
集合在数据库中具有着广泛应用，基于二进制编码的集合运算可以大大提高记录增、删、改的计算效率。数据库中数据在计算机系统中一般以二维表形式存在，可将其中每一列分别看作是一个集合，列标题就是该集合的名称，每一行是一个数据序列，称为记录。又可将整个二维表看成是记录的集合。下面考察一个具体例子：  
表1-1 二维表
![](images/ed20520091902c2b692c4144896337caee56d7b09ec379326531846771b24a4c.jpg)"
集合的包含关系,性质,"['第一章  集合与计数基础', '§ 1.1 集合的基本知识', '1.1.2 集合的概念与表示', '三、集合与集合的关系']","{'实体类型': '性质', '基本性质': ['自反性：对于任意给定的集合A，都成立A⊆A', '反对称性：对于任意两个集合A和B，A=B当且仅当A⊆B且B⊆A', '传递性：对于任意三个集合A、B、C，若A⊆B且B⊆C，则A⊆C']}",,4,"如前所述，集合中凡是相同的元素都看成是同一个元素，而且集合中元素之间的排列次序也不加区分，或者说是无序的。如此一来，集合就完全取决于集合中的元素。换句话说，对于任意两个集合，如果这两个集合中具有完全相同的元素，那么这两个集合就是完全一样的。或者说，这两个集合是相等的。于是得到如下关于集合相等的外延性原理：  
【定理1.1】（外延性原理）对于任意的集合$A$ 和集合$B$，$\pmb{A}$ 与$\pmb{B}$ 相等当且仅当两者具有相同元素；或者说，$\pmb{A}$ 与$\pmb{B}$ 相等当且仅当$A$ 中每个元素都属于$B$ 且$B$ 中每个元素都属于$A$。如果集合$A$ 与$B$ 相等，则记为$A=B$；否则，如果$A$ 与$B$ 不相等，则记为$A\ne B$。  
【定理1.2】集合的相等关系具有如下三条基本性质： （1）自反性：对于任意给定的集合$A$，成立$A{=}A$； （2）对称性：对于任意给定的两个集合$A$ 和$B$，若有$A{=}B$，则有$B{=}A$；  
（3）传递性：对于任意三个集合$A$、$B$、$C$，若有$A{=}B$ 且$B{=}C$，则有$_{A=C}$  
由【例题1.9】可以看出，集合$C$ 中的每个元素都是集合$A$ 中的元素，此时$A$ 完全包含了$C$，可将$C$ 看成是$A$ 的一个部分，由此得到如下集合的包含关系和子集的概念：  
【定义1.2】对于任意两个集合$A$ 和$B$，若$B$ 中的每个元素都是$A$ 中的元素，则称$\pmb{B}$ 包含于$\pmb{A}$（或$\pmb{A}$ 包含$\pmb{B}$），记为$B\subseteq A$，亦称$\pmb{B}$ 是$\pmb{A}$ 的子集，称符号$\subseteq$为集合之间的包含关系。如果$B$ 不能被$A$ 所包含，则称$\pmb{B}$ 不是$\pmb{A}$ 的子集，记为$B\nsubseteq A$。  
【定理1.3】集合的包含关系具有如下三条基本性质：（1）自反性：对于任意给定的集合$A$，都成立$A\subseteq A$  
（2）反对称性：对于任意两个集合$A$ 和$B$，$A{=}B$当且仅当$A\subseteq B$且$B\subseteq A$（3）传递性：对于任意三个集合$A$、$B$、$C$，若$A\subseteq B$且$B\subseteq C$，则$A\subseteq C$  
【定义1.3】对于任意两个集合$A$ 和$B$，如果$B\subseteq A$且$A\neq B$，则称$B$ 是$A$ 的真子集，记为$\mathrm{B}\subset\mathrm{A}$，并称符号$\subset$为集合之间的真包含关系。"
集合的基本运算,概念,"['第一章  集合与计数基础', '§ 1.1 集合的基本知识', '1.1.3 集合的基本运算']","{'实体类型': '概念', '定义': '通过运算机制从已有集合中构造出新的集合', '具体运算': '交运算、并运算、差运算、补运算和对称差运算'}",,3,我们学过实数的加、减、乘、除、乘方、开方等各种运算，通过这些运算可由已有实数生成新的实数。事实上，从数学方法论的角度来看，运算一种非常基本的数学手段。对于任何一个数学概念，在确定其内涵之后，我们总是通过构造概念运算的方式产生新的概念，代数式通过运算可以产生新的代数式、函数通过运算可以产生新的函数、命题通过运算可以产生新的命题、矩阵通过运算可以产生新的矩阵，等等。对集合的学习和探讨也是如此，在掌握集合的基本概念之后，下面进一步学习集合的基本运算及其性质，通过运算机制从已有集合中构造出新的集合，具体包括交运算、并运算、差运算、补运算和对称差运算。
集合的特征函数,概念,"['第七章 函数与特殊函数', '§ 7.3 集合的特征函数']","{'实体类型': '概念', '定义': '通过引入集合特征函数将关于集合的表示和运算转化为函数的表示和运算', '应用': '将关于集合问题的求解转化为关于函数问题的求解'}",,2,前面我们从二元关系与集合的角度介绍和讨论函数的相关知识，包括函数的集合定义和函数的关系运算。在本节，我们考虑相反的问题，就是如何以函数为基本工具来解决集合的相关问题。具体地说，就是通过引入集合特征函数将关于集合的表示和运算转化为函数的表示和运算，将关于集合问题的求解转化为关于函数问题的求解。
集合的相等关系,性质,"['第一章  集合与计数基础', '§ 1.1 集合的基本知识', '1.1.2 集合的概念与表示', '三、集合与集合的关系']","{'实体类型': '性质', '基本性质': ['自反性：对于任意给定的集合A，成立A=A', '对称性：对于任意给定的两个集合A和B，若有A=B，则有B=A', '传递性：对于任意三个集合A、B、C，若有A=B且B=C，则有A=C']}",,4,"如前所述，集合中凡是相同的元素都看成是同一个元素，而且集合中元素之间的排列次序也不加区分，或者说是无序的。如此一来，集合就完全取决于集合中的元素。换句话说，对于任意两个集合，如果这两个集合中具有完全相同的元素，那么这两个集合就是完全一样的。或者说，这两个集合是相等的。于是得到如下关于集合相等的外延性原理：  
【定理1.1】（外延性原理）对于任意的集合$A$ 和集合$B$，$\pmb{A}$ 与$\pmb{B}$ 相等当且仅当两者具有相同元素；或者说，$\pmb{A}$ 与$\pmb{B}$ 相等当且仅当$A$ 中每个元素都属于$B$ 且$B$ 中每个元素都属于$A$。如果集合$A$ 与$B$ 相等，则记为$A=B$；否则，如果$A$ 与$B$ 不相等，则记为$A\ne B$。  
【定理1.2】集合的相等关系具有如下三条基本性质： （1）自反性：对于任意给定的集合$A$，成立$A{=}A$； （2）对称性：对于任意给定的两个集合$A$ 和$B$，若有$A{=}B$，则有$B{=}A$；  
（3）传递性：对于任意三个集合$A$、$B$、$C$，若有$A{=}B$ 且$B{=}C$，则有$_{A=C}$  
由【例题1.9】可以看出，集合$C$ 中的每个元素都是集合$A$ 中的元素，此时$A$ 完全包含了$C$，可将$C$ 看成是$A$ 的一个部分，由此得到如下集合的包含关系和子集的概念：  
【定义1.2】对于任意两个集合$A$ 和$B$，若$B$ 中的每个元素都是$A$ 中的元素，则称$\pmb{B}$ 包含于$\pmb{A}$（或$\pmb{A}$ 包含$\pmb{B}$），记为$B\subseteq A$，亦称$\pmb{B}$ 是$\pmb{A}$ 的子集，称符号$\subseteq$为集合之间的包含关系。如果$B$ 不能被$A$ 所包含，则称$\pmb{B}$ 不是$\pmb{A}$ 的子集，记为$B\nsubseteq A$。  
【定理1.3】集合的包含关系具有如下三条基本性质：（1）自反性：对于任意给定的集合$A$，都成立$A\subseteq A$  
（2）反对称性：对于任意两个集合$A$ 和$B$，$A{=}B$当且仅当$A\subseteq B$且$B\subseteq A$（3）传递性：对于任意三个集合$A$、$B$、$C$，若$A\subseteq B$且$B\subseteq C$，则$A\subseteq C$  
【定义1.3】对于任意两个集合$A$ 和$B$，如果$B\subseteq A$且$A\neq B$，则称$B$ 是$A$ 的真子集，记为$\mathrm{B}\subset\mathrm{A}$，并称符号$\subset$为集合之间的真包含关系。"
集合的表示方法,概念,"['§ 1.1 集合的基本知识', '二、集合的表示方法', '1.1.2 集合的概念与表示', '第一章  集合与计数基础']","{'实体类型': '概念', '定义': '用于表示集合的方式', '主要方法': '枚举法、描述法、归纳法和文氏图法'}",,3,集合论从一个比数更加基本的概念——集合出发，定义出数和数的运算，进而演化出整个数学学科的理论体系。本小节将从集合的基本概念出发，介绍集合论中最为基础的知识，包括集合概念的含义、元素的概念与性质、集合的表示方法、集合之间的相等与包含关系、若干常用的特殊集合等。
集合等势,定义,"['第一章  集合与计数基础', '§ 1.2 可数集与不可数集', '1.2.1 无限集的度量问题']","{'实体类型': '定义', '内容': '设A和B是任意两个集合，如果A和B之间存在一一对应的关系，则称A与B等势', '记法': 'A^∘B'}",,3,"现考察集合规模的度量问题。直观上看，集合中元素数目越多集合的规模就越大。关键是如何界定集合中元素数目的多少？对于有限集，这个不成问题，可通过对集合中元素进行计数的方法解决。然而，对于无限集来说，问题就没这么简单了。例如对于下列问题：  
正整数集合$\{1,2,3,\ \cdots\ \}$和正整数平方集合$\{1^{2},2^{2},3^{2},\ \cdots\ \}$，哪个集合的元素更多？  
显然，正整数平方集合是正整数集合的一个真子集，因此正整数集合似乎应该更大一些。但这两个集合元素之间又显然存在一一对应关系。从传统有限集合计数的观点看，两者的数目又必定是相等的。这似乎存在一种矛盾。事实上，早在1638 年，意大利物理学家伽利略也发现了类似于这样的问题，但是他无法解决并感到困惑，便提出了所谓的伽利略悖论。  
其实，无限集所具有的无限延展特性使其与有限集合有着本质性差异，对有限集合进行精确计数的方式不再适用于对无限集合的度量。因此，必须采用同时适合有限集与无限集的新方法来实现对集合规模的度量。由此得到如下关于集合等势的概念：  
【定义1.15】设$A$ 和$B$ 是任意两个集合，如果$A$ 和$B$ 之间存在一一对应的关系：  
$$
\psi{\colon}A\to B
$$  
则称$\pmb{A}$ 与$\pmb{B}$ 等势，记为：$A^{\circ}B$  
显然，若 $\scriptstyle A=B$ ，则 $A^{\scriptscriptstyle\frown}B$ ，反之不然。  
【定理1.5】集合的等势满足如下三条基本性质：（1）自反性：对于任意集合$A$，有$A{\sim}A$；（2）对称性：对于任意两个集合$A$ 和$B$，如果$A{\sim}B$，则有$B{\sim}A$（3）传递性：对于任意三个集合$A$、$B$ 和$C$，如果$A{\sim}B$ 且$B{\sim}C$，则有$A{\sim}C$  
上述等势概念表达的仅仅是集合在数量规模上次序比较关系，要真正实现对无限集规模的度量，还需确定一个基本的规模度量单位作为度量标准或基准。显然，任何无限集都可生成一个子集与自然数集等势，因此可将自然数集合作为无限集规模度量的一种基准。下面着重介绍自然数的基本概念与性质。"
集合等势的基本性质,定理,"['第一章  集合与计数基础', '§ 1.2 可数集与不可数集', '1.2.1 无限集的度量问题']","{'实体类型': '定理', '性质1': '自反性：对于任意集合A，有A∼A', '性质2': '对称性：对于任意两个集合A和B，如果A∼B，则有B∼A', '性质3': '传递性：对于任意三个集合A、B和C，如果A∼B且B∼C，则有A∼C'}",,3,"现考察集合规模的度量问题。直观上看，集合中元素数目越多集合的规模就越大。关键是如何界定集合中元素数目的多少？对于有限集，这个不成问题，可通过对集合中元素进行计数的方法解决。然而，对于无限集来说，问题就没这么简单了。例如对于下列问题：  
正整数集合$\{1,2,3,\ \cdots\ \}$和正整数平方集合$\{1^{2},2^{2},3^{2},\ \cdots\ \}$，哪个集合的元素更多？  
显然，正整数平方集合是正整数集合的一个真子集，因此正整数集合似乎应该更大一些。但这两个集合元素之间又显然存在一一对应关系。从传统有限集合计数的观点看，两者的数目又必定是相等的。这似乎存在一种矛盾。事实上，早在1638 年，意大利物理学家伽利略也发现了类似于这样的问题，但是他无法解决并感到困惑，便提出了所谓的伽利略悖论。  
其实，无限集所具有的无限延展特性使其与有限集合有着本质性差异，对有限集合进行精确计数的方式不再适用于对无限集合的度量。因此，必须采用同时适合有限集与无限集的新方法来实现对集合规模的度量。由此得到如下关于集合等势的概念：  
【定义1.15】设$A$ 和$B$ 是任意两个集合，如果$A$ 和$B$ 之间存在一一对应的关系：  
$$
\psi{\colon}A\to B
$$  
则称$\pmb{A}$ 与$\pmb{B}$ 等势，记为：$A^{\circ}B$  
显然，若 $\scriptstyle A=B$ ，则 $A^{\scriptscriptstyle\frown}B$ ，反之不然。  
【定理1.5】集合的等势满足如下三条基本性质：（1）自反性：对于任意集合$A$，有$A{\sim}A$；（2）对称性：对于任意两个集合$A$ 和$B$，如果$A{\sim}B$，则有$B{\sim}A$（3）传递性：对于任意三个集合$A$、$B$ 和$C$，如果$A{\sim}B$ 且$B{\sim}C$，则有$A{\sim}C$  
上述等势概念表达的仅仅是集合在数量规模上次序比较关系，要真正实现对无限集规模的度量，还需确定一个基本的规模度量单位作为度量标准或基准。显然，任何无限集都可生成一个子集与自然数集等势，因此可将自然数集合作为无限集规模度量的一种基准。下面着重介绍自然数的基本概念与性质。"
集合表示法,方法,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.3 图的表示方法']","{'实体类型': '方法', '特点': '精确但抽象且不易理解'}",,3,"如前所述，图模型其实就是一种特殊的二元关系。因此，图模型作为一种二元关系，一般来说具有三种基本的表示方法，即集合表示法、图形表示法和矩阵表示法。对于一个图模型G，若将其记为 $G=\langle V,E\rangle$ ，并枚举集合 $V$ 和 $E$ 中所有元素，则称这种表示方法为图的集合表示法。若画出$G$ 的图形，用小圆圈表示 $V$中的结点，用由 $u$ 指向 $v$ 的有向线段或曲线表示有向边 $\langle u,v\rangle$ ，无向线段或曲线表示无向边 $(\mathrm{u},\mathrm{v})$ ，则称该方法为图的图形表示法。  
![图8-8 图模型G的图形表示法 ](images/42c40d1dbd600657cf3b9d4593b6b7c38007adbf1cf3dec9952b6b75bb10d397.jpg)  
对于图8-8 所示的图$G$ ，可用集合为 $G=\langle V,E\rangle$ ，其顶点集 $V=\{v_{1},v_{2},v_{3},v_{4}\}$，其边集$E=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{2},v_{3}\rangle,\langle v_{2},v_{4}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$ 。 若用图形表示，则其本身就是图形表示。  
集合表示法比较精确，但抽象且不易理解；图形表示法形象直观，但是当图中的结点和边的数目较大时，这种表示法很不方便甚至不可行。事实上，可以通过矩阵将图模型的逻辑结构转变成可在计算机中存储和运算的形式，并可设计一定的存储结构满足计算机处理的需要。因此，计算机系统通常使用矩阵实现对图的表示和处理。本节着重介绍图的矩阵表示法，具体包括邻接矩阵表示法、关联矩阵表示法、邻接表表示法等几种类型。"
集合覆盖,概念,"['第六章 特殊关系模型', '6.2.2  集合的覆盖', '§ 6.2 相容关系与元素聚类']","{'实体类型': '概念', '定义': ['由相容关系构造的对集合的覆盖，各个相容类之间的交集可以为非空', '假设A是任一非空集合，Q是A的非空子集Q_i组成的集族，且满足Q_1∪Q_2∪...∪Q_m=A，则称Q是A的一个覆盖'], '特点': ['与划分不同，集合中的同一元素可同时属于多个不同相容类', '划分一定是覆盖，但覆盖不一定是划分'], 'name': '集合覆盖'}",,2,"相容关系，顾名思义就是一种能求同存异的关系，表示对象之间存在一些相同点或共性,例如国家之间的共同利益、人与人之间的共同兴趣爱好等。日常工作和生活中人与人之间的朋友关系、英文单词之间存在共同字母的关系等都可看成是相容关系。与等价关系相比，相容关系所表示对象之间的联系显然要弱一些，因为等价关系要求的是对象之间完全相同或相等。类似于等价关系可构造对集合的划分，相容关系则可构造对集合的覆盖。与划分不同的是构成集合覆盖的各个相容类之间的交集可以为非空。也就是说，集合中的同一元素可同时属于多个不同相容类。这相当于对集合中的元素进行聚类,因为在集合元素的聚类过程中，同一元素可同时聚合到多个不同的类别当中。这是元素聚类与元素分类的主要区别。聚类是有别于分类的另外一种非常重要的问题求解方法，可用于计算机数据分析相关的很多领域，例如数据挖掘和目标识别中的聚类分析等等。本节主要介绍相容关系的基本知识，主要包括相容关系与相容类的概念和性质、集合覆盖与完全覆盖的相关知识。"
集合论,概念,"['1.1.1 数学危机与集合论', '第一章  集合与计数基础', '§ 1.1 集合的基本知识']","{'实体类型': '概念', '地位': ['离散数学的分支之一', '离散数学的基础和出发点', '成为整个数学大厦的根基'], '作用': '学习各个离散数学分支所必备的入门基础', '定义': ['整个数学的基础和出发点', '用集合的方式定义自然数并取得成功'], '应用': '计算机的各个领域都与集合论有着极其密切的关系', '特点': '可以表示和处理数值信息及非数值信息，例如对数据的增删查改、描述数据关系，进行数据信息运算', '成就': '被誉为十九世纪最伟大的数学成就', '创始人': '康托'}",,1,离散数学以各种离散量的概念、关系、结构和运算性质为研究对象，以充分满足计算机相关学科对离散量进行表示和处理的数学需求。正如微积分支撑了作为近代工业文明基础的物理学，离散数学支撑了作为现代信息社会基础的计算机科学。事实上，离散数学是一门综合的数学学科，由多个数学分支组成，包括集合论、数理逻辑、图论、数论、组合分析、代数结构等，分别从不同角度出发研究各种离散量之间数与形的关系。本章比较系统地介绍集合论与计数的基础知识， 它们是学习各个离散数学分支所必备的入门基础。 尽管读者可能已 经从其它途径获悉其中某些概念，但是要想掌握作为支撑整个计算机学科基石的离散数学，就必须重新审视和系统地学习这些入门知识。
集族,概念,"['第一章  集合与计数基础', '§ 1.1 集合的基本知识', '1.1.2 集合的概念与表示', '四、常用的特殊集合', '3.有限子集与幂集']","{'实体类型': '概念', '定义': '以集合作为元素的集合'}",,5,"对于有限集合，我们可以构造出相关的子集并对子集进行计数，具体定义如下：  
【定义1.8】设$A$ 是任一有限集合，若$A$ 中含有$n$ 个元素，即有$\left|A\right|{=}n$，则称$A$ 为$n$ 元集合。对于$A$ 的任意一个子集$B$，若$B$ 中含有$m$ 个元素，则称$B$ 为$A$ 的$m$ 元子集。  
也就是说：$n$ 元集合共有$2^{n}$个不同的子集。  
事实上，对于任意一个集合$A$，还可以将其每个子集分别作为一个元素构成一个新的集合，由此得到如下幂集的概念：  
【定义1.9】假设$A$ 任意一个给定的集合，以$A$ 的所有不同子集为元素构成的集合称为$A$ 的幂集，记为$P(A)$或$2^{A}$，即有：  
$$
P(A)=\{B|B\subseteq A\}
$$  
对于以集合作为元素的集合，亦即集合的集合，通常称之为集族。由此可知，幂集其实就是一种特殊的集族。"
零元,概念,"['第十一章  抽象代数结构通论', '§ 11.2 代数结构的运算性质', '11.2.2 特殊元素']","{'实体类型': '概念', '定义': '与任意运算对象运算结果为自身的元素', '例子': '实数0（加法）、零矩阵（矩阵加法）、空集∅（集合并）'}",,3,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)"
零因子环,概念,"['第十二章 典型抽象代数结构', '§ 12.4 环和域的基本知识', '12.4.1  环的概念与性质']","{'实体类型': '概念', '定义': '存在两个非零元素乘积为零的环'}",,3,"我们知道，整数集合𝑍上具有加法$+$和乘法$\times$这两种运算，并且$\langle Z,+\rangle$是一个交换群、$\langle Z,\times\rangle$是一个半群，并且乘法对加法满足左、右分配律，即有：  
$$
a\times(b+c)=a\times b+a\times c;\ (b+c)\times a=b\times a+c a\times
$$  
由此可见，整数运算系统主要由两个运算子系统构成，即由一个基于加法运算的交换群和一个基于乘法运算的半群构成，并且乘法对加法满足分配律。  
将整数运算系统的上述性质进行抽象，就得到如果环代数结构的定义：  
【定义12.22】如果$\langle G,+,\times\rangle$是具有两个二元运算的代数系统，且满足：（1）$\langle G,+\rangle$是交换群；（2）$\langle G,\times\rangle$是半群；（3）$G$中的$\times$对$+$满足分配律。则称$\langle G,+,\times\rangle$是环代数结构或环代数系统，通常简称为环结构、环系统或环，并称$+$和$\times$分别为环中的加法和乘法。  
由上述定义可知，环结构由加法交换群和乘法半群这两个子结构组成，且满足乘法对加法的分配律。显然，代数系统$\langle Z,+,\times\rangle$就是一个环结构。  
此外，$\langle Q,+,\times\rangle,~\langle R,+,\times\rangle,~\langle C,+,\times\rangle$也都是环结构，其中$Q$是有理数集，$R$是实数集，$C$是复数集，分别称作整数环，有理数环，实数环和复数环。  
可根据构成环的群子结构或半群子结构的特点，对环结构做进一步的分类：  
【定义12.23】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果$\langle G,\times\rangle$是一个含幺半群，则称$\langle G,+,\times\rangle$是一个含幺环，如果$\langle G,\times\rangle$是一个交换半群，则称$\langle G,+,\times\rangle$是一个交换环，如果$\langle G,\times\rangle$是一个含幺交换半群，则称$\langle G,+,\times\rangle$是一个含幺交换环。  
为了叙述上的方便，通常将环中加法的单位元记作0，而将环中元素$x$关于加法的逆元称作$x$的负元，记作$-x$。如果环中乘法有单位元，就把这个单位元记作1，而将$ x$关于乘法的逆元（若存在的话）称为$x$的逆元，记作$:\!x^{-1}$。类似地，可用$x-y,$表示$ x+(-y)$，分别用$n x$和$x^{n}$表示$x$的加法和乘法$ n$次幂，即有：  
$$
n x=\underbrace{x+x+\cdots+x}_{n^{}个};\,\,\,x^{n}=\underbrace{x x\cdots x}_{n^{}个}
$$  
下面讨论环的基本性质。由环的定义可知，环中加法满足交换律、结合律，有单位元0  ，  
每个元素都有负元，环中乘法适合结合律，乘法对加法适合分配律。除此之外，我们进一步考察环的其它一些性质。首先考察环结构中加法逆元的性质：  
【定理12.28】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a,b\in G$，有：  
$$
-(a\times b)=a\times(-b)=(-a)\times b\quad\text{(12-20)}
$$  
下面考察环结构中加法单位元的性质：  
【定理12.29】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a\in G$，有：  
$$
a\times0=0\times a=0\quad\text{(12-21)}
$$  
上述定理12.29 表明，环结构中加法运算的单位元是乘法运算的零元，并且环中任二元素相乘，若其中至少有一个为零元，则乘积必为零元。但反之不然，因为在环中，两个非零元的乘积可能为零元，由此引出如下环结构中零因子的概念：  
【定义12.24】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果存在$G$中两个非零元素满足$a\cdot b=0$ ，称该环为含零因子环，元素 $a$ 和 $b$ 是其零因子，否则称该环为无零因子环。  
【定理12.30】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则$\langle G,+,\times\rangle$是无零因子环当且仅当于$\langle G,\times\rangle$满足消去律。  
由于环是由群和半群这两个子结构构成，故与群结构类似，环结构也存在子环、环同态的相关概念和理论。事实上，子环和环同态的概念和性质完全可以使用与群类似的思路进行讨论，这里不再赘述，读者可自行查阅环结构的相关资料深入学习。"
零图,概念,"['第八章  图的基本理论与算法', '§ 8.1 图的概念与表示', '8.1.2 图的定义与分类']","{'实体类型': '概念', '定义': '由孤立结点组成而没有边的图'}",,3,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)"
零流边,概念,"['第十章  特殊图模型与算法', '§ 10.4 网络流图及其优化问题', '10.4.1 流网络与切割']","{'实体类型': '概念', '定义': '满足f(u,v)=0的边'}",,3,"首先介绍流网络模型的相关基本概念及其数据描述。如同每条公路有运输量、每根水管有最大流量限制一样，网络流图的每条边都有容量，或者说每条边都有一定的流量。网络流图其实就是每条边具有附带容量（可理解为权值）的有向图。其具体定义如下：  
【定义10.4.1】设有向图$G=\langle V,E\rangle$，$V$中包含一个源结点𝑠和一个汇结点$t$，且每条边$(u,v)\in E$均有一个非负容量$c(u,v)\geq0$，若$(u,v)\notin E$，则规定其容量$c(u,v)=0$，此时称有向图$G$是一个网络流图，简称为流网络或网络。源结点$s$即起点，汇结点$t$即终点。网络流是定义在网络$G$中关于边的一个实函数，用$f(u,v)$表示有向边$(u,v)\in E$上结点$ u$到结点$v$的网络流。$f(u,v)$表示$u$ 到$v$的净流。  
例如，如果$_{u}$到$v$有6 个单位的实际流，且$v$到$u$有3 个单位的实际流，那么$f(u,v)=$3，$f(v,u)=-3$，互为相反数。净流是实际通过的流量矢量和，可类比合力的概念。  
满足以下三个性质的网络流$f$称之为可行流：  
（1）容量限制：对所有的$(u,v)\in E$，都有$f(u,v)\leq c(u,\textit{}v)$。即一条边的流不能超过它的容量。这也很容易理解，如同自来水管的水流自然不会超过水管本身的容量。  
（2）斜对称：对所有$(u,v)\in E$，都有$f(u,v)=-f(v,u)$。即点$\cdot u$到$v$的净流必须与点𝑣到$u$的净流相反。可以类比物理中矢量概念，如作用力与反作用力，强调的是其方向性。  
（3）流守恒：对所有$u\in V-\{s,t\}$，都有$\textstyle\sum_{v\in V}f(u,v)=0$。即除源结点$𝑠$和汇结点$𝑡$外，其余每个结点的净流之和为0。  
![图10-68 网络及可行流  ](images/bada5974bba3db0db4c82fa8e3076a8834542abfa1641f17fac232a32e6fee29.jpg)  
例如，如图10-68 所示，网络中定义网络流$f(u,v)$是一条可行流。图中每条边所对应的序偶表示该边的容量和流量，第一个数字表示边的容量，第二个数字表示边的流量。  
下面结合图10-68 所示网络实例介绍网络流模型中与边相关的几个概念。可根据边的容量与流的大小关系对网络中的边进行分类：  
（1）满足$f(u,v)=c(u,v)$的边称为饱和边，如边(1,2)、 (2,3)  
（2）满足$f(u,v)<c(u,v)$的边称为非饱和边，如边(2,4)。  
（3）满足 $f(u,v)=0$ 的边称为零流边，如边 (3,4) ；满足 $f(u,v)>0$ 的边称为非零流 边，如边(5,4)。  
（4）既不是零流边也不是饱和边的边，称为弱流边，如边(5,6)  
如果把图10-78 看作是一个公路网，6 个结点分别表示6 座城镇，每条边上的权数表示两城镇间的距离。若现在需要从起点1 将一些物资运送到终点6，应怎样选择路线才能使总运输距离最短。我们知道，这样一类问题称为最短路径问题。类似的，如果把图10-1看作为一个输油管道网，结点1表示为发送点，结点6表示为接收点，其它点表示为中转站，各边的权数表示该段管道的最大运输油量。那么如何安排输油线路才能使从1到6的总运输量最大。这样一类问题就是最大流问题。  
最大流问题是网络优化中的一个典型的问题，简单地说，就是在满足容量约束的前提下将尽可能多的流从源结点流向汇结点。因此，最大流问题就是求流网络$G$中使其流量$f$达到最大的一个可行流，该可行流即为最大流。具体定义如下：  
【定义10.4.2】设有向图$G=\langle V,E\rangle$是任意给定的一个网络流图，若$f$是$G$ 中流量最大的的可行流，则称该可行流$f$是$G$ 的最大流，构构造网络流图$G$ 中最大流的问题，就称为网络流图的最大流问题。  
为了实现对最大流问题的求解，必须对网络流图中的增流空间进行合理的度量，通常使用一种名为残留网络的图模型实现这项工作。残留网络的具体定义如下：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图， $f$为$G$的一个流，对于$G$的任意一条边$(u,v)$，在不超过容量$c(u,v)$条件下，从$u$到$v$可压入的额外流量，称为$(u,v)$的残留容量。由$G$中所有边残留容量构成的带权有向图称为$G$的残留网络，记为$G_{f}=\langle V,E_{f}\rangle$。  
若$c_{f}(u,v)$为残留网络$G_{f}$中边$(u,v)$的残留容量，且边$(u,v)\in E$或边$(v,u)\in E$，则$(u,v)\in$$E_{f}$,$\,c_{f}(u,v)=c(u,v)-f(u,v)\,$。例如，若设$(u,v)$当前流量为(4,3)，此时$c(u,v)=4$，$f(u,v)$）$=3$，则有：$c_{f}(u,v)=1$。  
需要注意的是，残留网络具有这样的性质：假设从$_{.}u$到$v$已经有了3 个单位流量，那么从反方向上看，也就是从$v$ 到$u$ 就有了3 个单位的残留容量，这时$c_{f}(v,u)=3$。换句话说，从$u$ 到$v$ 有3 个单位流量，那么从$v$到$u$ 就有了将这3 个单位流量压回去的能力。因此，残留网络结点之间通常由双向带权边进行联结。例如，对于图10-69（a）所示的一个流网络$G$，图10-69（b）则表示该流网络𝐺的残留网络。  
![图10-69 流网络及其残留网络 ](images/d65d1c72064671125468548ae171a28ede5424f1d36d601972ed76c90131fc8c.jpg)  
对于任意给定的一个网络流图$G=\langle V,E\rangle$，可以通过其残留网络$G_{f}=\langle V,E_{f}\rangle$求得$G$的最大流。基本思路如下：首先，对所有的结点令初始状态时流的值为0，即对于$\forall u,v\in V$，有$f(u,v)=0$。然后，通过迭代方式其残留网络中不断寻找源点𝑠到汇点$t$之间的流量增广路径来增加网络流量值，直到残留网络没有这样的增广路径为止。  
因此，在残留网络$G_{f}=\langle V,E_{f}\rangle$寻找流量增广路径是最大流求解算法的关键。为正确理解该算法，现给出流网络增广路径的具体定义：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，$G_{f}=\langle V,E_{f}\rangle$为$G$在流$f$下的一个残留网络，则$G_{f}=\langle V,E_{f}\rangle$中任意一条从源点$s$到汇点$t$的简单路径$p$称为$G=\langle V,E\rangle$的一条流量增广路径，简称为增广路径。  
事实上，可将增广路径形象地理解为网络流图$G$中从源点𝑠到汇点𝑡的一条不违反流网络边容量限制的路径，并向这条路径压入一定的流量，以增加整个网络的流量值。例如，图10-69（b）所示的残留网络存在这样一条如图10-70 中加粗有向边所示的增广路径。  
![图10-70 增广路径 ](images/1e52dc98ce8f5b49283b093dbb72c0d5308ccdc9782306a98cb168474d58608f.jpg)  
![图10-71 流网络的一个切割](images/c52dd38b6f7d2bc46bb57e2440709d67355577a7b3d5fb2e920f10a5bfeb8598.jpg)  
若将图10-70 所示增广路径在流网络所对应每条边的流量增加4 个单位，得到一个新的流网络，其流量比原网络多4 个单位。然后，在新流网络所对应的残留网络中继续寻找新增广路径，直到找不到新增广路径为止。显然，现在的问题是：如果在残留网络$G_{f}=$$\langle V,E_{f}\rangle$中找不到增广路径，此时该残留网络所对应的流$f$是否就是流网络$G=\langle V,E\rangle$的最大流？要解决这个问题，必须进一步引入流网络切割的相关概念，具体如下：  
【定义10.4.4】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，如果将$G$的结点集合𝑉划分为𝑆和$T=V-S$两部分，使得源点$s\in S$且$t\in T$，则称$(S,T)$是$G=\langle V,E\rangle$的一个切割，简称为割。从集合 𝑆 到集合 𝑇 的所有有向边容量之和称为切割 $(S,T)$ 的容量，穿过切割 $(S,T)$所有边流量的代数和流量称为切割$(S,T)$的净流量，记为$f(S,T)$。  
主要注意的是，定义10.4.4 中边的流量带有正负方向，如果流从结点𝑆流向$T$，则该边的流量值为正，如果流从结点𝑇流向𝑆，则该边的流量值为负。例如，对图10-69（a）所示的流网络，可画一个如图10-71 所示的切割$(S,T)$，其容量为：  
$$
c(u,w)+c(v,x)=12+14=26
$$  
穿过该切割的净流量为：  
$$
f(u,w)+f(v,x)-f(w,v)=12+11-4=19
$$  
显然，对于任意一个切割，穿过该切割的净流量上界就是该切割的容量，即穿过切割的净流量不可能超过割的容量。由于流网络中所有切割的流都相等并且等于网络的流，因此，网络最大流必然无法超过网络的最小割。由此得到如下最大流最小割定理：  
【定理10.4.1】（最大流最小割定理）设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和$t$分别为其源点和汇点，则$G=\langle V,E\rangle$的最大流量等于其最小割切的容量。对于$G=\langle V,E\rangle$上的任意一个流$f$，以下三个结论彼此等价：  
(1) $f$是流网络$G=\langle V,E\rangle$的一个最大流；  
(2) 流网络$G=\langle V,E\rangle$的残留网络中不包括任何增广路径；  
(3) 存在流网络$G=\langle V,E\rangle$的某个切割$(S,T)$，满足：
$$
f(S,T)=c(S,T)
$$"
霍夫曼算法,算法,"['第九章  树的基本理论与算法', '§ 9.2 根树的基本知识', '9.2.3  前缀码与最优树']","{'实体类型': '算法', '定义': '一种构造最优树的算法，基本思路是将问题转化为画一棵带有t-1个权的最优树，依次类推', '应用': '构造最优树，用于高效编码', '步骤': '（1）初始：令S={w1,w2,⋯};（2）从S中取出两个最小的权wi和wj，画结点vi，带权wi，画结点vj，带权wj。画vi和vj的父亲v，连接vi和v，vj和v，令v带权wi+wj;（3）令S=(S-{wi,wj})∪{wi+wj};（4）判断S是否只含一个元素。若是，则停止，否则转（2）'}",,3,"在计算机及通信技术中，常用二进制编码来表示符号，称之为码字。例如，可用00、01、10、11 分别表示字母A、B、C、D。如果字母A、B、C、D 出现的频率是一样的，则传输100 个字母会使用200 个二进制位。但实际上字母出现的频率很不一样，比如A 出现的频率为$60\%$，B 出现的频率为$25\%$，C 出现的频率为$10\%$，D 出现的频率为$5\%$。能否用不等长的二进制序列表示字母A、B、C、D，使传输的信息的二进制位尽可能少呢？  
事实上，可用000 表示字母D，用001 表示字母C，01 表示B，1 表示A。此时，传输100 个字母所用的二进制位为：  
$$
3\times5+3\times10+2\times25+1\times60=155
$$  
这种表示比用等长的二进制序列表示法好，节省了二进制位。  
在编码时还要考虑一个问题，就是二进制序列的分词问题。例如，如果用1 表示A，用00 表示B，用001 表示C，用000 表示D 时，那么在接收到信息001000 时，则无法辨别它是CD 还是BAD。因此，在使用二进制序列表示A、B、C、D 等字母时，需要一些特定的编码策略以避免出现类似容易混淆的情况。为此引入如下前缀及前缀码的概念：  
【定义9.9】设$a_{1}a_{2}\cdots a_{n-1}a_{n}$是长度为$n$的符号串，则称其子串$a_{1},a_{1}a_{2},a_{1}a_{2}a_{3},\cdots\,,$,$a_{1}a_{2}\cdots a_{n-1}$分别为$a_{1}a_{2}\cdots a_{n-1}a_{n}$的长度为1，2，⋯，$n-1$的前缀。  
【定义9.10】设$A=\{b_{1},b_{2},\cdots,b_{m}\}$是一个符号串集合，若对任意$b_{i}$，$b_{j}\in A$，$b_{i}\neq$$b_{j}$，$b_{i}$不是$.b_{j}$的前缀，$b_{j}$也不是$b_{i}$的前缀，则称𝐴为前缀码。若在符号串$b_{i}\bigl(i=1,2,\cdots,\ \mathsf{m}\bigr)$中，只出现0 和1 两个符号，则称𝐴为二元前缀码,在不引起混淆时简称为前缀码。  
例如{1，01，001，000}是前缀码，而{1，11，001，0011}不是前缀码。那么如何产生前缀码呢？事实上，可用一棵二元树来产生一个二元前缀码：  
给定一棵有𝑡片叶二元树𝑇。设$v$是𝑇的任一分支点，则$v$至少一个儿子至多两个儿子。若𝑣有两个儿子，则在由𝑣引出的两条边上，左边的标0，右边的标1；若$v$只有一个儿子，在$v$引出的边上可标0 也可标1。设${v}_{i}$为𝑇的任意一片叶，从树根到$v_{i}$的通路上各边的标号组成的符号串放在$v_{i}$处，$t$片叶处的𝑡个符号串组成的集合为一个二元前缀码。  
由上述做法可知，$v_{i}$中符号串的前缀码均在${v}_{i}$所在通路上，因而所得集合为0 和1 组成前缀码。显然，若𝑇存在带一个儿子的分支点，则𝑇产生不唯一的前缀码， 𝑇若为二元完全树，则𝑇产生唯一的前缀码。例如，图9-26 所示二元树产生的前缀码为：  
![](images/0e364ce62d589d6e701c3aee01259a3ff2b2c5a6aebc38eaf711e5ecde762552.jpg)  
![](images/c850aef1e068c66827fea6f4c98a09846df47e5a769a3618a27f7a6bb63e479e.jpg)  
【定义9.11】设有一棵二元树𝑇，若对其所以的𝑡片叶赋以权值$w_{1},w_{2},\cdots,w_{t}$，则称之为赋权二元树；若权为$w_{i}$的叶的层数为$L(w_{i})$，则称：  
$$
w(T)=\sum_{i=1}^{t}w_{i}\times L(w_{i})
$$  
为该赋权二元树 𝑇 的权；   $w(T)$ 最小的二元树称为最优树。  
下面的定理9.7 给出了构造最优树的一个基本思路：  
【定理9.7】假设𝑇是一棵带有权值为$|w_{1}\leq w_{2}\leq\cdots\leq w_{t}$二元最优树。其中权$w_{1}$和$w_{2}$所对应叶结点必定是兄弟，并且如果将其父结点由分支结点改为带权$w_{1}+w_{2}$的叶结点，则由此得到的一棵新树$T^{\prime}$也是一棵最优树。  
根据上述定理，美国计算机科学家霍夫曼在1952 年提出一种构造最优树的算法，通常称之为霍夫曼算法。对于任意给定的权值 $w_{1}\leq w_{2}\leq\cdots\leq w_{t}$，算法的基本思路是：要画一棵带有$t$个权的最优树，则可依据定理9.7 将问题转化为要画一棵带有𝑡−1个权的最优树，依次类推.具体做法是：首先找出两个最小的权值设为$w_{1}$和$w_{2}$，然后对𝑡−1个权$w_{1}+$$w_{2},w_{3},\cdots,w_{t}$求作最优树，并将这棵最优树中权$w_{1}+w_{2}$对应的叶结点分叉出两个儿子，依次类推，直到只有一个权值的最优树的情形.具体算法过程如下：  
（1）初始：令${\cal{S}}=\{w_{1},w_{2},\cdots,\}$ ;  
（2）从𝑆中取出两个最小的权$w_{i}$和$w_{j}$，画结点$v_{i}$，带权$w_{i}$，画结点$v_{j}$，带权$w_{j}$。画$v_{i}$和$v_{j}$的父亲$v$，连接$v_{i}$和$v$，$v_{j}$和$v$，令$v$带权$.w_{i}+w_{j}$；  
（3）令$S=\left(S-\left\{w_{i},w_{j}\right\}\right)\cup\{w_{i}+w_{j}\};$  
（4）判断𝑆是否只含一个元素。若是，则停止，否则转（2）。  
从上述算法过程可以看出，霍夫曼算法采用递推的方式构造最优树，核心思想是逐步从从带权为$w_{1}+w_{2},w_{3},\cdots,w_{t}$的最优树${T^{\prime}}$中得到带权为$w_{1}$，$w_{2}$，⋯，$w_{t}$的最优树。  
下面结合具体实例介绍最优树的具体构造过程："
霍尔婚姻定理,定理,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.2.2 完备匹配与最大匹配']","{'实体类型': '定理', '条件': '二分图G存在X-完备匹配的充分必要条件是X中任意k个结点至少与Y中k个结点相邻', '应用': '判断二分图是否存在X-完备匹配'}",,3,"首先考察一个有趣的问题：假设在某个小型舞会上有5 名男士和5 名女士，其中某些男士与某些女士之间相互认识，问如何安排才能使得相互认识的男生和女士人成为舞伴。  
可用如图10-30（a）所示的二分图模型$G=\langle X,E,Y\rangle$表示上述舞伴配对问题，其中结点集合$X=\{x_{1},x_{2},x_{3},x_{4},x_{5}\}$和$Y=\{y_{1},y_{2},y_{3},y_{4},y_{5}\}$分别表示5 名男士和5 名女士构成的集合，图中有无向边$(x_{i},y_{j})$当且仅当男士$x_{i}$与女士$y_{j}$相互认识。  
![图10-30  舞伴的安排问题 ](images/e92b7888a1cc6a1b77006b78c8c42919c89a7e806394091bb76e5c5538b07826.jpg)  
通过观察，不难得到如图10-30（b）中实线边所示的一种安排方案。由于每个人最多只能与一个异性匹配成舞伴，故所得到的安排方案其实就是图$G=\langle X,E,Y\rangle$中5 条不相邻边组成的$E$的子集：$M=\{(x_{1},y_{3}),(x_{2},y_{1}),(x_{3},y_{2}),(x_{4},y_{5}),(x_{5},y_{4})\}_{\circ}$。  
不难看出，上述问题其实就是在两类不同性质的对象之间寻找某种配对或者匹配的问题。事实上，日常生活和工作中的很多问题，例如学生选课、工作任务安排等等，都可以归结为这种匹配问题。对上述实例进行抽象，得到如下匹配的相关概念：  
【定义10.4】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，图中互不相邻的边构成$.E$的子集$M$称为$G$的一个匹配，$G$中与$M$中的边关联的结点称为匹配$M$的饱和结点。如果$X$中每个结点都是某个匹配的饱和结点，则称该匹配为$G$的一个$X^{.}$-完备匹配；如果𝑌中每个结点都是某个匹配的饱和结点，则称该匹配为$G$的一个𝑌-完备匹配；如果$G$的某个匹配既是$X-$完备匹配，又是𝑌-完备匹配，则称该匹配为完备匹配。$G$中基数最大的匹配称为𝐺的最大匹配，最大匹配中的边数称为$G$的匹配数，记作$\alpha^{\prime}(G)$。  
由定义10.4 可知，二分图的$X^{-}$完备匹配、$Y-$完备匹配和完备匹配肯定是最大匹配，反之不然，最大匹配不一定是$X-$完备匹配、$Y-$完备匹配或完备匹配。对于任意一个给定的二分图，其最大匹配总是存在，但其$X{-}$完备匹配、$Y-$完备匹配或完备匹配不一定存在。如果一个二分图存在完备匹配，则必有$|X|=|Y|$，反之不然。  
![图10-31  二分图及其最大匹配  ](images/426797d69400c6077f0021e199ce3acdf2169381fe7ee70516dbf26e96f0ac68.jpg)  
例如，对于图10-31（a）所示的二分图，图10-31（b）所示的全部实线边构成的集合：  
$$
M=\{(x_{1},y_{3}),(x_{2},y_{1}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
是该二分图的一个最大匹配。该匹配显然不是$X^{-}$完备匹配、$Y-$完备匹配或完备匹配，因为$x_{4}$和$y_{4}$均是其非饱和点。再如，图10-30（b）中实线边所示的匹配显然是一个完备匹配，自然也是最大匹配。  
下面考察对于一个给定的二分图$G=\langle X,E,Y\rangle$，当$G$满足什么条件时存在完备匹配。这里仅讨论$X^{-}$完备匹配的情形，至于$Y-$完备匹配和完备匹配的情况，可类似讨论。  
首先给出著名的霍尔婚姻定理，该定理给出了二分图$G=\langle X,E,Y\rangle$存在$X^{-}$完备匹配的一个充分必要条件，具体如下：  
【定理10.8】（霍尔婚姻定理）设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，则$G$存在$X^{-}$完备匹配的充分必要条件是$X$中任意$k$个结点至少与𝑌中$k$个结点相邻。具体地说，就是对于$\forall S\subseteq X$，有$|S|\leq|\mathsf{N}(\mathsf{S})|$，其中N(S)表示𝑌中所有与S中结点相邻的结点组成的集合。  
![图10-32  $X$-完备匹配存在性的判定](images/e5661ccfd2ab0df27e3feadf55016324a2bdd2f775f9de7183f592d16a209926.jpg)  
例如，图10-32（a）所示二分图满足霍尔婚姻定理的条件，故存在$X^{-}$完备匹配，图$10-$32（b）所示二分图不满足霍尔婚姻定理的条件，故不存在$X^{-}$完备匹配。  
定理10.8 中需要计算𝑋中所有子集在𝑌中邻接结点的集合，在很多情况下计算量很大，不便使用。为此，下面给出一个名为$t-$条件的充分条件，具体如下：  
【定理10.9】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，如果$G$满足：$X$中每个结点至少关联t-条边且𝑌中每个结点至多关联$t^{-}$条边，则图$G$一定存在$X^{-}$完备匹配。  
判断𝑡条件非常简单，只需计算$X$中结点最小度$\delta(X)$和$\Delta(Y)$中结点最大度$\Delta$即可。例如，对于图10-32（a）所示二分图，显然有$\delta(X)=\Delta(Y)=2=t$，故存在$X{-}$完备匹配。"
非对称加密算法,算法,['第二章  整数与算法设计基础'],"{'实体类型': '算法', '基础': '基于整数模余运算理论', '成功应用': '20世纪70年代取得成功应用'}",,1,"整数作为一种最基本的离散量和离散结构不仅是离散数学的研究对象，而且其自身也是研究其它离散结构的一项基本工具，在离散量的度量、计数和算法设计等方面发挥重要的基础性作用。整数是人类最早认识和使用的数，专门研究整数及其性质的整数理论是一个具有几千年历史的非常古老的数学分支。在很长一段时期内，整数理论被认为仅仅是思想的体操、数学思维能力的训练工具，其实用性并没有得到充分重视。著名数学家数学王子高斯就曾给出这样的评价：如果说数学是科学的皇后，那么整数理论则是皇后头上美丽的皇冠。意指其仅仅是漂亮而不够实用。直到20 世纪70 年代基于整数模余运算理论的非对称加密算法被设计出来并取得成功应用，整数理论的实用性才得到广泛重视。事实上，算法概念正是诞生于整数的算术运算，这使得整数理论与计算机算法有着一种天然的紧密联系。计算机学科的诞生与兴起让整数理论这门古老的学科重新焕发出新的生命并得到蓬勃发展。目前，整数理论已经成为算法设计与算法度量的一项基本工具，在散列函数构造、伪随机数生成、信息编码与加密等多个领域得到广泛应用。其实除整数之外，离散数学中很多其它离散结构模型，例如图模型、关系模型、群代数结构模型等，也都是通过相关算法在计算机领域发挥重要作用。因此，算法设计技术是学习与应用离散数学所必备的基本知识。  
综上所述，作为学习离散数学的另一入门基础，本章比较系统地介绍整数理论与算法设计的基本知识，具体包括整除的基本概念与运算性质、模余运算的基础知识、同余方程及其解法、非对称加密算法、算法设计的基本知识、算法设计的基本策略与应用等。"
非平凡逻辑运算联结词,概念,"['第三章  命题演算与推理', '§ 3.3 联结词的完备集', '3.3.1  联结词的枚举']","{'实体类型': '概念', '定义': '不能通过其他联结词表达的逻辑运算联结词', '数量': '一元逻辑运算联结词有1个，二元逻辑运算联结词有9个'}",,3,"不难看出，每个运算联结词分别对应一个命题公式，且彼此不同的运算联结词所对应的命题公式也互不相同。尽管可以通过命题公式的定义构造出无穷多个形态各异的命题公式，但是这些命题公式中有很多是彼此等值的。因此，如果我们将彼此等值命题公式视为同一种类型并且能够计算出类型的数目，那么命题运算联结词的枚举问题便迎刃而解。  
对于任意一个含有$\cdot_{n}$个命题变量的命题公式，都可以将它看成是一个由这$n$个变量为自变量的𝑛元函数。显然，每个自变量的取值以及函数值的取值均为{真，假}或{0, 1}，故有如下𝑛元真值函数的相关定义：  
【定义3.17】假设𝐺是一个含有$\cdot_{n}$个命题变元的命题公式，则称𝐺是一个$\mathbfit{n}$元真值函数。在所有的$n$元真值函数中，将相互等值的真值函数归为一类，并从每个类中分别选取一个$_{n}$元真值函数作为该的类代表，称这种具有代表性质的真值函数为$\mathbfit{n}$元真值函项。  
显然，$n$元真值函数的种类数就是$n$元真值函项的个数。因此，下面着重考察如何对n 元真值函项进行计数和枚举。  
对于一元真值函数$G(P)$，它只含有一个命题变元𝑃。由于$P$只有$T$和$F$两种取值状态且对于每种状态，$G(P)$都只有$T$和$F$两种不同取值方式，由计数的乘法原理知，$G(P)$有且仅有有4 种不同的表现形式，如表3-13 所示。  
表3-13  一元真值函数
![](images/7e299ca38127d46167de49648c7ba3b93226e9a0d0de2bd6d7016fad80f5bc00.jpg)  
从表3-13 中可以看出，一元真值函数$G(P)$有且仅有4 种不同类型。由此可以得到如下全部四个不同的一元真值函项：  
$$
G_{1}(P)\Leftrightarrow T;\,\,\,G_{2}(P)\Leftrightarrow P;\,\,\,G_{3}(P)\Leftrightarrow\neg P\,;\,\,\,\,\,G_{4}(P)\Leftrightarrow F
$$  
由此可见，非平凡的一元逻辑运算联结词只有$\neg$运算，即 $G_{3}(P)=\neg P$  
下面考察二元真值函数$G(P,Q)$：由于每个命题变量分别取T和F两种状态，故$P$与$Q$的取值状态组合数为4。对于$\cdot P$与$Q$每一种组合状态，$G(P,Q)$都有$T$和$F$这两种取值状态，由计数的乘法原理知，$G(P,Q)$有且仅有有$2^{4}{=}16$ 种不同表现形式，如表3-14 所示。  
![](images/07f980b35eb2afa32c89cb472f39cdcc1aa211c2d1dac882499a493bebe3a0fa.jpg)  
从表3-14 中可以看出，二元真值函数$G(P,Q)$有且仅有16 种不同类型。由此可以得到如下全部16 个不同的二元真值函项：  
$G_{1}(P,Q)\Leftrightarrow P\land\lnot P;\,\,\,G_{2}(P,Q)\Leftrightarrow P\land Q;\,\,\,G_{3}(P,Q)\Leftrightarrow\lnot(P\to Q)\,;\quad G_{4}(P,Q)\Leftrightarrow P\,;$ $G_{5}(P,Q)\Leftrightarrow\neg(Q\to P);\;\;G_{6}(P,Q)\Leftrightarrow Q;\;\;G_{7}(P,Q)\Leftrightarrow\neg(P\leftrightarrow Q);\quad G_{8}(P,Q)\Leftrightarrow P\lor Q;$ $G_{9}(P,Q)\Leftrightarrow\neg(P\vee Q);\;\;G_{10}(P,Q)\Leftrightarrow P\leftrightarrow Q;\;\;G_{11}(P,Q)\Leftrightarrow\neg Q;\quad G_{12}(P,Q)\Leftrightarrow Q\rightarrow P$ $G_{13}(P,Q)\Leftrightarrow\neg P;\;\;G_{14}(P,Q)\Leftrightarrow P\rightarrow Q;\;\;G_{15}(P,Q)\Leftrightarrow\neg(P\wedge Q);\quad\;G_{16}(P,Q)\Leftrightarrow P\vee\neg P$  
由此可见，非平凡二元逻辑运算联结词一共有9 个，除了前面已学的5 个常用联结词$\neg，\wedge，\vee，\rightarrow，\leftrightarrow$之外，还有如下4 个新的运算联结词，即：$\overline{{\mathsf{V}}}\,,\,\nrightarrow\,\uparrow\,,\,\downarrow$。这4 种联结词的真值取值规则如表3-15 和表3-16 所示。  
表3-15  4 种新联结词的含义与表示
![](images/06836354c54edf7769126bc450a894d316d020c9711d3c09afa06457b363815b.jpg)  
表3-16  4 种新联结词的真值
![](images/731846b634a2ef84c0898fbd837a1e716d721d529b86c9bb6916ff3a66582dbc.jpg)  
由表3-15 和表3-16 真可知：  
$P\;{\overline{{\lor}}}\;Q\Leftrightarrow\neg(P\leftrightarrow Q)\colon\;P\nrightarrow Q\Leftrightarrow\neg(P\rightarrow Q)\colon\;P\uparrow Q\Leftrightarrow\neg(P\wedge Q)\colon\;P\downarrow Q\Leftrightarrow\neg(P\vee Q)$  
对于一般$_{n}$元真值函数$G(P_{1},P_{2},\cdots,P_{n})$，其$.n$个命题变量$P_{1},P_{2},\cdots,P_{n}$的取值状态组合数为$2^{n}$。对于每个取值状态的组合，$G(P_{1},P_{2},\cdots,P_{n})$均有$T$和$F$这两种取值。因此，$G(P_{1},P_{2},\cdots,P_{n})$有且仅有$2^{2^{n}}$种不同表现形式，即有且仅有$\cdot2^{2^{n}}$个$_{n}$元真值函项。例如，当$n=3$时，有且仅有$2^{8}{=}256$ 个真值函项，由此可得到所有非平凡三元逻辑运算联结词，具体不再赘述。"
非等值型范式,概念,"['二、无∃型前束范式', '§ 4.3 谓词公式的范式', '第四章  谓词演算与推理', '4.3.2 非等值型范式']","{'实体类型': '概念', '特点': '不需要等值演算', '应用': '判断公式是否为永真式或矛盾式', '定义': '一种特殊的谓词公式范式'}",,3,前束范式虽然能够与原谓词公式等值，但是这种范式中的量词的排列不够规整。在谓词逻辑演算或推理中，有时候只需要判断某个公式是否为永真式或者矛盾式，此时并不一定需要等值演算，可以牺牲等值的要求得到一些量词排列更加规整的前束公式或前束范式。例如，可以要求谓词公式中所有存在量词排在所有全称量词的左边，或者保留所有的全称量词而消去所有的存在量词，这些都是所谓斯科伦范式或斯科伦标准型的由来。本小节简要介绍两种基本的斯科伦标准型，即∃型前束范式和无∃型前束范式。
非连通图,概念,"['第八章  图的基本理论与算法', '§ 8.2 图的运算与结构', '8.3.3  无向图的连通性']","{'实体类型': '概念', '定义': '无向图中存在至少一对结点不连通的图'}",,3,"前面我们学习了图的可达性概念及其判定，其描述的是图中两个结点之间是否可以通过一条或者多条通路进行联结，并从图的局部角度分别考察两个结点之间的连通关系。现在我  
们从全局性角度考察整个图中多个结点之间的连通关系，将两个结点之间的可达性概念推广到整个图中任意两个结点之间的可达性，由此得到图的连通性和连通图的相关概念。  
在图的连通性方面，无向图和有向图之间具有很大的差异。因此，我们分别讨论无向图和有向图的连通性。本小节主要介绍和讨论无向图连通性的概念与性质。首先给出无向图连通图的相关概念，具体定义如下：  
【定义8.25】设 $G=\langle V,E\rangle$ 为任一给定的无向图，对于图中的两个结点$v_{i}$ 与 $v_{j}$，如果从$\boldsymbol{v}_{i}$到$v_{j}$是可达的，则称从 $v_{i}$ 到 $v_{j}$是连通的，表示为[ $v_{i}\ \ ,v_{j}]$。规定图中任何结点与其自身是连通的。如果无向图$G$中任何两个结点之间都是连通的，则称该图为无向连通图或连通无向图，简称为连通图；否则，称$G$ 是非连通无向图，简称为非连通图。  
显然，无向图中两个结点之间的连通性是双向的，也就是说两结点之间的连通关系满足对称性，即：若有$v_{i}$ 到 $v_{j}$可达则必有$v_{j}$ 到 $v_{i}$可达。故在无向图中，也可将从${v}_{i}$ 到 $v_{j}$的连通说成$v_{i}$ 与 $v_{j}$连通。另外，注意到平凡图有且只有一个结点，根据无向图中结点连通性的规定，它是一种特殊的连通图。  
下面的定理表明，无向图模型中结点之间的连通性关系是一个等价关系：  
【定理8.7】设 $G=\langle V,E\rangle$ 为任一给定的无向图，其结点集为 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，令$R$ 是集合$\cdot V=\{v_{1},v_{2},\ldots,v_{n}\}$上结点之间的连通关系，即有：  
$R=\{\langle u,v\rangle|u,v\in V\}$, 且从$u$到𝑣连通}       （8-10）  
则$R$是集合𝑉上的一个等价关系。  
既然无向图模型中结点之间的连通性关系$R$是一个等价关系，那么就可以使用等价关系$R$ 将无向图 $G$ 的结点集合 𝑉 划分为若干互不相同的等价类，记为   $V_{1},V_{2},\ldots,V_{k}$ 。在这些等价类 中，相互连通的结点属于同一个等价类，不连通的结点属于不同的等价类。由此得到无向图模型的连通分支的概念，具体定义如下：  
【定义8.26】设 $G=\langle V,E\rangle$ 为任一给定的无向图$R$是图$G$结点集合𝑉上的连通性关系，则以关系𝑅的每个等价类为结点集的导出子图都称为图$G$的一个连通分支，并用$p(\mathbf G)$表示图𝐺的连通分支总数。  
由上述定义可知，如果无向图$G=\langle V,E\rangle$的结点连通性关系$R$作为一个等价关系，将结点集𝑉划分为$k$个不同的等价类$V_{1},V_{2},\ldots,V_{k}$，则由它们导出的子图$G(V_{1}),G(V_{2}),\cdots,G(V_{k})$均为图$G$的连通分支。因此，可以根据无向图中结点之间的连通关系实现对图模型的一个分解。显然，若   $p(G)=1$ ，则 $G$ 是连通图。若   $p(G)>1$ ，则   $G$ 是非连通图。  
【定义8.27】对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在结点集𝑉的某个子集 $V^{\prime}\subseteq$$V$ ，使得 $p(G-V^{\prime})>p(G)$ ，且对于 $V^{\prime}$的任何真子集 $V^{\prime\prime}$，有 $p(G-V^{\prime\prime})=p(G)$，则称 $V^{\prime}$为 $G$ 的点割集。如果点割集中只有一个结点 $v$ ，则称 $v$ 为割点。  
由上述定义可知，可通过删除图中适当结点以破坏图结构的方式考察图的连通程度。图中有些结点组成的集合在图的连通性中起着非常关键的作用，删除这些结点后会使得连通图变成非连通图，使得非连通图变得更加不连通，或者增加连通分支的数目。  
显然，对图中的任意一个点割集，该集合中所有结点都是由该点割集增加连通分支时必须同时删除的结点。例如在图8-40 所示的图$G_{1}$中，集合$\{v_{4}\},\{v_{1},v_{3}\}$都是点割集，但$\{v_{1},v_{3},v_{4}\}$则不是点割集，因为要增加图$G_{1}$的连通分支，不必同时删除结点$v_{1},v_{3},v_{4}$。  
需要注意的是，由于删除割点后，割点的邻接边也需要删除，因此我们用虚线表示已删除的边或者结点。同样，对下文所要介绍的边割集也做类似处理。  
同样，可以通过删除图中适当的边以破坏图结构的方式考察图模型的连通程度，由此可以得到边割集的相关概念，具体定义如下：  
【定义8.28】 对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在边集$E$的某个子集 $E^{\prime}\subseteq$$E$ ，使得 $p(G-\ E^{\prime})>p(G)$ ，且对于 $E^{\prime}$的任何真子集 $E^{\prime\prime}$，有 $p(G-\ E^{\prime\prime})=p(G)$，则称$V^{\prime}$为 $G$ 的边割集。如果点割集中只有一个条边  $e$ ，则称 $e$为割边或桥。  
![图8-42 例题8.24 图模型  ](images/6c126be3977ab4a2c63afc18255dc22be84fa010ee39891af7c0eba551970203.jpg)  
关于点割集与边割集，需要注意以下几个要点：  
（1）完全图 $K_{n}$ 无点割集，因为从 $K_{n}$ 中删除 $k\leq n-1$个顶点后，所得图仍然是连通的。  
（2）$n$ 阶零图既无点割集也无边割集。  
（3）对于连通图 $G$，$E^{\prime}$为 $G$ 的边割集，则必有 $p(G-E^{\prime})=2$ 。 因为删除一条边最多只能增加一个连通分支。  
（4）对于连通图 $G\ \ ,V^{\prime}$为 $G$ 的点割集，则 $p(G-V^{\prime})\geq2$，而且可能 $p(G-E^{\prime})>2$因为删除一个结点可能增加多个连通分支。  
从上述例题可以看出，对于任意给定的一个无向连通图，经常会有多个点割集或边割集，而且每个集合中所含元素的个数也不一样。此时，需要重点关注的应该是那些个数最小的集合。因为这些集合刻画了图连通结构中最为薄弱的环节，反映了连通图的最低连通程度。由此得到无向图连通图的点连通度与边连通度的概念，具体定义如下：  
【定义8.29】对于任意给定的一个无向连通图 $G=\langle V,E\rangle$，令：$\kappa(G){=}m i n\{|V^{\prime}||V^{\prime}$为G 的点割集}；$\lambda(\mathbf{G})=\operatorname*{min}\{|E^{\prime}||E^{\prime}$为G 的边割集} 并称 $\kappa(G)$ 为图 $G$ 的点连通度，$\lambda(G)$ 为图 $G$ 的边连通度。  
显然，点连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少结点数，边连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少边数。  
例如，对于图8-44 所示的无向连通图$G$ ，有$\kappa(G)=2$，$\lambda(G)=3$；对于图8-45 所示的彼得森图，有$\kappa(G)=\lambda(G)=3$。  
![图8-44 图的连通度  ](images/28f9ee3f26ab71faac7e5360d73417062a5a59d8421071b9feb627483727c42a.jpg)  
![图8-45  彼得森图  ](images/80ddd389b19bdc8904c989e51a73f2c183cb8c6f73b8b9c479ee3affcb66c7c0.jpg)  
关于无向连通图的点连通度$\kappa(G)$和边连通度$\lambda(\mathrm{G})$，需要注意以下几个要点：  
（1）如果 $G$是平凡图或非连通图，则规定 $\kappa(G)=\lambda(G)=0;$  
（2）如果$G$ 是完全图 $K_{n}$ ，由于 $G$ 中无点割集，当删除 $n-1$个顶点后，$G$ 为平凡图，故 $\kappa(G)=n-1$。  
（3）如果 $G$ 中存在割点，则 $\kappa(G)=1$；如果 $G$ 中存在割边，则 $\lambda(G)=1$。对于任何无向图 $G$ ，其点连通度 $\kappa$ 、边连通度 $\lambda$ 与结点最小度 δ 之间有如下关系：  
【定理8.8】对于任一无向图$G=\langle V,E\rangle$ ，均成立下列不等式：
$$
\kappa(G)\leq\lambda(G)\leq\delta\ (G)
$$"
非门,概念,"['第三章  命题演算与推理', '§ 3.6 命题逻辑的应用', '3.6.2 组合逻辑电路设计']",{'实体类型': '概念'},,3,"逻辑电路，又分为逻辑电路和时序逻辑电路。前者由最基本的“与门”、“或门”和“非门”电路组成，其输出值仅依赖于其输入变量的当前值，与输入变量的过去值无关—即不具记忆和存储功能；后者也由上述基本逻辑门电路组成，但存在反馈回路—它的输出值不仅依赖于输入变量的当前值， 也依赖于输入变量的过去值。 命题逻辑是组合逻辑电路设计的理论基础 和基本工具。如图3-10 所示，组合逻辑电路中的 “非门”、 “与门”、 “或门”，即为命题逻辑的“与”、“或”、“非”三种运算。通过利用这三种门，就可以构造出各种组合逻辑电路。  
![](images/e4f21b269b175874de7115f5156d6a3c1eb9e6666a1338dc9d4727bc0ca3ab30.jpg)
图3-10 基本类型的门  
“与门”和“或门”允许有多个输入，具有 $n$个输入的“与门”和“或门”如图3-11 所示。  
![](images/b8e3cbd2c8e7532c3d5f1acea4bd76306cd188918c6130d6354e264b174b34dc.jpg)
图3-11 具有 $n$ 个输入的门"
非零流边,概念,"['第十章  特殊图模型与算法', '§ 10.4 网络流图及其优化问题', '10.4.1 流网络与切割']","{'实体类型': '概念', '定义': '满足f(u,v)>0的边'}",,3,"首先介绍流网络模型的相关基本概念及其数据描述。如同每条公路有运输量、每根水管有最大流量限制一样，网络流图的每条边都有容量，或者说每条边都有一定的流量。网络流图其实就是每条边具有附带容量（可理解为权值）的有向图。其具体定义如下：  
【定义10.4.1】设有向图$G=\langle V,E\rangle$，$V$中包含一个源结点𝑠和一个汇结点$t$，且每条边$(u,v)\in E$均有一个非负容量$c(u,v)\geq0$，若$(u,v)\notin E$，则规定其容量$c(u,v)=0$，此时称有向图$G$是一个网络流图，简称为流网络或网络。源结点$s$即起点，汇结点$t$即终点。网络流是定义在网络$G$中关于边的一个实函数，用$f(u,v)$表示有向边$(u,v)\in E$上结点$ u$到结点$v$的网络流。$f(u,v)$表示$u$ 到$v$的净流。  
例如，如果$_{u}$到$v$有6 个单位的实际流，且$v$到$u$有3 个单位的实际流，那么$f(u,v)=$3，$f(v,u)=-3$，互为相反数。净流是实际通过的流量矢量和，可类比合力的概念。  
满足以下三个性质的网络流$f$称之为可行流：  
（1）容量限制：对所有的$(u,v)\in E$，都有$f(u,v)\leq c(u,\textit{}v)$。即一条边的流不能超过它的容量。这也很容易理解，如同自来水管的水流自然不会超过水管本身的容量。  
（2）斜对称：对所有$(u,v)\in E$，都有$f(u,v)=-f(v,u)$。即点$\cdot u$到$v$的净流必须与点𝑣到$u$的净流相反。可以类比物理中矢量概念，如作用力与反作用力，强调的是其方向性。  
（3）流守恒：对所有$u\in V-\{s,t\}$，都有$\textstyle\sum_{v\in V}f(u,v)=0$。即除源结点$𝑠$和汇结点$𝑡$外，其余每个结点的净流之和为0。  
![图10-68 网络及可行流  ](images/bada5974bba3db0db4c82fa8e3076a8834542abfa1641f17fac232a32e6fee29.jpg)  
例如，如图10-68 所示，网络中定义网络流$f(u,v)$是一条可行流。图中每条边所对应的序偶表示该边的容量和流量，第一个数字表示边的容量，第二个数字表示边的流量。  
下面结合图10-68 所示网络实例介绍网络流模型中与边相关的几个概念。可根据边的容量与流的大小关系对网络中的边进行分类：  
（1）满足$f(u,v)=c(u,v)$的边称为饱和边，如边(1,2)、 (2,3)  
（2）满足$f(u,v)<c(u,v)$的边称为非饱和边，如边(2,4)。  
（3）满足 $f(u,v)=0$ 的边称为零流边，如边 (3,4) ；满足 $f(u,v)>0$ 的边称为非零流 边，如边(5,4)。  
（4）既不是零流边也不是饱和边的边，称为弱流边，如边(5,6)  
如果把图10-78 看作是一个公路网，6 个结点分别表示6 座城镇，每条边上的权数表示两城镇间的距离。若现在需要从起点1 将一些物资运送到终点6，应怎样选择路线才能使总运输距离最短。我们知道，这样一类问题称为最短路径问题。类似的，如果把图10-1看作为一个输油管道网，结点1表示为发送点，结点6表示为接收点，其它点表示为中转站，各边的权数表示该段管道的最大运输油量。那么如何安排输油线路才能使从1到6的总运输量最大。这样一类问题就是最大流问题。  
最大流问题是网络优化中的一个典型的问题，简单地说，就是在满足容量约束的前提下将尽可能多的流从源结点流向汇结点。因此，最大流问题就是求流网络$G$中使其流量$f$达到最大的一个可行流，该可行流即为最大流。具体定义如下：  
【定义10.4.2】设有向图$G=\langle V,E\rangle$是任意给定的一个网络流图，若$f$是$G$ 中流量最大的的可行流，则称该可行流$f$是$G$ 的最大流，构构造网络流图$G$ 中最大流的问题，就称为网络流图的最大流问题。  
为了实现对最大流问题的求解，必须对网络流图中的增流空间进行合理的度量，通常使用一种名为残留网络的图模型实现这项工作。残留网络的具体定义如下：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图， $f$为$G$的一个流，对于$G$的任意一条边$(u,v)$，在不超过容量$c(u,v)$条件下，从$u$到$v$可压入的额外流量，称为$(u,v)$的残留容量。由$G$中所有边残留容量构成的带权有向图称为$G$的残留网络，记为$G_{f}=\langle V,E_{f}\rangle$。  
若$c_{f}(u,v)$为残留网络$G_{f}$中边$(u,v)$的残留容量，且边$(u,v)\in E$或边$(v,u)\in E$，则$(u,v)\in$$E_{f}$,$\,c_{f}(u,v)=c(u,v)-f(u,v)\,$。例如，若设$(u,v)$当前流量为(4,3)，此时$c(u,v)=4$，$f(u,v)$）$=3$，则有：$c_{f}(u,v)=1$。  
需要注意的是，残留网络具有这样的性质：假设从$_{.}u$到$v$已经有了3 个单位流量，那么从反方向上看，也就是从$v$ 到$u$ 就有了3 个单位的残留容量，这时$c_{f}(v,u)=3$。换句话说，从$u$ 到$v$ 有3 个单位流量，那么从$v$到$u$ 就有了将这3 个单位流量压回去的能力。因此，残留网络结点之间通常由双向带权边进行联结。例如，对于图10-69（a）所示的一个流网络$G$，图10-69（b）则表示该流网络𝐺的残留网络。  
![图10-69 流网络及其残留网络 ](images/d65d1c72064671125468548ae171a28ede5424f1d36d601972ed76c90131fc8c.jpg)  
对于任意给定的一个网络流图$G=\langle V,E\rangle$，可以通过其残留网络$G_{f}=\langle V,E_{f}\rangle$求得$G$的最大流。基本思路如下：首先，对所有的结点令初始状态时流的值为0，即对于$\forall u,v\in V$，有$f(u,v)=0$。然后，通过迭代方式其残留网络中不断寻找源点𝑠到汇点$t$之间的流量增广路径来增加网络流量值，直到残留网络没有这样的增广路径为止。  
因此，在残留网络$G_{f}=\langle V,E_{f}\rangle$寻找流量增广路径是最大流求解算法的关键。为正确理解该算法，现给出流网络增广路径的具体定义：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，$G_{f}=\langle V,E_{f}\rangle$为$G$在流$f$下的一个残留网络，则$G_{f}=\langle V,E_{f}\rangle$中任意一条从源点$s$到汇点$t$的简单路径$p$称为$G=\langle V,E\rangle$的一条流量增广路径，简称为增广路径。  
事实上，可将增广路径形象地理解为网络流图$G$中从源点𝑠到汇点𝑡的一条不违反流网络边容量限制的路径，并向这条路径压入一定的流量，以增加整个网络的流量值。例如，图10-69（b）所示的残留网络存在这样一条如图10-70 中加粗有向边所示的增广路径。  
![图10-70 增广路径 ](images/1e52dc98ce8f5b49283b093dbb72c0d5308ccdc9782306a98cb168474d58608f.jpg)  
![图10-71 流网络的一个切割](images/c52dd38b6f7d2bc46bb57e2440709d67355577a7b3d5fb2e920f10a5bfeb8598.jpg)  
若将图10-70 所示增广路径在流网络所对应每条边的流量增加4 个单位，得到一个新的流网络，其流量比原网络多4 个单位。然后，在新流网络所对应的残留网络中继续寻找新增广路径，直到找不到新增广路径为止。显然，现在的问题是：如果在残留网络$G_{f}=$$\langle V,E_{f}\rangle$中找不到增广路径，此时该残留网络所对应的流$f$是否就是流网络$G=\langle V,E\rangle$的最大流？要解决这个问题，必须进一步引入流网络切割的相关概念，具体如下：  
【定义10.4.4】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，如果将$G$的结点集合𝑉划分为𝑆和$T=V-S$两部分，使得源点$s\in S$且$t\in T$，则称$(S,T)$是$G=\langle V,E\rangle$的一个切割，简称为割。从集合 𝑆 到集合 𝑇 的所有有向边容量之和称为切割 $(S,T)$ 的容量，穿过切割 $(S,T)$所有边流量的代数和流量称为切割$(S,T)$的净流量，记为$f(S,T)$。  
主要注意的是，定义10.4.4 中边的流量带有正负方向，如果流从结点𝑆流向$T$，则该边的流量值为正，如果流从结点𝑇流向𝑆，则该边的流量值为负。例如，对图10-69（a）所示的流网络，可画一个如图10-71 所示的切割$(S,T)$，其容量为：  
$$
c(u,w)+c(v,x)=12+14=26
$$  
穿过该切割的净流量为：  
$$
f(u,w)+f(v,x)-f(w,v)=12+11-4=19
$$  
显然，对于任意一个切割，穿过该切割的净流量上界就是该切割的容量，即穿过切割的净流量不可能超过割的容量。由于流网络中所有切割的流都相等并且等于网络的流，因此，网络最大流必然无法超过网络的最小割。由此得到如下最大流最小割定理：  
【定理10.4.1】（最大流最小割定理）设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和$t$分别为其源点和汇点，则$G=\langle V,E\rangle$的最大流量等于其最小割切的容量。对于$G=\langle V,E\rangle$上的任意一个流$f$，以下三个结论彼此等价：  
(1) $f$是流网络$G=\langle V,E\rangle$的一个最大流；  
(2) 流网络$G=\langle V,E\rangle$的残留网络中不包括任何增广路径；  
(3) 存在流网络$G=\langle V,E\rangle$的某个切割$(S,T)$，满足：
$$
f(S,T)=c(S,T)
$$"
非饱和边,概念,"['第十章  特殊图模型与算法', '§ 10.4 网络流图及其优化问题', '10.4.1 流网络与切割']","{'实体类型': '概念', '定义': '满足f(u,v)<c(u,v)的边'}",,3,"首先介绍流网络模型的相关基本概念及其数据描述。如同每条公路有运输量、每根水管有最大流量限制一样，网络流图的每条边都有容量，或者说每条边都有一定的流量。网络流图其实就是每条边具有附带容量（可理解为权值）的有向图。其具体定义如下：  
【定义10.4.1】设有向图$G=\langle V,E\rangle$，$V$中包含一个源结点𝑠和一个汇结点$t$，且每条边$(u,v)\in E$均有一个非负容量$c(u,v)\geq0$，若$(u,v)\notin E$，则规定其容量$c(u,v)=0$，此时称有向图$G$是一个网络流图，简称为流网络或网络。源结点$s$即起点，汇结点$t$即终点。网络流是定义在网络$G$中关于边的一个实函数，用$f(u,v)$表示有向边$(u,v)\in E$上结点$ u$到结点$v$的网络流。$f(u,v)$表示$u$ 到$v$的净流。  
例如，如果$_{u}$到$v$有6 个单位的实际流，且$v$到$u$有3 个单位的实际流，那么$f(u,v)=$3，$f(v,u)=-3$，互为相反数。净流是实际通过的流量矢量和，可类比合力的概念。  
满足以下三个性质的网络流$f$称之为可行流：  
（1）容量限制：对所有的$(u,v)\in E$，都有$f(u,v)\leq c(u,\textit{}v)$。即一条边的流不能超过它的容量。这也很容易理解，如同自来水管的水流自然不会超过水管本身的容量。  
（2）斜对称：对所有$(u,v)\in E$，都有$f(u,v)=-f(v,u)$。即点$\cdot u$到$v$的净流必须与点𝑣到$u$的净流相反。可以类比物理中矢量概念，如作用力与反作用力，强调的是其方向性。  
（3）流守恒：对所有$u\in V-\{s,t\}$，都有$\textstyle\sum_{v\in V}f(u,v)=0$。即除源结点$𝑠$和汇结点$𝑡$外，其余每个结点的净流之和为0。  
![图10-68 网络及可行流  ](images/bada5974bba3db0db4c82fa8e3076a8834542abfa1641f17fac232a32e6fee29.jpg)  
例如，如图10-68 所示，网络中定义网络流$f(u,v)$是一条可行流。图中每条边所对应的序偶表示该边的容量和流量，第一个数字表示边的容量，第二个数字表示边的流量。  
下面结合图10-68 所示网络实例介绍网络流模型中与边相关的几个概念。可根据边的容量与流的大小关系对网络中的边进行分类：  
（1）满足$f(u,v)=c(u,v)$的边称为饱和边，如边(1,2)、 (2,3)  
（2）满足$f(u,v)<c(u,v)$的边称为非饱和边，如边(2,4)。  
（3）满足 $f(u,v)=0$ 的边称为零流边，如边 (3,4) ；满足 $f(u,v)>0$ 的边称为非零流 边，如边(5,4)。  
（4）既不是零流边也不是饱和边的边，称为弱流边，如边(5,6)  
如果把图10-78 看作是一个公路网，6 个结点分别表示6 座城镇，每条边上的权数表示两城镇间的距离。若现在需要从起点1 将一些物资运送到终点6，应怎样选择路线才能使总运输距离最短。我们知道，这样一类问题称为最短路径问题。类似的，如果把图10-1看作为一个输油管道网，结点1表示为发送点，结点6表示为接收点，其它点表示为中转站，各边的权数表示该段管道的最大运输油量。那么如何安排输油线路才能使从1到6的总运输量最大。这样一类问题就是最大流问题。  
最大流问题是网络优化中的一个典型的问题，简单地说，就是在满足容量约束的前提下将尽可能多的流从源结点流向汇结点。因此，最大流问题就是求流网络$G$中使其流量$f$达到最大的一个可行流，该可行流即为最大流。具体定义如下：  
【定义10.4.2】设有向图$G=\langle V,E\rangle$是任意给定的一个网络流图，若$f$是$G$ 中流量最大的的可行流，则称该可行流$f$是$G$ 的最大流，构构造网络流图$G$ 中最大流的问题，就称为网络流图的最大流问题。  
为了实现对最大流问题的求解，必须对网络流图中的增流空间进行合理的度量，通常使用一种名为残留网络的图模型实现这项工作。残留网络的具体定义如下：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图， $f$为$G$的一个流，对于$G$的任意一条边$(u,v)$，在不超过容量$c(u,v)$条件下，从$u$到$v$可压入的额外流量，称为$(u,v)$的残留容量。由$G$中所有边残留容量构成的带权有向图称为$G$的残留网络，记为$G_{f}=\langle V,E_{f}\rangle$。  
若$c_{f}(u,v)$为残留网络$G_{f}$中边$(u,v)$的残留容量，且边$(u,v)\in E$或边$(v,u)\in E$，则$(u,v)\in$$E_{f}$,$\,c_{f}(u,v)=c(u,v)-f(u,v)\,$。例如，若设$(u,v)$当前流量为(4,3)，此时$c(u,v)=4$，$f(u,v)$）$=3$，则有：$c_{f}(u,v)=1$。  
需要注意的是，残留网络具有这样的性质：假设从$_{.}u$到$v$已经有了3 个单位流量，那么从反方向上看，也就是从$v$ 到$u$ 就有了3 个单位的残留容量，这时$c_{f}(v,u)=3$。换句话说，从$u$ 到$v$ 有3 个单位流量，那么从$v$到$u$ 就有了将这3 个单位流量压回去的能力。因此，残留网络结点之间通常由双向带权边进行联结。例如，对于图10-69（a）所示的一个流网络$G$，图10-69（b）则表示该流网络𝐺的残留网络。  
![图10-69 流网络及其残留网络 ](images/d65d1c72064671125468548ae171a28ede5424f1d36d601972ed76c90131fc8c.jpg)  
对于任意给定的一个网络流图$G=\langle V,E\rangle$，可以通过其残留网络$G_{f}=\langle V,E_{f}\rangle$求得$G$的最大流。基本思路如下：首先，对所有的结点令初始状态时流的值为0，即对于$\forall u,v\in V$，有$f(u,v)=0$。然后，通过迭代方式其残留网络中不断寻找源点𝑠到汇点$t$之间的流量增广路径来增加网络流量值，直到残留网络没有这样的增广路径为止。  
因此，在残留网络$G_{f}=\langle V,E_{f}\rangle$寻找流量增广路径是最大流求解算法的关键。为正确理解该算法，现给出流网络增广路径的具体定义：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，$G_{f}=\langle V,E_{f}\rangle$为$G$在流$f$下的一个残留网络，则$G_{f}=\langle V,E_{f}\rangle$中任意一条从源点$s$到汇点$t$的简单路径$p$称为$G=\langle V,E\rangle$的一条流量增广路径，简称为增广路径。  
事实上，可将增广路径形象地理解为网络流图$G$中从源点𝑠到汇点𝑡的一条不违反流网络边容量限制的路径，并向这条路径压入一定的流量，以增加整个网络的流量值。例如，图10-69（b）所示的残留网络存在这样一条如图10-70 中加粗有向边所示的增广路径。  
![图10-70 增广路径 ](images/1e52dc98ce8f5b49283b093dbb72c0d5308ccdc9782306a98cb168474d58608f.jpg)  
![图10-71 流网络的一个切割](images/c52dd38b6f7d2bc46bb57e2440709d67355577a7b3d5fb2e920f10a5bfeb8598.jpg)  
若将图10-70 所示增广路径在流网络所对应每条边的流量增加4 个单位，得到一个新的流网络，其流量比原网络多4 个单位。然后，在新流网络所对应的残留网络中继续寻找新增广路径，直到找不到新增广路径为止。显然，现在的问题是：如果在残留网络$G_{f}=$$\langle V,E_{f}\rangle$中找不到增广路径，此时该残留网络所对应的流$f$是否就是流网络$G=\langle V,E\rangle$的最大流？要解决这个问题，必须进一步引入流网络切割的相关概念，具体如下：  
【定义10.4.4】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，如果将$G$的结点集合𝑉划分为𝑆和$T=V-S$两部分，使得源点$s\in S$且$t\in T$，则称$(S,T)$是$G=\langle V,E\rangle$的一个切割，简称为割。从集合 𝑆 到集合 𝑇 的所有有向边容量之和称为切割 $(S,T)$ 的容量，穿过切割 $(S,T)$所有边流量的代数和流量称为切割$(S,T)$的净流量，记为$f(S,T)$。  
主要注意的是，定义10.4.4 中边的流量带有正负方向，如果流从结点𝑆流向$T$，则该边的流量值为正，如果流从结点𝑇流向𝑆，则该边的流量值为负。例如，对图10-69（a）所示的流网络，可画一个如图10-71 所示的切割$(S,T)$，其容量为：  
$$
c(u,w)+c(v,x)=12+14=26
$$  
穿过该切割的净流量为：  
$$
f(u,w)+f(v,x)-f(w,v)=12+11-4=19
$$  
显然，对于任意一个切割，穿过该切割的净流量上界就是该切割的容量，即穿过切割的净流量不可能超过割的容量。由于流网络中所有切割的流都相等并且等于网络的流，因此，网络最大流必然无法超过网络的最小割。由此得到如下最大流最小割定理：  
【定理10.4.1】（最大流最小割定理）设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和$t$分别为其源点和汇点，则$G=\langle V,E\rangle$的最大流量等于其最小割切的容量。对于$G=\langle V,E\rangle$上的任意一个流$f$，以下三个结论彼此等价：  
(1) $f$是流网络$G=\langle V,E\rangle$的一个最大流；  
(2) 流网络$G=\langle V,E\rangle$的残留网络中不包括任何增广路径；  
(3) 存在流网络$G=\langle V,E\rangle$的某个切割$(S,T)$，满足：
$$
f(S,T)=c(S,T)
$$"
面,概念,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.3.1  平面图的概念与性质']","{'实体类型': '概念', '定义': '由图中边所包围且内部不包含结点与边的区域', '分类': '有限面和无限面'}",,3,"所谓平面图，直观地说就是可以将该图嵌入到某个平面上。如图10-46（a）所示，图模型的边有时不仅在结点处相交，而且还在某些非结点处有交叉，这些非结点处交叉点的边重叠特征显然会导致图模型不能嵌入在同一个平面上。因此，为了将图模型嵌入平面，首先必须适当调整该图中边的走向，以保证任意两条边不会在非结点处有交叉，如图10-46（b）所示。由此得到可平面图和平面图的相关概念。  
【定义10.6】设$G=\langle V,E\rangle$是任意给定的一个图模型，如果该图中有两条边在非结点处有交叉，则称这两条边为该图的交叉边，交叉的具体位置称为交叉点。如果可将图𝐺画在同一个平面上，并且所有边除在结点处之外均不交叉，则称图𝐺可嵌入平面，或称𝐺为可平面图，否则称该图为不可平面图或非平面图。对于可平面图𝐺，将其边不交叉的画法称为𝐺的平面嵌入表示。以平面嵌入方式表示的图可平面图𝐺称为平面图。对于一个平面图𝐺，若对其再加一条边就变成不可平面图，则称𝐺为最大平面图。  
![](images/ad5984e0ab09600028eb4068193d74e75743de0f027a20b4d084511a312873d4.jpg)  
![（a）完全二分图$K_{3,3}$  （b）无法消除交叉  ](images/aa69f9dcec49f0e95a534b493200688a98dae4f4be8a347fbd35c04b8c21413b.jpg)  
例如，对于图10-46（a）所示的图，该图有三对交叉边，即$(v_{1},v_{4})$和$(v_{2},v_{3}),~(v_{1},v_{4})$和$(v_{2},v_{5})$、$(v_{1},v_{5})$和$(v_{2},v_{3})$。由于可将该图表示成图10-46（b）的形式，故该图是一个可平面图。图10-46（b）所示的图就是一个平面图。显然，如果在该平面图上增加一条边，则该图就变成一个不可平面图，故该是一个最大平面图。再如，对于图10-47（a）所示的图模型，无论怎么调整边的走向都不能将其以平面嵌入方式表示，如图10-47（b）所示。故图10-47（a）所示的图模型为不可平面图或非平面图。  
在没有特别要求的情况下，通常将可平面图与平面图不加区分地统称为平面图。与一般图模型显著不同的是，平面图模型除了具有结点和边这两个基本构件之外，还有一般图模型所没有的面的概念，并且由进一步面衍生出边界的概念。因此，平面图是一类非常重要的特殊图模型，无论在理论上还是在应用方面都具有非常重要的价值，在印刷电路板的设计、城市管网设计与规划等多个领域得到实际应用。  
图论之父欧拉对平面图有着比较深刻的研究，发现并论证了平面图的结点、边和面之间的数量关系，提出了著名的欧拉公式。下面给出平面图中面的相关概念：  
【定义10.7】设$G=\langle V,E\rangle$是任意给定的一个平面图，由𝐺中边所包围且内部不包含结点与边的区域，称为$G$的一个面。区域面积有限的面称为有限面，区域面积无限的面称为无限面。对于$G$的任意一个面$R$，包围面$R$的所有边构成的回路称为面𝑅的边界，面𝑅边界中边的个数称为面$R$的次数或度，记为${\bf d e g}(R)$。  
通俗地说，如果把一个平面图画在平面上，然后用小刀沿着图的边将平面切开，那么整个平面就被切成若干块，其中每一块就是图的一个面。或者说，平面图的一个面就是平面中一个以边为界线不能再分割的区域块。例如，对于图10-46（b）所示的平面图，一共有六个面，其中有一个面是无限面，其余五个是有限面。需要注意的是，对于任何一个平面图，该图有且仅有一个无限面。下面的定理10.11 给出了平面图中面数与边数的数量关系：  
【定理10.11】平面图中所有面的次数之和等于边数的两倍。  
下面定理10.12 是著名的欧拉公式，给出了平面图中结点、边和面之间的数量关系：  
【定理10.12】设$G=\langle V,E\rangle$是任意给定的一个连通平面图，若它有$n$个结点、$m$条边、$r$ 个面，则有  
$$
n-m+r=2\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
【定理10.13】如果平面连通图$G$每个面的次数均为$l(l\geq3)$，则有：  
$$
m=l(n-2)/(l-2)
$$  
其中$m$为$G$的边数，$n$为$G$的结点数。  
【定理10.14】设$G$是一个$(n,m)$简单连通平面图，若$m>1$，则有：  
$$
m\leq3n-6\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
由定理10.4 的逆命题不成立，也就是说满足不等式$m\leq3n-6$的简单连通图不一定是平面图。但是对于一个简单连通图，若不满足$m\leq3n-6$，则一定是非平面图。因此，可用定理10.4 的结论证明某个简单连通图不是非平面图。  
【定理10.15】设$G$为一平面连通简单图，其结点数$n\geq4$，边数为$m$，且$G$不以$K_{3}$为其子图，则有$m\leq2n-4$。  
【定义10.8】对于是任意给定的一个图模型$G=\langle V,E\rangle$  
设$e=(u,v)$是$G$的任意一条边，如果在图$G$中删除该边并新增一个结点$w$及两条边$e_{1}=$$(u,w)$、$e_{2}=(w,v)$ ，则称该操作为对图$G$的边切割操作；  
设𝑤是$G$中任意一个度数为2 的结点，且是边${e_{1}=(u,w)}$和$e_{2}=(w,v)$的公共结点，如果在图$G$中删除结点$w$及边$e_{1},\,e_{2}$，并增加边$e=(u,v)$，则称该操作为对图$G$的结点贯通操作；  
对图$G$的边切割操作和结点贯通操作统称为对图$G$的同胚操作。  
显然，边切割操作和结点贯通操作是一对互逆操作。例如，对于图10-48 所示的两个图模型，可通过对边的切割操作将$G_{1}$变成$G_{2}$，也可通过对结点做贯通操作将$G_{2}$变成$G_{1}$。  
![图10-48  图的同胚操作与同胚关系  ](images/17b45e1706460a818a5492fb4df19f0ddd6b072e9cf57afef7db0852f0c58237.jpg)  
下面在同胚操作的基础上，引入如下两个图之间的同胚关系：  
【定义10.9】设$G_{1}=\langle V_{1},E_{1}\rangle$和$G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，如果可用同胚操作将其中一个转化为另外一个，则称$G_{1}$与$G_{2}$具有同胚关系，简称为$G_{1}$与$G_{2}$同胚。  
根据上述同胚的概念，可以得到如下关于平面图判定的库拉托夫斯基定理：  
【定理10.16】（库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是$G$的任何子图都不同胚于$K_{5}$或$K_{3,3}$。  
【定理10.17】(库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是𝐺的任何子图都不能通过边的收缩得到$K_{5}$或$K_{3,3}$。  
![图10-51 彼得森图收缩为$ K_{5}$](images/b6cd48c8bf37519af48b0cc187afdf1adc13d2c5e160a08fe418ce5c94762fd6.jpg)  
库拉托夫斯基定理是一个非常著名定理，通常将$K_{5}$和$K_{3,3}$称为库拉托夫斯基图。可以使用该定理判定一个图是否为平面图。例如，对于图$10{-}51\mathrm{a}$）所示的彼得森图，收缩其边$(v_{i},u_{i})(i=1,2,3,4,5)$，则可得到图$K_{5}$，见图10-51b)。故彼得森图不是平面图。  
值得注意的是，虽然库拉托夫斯基定理给出了平面图判定的充分必要条件，但是目前还没有基于该定理得到一个有效的判定算法。因此，对于一个比较复杂的图模型，要判定其是否为平面图，有时并不是一件容易的事情。"
面着色,概念,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.3.3 着色问题与算法', '二、平面图的着色问题']","{'实体类型': '概念', '定义': '对平面图的面进行着色，使得相邻的面具有不同的颜色'}",,4,"如前所述，图的着色问题起源于对地图中每个国家领土的着色问题。例如，对于如图$10-$62 所示的地图，显然可以用4 种颜色对该地图中每个国家的领土进行标定。不难看出，该地图其实是一种连通无桥平面图，每个国家的领土范围对应于该平面图的一个面。因此，对地图中每个国家领土的着色问题，可转化为对这种特殊平面图中面的着色问题。  
![10-62 平面图的着色问题  ](images/0f1d899dc5071bbbd74c74607374e17794ff18cb387057f7c4c58b59ecbd991c.jpg)  
下面考察基于这种特殊平面图的面着色问题，首先给出面着色的相关定义：  
【定义10.13】连通无桥平面图及其所有有限面称为地图。地图中每有限面分别称为一个国家，若两个国家至少有一条公共边，则称这两个国家相邻。如果对给定地图$G$上每个国家涂上或标注一种颜色，使得相邻的国家具有不同的颜色，则称这种操作是对图$G$的面着色。若可用$k$种颜色就可完成对地图$G$的面着色，则称$G$是$k{-}$面可着色的。若$G$是$k{-}$面可着色的，但不是$(k-1){-}$面可着色的，则称$G$是${k}$-色地图，称$ k$为$G$的面色数，记为$\chi^{*}(G)$。  
事实上，对地图的面着色可以通过平面图的结点着色来研究。这是因为平面图$G$的对偶图$G^{*}$也是一个平面图，并且图$G$的每个面与图$G^{*}$的每个结点之间具有一一对应的关系。例如，对10-62（a）所示的面着色问题，可以转化为10-62（b）所示的结点着色问题。下面的定理10.22 揭示了作为地图的一种特殊平面图与其对偶图之间的色数关系：  
【定理10.22】地图$G$是$k^{-}$面可着色图，当且仅当它的对偶图$G^{*}$是$k^{-}$可着色图。  
【定理10.23】设$G=\langle V,E\rangle$是简单平面图，则$G$中至少存在一个度数不超过5 的结点。  
下面给出关于平面图结点着色的五色定理：  
【定理10.24】（五色定理）设$G=\langle V,E\rangle$是任意给定的一个连通简单平面图，则$G$的点色数为5。  
上述五色定理是数学家赫伍德在研究四色猜想时给出的一个重要结论，可以说是四色猜想研究历史上的一个重大突破。四色猜想是一个与哥德巴赫猜想、黎曼猜想同样著名的数学猜想。该猜想最初由英国青年佛朗西斯·格里斯在1852 年提出：  
四色猜想：连通简单平面图的色数不超过4。  
公元1852 年，毕业于英国伦敦大学并从事地图着色工作的佛朗西斯·格里斯，发现了一个奇怪的现象：无论多么复杂的地图，只要用四种颜色，就可以区分有公共边界的国家和地区。佛朗西斯觉得这中间一定有什么奥妙，便求教著名的英国数学家摩根。摩根对此苦苦思索了几个昼夜后还是不得其解，便写信给著名数学家哈密顿，希望哈密尔顿要么能证明这个问题，要么构造出一个需要五种或更多种颜色的图来。然而，智慧超人的哈密尔顿耗费了整整13 年心血，终于一筹莫展，抱恨逝去！  
哈密尔顿死后，又过了13 年，英国数学家凯莱在一次数学年会上把这个问题归纳为四色猜想，并于公元1879 年在英国皇家地理会刊的创刊号上，公开征求对四色猜想的解答。在征解消息发出的同年，一位半路出家的数学家肯普，发表了一个关于四色定理的证明。人们普遍以为四色猜想已经成为历史。不料过了11 年，即公元1890 年，一个名叫赫伍德的青年，指出了肯普在证明中的错误。与此同时，赫伍德匠心独运，利用肯普提供的方法，成功地证明了上述五色定理。由于存在不可3-着色的平面图$K_{4}$，故四色定理若得到证明，将是平面图色数问题的最佳结果。  
1976 年6 月，美国两位著名数学家阿佩尔和海肯通过计算机计算了1200 小时，通过数组计算的方法验证了四色猜想的正确性。据此，人们将四色猜想改名为四色定理。但是，四色定理并没有得到所以数学家的认可，因为目前还没理论上严谨的数学证明。"
韦尔奇•鲍威尔算法,算法,"['第十章  特殊图模型与算法', '§ 10.2 二分图与匹配问题', '10.3.3 着色问题与算法', '三、结点着色算法']","{'实体类型': '算法', '基本思路': '将图中的结点按度数递减顺序排列，用不同颜色依次对不邻接的结点着色，直到所有结点着色完毕'}",,4,"如前所述，图的边着色和面着色问题都可转化为对图的结点着色问题。因此，如果掌握了对一个图的结点进行着色的具体设计方法，则边着色和面着色的设计问题便可迎刃而解。因此，我们仅给出结点着色算法。首先介绍一种比较直观的基于贪心策略的着色算法，然后介绍比较巧妙的韦尔奇•鲍威尔着色算法。  
基于贪心策略的着色算法的计算思路比较直观，首先对每个结点构造一个颜色集合，然后通过贪心策略逐步对颜色集合进行优化和排除，最后得到一种优化的着色方案。  
设$G=\langle V,E\rangle$是任意给定的一个连通无向图，令$\{c_{1},c_{2},\cdots,c_{n}\}$为全部可选颜色的集合，$V=\{v_{1},v_{2},\cdots,v_{n}\}$。则基于贪心策略的着色算法具体步骤如下：  
1）对$i=1,2,\cdots,n$，作集合$C_{i}=\{c_{1},c_{2},\cdots,c_{i}\}$。  
2）给结点$v_{i}(i=1,2,\cdots,n)$标上颜色集$C_{i}$的第一种颜色$c_{k}$  
3）对点$v_{i}$的所有邻接点$v_{j}(j>1)$，作$C_{j}=C_{j}-\{c_{k}\}$。  
4）转到步骤2），直到所有结点都着色为止。  
例如，图10-66（a）所示的无向图$G$，使用上述基于贪心策略的着色算法，不难得到如图10-66（b）所示的着色结果。  
![图10-66 无向图𝐺及其结点着色  ](images/0f362f12a7e52ba554944661d9c9e977185a05cbdb94dab0ac96e78d08f2908c.jpg)  
韦尔奇•鲍威尔算法是一个非常著名的结点着色算法。该算法的基本思路如下：首先将图$G$中的结点按度数的递减顺序进行排列；然后用第一种颜色对结点着色，并按排列顺序对与前面着色结点不邻接的每一结点着上同样的颜色；最后用第二种颜色对尚未着色的结点重复前一步骤，并用第三种颜色继续这种做法，直到所有的结点全部着色为止。  
设$G=\langle V,E\rangle$是任意给定的一个连通无向图，令$\cdot V=\{v_{1},v_{2},\cdots,v_{n}\}$且所有结点中共有𝑠种不同的度数，则韦尔奇•鲍威尔结点着色算法的具体步骤如下：  
1）图$G$的所有结点按其度数从大到小进行排列，度数相同的结点次序不究，得到：并设初值$i=j=k=1$，$B=\emptyset$，其中$B$表示已着色结点集合。  
2）用第𝑖种颜色对结点$v_{j k}$进行着色，并按次序对与$v_{j k}$不相邻的结点着同一颜色，将与$v_{j k}$着同色的所有结点放入$B$集合。  
3 ）若 $\,\!V(G)-B=\varnothing$ ，则停止，此时每个结点都已被着色。否则 $i=i+1$ ，取结点 $v_{j k}\in$ $V(G)-B$，且$\deg\!\left(v_{j k}\right)=\operatorname*{max}\{\deg\!\left(v_{x y}\right)\!,v_{x y}\in V(G)-B\}$，转去执行2）。"
饱和边,概念,"['第十章  特殊图模型与算法', '§ 10.4 网络流图及其优化问题', '10.4.1 流网络与切割']","{'实体类型': '概念', '定义': '满足f(u,v)=c(u,v)的边'}",,3,"首先介绍流网络模型的相关基本概念及其数据描述。如同每条公路有运输量、每根水管有最大流量限制一样，网络流图的每条边都有容量，或者说每条边都有一定的流量。网络流图其实就是每条边具有附带容量（可理解为权值）的有向图。其具体定义如下：  
【定义10.4.1】设有向图$G=\langle V,E\rangle$，$V$中包含一个源结点𝑠和一个汇结点$t$，且每条边$(u,v)\in E$均有一个非负容量$c(u,v)\geq0$，若$(u,v)\notin E$，则规定其容量$c(u,v)=0$，此时称有向图$G$是一个网络流图，简称为流网络或网络。源结点$s$即起点，汇结点$t$即终点。网络流是定义在网络$G$中关于边的一个实函数，用$f(u,v)$表示有向边$(u,v)\in E$上结点$ u$到结点$v$的网络流。$f(u,v)$表示$u$ 到$v$的净流。  
例如，如果$_{u}$到$v$有6 个单位的实际流，且$v$到$u$有3 个单位的实际流，那么$f(u,v)=$3，$f(v,u)=-3$，互为相反数。净流是实际通过的流量矢量和，可类比合力的概念。  
满足以下三个性质的网络流$f$称之为可行流：  
（1）容量限制：对所有的$(u,v)\in E$，都有$f(u,v)\leq c(u,\textit{}v)$。即一条边的流不能超过它的容量。这也很容易理解，如同自来水管的水流自然不会超过水管本身的容量。  
（2）斜对称：对所有$(u,v)\in E$，都有$f(u,v)=-f(v,u)$。即点$\cdot u$到$v$的净流必须与点𝑣到$u$的净流相反。可以类比物理中矢量概念，如作用力与反作用力，强调的是其方向性。  
（3）流守恒：对所有$u\in V-\{s,t\}$，都有$\textstyle\sum_{v\in V}f(u,v)=0$。即除源结点$𝑠$和汇结点$𝑡$外，其余每个结点的净流之和为0。  
![图10-68 网络及可行流  ](images/bada5974bba3db0db4c82fa8e3076a8834542abfa1641f17fac232a32e6fee29.jpg)  
例如，如图10-68 所示，网络中定义网络流$f(u,v)$是一条可行流。图中每条边所对应的序偶表示该边的容量和流量，第一个数字表示边的容量，第二个数字表示边的流量。  
下面结合图10-68 所示网络实例介绍网络流模型中与边相关的几个概念。可根据边的容量与流的大小关系对网络中的边进行分类：  
（1）满足$f(u,v)=c(u,v)$的边称为饱和边，如边(1,2)、 (2,3)  
（2）满足$f(u,v)<c(u,v)$的边称为非饱和边，如边(2,4)。  
（3）满足 $f(u,v)=0$ 的边称为零流边，如边 (3,4) ；满足 $f(u,v)>0$ 的边称为非零流 边，如边(5,4)。  
（4）既不是零流边也不是饱和边的边，称为弱流边，如边(5,6)  
如果把图10-78 看作是一个公路网，6 个结点分别表示6 座城镇，每条边上的权数表示两城镇间的距离。若现在需要从起点1 将一些物资运送到终点6，应怎样选择路线才能使总运输距离最短。我们知道，这样一类问题称为最短路径问题。类似的，如果把图10-1看作为一个输油管道网，结点1表示为发送点，结点6表示为接收点，其它点表示为中转站，各边的权数表示该段管道的最大运输油量。那么如何安排输油线路才能使从1到6的总运输量最大。这样一类问题就是最大流问题。  
最大流问题是网络优化中的一个典型的问题，简单地说，就是在满足容量约束的前提下将尽可能多的流从源结点流向汇结点。因此，最大流问题就是求流网络$G$中使其流量$f$达到最大的一个可行流，该可行流即为最大流。具体定义如下：  
【定义10.4.2】设有向图$G=\langle V,E\rangle$是任意给定的一个网络流图，若$f$是$G$ 中流量最大的的可行流，则称该可行流$f$是$G$ 的最大流，构构造网络流图$G$ 中最大流的问题，就称为网络流图的最大流问题。  
为了实现对最大流问题的求解，必须对网络流图中的增流空间进行合理的度量，通常使用一种名为残留网络的图模型实现这项工作。残留网络的具体定义如下：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图， $f$为$G$的一个流，对于$G$的任意一条边$(u,v)$，在不超过容量$c(u,v)$条件下，从$u$到$v$可压入的额外流量，称为$(u,v)$的残留容量。由$G$中所有边残留容量构成的带权有向图称为$G$的残留网络，记为$G_{f}=\langle V,E_{f}\rangle$。  
若$c_{f}(u,v)$为残留网络$G_{f}$中边$(u,v)$的残留容量，且边$(u,v)\in E$或边$(v,u)\in E$，则$(u,v)\in$$E_{f}$,$\,c_{f}(u,v)=c(u,v)-f(u,v)\,$。例如，若设$(u,v)$当前流量为(4,3)，此时$c(u,v)=4$，$f(u,v)$）$=3$，则有：$c_{f}(u,v)=1$。  
需要注意的是，残留网络具有这样的性质：假设从$_{.}u$到$v$已经有了3 个单位流量，那么从反方向上看，也就是从$v$ 到$u$ 就有了3 个单位的残留容量，这时$c_{f}(v,u)=3$。换句话说，从$u$ 到$v$ 有3 个单位流量，那么从$v$到$u$ 就有了将这3 个单位流量压回去的能力。因此，残留网络结点之间通常由双向带权边进行联结。例如，对于图10-69（a）所示的一个流网络$G$，图10-69（b）则表示该流网络𝐺的残留网络。  
![图10-69 流网络及其残留网络 ](images/d65d1c72064671125468548ae171a28ede5424f1d36d601972ed76c90131fc8c.jpg)  
对于任意给定的一个网络流图$G=\langle V,E\rangle$，可以通过其残留网络$G_{f}=\langle V,E_{f}\rangle$求得$G$的最大流。基本思路如下：首先，对所有的结点令初始状态时流的值为0，即对于$\forall u,v\in V$，有$f(u,v)=0$。然后，通过迭代方式其残留网络中不断寻找源点𝑠到汇点$t$之间的流量增广路径来增加网络流量值，直到残留网络没有这样的增广路径为止。  
因此，在残留网络$G_{f}=\langle V,E_{f}\rangle$寻找流量增广路径是最大流求解算法的关键。为正确理解该算法，现给出流网络增广路径的具体定义：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，$G_{f}=\langle V,E_{f}\rangle$为$G$在流$f$下的一个残留网络，则$G_{f}=\langle V,E_{f}\rangle$中任意一条从源点$s$到汇点$t$的简单路径$p$称为$G=\langle V,E\rangle$的一条流量增广路径，简称为增广路径。  
事实上，可将增广路径形象地理解为网络流图$G$中从源点𝑠到汇点𝑡的一条不违反流网络边容量限制的路径，并向这条路径压入一定的流量，以增加整个网络的流量值。例如，图10-69（b）所示的残留网络存在这样一条如图10-70 中加粗有向边所示的增广路径。  
![图10-70 增广路径 ](images/1e52dc98ce8f5b49283b093dbb72c0d5308ccdc9782306a98cb168474d58608f.jpg)  
![图10-71 流网络的一个切割](images/c52dd38b6f7d2bc46bb57e2440709d67355577a7b3d5fb2e920f10a5bfeb8598.jpg)  
若将图10-70 所示增广路径在流网络所对应每条边的流量增加4 个单位，得到一个新的流网络，其流量比原网络多4 个单位。然后，在新流网络所对应的残留网络中继续寻找新增广路径，直到找不到新增广路径为止。显然，现在的问题是：如果在残留网络$G_{f}=$$\langle V,E_{f}\rangle$中找不到增广路径，此时该残留网络所对应的流$f$是否就是流网络$G=\langle V,E\rangle$的最大流？要解决这个问题，必须进一步引入流网络切割的相关概念，具体如下：  
【定义10.4.4】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，如果将$G$的结点集合𝑉划分为𝑆和$T=V-S$两部分，使得源点$s\in S$且$t\in T$，则称$(S,T)$是$G=\langle V,E\rangle$的一个切割，简称为割。从集合 𝑆 到集合 𝑇 的所有有向边容量之和称为切割 $(S,T)$ 的容量，穿过切割 $(S,T)$所有边流量的代数和流量称为切割$(S,T)$的净流量，记为$f(S,T)$。  
主要注意的是，定义10.4.4 中边的流量带有正负方向，如果流从结点𝑆流向$T$，则该边的流量值为正，如果流从结点𝑇流向𝑆，则该边的流量值为负。例如，对图10-69（a）所示的流网络，可画一个如图10-71 所示的切割$(S,T)$，其容量为：  
$$
c(u,w)+c(v,x)=12+14=26
$$  
穿过该切割的净流量为：  
$$
f(u,w)+f(v,x)-f(w,v)=12+11-4=19
$$  
显然，对于任意一个切割，穿过该切割的净流量上界就是该切割的容量，即穿过切割的净流量不可能超过割的容量。由于流网络中所有切割的流都相等并且等于网络的流，因此，网络最大流必然无法超过网络的最小割。由此得到如下最大流最小割定理：  
【定理10.4.1】（最大流最小割定理）设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和$t$分别为其源点和汇点，则$G=\langle V,E\rangle$的最大流量等于其最小割切的容量。对于$G=\langle V,E\rangle$上的任意一个流$f$，以下三个结论彼此等价：  
(1) $f$是流网络$G=\langle V,E\rangle$的一个最大流；  
(2) 流网络$G=\langle V,E\rangle$的残留网络中不包括任何增广路径；  
(3) 存在流网络$G=\langle V,E\rangle$的某个切割$(S,T)$，满足：
$$
f(S,T)=c(S,T)
$$"
鸽笼原理,原理,"['一、容斥原理及其应用', '二、鸽笼原理及其应用', '1.3.2 容斥原理与鸽笼原理', '§ 1.3 有限集的基本计数技术', '第一章  集合与计数基础']","{'实体类型': '原理', 'name': '鸽笼原理', '提出者': '狄利克雷', '定义': '如果把多于n个的元素按任一方式分成n个集合，那么至少有一个集合中含有两个或两个以上的元素', '别称': '抽屉法则', '应用': '解决很多数学问题'}",,3,在前述加法原理中，我们将某个集合看成是由多个集合的并运算而构成，并且要求参与并运算的多个集合互不相交。现在将加法原理中多个集合互不相交的条件去掉，由此便可得到容斥原理。因此，容斥原理可看成是加法原理的一种推广形式。
鼓轮设计问题,问题,"['第十章  特殊图模型与算法', '§ 10.4 网络流图及其优化问题', '10.5.1 鼓轮设计问题']","{'实体类型': '问题', '定义': '设计计算机鼓轮的绝缘材料和导电材料分布，使得每旋转一周输出所有不同的二进制数', '特点': '将二进制数码排成圆圈，任意依次相连的数码组成的三位二进制数互不相同', '方法': '构建有向图，求欧拉回路以得到二进制数码的圆排列'}",,3,"计算机鼓轮是由绝缘材料和导电材料制成，主要用于输出二进制数码。例如，对于如图10-7（a）所示的一个轮鼓，旋转鼓的表面分成了8 块扇形，图中阴影区表示用导电材料制成，空白区用绝缘材料制成，终端𝑎、𝑏和 $c$与扇面接触时接触导体输出1，接触绝缘体时输出0。鼓轮按逆时针旋转，触点每转一个扇区就输出一个三位二进制信号。  
问题是如何设计这8 块扇形区域绝缘材料与导电材料的分布，使得鼓轮每旋转一周，就能得到从000 到111 这8 个不同的二进制数。这就是计算机鼓论设计问题。从数学逻辑上看，这个问题也可理解为：如何将8 个二进制数码排成一个圆圈，使得任意3 个依次相连的数码组成的三位二进制数互不相同，而且能够产生全部8 个不同的三位二进制数。  
对于终端$a,b,c$，若某时刻的输出信号为$a_{1}a_{2}a_{3}$，则每转一个扇形，信号变成$a_{2}a_{3}a_{4}$。由此可见，前一次输出信号的右两位决定了后一次输出信号的左两位。故可把所有两位二进制数作为结点，将二进制数码之间传递关系的结点引一条有向边，将这两个二位二进制数进行串接并合并两者重复的部分，产生一个三位二进制数，并用这个三位二进制数表示该有向边。例如，对于结点$a_{1}a_{2}$和$a_{2}a_{3}$，可从$a_{1}a_{2}$到$a_{2}a_{3}$引一条有向边表示$a_{1}a_{2}a_{3}$这个三位的二进制数。由此得到如图10-7（b）所示的有向图。  
![图10-89 三位计算机轮鼓设计问题 ](images/fd2bd5a3740dee863b37e0bc2d2faadb7b3dbae1169c6c42913ac97c999411af.jpg)  
由于图10-7（b）所示有向图中每条边都代表一个三位二进制数，并且不同边表示不同的三位二进制数。因此，若能在该有向图上求出一条欧拉回路，则可得到该全部 8 个三位二进制数的一个圆排列，由该圆排列不难得到所求8 个二进制数码的圆排列。  
由图10-7（b）可知，该有向图4 个结点的出度和入度数均为2 故存在欧拉回路，比如$(e_{0},e_{1},e_{3},e_{7},e_{6},e_{5},e_{2},e_{4})$即是一条欧拉回路，根据该回路不难得到其对应的8 个二进制数码的圆排列为：00011101。按此数码排列分布计算机轮鼓8 块扇形区域绝缘材料与导电材料，则该鼓轮按逆时针每旋转一个扇区就输出一个三位二进制信号，鼓轮每旋转一周，就能得到从000 到111 这8 个不同的二进制数。  
上述所求的8 个二进制数码的圆排列00011101 称为一个8 位布鲁英序列。下面进一步考察16 位布鲁英序列。如图10-90（a）所示，此时旋转鼓的表面分成了16 块扇形，图中阴影区表示用导电材料制成，空白区用绝缘材料制成，终端$a$、$b$、𝑐和 $d$与扇面接触时接触导体输出1，接触绝缘体时输出0。鼓轮按逆时针旋转，触点每转一个扇区就输出一个二进制信号。问题是如何选取这16 块扇形的材料，使鼓轮旋转一周，触点能够输出个不同的四位二进制信号，并且每转一周就能得到从$0000{\sim}1111$ 这全部16 个四位二进制数。  
![图10-90 四位计算机轮鼓设计问题 ](images/5b3de38c173917b97e4ae2bdc5b3b0f102b52c396d35769298cedf57247d3416.jpg)  
从逻辑上看，四位计算机轮鼓设计问题也可理解为：把16 个二进制数排成一个圆圈，使得4 个依次相连的数字所组成的16 个四位二进制数互不相同。  
对于终端$a,b,c,d$，若某时刻的输出信号为$a_{1}a_{2}a_{3}a_{4}$，则每转一个扇形，信号变成$a_{2}a_{3}a_{4}a_{5}$。由此可以看出，前一次输出信号的右三位决定了后一次输出信号的左三位。因此，我们可把所有三位二进制数作结点，从每一个结点$a_{1}a_{2}a_{3}$到$a_{2}a_{3}a_{4}$引一条有向边表示$a_{1}a_{2}a_{3}a_{4}$这个四位的二进制数，作出表示所有可能的码变换的有向图如图10-90（b）所示。于是问题转化为在这个有向图上求一条欧拉回路。  
由图10-90（b）可知，该有向图8 个结点的出度和入度均为2，故存在欧拉回路，例如$e_{0},e_{1},e_{2},e_{4},e_{9},e_{3},e_{6},e_{13},e_{10},e_{5},e_{11},e_{7},e_{15},e_{14},e_{12},e_{8}$是一条欧拉回路，其对应布鲁英序列为0000100110101111。计算机轮鼓绝缘材料与导电材料按此序列分布便可满足要求。"
