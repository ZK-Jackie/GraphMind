start,relation,target,attribute,content,description
离散数学,包含,集合论,,离散数学以各种离散量的概念、关系、结构和运算性质为研究对象，以充分满足计算机相关学科对离散量进行表示和处理的数学需求。正如微积分支撑了作为近代工业文明基础的物理学，离散数学支撑了作为现代信息社会基础的计算机科学。事实上，离散数学是一门综合的数学学科，由多个数学分支组成，包括集合论、数理逻辑、图论、数论、组合分析、代数结构等，分别从不同角度出发研究各种离散量之间数与形的关系。本章比较系统地介绍集合论与计数的基础知识， 它们是学习各个离散数学分支所必备的入门基础。 尽管读者可能已 经从其它途径获悉其中某些概念，但是要想掌握作为支撑整个计算机学科基石的离散数学，就必须重新审视和系统地学习这些入门知识。,离散数学包含集合论作为其组成部分
离散数学,包含,数理逻辑,,离散数学以各种离散量的概念、关系、结构和运算性质为研究对象，以充分满足计算机相关学科对离散量进行表示和处理的数学需求。正如微积分支撑了作为近代工业文明基础的物理学，离散数学支撑了作为现代信息社会基础的计算机科学。事实上，离散数学是一门综合的数学学科，由多个数学分支组成，包括集合论、数理逻辑、图论、数论、组合分析、代数结构等，分别从不同角度出发研究各种离散量之间数与形的关系。本章比较系统地介绍集合论与计数的基础知识， 它们是学习各个离散数学分支所必备的入门基础。 尽管读者可能已 经从其它途径获悉其中某些概念，但是要想掌握作为支撑整个计算机学科基石的离散数学，就必须重新审视和系统地学习这些入门知识。,离散数学包含数理逻辑作为其组成部分
离散数学,包含,图论,,离散数学以各种离散量的概念、关系、结构和运算性质为研究对象，以充分满足计算机相关学科对离散量进行表示和处理的数学需求。正如微积分支撑了作为近代工业文明基础的物理学，离散数学支撑了作为现代信息社会基础的计算机科学。事实上，离散数学是一门综合的数学学科，由多个数学分支组成，包括集合论、数理逻辑、图论、数论、组合分析、代数结构等，分别从不同角度出发研究各种离散量之间数与形的关系。本章比较系统地介绍集合论与计数的基础知识， 它们是学习各个离散数学分支所必备的入门基础。 尽管读者可能已 经从其它途径获悉其中某些概念，但是要想掌握作为支撑整个计算机学科基石的离散数学，就必须重新审视和系统地学习这些入门知识。,离散数学包含图论作为其组成部分
离散数学,包含,数论,,离散数学以各种离散量的概念、关系、结构和运算性质为研究对象，以充分满足计算机相关学科对离散量进行表示和处理的数学需求。正如微积分支撑了作为近代工业文明基础的物理学，离散数学支撑了作为现代信息社会基础的计算机科学。事实上，离散数学是一门综合的数学学科，由多个数学分支组成，包括集合论、数理逻辑、图论、数论、组合分析、代数结构等，分别从不同角度出发研究各种离散量之间数与形的关系。本章比较系统地介绍集合论与计数的基础知识， 它们是学习各个离散数学分支所必备的入门基础。 尽管读者可能已 经从其它途径获悉其中某些概念，但是要想掌握作为支撑整个计算机学科基石的离散数学，就必须重新审视和系统地学习这些入门知识。,离散数学包含数论作为其组成部分
离散数学,包含,组合分析,,离散数学以各种离散量的概念、关系、结构和运算性质为研究对象，以充分满足计算机相关学科对离散量进行表示和处理的数学需求。正如微积分支撑了作为近代工业文明基础的物理学，离散数学支撑了作为现代信息社会基础的计算机科学。事实上，离散数学是一门综合的数学学科，由多个数学分支组成，包括集合论、数理逻辑、图论、数论、组合分析、代数结构等，分别从不同角度出发研究各种离散量之间数与形的关系。本章比较系统地介绍集合论与计数的基础知识， 它们是学习各个离散数学分支所必备的入门基础。 尽管读者可能已 经从其它途径获悉其中某些概念，但是要想掌握作为支撑整个计算机学科基石的离散数学，就必须重新审视和系统地学习这些入门知识。,离散数学包含组合分析作为其组成部分
离散数学,包含,代数结构,,离散数学以各种离散量的概念、关系、结构和运算性质为研究对象，以充分满足计算机相关学科对离散量进行表示和处理的数学需求。正如微积分支撑了作为近代工业文明基础的物理学，离散数学支撑了作为现代信息社会基础的计算机科学。事实上，离散数学是一门综合的数学学科，由多个数学分支组成，包括集合论、数理逻辑、图论、数论、组合分析、代数结构等，分别从不同角度出发研究各种离散量之间数与形的关系。本章比较系统地介绍集合论与计数的基础知识， 它们是学习各个离散数学分支所必备的入门基础。 尽管读者可能已 经从其它途径获悉其中某些概念，但是要想掌握作为支撑整个计算机学科基石的离散数学，就必须重新审视和系统地学习这些入门知识。,离散数学包含代数结构作为其组成部分
集合论,基础,计数,,离散数学以各种离散量的概念、关系、结构和运算性质为研究对象，以充分满足计算机相关学科对离散量进行表示和处理的数学需求。正如微积分支撑了作为近代工业文明基础的物理学，离散数学支撑了作为现代信息社会基础的计算机科学。事实上，离散数学是一门综合的数学学科，由多个数学分支组成，包括集合论、数理逻辑、图论、数论、组合分析、代数结构等，分别从不同角度出发研究各种离散量之间数与形的关系。本章比较系统地介绍集合论与计数的基础知识， 它们是学习各个离散数学分支所必备的入门基础。 尽管读者可能已 经从其它途径获悉其中某些概念，但是要想掌握作为支撑整个计算机学科基石的离散数学，就必须重新审视和系统地学习这些入门知识。,集合论与计数是学习离散数学分支的入门基础
集合论,基础与组成,集合,,集合论是整个数学的基础和出发点， 当然也是离散数学的基础和出发点， 要学好离散数 学，首先必须学习集合论的有关知识。学习集合论还有一个非常重要的原因，那就是计算机的各个领域都与集合论有着极其密切的关系。因为集合不仅可以表示数值信息，而且还可表示和处理各种非数值信息，例如对各种数据的增删查改、对数据之间关系的描述等等，甚至可以让这些数据信息像数值一样进行运算。在本节，我们将学习集合论的基本知识，包括数学危机与集合论的由来、集合的概念与表示、集合的基本运算及运算性质等。,集合论是数学的基础，集合是集合论的基本组成元素，集合论研究集合的概念、表示、基本运算及运算性质
数学危机,解决,极限理论,,"众所周知，数学是整个自然科学体系的基础，人们对自然界的认识结论一般需要通过数学演算或数学证明来保证其正确性。打铁还需自身硬，从理论上说，数学既然能够作为一种可以鉴别认识结论真伪的基本工具，那么其自身就不应该有任何错误或矛盾。但实际情况并没有这么简单，千百年来陆续出现的希帕索斯悖论、贝克莱悖论、理发师悖论，使得数学理论的正确性面临一次又一次严峻挑战，历史上称之为数学危机。为拯救数学于危机之中，捍卫数学理论的正确性，无数杰出科学家做了大量深入系统的研究工作。直到在十九世纪初，柯西、维尔斯特拉斯等数学家通过创立极限理论，终于解决了希帕索斯悖论、贝克莱悖论问题，为实数理论和微积分的正确性奠定了坚实的基础。  
但是，极限理论在逻辑上还有需要完善的地方.因为极限概念由自然数定义，要保证极限理论的正确性，首先必须要保证自然数概念及相关理论的正确性。虽然自然数是大家熟知且常用的一个基本概念，大家从小学就开始学习自然数的计数和运算，但是对自然数概念的理解主要还是依靠经验。为保证极限理论的正确性，必须对自然数进行正式的数学定义。数学家冯·诺依曼用集合的方式定义了自然数并取得成功。由此，对整个数学理论体系正确性和无矛盾性的论证就转化为对集合论的正确性和无矛盾性的论证，集合论成为整个数学大厦的根基。尽管卢素提出理发师悖论指出了集合论的局限性，一度动摇了这个根基，但是有惊无险，策莫罗提出的公理化集合论有效解决了理发师悖论问题，不仅稳定了数学根基，而且进一步确立了集合论在整个数学大厦中的基础地位。集合论被誉为十九世纪最伟大的数学成就，集合论的创始人康托被誉为整个十九世纪最伟大的数学家，没有之一。",极限理论的创立解决了数学危机中的希帕索斯悖论和贝克莱悖论问题
极限理论,依赖,集合论,,"众所周知，数学是整个自然科学体系的基础，人们对自然界的认识结论一般需要通过数学演算或数学证明来保证其正确性。打铁还需自身硬，从理论上说，数学既然能够作为一种可以鉴别认识结论真伪的基本工具，那么其自身就不应该有任何错误或矛盾。但实际情况并没有这么简单，千百年来陆续出现的希帕索斯悖论、贝克莱悖论、理发师悖论，使得数学理论的正确性面临一次又一次严峻挑战，历史上称之为数学危机。为拯救数学于危机之中，捍卫数学理论的正确性，无数杰出科学家做了大量深入系统的研究工作。直到在十九世纪初，柯西、维尔斯特拉斯等数学家通过创立极限理论，终于解决了希帕索斯悖论、贝克莱悖论问题，为实数理论和微积分的正确性奠定了坚实的基础。  
但是，极限理论在逻辑上还有需要完善的地方.因为极限概念由自然数定义，要保证极限理论的正确性，首先必须要保证自然数概念及相关理论的正确性。虽然自然数是大家熟知且常用的一个基本概念，大家从小学就开始学习自然数的计数和运算，但是对自然数概念的理解主要还是依靠经验。为保证极限理论的正确性，必须对自然数进行正式的数学定义。数学家冯·诺依曼用集合的方式定义了自然数并取得成功。由此，对整个数学理论体系正确性和无矛盾性的论证就转化为对集合论的正确性和无矛盾性的论证，集合论成为整个数学大厦的根基。尽管卢素提出理发师悖论指出了集合论的局限性，一度动摇了这个根基，但是有惊无险，策莫罗提出的公理化集合论有效解决了理发师悖论问题，不仅稳定了数学根基，而且进一步确立了集合论在整个数学大厦中的基础地位。集合论被誉为十九世纪最伟大的数学成就，集合论的创始人康托被誉为整个十九世纪最伟大的数学家，没有之一。",极限理论的正确性依赖于自然数的正式数学定义，而自然数的定义依赖于集合论
集合论,发展,公理化集合论,,"众所周知，数学是整个自然科学体系的基础，人们对自然界的认识结论一般需要通过数学演算或数学证明来保证其正确性。打铁还需自身硬，从理论上说，数学既然能够作为一种可以鉴别认识结论真伪的基本工具，那么其自身就不应该有任何错误或矛盾。但实际情况并没有这么简单，千百年来陆续出现的希帕索斯悖论、贝克莱悖论、理发师悖论，使得数学理论的正确性面临一次又一次严峻挑战，历史上称之为数学危机。为拯救数学于危机之中，捍卫数学理论的正确性，无数杰出科学家做了大量深入系统的研究工作。直到在十九世纪初，柯西、维尔斯特拉斯等数学家通过创立极限理论，终于解决了希帕索斯悖论、贝克莱悖论问题，为实数理论和微积分的正确性奠定了坚实的基础。  
但是，极限理论在逻辑上还有需要完善的地方.因为极限概念由自然数定义，要保证极限理论的正确性，首先必须要保证自然数概念及相关理论的正确性。虽然自然数是大家熟知且常用的一个基本概念，大家从小学就开始学习自然数的计数和运算，但是对自然数概念的理解主要还是依靠经验。为保证极限理论的正确性，必须对自然数进行正式的数学定义。数学家冯·诺依曼用集合的方式定义了自然数并取得成功。由此，对整个数学理论体系正确性和无矛盾性的论证就转化为对集合论的正确性和无矛盾性的论证，集合论成为整个数学大厦的根基。尽管卢素提出理发师悖论指出了集合论的局限性，一度动摇了这个根基，但是有惊无险，策莫罗提出的公理化集合论有效解决了理发师悖论问题，不仅稳定了数学根基，而且进一步确立了集合论在整个数学大厦中的基础地位。集合论被誉为十九世纪最伟大的数学成就，集合论的创始人康托被誉为整个十九世纪最伟大的数学家，没有之一。",公理化集合论是为了解决集合论的局限性而提出的，进一步确立了集合论在数学中的基础地位
数学危机,影响,集合论,,"众所周知，数学是整个自然科学体系的基础，人们对自然界的认识结论一般需要通过数学演算或数学证明来保证其正确性。打铁还需自身硬，从理论上说，数学既然能够作为一种可以鉴别认识结论真伪的基本工具，那么其自身就不应该有任何错误或矛盾。但实际情况并没有这么简单，千百年来陆续出现的希帕索斯悖论、贝克莱悖论、理发师悖论，使得数学理论的正确性面临一次又一次严峻挑战，历史上称之为数学危机。为拯救数学于危机之中，捍卫数学理论的正确性，无数杰出科学家做了大量深入系统的研究工作。直到在十九世纪初，柯西、维尔斯特拉斯等数学家通过创立极限理论，终于解决了希帕索斯悖论、贝克莱悖论问题，为实数理论和微积分的正确性奠定了坚实的基础。  
但是，极限理论在逻辑上还有需要完善的地方.因为极限概念由自然数定义，要保证极限理论的正确性，首先必须要保证自然数概念及相关理论的正确性。虽然自然数是大家熟知且常用的一个基本概念，大家从小学就开始学习自然数的计数和运算，但是对自然数概念的理解主要还是依靠经验。为保证极限理论的正确性，必须对自然数进行正式的数学定义。数学家冯·诺依曼用集合的方式定义了自然数并取得成功。由此，对整个数学理论体系正确性和无矛盾性的论证就转化为对集合论的正确性和无矛盾性的论证，集合论成为整个数学大厦的根基。尽管卢素提出理发师悖论指出了集合论的局限性，一度动摇了这个根基，但是有惊无险，策莫罗提出的公理化集合论有效解决了理发师悖论问题，不仅稳定了数学根基，而且进一步确立了集合论在整个数学大厦中的基础地位。集合论被誉为十九世纪最伟大的数学成就，集合论的创始人康托被誉为整个十九世纪最伟大的数学家，没有之一。",数学危机促使了对集合论的深入研究和公理化集合论的提出
集合,包含,元素,,集合论从一个比数更加基本的概念——集合出发，定义出数和数的运算，进而演化出整个数学学科的理论体系。本小节将从集合的基本概念出发，介绍集合论中最为基础的知识，包括集合概念的含义、元素的概念与性质、集合的表示方法、集合之间的相等与包含关系、若干常用的特殊集合等。,集合包含元素
集合,使用,集合的表示方法,,集合论从一个比数更加基本的概念——集合出发，定义出数和数的运算，进而演化出整个数学学科的理论体系。本小节将从集合的基本概念出发，介绍集合论中最为基础的知识，包括集合概念的含义、元素的概念与性质、集合的表示方法、集合之间的相等与包含关系、若干常用的特殊集合等。,集合使用特定的表示方法来描述
集合,具有,集合之间的相等与包含关系,,集合论从一个比数更加基本的概念——集合出发，定义出数和数的运算，进而演化出整个数学学科的理论体系。本小节将从集合的基本概念出发，介绍集合论中最为基础的知识，包括集合概念的含义、元素的概念与性质、集合的表示方法、集合之间的相等与包含关系、若干常用的特殊集合等。,集合之间具有相等与包含关系
集合,包含,特殊集合,,集合论从一个比数更加基本的概念——集合出发，定义出数和数的运算，进而演化出整个数学学科的理论体系。本小节将从集合的基本概念出发，介绍集合论中最为基础的知识，包括集合概念的含义、元素的概念与性质、集合的表示方法、集合之间的相等与包含关系、若干常用的特殊集合等。,集合中包含特殊集合
元素,通过,集合的表示方法,,集合论从一个比数更加基本的概念——集合出发，定义出数和数的运算，进而演化出整个数学学科的理论体系。本小节将从集合的基本概念出发，介绍集合论中最为基础的知识，包括集合概念的含义、元素的概念与性质、集合的表示方法、集合之间的相等与包含关系、若干常用的特殊集合等。,元素通过集合的表示方法来标识
集合的表示方法,描述,集合之间的相等与包含关系,,集合论从一个比数更加基本的概念——集合出发，定义出数和数的运算，进而演化出整个数学学科的理论体系。本小节将从集合的基本概念出发，介绍集合论中最为基础的知识，包括集合概念的含义、元素的概念与性质、集合的表示方法、集合之间的相等与包含关系、若干常用的特殊集合等。,集合的表示方法用于描述集合之间的相等与包含关系
集合之间的相等与包含关系,应用,特殊集合,,集合论从一个比数更加基本的概念——集合出发，定义出数和数的运算，进而演化出整个数学学科的理论体系。本小节将从集合的基本概念出发，介绍集合论中最为基础的知识，包括集合概念的含义、元素的概念与性质、集合的表示方法、集合之间的相等与包含关系、若干常用的特殊集合等。,集合之间的相等与包含关系应用于特殊集合
集合,包含,元素,,"我们知道，如果要定义一个概念，必须要使用其它概念。例如，在“边长相等的三角形是等边三角形”这个定义中，就要用到边长、相等、三角形等概念。而要定义其它概念就必须使用另外其它的概念，而且不能循环使用。如此下去，必然会存在一些最原始的概念作为一切概念的出发点，只能使用这些原始概念来定义其它概念而不能用其它概念来定义这些原始概念。也就是说，这些原始概念的含义是不言自明的，只能通过其它的概念去理解或解释其含义，而不能对其下严格的定义。例如，几何学中的点、线、面的概念就是原始概念，我们都知道这些概念的具体含义，但它们是没有定义的。  
集合就是这样一种没有定义的原始概念，我们可对其含义进行如下描述或理解：  
所谓集合，就是在指定范围内满足给定条件、能相互区分的所有对象构成的总体，集合中每个对象称为该集合的元素。  
（1） 硬币有两面——正面和反面，“正面、反面”构成一集合。（2） 计算机内存的全体单元构成一集合。 （3） 所有三角形构成的三角形集合。 （4） 所有正整数的集合。  
根据集合概念的上述解释，不难看出元素与集合之间的归属关系是明确的：对于任意一个集合和任意一个对象，该对象要么属于这个集合，要么不属于这个集合，两者必居其一且仅居其一。除此之外，还可看出集合中每个元素必须满足如下三条基本性质：  
1。互异性：集合中的每个元素都是互不相同的，凡是相同的元素都视为同一元素。例如集合{5, 5, 6}应该理解为$\{5,\,6\}$。  
2。可分性：集合中的每个元素都是可以明确加以区分的对象。3。无序性：集合中的元素之间是没有次序的。例如：{5, 6}和{6, 5}应视为同一集合。  
通常用带下标或不带下标的大写英文字母$A$，$B$，$C$，…表示集合，用带下标或不带下标的小写英文字母$x$，y，$z$，…表示集合中的对象或元素。  
【定义1.1】对于任意一个对象$x$ 和任意一个集合𝐴，当对象$x$ 是集合$\cdot A$中元素时，称$x$属于𝑨，记为$x\in A$；当对象$x$ 不是集合$A$ 中元素时，称$_x$ 不属于$A$，记为$x\notin A$。  
罗素悖论产生的原因是集合的定义不受限制。经过研究发现如果允许将集合作为其自身的元素，则会产生一些矛盾或悖论.因此，德国数学家康托之后创立的许多公理化集合论都直接或间接地限制集合成为它自己的元素，有效避免了罗素悖论。",集合是由满足给定条件的所有对象构成的总体，集合中的每个对象称为该集合的元素，元素与集合之间存在明确的归属关系。
集合,引发,罗素悖论,,"我们知道，如果要定义一个概念，必须要使用其它概念。例如，在“边长相等的三角形是等边三角形”这个定义中，就要用到边长、相等、三角形等概念。而要定义其它概念就必须使用另外其它的概念，而且不能循环使用。如此下去，必然会存在一些最原始的概念作为一切概念的出发点，只能使用这些原始概念来定义其它概念而不能用其它概念来定义这些原始概念。也就是说，这些原始概念的含义是不言自明的，只能通过其它的概念去理解或解释其含义，而不能对其下严格的定义。例如，几何学中的点、线、面的概念就是原始概念，我们都知道这些概念的具体含义，但它们是没有定义的。  
集合就是这样一种没有定义的原始概念，我们可对其含义进行如下描述或理解：  
所谓集合，就是在指定范围内满足给定条件、能相互区分的所有对象构成的总体，集合中每个对象称为该集合的元素。  
（1） 硬币有两面——正面和反面，“正面、反面”构成一集合。（2） 计算机内存的全体单元构成一集合。 （3） 所有三角形构成的三角形集合。 （4） 所有正整数的集合。  
根据集合概念的上述解释，不难看出元素与集合之间的归属关系是明确的：对于任意一个集合和任意一个对象，该对象要么属于这个集合，要么不属于这个集合，两者必居其一且仅居其一。除此之外，还可看出集合中每个元素必须满足如下三条基本性质：  
1。互异性：集合中的每个元素都是互不相同的，凡是相同的元素都视为同一元素。例如集合{5, 5, 6}应该理解为$\{5,\,6\}$。  
2。可分性：集合中的每个元素都是可以明确加以区分的对象。3。无序性：集合中的元素之间是没有次序的。例如：{5, 6}和{6, 5}应视为同一集合。  
通常用带下标或不带下标的大写英文字母$A$，$B$，$C$，…表示集合，用带下标或不带下标的小写英文字母$x$，y，$z$，…表示集合中的对象或元素。  
【定义1.1】对于任意一个对象$x$ 和任意一个集合𝐴，当对象$x$ 是集合$\cdot A$中元素时，称$x$属于𝑨，记为$x\in A$；当对象$x$ 不是集合$A$ 中元素时，称$_x$ 不属于$A$，记为$x\notin A$。  
罗素悖论产生的原因是集合的定义不受限制。经过研究发现如果允许将集合作为其自身的元素，则会产生一些矛盾或悖论.因此，德国数学家康托之后创立的许多公理化集合论都直接或间接地限制集合成为它自己的元素，有效避免了罗素悖论。",罗素悖论的产生是由于集合的定义不受限制，特别是当集合被允许作为其自身的元素时，会导致矛盾或悖论。
集合的表示方法,包含,枚举法,,集合的表示方法主要有枚举法、描述法、归纳法和文氏图法。,枚举法是集合的表示方法之一
集合的表示方法,包含,描述法,,集合的表示方法主要有枚举法、描述法、归纳法和文氏图法。,描述法是集合的表示方法之一
集合的表示方法,包含,归纳法,,集合的表示方法主要有枚举法、描述法、归纳法和文氏图法。,归纳法是集合的表示方法之一
集合的表示方法,包含,文氏图法,,集合的表示方法主要有枚举法、描述法、归纳法和文氏图法。,文氏图法是集合的表示方法之一
枚举法,表示,集合,,"所谓枚举法，就是列出集合中所有元素或者可以看出元素变化规律的部分元素。对于一个集合，如果该集合中仅含个数较少的有限个元素，或者集合中元素之间有明显关系时，通常使用枚举法表示该集合。  
枚举法表示的是集合的外延，是一种显示表示方法，具有直观性强、易于理解等优点。但对于元素数目较多的集合，枚举法显然不是一种有效方法、甚至不可行。从计算机的角度看，如果一次性将大量数据输入计算机，将占据大量内存。因此，有时需要使用描述法、归纳法等其它方式来表示集合。",枚举法用于列出集合中所有元素或部分元素，适用于元素较少或元素间有明显关系的集合
枚举法,替代,描述法,,"所谓枚举法，就是列出集合中所有元素或者可以看出元素变化规律的部分元素。对于一个集合，如果该集合中仅含个数较少的有限个元素，或者集合中元素之间有明显关系时，通常使用枚举法表示该集合。  
枚举法表示的是集合的外延，是一种显示表示方法，具有直观性强、易于理解等优点。但对于元素数目较多的集合，枚举法显然不是一种有效方法、甚至不可行。从计算机的角度看，如果一次性将大量数据输入计算机，将占据大量内存。因此，有时需要使用描述法、归纳法等其它方式来表示集合。",对于元素数目较多的集合，枚举法不适用，需使用描述法等其它方式表示
枚举法,替代,归纳法,,"所谓枚举法，就是列出集合中所有元素或者可以看出元素变化规律的部分元素。对于一个集合，如果该集合中仅含个数较少的有限个元素，或者集合中元素之间有明显关系时，通常使用枚举法表示该集合。  
枚举法表示的是集合的外延，是一种显示表示方法，具有直观性强、易于理解等优点。但对于元素数目较多的集合，枚举法显然不是一种有效方法、甚至不可行。从计算机的角度看，如果一次性将大量数据输入计算机，将占据大量内存。因此，有时需要使用描述法、归纳法等其它方式来表示集合。",对于元素数目较多的集合，枚举法不适用，需使用归纳法等其它方式表示
描述法,表示,集合,,"所谓描述法，就是描述集合中元素所具备的某种特性来表示集合。通常用数学符号来表示集合中的任意元素都具有性质$P$。集合描述法表示的具体形式如下：  
$$
A=\{x|P(x)\}
$$  
其中：符号$P(x)$表示元素$x$具有性质$P$  
描述法表示的是集合的内涵，是一种隐式表示方法，表达内容具有一定的抽象性和普适性。描述法的优点是不需要列出集合中全部元素，只需给出集合中元素的描述特性。因此，描述法的表达能力很强，既可表示有限集合，也可表示无限集合。",描述法通过描述集合中元素的特性来表示集合
描述法,使用,性质P,,"所谓描述法，就是描述集合中元素所具备的某种特性来表示集合。通常用数学符号来表示集合中的任意元素都具有性质$P$。集合描述法表示的具体形式如下：  
$$
A=\{x|P(x)\}
$$  
其中：符号$P(x)$表示元素$x$具有性质$P$  
描述法表示的是集合的内涵，是一种隐式表示方法，表达内容具有一定的抽象性和普适性。描述法的优点是不需要列出集合中全部元素，只需给出集合中元素的描述特性。因此，描述法的表达能力很强，既可表示有限集合，也可表示无限集合。",描述法使用数学符号表示集合中任意元素具有的性质P
描述法,表示,内涵,,"所谓描述法，就是描述集合中元素所具备的某种特性来表示集合。通常用数学符号来表示集合中的任意元素都具有性质$P$。集合描述法表示的具体形式如下：  
$$
A=\{x|P(x)\}
$$  
其中：符号$P(x)$表示元素$x$具有性质$P$  
描述法表示的是集合的内涵，是一种隐式表示方法，表达内容具有一定的抽象性和普适性。描述法的优点是不需要列出集合中全部元素，只需给出集合中元素的描述特性。因此，描述法的表达能力很强，既可表示有限集合，也可表示无限集合。",描述法表示集合的内涵，是一种隐式表示方法
描述法,具有,抽象性和普适性,,"所谓描述法，就是描述集合中元素所具备的某种特性来表示集合。通常用数学符号来表示集合中的任意元素都具有性质$P$。集合描述法表示的具体形式如下：  
$$
A=\{x|P(x)\}
$$  
其中：符号$P(x)$表示元素$x$具有性质$P$  
描述法表示的是集合的内涵，是一种隐式表示方法，表达内容具有一定的抽象性和普适性。描述法的优点是不需要列出集合中全部元素，只需给出集合中元素的描述特性。因此，描述法的表达能力很强，既可表示有限集合，也可表示无限集合。",描述法表达内容具有一定的抽象性和普适性
描述法,表示,有限集合,,"所谓描述法，就是描述集合中元素所具备的某种特性来表示集合。通常用数学符号来表示集合中的任意元素都具有性质$P$。集合描述法表示的具体形式如下：  
$$
A=\{x|P(x)\}
$$  
其中：符号$P(x)$表示元素$x$具有性质$P$  
描述法表示的是集合的内涵，是一种隐式表示方法，表达内容具有一定的抽象性和普适性。描述法的优点是不需要列出集合中全部元素，只需给出集合中元素的描述特性。因此，描述法的表达能力很强，既可表示有限集合，也可表示无限集合。",描述法可以表示有限集合
描述法,表示,无限集合,,"所谓描述法，就是描述集合中元素所具备的某种特性来表示集合。通常用数学符号来表示集合中的任意元素都具有性质$P$。集合描述法表示的具体形式如下：  
$$
A=\{x|P(x)\}
$$  
其中：符号$P(x)$表示元素$x$具有性质$P$  
描述法表示的是集合的内涵，是一种隐式表示方法，表达内容具有一定的抽象性和普适性。描述法的优点是不需要列出集合中全部元素，只需给出集合中元素的描述特性。因此，描述法的表达能力很强，既可表示有限集合，也可表示无限集合。",描述法可以表示无限集合
归纳法,构造,集合,,"归纳法是一种基于构造策略的表示方法。该方法通过定义一些规则把集合构造出来，由此实现对集合的表示。具体的构造规则通常由如下三个部分组成：  
（1）基础部分：确定集合中某些最基本的元素；（2）归纳部分：确定由集合中已有元素构造出新元素的规则或方法；（3）边界部分：确定集合在通过构造元素实现不断扩张的过程中不能超过的界限。  
上述基础部分决定了该集合为非空集合并确定了集合的初始元素，归纳部分则根据集合中初始元素通过一定的规则或方法不断构造出新的元素，是集合不断扩张的过程，边界部分则是对集合的扩张进行限制，给出了集合的边界，由此构成一个具有确定边界的集合。  
总之，基础部分和归纳部分确定了集合中至少包含哪些元素，边界部分则是确定了集合中最多包含哪些元素。  
集合归纳表示法的构造性特点非常适合用计算机进行处理，在计算机相关领域得到广泛应用。在后续内容中，我们将会看到，通过用归纳法构造集合的方式来定义一个概念或设计一个算法，在计算机相关领域是一件屡见不鲜的事情。",归纳法通过定义基础部分、归纳部分和边界部分的规则来构造集合，实现对集合的表示
归纳法,应用,计算机相关领域,,"归纳法是一种基于构造策略的表示方法。该方法通过定义一些规则把集合构造出来，由此实现对集合的表示。具体的构造规则通常由如下三个部分组成：  
（1）基础部分：确定集合中某些最基本的元素；（2）归纳部分：确定由集合中已有元素构造出新元素的规则或方法；（3）边界部分：确定集合在通过构造元素实现不断扩张的过程中不能超过的界限。  
上述基础部分决定了该集合为非空集合并确定了集合的初始元素，归纳部分则根据集合中初始元素通过一定的规则或方法不断构造出新的元素，是集合不断扩张的过程，边界部分则是对集合的扩张进行限制，给出了集合的边界，由此构成一个具有确定边界的集合。  
总之，基础部分和归纳部分确定了集合中至少包含哪些元素，边界部分则是确定了集合中最多包含哪些元素。  
集合归纳表示法的构造性特点非常适合用计算机进行处理，在计算机相关领域得到广泛应用。在后续内容中，我们将会看到，通过用归纳法构造集合的方式来定义一个概念或设计一个算法，在计算机相关领域是一件屡见不鲜的事情。",归纳法的构造性特点使其在计算机相关领域得到广泛应用，用于定义概念或设计算法
集合,表示,文氏图法,,文氏图（或称文恩图）以英国数学家文恩的名字命名.文恩在1881 年介绍了这种图的使用方法。文氏图用长方形表示全集，用长方形内部的圆或其它几何图形表示普通集合。文氏图常用于形象地表示集合之间的关系。,文氏图法用长方形内部的圆或其它几何图形表示普通集合，常用于形象地表示集合之间的关系
集合,定义,外延性原理,,"如前所述，集合中凡是相同的元素都看成是同一个元素，而且集合中元素之间的排列次序也不加区分，或者说是无序的。如此一来，集合就完全取决于集合中的元素。换句话说，对于任意两个集合，如果这两个集合中具有完全相同的元素，那么这两个集合就是完全一样的。或者说，这两个集合是相等的。于是得到如下关于集合相等的外延性原理：  
【定理1.1】（外延性原理）对于任意的集合$A$ 和集合$B$，$\pmb{A}$ 与$\pmb{B}$ 相等当且仅当两者具有相同元素；或者说，$\pmb{A}$ 与$\pmb{B}$ 相等当且仅当$A$ 中每个元素都属于$B$ 且$B$ 中每个元素都属于$A$。如果集合$A$ 与$B$ 相等，则记为$A=B$；否则，如果$A$ 与$B$ 不相等，则记为$A\ne B$。  
【定理1.2】集合的相等关系具有如下三条基本性质： （1）自反性：对于任意给定的集合$A$，成立$A{=}A$； （2）对称性：对于任意给定的两个集合$A$ 和$B$，若有$A{=}B$，则有$B{=}A$；  
（3）传递性：对于任意三个集合$A$、$B$、$C$，若有$A{=}B$ 且$B{=}C$，则有$_{A=C}$  
由【例题1.9】可以看出，集合$C$ 中的每个元素都是集合$A$ 中的元素，此时$A$ 完全包含了$C$，可将$C$ 看成是$A$ 的一个部分，由此得到如下集合的包含关系和子集的概念：  
【定义1.2】对于任意两个集合$A$ 和$B$，若$B$ 中的每个元素都是$A$ 中的元素，则称$\pmb{B}$ 包含于$\pmb{A}$（或$\pmb{A}$ 包含$\pmb{B}$），记为$B\subseteq A$，亦称$\pmb{B}$ 是$\pmb{A}$ 的子集，称符号$\subseteq$为集合之间的包含关系。如果$B$ 不能被$A$ 所包含，则称$\pmb{B}$ 不是$\pmb{A}$ 的子集，记为$B\nsubseteq A$。  
【定理1.3】集合的包含关系具有如下三条基本性质：（1）自反性：对于任意给定的集合$A$，都成立$A\subseteq A$  
（2）反对称性：对于任意两个集合$A$ 和$B$，$A{=}B$当且仅当$A\subseteq B$且$B\subseteq A$（3）传递性：对于任意三个集合$A$、$B$、$C$，若$A\subseteq B$且$B\subseteq C$，则$A\subseteq C$  
【定义1.3】对于任意两个集合$A$ 和$B$，如果$B\subseteq A$且$A\neq B$，则称$B$ 是$A$ 的真子集，记为$\mathrm{B}\subset\mathrm{A}$，并称符号$\subset$为集合之间的真包含关系。",外延性原理定义了集合相等的条件，即两个集合相等当且仅当它们具有相同的元素。
集合,具有,集合的相等关系,,"如前所述，集合中凡是相同的元素都看成是同一个元素，而且集合中元素之间的排列次序也不加区分，或者说是无序的。如此一来，集合就完全取决于集合中的元素。换句话说，对于任意两个集合，如果这两个集合中具有完全相同的元素，那么这两个集合就是完全一样的。或者说，这两个集合是相等的。于是得到如下关于集合相等的外延性原理：  
【定理1.1】（外延性原理）对于任意的集合$A$ 和集合$B$，$\pmb{A}$ 与$\pmb{B}$ 相等当且仅当两者具有相同元素；或者说，$\pmb{A}$ 与$\pmb{B}$ 相等当且仅当$A$ 中每个元素都属于$B$ 且$B$ 中每个元素都属于$A$。如果集合$A$ 与$B$ 相等，则记为$A=B$；否则，如果$A$ 与$B$ 不相等，则记为$A\ne B$。  
【定理1.2】集合的相等关系具有如下三条基本性质： （1）自反性：对于任意给定的集合$A$，成立$A{=}A$； （2）对称性：对于任意给定的两个集合$A$ 和$B$，若有$A{=}B$，则有$B{=}A$；  
（3）传递性：对于任意三个集合$A$、$B$、$C$，若有$A{=}B$ 且$B{=}C$，则有$_{A=C}$  
由【例题1.9】可以看出，集合$C$ 中的每个元素都是集合$A$ 中的元素，此时$A$ 完全包含了$C$，可将$C$ 看成是$A$ 的一个部分，由此得到如下集合的包含关系和子集的概念：  
【定义1.2】对于任意两个集合$A$ 和$B$，若$B$ 中的每个元素都是$A$ 中的元素，则称$\pmb{B}$ 包含于$\pmb{A}$（或$\pmb{A}$ 包含$\pmb{B}$），记为$B\subseteq A$，亦称$\pmb{B}$ 是$\pmb{A}$ 的子集，称符号$\subseteq$为集合之间的包含关系。如果$B$ 不能被$A$ 所包含，则称$\pmb{B}$ 不是$\pmb{A}$ 的子集，记为$B\nsubseteq A$。  
【定理1.3】集合的包含关系具有如下三条基本性质：（1）自反性：对于任意给定的集合$A$，都成立$A\subseteq A$  
（2）反对称性：对于任意两个集合$A$ 和$B$，$A{=}B$当且仅当$A\subseteq B$且$B\subseteq A$（3）传递性：对于任意三个集合$A$、$B$、$C$，若$A\subseteq B$且$B\subseteq C$，则$A\subseteq C$  
【定义1.3】对于任意两个集合$A$ 和$B$，如果$B\subseteq A$且$A\neq B$，则称$B$ 是$A$ 的真子集，记为$\mathrm{B}\subset\mathrm{A}$，并称符号$\subset$为集合之间的真包含关系。",集合的相等关系具有自反性、对称性和传递性。
集合,包含,子集,,"如前所述，集合中凡是相同的元素都看成是同一个元素，而且集合中元素之间的排列次序也不加区分，或者说是无序的。如此一来，集合就完全取决于集合中的元素。换句话说，对于任意两个集合，如果这两个集合中具有完全相同的元素，那么这两个集合就是完全一样的。或者说，这两个集合是相等的。于是得到如下关于集合相等的外延性原理：  
【定理1.1】（外延性原理）对于任意的集合$A$ 和集合$B$，$\pmb{A}$ 与$\pmb{B}$ 相等当且仅当两者具有相同元素；或者说，$\pmb{A}$ 与$\pmb{B}$ 相等当且仅当$A$ 中每个元素都属于$B$ 且$B$ 中每个元素都属于$A$。如果集合$A$ 与$B$ 相等，则记为$A=B$；否则，如果$A$ 与$B$ 不相等，则记为$A\ne B$。  
【定理1.2】集合的相等关系具有如下三条基本性质： （1）自反性：对于任意给定的集合$A$，成立$A{=}A$； （2）对称性：对于任意给定的两个集合$A$ 和$B$，若有$A{=}B$，则有$B{=}A$；  
（3）传递性：对于任意三个集合$A$、$B$、$C$，若有$A{=}B$ 且$B{=}C$，则有$_{A=C}$  
由【例题1.9】可以看出，集合$C$ 中的每个元素都是集合$A$ 中的元素，此时$A$ 完全包含了$C$，可将$C$ 看成是$A$ 的一个部分，由此得到如下集合的包含关系和子集的概念：  
【定义1.2】对于任意两个集合$A$ 和$B$，若$B$ 中的每个元素都是$A$ 中的元素，则称$\pmb{B}$ 包含于$\pmb{A}$（或$\pmb{A}$ 包含$\pmb{B}$），记为$B\subseteq A$，亦称$\pmb{B}$ 是$\pmb{A}$ 的子集，称符号$\subseteq$为集合之间的包含关系。如果$B$ 不能被$A$ 所包含，则称$\pmb{B}$ 不是$\pmb{A}$ 的子集，记为$B\nsubseteq A$。  
【定理1.3】集合的包含关系具有如下三条基本性质：（1）自反性：对于任意给定的集合$A$，都成立$A\subseteq A$  
（2）反对称性：对于任意两个集合$A$ 和$B$，$A{=}B$当且仅当$A\subseteq B$且$B\subseteq A$（3）传递性：对于任意三个集合$A$、$B$、$C$，若$A\subseteq B$且$B\subseteq C$，则$A\subseteq C$  
【定义1.3】对于任意两个集合$A$ 和$B$，如果$B\subseteq A$且$A\neq B$，则称$B$ 是$A$ 的真子集，记为$\mathrm{B}\subset\mathrm{A}$，并称符号$\subset$为集合之间的真包含关系。",如果一个集合中的每个元素都是另一个集合中的元素，则前者是后者的子集。
集合,定义,集合的包含关系,,"如前所述，集合中凡是相同的元素都看成是同一个元素，而且集合中元素之间的排列次序也不加区分，或者说是无序的。如此一来，集合就完全取决于集合中的元素。换句话说，对于任意两个集合，如果这两个集合中具有完全相同的元素，那么这两个集合就是完全一样的。或者说，这两个集合是相等的。于是得到如下关于集合相等的外延性原理：  
【定理1.1】（外延性原理）对于任意的集合$A$ 和集合$B$，$\pmb{A}$ 与$\pmb{B}$ 相等当且仅当两者具有相同元素；或者说，$\pmb{A}$ 与$\pmb{B}$ 相等当且仅当$A$ 中每个元素都属于$B$ 且$B$ 中每个元素都属于$A$。如果集合$A$ 与$B$ 相等，则记为$A=B$；否则，如果$A$ 与$B$ 不相等，则记为$A\ne B$。  
【定理1.2】集合的相等关系具有如下三条基本性质： （1）自反性：对于任意给定的集合$A$，成立$A{=}A$； （2）对称性：对于任意给定的两个集合$A$ 和$B$，若有$A{=}B$，则有$B{=}A$；  
（3）传递性：对于任意三个集合$A$、$B$、$C$，若有$A{=}B$ 且$B{=}C$，则有$_{A=C}$  
由【例题1.9】可以看出，集合$C$ 中的每个元素都是集合$A$ 中的元素，此时$A$ 完全包含了$C$，可将$C$ 看成是$A$ 的一个部分，由此得到如下集合的包含关系和子集的概念：  
【定义1.2】对于任意两个集合$A$ 和$B$，若$B$ 中的每个元素都是$A$ 中的元素，则称$\pmb{B}$ 包含于$\pmb{A}$（或$\pmb{A}$ 包含$\pmb{B}$），记为$B\subseteq A$，亦称$\pmb{B}$ 是$\pmb{A}$ 的子集，称符号$\subseteq$为集合之间的包含关系。如果$B$ 不能被$A$ 所包含，则称$\pmb{B}$ 不是$\pmb{A}$ 的子集，记为$B\nsubseteq A$。  
【定理1.3】集合的包含关系具有如下三条基本性质：（1）自反性：对于任意给定的集合$A$，都成立$A\subseteq A$  
（2）反对称性：对于任意两个集合$A$ 和$B$，$A{=}B$当且仅当$A\subseteq B$且$B\subseteq A$（3）传递性：对于任意三个集合$A$、$B$、$C$，若$A\subseteq B$且$B\subseteq C$，则$A\subseteq C$  
【定义1.3】对于任意两个集合$A$ 和$B$，如果$B\subseteq A$且$A\neq B$，则称$B$ 是$A$ 的真子集，记为$\mathrm{B}\subset\mathrm{A}$，并称符号$\subset$为集合之间的真包含关系。",集合的包含关系定义了一个集合包含另一个集合的条件，即后者的每个元素都是前者的元素。
子集,特化,真子集,,"如前所述，集合中凡是相同的元素都看成是同一个元素，而且集合中元素之间的排列次序也不加区分，或者说是无序的。如此一来，集合就完全取决于集合中的元素。换句话说，对于任意两个集合，如果这两个集合中具有完全相同的元素，那么这两个集合就是完全一样的。或者说，这两个集合是相等的。于是得到如下关于集合相等的外延性原理：  
【定理1.1】（外延性原理）对于任意的集合$A$ 和集合$B$，$\pmb{A}$ 与$\pmb{B}$ 相等当且仅当两者具有相同元素；或者说，$\pmb{A}$ 与$\pmb{B}$ 相等当且仅当$A$ 中每个元素都属于$B$ 且$B$ 中每个元素都属于$A$。如果集合$A$ 与$B$ 相等，则记为$A=B$；否则，如果$A$ 与$B$ 不相等，则记为$A\ne B$。  
【定理1.2】集合的相等关系具有如下三条基本性质： （1）自反性：对于任意给定的集合$A$，成立$A{=}A$； （2）对称性：对于任意给定的两个集合$A$ 和$B$，若有$A{=}B$，则有$B{=}A$；  
（3）传递性：对于任意三个集合$A$、$B$、$C$，若有$A{=}B$ 且$B{=}C$，则有$_{A=C}$  
由【例题1.9】可以看出，集合$C$ 中的每个元素都是集合$A$ 中的元素，此时$A$ 完全包含了$C$，可将$C$ 看成是$A$ 的一个部分，由此得到如下集合的包含关系和子集的概念：  
【定义1.2】对于任意两个集合$A$ 和$B$，若$B$ 中的每个元素都是$A$ 中的元素，则称$\pmb{B}$ 包含于$\pmb{A}$（或$\pmb{A}$ 包含$\pmb{B}$），记为$B\subseteq A$，亦称$\pmb{B}$ 是$\pmb{A}$ 的子集，称符号$\subseteq$为集合之间的包含关系。如果$B$ 不能被$A$ 所包含，则称$\pmb{B}$ 不是$\pmb{A}$ 的子集，记为$B\nsubseteq A$。  
【定理1.3】集合的包含关系具有如下三条基本性质：（1）自反性：对于任意给定的集合$A$，都成立$A\subseteq A$  
（2）反对称性：对于任意两个集合$A$ 和$B$，$A{=}B$当且仅当$A\subseteq B$且$B\subseteq A$（3）传递性：对于任意三个集合$A$、$B$、$C$，若$A\subseteq B$且$B\subseteq C$，则$A\subseteq C$  
【定义1.3】对于任意两个集合$A$ 和$B$，如果$B\subseteq A$且$A\neq B$，则称$B$ 是$A$ 的真子集，记为$\mathrm{B}\subset\mathrm{A}$，并称符号$\subset$为集合之间的真包含关系。",如果一个集合是另一个集合的子集且两者不相等，则前者是后者的真子集。
集合的包含关系,特化,真子集,,"如前所述，集合中凡是相同的元素都看成是同一个元素，而且集合中元素之间的排列次序也不加区分，或者说是无序的。如此一来，集合就完全取决于集合中的元素。换句话说，对于任意两个集合，如果这两个集合中具有完全相同的元素，那么这两个集合就是完全一样的。或者说，这两个集合是相等的。于是得到如下关于集合相等的外延性原理：  
【定理1.1】（外延性原理）对于任意的集合$A$ 和集合$B$，$\pmb{A}$ 与$\pmb{B}$ 相等当且仅当两者具有相同元素；或者说，$\pmb{A}$ 与$\pmb{B}$ 相等当且仅当$A$ 中每个元素都属于$B$ 且$B$ 中每个元素都属于$A$。如果集合$A$ 与$B$ 相等，则记为$A=B$；否则，如果$A$ 与$B$ 不相等，则记为$A\ne B$。  
【定理1.2】集合的相等关系具有如下三条基本性质： （1）自反性：对于任意给定的集合$A$，成立$A{=}A$； （2）对称性：对于任意给定的两个集合$A$ 和$B$，若有$A{=}B$，则有$B{=}A$；  
（3）传递性：对于任意三个集合$A$、$B$、$C$，若有$A{=}B$ 且$B{=}C$，则有$_{A=C}$  
由【例题1.9】可以看出，集合$C$ 中的每个元素都是集合$A$ 中的元素，此时$A$ 完全包含了$C$，可将$C$ 看成是$A$ 的一个部分，由此得到如下集合的包含关系和子集的概念：  
【定义1.2】对于任意两个集合$A$ 和$B$，若$B$ 中的每个元素都是$A$ 中的元素，则称$\pmb{B}$ 包含于$\pmb{A}$（或$\pmb{A}$ 包含$\pmb{B}$），记为$B\subseteq A$，亦称$\pmb{B}$ 是$\pmb{A}$ 的子集，称符号$\subseteq$为集合之间的包含关系。如果$B$ 不能被$A$ 所包含，则称$\pmb{B}$ 不是$\pmb{A}$ 的子集，记为$B\nsubseteq A$。  
【定理1.3】集合的包含关系具有如下三条基本性质：（1）自反性：对于任意给定的集合$A$，都成立$A\subseteq A$  
（2）反对称性：对于任意两个集合$A$ 和$B$，$A{=}B$当且仅当$A\subseteq B$且$B\subseteq A$（3）传递性：对于任意三个集合$A$、$B$、$C$，若$A\subseteq B$且$B\subseteq C$，则$A\subseteq C$  
【定义1.3】对于任意两个集合$A$ 和$B$，如果$B\subseteq A$且$A\neq B$，则称$B$ 是$A$ 的真子集，记为$\mathrm{B}\subset\mathrm{A}$，并称符号$\subset$为集合之间的真包含关系。",真子集是集合包含关系的一种特化，表示一个集合严格包含另一个集合。
集合,包含,空集,,集合论中有一些非常重要和常用的特殊集合，它们分别具有一些特殊性质。离散数学中很多基本概念的定义及其性质讨论都离不开它们。下面具体介绍这些特殊集合的基本概念及性质，包括空集、全集、有限集、无限集、子集、幂集等。,集合包含空集
集合,包含,全集,,集合论中有一些非常重要和常用的特殊集合，它们分别具有一些特殊性质。离散数学中很多基本概念的定义及其性质讨论都离不开它们。下面具体介绍这些特殊集合的基本概念及性质，包括空集、全集、有限集、无限集、子集、幂集等。,集合包含全集
集合,包含,有限集,,集合论中有一些非常重要和常用的特殊集合，它们分别具有一些特殊性质。离散数学中很多基本概念的定义及其性质讨论都离不开它们。下面具体介绍这些特殊集合的基本概念及性质，包括空集、全集、有限集、无限集、子集、幂集等。,集合包含有限集
集合,包含,无限集,,集合论中有一些非常重要和常用的特殊集合，它们分别具有一些特殊性质。离散数学中很多基本概念的定义及其性质讨论都离不开它们。下面具体介绍这些特殊集合的基本概念及性质，包括空集、全集、有限集、无限集、子集、幂集等。,集合包含无限集
集合,包含,子集,,集合论中有一些非常重要和常用的特殊集合，它们分别具有一些特殊性质。离散数学中很多基本概念的定义及其性质讨论都离不开它们。下面具体介绍这些特殊集合的基本概念及性质，包括空集、全集、有限集、无限集、子集、幂集等。,集合包含子集
集合,包含,幂集,,集合论中有一些非常重要和常用的特殊集合，它们分别具有一些特殊性质。离散数学中很多基本概念的定义及其性质讨论都离不开它们。下面具体介绍这些特殊集合的基本概念及性质，包括空集、全集、有限集、无限集、子集、幂集等。,集合包含幂集
空集,子集关系,全集,,"通常将不包含任何元素的集合定义为空集，即有：  
【定义1.4】不含任何元素的集合称为空集，记作$\varnothing$。  
【定理1.4】空集是一切集合的子集并且是绝对唯一的。  
在日常生活和实际工作中，对任何一个问题的讨论和处理一般都是在一个相对固定的范围之内。这个范围构成了问题讨论的默认论域或背景，由此得到如下全集的概念：  
【定义1.5】相对固定范围之内所有元素组成的集合称为全集，通常用$U$ 表示。  
在集合的文氏图表示法中，一般用矩形表示全集，圆形表示非全集集合。 对于每个具体的问题，默认论域或背景应当是唯一的，否则就会引起该问题在概念理解上的歧义和混乱。但是，对于不同的问题，通常具有与之相应的不同默认论域或背景，因而具有与之相应的不同全集。因此，全集是相对唯一的。",空集是全集的子集
空集,唯一性,全集,,"通常将不包含任何元素的集合定义为空集，即有：  
【定义1.4】不含任何元素的集合称为空集，记作$\varnothing$。  
【定理1.4】空集是一切集合的子集并且是绝对唯一的。  
在日常生活和实际工作中，对任何一个问题的讨论和处理一般都是在一个相对固定的范围之内。这个范围构成了问题讨论的默认论域或背景，由此得到如下全集的概念：  
【定义1.5】相对固定范围之内所有元素组成的集合称为全集，通常用$U$ 表示。  
在集合的文氏图表示法中，一般用矩形表示全集，圆形表示非全集集合。 对于每个具体的问题，默认论域或背景应当是唯一的，否则就会引起该问题在概念理解上的歧义和混乱。但是，对于不同的问题，通常具有与之相应的不同默认论域或背景，因而具有与之相应的不同全集。因此，全集是相对唯一的。",空集是绝对唯一的，而全集是相对唯一的
集合基数,定义,有限集,,"在集合的理论研究和实际应用中，经常需要对集合中元素的数量规模进行度量，由此得到集合基数的概念，具体定义如下：  
【定义1.6】对于任意集合$A$，$A$ 中所含元素的个数称为$A$ 的基数，记为$|A|\circ$  
【定义1.7】对于任意给定的集合$A$，如果它的基数是一个有限数，则称该集合是一个有限集，否则称之为无限集。  
有限集中元素的个数是有限的，无限集中元素的个数是无限的。无论从概念上还是方法看，有限集和无限集的规模度量或计数都有着本质上的区别，我们将在后续相关内容中对此做具体介绍和分析。",集合基数为有限数的集合称为有限集
集合基数,定义,无限集,,"在集合的理论研究和实际应用中，经常需要对集合中元素的数量规模进行度量，由此得到集合基数的概念，具体定义如下：  
【定义1.6】对于任意集合$A$，$A$ 中所含元素的个数称为$A$ 的基数，记为$|A|\circ$  
【定义1.7】对于任意给定的集合$A$，如果它的基数是一个有限数，则称该集合是一个有限集，否则称之为无限集。  
有限集中元素的个数是有限的，无限集中元素的个数是无限的。无论从概念上还是方法看，有限集和无限集的规模度量或计数都有着本质上的区别，我们将在后续相关内容中对此做具体介绍和分析。",集合基数为无限数的集合称为无限集
有限集,对比,无限集,,"在集合的理论研究和实际应用中，经常需要对集合中元素的数量规模进行度量，由此得到集合基数的概念，具体定义如下：  
【定义1.6】对于任意集合$A$，$A$ 中所含元素的个数称为$A$ 的基数，记为$|A|\circ$  
【定义1.7】对于任意给定的集合$A$，如果它的基数是一个有限数，则称该集合是一个有限集，否则称之为无限集。  
有限集中元素的个数是有限的，无限集中元素的个数是无限的。无论从概念上还是方法看，有限集和无限集的规模度量或计数都有着本质上的区别，我们将在后续相关内容中对此做具体介绍和分析。",有限集和无限集在元素个数和规模度量上有本质区别
有限集合,包含,子集,,"对于有限集合，我们可以构造出相关的子集并对子集进行计数，具体定义如下：  
【定义1.8】设$A$ 是任一有限集合，若$A$ 中含有$n$ 个元素，即有$\left|A\right|{=}n$，则称$A$ 为$n$ 元集合。对于$A$ 的任意一个子集$B$，若$B$ 中含有$m$ 个元素，则称$B$ 为$A$ 的$m$ 元子集。  
也就是说：$n$ 元集合共有$2^{n}$个不同的子集。  
事实上，对于任意一个集合$A$，还可以将其每个子集分别作为一个元素构成一个新的集合，由此得到如下幂集的概念：  
【定义1.9】假设$A$ 任意一个给定的集合，以$A$ 的所有不同子集为元素构成的集合称为$A$ 的幂集，记为$P(A)$或$2^{A}$，即有：  
$$
P(A)=\{B|B\subseteq A\}
$$  
对于以集合作为元素的集合，亦即集合的集合，通常称之为集族。由此可知，幂集其实就是一种特殊的集族。",有限集合包含多个子集，且子集的个数与集合元素数量相关
有限集合,生成,幂集,,"对于有限集合，我们可以构造出相关的子集并对子集进行计数，具体定义如下：  
【定义1.8】设$A$ 是任一有限集合，若$A$ 中含有$n$ 个元素，即有$\left|A\right|{=}n$，则称$A$ 为$n$ 元集合。对于$A$ 的任意一个子集$B$，若$B$ 中含有$m$ 个元素，则称$B$ 为$A$ 的$m$ 元子集。  
也就是说：$n$ 元集合共有$2^{n}$个不同的子集。  
事实上，对于任意一个集合$A$，还可以将其每个子集分别作为一个元素构成一个新的集合，由此得到如下幂集的概念：  
【定义1.9】假设$A$ 任意一个给定的集合，以$A$ 的所有不同子集为元素构成的集合称为$A$ 的幂集，记为$P(A)$或$2^{A}$，即有：  
$$
P(A)=\{B|B\subseteq A\}
$$  
对于以集合作为元素的集合，亦即集合的集合，通常称之为集族。由此可知，幂集其实就是一种特殊的集族。",有限集合的所有子集构成其幂集
幂集,属于,集族,,"对于有限集合，我们可以构造出相关的子集并对子集进行计数，具体定义如下：  
【定义1.8】设$A$ 是任一有限集合，若$A$ 中含有$n$ 个元素，即有$\left|A\right|{=}n$，则称$A$ 为$n$ 元集合。对于$A$ 的任意一个子集$B$，若$B$ 中含有$m$ 个元素，则称$B$ 为$A$ 的$m$ 元子集。  
也就是说：$n$ 元集合共有$2^{n}$个不同的子集。  
事实上，对于任意一个集合$A$，还可以将其每个子集分别作为一个元素构成一个新的集合，由此得到如下幂集的概念：  
【定义1.9】假设$A$ 任意一个给定的集合，以$A$ 的所有不同子集为元素构成的集合称为$A$ 的幂集，记为$P(A)$或$2^{A}$，即有：  
$$
P(A)=\{B|B\subseteq A\}
$$  
对于以集合作为元素的集合，亦即集合的集合，通常称之为集族。由此可知，幂集其实就是一种特殊的集族。",幂集是一种特殊的集族
集合的基本运算,构造,集合,,我们学过实数的加、减、乘、除、乘方、开方等各种运算，通过这些运算可由已有实数生成新的实数。事实上，从数学方法论的角度来看，运算一种非常基本的数学手段。对于任何一个数学概念，在确定其内涵之后，我们总是通过构造概念运算的方式产生新的概念，代数式通过运算可以产生新的代数式、函数通过运算可以产生新的函数、命题通过运算可以产生新的命题、矩阵通过运算可以产生新的矩阵，等等。对集合的学习和探讨也是如此，在掌握集合的基本概念之后，下面进一步学习集合的基本运算及其性质，通过运算机制从已有集合中构造出新的集合，具体包括交运算、并运算、差运算、补运算和对称差运算。,集合的基本运算用于从已有集合中构造出新的集合
集合并运算,定义与区别,集合交运算,,"有时候需要将两个集合的中的元素合并起来构成一个新的集合，由此得到集合并运算的概念；有时需要将两个集合中的共同部分取出来构成一个新的集合，由此得到集合交运算的概念。这两个运算的具体定义如下：  
【定义1.10】对于任意两个集合$A$ 和$B$， $A\cup B=\left\{x\middle|x\in A\right.$或者$\cdot x\in B\}$称为$A$ 和$B$ 并集，亦称$A\cup B$为集合$A$ 和$B$ 的并运算；$A\cap B=\{x|x\in A$并且$x\in B.$}称为$A$ 和$B$ 交集，亦  称$A\cap B$为集合$A$ 和$B$ 的交运算。  
由上述定义可知，对于任意两个集合$A$ 和$B$，两者并运算的结果产生一个新集合，该集合是由$A$ 和$B$ 中元素合并而成，如图$1{\cdot}2(a)$所示；两者交运算结果产生另外一个新集合，该集合由$A$ 和$B$ 的共同部分组成，或者说由同时属于$A$ 和$B$ 的元素组成，如图1-2(b)所示。  
![](images/4fb6199ac21b049856dda6721c89f3d4f0739da1971ad0bbc7426e82d630f6b5.jpg)
图1-2 并、交运算的文氏图  
不难看出，并运算和交运算其实分别就是实数加法和乘法在集合论领域的推广。根据并运算与交运算的定义，不难证明它们满足如下基本运算性质：  
(1) 幂等律：对于任意集合$A$，有：$A\cup A=A$；$A\cap A=A$ (2) 交换律：对于任意两个集合$A$ 和$B$，有：$A\cup B=B\cup A$；$A\cap B=B\cap A$ (3) 结合律：对于任意三个集合$A,\ B$ 和$C$，有：  
$$
(A\cup B)\cup C=A\cup(B\cup C);\;\;(A\cap B)\cap C=A\cap(B\cap C)
$$  
(4) 同一律：对于任意集合$A$，有：$A\cup\varnothing=A$；$A\cap U=A$(5) 零  律：对于任意集合$A$，有：$A\cup U=U$；$A\cap\varnothing=\varnothing$(6) 分配律：对于任意三个集合$A,\ B$ 和$C$，有：  
$$
\begin{array}{r}{A\cap(B\cup C)=(A\cap B)\cup(A\cap C)}\\ {A\cup(B\cap C)=(A\cup B)\cap(A\cup C)}\end{array}
$$  
(7) 吸收律：对于任意两个集合$A$ 和$B$，有：  
$$
A\cup(A\cap B)=A;\,\,\,A\cap(A\cup B)=A
$$  
(8) 对于任意两个集合$A$ 和$B$，有：  
$A\subseteq B$当且仅当$A\cup B=B$ $A\subseteq B$当且仅当$A\cap B=A$  
其中$U$和$\varnothing$分别表示全集和空集。  
上述性质既可根据文氏图简单直观地得到，也可根据集合相等的定义给出数学证明。现仅以分配律为例进行证明，读者可自行给出其余性质的证明。  
上述两个集合的并与交运算可以推广到如下多个集合的情形：  
【定义1.11】对于任意$n$ 个集合$A_{1},A_{2},\ldots,A_{n}$，其交运算和并运算分别为：  
$A_{1}\cap A_{2}\cap,\ldots,\cap A_{n}=\{x|x\in A_{1}$ 或 ${\boldsymbol{x}}\in A_{2}$ 或 …  或 $\textstyle{\boldsymbol{x}}\in A_{n}]$ }   $A_{1}\cup A_{2}\cup,\ldots,\cup A_{n}=\{x|x\in A_{1}$ 且 $x\in A_{2}$ 且 …  且 $x\in A_{n}\}$",集合并运算是指将两个集合中的元素合并成一个新的集合，而集合交运算是指取出两个集合中的共同部分构成一个新的集合。两者分别对应集合论中的并集和交集概念。
集合并运算,运算性质,集合交运算,,"有时候需要将两个集合的中的元素合并起来构成一个新的集合，由此得到集合并运算的概念；有时需要将两个集合中的共同部分取出来构成一个新的集合，由此得到集合交运算的概念。这两个运算的具体定义如下：  
【定义1.10】对于任意两个集合$A$ 和$B$， $A\cup B=\left\{x\middle|x\in A\right.$或者$\cdot x\in B\}$称为$A$ 和$B$ 并集，亦称$A\cup B$为集合$A$ 和$B$ 的并运算；$A\cap B=\{x|x\in A$并且$x\in B.$}称为$A$ 和$B$ 交集，亦  称$A\cap B$为集合$A$ 和$B$ 的交运算。  
由上述定义可知，对于任意两个集合$A$ 和$B$，两者并运算的结果产生一个新集合，该集合是由$A$ 和$B$ 中元素合并而成，如图$1{\cdot}2(a)$所示；两者交运算结果产生另外一个新集合，该集合由$A$ 和$B$ 的共同部分组成，或者说由同时属于$A$ 和$B$ 的元素组成，如图1-2(b)所示。  
![](images/4fb6199ac21b049856dda6721c89f3d4f0739da1971ad0bbc7426e82d630f6b5.jpg)
图1-2 并、交运算的文氏图  
不难看出，并运算和交运算其实分别就是实数加法和乘法在集合论领域的推广。根据并运算与交运算的定义，不难证明它们满足如下基本运算性质：  
(1) 幂等律：对于任意集合$A$，有：$A\cup A=A$；$A\cap A=A$ (2) 交换律：对于任意两个集合$A$ 和$B$，有：$A\cup B=B\cup A$；$A\cap B=B\cap A$ (3) 结合律：对于任意三个集合$A,\ B$ 和$C$，有：  
$$
(A\cup B)\cup C=A\cup(B\cup C);\;\;(A\cap B)\cap C=A\cap(B\cap C)
$$  
(4) 同一律：对于任意集合$A$，有：$A\cup\varnothing=A$；$A\cap U=A$(5) 零  律：对于任意集合$A$，有：$A\cup U=U$；$A\cap\varnothing=\varnothing$(6) 分配律：对于任意三个集合$A,\ B$ 和$C$，有：  
$$
\begin{array}{r}{A\cap(B\cup C)=(A\cap B)\cup(A\cap C)}\\ {A\cup(B\cap C)=(A\cup B)\cap(A\cup C)}\end{array}
$$  
(7) 吸收律：对于任意两个集合$A$ 和$B$，有：  
$$
A\cup(A\cap B)=A;\,\,\,A\cap(A\cup B)=A
$$  
(8) 对于任意两个集合$A$ 和$B$，有：  
$A\subseteq B$当且仅当$A\cup B=B$ $A\subseteq B$当且仅当$A\cap B=A$  
其中$U$和$\varnothing$分别表示全集和空集。  
上述性质既可根据文氏图简单直观地得到，也可根据集合相等的定义给出数学证明。现仅以分配律为例进行证明，读者可自行给出其余性质的证明。  
上述两个集合的并与交运算可以推广到如下多个集合的情形：  
【定义1.11】对于任意$n$ 个集合$A_{1},A_{2},\ldots,A_{n}$，其交运算和并运算分别为：  
$A_{1}\cap A_{2}\cap,\ldots,\cap A_{n}=\{x|x\in A_{1}$ 或 ${\boldsymbol{x}}\in A_{2}$ 或 …  或 $\textstyle{\boldsymbol{x}}\in A_{n}]$ }   $A_{1}\cup A_{2}\cup,\ldots,\cup A_{n}=\{x|x\in A_{1}$ 且 $x\in A_{2}$ 且 …  且 $x\in A_{n}\}$",集合并运算和集合交运算满足幂等律、交换律、结合律、同一律、零律、分配律和吸收律等基本运算性质。
集合并运算,推广,集合交运算,,"有时候需要将两个集合的中的元素合并起来构成一个新的集合，由此得到集合并运算的概念；有时需要将两个集合中的共同部分取出来构成一个新的集合，由此得到集合交运算的概念。这两个运算的具体定义如下：  
【定义1.10】对于任意两个集合$A$ 和$B$， $A\cup B=\left\{x\middle|x\in A\right.$或者$\cdot x\in B\}$称为$A$ 和$B$ 并集，亦称$A\cup B$为集合$A$ 和$B$ 的并运算；$A\cap B=\{x|x\in A$并且$x\in B.$}称为$A$ 和$B$ 交集，亦  称$A\cap B$为集合$A$ 和$B$ 的交运算。  
由上述定义可知，对于任意两个集合$A$ 和$B$，两者并运算的结果产生一个新集合，该集合是由$A$ 和$B$ 中元素合并而成，如图$1{\cdot}2(a)$所示；两者交运算结果产生另外一个新集合，该集合由$A$ 和$B$ 的共同部分组成，或者说由同时属于$A$ 和$B$ 的元素组成，如图1-2(b)所示。  
![](images/4fb6199ac21b049856dda6721c89f3d4f0739da1971ad0bbc7426e82d630f6b5.jpg)
图1-2 并、交运算的文氏图  
不难看出，并运算和交运算其实分别就是实数加法和乘法在集合论领域的推广。根据并运算与交运算的定义，不难证明它们满足如下基本运算性质：  
(1) 幂等律：对于任意集合$A$，有：$A\cup A=A$；$A\cap A=A$ (2) 交换律：对于任意两个集合$A$ 和$B$，有：$A\cup B=B\cup A$；$A\cap B=B\cap A$ (3) 结合律：对于任意三个集合$A,\ B$ 和$C$，有：  
$$
(A\cup B)\cup C=A\cup(B\cup C);\;\;(A\cap B)\cap C=A\cap(B\cap C)
$$  
(4) 同一律：对于任意集合$A$，有：$A\cup\varnothing=A$；$A\cap U=A$(5) 零  律：对于任意集合$A$，有：$A\cup U=U$；$A\cap\varnothing=\varnothing$(6) 分配律：对于任意三个集合$A,\ B$ 和$C$，有：  
$$
\begin{array}{r}{A\cap(B\cup C)=(A\cap B)\cup(A\cap C)}\\ {A\cup(B\cap C)=(A\cup B)\cap(A\cup C)}\end{array}
$$  
(7) 吸收律：对于任意两个集合$A$ 和$B$，有：  
$$
A\cup(A\cap B)=A;\,\,\,A\cap(A\cup B)=A
$$  
(8) 对于任意两个集合$A$ 和$B$，有：  
$A\subseteq B$当且仅当$A\cup B=B$ $A\subseteq B$当且仅当$A\cap B=A$  
其中$U$和$\varnothing$分别表示全集和空集。  
上述性质既可根据文氏图简单直观地得到，也可根据集合相等的定义给出数学证明。现仅以分配律为例进行证明，读者可自行给出其余性质的证明。  
上述两个集合的并与交运算可以推广到如下多个集合的情形：  
【定义1.11】对于任意$n$ 个集合$A_{1},A_{2},\ldots,A_{n}$，其交运算和并运算分别为：  
$A_{1}\cap A_{2}\cap,\ldots,\cap A_{n}=\{x|x\in A_{1}$ 或 ${\boldsymbol{x}}\in A_{2}$ 或 …  或 $\textstyle{\boldsymbol{x}}\in A_{n}]$ }   $A_{1}\cup A_{2}\cup,\ldots,\cup A_{n}=\{x|x\in A_{1}$ 且 $x\in A_{2}$ 且 …  且 $x\in A_{n}\}$",集合并运算和集合交运算可以推广到多个集合的情况，定义了多个集合的并运算和交运算。
差运算,互补,补运算,,"对于任意给定的两个集合$A$ 和$B$，有时需要将属于$A$ 但不属于$B$ 的所有元素取出来构成一个新的集合，由此得到如下集合差运算的概念：  
【定义1.12】对于任意给定的两个集合$A$ 和$B$，集合$\cdot A-B=\{x|x\in A$并且$x\notin B\}$称为$A$ 与$B$ 的差集，$A-B$亦称为集合𝐴与$B$的差运算；令$U$表示全集，则${\bar{A}}=U-A=\{x|x\in$$U$且$x\notin A\}$称为$A$ 的补集，亦称$\bar{A}$为对集合$A$ 的补运算。  
一般来说，所谓两个对象互补，是指这两个对象之间无共同部分并且若将两者合并则构成一个完整的整体。如果将全集𝑈看成是一个完整的整体，那么任何一个集合与它的补集显然构成一种互补关系。图1-3 为集合差运算和补运算的文氏图。  
![](images/3dd3ff26327d44646f11d3b3940708dbd5563cf42578e139e0a56534e35c5eff.jpg)
图1-3 差、补运算的文氏图  
不难看出，集合的差运算和补运算其实就是实数减法运算在集合论中的推广。根据集合差运算与补运算的定义，不难证明它们满足如下基本运算性质：  
(1) 矛盾律：对于任意给定的集合$A$，有：$A\cap{\bar{A}}=\emptyset$；(2) 排中律：对于任意给定的集合$A$，有：$A\cup\bar{A}=U$  
(3) 双重否定律：对于任意给定的集合$A$，有：$\bar{\bar{A}}=A$  
(4) 德摩根律：对于任意给定的两个集合$A$ 和$B$，有： $\overline{{A\cup B}}=\bar{A}\cap\bar{B},\,\,\,\overline{{A\cap B}}=\bar{A}\cup\bar{B}$  
(5) 对于任意给定的三个集合$A$、$B$ 和$C$，有：  
$A\cup(B\cup C)=(A\cup B)\cup C;\;A\cap(B\cap C)=(A\cap B)\cap C\circ$ $A\cap(B\cup C)=(A\cap B)\cup(A\cap C);\;A\cup(B\cap C)=(A\cup B)\cap(A\cup C)\,.$ $A\cap(A\cup B)=A;\,\,\,A\cup(A\cap B)=A\,.$  
现仅以德摩根律为例给出上述运算性质的证明，读者可自行给出其余证明。【例题1.22】对于任意给定的两个集合$A$ 和$B$，证明如下德摩根律：  
$$
{\overline{{A\cup B}}}={\bar{A}}\cap{\overline{{B}}}\,;\;{\overline{{A\cap B}}}={\bar{A}}\cup{\bar{B}}
$$",差运算和补运算在集合论中构成互补关系，差运算表示集合A中不属于B的元素，补运算表示全集U中不属于A的元素。
差运算,满足,矛盾律,,"对于任意给定的两个集合$A$ 和$B$，有时需要将属于$A$ 但不属于$B$ 的所有元素取出来构成一个新的集合，由此得到如下集合差运算的概念：  
【定义1.12】对于任意给定的两个集合$A$ 和$B$，集合$\cdot A-B=\{x|x\in A$并且$x\notin B\}$称为$A$ 与$B$ 的差集，$A-B$亦称为集合𝐴与$B$的差运算；令$U$表示全集，则${\bar{A}}=U-A=\{x|x\in$$U$且$x\notin A\}$称为$A$ 的补集，亦称$\bar{A}$为对集合$A$ 的补运算。  
一般来说，所谓两个对象互补，是指这两个对象之间无共同部分并且若将两者合并则构成一个完整的整体。如果将全集𝑈看成是一个完整的整体，那么任何一个集合与它的补集显然构成一种互补关系。图1-3 为集合差运算和补运算的文氏图。  
![](images/3dd3ff26327d44646f11d3b3940708dbd5563cf42578e139e0a56534e35c5eff.jpg)
图1-3 差、补运算的文氏图  
不难看出，集合的差运算和补运算其实就是实数减法运算在集合论中的推广。根据集合差运算与补运算的定义，不难证明它们满足如下基本运算性质：  
(1) 矛盾律：对于任意给定的集合$A$，有：$A\cap{\bar{A}}=\emptyset$；(2) 排中律：对于任意给定的集合$A$，有：$A\cup\bar{A}=U$  
(3) 双重否定律：对于任意给定的集合$A$，有：$\bar{\bar{A}}=A$  
(4) 德摩根律：对于任意给定的两个集合$A$ 和$B$，有： $\overline{{A\cup B}}=\bar{A}\cap\bar{B},\,\,\,\overline{{A\cap B}}=\bar{A}\cup\bar{B}$  
(5) 对于任意给定的三个集合$A$、$B$ 和$C$，有：  
$A\cup(B\cup C)=(A\cup B)\cup C;\;A\cap(B\cap C)=(A\cap B)\cap C\circ$ $A\cap(B\cup C)=(A\cap B)\cup(A\cap C);\;A\cup(B\cap C)=(A\cup B)\cap(A\cup C)\,.$ $A\cap(A\cup B)=A;\,\,\,A\cup(A\cap B)=A\,.$  
现仅以德摩根律为例给出上述运算性质的证明，读者可自行给出其余证明。【例题1.22】对于任意给定的两个集合$A$ 和$B$，证明如下德摩根律：  
$$
{\overline{{A\cup B}}}={\bar{A}}\cap{\overline{{B}}}\,;\;{\overline{{A\cap B}}}={\bar{A}}\cup{\bar{B}}
$$",差运算满足矛盾律，即集合A与其补集的交集为空集。
差运算,满足,排中律,,"对于任意给定的两个集合$A$ 和$B$，有时需要将属于$A$ 但不属于$B$ 的所有元素取出来构成一个新的集合，由此得到如下集合差运算的概念：  
【定义1.12】对于任意给定的两个集合$A$ 和$B$，集合$\cdot A-B=\{x|x\in A$并且$x\notin B\}$称为$A$ 与$B$ 的差集，$A-B$亦称为集合𝐴与$B$的差运算；令$U$表示全集，则${\bar{A}}=U-A=\{x|x\in$$U$且$x\notin A\}$称为$A$ 的补集，亦称$\bar{A}$为对集合$A$ 的补运算。  
一般来说，所谓两个对象互补，是指这两个对象之间无共同部分并且若将两者合并则构成一个完整的整体。如果将全集𝑈看成是一个完整的整体，那么任何一个集合与它的补集显然构成一种互补关系。图1-3 为集合差运算和补运算的文氏图。  
![](images/3dd3ff26327d44646f11d3b3940708dbd5563cf42578e139e0a56534e35c5eff.jpg)
图1-3 差、补运算的文氏图  
不难看出，集合的差运算和补运算其实就是实数减法运算在集合论中的推广。根据集合差运算与补运算的定义，不难证明它们满足如下基本运算性质：  
(1) 矛盾律：对于任意给定的集合$A$，有：$A\cap{\bar{A}}=\emptyset$；(2) 排中律：对于任意给定的集合$A$，有：$A\cup\bar{A}=U$  
(3) 双重否定律：对于任意给定的集合$A$，有：$\bar{\bar{A}}=A$  
(4) 德摩根律：对于任意给定的两个集合$A$ 和$B$，有： $\overline{{A\cup B}}=\bar{A}\cap\bar{B},\,\,\,\overline{{A\cap B}}=\bar{A}\cup\bar{B}$  
(5) 对于任意给定的三个集合$A$、$B$ 和$C$，有：  
$A\cup(B\cup C)=(A\cup B)\cup C;\;A\cap(B\cap C)=(A\cap B)\cap C\circ$ $A\cap(B\cup C)=(A\cap B)\cup(A\cap C);\;A\cup(B\cap C)=(A\cup B)\cap(A\cup C)\,.$ $A\cap(A\cup B)=A;\,\,\,A\cup(A\cap B)=A\,.$  
现仅以德摩根律为例给出上述运算性质的证明，读者可自行给出其余证明。【例题1.22】对于任意给定的两个集合$A$ 和$B$，证明如下德摩根律：  
$$
{\overline{{A\cup B}}}={\bar{A}}\cap{\overline{{B}}}\,;\;{\overline{{A\cap B}}}={\bar{A}}\cup{\bar{B}}
$$",差运算满足排中律，即集合A与其补集的并集为全集U。
差运算,满足,双重否定律,,"对于任意给定的两个集合$A$ 和$B$，有时需要将属于$A$ 但不属于$B$ 的所有元素取出来构成一个新的集合，由此得到如下集合差运算的概念：  
【定义1.12】对于任意给定的两个集合$A$ 和$B$，集合$\cdot A-B=\{x|x\in A$并且$x\notin B\}$称为$A$ 与$B$ 的差集，$A-B$亦称为集合𝐴与$B$的差运算；令$U$表示全集，则${\bar{A}}=U-A=\{x|x\in$$U$且$x\notin A\}$称为$A$ 的补集，亦称$\bar{A}$为对集合$A$ 的补运算。  
一般来说，所谓两个对象互补，是指这两个对象之间无共同部分并且若将两者合并则构成一个完整的整体。如果将全集𝑈看成是一个完整的整体，那么任何一个集合与它的补集显然构成一种互补关系。图1-3 为集合差运算和补运算的文氏图。  
![](images/3dd3ff26327d44646f11d3b3940708dbd5563cf42578e139e0a56534e35c5eff.jpg)
图1-3 差、补运算的文氏图  
不难看出，集合的差运算和补运算其实就是实数减法运算在集合论中的推广。根据集合差运算与补运算的定义，不难证明它们满足如下基本运算性质：  
(1) 矛盾律：对于任意给定的集合$A$，有：$A\cap{\bar{A}}=\emptyset$；(2) 排中律：对于任意给定的集合$A$，有：$A\cup\bar{A}=U$  
(3) 双重否定律：对于任意给定的集合$A$，有：$\bar{\bar{A}}=A$  
(4) 德摩根律：对于任意给定的两个集合$A$ 和$B$，有： $\overline{{A\cup B}}=\bar{A}\cap\bar{B},\,\,\,\overline{{A\cap B}}=\bar{A}\cup\bar{B}$  
(5) 对于任意给定的三个集合$A$、$B$ 和$C$，有：  
$A\cup(B\cup C)=(A\cup B)\cup C;\;A\cap(B\cap C)=(A\cap B)\cap C\circ$ $A\cap(B\cup C)=(A\cap B)\cup(A\cap C);\;A\cup(B\cap C)=(A\cup B)\cap(A\cup C)\,.$ $A\cap(A\cup B)=A;\,\,\,A\cup(A\cap B)=A\,.$  
现仅以德摩根律为例给出上述运算性质的证明，读者可自行给出其余证明。【例题1.22】对于任意给定的两个集合$A$ 和$B$，证明如下德摩根律：  
$$
{\overline{{A\cup B}}}={\bar{A}}\cap{\overline{{B}}}\,;\;{\overline{{A\cap B}}}={\bar{A}}\cup{\bar{B}}
$$",差运算满足双重否定律，即集合A的双重补集等于A本身。
差运算,满足,德摩根律,,"对于任意给定的两个集合$A$ 和$B$，有时需要将属于$A$ 但不属于$B$ 的所有元素取出来构成一个新的集合，由此得到如下集合差运算的概念：  
【定义1.12】对于任意给定的两个集合$A$ 和$B$，集合$\cdot A-B=\{x|x\in A$并且$x\notin B\}$称为$A$ 与$B$ 的差集，$A-B$亦称为集合𝐴与$B$的差运算；令$U$表示全集，则${\bar{A}}=U-A=\{x|x\in$$U$且$x\notin A\}$称为$A$ 的补集，亦称$\bar{A}$为对集合$A$ 的补运算。  
一般来说，所谓两个对象互补，是指这两个对象之间无共同部分并且若将两者合并则构成一个完整的整体。如果将全集𝑈看成是一个完整的整体，那么任何一个集合与它的补集显然构成一种互补关系。图1-3 为集合差运算和补运算的文氏图。  
![](images/3dd3ff26327d44646f11d3b3940708dbd5563cf42578e139e0a56534e35c5eff.jpg)
图1-3 差、补运算的文氏图  
不难看出，集合的差运算和补运算其实就是实数减法运算在集合论中的推广。根据集合差运算与补运算的定义，不难证明它们满足如下基本运算性质：  
(1) 矛盾律：对于任意给定的集合$A$，有：$A\cap{\bar{A}}=\emptyset$；(2) 排中律：对于任意给定的集合$A$，有：$A\cup\bar{A}=U$  
(3) 双重否定律：对于任意给定的集合$A$，有：$\bar{\bar{A}}=A$  
(4) 德摩根律：对于任意给定的两个集合$A$ 和$B$，有： $\overline{{A\cup B}}=\bar{A}\cap\bar{B},\,\,\,\overline{{A\cap B}}=\bar{A}\cup\bar{B}$  
(5) 对于任意给定的三个集合$A$、$B$ 和$C$，有：  
$A\cup(B\cup C)=(A\cup B)\cup C;\;A\cap(B\cap C)=(A\cap B)\cap C\circ$ $A\cap(B\cup C)=(A\cap B)\cup(A\cap C);\;A\cup(B\cap C)=(A\cup B)\cap(A\cup C)\,.$ $A\cap(A\cup B)=A;\,\,\,A\cup(A\cap B)=A\,.$  
现仅以德摩根律为例给出上述运算性质的证明，读者可自行给出其余证明。【例题1.22】对于任意给定的两个集合$A$ 和$B$，证明如下德摩根律：  
$$
{\overline{{A\cup B}}}={\bar{A}}\cap{\overline{{B}}}\,;\;{\overline{{A\cap B}}}={\bar{A}}\cup{\bar{B}}
$$",差运算满足德摩根律，即集合A和B的并集的补集等于A和B补集的交集，交集的补集等于补集的并集。
补运算,满足,矛盾律,,"对于任意给定的两个集合$A$ 和$B$，有时需要将属于$A$ 但不属于$B$ 的所有元素取出来构成一个新的集合，由此得到如下集合差运算的概念：  
【定义1.12】对于任意给定的两个集合$A$ 和$B$，集合$\cdot A-B=\{x|x\in A$并且$x\notin B\}$称为$A$ 与$B$ 的差集，$A-B$亦称为集合𝐴与$B$的差运算；令$U$表示全集，则${\bar{A}}=U-A=\{x|x\in$$U$且$x\notin A\}$称为$A$ 的补集，亦称$\bar{A}$为对集合$A$ 的补运算。  
一般来说，所谓两个对象互补，是指这两个对象之间无共同部分并且若将两者合并则构成一个完整的整体。如果将全集𝑈看成是一个完整的整体，那么任何一个集合与它的补集显然构成一种互补关系。图1-3 为集合差运算和补运算的文氏图。  
![](images/3dd3ff26327d44646f11d3b3940708dbd5563cf42578e139e0a56534e35c5eff.jpg)
图1-3 差、补运算的文氏图  
不难看出，集合的差运算和补运算其实就是实数减法运算在集合论中的推广。根据集合差运算与补运算的定义，不难证明它们满足如下基本运算性质：  
(1) 矛盾律：对于任意给定的集合$A$，有：$A\cap{\bar{A}}=\emptyset$；(2) 排中律：对于任意给定的集合$A$，有：$A\cup\bar{A}=U$  
(3) 双重否定律：对于任意给定的集合$A$，有：$\bar{\bar{A}}=A$  
(4) 德摩根律：对于任意给定的两个集合$A$ 和$B$，有： $\overline{{A\cup B}}=\bar{A}\cap\bar{B},\,\,\,\overline{{A\cap B}}=\bar{A}\cup\bar{B}$  
(5) 对于任意给定的三个集合$A$、$B$ 和$C$，有：  
$A\cup(B\cup C)=(A\cup B)\cup C;\;A\cap(B\cap C)=(A\cap B)\cap C\circ$ $A\cap(B\cup C)=(A\cap B)\cup(A\cap C);\;A\cup(B\cap C)=(A\cup B)\cap(A\cup C)\,.$ $A\cap(A\cup B)=A;\,\,\,A\cup(A\cap B)=A\,.$  
现仅以德摩根律为例给出上述运算性质的证明，读者可自行给出其余证明。【例题1.22】对于任意给定的两个集合$A$ 和$B$，证明如下德摩根律：  
$$
{\overline{{A\cup B}}}={\bar{A}}\cap{\overline{{B}}}\,;\;{\overline{{A\cap B}}}={\bar{A}}\cup{\bar{B}}
$$",补运算满足矛盾律，即集合A与其补集的交集为空集。
补运算,满足,排中律,,"对于任意给定的两个集合$A$ 和$B$，有时需要将属于$A$ 但不属于$B$ 的所有元素取出来构成一个新的集合，由此得到如下集合差运算的概念：  
【定义1.12】对于任意给定的两个集合$A$ 和$B$，集合$\cdot A-B=\{x|x\in A$并且$x\notin B\}$称为$A$ 与$B$ 的差集，$A-B$亦称为集合𝐴与$B$的差运算；令$U$表示全集，则${\bar{A}}=U-A=\{x|x\in$$U$且$x\notin A\}$称为$A$ 的补集，亦称$\bar{A}$为对集合$A$ 的补运算。  
一般来说，所谓两个对象互补，是指这两个对象之间无共同部分并且若将两者合并则构成一个完整的整体。如果将全集𝑈看成是一个完整的整体，那么任何一个集合与它的补集显然构成一种互补关系。图1-3 为集合差运算和补运算的文氏图。  
![](images/3dd3ff26327d44646f11d3b3940708dbd5563cf42578e139e0a56534e35c5eff.jpg)
图1-3 差、补运算的文氏图  
不难看出，集合的差运算和补运算其实就是实数减法运算在集合论中的推广。根据集合差运算与补运算的定义，不难证明它们满足如下基本运算性质：  
(1) 矛盾律：对于任意给定的集合$A$，有：$A\cap{\bar{A}}=\emptyset$；(2) 排中律：对于任意给定的集合$A$，有：$A\cup\bar{A}=U$  
(3) 双重否定律：对于任意给定的集合$A$，有：$\bar{\bar{A}}=A$  
(4) 德摩根律：对于任意给定的两个集合$A$ 和$B$，有： $\overline{{A\cup B}}=\bar{A}\cap\bar{B},\,\,\,\overline{{A\cap B}}=\bar{A}\cup\bar{B}$  
(5) 对于任意给定的三个集合$A$、$B$ 和$C$，有：  
$A\cup(B\cup C)=(A\cup B)\cup C;\;A\cap(B\cap C)=(A\cap B)\cap C\circ$ $A\cap(B\cup C)=(A\cap B)\cup(A\cap C);\;A\cup(B\cap C)=(A\cup B)\cap(A\cup C)\,.$ $A\cap(A\cup B)=A;\,\,\,A\cup(A\cap B)=A\,.$  
现仅以德摩根律为例给出上述运算性质的证明，读者可自行给出其余证明。【例题1.22】对于任意给定的两个集合$A$ 和$B$，证明如下德摩根律：  
$$
{\overline{{A\cup B}}}={\bar{A}}\cap{\overline{{B}}}\,;\;{\overline{{A\cap B}}}={\bar{A}}\cup{\bar{B}}
$$",补运算满足排中律，即集合A与其补集的并集为全集U。
补运算,满足,双重否定律,,"对于任意给定的两个集合$A$ 和$B$，有时需要将属于$A$ 但不属于$B$ 的所有元素取出来构成一个新的集合，由此得到如下集合差运算的概念：  
【定义1.12】对于任意给定的两个集合$A$ 和$B$，集合$\cdot A-B=\{x|x\in A$并且$x\notin B\}$称为$A$ 与$B$ 的差集，$A-B$亦称为集合𝐴与$B$的差运算；令$U$表示全集，则${\bar{A}}=U-A=\{x|x\in$$U$且$x\notin A\}$称为$A$ 的补集，亦称$\bar{A}$为对集合$A$ 的补运算。  
一般来说，所谓两个对象互补，是指这两个对象之间无共同部分并且若将两者合并则构成一个完整的整体。如果将全集𝑈看成是一个完整的整体，那么任何一个集合与它的补集显然构成一种互补关系。图1-3 为集合差运算和补运算的文氏图。  
![](images/3dd3ff26327d44646f11d3b3940708dbd5563cf42578e139e0a56534e35c5eff.jpg)
图1-3 差、补运算的文氏图  
不难看出，集合的差运算和补运算其实就是实数减法运算在集合论中的推广。根据集合差运算与补运算的定义，不难证明它们满足如下基本运算性质：  
(1) 矛盾律：对于任意给定的集合$A$，有：$A\cap{\bar{A}}=\emptyset$；(2) 排中律：对于任意给定的集合$A$，有：$A\cup\bar{A}=U$  
(3) 双重否定律：对于任意给定的集合$A$，有：$\bar{\bar{A}}=A$  
(4) 德摩根律：对于任意给定的两个集合$A$ 和$B$，有： $\overline{{A\cup B}}=\bar{A}\cap\bar{B},\,\,\,\overline{{A\cap B}}=\bar{A}\cup\bar{B}$  
(5) 对于任意给定的三个集合$A$、$B$ 和$C$，有：  
$A\cup(B\cup C)=(A\cup B)\cup C;\;A\cap(B\cap C)=(A\cap B)\cap C\circ$ $A\cap(B\cup C)=(A\cap B)\cup(A\cap C);\;A\cup(B\cap C)=(A\cup B)\cap(A\cup C)\,.$ $A\cap(A\cup B)=A;\,\,\,A\cup(A\cap B)=A\,.$  
现仅以德摩根律为例给出上述运算性质的证明，读者可自行给出其余证明。【例题1.22】对于任意给定的两个集合$A$ 和$B$，证明如下德摩根律：  
$$
{\overline{{A\cup B}}}={\bar{A}}\cap{\overline{{B}}}\,;\;{\overline{{A\cap B}}}={\bar{A}}\cup{\bar{B}}
$$",补运算满足双重否定律，即集合A的双重补集等于A本身。
补运算,满足,德摩根律,,"对于任意给定的两个集合$A$ 和$B$，有时需要将属于$A$ 但不属于$B$ 的所有元素取出来构成一个新的集合，由此得到如下集合差运算的概念：  
【定义1.12】对于任意给定的两个集合$A$ 和$B$，集合$\cdot A-B=\{x|x\in A$并且$x\notin B\}$称为$A$ 与$B$ 的差集，$A-B$亦称为集合𝐴与$B$的差运算；令$U$表示全集，则${\bar{A}}=U-A=\{x|x\in$$U$且$x\notin A\}$称为$A$ 的补集，亦称$\bar{A}$为对集合$A$ 的补运算。  
一般来说，所谓两个对象互补，是指这两个对象之间无共同部分并且若将两者合并则构成一个完整的整体。如果将全集𝑈看成是一个完整的整体，那么任何一个集合与它的补集显然构成一种互补关系。图1-3 为集合差运算和补运算的文氏图。  
![](images/3dd3ff26327d44646f11d3b3940708dbd5563cf42578e139e0a56534e35c5eff.jpg)
图1-3 差、补运算的文氏图  
不难看出，集合的差运算和补运算其实就是实数减法运算在集合论中的推广。根据集合差运算与补运算的定义，不难证明它们满足如下基本运算性质：  
(1) 矛盾律：对于任意给定的集合$A$，有：$A\cap{\bar{A}}=\emptyset$；(2) 排中律：对于任意给定的集合$A$，有：$A\cup\bar{A}=U$  
(3) 双重否定律：对于任意给定的集合$A$，有：$\bar{\bar{A}}=A$  
(4) 德摩根律：对于任意给定的两个集合$A$ 和$B$，有： $\overline{{A\cup B}}=\bar{A}\cap\bar{B},\,\,\,\overline{{A\cap B}}=\bar{A}\cup\bar{B}$  
(5) 对于任意给定的三个集合$A$、$B$ 和$C$，有：  
$A\cup(B\cup C)=(A\cup B)\cup C;\;A\cap(B\cap C)=(A\cap B)\cap C\circ$ $A\cap(B\cup C)=(A\cap B)\cup(A\cap C);\;A\cup(B\cap C)=(A\cup B)\cap(A\cup C)\,.$ $A\cap(A\cup B)=A;\,\,\,A\cup(A\cap B)=A\,.$  
现仅以德摩根律为例给出上述运算性质的证明，读者可自行给出其余证明。【例题1.22】对于任意给定的两个集合$A$ 和$B$，证明如下德摩根律：  
$$
{\overline{{A\cup B}}}={\bar{A}}\cap{\overline{{B}}}\,;\;{\overline{{A\cap B}}}={\bar{A}}\cup{\bar{B}}
$$",补运算满足德摩根律，即集合A和B的并集的补集等于A和B补集的交集，交集的补集等于补集的并集。
集合的二进制表示,优化,集合的交、并、差运算,,"集合在计算机中有着广泛的应用，一般都是将集合中的元素顺序的存放在计算机中，但这种存储方式会使得在计算集合的交、并、差等运算时需要对元素进行搜索，随之而来的是不必要的时间开销。为了避免这个问题，现在介绍一种比较有效的存储方法。  
假设全集$U$是有限集合，$A{=}\{a_{1},a_{2},{\ldots},a_{n}\}$是$U$的一个子集且对应一个长度为$n$的比特串$B{=}b_{1}b_{2}{...}b_{n}$。串$B$ 的每一位数字按如下方式取值：如果$a_{i}{\in}A$，则$b_{i}{=}1$，否则$b_{i}{=}0$。此时对于全集$U$ 的任意两个子集合，它们之间的交、并运算就可以按二进制数的布尔乘、布尔加运算进行，即：两个子集交的编码是两个子集编码对应位置的布尔乘；两个子集并的编码是两个子集编码对应位置的布尔加。布尔乘、布尔加的具体运算规则如下：  
$\begin{array}{r l r}{0+0=0}&{{}}&{0+1=1+0=1+1=1}\end{array}$ $\begin{array}{r l r}{1\times1=1}&{{}}&{0\times1=1\times0=0\times0=0}\end{array}$  
下面进一步考察集合补运算的二进制编码表示.假设集合$A{=}\{a_{1},\,a_{2},\,...,a_{n}\}$对应长度为$n$的比特串为$B{=}b_{1}b_{2}{\ldots}.b_{n}$，则集合$A$ 的补集的二进制编码只需要简单地把$B{=}b_{1}b_{2}{\ldots}b_{n}$ 中每个1换成0，每个0 换成1 即可。  
集合在数据库中具有着广泛应用，基于二进制编码的集合运算可以大大提高记录增、删、改的计算效率。数据库中数据在计算机系统中一般以二维表形式存在，可将其中每一列分别看作是一个集合，列标题就是该集合的名称，每一行是一个数据序列，称为记录。又可将整个二维表看成是记录的集合。下面考察一个具体例子：  
表1-1 二维表
![](images/ed20520091902c2b692c4144896337caee56d7b09ec379326531846771b24a4c.jpg)",集合的二进制表示通过布尔乘和布尔加运算优化了集合的交、并运算
集合的二进制表示,实现,集合补运算,,"集合在计算机中有着广泛的应用，一般都是将集合中的元素顺序的存放在计算机中，但这种存储方式会使得在计算集合的交、并、差等运算时需要对元素进行搜索，随之而来的是不必要的时间开销。为了避免这个问题，现在介绍一种比较有效的存储方法。  
假设全集$U$是有限集合，$A{=}\{a_{1},a_{2},{\ldots},a_{n}\}$是$U$的一个子集且对应一个长度为$n$的比特串$B{=}b_{1}b_{2}{...}b_{n}$。串$B$ 的每一位数字按如下方式取值：如果$a_{i}{\in}A$，则$b_{i}{=}1$，否则$b_{i}{=}0$。此时对于全集$U$ 的任意两个子集合，它们之间的交、并运算就可以按二进制数的布尔乘、布尔加运算进行，即：两个子集交的编码是两个子集编码对应位置的布尔乘；两个子集并的编码是两个子集编码对应位置的布尔加。布尔乘、布尔加的具体运算规则如下：  
$\begin{array}{r l r}{0+0=0}&{{}}&{0+1=1+0=1+1=1}\end{array}$ $\begin{array}{r l r}{1\times1=1}&{{}}&{0\times1=1\times0=0\times0=0}\end{array}$  
下面进一步考察集合补运算的二进制编码表示.假设集合$A{=}\{a_{1},\,a_{2},\,...,a_{n}\}$对应长度为$n$的比特串为$B{=}b_{1}b_{2}{\ldots}.b_{n}$，则集合$A$ 的补集的二进制编码只需要简单地把$B{=}b_{1}b_{2}{\ldots}b_{n}$ 中每个1换成0，每个0 换成1 即可。  
集合在数据库中具有着广泛应用，基于二进制编码的集合运算可以大大提高记录增、删、改的计算效率。数据库中数据在计算机系统中一般以二维表形式存在，可将其中每一列分别看作是一个集合，列标题就是该集合的名称，每一行是一个数据序列，称为记录。又可将整个二维表看成是记录的集合。下面考察一个具体例子：  
表1-1 二维表
![](images/ed20520091902c2b692c4144896337caee56d7b09ec379326531846771b24a4c.jpg)",集合的二进制表示通过翻转比特串实现集合的补运算
集合的二进制表示,提高效率,数据库记录操作,,"集合在计算机中有着广泛的应用，一般都是将集合中的元素顺序的存放在计算机中，但这种存储方式会使得在计算集合的交、并、差等运算时需要对元素进行搜索，随之而来的是不必要的时间开销。为了避免这个问题，现在介绍一种比较有效的存储方法。  
假设全集$U$是有限集合，$A{=}\{a_{1},a_{2},{\ldots},a_{n}\}$是$U$的一个子集且对应一个长度为$n$的比特串$B{=}b_{1}b_{2}{...}b_{n}$。串$B$ 的每一位数字按如下方式取值：如果$a_{i}{\in}A$，则$b_{i}{=}1$，否则$b_{i}{=}0$。此时对于全集$U$ 的任意两个子集合，它们之间的交、并运算就可以按二进制数的布尔乘、布尔加运算进行，即：两个子集交的编码是两个子集编码对应位置的布尔乘；两个子集并的编码是两个子集编码对应位置的布尔加。布尔乘、布尔加的具体运算规则如下：  
$\begin{array}{r l r}{0+0=0}&{{}}&{0+1=1+0=1+1=1}\end{array}$ $\begin{array}{r l r}{1\times1=1}&{{}}&{0\times1=1\times0=0\times0=0}\end{array}$  
下面进一步考察集合补运算的二进制编码表示.假设集合$A{=}\{a_{1},\,a_{2},\,...,a_{n}\}$对应长度为$n$的比特串为$B{=}b_{1}b_{2}{\ldots}.b_{n}$，则集合$A$ 的补集的二进制编码只需要简单地把$B{=}b_{1}b_{2}{\ldots}b_{n}$ 中每个1换成0，每个0 换成1 即可。  
集合在数据库中具有着广泛应用，基于二进制编码的集合运算可以大大提高记录增、删、改的计算效率。数据库中数据在计算机系统中一般以二维表形式存在，可将其中每一列分别看作是一个集合，列标题就是该集合的名称，每一行是一个数据序列，称为记录。又可将整个二维表看成是记录的集合。下面考察一个具体例子：  
表1-1 二维表
![](images/ed20520091902c2b692c4144896337caee56d7b09ec379326531846771b24a4c.jpg)",基于二进制编码的集合运算可以提高数据库记录增、删、改的计算效率
基数,度量,无限集,,我们知道，基数是度量集合规模大小的指标，当集合基数为有限数时，该集合为有限集，其基数就是集合中元素的个数。当集合基数为无穷大时，该集合为无限集。对于无限集，如何使用基数度量其大小规模？例如，对于自然数集与有理数集，如何比较这两个无限集的基数，对于有理数集和无理数集，又如何比较两者的基数，等等。无穷大到底有多大？是否可以对无穷大的规模进行差异性分析，将其划分为不同层次或等级？本节将通过探讨与此相关的概念和问题，使得读者能够对无限集有着比较清晰的认识和本质性把握。,基数用于度量无限集的大小规模
自然数集,比较,有理数集,,我们知道，基数是度量集合规模大小的指标，当集合基数为有限数时，该集合为有限集，其基数就是集合中元素的个数。当集合基数为无穷大时，该集合为无限集。对于无限集，如何使用基数度量其大小规模？例如，对于自然数集与有理数集，如何比较这两个无限集的基数，对于有理数集和无理数集，又如何比较两者的基数，等等。无穷大到底有多大？是否可以对无穷大的规模进行差异性分析，将其划分为不同层次或等级？本节将通过探讨与此相关的概念和问题，使得读者能够对无限集有着比较清晰的认识和本质性把握。,通过基数比较自然数集与有理数集的大小
有理数集,比较,无理数集,,我们知道，基数是度量集合规模大小的指标，当集合基数为有限数时，该集合为有限集，其基数就是集合中元素的个数。当集合基数为无穷大时，该集合为无限集。对于无限集，如何使用基数度量其大小规模？例如，对于自然数集与有理数集，如何比较这两个无限集的基数，对于有理数集和无理数集，又如何比较两者的基数，等等。无穷大到底有多大？是否可以对无穷大的规模进行差异性分析，将其划分为不同层次或等级？本节将通过探讨与此相关的概念和问题，使得读者能够对无限集有着比较清晰的认识和本质性把握。,通过基数比较有理数集与无理数集的大小
可数集与不可数集,度量基础,集合等势,,"现考察集合规模的度量问题。直观上看，集合中元素数目越多集合的规模就越大。关键是如何界定集合中元素数目的多少？对于有限集，这个不成问题，可通过对集合中元素进行计数的方法解决。然而，对于无限集来说，问题就没这么简单了。例如对于下列问题：  
正整数集合$\{1,2,3,\ \cdots\ \}$和正整数平方集合$\{1^{2},2^{2},3^{2},\ \cdots\ \}$，哪个集合的元素更多？  
显然，正整数平方集合是正整数集合的一个真子集，因此正整数集合似乎应该更大一些。但这两个集合元素之间又显然存在一一对应关系。从传统有限集合计数的观点看，两者的数目又必定是相等的。这似乎存在一种矛盾。事实上，早在1638 年，意大利物理学家伽利略也发现了类似于这样的问题，但是他无法解决并感到困惑，便提出了所谓的伽利略悖论。  
其实，无限集所具有的无限延展特性使其与有限集合有着本质性差异，对有限集合进行精确计数的方式不再适用于对无限集合的度量。因此，必须采用同时适合有限集与无限集的新方法来实现对集合规模的度量。由此得到如下关于集合等势的概念：  
【定义1.15】设$A$ 和$B$ 是任意两个集合，如果$A$ 和$B$ 之间存在一一对应的关系：  
$$
\psi{\colon}A\to B
$$  
则称$\pmb{A}$ 与$\pmb{B}$ 等势，记为：$A^{\circ}B$  
显然，若 $\scriptstyle A=B$ ，则 $A^{\scriptscriptstyle\frown}B$ ，反之不然。  
【定理1.5】集合的等势满足如下三条基本性质：（1）自反性：对于任意集合$A$，有$A{\sim}A$；（2）对称性：对于任意两个集合$A$ 和$B$，如果$A{\sim}B$，则有$B{\sim}A$（3）传递性：对于任意三个集合$A$、$B$ 和$C$，如果$A{\sim}B$ 且$B{\sim}C$，则有$A{\sim}C$  
上述等势概念表达的仅仅是集合在数量规模上次序比较关系，要真正实现对无限集规模的度量，还需确定一个基本的规模度量单位作为度量标准或基准。显然，任何无限集都可生成一个子集与自然数集等势，因此可将自然数集合作为无限集规模度量的一种基准。下面着重介绍自然数的基本概念与性质。",集合等势是用于度量可数集与不可数集规模的基础概念
集合等势,具备,集合等势的基本性质,,"现考察集合规模的度量问题。直观上看，集合中元素数目越多集合的规模就越大。关键是如何界定集合中元素数目的多少？对于有限集，这个不成问题，可通过对集合中元素进行计数的方法解决。然而，对于无限集来说，问题就没这么简单了。例如对于下列问题：  
正整数集合$\{1,2,3,\ \cdots\ \}$和正整数平方集合$\{1^{2},2^{2},3^{2},\ \cdots\ \}$，哪个集合的元素更多？  
显然，正整数平方集合是正整数集合的一个真子集，因此正整数集合似乎应该更大一些。但这两个集合元素之间又显然存在一一对应关系。从传统有限集合计数的观点看，两者的数目又必定是相等的。这似乎存在一种矛盾。事实上，早在1638 年，意大利物理学家伽利略也发现了类似于这样的问题，但是他无法解决并感到困惑，便提出了所谓的伽利略悖论。  
其实，无限集所具有的无限延展特性使其与有限集合有着本质性差异，对有限集合进行精确计数的方式不再适用于对无限集合的度量。因此，必须采用同时适合有限集与无限集的新方法来实现对集合规模的度量。由此得到如下关于集合等势的概念：  
【定义1.15】设$A$ 和$B$ 是任意两个集合，如果$A$ 和$B$ 之间存在一一对应的关系：  
$$
\psi{\colon}A\to B
$$  
则称$\pmb{A}$ 与$\pmb{B}$ 等势，记为：$A^{\circ}B$  
显然，若 $\scriptstyle A=B$ ，则 $A^{\scriptscriptstyle\frown}B$ ，反之不然。  
【定理1.5】集合的等势满足如下三条基本性质：（1）自反性：对于任意集合$A$，有$A{\sim}A$；（2）对称性：对于任意两个集合$A$ 和$B$，如果$A{\sim}B$，则有$B{\sim}A$（3）传递性：对于任意三个集合$A$、$B$ 和$C$，如果$A{\sim}B$ 且$B{\sim}C$，则有$A{\sim}C$  
上述等势概念表达的仅仅是集合在数量规模上次序比较关系，要真正实现对无限集规模的度量，还需确定一个基本的规模度量单位作为度量标准或基准。显然，任何无限集都可生成一个子集与自然数集等势，因此可将自然数集合作为无限集规模度量的一种基准。下面着重介绍自然数的基本概念与性质。",集合等势具备自反性、对称性和传递性三条基本性质
自然数集合,基准,集合等势,,"现考察集合规模的度量问题。直观上看，集合中元素数目越多集合的规模就越大。关键是如何界定集合中元素数目的多少？对于有限集，这个不成问题，可通过对集合中元素进行计数的方法解决。然而，对于无限集来说，问题就没这么简单了。例如对于下列问题：  
正整数集合$\{1,2,3,\ \cdots\ \}$和正整数平方集合$\{1^{2},2^{2},3^{2},\ \cdots\ \}$，哪个集合的元素更多？  
显然，正整数平方集合是正整数集合的一个真子集，因此正整数集合似乎应该更大一些。但这两个集合元素之间又显然存在一一对应关系。从传统有限集合计数的观点看，两者的数目又必定是相等的。这似乎存在一种矛盾。事实上，早在1638 年，意大利物理学家伽利略也发现了类似于这样的问题，但是他无法解决并感到困惑，便提出了所谓的伽利略悖论。  
其实，无限集所具有的无限延展特性使其与有限集合有着本质性差异，对有限集合进行精确计数的方式不再适用于对无限集合的度量。因此，必须采用同时适合有限集与无限集的新方法来实现对集合规模的度量。由此得到如下关于集合等势的概念：  
【定义1.15】设$A$ 和$B$ 是任意两个集合，如果$A$ 和$B$ 之间存在一一对应的关系：  
$$
\psi{\colon}A\to B
$$  
则称$\pmb{A}$ 与$\pmb{B}$ 等势，记为：$A^{\circ}B$  
显然，若 $\scriptstyle A=B$ ，则 $A^{\scriptscriptstyle\frown}B$ ，反之不然。  
【定理1.5】集合的等势满足如下三条基本性质：（1）自反性：对于任意集合$A$，有$A{\sim}A$；（2）对称性：对于任意两个集合$A$ 和$B$，如果$A{\sim}B$，则有$B{\sim}A$（3）传递性：对于任意三个集合$A$、$B$ 和$C$，如果$A{\sim}B$ 且$B{\sim}C$，则有$A{\sim}C$  
上述等势概念表达的仅仅是集合在数量规模上次序比较关系，要真正实现对无限集规模的度量，还需确定一个基本的规模度量单位作为度量标准或基准。显然，任何无限集都可生成一个子集与自然数集等势，因此可将自然数集合作为无限集规模度量的一种基准。下面着重介绍自然数的基本概念与性质。",自然数集合作为无限集规模度量的基准，与任何无限集的子集等势
自然数的集合定义,基于,皮亚诺公理,,"我们知道，自然数是对有限集合中所含元素个数进行度量和比较的一种工具。如果将所含元素个数彼此相等的有限集合抽象成一个抽象集合，或者说从所含元素个数彼此相等的有限集合中选出一个集合作为代表构成抽象集合，那么所有这些抽象集合就可以按其规模的大小排成一个有序序列。因此，从本质上说自然数就是表示这些抽象集合及其有序序列的一种数学符号。例如，可以将自然数3 定义为能够表示所有3 元集合的一种抽象集合、将自然数5 定义为能够表示所有5 元集合的一种抽象集合，等等。自然数的上述本质特征并不难以理解，问题是如何找到一种恰当的方法来定义这种抽象集合。  
1891 年，著名数学家皮亚诺以0 和后继数这两个不定义概念外加5 条公理表述了自然数的上述本质特征，创立了如下关于自然数的皮亚诺公理系统，为自然数的抽象集合定义及相关的算术运算系统构造提供了一个标准.皮亚诺5 公理的具体内容如下：  
公理1：至少存在一个体是自然数，它被记为0； 公理2：如果$n$ 是自然数，那么$n$ 必定含有一个直接后继，记为$|n^{+}$  
公理3：0 不是任何自然数的直接后继； 公理4：如果自然数$m,n$ 的直接后继$m^{+}$, $n^{+}$相同，那么$m{=}n$  
公理5：不满足上述条件的个体均非自然数。  
可以证明，自然数的所有运算性质都可从上述5 条公理出发推演获得。根据上述5 条公理，可以构建一套比较完备的自然数算术运算系统。定义自然数其实就是要找出一系列具体个体，让它们满足这5 条公理，其中关键要点就是要给出0 和后继数的具体定义。",自然数的集合定义是基于皮亚诺公理系统来构建的，皮亚诺公理为自然数的抽象集合定义及相关的算术运算系统提供了标准。
可数集与不可数集,相关,自然数的集合定义,,"我们知道，自然数是对有限集合中所含元素个数进行度量和比较的一种工具。如果将所含元素个数彼此相等的有限集合抽象成一个抽象集合，或者说从所含元素个数彼此相等的有限集合中选出一个集合作为代表构成抽象集合，那么所有这些抽象集合就可以按其规模的大小排成一个有序序列。因此，从本质上说自然数就是表示这些抽象集合及其有序序列的一种数学符号。例如，可以将自然数3 定义为能够表示所有3 元集合的一种抽象集合、将自然数5 定义为能够表示所有5 元集合的一种抽象集合，等等。自然数的上述本质特征并不难以理解，问题是如何找到一种恰当的方法来定义这种抽象集合。  
1891 年，著名数学家皮亚诺以0 和后继数这两个不定义概念外加5 条公理表述了自然数的上述本质特征，创立了如下关于自然数的皮亚诺公理系统，为自然数的抽象集合定义及相关的算术运算系统构造提供了一个标准.皮亚诺5 公理的具体内容如下：  
公理1：至少存在一个体是自然数，它被记为0； 公理2：如果$n$ 是自然数，那么$n$ 必定含有一个直接后继，记为$|n^{+}$  
公理3：0 不是任何自然数的直接后继； 公理4：如果自然数$m,n$ 的直接后继$m^{+}$, $n^{+}$相同，那么$m{=}n$  
公理5：不满足上述条件的个体均非自然数。  
可以证明，自然数的所有运算性质都可从上述5 条公理出发推演获得。根据上述5 条公理，可以构建一套比较完备的自然数算术运算系统。定义自然数其实就是要找出一系列具体个体，让它们满足这5 条公理，其中关键要点就是要给出0 和后继数的具体定义。",自然数的集合定义涉及到有限集合的元素个数度量，这与可数集与不可数集的概念相关，因为自然数用于表示有限集合的规模。
自然数的集合定义,满足,皮亚诺公理,,"1923 年，著名数学家冯·诺依曼用集合给定义了0 和后继数的概念，并由此通过归纳的方式实现自然数和自然数集合的完美定义。  
【定义1.16】对于任意一个给定的集合$A$，称集合$\cdot A^{+}=A\cup\{A\}$为$A$ 的直接后继。  
【定义1.17】对于任意给定的集合$N$，若它满足如下两个条件，则称其为自然数集合：  
（1）基础条款：空集属于集合$N$，即有$\emptyset\in N$，并将$\emptyset$定义为自然数0； （2）归纳条款：对于任意一个集合$A$，若有$A\in N$，则必有$A^{+}=A\cup\{A\}\in N.$  
上述自然数集合的归纳定义是一种构造性定义方法，通过基础条款和归纳条款构造出自然数集的全部元素 . 基础条款决定了自然数集合为非空集合并确定了集合的初始元素，即自 然数0；归纳条款则以初始元素为出发点通过构造后继元素的方式不断产生新的元素。  
具体地说，按以上定义，自然数集合由如下形式的元素构成：  
$$
\emptyset,\ \{\emptyset\},\ \{\emptyset,\ \{\emptyset\}\},\ \{\emptyset,\ \{\emptyset\},\ \{\emptyset,\ \{\emptyset\}\},\ \{\emptyset,\ \{\emptyset\},\ \{\emptyset,\ \{\emptyset\}\}\}\},\ \cdots
$$  
根据等势的定义，$\{\emptyset\}$与所有含有1 个元素的集合等势，可以看成是这些集合的代表，令其为自然数1；同理有：$\{\varnothing,\;\;\{\varnothing\}\}$与所有含有2 个元素的集合等势，可以看成是这些集合的代表，令其为自然数2；$\{\varnothing,\;\;\{\varnothing\}$，$\{\varnothing,\;\;\{\varnothing\}\}$与所有含有3 个元素的集合等势，可以看成是这些集合的代表，令其为自然数3；$\{\emptyset,\ \{\emptyset\},\ \{\emptyset,\ \{\emptyset\}\}\}$与所有含有4 个元素的集合等势，可以看成是这些集合的代表，令其为自然数4；如此下去，便可得到所有自然数：0, 1, 2, 3, 4，…，并显然成立如下递推关系：  
$$
0\!\!=\!\!\emptyset;\;\;1\!\!=\!\!\{0\};\;\;2\!\!=\!\!\{0\,,\;\;1\};\;\;3\!\!=\!\!\{0\,,\;\;1\,,\;\;2\};\;\;4\!\!=\!\!\{0\,,\;\;1\,,\;\;2\,,\;\,3\};\;\;\cdots
$$  
一般地，有：  
$$
n=\{0\,,\ 1\,,\ 2\,,\ \dots\ \,,\ n-1\}
$$  
下述定理表明上述自然数定义满足皮亚诺公理系统的要求：【定理1.6】自然数的集合定义满足皮亚诺提出的5 条公理。  
有了自然数，便可以定义自然数集合上的各种运算、函数和特殊自然数，这里就不再一一赘述，下面仅给出自然数子集上最大数和最小数的相关定义：  
【定义1.18】如果对$x$ 作不少于一次的后继运算后得到$y$，那么称$x<y$。如果$x$在自然数子集$K$ 中，$K$ 中没有其它数小于$x$，那么称$x$ 是子集$K$ 中的最小数，如果$x$ 在自然数子集$K$ 中，$x$ 不小于$K$中其它数，那么称$x$ 是子集$K$ 中的最大数。  
根据上述定义，在由单个自然数$a$ 组成自然数子集$\{a\}$中，$a$ 既是最小数也是最大数。下面定理给出了自然数子集中最小值和最大值的存在性：  
【定理1.7】自然数集合具有如下三个基本性质：  
（1）0 是自然数集合的最小数。  
（2）自然数集合的所有非空子集具有最小数（最小数原理），从而正整数集合的所有非空子集均有最小数。  
（3）自然数集合的所有非空有限子集均有最大数，从而正整数集合的所有非空有限子集均有最大数。",自然数的集合定义满足皮亚诺公理系统的要求
自然数子集的最大数和最小数,包含,自然数集合的基本性质,,"1923 年，著名数学家冯·诺依曼用集合给定义了0 和后继数的概念，并由此通过归纳的方式实现自然数和自然数集合的完美定义。  
【定义1.16】对于任意一个给定的集合$A$，称集合$\cdot A^{+}=A\cup\{A\}$为$A$ 的直接后继。  
【定义1.17】对于任意给定的集合$N$，若它满足如下两个条件，则称其为自然数集合：  
（1）基础条款：空集属于集合$N$，即有$\emptyset\in N$，并将$\emptyset$定义为自然数0； （2）归纳条款：对于任意一个集合$A$，若有$A\in N$，则必有$A^{+}=A\cup\{A\}\in N.$  
上述自然数集合的归纳定义是一种构造性定义方法，通过基础条款和归纳条款构造出自然数集的全部元素 . 基础条款决定了自然数集合为非空集合并确定了集合的初始元素，即自 然数0；归纳条款则以初始元素为出发点通过构造后继元素的方式不断产生新的元素。  
具体地说，按以上定义，自然数集合由如下形式的元素构成：  
$$
\emptyset,\ \{\emptyset\},\ \{\emptyset,\ \{\emptyset\}\},\ \{\emptyset,\ \{\emptyset\},\ \{\emptyset,\ \{\emptyset\}\},\ \{\emptyset,\ \{\emptyset\},\ \{\emptyset,\ \{\emptyset\}\}\}\},\ \cdots
$$  
根据等势的定义，$\{\emptyset\}$与所有含有1 个元素的集合等势，可以看成是这些集合的代表，令其为自然数1；同理有：$\{\varnothing,\;\;\{\varnothing\}\}$与所有含有2 个元素的集合等势，可以看成是这些集合的代表，令其为自然数2；$\{\varnothing,\;\;\{\varnothing\}$，$\{\varnothing,\;\;\{\varnothing\}\}$与所有含有3 个元素的集合等势，可以看成是这些集合的代表，令其为自然数3；$\{\emptyset,\ \{\emptyset\},\ \{\emptyset,\ \{\emptyset\}\}\}$与所有含有4 个元素的集合等势，可以看成是这些集合的代表，令其为自然数4；如此下去，便可得到所有自然数：0, 1, 2, 3, 4，…，并显然成立如下递推关系：  
$$
0\!\!=\!\!\emptyset;\;\;1\!\!=\!\!\{0\};\;\;2\!\!=\!\!\{0\,,\;\;1\};\;\;3\!\!=\!\!\{0\,,\;\;1\,,\;\;2\};\;\;4\!\!=\!\!\{0\,,\;\;1\,,\;\;2\,,\;\,3\};\;\;\cdots
$$  
一般地，有：  
$$
n=\{0\,,\ 1\,,\ 2\,,\ \dots\ \,,\ n-1\}
$$  
下述定理表明上述自然数定义满足皮亚诺公理系统的要求：【定理1.6】自然数的集合定义满足皮亚诺提出的5 条公理。  
有了自然数，便可以定义自然数集合上的各种运算、函数和特殊自然数，这里就不再一一赘述，下面仅给出自然数子集上最大数和最小数的相关定义：  
【定义1.18】如果对$x$ 作不少于一次的后继运算后得到$y$，那么称$x<y$。如果$x$在自然数子集$K$ 中，$K$ 中没有其它数小于$x$，那么称$x$ 是子集$K$ 中的最小数，如果$x$ 在自然数子集$K$ 中，$x$ 不小于$K$中其它数，那么称$x$ 是子集$K$ 中的最大数。  
根据上述定义，在由单个自然数$a$ 组成自然数子集$\{a\}$中，$a$ 既是最小数也是最大数。下面定理给出了自然数子集中最小值和最大值的存在性：  
【定理1.7】自然数集合具有如下三个基本性质：  
（1）0 是自然数集合的最小数。  
（2）自然数集合的所有非空子集具有最小数（最小数原理），从而正整数集合的所有非空子集均有最小数。  
（3）自然数集合的所有非空有限子集均有最大数，从而正整数集合的所有非空有限子集均有最大数。",自然数集合的基本性质包括自然数子集的最大数和最小数的定义和存在性
自然数的集合定义,基础,自然数集合的基本性质,,"1923 年，著名数学家冯·诺依曼用集合给定义了0 和后继数的概念，并由此通过归纳的方式实现自然数和自然数集合的完美定义。  
【定义1.16】对于任意一个给定的集合$A$，称集合$\cdot A^{+}=A\cup\{A\}$为$A$ 的直接后继。  
【定义1.17】对于任意给定的集合$N$，若它满足如下两个条件，则称其为自然数集合：  
（1）基础条款：空集属于集合$N$，即有$\emptyset\in N$，并将$\emptyset$定义为自然数0； （2）归纳条款：对于任意一个集合$A$，若有$A\in N$，则必有$A^{+}=A\cup\{A\}\in N.$  
上述自然数集合的归纳定义是一种构造性定义方法，通过基础条款和归纳条款构造出自然数集的全部元素 . 基础条款决定了自然数集合为非空集合并确定了集合的初始元素，即自 然数0；归纳条款则以初始元素为出发点通过构造后继元素的方式不断产生新的元素。  
具体地说，按以上定义，自然数集合由如下形式的元素构成：  
$$
\emptyset,\ \{\emptyset\},\ \{\emptyset,\ \{\emptyset\}\},\ \{\emptyset,\ \{\emptyset\},\ \{\emptyset,\ \{\emptyset\}\},\ \{\emptyset,\ \{\emptyset\},\ \{\emptyset,\ \{\emptyset\}\}\}\},\ \cdots
$$  
根据等势的定义，$\{\emptyset\}$与所有含有1 个元素的集合等势，可以看成是这些集合的代表，令其为自然数1；同理有：$\{\varnothing,\;\;\{\varnothing\}\}$与所有含有2 个元素的集合等势，可以看成是这些集合的代表，令其为自然数2；$\{\varnothing,\;\;\{\varnothing\}$，$\{\varnothing,\;\;\{\varnothing\}\}$与所有含有3 个元素的集合等势，可以看成是这些集合的代表，令其为自然数3；$\{\emptyset,\ \{\emptyset\},\ \{\emptyset,\ \{\emptyset\}\}\}$与所有含有4 个元素的集合等势，可以看成是这些集合的代表，令其为自然数4；如此下去，便可得到所有自然数：0, 1, 2, 3, 4，…，并显然成立如下递推关系：  
$$
0\!\!=\!\!\emptyset;\;\;1\!\!=\!\!\{0\};\;\;2\!\!=\!\!\{0\,,\;\;1\};\;\;3\!\!=\!\!\{0\,,\;\;1\,,\;\;2\};\;\;4\!\!=\!\!\{0\,,\;\;1\,,\;\;2\,,\;\,3\};\;\;\cdots
$$  
一般地，有：  
$$
n=\{0\,,\ 1\,,\ 2\,,\ \dots\ \,,\ n-1\}
$$  
下述定理表明上述自然数定义满足皮亚诺公理系统的要求：【定理1.6】自然数的集合定义满足皮亚诺提出的5 条公理。  
有了自然数，便可以定义自然数集合上的各种运算、函数和特殊自然数，这里就不再一一赘述，下面仅给出自然数子集上最大数和最小数的相关定义：  
【定义1.18】如果对$x$ 作不少于一次的后继运算后得到$y$，那么称$x<y$。如果$x$在自然数子集$K$ 中，$K$ 中没有其它数小于$x$，那么称$x$ 是子集$K$ 中的最小数，如果$x$ 在自然数子集$K$ 中，$x$ 不小于$K$中其它数，那么称$x$ 是子集$K$ 中的最大数。  
根据上述定义，在由单个自然数$a$ 组成自然数子集$\{a\}$中，$a$ 既是最小数也是最大数。下面定理给出了自然数子集中最小值和最大值的存在性：  
【定理1.7】自然数集合具有如下三个基本性质：  
（1）0 是自然数集合的最小数。  
（2）自然数集合的所有非空子集具有最小数（最小数原理），从而正整数集合的所有非空子集均有最小数。  
（3）自然数集合的所有非空有限子集均有最大数，从而正整数集合的所有非空有限子集均有最大数。",自然数的集合定义是自然数集合基本性质的基础
自然数的集合定义,提供,自然数的归纳证明,,"使用归纳法不仅可以实现对自然数集合的一种构造性定义，而且还提供了关于自然数命题的一种有效证明方法，即自然数的归纳证明法。这种证明法两种具体形式，分别基于数学归纳法第一原理和数学归纳法第二原理。  
【数学归纳法第一原理】假设$P(n)$是一个关于自然数$n$ 的命题，若有：  
（1）基础步骤：$P(0)$为真；  
（2）归纳步骤：对于任意正整数$k$，如果$P(k)$为真，则$P(k{+}1)$为真。则$P(n)$对一切自然数$n$ 均为真。  
【证明】假设已经对$P(n)$完成了基础步骤和归纳步骤的证明，但是存在某个自然数$m_{0}$使得 $P(m_{0})$为假。令集合$S$ 为所有使得$P(n)$为假的自然数组成的集合，即：  
$S=\{m|m为自然数且P(m)为假\} $  
由于$\cdot m_{0}\in S$，故𝑆为非空集合，根据定理1.7 中的最小数原理知，$S$中必然存在最小的自然数$s$。由于$P(0)$为真，故$s\neq0$。因此，$s-1$为自然数且不在集合𝑆中，即$P(s-1)$为真。根据归纳假设有$P(s)$为真，这与$s\in S$矛盾！故$P(n)$对一切自然数$n$ 均为真。□  
使用数学归纳法第一原理完成证明的关键在于：首先需要假定对任意一个正整数$k$，$P(\mathrm{k})$为真，然后在此假定下证明$P(k{+}1)$必为真。如果用数学归纳法完成了上述原理中的两  
个步骤，那么就证明了对所有自然数而言$P(n)$为真。  
【数学归纳法第二原理】假设$P(n)$是一个关于自然数$n$ 的命题，若有：  
1）基础步骤：$P(1)$为真；  
（ 2 ）归纳步骤：对于任意正整数 $k$ ，若 $P(1),P(2),\dots,P(k)$ 均为真，则 $P(k{+}1)$ 为真。 则$P(n)$对一切自然数$n$ 均为真。",自然数的集合定义通过归纳法提供了一种自然数命题的有效证明方法，即自然数的归纳证明法
自然数的归纳证明,基于,数学归纳法第一原理,,"使用归纳法不仅可以实现对自然数集合的一种构造性定义，而且还提供了关于自然数命题的一种有效证明方法，即自然数的归纳证明法。这种证明法两种具体形式，分别基于数学归纳法第一原理和数学归纳法第二原理。  
【数学归纳法第一原理】假设$P(n)$是一个关于自然数$n$ 的命题，若有：  
（1）基础步骤：$P(0)$为真；  
（2）归纳步骤：对于任意正整数$k$，如果$P(k)$为真，则$P(k{+}1)$为真。则$P(n)$对一切自然数$n$ 均为真。  
【证明】假设已经对$P(n)$完成了基础步骤和归纳步骤的证明，但是存在某个自然数$m_{0}$使得 $P(m_{0})$为假。令集合$S$ 为所有使得$P(n)$为假的自然数组成的集合，即：  
$S=\{m|m为自然数且P(m)为假\} $  
由于$\cdot m_{0}\in S$，故𝑆为非空集合，根据定理1.7 中的最小数原理知，$S$中必然存在最小的自然数$s$。由于$P(0)$为真，故$s\neq0$。因此，$s-1$为自然数且不在集合𝑆中，即$P(s-1)$为真。根据归纳假设有$P(s)$为真，这与$s\in S$矛盾！故$P(n)$对一切自然数$n$ 均为真。□  
使用数学归纳法第一原理完成证明的关键在于：首先需要假定对任意一个正整数$k$，$P(\mathrm{k})$为真，然后在此假定下证明$P(k{+}1)$必为真。如果用数学归纳法完成了上述原理中的两  
个步骤，那么就证明了对所有自然数而言$P(n)$为真。  
【数学归纳法第二原理】假设$P(n)$是一个关于自然数$n$ 的命题，若有：  
1）基础步骤：$P(1)$为真；  
（ 2 ）归纳步骤：对于任意正整数 $k$ ，若 $P(1),P(2),\dots,P(k)$ 均为真，则 $P(k{+}1)$ 为真。 则$P(n)$对一切自然数$n$ 均为真。",自然数的归纳证明法的一种具体形式基于数学归纳法第一原理
自然数的归纳证明,基于,数学归纳法第二原理,,"使用归纳法不仅可以实现对自然数集合的一种构造性定义，而且还提供了关于自然数命题的一种有效证明方法，即自然数的归纳证明法。这种证明法两种具体形式，分别基于数学归纳法第一原理和数学归纳法第二原理。  
【数学归纳法第一原理】假设$P(n)$是一个关于自然数$n$ 的命题，若有：  
（1）基础步骤：$P(0)$为真；  
（2）归纳步骤：对于任意正整数$k$，如果$P(k)$为真，则$P(k{+}1)$为真。则$P(n)$对一切自然数$n$ 均为真。  
【证明】假设已经对$P(n)$完成了基础步骤和归纳步骤的证明，但是存在某个自然数$m_{0}$使得 $P(m_{0})$为假。令集合$S$ 为所有使得$P(n)$为假的自然数组成的集合，即：  
$S=\{m|m为自然数且P(m)为假\} $  
由于$\cdot m_{0}\in S$，故𝑆为非空集合，根据定理1.7 中的最小数原理知，$S$中必然存在最小的自然数$s$。由于$P(0)$为真，故$s\neq0$。因此，$s-1$为自然数且不在集合𝑆中，即$P(s-1)$为真。根据归纳假设有$P(s)$为真，这与$s\in S$矛盾！故$P(n)$对一切自然数$n$ 均为真。□  
使用数学归纳法第一原理完成证明的关键在于：首先需要假定对任意一个正整数$k$，$P(\mathrm{k})$为真，然后在此假定下证明$P(k{+}1)$必为真。如果用数学归纳法完成了上述原理中的两  
个步骤，那么就证明了对所有自然数而言$P(n)$为真。  
【数学归纳法第二原理】假设$P(n)$是一个关于自然数$n$ 的命题，若有：  
1）基础步骤：$P(1)$为真；  
（ 2 ）归纳步骤：对于任意正整数 $k$ ，若 $P(1),P(2),\dots,P(k)$ 均为真，则 $P(k{+}1)$ 为真。 则$P(n)$对一切自然数$n$ 均为真。",自然数的归纳证明法的另一种具体形式基于数学归纳法第二原理
可数集合,等势,自然数集,,"从前面的讨论不难看出，对于任意一个给定的自然数$n$，该自然数其实就是对所有含有$n$ 个元素集合的一种抽象。例如，自然数3 就是对所有含有3 个元素集合的抽象，或者说自然数3 就是将所有含有3 个元素的集合房子一起组成集族。因此，自然数可以根据集合中所含元素个数为标准对所有有限集进行分类，从而实现对有限集基数的度量和比较。  
对无限集基数的度量和比较则没有这么简单。如前所述，任意一个无限集合，都可以找到它的一个子集与自然数集等势。因此，自然数集应当是规模最小的一种无限集合，可用自然数集作为无限集基数的最小度量单位或者度量基准。据此得到如下定义：  
【定义1.19】凡是与自然数集$N$ 等势的集合都称为可数集合，该类集合的基数记为$\aleph_{0}$，读作阿列夫零。  
根据上述例题，可以得到关于有限集合和可数集合的如下基本性质：  
（1）两个有限集合等势，当且仅当它们具有相同的元素个数；（2）有限集合不可能与其任何真子集合等势； （3）可数集合可以与其可数的真子集等势。  
由此可知，元素个数不相等的无限集之间仍有可能存在等势关系。因此，无限集合的基数已经不能通过集合中元素的个数来度量，或者说不能用一个自然数来度量，而是需要以自然数集或其它无限集合的基数为标准进行度量。  
现在考察这样的一个问题，除了可数集合之外，还有没有其它的无限集合？或者说，是否每一个无限集合都能够与自然数集合建立一一对应的关系？事实上并非如此，例如开区间(0, 1)就不能与自然数建立等势关系，所有与开区间(0, 1)等势的集合构成了另外一类不同规模的集合，称之为不可数集合。其具体定义如下：  
【定义1.20】开区间(0, 1)称为不可数集合，其基数记为ℵ，读作阿列夫；凡是与开区间(0, 1)等势的集合都称为不可数集合。  
因此，不可数集合是比可数集合规模更大的一种无限集合类型。当然，还可以考虑不可数集合的幂集、不可数集合幂集的幂集等等，由此可以构造出很多种不同基数的无限集合。关于这些无限集合基数及其性质的讨论已经超出了离散数学的范畴，有兴趣的读者可以参阅实变函数理论中与连续统相关的内容。",凡是与自然数集等势的集合都称为可数集合
不可数集合,等势,"开区间(0, 1)",,"从前面的讨论不难看出，对于任意一个给定的自然数$n$，该自然数其实就是对所有含有$n$ 个元素集合的一种抽象。例如，自然数3 就是对所有含有3 个元素集合的抽象，或者说自然数3 就是将所有含有3 个元素的集合房子一起组成集族。因此，自然数可以根据集合中所含元素个数为标准对所有有限集进行分类，从而实现对有限集基数的度量和比较。  
对无限集基数的度量和比较则没有这么简单。如前所述，任意一个无限集合，都可以找到它的一个子集与自然数集等势。因此，自然数集应当是规模最小的一种无限集合，可用自然数集作为无限集基数的最小度量单位或者度量基准。据此得到如下定义：  
【定义1.19】凡是与自然数集$N$ 等势的集合都称为可数集合，该类集合的基数记为$\aleph_{0}$，读作阿列夫零。  
根据上述例题，可以得到关于有限集合和可数集合的如下基本性质：  
（1）两个有限集合等势，当且仅当它们具有相同的元素个数；（2）有限集合不可能与其任何真子集合等势； （3）可数集合可以与其可数的真子集等势。  
由此可知，元素个数不相等的无限集之间仍有可能存在等势关系。因此，无限集合的基数已经不能通过集合中元素的个数来度量，或者说不能用一个自然数来度量，而是需要以自然数集或其它无限集合的基数为标准进行度量。  
现在考察这样的一个问题，除了可数集合之外，还有没有其它的无限集合？或者说，是否每一个无限集合都能够与自然数集合建立一一对应的关系？事实上并非如此，例如开区间(0, 1)就不能与自然数建立等势关系，所有与开区间(0, 1)等势的集合构成了另外一类不同规模的集合，称之为不可数集合。其具体定义如下：  
【定义1.20】开区间(0, 1)称为不可数集合，其基数记为ℵ，读作阿列夫；凡是与开区间(0, 1)等势的集合都称为不可数集合。  
因此，不可数集合是比可数集合规模更大的一种无限集合类型。当然，还可以考虑不可数集合的幂集、不可数集合幂集的幂集等等，由此可以构造出很多种不同基数的无限集合。关于这些无限集合基数及其性质的讨论已经超出了离散数学的范畴，有兴趣的读者可以参阅实变函数理论中与连续统相关的内容。","凡是与开区间(0, 1)等势的集合都称为不可数集合"
可数集合,规模比较,不可数集合,,"从前面的讨论不难看出，对于任意一个给定的自然数$n$，该自然数其实就是对所有含有$n$ 个元素集合的一种抽象。例如，自然数3 就是对所有含有3 个元素集合的抽象，或者说自然数3 就是将所有含有3 个元素的集合房子一起组成集族。因此，自然数可以根据集合中所含元素个数为标准对所有有限集进行分类，从而实现对有限集基数的度量和比较。  
对无限集基数的度量和比较则没有这么简单。如前所述，任意一个无限集合，都可以找到它的一个子集与自然数集等势。因此，自然数集应当是规模最小的一种无限集合，可用自然数集作为无限集基数的最小度量单位或者度量基准。据此得到如下定义：  
【定义1.19】凡是与自然数集$N$ 等势的集合都称为可数集合，该类集合的基数记为$\aleph_{0}$，读作阿列夫零。  
根据上述例题，可以得到关于有限集合和可数集合的如下基本性质：  
（1）两个有限集合等势，当且仅当它们具有相同的元素个数；（2）有限集合不可能与其任何真子集合等势； （3）可数集合可以与其可数的真子集等势。  
由此可知，元素个数不相等的无限集之间仍有可能存在等势关系。因此，无限集合的基数已经不能通过集合中元素的个数来度量，或者说不能用一个自然数来度量，而是需要以自然数集或其它无限集合的基数为标准进行度量。  
现在考察这样的一个问题，除了可数集合之外，还有没有其它的无限集合？或者说，是否每一个无限集合都能够与自然数集合建立一一对应的关系？事实上并非如此，例如开区间(0, 1)就不能与自然数建立等势关系，所有与开区间(0, 1)等势的集合构成了另外一类不同规模的集合，称之为不可数集合。其具体定义如下：  
【定义1.20】开区间(0, 1)称为不可数集合，其基数记为ℵ，读作阿列夫；凡是与开区间(0, 1)等势的集合都称为不可数集合。  
因此，不可数集合是比可数集合规模更大的一种无限集合类型。当然，还可以考虑不可数集合的幂集、不可数集合幂集的幂集等等，由此可以构造出很多种不同基数的无限集合。关于这些无限集合基数及其性质的讨论已经超出了离散数学的范畴，有兴趣的读者可以参阅实变函数理论中与连续统相关的内容。",不可数集合是比可数集合规模更大的一种无限集合类型
无限集的基数比较,度量基准,可数集合,,"从前面的讨论不难看出，对于任意一个给定的自然数$n$，该自然数其实就是对所有含有$n$ 个元素集合的一种抽象。例如，自然数3 就是对所有含有3 个元素集合的抽象，或者说自然数3 就是将所有含有3 个元素的集合房子一起组成集族。因此，自然数可以根据集合中所含元素个数为标准对所有有限集进行分类，从而实现对有限集基数的度量和比较。  
对无限集基数的度量和比较则没有这么简单。如前所述，任意一个无限集合，都可以找到它的一个子集与自然数集等势。因此，自然数集应当是规模最小的一种无限集合，可用自然数集作为无限集基数的最小度量单位或者度量基准。据此得到如下定义：  
【定义1.19】凡是与自然数集$N$ 等势的集合都称为可数集合，该类集合的基数记为$\aleph_{0}$，读作阿列夫零。  
根据上述例题，可以得到关于有限集合和可数集合的如下基本性质：  
（1）两个有限集合等势，当且仅当它们具有相同的元素个数；（2）有限集合不可能与其任何真子集合等势； （3）可数集合可以与其可数的真子集等势。  
由此可知，元素个数不相等的无限集之间仍有可能存在等势关系。因此，无限集合的基数已经不能通过集合中元素的个数来度量，或者说不能用一个自然数来度量，而是需要以自然数集或其它无限集合的基数为标准进行度量。  
现在考察这样的一个问题，除了可数集合之外，还有没有其它的无限集合？或者说，是否每一个无限集合都能够与自然数集合建立一一对应的关系？事实上并非如此，例如开区间(0, 1)就不能与自然数建立等势关系，所有与开区间(0, 1)等势的集合构成了另外一类不同规模的集合，称之为不可数集合。其具体定义如下：  
【定义1.20】开区间(0, 1)称为不可数集合，其基数记为ℵ，读作阿列夫；凡是与开区间(0, 1)等势的集合都称为不可数集合。  
因此，不可数集合是比可数集合规模更大的一种无限集合类型。当然，还可以考虑不可数集合的幂集、不可数集合幂集的幂集等等，由此可以构造出很多种不同基数的无限集合。关于这些无限集合基数及其性质的讨论已经超出了离散数学的范畴，有兴趣的读者可以参阅实变函数理论中与连续统相关的内容。",自然数集作为无限集基数的最小度量单位或度量基准，用于比较可数集合的基数
无限集的基数比较,度量基准,不可数集合,,"从前面的讨论不难看出，对于任意一个给定的自然数$n$，该自然数其实就是对所有含有$n$ 个元素集合的一种抽象。例如，自然数3 就是对所有含有3 个元素集合的抽象，或者说自然数3 就是将所有含有3 个元素的集合房子一起组成集族。因此，自然数可以根据集合中所含元素个数为标准对所有有限集进行分类，从而实现对有限集基数的度量和比较。  
对无限集基数的度量和比较则没有这么简单。如前所述，任意一个无限集合，都可以找到它的一个子集与自然数集等势。因此，自然数集应当是规模最小的一种无限集合，可用自然数集作为无限集基数的最小度量单位或者度量基准。据此得到如下定义：  
【定义1.19】凡是与自然数集$N$ 等势的集合都称为可数集合，该类集合的基数记为$\aleph_{0}$，读作阿列夫零。  
根据上述例题，可以得到关于有限集合和可数集合的如下基本性质：  
（1）两个有限集合等势，当且仅当它们具有相同的元素个数；（2）有限集合不可能与其任何真子集合等势； （3）可数集合可以与其可数的真子集等势。  
由此可知，元素个数不相等的无限集之间仍有可能存在等势关系。因此，无限集合的基数已经不能通过集合中元素的个数来度量，或者说不能用一个自然数来度量，而是需要以自然数集或其它无限集合的基数为标准进行度量。  
现在考察这样的一个问题，除了可数集合之外，还有没有其它的无限集合？或者说，是否每一个无限集合都能够与自然数集合建立一一对应的关系？事实上并非如此，例如开区间(0, 1)就不能与自然数建立等势关系，所有与开区间(0, 1)等势的集合构成了另外一类不同规模的集合，称之为不可数集合。其具体定义如下：  
【定义1.20】开区间(0, 1)称为不可数集合，其基数记为ℵ，读作阿列夫；凡是与开区间(0, 1)等势的集合都称为不可数集合。  
因此，不可数集合是比可数集合规模更大的一种无限集合类型。当然，还可以考虑不可数集合的幂集、不可数集合幂集的幂集等等，由此可以构造出很多种不同基数的无限集合。关于这些无限集合基数及其性质的讨论已经超出了离散数学的范畴，有兴趣的读者可以参阅实变函数理论中与连续统相关的内容。",通过自然数集或其它无限集合的基数为标准进行不可数集合的基数度量
有限集的基本计数技术,应用于,计算机问题求解,,现考察有限集的度量问题，度量有限集的目标是要统计出集合中元素的个数。当集合不是以枚举方式出现时，对元素个数的统计有时就不一定是显然的，需要一些相关技巧或技术，称之为计数技术。有限集合的计数技术在计算机问题求解或算法设计中具有基础性的重要作用。例如对于算法设计来说，如果要设计出问题求解的有效算法，很多情况下需要计算或估算出解空间或状态空间大小规模。事实上，这些解空间就是一些有限集合，度量这些有限集的大小就需要对其进行计数。目前，计数技术可大致分为基本计数技术和高级计数技术这两种基本类型，本节主要学习若干基本计数技术，具体包括加法原理与乘法原理、容斥原理与鸽笼原理、排列计数与组合计数。,有限集的基本计数技术在计算机问题求解中具有基础性的重要作用
有限集的基本计数技术,应用于,算法设计,,现考察有限集的度量问题，度量有限集的目标是要统计出集合中元素的个数。当集合不是以枚举方式出现时，对元素个数的统计有时就不一定是显然的，需要一些相关技巧或技术，称之为计数技术。有限集合的计数技术在计算机问题求解或算法设计中具有基础性的重要作用。例如对于算法设计来说，如果要设计出问题求解的有效算法，很多情况下需要计算或估算出解空间或状态空间大小规模。事实上，这些解空间就是一些有限集合，度量这些有限集的大小就需要对其进行计数。目前，计数技术可大致分为基本计数技术和高级计数技术这两种基本类型，本节主要学习若干基本计数技术，具体包括加法原理与乘法原理、容斥原理与鸽笼原理、排列计数与组合计数。,有限集的基本计数技术在算法设计中具有基础性的重要作用
有限集的基本计数技术,用于度量,解空间,,现考察有限集的度量问题，度量有限集的目标是要统计出集合中元素的个数。当集合不是以枚举方式出现时，对元素个数的统计有时就不一定是显然的，需要一些相关技巧或技术，称之为计数技术。有限集合的计数技术在计算机问题求解或算法设计中具有基础性的重要作用。例如对于算法设计来说，如果要设计出问题求解的有效算法，很多情况下需要计算或估算出解空间或状态空间大小规模。事实上，这些解空间就是一些有限集合，度量这些有限集的大小就需要对其进行计数。目前，计数技术可大致分为基本计数技术和高级计数技术这两种基本类型，本节主要学习若干基本计数技术，具体包括加法原理与乘法原理、容斥原理与鸽笼原理、排列计数与组合计数。,有限集的基本计数技术用于度量解空间的大小
有限集的基本计数技术,用于度量,状态空间,,现考察有限集的度量问题，度量有限集的目标是要统计出集合中元素的个数。当集合不是以枚举方式出现时，对元素个数的统计有时就不一定是显然的，需要一些相关技巧或技术，称之为计数技术。有限集合的计数技术在计算机问题求解或算法设计中具有基础性的重要作用。例如对于算法设计来说，如果要设计出问题求解的有效算法，很多情况下需要计算或估算出解空间或状态空间大小规模。事实上，这些解空间就是一些有限集合，度量这些有限集的大小就需要对其进行计数。目前，计数技术可大致分为基本计数技术和高级计数技术这两种基本类型，本节主要学习若干基本计数技术，具体包括加法原理与乘法原理、容斥原理与鸽笼原理、排列计数与组合计数。,有限集的基本计数技术用于度量状态空间的大小
有限集的基本计数技术,包括,加法原理,,现考察有限集的度量问题，度量有限集的目标是要统计出集合中元素的个数。当集合不是以枚举方式出现时，对元素个数的统计有时就不一定是显然的，需要一些相关技巧或技术，称之为计数技术。有限集合的计数技术在计算机问题求解或算法设计中具有基础性的重要作用。例如对于算法设计来说，如果要设计出问题求解的有效算法，很多情况下需要计算或估算出解空间或状态空间大小规模。事实上，这些解空间就是一些有限集合，度量这些有限集的大小就需要对其进行计数。目前，计数技术可大致分为基本计数技术和高级计数技术这两种基本类型，本节主要学习若干基本计数技术，具体包括加法原理与乘法原理、容斥原理与鸽笼原理、排列计数与组合计数。,有限集的基本计数技术包括加法原理
有限集的基本计数技术,包括,乘法原理,,现考察有限集的度量问题，度量有限集的目标是要统计出集合中元素的个数。当集合不是以枚举方式出现时，对元素个数的统计有时就不一定是显然的，需要一些相关技巧或技术，称之为计数技术。有限集合的计数技术在计算机问题求解或算法设计中具有基础性的重要作用。例如对于算法设计来说，如果要设计出问题求解的有效算法，很多情况下需要计算或估算出解空间或状态空间大小规模。事实上，这些解空间就是一些有限集合，度量这些有限集的大小就需要对其进行计数。目前，计数技术可大致分为基本计数技术和高级计数技术这两种基本类型，本节主要学习若干基本计数技术，具体包括加法原理与乘法原理、容斥原理与鸽笼原理、排列计数与组合计数。,有限集的基本计数技术包括乘法原理
有限集的基本计数技术,包括,容斥原理,,现考察有限集的度量问题，度量有限集的目标是要统计出集合中元素的个数。当集合不是以枚举方式出现时，对元素个数的统计有时就不一定是显然的，需要一些相关技巧或技术，称之为计数技术。有限集合的计数技术在计算机问题求解或算法设计中具有基础性的重要作用。例如对于算法设计来说，如果要设计出问题求解的有效算法，很多情况下需要计算或估算出解空间或状态空间大小规模。事实上，这些解空间就是一些有限集合，度量这些有限集的大小就需要对其进行计数。目前，计数技术可大致分为基本计数技术和高级计数技术这两种基本类型，本节主要学习若干基本计数技术，具体包括加法原理与乘法原理、容斥原理与鸽笼原理、排列计数与组合计数。,有限集的基本计数技术包括容斥原理
有限集的基本计数技术,包括,鸽笼原理,,现考察有限集的度量问题，度量有限集的目标是要统计出集合中元素的个数。当集合不是以枚举方式出现时，对元素个数的统计有时就不一定是显然的，需要一些相关技巧或技术，称之为计数技术。有限集合的计数技术在计算机问题求解或算法设计中具有基础性的重要作用。例如对于算法设计来说，如果要设计出问题求解的有效算法，很多情况下需要计算或估算出解空间或状态空间大小规模。事实上，这些解空间就是一些有限集合，度量这些有限集的大小就需要对其进行计数。目前，计数技术可大致分为基本计数技术和高级计数技术这两种基本类型，本节主要学习若干基本计数技术，具体包括加法原理与乘法原理、容斥原理与鸽笼原理、排列计数与组合计数。,有限集的基本计数技术包括鸽笼原理
有限集的基本计数技术,包括,排列计数,,现考察有限集的度量问题，度量有限集的目标是要统计出集合中元素的个数。当集合不是以枚举方式出现时，对元素个数的统计有时就不一定是显然的，需要一些相关技巧或技术，称之为计数技术。有限集合的计数技术在计算机问题求解或算法设计中具有基础性的重要作用。例如对于算法设计来说，如果要设计出问题求解的有效算法，很多情况下需要计算或估算出解空间或状态空间大小规模。事实上，这些解空间就是一些有限集合，度量这些有限集的大小就需要对其进行计数。目前，计数技术可大致分为基本计数技术和高级计数技术这两种基本类型，本节主要学习若干基本计数技术，具体包括加法原理与乘法原理、容斥原理与鸽笼原理、排列计数与组合计数。,有限集的基本计数技术包括排列计数
有限集的基本计数技术,包括,组合计数,,现考察有限集的度量问题，度量有限集的目标是要统计出集合中元素的个数。当集合不是以枚举方式出现时，对元素个数的统计有时就不一定是显然的，需要一些相关技巧或技术，称之为计数技术。有限集合的计数技术在计算机问题求解或算法设计中具有基础性的重要作用。例如对于算法设计来说，如果要设计出问题求解的有效算法，很多情况下需要计算或估算出解空间或状态空间大小规模。事实上，这些解空间就是一些有限集合，度量这些有限集的大小就需要对其进行计数。目前，计数技术可大致分为基本计数技术和高级计数技术这两种基本类型，本节主要学习若干基本计数技术，具体包括加法原理与乘法原理、容斥原理与鸽笼原理、排列计数与组合计数。,有限集的基本计数技术包括组合计数
加法原理,基础,乘法原理,,"加法原理和乘法原理是最基本的计数法则，其它所有计数方法或技巧都建立在这两个法则的基础之上。  
加法原理：对于任意一个有限集合$A$，如果它可以看成是多个集合的并集且这多个集合之间互不相交，即有：  
$$
A=A_{1}\cup A_{2}\cup\cdots\cup A_{n}\ \stackrel{\mathrm{~H~}}{\cdots}\ A_{i}\cap A_{j}=\varnothing\ \left(i\neq j\right)
$$  
则有：  
$$
|A|=|A_{1}|+|A_{2}|+\cdots+|A_{n}|
$$  
加法原理的另外一种说法如下：  
如果$n$ 个独立事件分别有$\cdot k_{1},k_{2},\cdots,k_{n}$种方式发生，那么这$n$ 个独立事件之一发生方式的总数$k$ 有可按下式计算：  
$$
k=k_{1}+k_{2}+\dots+k_{n}
$$  
加法原理的含义非常直观，其正确性是显然的。使用加法原理进行计数的关键在于如何将一个有限集合适当划分为若干互不相交的子集，并计算这些子集的基数。如果完成一个任务可以采用很多种不同的方法，而且每一种方法又有很多种不同的选择，那么完成该项任务的总方法数就等于这些所有选择数的总和。",加法原理和乘法原理是最基本的计数法则，其它所有计数方法或技巧都建立在这两个法则的基础之上
容斥原理,推广,加法原理,,在前述加法原理中，我们将某个集合看成是由多个集合的并运算而构成，并且要求参与并运算的多个集合互不相交。现在将加法原理中多个集合互不相交的条件去掉，由此便可得到容斥原理。因此，容斥原理可看成是加法原理的一种推广形式。,容斥原理是加法原理的一种推广形式，去除了加法原理中多个集合互不相交的条件
容斥原理,无直接关系,鸽笼原理,,"首先考察下列问题：假设某班共有50 人，其中有32 人会唱歌、26 人会跳舞、15 人既会唱歌又会跳舞，问多少人会唱歌或会跳舞？多少人既不会唱歌也不会跳舞？  
如图1-7 所示，集合$A$ 表示班上所有会唱歌的人，$B$ 表示班上所有会跳舞的人，$A\cap B$表示班上所有既会唱歌又会跳舞人，$A\cup B$表示班上所有会唱歌或者会跳舞人。  
不难看出，若将$A$ 与$B$ 的基数直接相加，即将分别表示$A$ 和$B$ 的两个区域直接相加，则图中表示$A\cap B$的阴影部分就是双层的。因此，要想像加法原理那样用$A$ 和$B$的基数和作为$A\cup B$的基数，就必须将表示𝐴∩$B$的阴影部分去掉一层，即减去一个$|A\cap B|$，故有：  
$$
|A\cup B|=|A|+|B|-|A\cap B|=32+26-15=43(\mathcal{A})
$$  
显然，班上既不会唱歌也不会跳舞的人数为：  
$$
|{\overline{{A\cup B}}}|=|U|-|A\cup B|=50-43=7(\mathcal{A})
$$  
![](images/83294eaaa652139fdc533ac2326406b29ebe30c3a5ea63f76c324c67d62b5655.jpg)
图1-7 唱歌跳舞人数集合  
一般地，对于任意给定的两个有限集合，成立如下的容斥原理：【定理1.8】假设$A$ 和$B$ 是任意两个有限集合，则有：  
$$
|A\cup B|=|A|+|B|-|A\cap B|
$$",文本中仅提及容斥原理，未涉及鸽笼原理，两者无直接关系
鸽笼原理,等价,定理1.11,,"鸽笼原理是数学神童狄利克雷在9 岁时提出，那时他家中有九个鸽笼十只鸽子，他观察到这样一个现象：无论怎样分配鸽笼给鸽子，必然一个鸽笼里面至少有两只鸽子，便由此提出鸽笼原理，并用该原理解决很多数学问题。鸽笼原理有时也称为抽屉法则，通俗地说，就是将5 本书放在4 个抽屉里面，必然有一个抽屉至少有两本书。  
【定理1.11】如果把多于$n$ 个的元素按任一方式分成$n$ 个集合，那么至少有一个集合中含有两个或两个以上的元素。  
【定理1.12】将$n$ 个元素以任一方式分成$m$ 个集合且$m<n$，则必然存在一个集合中至少有含有$\lfloor(n-1)/m\rfloor+1$个元素。其中$\lfloor x\rfloor$表示对实数$x$ 进行向下下取整，即取不超过$x$ 的最大整数部分。",鸽笼原理与定理1.11表述的是同一个数学概念，即多于n个元素分成n个集合时，至少有一个集合包含两个或更多元素。
鸽笼原理,推广,定理1.12,,"鸽笼原理是数学神童狄利克雷在9 岁时提出，那时他家中有九个鸽笼十只鸽子，他观察到这样一个现象：无论怎样分配鸽笼给鸽子，必然一个鸽笼里面至少有两只鸽子，便由此提出鸽笼原理，并用该原理解决很多数学问题。鸽笼原理有时也称为抽屉法则，通俗地说，就是将5 本书放在4 个抽屉里面，必然有一个抽屉至少有两本书。  
【定理1.11】如果把多于$n$ 个的元素按任一方式分成$n$ 个集合，那么至少有一个集合中含有两个或两个以上的元素。  
【定理1.12】将$n$ 个元素以任一方式分成$m$ 个集合且$m<n$，则必然存在一个集合中至少有含有$\lfloor(n-1)/m\rfloor+1$个元素。其中$\lfloor x\rfloor$表示对实数$x$ 进行向下下取整，即取不超过$x$ 的最大整数部分。",鸽笼原理是定理1.12的特例，定理1.12更一般地描述了将n个元素分成m个集合时，至少有一个集合包含至少\lfloor(n-1)/m\rfloor+1个元素的情况。
排列计数,分类,组合计数,,排列与组合是两类比较基本的计数问题，根据从集合中选择元素的有序与无序、是否允许重复等限制条件，可将这两类问题进一步划分为四种基本类型，即不重复的排列、不重复的组合、可重复的排列和可重复的组合。,排列计数和组合计数根据选择元素的有序与无序、是否允许重复等条件，可划分为四种基本类型
不重复排列,包含,全排列,,"首先考察如下排列问题：  
某班有35 名同学，现从中选出15 名同学排成一排，问有多少种排列方式？  
这个问题有如下两个关键要点：第一、在排列中每位同学最多只能出现一次，也就是无重复性；第二、不同的次序构成不同的排列。由此得到如下不重复排列的概念：  
【定义1.21】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中依次取出$r$ 个不同元素并将其按取出的次序排成一排，由此形成的一个有序排列称之为不重复$r\cdot$-排列，简称为$r\cdot$-排列或排列，不重复$r\cdot$-排列的个数称为不重复$r\cdot$-排列数，简称为$r\cdot$-排列数或排列数，记为${P}_{n}^{r}$或$P(n,r)$。称$r=n$时构成的排列称为全排列，$r<n$时构成的排列为选排列。  
根据乘法原理，显然可以得到如下结论：  
【定理1.13】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r\cdot$-排列数计算公式：  
$P(n,r)=n(n-1)(n-2)\cdots(n-r+1)\ \ ={\frac{n!}{(n-r)!}}$ 其中：$n!=n(n-1)(n-2)\cdots2\cdot1$  
【定义1.22】假设$S$是由$n$ 个不同的元素组成的集合，从$S$ 中依次取出$r$ 个不同元素并将其按取出的次序排成一个圆圈，由此形成的一个有序圆排列称之为不重复$r\cdot$-圆排列，简称为$r\cdot$-圆排列或圆排列，不重复$r\cdot$圆排列的个数称为不重复$r\cdot$-圆排列数，简称为$r\cdot$-圆排列数或圆排列数，记为${\cal P}_{c}(n,r)$。  
相对于上述圆排列的概念，有时亦将$r\cdot$-排列称为$r$-线排列或线排列。由前面分析不难看出，如果将每个$r\cdot$-线排列的首尾相连构成一个$r\cdot$-圆排列，则由此构成的所有圆排列必然有$r$倍的重复数。故有如下$r\cdot$-圆排列计算公式：  
【定理1.14】对于任意给定的两个正整数$n$ 和$r$，且$r\leq n$，其$r\cdot$-圆排列数为$P_{c}(n,r)$：  
$$
P_{c}(n,r)=\frac{P(n,r)}{r}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r}=\frac{n!}{r(n-r)!}
$$  
以上例子的共有特点是所有选出的元素都有一定的次序。事实上，很多情况下并不需要选出的元素具有有次序。  
考察如下组合问题：  
某班有35 名同学，现从中任意选出15 名同学参加问卷活动，问有多少种选择方式？  
与前述$r$-排列问题不同的是，这个问题只考虑抽取的是哪15 名同学，并不考虑抽取次序以及与之相关的排列问题。由此得到如下不重复组合及相关组合数的概念：  
【定义1.23】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中任意取出$r$ 个不同元素组成一个子集合，称每一个这样的子集合为一个不重复$r$-组合，简称为$r\cdot$-组合或组合，不重复$r$-组合的个数称为不重复$r\cdot$-组合数，简称为$r\cdot$-组合数或组合数，记为$C_{n}^{r}$或$C(n,r)$。  
显然， $r$ - 组合与 $r$ - 排列的区别在于 $r\cdot$ 组合不考虑组合中元素的排列次序， $r\cdot$ - 排列必须考 虑排列中各元素的排列次序。如果两个$r\cdot$-排列所含的元素完全相同，仅仅是排列次序不同，两个$r\cdot$-排列是同一个组合，由此得到有如下组合数计算公式：  
【定理1.15】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r-$组合数计算公式：  
$$
C(n,r)=\frac{P(n,r)}{r!}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r!}=\frac{n!}{r!(n-r)!}
$$",全排列是不重复排列的一种特殊情况，当$r=n$时称为全排列。
不重复排列,包含,选排列,,"首先考察如下排列问题：  
某班有35 名同学，现从中选出15 名同学排成一排，问有多少种排列方式？  
这个问题有如下两个关键要点：第一、在排列中每位同学最多只能出现一次，也就是无重复性；第二、不同的次序构成不同的排列。由此得到如下不重复排列的概念：  
【定义1.21】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中依次取出$r$ 个不同元素并将其按取出的次序排成一排，由此形成的一个有序排列称之为不重复$r\cdot$-排列，简称为$r\cdot$-排列或排列，不重复$r\cdot$-排列的个数称为不重复$r\cdot$-排列数，简称为$r\cdot$-排列数或排列数，记为${P}_{n}^{r}$或$P(n,r)$。称$r=n$时构成的排列称为全排列，$r<n$时构成的排列为选排列。  
根据乘法原理，显然可以得到如下结论：  
【定理1.13】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r\cdot$-排列数计算公式：  
$P(n,r)=n(n-1)(n-2)\cdots(n-r+1)\ \ ={\frac{n!}{(n-r)!}}$ 其中：$n!=n(n-1)(n-2)\cdots2\cdot1$  
【定义1.22】假设$S$是由$n$ 个不同的元素组成的集合，从$S$ 中依次取出$r$ 个不同元素并将其按取出的次序排成一个圆圈，由此形成的一个有序圆排列称之为不重复$r\cdot$-圆排列，简称为$r\cdot$-圆排列或圆排列，不重复$r\cdot$圆排列的个数称为不重复$r\cdot$-圆排列数，简称为$r\cdot$-圆排列数或圆排列数，记为${\cal P}_{c}(n,r)$。  
相对于上述圆排列的概念，有时亦将$r\cdot$-排列称为$r$-线排列或线排列。由前面分析不难看出，如果将每个$r\cdot$-线排列的首尾相连构成一个$r\cdot$-圆排列，则由此构成的所有圆排列必然有$r$倍的重复数。故有如下$r\cdot$-圆排列计算公式：  
【定理1.14】对于任意给定的两个正整数$n$ 和$r$，且$r\leq n$，其$r\cdot$-圆排列数为$P_{c}(n,r)$：  
$$
P_{c}(n,r)=\frac{P(n,r)}{r}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r}=\frac{n!}{r(n-r)!}
$$  
以上例子的共有特点是所有选出的元素都有一定的次序。事实上，很多情况下并不需要选出的元素具有有次序。  
考察如下组合问题：  
某班有35 名同学，现从中任意选出15 名同学参加问卷活动，问有多少种选择方式？  
与前述$r$-排列问题不同的是，这个问题只考虑抽取的是哪15 名同学，并不考虑抽取次序以及与之相关的排列问题。由此得到如下不重复组合及相关组合数的概念：  
【定义1.23】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中任意取出$r$ 个不同元素组成一个子集合，称每一个这样的子集合为一个不重复$r$-组合，简称为$r\cdot$-组合或组合，不重复$r$-组合的个数称为不重复$r\cdot$-组合数，简称为$r\cdot$-组合数或组合数，记为$C_{n}^{r}$或$C(n,r)$。  
显然， $r$ - 组合与 $r$ - 排列的区别在于 $r\cdot$ 组合不考虑组合中元素的排列次序， $r\cdot$ - 排列必须考 虑排列中各元素的排列次序。如果两个$r\cdot$-排列所含的元素完全相同，仅仅是排列次序不同，两个$r\cdot$-排列是同一个组合，由此得到有如下组合数计算公式：  
【定理1.15】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r-$组合数计算公式：  
$$
C(n,r)=\frac{P(n,r)}{r!}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r!}=\frac{n!}{r!(n-r)!}
$$",选排列是不重复排列的一种特殊情况，当$r<n$时称为选排列。
不重复排列,等价,r-线排列,,"首先考察如下排列问题：  
某班有35 名同学，现从中选出15 名同学排成一排，问有多少种排列方式？  
这个问题有如下两个关键要点：第一、在排列中每位同学最多只能出现一次，也就是无重复性；第二、不同的次序构成不同的排列。由此得到如下不重复排列的概念：  
【定义1.21】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中依次取出$r$ 个不同元素并将其按取出的次序排成一排，由此形成的一个有序排列称之为不重复$r\cdot$-排列，简称为$r\cdot$-排列或排列，不重复$r\cdot$-排列的个数称为不重复$r\cdot$-排列数，简称为$r\cdot$-排列数或排列数，记为${P}_{n}^{r}$或$P(n,r)$。称$r=n$时构成的排列称为全排列，$r<n$时构成的排列为选排列。  
根据乘法原理，显然可以得到如下结论：  
【定理1.13】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r\cdot$-排列数计算公式：  
$P(n,r)=n(n-1)(n-2)\cdots(n-r+1)\ \ ={\frac{n!}{(n-r)!}}$ 其中：$n!=n(n-1)(n-2)\cdots2\cdot1$  
【定义1.22】假设$S$是由$n$ 个不同的元素组成的集合，从$S$ 中依次取出$r$ 个不同元素并将其按取出的次序排成一个圆圈，由此形成的一个有序圆排列称之为不重复$r\cdot$-圆排列，简称为$r\cdot$-圆排列或圆排列，不重复$r\cdot$圆排列的个数称为不重复$r\cdot$-圆排列数，简称为$r\cdot$-圆排列数或圆排列数，记为${\cal P}_{c}(n,r)$。  
相对于上述圆排列的概念，有时亦将$r\cdot$-排列称为$r$-线排列或线排列。由前面分析不难看出，如果将每个$r\cdot$-线排列的首尾相连构成一个$r\cdot$-圆排列，则由此构成的所有圆排列必然有$r$倍的重复数。故有如下$r\cdot$-圆排列计算公式：  
【定理1.14】对于任意给定的两个正整数$n$ 和$r$，且$r\leq n$，其$r\cdot$-圆排列数为$P_{c}(n,r)$：  
$$
P_{c}(n,r)=\frac{P(n,r)}{r}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r}=\frac{n!}{r(n-r)!}
$$  
以上例子的共有特点是所有选出的元素都有一定的次序。事实上，很多情况下并不需要选出的元素具有有次序。  
考察如下组合问题：  
某班有35 名同学，现从中任意选出15 名同学参加问卷活动，问有多少种选择方式？  
与前述$r$-排列问题不同的是，这个问题只考虑抽取的是哪15 名同学，并不考虑抽取次序以及与之相关的排列问题。由此得到如下不重复组合及相关组合数的概念：  
【定义1.23】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中任意取出$r$ 个不同元素组成一个子集合，称每一个这样的子集合为一个不重复$r$-组合，简称为$r\cdot$-组合或组合，不重复$r$-组合的个数称为不重复$r\cdot$-组合数，简称为$r\cdot$-组合数或组合数，记为$C_{n}^{r}$或$C(n,r)$。  
显然， $r$ - 组合与 $r$ - 排列的区别在于 $r\cdot$ 组合不考虑组合中元素的排列次序， $r\cdot$ - 排列必须考 虑排列中各元素的排列次序。如果两个$r\cdot$-排列所含的元素完全相同，仅仅是排列次序不同，两个$r\cdot$-排列是同一个组合，由此得到有如下组合数计算公式：  
【定理1.15】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r-$组合数计算公式：  
$$
C(n,r)=\frac{P(n,r)}{r!}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r!}=\frac{n!}{r!(n-r)!}
$$",不重复$r\cdot$-排列也称为$r$-线排列或线排列。
不重复圆排列,转换,r-线排列,,"首先考察如下排列问题：  
某班有35 名同学，现从中选出15 名同学排成一排，问有多少种排列方式？  
这个问题有如下两个关键要点：第一、在排列中每位同学最多只能出现一次，也就是无重复性；第二、不同的次序构成不同的排列。由此得到如下不重复排列的概念：  
【定义1.21】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中依次取出$r$ 个不同元素并将其按取出的次序排成一排，由此形成的一个有序排列称之为不重复$r\cdot$-排列，简称为$r\cdot$-排列或排列，不重复$r\cdot$-排列的个数称为不重复$r\cdot$-排列数，简称为$r\cdot$-排列数或排列数，记为${P}_{n}^{r}$或$P(n,r)$。称$r=n$时构成的排列称为全排列，$r<n$时构成的排列为选排列。  
根据乘法原理，显然可以得到如下结论：  
【定理1.13】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r\cdot$-排列数计算公式：  
$P(n,r)=n(n-1)(n-2)\cdots(n-r+1)\ \ ={\frac{n!}{(n-r)!}}$ 其中：$n!=n(n-1)(n-2)\cdots2\cdot1$  
【定义1.22】假设$S$是由$n$ 个不同的元素组成的集合，从$S$ 中依次取出$r$ 个不同元素并将其按取出的次序排成一个圆圈，由此形成的一个有序圆排列称之为不重复$r\cdot$-圆排列，简称为$r\cdot$-圆排列或圆排列，不重复$r\cdot$圆排列的个数称为不重复$r\cdot$-圆排列数，简称为$r\cdot$-圆排列数或圆排列数，记为${\cal P}_{c}(n,r)$。  
相对于上述圆排列的概念，有时亦将$r\cdot$-排列称为$r$-线排列或线排列。由前面分析不难看出，如果将每个$r\cdot$-线排列的首尾相连构成一个$r\cdot$-圆排列，则由此构成的所有圆排列必然有$r$倍的重复数。故有如下$r\cdot$-圆排列计算公式：  
【定理1.14】对于任意给定的两个正整数$n$ 和$r$，且$r\leq n$，其$r\cdot$-圆排列数为$P_{c}(n,r)$：  
$$
P_{c}(n,r)=\frac{P(n,r)}{r}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r}=\frac{n!}{r(n-r)!}
$$  
以上例子的共有特点是所有选出的元素都有一定的次序。事实上，很多情况下并不需要选出的元素具有有次序。  
考察如下组合问题：  
某班有35 名同学，现从中任意选出15 名同学参加问卷活动，问有多少种选择方式？  
与前述$r$-排列问题不同的是，这个问题只考虑抽取的是哪15 名同学，并不考虑抽取次序以及与之相关的排列问题。由此得到如下不重复组合及相关组合数的概念：  
【定义1.23】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中任意取出$r$ 个不同元素组成一个子集合，称每一个这样的子集合为一个不重复$r$-组合，简称为$r\cdot$-组合或组合，不重复$r$-组合的个数称为不重复$r\cdot$-组合数，简称为$r\cdot$-组合数或组合数，记为$C_{n}^{r}$或$C(n,r)$。  
显然， $r$ - 组合与 $r$ - 排列的区别在于 $r\cdot$ 组合不考虑组合中元素的排列次序， $r\cdot$ - 排列必须考 虑排列中各元素的排列次序。如果两个$r\cdot$-排列所含的元素完全相同，仅仅是排列次序不同，两个$r\cdot$-排列是同一个组合，由此得到有如下组合数计算公式：  
【定理1.15】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r-$组合数计算公式：  
$$
C(n,r)=\frac{P(n,r)}{r!}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r!}=\frac{n!}{r!(n-r)!}
$$",将每个$r\cdot$-线排列的首尾相连可以构成一个$r\cdot$-圆排列。
不重复组合,区别,r-线排列,,"首先考察如下排列问题：  
某班有35 名同学，现从中选出15 名同学排成一排，问有多少种排列方式？  
这个问题有如下两个关键要点：第一、在排列中每位同学最多只能出现一次，也就是无重复性；第二、不同的次序构成不同的排列。由此得到如下不重复排列的概念：  
【定义1.21】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中依次取出$r$ 个不同元素并将其按取出的次序排成一排，由此形成的一个有序排列称之为不重复$r\cdot$-排列，简称为$r\cdot$-排列或排列，不重复$r\cdot$-排列的个数称为不重复$r\cdot$-排列数，简称为$r\cdot$-排列数或排列数，记为${P}_{n}^{r}$或$P(n,r)$。称$r=n$时构成的排列称为全排列，$r<n$时构成的排列为选排列。  
根据乘法原理，显然可以得到如下结论：  
【定理1.13】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r\cdot$-排列数计算公式：  
$P(n,r)=n(n-1)(n-2)\cdots(n-r+1)\ \ ={\frac{n!}{(n-r)!}}$ 其中：$n!=n(n-1)(n-2)\cdots2\cdot1$  
【定义1.22】假设$S$是由$n$ 个不同的元素组成的集合，从$S$ 中依次取出$r$ 个不同元素并将其按取出的次序排成一个圆圈，由此形成的一个有序圆排列称之为不重复$r\cdot$-圆排列，简称为$r\cdot$-圆排列或圆排列，不重复$r\cdot$圆排列的个数称为不重复$r\cdot$-圆排列数，简称为$r\cdot$-圆排列数或圆排列数，记为${\cal P}_{c}(n,r)$。  
相对于上述圆排列的概念，有时亦将$r\cdot$-排列称为$r$-线排列或线排列。由前面分析不难看出，如果将每个$r\cdot$-线排列的首尾相连构成一个$r\cdot$-圆排列，则由此构成的所有圆排列必然有$r$倍的重复数。故有如下$r\cdot$-圆排列计算公式：  
【定理1.14】对于任意给定的两个正整数$n$ 和$r$，且$r\leq n$，其$r\cdot$-圆排列数为$P_{c}(n,r)$：  
$$
P_{c}(n,r)=\frac{P(n,r)}{r}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r}=\frac{n!}{r(n-r)!}
$$  
以上例子的共有特点是所有选出的元素都有一定的次序。事实上，很多情况下并不需要选出的元素具有有次序。  
考察如下组合问题：  
某班有35 名同学，现从中任意选出15 名同学参加问卷活动，问有多少种选择方式？  
与前述$r$-排列问题不同的是，这个问题只考虑抽取的是哪15 名同学，并不考虑抽取次序以及与之相关的排列问题。由此得到如下不重复组合及相关组合数的概念：  
【定义1.23】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中任意取出$r$ 个不同元素组成一个子集合，称每一个这样的子集合为一个不重复$r$-组合，简称为$r\cdot$-组合或组合，不重复$r$-组合的个数称为不重复$r\cdot$-组合数，简称为$r\cdot$-组合数或组合数，记为$C_{n}^{r}$或$C(n,r)$。  
显然， $r$ - 组合与 $r$ - 排列的区别在于 $r\cdot$ 组合不考虑组合中元素的排列次序， $r\cdot$ - 排列必须考 虑排列中各元素的排列次序。如果两个$r\cdot$-排列所含的元素完全相同，仅仅是排列次序不同，两个$r\cdot$-排列是同一个组合，由此得到有如下组合数计算公式：  
【定理1.15】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r-$组合数计算公式：  
$$
C(n,r)=\frac{P(n,r)}{r!}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r!}=\frac{n!}{r!(n-r)!}
$$",不重复$r$-组合不考虑组合中元素的排列次序，而$r\cdot$-排列必须考虑排列中各元素的排列次序。
定理1.13,描述,不重复排列,,"首先考察如下排列问题：  
某班有35 名同学，现从中选出15 名同学排成一排，问有多少种排列方式？  
这个问题有如下两个关键要点：第一、在排列中每位同学最多只能出现一次，也就是无重复性；第二、不同的次序构成不同的排列。由此得到如下不重复排列的概念：  
【定义1.21】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中依次取出$r$ 个不同元素并将其按取出的次序排成一排，由此形成的一个有序排列称之为不重复$r\cdot$-排列，简称为$r\cdot$-排列或排列，不重复$r\cdot$-排列的个数称为不重复$r\cdot$-排列数，简称为$r\cdot$-排列数或排列数，记为${P}_{n}^{r}$或$P(n,r)$。称$r=n$时构成的排列称为全排列，$r<n$时构成的排列为选排列。  
根据乘法原理，显然可以得到如下结论：  
【定理1.13】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r\cdot$-排列数计算公式：  
$P(n,r)=n(n-1)(n-2)\cdots(n-r+1)\ \ ={\frac{n!}{(n-r)!}}$ 其中：$n!=n(n-1)(n-2)\cdots2\cdot1$  
【定义1.22】假设$S$是由$n$ 个不同的元素组成的集合，从$S$ 中依次取出$r$ 个不同元素并将其按取出的次序排成一个圆圈，由此形成的一个有序圆排列称之为不重复$r\cdot$-圆排列，简称为$r\cdot$-圆排列或圆排列，不重复$r\cdot$圆排列的个数称为不重复$r\cdot$-圆排列数，简称为$r\cdot$-圆排列数或圆排列数，记为${\cal P}_{c}(n,r)$。  
相对于上述圆排列的概念，有时亦将$r\cdot$-排列称为$r$-线排列或线排列。由前面分析不难看出，如果将每个$r\cdot$-线排列的首尾相连构成一个$r\cdot$-圆排列，则由此构成的所有圆排列必然有$r$倍的重复数。故有如下$r\cdot$-圆排列计算公式：  
【定理1.14】对于任意给定的两个正整数$n$ 和$r$，且$r\leq n$，其$r\cdot$-圆排列数为$P_{c}(n,r)$：  
$$
P_{c}(n,r)=\frac{P(n,r)}{r}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r}=\frac{n!}{r(n-r)!}
$$  
以上例子的共有特点是所有选出的元素都有一定的次序。事实上，很多情况下并不需要选出的元素具有有次序。  
考察如下组合问题：  
某班有35 名同学，现从中任意选出15 名同学参加问卷活动，问有多少种选择方式？  
与前述$r$-排列问题不同的是，这个问题只考虑抽取的是哪15 名同学，并不考虑抽取次序以及与之相关的排列问题。由此得到如下不重复组合及相关组合数的概念：  
【定义1.23】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中任意取出$r$ 个不同元素组成一个子集合，称每一个这样的子集合为一个不重复$r$-组合，简称为$r\cdot$-组合或组合，不重复$r$-组合的个数称为不重复$r\cdot$-组合数，简称为$r\cdot$-组合数或组合数，记为$C_{n}^{r}$或$C(n,r)$。  
显然， $r$ - 组合与 $r$ - 排列的区别在于 $r\cdot$ 组合不考虑组合中元素的排列次序， $r\cdot$ - 排列必须考 虑排列中各元素的排列次序。如果两个$r\cdot$-排列所含的元素完全相同，仅仅是排列次序不同，两个$r\cdot$-排列是同一个组合，由此得到有如下组合数计算公式：  
【定理1.15】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r-$组合数计算公式：  
$$
C(n,r)=\frac{P(n,r)}{r!}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r!}=\frac{n!}{r!(n-r)!}
$$",定理1.13给出了不重复$r\cdot$-排列数的计算公式。
定理1.14,描述,不重复圆排列,,"首先考察如下排列问题：  
某班有35 名同学，现从中选出15 名同学排成一排，问有多少种排列方式？  
这个问题有如下两个关键要点：第一、在排列中每位同学最多只能出现一次，也就是无重复性；第二、不同的次序构成不同的排列。由此得到如下不重复排列的概念：  
【定义1.21】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中依次取出$r$ 个不同元素并将其按取出的次序排成一排，由此形成的一个有序排列称之为不重复$r\cdot$-排列，简称为$r\cdot$-排列或排列，不重复$r\cdot$-排列的个数称为不重复$r\cdot$-排列数，简称为$r\cdot$-排列数或排列数，记为${P}_{n}^{r}$或$P(n,r)$。称$r=n$时构成的排列称为全排列，$r<n$时构成的排列为选排列。  
根据乘法原理，显然可以得到如下结论：  
【定理1.13】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r\cdot$-排列数计算公式：  
$P(n,r)=n(n-1)(n-2)\cdots(n-r+1)\ \ ={\frac{n!}{(n-r)!}}$ 其中：$n!=n(n-1)(n-2)\cdots2\cdot1$  
【定义1.22】假设$S$是由$n$ 个不同的元素组成的集合，从$S$ 中依次取出$r$ 个不同元素并将其按取出的次序排成一个圆圈，由此形成的一个有序圆排列称之为不重复$r\cdot$-圆排列，简称为$r\cdot$-圆排列或圆排列，不重复$r\cdot$圆排列的个数称为不重复$r\cdot$-圆排列数，简称为$r\cdot$-圆排列数或圆排列数，记为${\cal P}_{c}(n,r)$。  
相对于上述圆排列的概念，有时亦将$r\cdot$-排列称为$r$-线排列或线排列。由前面分析不难看出，如果将每个$r\cdot$-线排列的首尾相连构成一个$r\cdot$-圆排列，则由此构成的所有圆排列必然有$r$倍的重复数。故有如下$r\cdot$-圆排列计算公式：  
【定理1.14】对于任意给定的两个正整数$n$ 和$r$，且$r\leq n$，其$r\cdot$-圆排列数为$P_{c}(n,r)$：  
$$
P_{c}(n,r)=\frac{P(n,r)}{r}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r}=\frac{n!}{r(n-r)!}
$$  
以上例子的共有特点是所有选出的元素都有一定的次序。事实上，很多情况下并不需要选出的元素具有有次序。  
考察如下组合问题：  
某班有35 名同学，现从中任意选出15 名同学参加问卷活动，问有多少种选择方式？  
与前述$r$-排列问题不同的是，这个问题只考虑抽取的是哪15 名同学，并不考虑抽取次序以及与之相关的排列问题。由此得到如下不重复组合及相关组合数的概念：  
【定义1.23】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中任意取出$r$ 个不同元素组成一个子集合，称每一个这样的子集合为一个不重复$r$-组合，简称为$r\cdot$-组合或组合，不重复$r$-组合的个数称为不重复$r\cdot$-组合数，简称为$r\cdot$-组合数或组合数，记为$C_{n}^{r}$或$C(n,r)$。  
显然， $r$ - 组合与 $r$ - 排列的区别在于 $r\cdot$ 组合不考虑组合中元素的排列次序， $r\cdot$ - 排列必须考 虑排列中各元素的排列次序。如果两个$r\cdot$-排列所含的元素完全相同，仅仅是排列次序不同，两个$r\cdot$-排列是同一个组合，由此得到有如下组合数计算公式：  
【定理1.15】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r-$组合数计算公式：  
$$
C(n,r)=\frac{P(n,r)}{r!}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r!}=\frac{n!}{r!(n-r)!}
$$",定理1.14给出了不重复$r\cdot$-圆排列数的计算公式。
定理1.15,描述,不重复组合,,"首先考察如下排列问题：  
某班有35 名同学，现从中选出15 名同学排成一排，问有多少种排列方式？  
这个问题有如下两个关键要点：第一、在排列中每位同学最多只能出现一次，也就是无重复性；第二、不同的次序构成不同的排列。由此得到如下不重复排列的概念：  
【定义1.21】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中依次取出$r$ 个不同元素并将其按取出的次序排成一排，由此形成的一个有序排列称之为不重复$r\cdot$-排列，简称为$r\cdot$-排列或排列，不重复$r\cdot$-排列的个数称为不重复$r\cdot$-排列数，简称为$r\cdot$-排列数或排列数，记为${P}_{n}^{r}$或$P(n,r)$。称$r=n$时构成的排列称为全排列，$r<n$时构成的排列为选排列。  
根据乘法原理，显然可以得到如下结论：  
【定理1.13】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r\cdot$-排列数计算公式：  
$P(n,r)=n(n-1)(n-2)\cdots(n-r+1)\ \ ={\frac{n!}{(n-r)!}}$ 其中：$n!=n(n-1)(n-2)\cdots2\cdot1$  
【定义1.22】假设$S$是由$n$ 个不同的元素组成的集合，从$S$ 中依次取出$r$ 个不同元素并将其按取出的次序排成一个圆圈，由此形成的一个有序圆排列称之为不重复$r\cdot$-圆排列，简称为$r\cdot$-圆排列或圆排列，不重复$r\cdot$圆排列的个数称为不重复$r\cdot$-圆排列数，简称为$r\cdot$-圆排列数或圆排列数，记为${\cal P}_{c}(n,r)$。  
相对于上述圆排列的概念，有时亦将$r\cdot$-排列称为$r$-线排列或线排列。由前面分析不难看出，如果将每个$r\cdot$-线排列的首尾相连构成一个$r\cdot$-圆排列，则由此构成的所有圆排列必然有$r$倍的重复数。故有如下$r\cdot$-圆排列计算公式：  
【定理1.14】对于任意给定的两个正整数$n$ 和$r$，且$r\leq n$，其$r\cdot$-圆排列数为$P_{c}(n,r)$：  
$$
P_{c}(n,r)=\frac{P(n,r)}{r}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r}=\frac{n!}{r(n-r)!}
$$  
以上例子的共有特点是所有选出的元素都有一定的次序。事实上，很多情况下并不需要选出的元素具有有次序。  
考察如下组合问题：  
某班有35 名同学，现从中任意选出15 名同学参加问卷活动，问有多少种选择方式？  
与前述$r$-排列问题不同的是，这个问题只考虑抽取的是哪15 名同学，并不考虑抽取次序以及与之相关的排列问题。由此得到如下不重复组合及相关组合数的概念：  
【定义1.23】假设$S$是由$n$ 个不同的元素组成的集合，从$S$中任意取出$r$ 个不同元素组成一个子集合，称每一个这样的子集合为一个不重复$r$-组合，简称为$r\cdot$-组合或组合，不重复$r$-组合的个数称为不重复$r\cdot$-组合数，简称为$r\cdot$-组合数或组合数，记为$C_{n}^{r}$或$C(n,r)$。  
显然， $r$ - 组合与 $r$ - 排列的区别在于 $r\cdot$ 组合不考虑组合中元素的排列次序， $r\cdot$ - 排列必须考 虑排列中各元素的排列次序。如果两个$r\cdot$-排列所含的元素完全相同，仅仅是排列次序不同，两个$r\cdot$-排列是同一个组合，由此得到有如下组合数计算公式：  
【定理1.15】对于任意两个正整数$n$ 和$r$，且$r\leq n$，成立如下$r-$组合数计算公式：  
$$
C(n,r)=\frac{P(n,r)}{r!}=\frac{n(n-1)(n-2)\cdots(n-r+1)}{r!}=\frac{n!}{r!(n-r)!}
$$",定理1.15给出了不重复$r$-组合数的计算公式。
重集,定义基础,可重复排列,,"现考察这样一个问题：用1、2、3 这3 个数字可以构成多少种不同的5 位数字？  
使用乘法原理不难知道该问题解为$\ 13^{5}=243$种。这显然是一个元素可以重复的排列问题，现具体讨论这类问题。我们知道，在经典集合论中，集合中元素是不可重复的。为解决集合中重复元素的表示问题，现引入重集的概念。与集合的概念一样，重集也是一个没有具体定义的原始概念，只有通过如下方式对其含义进行描述或理解：  
所谓重集，就是在指定范围内满足给定条件、且允许多个相同对象同时出现的所有对象构成的总体，重集中每个对象仍然称为该集合的元素，重集中相同元素的个数称为元素的重数。具体地说，如果一个重集中含有 $\cdot_{n_{1}}$ 个 $\cdot a_{1}$ ， $n_{2}$ 个 $a_{2}$ ， ⋯ ， $n_{m}$ 个 $a_{m}$ ，且 $n_{1}+n_{2}+\cdots+n_{m}=$ $n$，则称该重集为含有$n$个元素的$m$元重集，记为：$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}.$。  
约定：$\infty\cdot a$表示元素$a$可在重集中出现任意多次；$\{\infty\cdot a_{1},\infty\cdot a_{2},\cdots,\infty\cdot a_{m}\}$则表示重集中所有元素均可出现任意多次，称其为无穷重$\pmb{m}$ 元重集。  
事实上，可将$m$ 元重集看成是由$m$ 个容器组成的容器组，其中第一个容器可以放入（或取出）$n_{1}$个元素$a_{1}$，第二个容器可以放入（或取出）$n_{2}$个元素$a_{2}$，…，第$m$个容器可以放入（或取出）$n_{m}$个元素$a_{m}$.对于$\infty\cdot a$，则可将其理解为可以放入（或取出）无穷多个元素$a$的容器.需要注意的是，通常认为重集不是集合，但可将集合看成是重集的特例。  
显然，用1、2、3 这个数字构成5 位数字，就是一个无穷重3 元重集中取出5 个元素的排列问题。一般地，这种重集排列问题或可重复排列问题的定义如下：  
【定义1.24】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的重集，从该重集中依次取出$r$ 个元素并将其按取出的次序排成一排，由此形成的一个有序排列称之为可重复$r$-排列，可重复$r\mathbf{\cdot}$-排列的个数称为可重复$r$-排列数；令$\cdot n_{1}+n_{2}+\cdots n_{m}=n$，则称$\cdot r=n$时构成的排列称为全排列，$r<n$时构成的排列为选排列。  
通过乘法原理不难得到如下无穷重$m$ 元重集的可重复$r\mathbf{\cdot}$-排列数计算公式  
【定理1.16】假设$\{\infty\cdot a_{1},\infty\cdot a_{2},\cdots,\infty\cdot a_{m}\}$是任意一个给定的无穷重$m$ 元重集，该重集下可重复$r$-排列数为$m^{r}$。  
【证明】无穷重数$m$ 元重集$\{\infty\cdot a_{1}$，$\infty\cdot a_{2}$，⋯，$\infty\cdot a_{m}\}$ $r$-排列的每一个位置上，均有$m$  种选择方案，故而 $r$ - 排列数为 $\ \ \cdot m^{r}$ 。□  
【例题1.57】（1）用7 颗六彩珠串成长链，可串出多少种不同长链（假定六彩珠取之不尽，且不考虑链子的反转）？（2）至少用两种颜色的六彩珠串成7 珠环链，求环链的种数（假定六彩的珠子取之不尽，且不考虑链子的反转）？  
![](images/3f1e76f81dba91759e05f5e7aace97377518f23c7e8ea20e34523f4359261b28.jpg)
图1-8 4-圆排列  
有穷集$m$ 元重集上可重复$r\mathbf{\cdot}$-排列数的计算是一个比较复杂的问题，有兴趣的同学可以查阅相关资料，不再赘述。在此仅考虑如下比较简单的全排列数的计算问题：  
【定理1.17】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的含有$n$ 个元素的有限$m$元重集，从该重集中依次取出$n$ 个元素的全排列数为：  
$$
\frac{n!}{n_{1}!\cdot n_{2}!\cdot\dots\cdot n_{m}!}
$$  
【例题1.58】EXCELLENT 单词含有9 个字母，若重新排序字母顺序，请问能构成多少个不同字符串？",重集是可重复排列问题的基本概念，用于表示允许多个相同对象同时出现的集合
重集,应用对象,无穷重m元重集的可重复r-排列数计算公式,,"现考察这样一个问题：用1、2、3 这3 个数字可以构成多少种不同的5 位数字？  
使用乘法原理不难知道该问题解为$\ 13^{5}=243$种。这显然是一个元素可以重复的排列问题，现具体讨论这类问题。我们知道，在经典集合论中，集合中元素是不可重复的。为解决集合中重复元素的表示问题，现引入重集的概念。与集合的概念一样，重集也是一个没有具体定义的原始概念，只有通过如下方式对其含义进行描述或理解：  
所谓重集，就是在指定范围内满足给定条件、且允许多个相同对象同时出现的所有对象构成的总体，重集中每个对象仍然称为该集合的元素，重集中相同元素的个数称为元素的重数。具体地说，如果一个重集中含有 $\cdot_{n_{1}}$ 个 $\cdot a_{1}$ ， $n_{2}$ 个 $a_{2}$ ， ⋯ ， $n_{m}$ 个 $a_{m}$ ，且 $n_{1}+n_{2}+\cdots+n_{m}=$ $n$，则称该重集为含有$n$个元素的$m$元重集，记为：$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}.$。  
约定：$\infty\cdot a$表示元素$a$可在重集中出现任意多次；$\{\infty\cdot a_{1},\infty\cdot a_{2},\cdots,\infty\cdot a_{m}\}$则表示重集中所有元素均可出现任意多次，称其为无穷重$\pmb{m}$ 元重集。  
事实上，可将$m$ 元重集看成是由$m$ 个容器组成的容器组，其中第一个容器可以放入（或取出）$n_{1}$个元素$a_{1}$，第二个容器可以放入（或取出）$n_{2}$个元素$a_{2}$，…，第$m$个容器可以放入（或取出）$n_{m}$个元素$a_{m}$.对于$\infty\cdot a$，则可将其理解为可以放入（或取出）无穷多个元素$a$的容器.需要注意的是，通常认为重集不是集合，但可将集合看成是重集的特例。  
显然，用1、2、3 这个数字构成5 位数字，就是一个无穷重3 元重集中取出5 个元素的排列问题。一般地，这种重集排列问题或可重复排列问题的定义如下：  
【定义1.24】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的重集，从该重集中依次取出$r$ 个元素并将其按取出的次序排成一排，由此形成的一个有序排列称之为可重复$r$-排列，可重复$r\mathbf{\cdot}$-排列的个数称为可重复$r$-排列数；令$\cdot n_{1}+n_{2}+\cdots n_{m}=n$，则称$\cdot r=n$时构成的排列称为全排列，$r<n$时构成的排列为选排列。  
通过乘法原理不难得到如下无穷重$m$ 元重集的可重复$r\mathbf{\cdot}$-排列数计算公式  
【定理1.16】假设$\{\infty\cdot a_{1},\infty\cdot a_{2},\cdots,\infty\cdot a_{m}\}$是任意一个给定的无穷重$m$ 元重集，该重集下可重复$r$-排列数为$m^{r}$。  
【证明】无穷重数$m$ 元重集$\{\infty\cdot a_{1}$，$\infty\cdot a_{2}$，⋯，$\infty\cdot a_{m}\}$ $r$-排列的每一个位置上，均有$m$  种选择方案，故而 $r$ - 排列数为 $\ \ \cdot m^{r}$ 。□  
【例题1.57】（1）用7 颗六彩珠串成长链，可串出多少种不同长链（假定六彩珠取之不尽，且不考虑链子的反转）？（2）至少用两种颜色的六彩珠串成7 珠环链，求环链的种数（假定六彩的珠子取之不尽，且不考虑链子的反转）？  
![](images/3f1e76f81dba91759e05f5e7aace97377518f23c7e8ea20e34523f4359261b28.jpg)
图1-8 4-圆排列  
有穷集$m$ 元重集上可重复$r\mathbf{\cdot}$-排列数的计算是一个比较复杂的问题，有兴趣的同学可以查阅相关资料，不再赘述。在此仅考虑如下比较简单的全排列数的计算问题：  
【定理1.17】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的含有$n$ 个元素的有限$m$元重集，从该重集中依次取出$n$ 个元素的全排列数为：  
$$
\frac{n!}{n_{1}!\cdot n_{2}!\cdot\dots\cdot n_{m}!}
$$  
【例题1.58】EXCELLENT 单词含有9 个字母，若重新排序字母顺序，请问能构成多少个不同字符串？",无穷重m元重集的可重复r-排列数计算公式适用于重集中元素可无限重复的情况
重集,应用对象,有限m元重集的全排列数计算公式,,"现考察这样一个问题：用1、2、3 这3 个数字可以构成多少种不同的5 位数字？  
使用乘法原理不难知道该问题解为$\ 13^{5}=243$种。这显然是一个元素可以重复的排列问题，现具体讨论这类问题。我们知道，在经典集合论中，集合中元素是不可重复的。为解决集合中重复元素的表示问题，现引入重集的概念。与集合的概念一样，重集也是一个没有具体定义的原始概念，只有通过如下方式对其含义进行描述或理解：  
所谓重集，就是在指定范围内满足给定条件、且允许多个相同对象同时出现的所有对象构成的总体，重集中每个对象仍然称为该集合的元素，重集中相同元素的个数称为元素的重数。具体地说，如果一个重集中含有 $\cdot_{n_{1}}$ 个 $\cdot a_{1}$ ， $n_{2}$ 个 $a_{2}$ ， ⋯ ， $n_{m}$ 个 $a_{m}$ ，且 $n_{1}+n_{2}+\cdots+n_{m}=$ $n$，则称该重集为含有$n$个元素的$m$元重集，记为：$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}.$。  
约定：$\infty\cdot a$表示元素$a$可在重集中出现任意多次；$\{\infty\cdot a_{1},\infty\cdot a_{2},\cdots,\infty\cdot a_{m}\}$则表示重集中所有元素均可出现任意多次，称其为无穷重$\pmb{m}$ 元重集。  
事实上，可将$m$ 元重集看成是由$m$ 个容器组成的容器组，其中第一个容器可以放入（或取出）$n_{1}$个元素$a_{1}$，第二个容器可以放入（或取出）$n_{2}$个元素$a_{2}$，…，第$m$个容器可以放入（或取出）$n_{m}$个元素$a_{m}$.对于$\infty\cdot a$，则可将其理解为可以放入（或取出）无穷多个元素$a$的容器.需要注意的是，通常认为重集不是集合，但可将集合看成是重集的特例。  
显然，用1、2、3 这个数字构成5 位数字，就是一个无穷重3 元重集中取出5 个元素的排列问题。一般地，这种重集排列问题或可重复排列问题的定义如下：  
【定义1.24】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的重集，从该重集中依次取出$r$ 个元素并将其按取出的次序排成一排，由此形成的一个有序排列称之为可重复$r$-排列，可重复$r\mathbf{\cdot}$-排列的个数称为可重复$r$-排列数；令$\cdot n_{1}+n_{2}+\cdots n_{m}=n$，则称$\cdot r=n$时构成的排列称为全排列，$r<n$时构成的排列为选排列。  
通过乘法原理不难得到如下无穷重$m$ 元重集的可重复$r\mathbf{\cdot}$-排列数计算公式  
【定理1.16】假设$\{\infty\cdot a_{1},\infty\cdot a_{2},\cdots,\infty\cdot a_{m}\}$是任意一个给定的无穷重$m$ 元重集，该重集下可重复$r$-排列数为$m^{r}$。  
【证明】无穷重数$m$ 元重集$\{\infty\cdot a_{1}$，$\infty\cdot a_{2}$，⋯，$\infty\cdot a_{m}\}$ $r$-排列的每一个位置上，均有$m$  种选择方案，故而 $r$ - 排列数为 $\ \ \cdot m^{r}$ 。□  
【例题1.57】（1）用7 颗六彩珠串成长链，可串出多少种不同长链（假定六彩珠取之不尽，且不考虑链子的反转）？（2）至少用两种颜色的六彩珠串成7 珠环链，求环链的种数（假定六彩的珠子取之不尽，且不考虑链子的反转）？  
![](images/3f1e76f81dba91759e05f5e7aace97377518f23c7e8ea20e34523f4359261b28.jpg)
图1-8 4-圆排列  
有穷集$m$ 元重集上可重复$r\mathbf{\cdot}$-排列数的计算是一个比较复杂的问题，有兴趣的同学可以查阅相关资料，不再赘述。在此仅考虑如下比较简单的全排列数的计算问题：  
【定理1.17】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的含有$n$ 个元素的有限$m$元重集，从该重集中依次取出$n$ 个元素的全排列数为：  
$$
\frac{n!}{n_{1}!\cdot n_{2}!\cdot\dots\cdot n_{m}!}
$$  
【例题1.58】EXCELLENT 单词含有9 个字母，若重新排序字母顺序，请问能构成多少个不同字符串？",有限m元重集的全排列数计算公式适用于重集中元素数量有限的情况
可重复排列,计算方法,无穷重m元重集的可重复r-排列数计算公式,,"现考察这样一个问题：用1、2、3 这3 个数字可以构成多少种不同的5 位数字？  
使用乘法原理不难知道该问题解为$\ 13^{5}=243$种。这显然是一个元素可以重复的排列问题，现具体讨论这类问题。我们知道，在经典集合论中，集合中元素是不可重复的。为解决集合中重复元素的表示问题，现引入重集的概念。与集合的概念一样，重集也是一个没有具体定义的原始概念，只有通过如下方式对其含义进行描述或理解：  
所谓重集，就是在指定范围内满足给定条件、且允许多个相同对象同时出现的所有对象构成的总体，重集中每个对象仍然称为该集合的元素，重集中相同元素的个数称为元素的重数。具体地说，如果一个重集中含有 $\cdot_{n_{1}}$ 个 $\cdot a_{1}$ ， $n_{2}$ 个 $a_{2}$ ， ⋯ ， $n_{m}$ 个 $a_{m}$ ，且 $n_{1}+n_{2}+\cdots+n_{m}=$ $n$，则称该重集为含有$n$个元素的$m$元重集，记为：$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}.$。  
约定：$\infty\cdot a$表示元素$a$可在重集中出现任意多次；$\{\infty\cdot a_{1},\infty\cdot a_{2},\cdots,\infty\cdot a_{m}\}$则表示重集中所有元素均可出现任意多次，称其为无穷重$\pmb{m}$ 元重集。  
事实上，可将$m$ 元重集看成是由$m$ 个容器组成的容器组，其中第一个容器可以放入（或取出）$n_{1}$个元素$a_{1}$，第二个容器可以放入（或取出）$n_{2}$个元素$a_{2}$，…，第$m$个容器可以放入（或取出）$n_{m}$个元素$a_{m}$.对于$\infty\cdot a$，则可将其理解为可以放入（或取出）无穷多个元素$a$的容器.需要注意的是，通常认为重集不是集合，但可将集合看成是重集的特例。  
显然，用1、2、3 这个数字构成5 位数字，就是一个无穷重3 元重集中取出5 个元素的排列问题。一般地，这种重集排列问题或可重复排列问题的定义如下：  
【定义1.24】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的重集，从该重集中依次取出$r$ 个元素并将其按取出的次序排成一排，由此形成的一个有序排列称之为可重复$r$-排列，可重复$r\mathbf{\cdot}$-排列的个数称为可重复$r$-排列数；令$\cdot n_{1}+n_{2}+\cdots n_{m}=n$，则称$\cdot r=n$时构成的排列称为全排列，$r<n$时构成的排列为选排列。  
通过乘法原理不难得到如下无穷重$m$ 元重集的可重复$r\mathbf{\cdot}$-排列数计算公式  
【定理1.16】假设$\{\infty\cdot a_{1},\infty\cdot a_{2},\cdots,\infty\cdot a_{m}\}$是任意一个给定的无穷重$m$ 元重集，该重集下可重复$r$-排列数为$m^{r}$。  
【证明】无穷重数$m$ 元重集$\{\infty\cdot a_{1}$，$\infty\cdot a_{2}$，⋯，$\infty\cdot a_{m}\}$ $r$-排列的每一个位置上，均有$m$  种选择方案，故而 $r$ - 排列数为 $\ \ \cdot m^{r}$ 。□  
【例题1.57】（1）用7 颗六彩珠串成长链，可串出多少种不同长链（假定六彩珠取之不尽，且不考虑链子的反转）？（2）至少用两种颜色的六彩珠串成7 珠环链，求环链的种数（假定六彩的珠子取之不尽，且不考虑链子的反转）？  
![](images/3f1e76f81dba91759e05f5e7aace97377518f23c7e8ea20e34523f4359261b28.jpg)
图1-8 4-圆排列  
有穷集$m$ 元重集上可重复$r\mathbf{\cdot}$-排列数的计算是一个比较复杂的问题，有兴趣的同学可以查阅相关资料，不再赘述。在此仅考虑如下比较简单的全排列数的计算问题：  
【定理1.17】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的含有$n$ 个元素的有限$m$元重集，从该重集中依次取出$n$ 个元素的全排列数为：  
$$
\frac{n!}{n_{1}!\cdot n_{2}!\cdot\dots\cdot n_{m}!}
$$  
【例题1.58】EXCELLENT 单词含有9 个字母，若重新排序字母顺序，请问能构成多少个不同字符串？",无穷重m元重集的可重复r-排列数计算公式提供了可重复排列问题的具体计算方法
可重复排列,计算方法,有限m元重集的全排列数计算公式,,"现考察这样一个问题：用1、2、3 这3 个数字可以构成多少种不同的5 位数字？  
使用乘法原理不难知道该问题解为$\ 13^{5}=243$种。这显然是一个元素可以重复的排列问题，现具体讨论这类问题。我们知道，在经典集合论中，集合中元素是不可重复的。为解决集合中重复元素的表示问题，现引入重集的概念。与集合的概念一样，重集也是一个没有具体定义的原始概念，只有通过如下方式对其含义进行描述或理解：  
所谓重集，就是在指定范围内满足给定条件、且允许多个相同对象同时出现的所有对象构成的总体，重集中每个对象仍然称为该集合的元素，重集中相同元素的个数称为元素的重数。具体地说，如果一个重集中含有 $\cdot_{n_{1}}$ 个 $\cdot a_{1}$ ， $n_{2}$ 个 $a_{2}$ ， ⋯ ， $n_{m}$ 个 $a_{m}$ ，且 $n_{1}+n_{2}+\cdots+n_{m}=$ $n$，则称该重集为含有$n$个元素的$m$元重集，记为：$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}.$。  
约定：$\infty\cdot a$表示元素$a$可在重集中出现任意多次；$\{\infty\cdot a_{1},\infty\cdot a_{2},\cdots,\infty\cdot a_{m}\}$则表示重集中所有元素均可出现任意多次，称其为无穷重$\pmb{m}$ 元重集。  
事实上，可将$m$ 元重集看成是由$m$ 个容器组成的容器组，其中第一个容器可以放入（或取出）$n_{1}$个元素$a_{1}$，第二个容器可以放入（或取出）$n_{2}$个元素$a_{2}$，…，第$m$个容器可以放入（或取出）$n_{m}$个元素$a_{m}$.对于$\infty\cdot a$，则可将其理解为可以放入（或取出）无穷多个元素$a$的容器.需要注意的是，通常认为重集不是集合，但可将集合看成是重集的特例。  
显然，用1、2、3 这个数字构成5 位数字，就是一个无穷重3 元重集中取出5 个元素的排列问题。一般地，这种重集排列问题或可重复排列问题的定义如下：  
【定义1.24】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的重集，从该重集中依次取出$r$ 个元素并将其按取出的次序排成一排，由此形成的一个有序排列称之为可重复$r$-排列，可重复$r\mathbf{\cdot}$-排列的个数称为可重复$r$-排列数；令$\cdot n_{1}+n_{2}+\cdots n_{m}=n$，则称$\cdot r=n$时构成的排列称为全排列，$r<n$时构成的排列为选排列。  
通过乘法原理不难得到如下无穷重$m$ 元重集的可重复$r\mathbf{\cdot}$-排列数计算公式  
【定理1.16】假设$\{\infty\cdot a_{1},\infty\cdot a_{2},\cdots,\infty\cdot a_{m}\}$是任意一个给定的无穷重$m$ 元重集，该重集下可重复$r$-排列数为$m^{r}$。  
【证明】无穷重数$m$ 元重集$\{\infty\cdot a_{1}$，$\infty\cdot a_{2}$，⋯，$\infty\cdot a_{m}\}$ $r$-排列的每一个位置上，均有$m$  种选择方案，故而 $r$ - 排列数为 $\ \ \cdot m^{r}$ 。□  
【例题1.57】（1）用7 颗六彩珠串成长链，可串出多少种不同长链（假定六彩珠取之不尽，且不考虑链子的反转）？（2）至少用两种颜色的六彩珠串成7 珠环链，求环链的种数（假定六彩的珠子取之不尽，且不考虑链子的反转）？  
![](images/3f1e76f81dba91759e05f5e7aace97377518f23c7e8ea20e34523f4359261b28.jpg)
图1-8 4-圆排列  
有穷集$m$ 元重集上可重复$r\mathbf{\cdot}$-排列数的计算是一个比较复杂的问题，有兴趣的同学可以查阅相关资料，不再赘述。在此仅考虑如下比较简单的全排列数的计算问题：  
【定理1.17】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的含有$n$ 个元素的有限$m$元重集，从该重集中依次取出$n$ 个元素的全排列数为：  
$$
\frac{n!}{n_{1}!\cdot n_{2}!\cdot\dots\cdot n_{m}!}
$$  
【例题1.58】EXCELLENT 单词含有9 个字母，若重新排序字母顺序，请问能构成多少个不同字符串？",有限m元重集的全排列数计算公式提供了有限重集全排列问题的具体计算方法
可重复的组合,包含,可重复r-组合,,"考察如下可重复的组合问题：从包含苹果、橙子和梨子的筐中任取4 个水果招待客人，假设筐中苹果、橙子和梨子的个数均多于4 个且不关心取水果的次序，问有多少种取法？  
可对这4 个水果的取法做如下枚举：  
4 个苹果；4 个橙子；4 个梨子；3 个苹果，1 个橙子；3 个苹果，1 个梨子；3 个橙子，1 个苹果；3 个橙子，1 个梨子；3 个梨子，1 个苹果；3 个梨子，1 个橙子；2 个橙子，2 个苹果；2 个橙子，2 个梨子；2 个梨子，2 个苹果；2 个橙子，1 个苹果，1 个梨子；2 个苹果，1 个梨子，1 个橙子；2 个梨子，1 个苹果，1 个橙子。  
由此可知取法一共有15 种。当水果种类或取出数目比较大时，这种枚举方法显然是不可行的。在这个问题中，可以将包含苹果、橙子和梨子的筐子分别看成是一个重集。由于不考虑取水果的次序，因此可将该问题看成是一种基于重集的可重复的组合数计算问题。  
下面具体介绍可重复的组合数计算问题的相关概念及解法。  
【定义1.25】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的重集，从该重集中任意取出$r$ 个元素组成一个子重集，称每一个这样的子重集为一个可重复$r\cdot$-组合，可重复$r\cdot$组合的个数称为可重复$r$-组合数。  
下面结合一个具体实例详细介绍可重复$r\cdot$-组合数的计算问题。  
【定理1.18】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的$m$ 元重集，且重集中每个元素的从数均不小于 $r$ ，则基于该重集的可重复 $r\cdot$ - 组合数为 $C(m-1+r,\ r)$ 。",可重复的组合问题中包含可重复r-组合的概念
可重复r-组合,定义,可重复r-组合数,,"考察如下可重复的组合问题：从包含苹果、橙子和梨子的筐中任取4 个水果招待客人，假设筐中苹果、橙子和梨子的个数均多于4 个且不关心取水果的次序，问有多少种取法？  
可对这4 个水果的取法做如下枚举：  
4 个苹果；4 个橙子；4 个梨子；3 个苹果，1 个橙子；3 个苹果，1 个梨子；3 个橙子，1 个苹果；3 个橙子，1 个梨子；3 个梨子，1 个苹果；3 个梨子，1 个橙子；2 个橙子，2 个苹果；2 个橙子，2 个梨子；2 个梨子，2 个苹果；2 个橙子，1 个苹果，1 个梨子；2 个苹果，1 个梨子，1 个橙子；2 个梨子，1 个苹果，1 个橙子。  
由此可知取法一共有15 种。当水果种类或取出数目比较大时，这种枚举方法显然是不可行的。在这个问题中，可以将包含苹果、橙子和梨子的筐子分别看成是一个重集。由于不考虑取水果的次序，因此可将该问题看成是一种基于重集的可重复的组合数计算问题。  
下面具体介绍可重复的组合数计算问题的相关概念及解法。  
【定义1.25】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的重集，从该重集中任意取出$r$ 个元素组成一个子重集，称每一个这样的子重集为一个可重复$r\cdot$-组合，可重复$r\cdot$组合的个数称为可重复$r$-组合数。  
下面结合一个具体实例详细介绍可重复$r\cdot$-组合数的计算问题。  
【定理1.18】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的$m$ 元重集，且重集中每个元素的从数均不小于 $r$ ，则基于该重集的可重复 $r\cdot$ - 组合数为 $C(m-1+r,\ r)$ 。",可重复r-组合的个数称为可重复r-组合数
定理1.18,计算,可重复r-组合数,,"考察如下可重复的组合问题：从包含苹果、橙子和梨子的筐中任取4 个水果招待客人，假设筐中苹果、橙子和梨子的个数均多于4 个且不关心取水果的次序，问有多少种取法？  
可对这4 个水果的取法做如下枚举：  
4 个苹果；4 个橙子；4 个梨子；3 个苹果，1 个橙子；3 个苹果，1 个梨子；3 个橙子，1 个苹果；3 个橙子，1 个梨子；3 个梨子，1 个苹果；3 个梨子，1 个橙子；2 个橙子，2 个苹果；2 个橙子，2 个梨子；2 个梨子，2 个苹果；2 个橙子，1 个苹果，1 个梨子；2 个苹果，1 个梨子，1 个橙子；2 个梨子，1 个苹果，1 个橙子。  
由此可知取法一共有15 种。当水果种类或取出数目比较大时，这种枚举方法显然是不可行的。在这个问题中，可以将包含苹果、橙子和梨子的筐子分别看成是一个重集。由于不考虑取水果的次序，因此可将该问题看成是一种基于重集的可重复的组合数计算问题。  
下面具体介绍可重复的组合数计算问题的相关概念及解法。  
【定义1.25】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的重集，从该重集中任意取出$r$ 个元素组成一个子重集，称每一个这样的子重集为一个可重复$r\cdot$-组合，可重复$r\cdot$组合的个数称为可重复$r$-组合数。  
下面结合一个具体实例详细介绍可重复$r\cdot$-组合数的计算问题。  
【定理1.18】假设$\{n_{1}\cdot a_{1},n_{2}\cdot a_{2},\cdots,n_{m}\cdot a_{m}\}$是任意一个给定的$m$ 元重集，且重集中每个元素的从数均不小于 $r$ ，则基于该重集的可重复 $r\cdot$ - 组合数为 $C(m-1+r,\ r)$ 。",定理1.18提供了计算可重复r-组合数的方法
递推关系计数法,包含于,递推关系求解技术,,前述基本计数技术主要基于静态思维，即认为求解问题处在一个相对静止状态，通过一些静态方法将这些状态的相关数量计算出来。如果求解问题在本质上具有动态演化性质，或者问题比较复杂必须考察其演变历史，对这类问题的计数必须考察问题状态的演变过程和规律，此时基于静态思维的基本计数技术就不能满足要求。本节介绍基于动态演化思想的高级计数技术，主要包括递推关系计数法、递推关系求解技术、生成函数计数法。,递推关系计数法是递推关系求解技术的一部分
递推关系计数法,并列,生成函数计数法,,前述基本计数技术主要基于静态思维，即认为求解问题处在一个相对静止状态，通过一些静态方法将这些状态的相关数量计算出来。如果求解问题在本质上具有动态演化性质，或者问题比较复杂必须考察其演变历史，对这类问题的计数必须考察问题状态的演变过程和规律，此时基于静态思维的基本计数技术就不能满足要求。本节介绍基于动态演化思想的高级计数技术，主要包括递推关系计数法、递推关系求解技术、生成函数计数法。,递推关系计数法与生成函数计数法都是高级计数技术的一部分
递推关系求解技术,并列,生成函数计数法,,前述基本计数技术主要基于静态思维，即认为求解问题处在一个相对静止状态，通过一些静态方法将这些状态的相关数量计算出来。如果求解问题在本质上具有动态演化性质，或者问题比较复杂必须考察其演变历史，对这类问题的计数必须考察问题状态的演变过程和规律，此时基于静态思维的基本计数技术就不能满足要求。本节介绍基于动态演化思想的高级计数技术，主要包括递推关系计数法、递推关系求解技术、生成函数计数法。,递推关系求解技术与生成函数计数法都是高级计数技术的一部分
递推关系,描述,数列,,"我们都学过数列知识，对于一个通项为$a_{n}$的数列$\left\{a_{n}\right\}$，其取值随着下标$n$ 变化而变化，表达的是一个动态演变过程。在很多情况下很难直接得到$a_{n}$的具体表达式，难以直接考察数列的动态演变过程。此时，为揭示数列中各项的动态演变规律，我们通常考察通项$a_{n}$与其前若干项之间的联系，或者说在通项与其前若干项之间建立一种确定的计算表达式，明确给出通项的具体构造过程，实现对动态过程的建模。由此得到如下递推关系的概念：  
【定义1.26】假设$\left\{a_{n}\right\}$是任一通项为$a_{n}$的数列，如果$a_{n}$可由其前若干项计算出来，则称该计算表达式为一个递推公式或递推关系式。为使递推公式能够进行递推计算，通常需要确定公式中一个或多个初始项的值，称这些初始项的值为递推公式的初值。如果一个数列的各项都满足递推关系，则称该数列为该递推关系的一个特解。  
例如，等差数列和等比数列都可用递推公式表示：对于公差为$d$的等差数列$\left\{a_{n}\right\}$，其递  
推公式为：$a_{n}=a_{n-1}+d$；公比$q$的等比数列$\left\{b_{n}\right\}$，其递推公式为$b_{n}=b_{n-1}q$。  
递推关系是求解组合计算问题的重要工具，在几乎所有的数学分支中都有着十分重要的作用。要使用递推关系解决有限集合的计数问题，首先必须针对求解问题演化规律建立相应的递推关系式，然后以递推关系式作为基本工具逐步实现对有限集合的计数。",递推关系用于描述数列中通项与其前若干项之间的计算表达式，揭示数列的动态演变规律
递推关系,等价,递推公式,,"我们都学过数列知识，对于一个通项为$a_{n}$的数列$\left\{a_{n}\right\}$，其取值随着下标$n$ 变化而变化，表达的是一个动态演变过程。在很多情况下很难直接得到$a_{n}$的具体表达式，难以直接考察数列的动态演变过程。此时，为揭示数列中各项的动态演变规律，我们通常考察通项$a_{n}$与其前若干项之间的联系，或者说在通项与其前若干项之间建立一种确定的计算表达式，明确给出通项的具体构造过程，实现对动态过程的建模。由此得到如下递推关系的概念：  
【定义1.26】假设$\left\{a_{n}\right\}$是任一通项为$a_{n}$的数列，如果$a_{n}$可由其前若干项计算出来，则称该计算表达式为一个递推公式或递推关系式。为使递推公式能够进行递推计算，通常需要确定公式中一个或多个初始项的值，称这些初始项的值为递推公式的初值。如果一个数列的各项都满足递推关系，则称该数列为该递推关系的一个特解。  
例如，等差数列和等比数列都可用递推公式表示：对于公差为$d$的等差数列$\left\{a_{n}\right\}$，其递  
推公式为：$a_{n}=a_{n-1}+d$；公比$q$的等比数列$\left\{b_{n}\right\}$，其递推公式为$b_{n}=b_{n-1}q$。  
递推关系是求解组合计算问题的重要工具，在几乎所有的数学分支中都有着十分重要的作用。要使用递推关系解决有限集合的计数问题，首先必须针对求解问题演化规律建立相应的递推关系式，然后以递推关系式作为基本工具逐步实现对有限集合的计数。",递推关系也称为递推公式，用于计算数列的通项
递推关系,依赖,初值,,"我们都学过数列知识，对于一个通项为$a_{n}$的数列$\left\{a_{n}\right\}$，其取值随着下标$n$ 变化而变化，表达的是一个动态演变过程。在很多情况下很难直接得到$a_{n}$的具体表达式，难以直接考察数列的动态演变过程。此时，为揭示数列中各项的动态演变规律，我们通常考察通项$a_{n}$与其前若干项之间的联系，或者说在通项与其前若干项之间建立一种确定的计算表达式，明确给出通项的具体构造过程，实现对动态过程的建模。由此得到如下递推关系的概念：  
【定义1.26】假设$\left\{a_{n}\right\}$是任一通项为$a_{n}$的数列，如果$a_{n}$可由其前若干项计算出来，则称该计算表达式为一个递推公式或递推关系式。为使递推公式能够进行递推计算，通常需要确定公式中一个或多个初始项的值，称这些初始项的值为递推公式的初值。如果一个数列的各项都满足递推关系，则称该数列为该递推关系的一个特解。  
例如，等差数列和等比数列都可用递推公式表示：对于公差为$d$的等差数列$\left\{a_{n}\right\}$，其递  
推公式为：$a_{n}=a_{n-1}+d$；公比$q$的等比数列$\left\{b_{n}\right\}$，其递推公式为$b_{n}=b_{n-1}q$。  
递推关系是求解组合计算问题的重要工具，在几乎所有的数学分支中都有着十分重要的作用。要使用递推关系解决有限集合的计数问题，首先必须针对求解问题演化规律建立相应的递推关系式，然后以递推关系式作为基本工具逐步实现对有限集合的计数。",递推关系的计算需要确定一个或多个初始项的值作为初值
递推关系,定义,特解,,"我们都学过数列知识，对于一个通项为$a_{n}$的数列$\left\{a_{n}\right\}$，其取值随着下标$n$ 变化而变化，表达的是一个动态演变过程。在很多情况下很难直接得到$a_{n}$的具体表达式，难以直接考察数列的动态演变过程。此时，为揭示数列中各项的动态演变规律，我们通常考察通项$a_{n}$与其前若干项之间的联系，或者说在通项与其前若干项之间建立一种确定的计算表达式，明确给出通项的具体构造过程，实现对动态过程的建模。由此得到如下递推关系的概念：  
【定义1.26】假设$\left\{a_{n}\right\}$是任一通项为$a_{n}$的数列，如果$a_{n}$可由其前若干项计算出来，则称该计算表达式为一个递推公式或递推关系式。为使递推公式能够进行递推计算，通常需要确定公式中一个或多个初始项的值，称这些初始项的值为递推公式的初值。如果一个数列的各项都满足递推关系，则称该数列为该递推关系的一个特解。  
例如，等差数列和等比数列都可用递推公式表示：对于公差为$d$的等差数列$\left\{a_{n}\right\}$，其递  
推公式为：$a_{n}=a_{n-1}+d$；公比$q$的等比数列$\left\{b_{n}\right\}$，其递推公式为$b_{n}=b_{n-1}q$。  
递推关系是求解组合计算问题的重要工具，在几乎所有的数学分支中都有着十分重要的作用。要使用递推关系解决有限集合的计数问题，首先必须针对求解问题演化规律建立相应的递推关系式，然后以递推关系式作为基本工具逐步实现对有限集合的计数。",满足递推关系的数列称为该递推关系的一个特解
递推关系,应用,组合计算问题,,"我们都学过数列知识，对于一个通项为$a_{n}$的数列$\left\{a_{n}\right\}$，其取值随着下标$n$ 变化而变化，表达的是一个动态演变过程。在很多情况下很难直接得到$a_{n}$的具体表达式，难以直接考察数列的动态演变过程。此时，为揭示数列中各项的动态演变规律，我们通常考察通项$a_{n}$与其前若干项之间的联系，或者说在通项与其前若干项之间建立一种确定的计算表达式，明确给出通项的具体构造过程，实现对动态过程的建模。由此得到如下递推关系的概念：  
【定义1.26】假设$\left\{a_{n}\right\}$是任一通项为$a_{n}$的数列，如果$a_{n}$可由其前若干项计算出来，则称该计算表达式为一个递推公式或递推关系式。为使递推公式能够进行递推计算，通常需要确定公式中一个或多个初始项的值，称这些初始项的值为递推公式的初值。如果一个数列的各项都满足递推关系，则称该数列为该递推关系的一个特解。  
例如，等差数列和等比数列都可用递推公式表示：对于公差为$d$的等差数列$\left\{a_{n}\right\}$，其递  
推公式为：$a_{n}=a_{n-1}+d$；公比$q$的等比数列$\left\{b_{n}\right\}$，其递推公式为$b_{n}=b_{n-1}q$。  
递推关系是求解组合计算问题的重要工具，在几乎所有的数学分支中都有着十分重要的作用。要使用递推关系解决有限集合的计数问题，首先必须针对求解问题演化规律建立相应的递推关系式，然后以递推关系式作为基本工具逐步实现对有限集合的计数。",递推关系是求解组合计算问题的重要工具
递推关系,重要性,数学分支,,"我们都学过数列知识，对于一个通项为$a_{n}$的数列$\left\{a_{n}\right\}$，其取值随着下标$n$ 变化而变化，表达的是一个动态演变过程。在很多情况下很难直接得到$a_{n}$的具体表达式，难以直接考察数列的动态演变过程。此时，为揭示数列中各项的动态演变规律，我们通常考察通项$a_{n}$与其前若干项之间的联系，或者说在通项与其前若干项之间建立一种确定的计算表达式，明确给出通项的具体构造过程，实现对动态过程的建模。由此得到如下递推关系的概念：  
【定义1.26】假设$\left\{a_{n}\right\}$是任一通项为$a_{n}$的数列，如果$a_{n}$可由其前若干项计算出来，则称该计算表达式为一个递推公式或递推关系式。为使递推公式能够进行递推计算，通常需要确定公式中一个或多个初始项的值，称这些初始项的值为递推公式的初值。如果一个数列的各项都满足递推关系，则称该数列为该递推关系的一个特解。  
例如，等差数列和等比数列都可用递推公式表示：对于公差为$d$的等差数列$\left\{a_{n}\right\}$，其递  
推公式为：$a_{n}=a_{n-1}+d$；公比$q$的等比数列$\left\{b_{n}\right\}$，其递推公式为$b_{n}=b_{n-1}q$。  
递推关系是求解组合计算问题的重要工具，在几乎所有的数学分支中都有着十分重要的作用。要使用递推关系解决有限集合的计数问题，首先必须针对求解问题演化规律建立相应的递推关系式，然后以递推关系式作为基本工具逐步实现对有限集合的计数。",递推关系在几乎所有的数学分支中都有着十分重要的作用
递推关系,方法,有限集合的计数问题,,"我们都学过数列知识，对于一个通项为$a_{n}$的数列$\left\{a_{n}\right\}$，其取值随着下标$n$ 变化而变化，表达的是一个动态演变过程。在很多情况下很难直接得到$a_{n}$的具体表达式，难以直接考察数列的动态演变过程。此时，为揭示数列中各项的动态演变规律，我们通常考察通项$a_{n}$与其前若干项之间的联系，或者说在通项与其前若干项之间建立一种确定的计算表达式，明确给出通项的具体构造过程，实现对动态过程的建模。由此得到如下递推关系的概念：  
【定义1.26】假设$\left\{a_{n}\right\}$是任一通项为$a_{n}$的数列，如果$a_{n}$可由其前若干项计算出来，则称该计算表达式为一个递推公式或递推关系式。为使递推公式能够进行递推计算，通常需要确定公式中一个或多个初始项的值，称这些初始项的值为递推公式的初值。如果一个数列的各项都满足递推关系，则称该数列为该递推关系的一个特解。  
例如，等差数列和等比数列都可用递推公式表示：对于公差为$d$的等差数列$\left\{a_{n}\right\}$，其递  
推公式为：$a_{n}=a_{n-1}+d$；公比$q$的等比数列$\left\{b_{n}\right\}$，其递推公式为$b_{n}=b_{n-1}q$。  
递推关系是求解组合计算问题的重要工具，在几乎所有的数学分支中都有着十分重要的作用。要使用递推关系解决有限集合的计数问题，首先必须针对求解问题演化规律建立相应的递推关系式，然后以递推关系式作为基本工具逐步实现对有限集合的计数。",使用递推关系解决有限集合的计数问题需要建立相应的递推关系式
递推关系,应用,迭代求解法,,"递推关系是复杂问题和动态问题求解重要工具，要使递推关系在问题求解中发挥作用特别是在计数问题中发挥作用，有时需要实现对递推关系式的求解，也就是说要找到满足递推公式的所有数列或部分数列的显示通项表达式。对递推关系式的求解是一个非常复杂的数学问题，属于离散数学及相关学科的前沿研究课题，有兴趣的读者可以查阅相关资料做进一步深入研究。作为抛砖引玉，我们仅介绍其中两种最常用的基本解法，即针对简单递推关系的迭代求解方法和针对常系数齐次线性递推关系的特征根求解方法。  
迭代求解法是一种最基本的解法，该方法主要用于求解一些比较简单的递推关系式，由如下两个基本步骤构成：  
第一、利用递推关系式对其右边的表达式进行迭代，并推测通项的显示表达式；  
第二、用数学归纳法证明得到的公式。  
目前还没有一个一般性的方法或公式能够实现对任意递推关系式的求解，通常需要针对对递推关系式的具体特点给出相应的求解方法。常系数齐次线性递推关系是一种特殊的递推关系，针对这类递推关系有一套完备可行的求解理论和方法。这套求解理论和方法是求解其它递推关系式的基础，因为很多其它递推关系式都是通过设法将其转化为某种常系数齐次线性递推关系的途径实现求解。下面给出常系数齐次线性递推关系的定义：  
【定义1.27】设$a_{1}$，$a_{2}$，⋯，$a_{k}$是$k$个常数且$a_{k}\neq0$，则下列递推关系：  
$$
u_{n}=a_{1}u_{n-1}+a_{2}u_{n-2}+\cdots+a_{k}u_{n-k}(n\geq k)
$$  
称为$k$阶常系数线性齐次递推关系。  
如果数列 $\{b_{n}\}_{n\geq0}$ 满足 $.b_{n}=a_{1}b_{n-1}+a_{2}b_{n-2}+\cdots+a_{k}b_{n-k}(n\geq k)$ ，则称数列 $\{b_{n}\}_{n\geq O}$ 或 $u_{n}=b_{n}{\big(}n=0,~1,~2,~\cdots{\big)}$是递推关系式(1 −17)的一个解。  
问题：递推关系式(1 −17)有没有解？如果有解，有多少个解？如何求解？下面的定理表明常系数齐次线性递推关系在满足初始条件的情况下有唯一解：  
【定理1.19】任意给出$k$个常数$b_{0}\,,\;\;b_{1}\,,\;\;\cdots\,,\;\;b_{k-1}$，有且仅有唯一一个数列是递推关系式 (1 −17) 满足初始条件 $v_{0}=b_{0}$ ， $v_{1}=b_{1}$ ， ⋯ ， $v_{k-1}=b_{k-1}$ 的解。  
对于常系数齐次线性递推关系的求解，基本思路是采用一种所谓特征根的方法，通过引入特征方程和特征根的概念，巧妙地将递推关系的求解问题转化为求代数方程根的求解问题。为此，我们引入如下特征方程和特征根的定义：  
【定义1.27】如下方程：  
$$
x^{k}-a_{1}x^{k-1}-a_{2}x^{k-2}-\cdots-a_{k-1}x-a_{k}=0
$$  
称为递推关系式(1 −17)的特征方程，它的根称为递推关系式(1 −17)的特征根。  
因为$a_{k}\neq0$，所以0 不是递推关系式(1 −17)的特征根。 下面的定理非常关键，它给出了特征根与常系数齐次线性递推关系解之间的联系：  
【定理1.20】设$q$ 是非0 复数，则$u_{n}=q^{n}$是递推关系式(1 −17)的一个解当且仅当$q$是递推关系式(1 −17)的一个特征根。  
下面定理给出了常系数齐次线性递推关系解的结构特点：  
【定理1.21】设$\cdot u_{n}=g_{i}(n)(i=1,2,\cdots,s)$均为递推关系式(1 −17)的解，$c_{i}(i=1,\!2,\cdots,s)$为任意常数，则有：  
$$
=\sum_{i=1}^{s}c_{i}g_{i}(n)
$$  
也是递推关系式(1 −17)的解。  
【定理1.22】如果递推关系式(1 −17)的$k$ 个特征根$q_{1}\,,\;\;q_{2}\,,\;\;\cdots\,,\;\;q_{k}$彼此相异，则  
$$
u_{n}=c_{1}q_{1}^{n}+c_{2}q_{2}^{n}+\cdots+c_{k}q_{k}^{n}
$$  
是递推关系式(1 −17)的通解。其中$c_{1}\,,\;\;c_{2}\,,\;\;\cdots\,,\;\;c_{k}$为任意常数。",迭代求解法用于求解简单的递推关系式
递推关系,特化,常系数齐次线性递推关系,,"递推关系是复杂问题和动态问题求解重要工具，要使递推关系在问题求解中发挥作用特别是在计数问题中发挥作用，有时需要实现对递推关系式的求解，也就是说要找到满足递推公式的所有数列或部分数列的显示通项表达式。对递推关系式的求解是一个非常复杂的数学问题，属于离散数学及相关学科的前沿研究课题，有兴趣的读者可以查阅相关资料做进一步深入研究。作为抛砖引玉，我们仅介绍其中两种最常用的基本解法，即针对简单递推关系的迭代求解方法和针对常系数齐次线性递推关系的特征根求解方法。  
迭代求解法是一种最基本的解法，该方法主要用于求解一些比较简单的递推关系式，由如下两个基本步骤构成：  
第一、利用递推关系式对其右边的表达式进行迭代，并推测通项的显示表达式；  
第二、用数学归纳法证明得到的公式。  
目前还没有一个一般性的方法或公式能够实现对任意递推关系式的求解，通常需要针对对递推关系式的具体特点给出相应的求解方法。常系数齐次线性递推关系是一种特殊的递推关系，针对这类递推关系有一套完备可行的求解理论和方法。这套求解理论和方法是求解其它递推关系式的基础，因为很多其它递推关系式都是通过设法将其转化为某种常系数齐次线性递推关系的途径实现求解。下面给出常系数齐次线性递推关系的定义：  
【定义1.27】设$a_{1}$，$a_{2}$，⋯，$a_{k}$是$k$个常数且$a_{k}\neq0$，则下列递推关系：  
$$
u_{n}=a_{1}u_{n-1}+a_{2}u_{n-2}+\cdots+a_{k}u_{n-k}(n\geq k)
$$  
称为$k$阶常系数线性齐次递推关系。  
如果数列 $\{b_{n}\}_{n\geq0}$ 满足 $.b_{n}=a_{1}b_{n-1}+a_{2}b_{n-2}+\cdots+a_{k}b_{n-k}(n\geq k)$ ，则称数列 $\{b_{n}\}_{n\geq O}$ 或 $u_{n}=b_{n}{\big(}n=0,~1,~2,~\cdots{\big)}$是递推关系式(1 −17)的一个解。  
问题：递推关系式(1 −17)有没有解？如果有解，有多少个解？如何求解？下面的定理表明常系数齐次线性递推关系在满足初始条件的情况下有唯一解：  
【定理1.19】任意给出$k$个常数$b_{0}\,,\;\;b_{1}\,,\;\;\cdots\,,\;\;b_{k-1}$，有且仅有唯一一个数列是递推关系式 (1 −17) 满足初始条件 $v_{0}=b_{0}$ ， $v_{1}=b_{1}$ ， ⋯ ， $v_{k-1}=b_{k-1}$ 的解。  
对于常系数齐次线性递推关系的求解，基本思路是采用一种所谓特征根的方法，通过引入特征方程和特征根的概念，巧妙地将递推关系的求解问题转化为求代数方程根的求解问题。为此，我们引入如下特征方程和特征根的定义：  
【定义1.27】如下方程：  
$$
x^{k}-a_{1}x^{k-1}-a_{2}x^{k-2}-\cdots-a_{k-1}x-a_{k}=0
$$  
称为递推关系式(1 −17)的特征方程，它的根称为递推关系式(1 −17)的特征根。  
因为$a_{k}\neq0$，所以0 不是递推关系式(1 −17)的特征根。 下面的定理非常关键，它给出了特征根与常系数齐次线性递推关系解之间的联系：  
【定理1.20】设$q$ 是非0 复数，则$u_{n}=q^{n}$是递推关系式(1 −17)的一个解当且仅当$q$是递推关系式(1 −17)的一个特征根。  
下面定理给出了常系数齐次线性递推关系解的结构特点：  
【定理1.21】设$\cdot u_{n}=g_{i}(n)(i=1,2,\cdots,s)$均为递推关系式(1 −17)的解，$c_{i}(i=1,\!2,\cdots,s)$为任意常数，则有：  
$$
=\sum_{i=1}^{s}c_{i}g_{i}(n)
$$  
也是递推关系式(1 −17)的解。  
【定理1.22】如果递推关系式(1 −17)的$k$ 个特征根$q_{1}\,,\;\;q_{2}\,,\;\;\cdots\,,\;\;q_{k}$彼此相异，则  
$$
u_{n}=c_{1}q_{1}^{n}+c_{2}q_{2}^{n}+\cdots+c_{k}q_{k}^{n}
$$  
是递推关系式(1 −17)的通解。其中$c_{1}\,,\;\;c_{2}\,,\;\;\cdots\,,\;\;c_{k}$为任意常数。",常系数齐次线性递推关系是递推关系的一种特殊形式
常系数齐次线性递推关系,引入,特征方程,,"递推关系是复杂问题和动态问题求解重要工具，要使递推关系在问题求解中发挥作用特别是在计数问题中发挥作用，有时需要实现对递推关系式的求解，也就是说要找到满足递推公式的所有数列或部分数列的显示通项表达式。对递推关系式的求解是一个非常复杂的数学问题，属于离散数学及相关学科的前沿研究课题，有兴趣的读者可以查阅相关资料做进一步深入研究。作为抛砖引玉，我们仅介绍其中两种最常用的基本解法，即针对简单递推关系的迭代求解方法和针对常系数齐次线性递推关系的特征根求解方法。  
迭代求解法是一种最基本的解法，该方法主要用于求解一些比较简单的递推关系式，由如下两个基本步骤构成：  
第一、利用递推关系式对其右边的表达式进行迭代，并推测通项的显示表达式；  
第二、用数学归纳法证明得到的公式。  
目前还没有一个一般性的方法或公式能够实现对任意递推关系式的求解，通常需要针对对递推关系式的具体特点给出相应的求解方法。常系数齐次线性递推关系是一种特殊的递推关系，针对这类递推关系有一套完备可行的求解理论和方法。这套求解理论和方法是求解其它递推关系式的基础，因为很多其它递推关系式都是通过设法将其转化为某种常系数齐次线性递推关系的途径实现求解。下面给出常系数齐次线性递推关系的定义：  
【定义1.27】设$a_{1}$，$a_{2}$，⋯，$a_{k}$是$k$个常数且$a_{k}\neq0$，则下列递推关系：  
$$
u_{n}=a_{1}u_{n-1}+a_{2}u_{n-2}+\cdots+a_{k}u_{n-k}(n\geq k)
$$  
称为$k$阶常系数线性齐次递推关系。  
如果数列 $\{b_{n}\}_{n\geq0}$ 满足 $.b_{n}=a_{1}b_{n-1}+a_{2}b_{n-2}+\cdots+a_{k}b_{n-k}(n\geq k)$ ，则称数列 $\{b_{n}\}_{n\geq O}$ 或 $u_{n}=b_{n}{\big(}n=0,~1,~2,~\cdots{\big)}$是递推关系式(1 −17)的一个解。  
问题：递推关系式(1 −17)有没有解？如果有解，有多少个解？如何求解？下面的定理表明常系数齐次线性递推关系在满足初始条件的情况下有唯一解：  
【定理1.19】任意给出$k$个常数$b_{0}\,,\;\;b_{1}\,,\;\;\cdots\,,\;\;b_{k-1}$，有且仅有唯一一个数列是递推关系式 (1 −17) 满足初始条件 $v_{0}=b_{0}$ ， $v_{1}=b_{1}$ ， ⋯ ， $v_{k-1}=b_{k-1}$ 的解。  
对于常系数齐次线性递推关系的求解，基本思路是采用一种所谓特征根的方法，通过引入特征方程和特征根的概念，巧妙地将递推关系的求解问题转化为求代数方程根的求解问题。为此，我们引入如下特征方程和特征根的定义：  
【定义1.27】如下方程：  
$$
x^{k}-a_{1}x^{k-1}-a_{2}x^{k-2}-\cdots-a_{k-1}x-a_{k}=0
$$  
称为递推关系式(1 −17)的特征方程，它的根称为递推关系式(1 −17)的特征根。  
因为$a_{k}\neq0$，所以0 不是递推关系式(1 −17)的特征根。 下面的定理非常关键，它给出了特征根与常系数齐次线性递推关系解之间的联系：  
【定理1.20】设$q$ 是非0 复数，则$u_{n}=q^{n}$是递推关系式(1 −17)的一个解当且仅当$q$是递推关系式(1 −17)的一个特征根。  
下面定理给出了常系数齐次线性递推关系解的结构特点：  
【定理1.21】设$\cdot u_{n}=g_{i}(n)(i=1,2,\cdots,s)$均为递推关系式(1 −17)的解，$c_{i}(i=1,\!2,\cdots,s)$为任意常数，则有：  
$$
=\sum_{i=1}^{s}c_{i}g_{i}(n)
$$  
也是递推关系式(1 −17)的解。  
【定理1.22】如果递推关系式(1 −17)的$k$ 个特征根$q_{1}\,,\;\;q_{2}\,,\;\;\cdots\,,\;\;q_{k}$彼此相异，则  
$$
u_{n}=c_{1}q_{1}^{n}+c_{2}q_{2}^{n}+\cdots+c_{k}q_{k}^{n}
$$  
是递推关系式(1 −17)的通解。其中$c_{1}\,,\;\;c_{2}\,,\;\;\cdots\,,\;\;c_{k}$为任意常数。",特征方程用于求解常系数齐次线性递推关系
常系数齐次线性递推关系,证明,定理1.19,,"递推关系是复杂问题和动态问题求解重要工具，要使递推关系在问题求解中发挥作用特别是在计数问题中发挥作用，有时需要实现对递推关系式的求解，也就是说要找到满足递推公式的所有数列或部分数列的显示通项表达式。对递推关系式的求解是一个非常复杂的数学问题，属于离散数学及相关学科的前沿研究课题，有兴趣的读者可以查阅相关资料做进一步深入研究。作为抛砖引玉，我们仅介绍其中两种最常用的基本解法，即针对简单递推关系的迭代求解方法和针对常系数齐次线性递推关系的特征根求解方法。  
迭代求解法是一种最基本的解法，该方法主要用于求解一些比较简单的递推关系式，由如下两个基本步骤构成：  
第一、利用递推关系式对其右边的表达式进行迭代，并推测通项的显示表达式；  
第二、用数学归纳法证明得到的公式。  
目前还没有一个一般性的方法或公式能够实现对任意递推关系式的求解，通常需要针对对递推关系式的具体特点给出相应的求解方法。常系数齐次线性递推关系是一种特殊的递推关系，针对这类递推关系有一套完备可行的求解理论和方法。这套求解理论和方法是求解其它递推关系式的基础，因为很多其它递推关系式都是通过设法将其转化为某种常系数齐次线性递推关系的途径实现求解。下面给出常系数齐次线性递推关系的定义：  
【定义1.27】设$a_{1}$，$a_{2}$，⋯，$a_{k}$是$k$个常数且$a_{k}\neq0$，则下列递推关系：  
$$
u_{n}=a_{1}u_{n-1}+a_{2}u_{n-2}+\cdots+a_{k}u_{n-k}(n\geq k)
$$  
称为$k$阶常系数线性齐次递推关系。  
如果数列 $\{b_{n}\}_{n\geq0}$ 满足 $.b_{n}=a_{1}b_{n-1}+a_{2}b_{n-2}+\cdots+a_{k}b_{n-k}(n\geq k)$ ，则称数列 $\{b_{n}\}_{n\geq O}$ 或 $u_{n}=b_{n}{\big(}n=0,~1,~2,~\cdots{\big)}$是递推关系式(1 −17)的一个解。  
问题：递推关系式(1 −17)有没有解？如果有解，有多少个解？如何求解？下面的定理表明常系数齐次线性递推关系在满足初始条件的情况下有唯一解：  
【定理1.19】任意给出$k$个常数$b_{0}\,,\;\;b_{1}\,,\;\;\cdots\,,\;\;b_{k-1}$，有且仅有唯一一个数列是递推关系式 (1 −17) 满足初始条件 $v_{0}=b_{0}$ ， $v_{1}=b_{1}$ ， ⋯ ， $v_{k-1}=b_{k-1}$ 的解。  
对于常系数齐次线性递推关系的求解，基本思路是采用一种所谓特征根的方法，通过引入特征方程和特征根的概念，巧妙地将递推关系的求解问题转化为求代数方程根的求解问题。为此，我们引入如下特征方程和特征根的定义：  
【定义1.27】如下方程：  
$$
x^{k}-a_{1}x^{k-1}-a_{2}x^{k-2}-\cdots-a_{k-1}x-a_{k}=0
$$  
称为递推关系式(1 −17)的特征方程，它的根称为递推关系式(1 −17)的特征根。  
因为$a_{k}\neq0$，所以0 不是递推关系式(1 −17)的特征根。 下面的定理非常关键，它给出了特征根与常系数齐次线性递推关系解之间的联系：  
【定理1.20】设$q$ 是非0 复数，则$u_{n}=q^{n}$是递推关系式(1 −17)的一个解当且仅当$q$是递推关系式(1 −17)的一个特征根。  
下面定理给出了常系数齐次线性递推关系解的结构特点：  
【定理1.21】设$\cdot u_{n}=g_{i}(n)(i=1,2,\cdots,s)$均为递推关系式(1 −17)的解，$c_{i}(i=1,\!2,\cdots,s)$为任意常数，则有：  
$$
=\sum_{i=1}^{s}c_{i}g_{i}(n)
$$  
也是递推关系式(1 −17)的解。  
【定理1.22】如果递推关系式(1 −17)的$k$ 个特征根$q_{1}\,,\;\;q_{2}\,,\;\;\cdots\,,\;\;q_{k}$彼此相异，则  
$$
u_{n}=c_{1}q_{1}^{n}+c_{2}q_{2}^{n}+\cdots+c_{k}q_{k}^{n}
$$  
是递推关系式(1 −17)的通解。其中$c_{1}\,,\;\;c_{2}\,,\;\;\cdots\,,\;\;c_{k}$为任意常数。",定理1.19证明了常系数齐次线性递推关系在满足初始条件时有唯一解
常系数齐次线性递推关系,联系,定理1.20,,"递推关系是复杂问题和动态问题求解重要工具，要使递推关系在问题求解中发挥作用特别是在计数问题中发挥作用，有时需要实现对递推关系式的求解，也就是说要找到满足递推公式的所有数列或部分数列的显示通项表达式。对递推关系式的求解是一个非常复杂的数学问题，属于离散数学及相关学科的前沿研究课题，有兴趣的读者可以查阅相关资料做进一步深入研究。作为抛砖引玉，我们仅介绍其中两种最常用的基本解法，即针对简单递推关系的迭代求解方法和针对常系数齐次线性递推关系的特征根求解方法。  
迭代求解法是一种最基本的解法，该方法主要用于求解一些比较简单的递推关系式，由如下两个基本步骤构成：  
第一、利用递推关系式对其右边的表达式进行迭代，并推测通项的显示表达式；  
第二、用数学归纳法证明得到的公式。  
目前还没有一个一般性的方法或公式能够实现对任意递推关系式的求解，通常需要针对对递推关系式的具体特点给出相应的求解方法。常系数齐次线性递推关系是一种特殊的递推关系，针对这类递推关系有一套完备可行的求解理论和方法。这套求解理论和方法是求解其它递推关系式的基础，因为很多其它递推关系式都是通过设法将其转化为某种常系数齐次线性递推关系的途径实现求解。下面给出常系数齐次线性递推关系的定义：  
【定义1.27】设$a_{1}$，$a_{2}$，⋯，$a_{k}$是$k$个常数且$a_{k}\neq0$，则下列递推关系：  
$$
u_{n}=a_{1}u_{n-1}+a_{2}u_{n-2}+\cdots+a_{k}u_{n-k}(n\geq k)
$$  
称为$k$阶常系数线性齐次递推关系。  
如果数列 $\{b_{n}\}_{n\geq0}$ 满足 $.b_{n}=a_{1}b_{n-1}+a_{2}b_{n-2}+\cdots+a_{k}b_{n-k}(n\geq k)$ ，则称数列 $\{b_{n}\}_{n\geq O}$ 或 $u_{n}=b_{n}{\big(}n=0,~1,~2,~\cdots{\big)}$是递推关系式(1 −17)的一个解。  
问题：递推关系式(1 −17)有没有解？如果有解，有多少个解？如何求解？下面的定理表明常系数齐次线性递推关系在满足初始条件的情况下有唯一解：  
【定理1.19】任意给出$k$个常数$b_{0}\,,\;\;b_{1}\,,\;\;\cdots\,,\;\;b_{k-1}$，有且仅有唯一一个数列是递推关系式 (1 −17) 满足初始条件 $v_{0}=b_{0}$ ， $v_{1}=b_{1}$ ， ⋯ ， $v_{k-1}=b_{k-1}$ 的解。  
对于常系数齐次线性递推关系的求解，基本思路是采用一种所谓特征根的方法，通过引入特征方程和特征根的概念，巧妙地将递推关系的求解问题转化为求代数方程根的求解问题。为此，我们引入如下特征方程和特征根的定义：  
【定义1.27】如下方程：  
$$
x^{k}-a_{1}x^{k-1}-a_{2}x^{k-2}-\cdots-a_{k-1}x-a_{k}=0
$$  
称为递推关系式(1 −17)的特征方程，它的根称为递推关系式(1 −17)的特征根。  
因为$a_{k}\neq0$，所以0 不是递推关系式(1 −17)的特征根。 下面的定理非常关键，它给出了特征根与常系数齐次线性递推关系解之间的联系：  
【定理1.20】设$q$ 是非0 复数，则$u_{n}=q^{n}$是递推关系式(1 −17)的一个解当且仅当$q$是递推关系式(1 −17)的一个特征根。  
下面定理给出了常系数齐次线性递推关系解的结构特点：  
【定理1.21】设$\cdot u_{n}=g_{i}(n)(i=1,2,\cdots,s)$均为递推关系式(1 −17)的解，$c_{i}(i=1,\!2,\cdots,s)$为任意常数，则有：  
$$
=\sum_{i=1}^{s}c_{i}g_{i}(n)
$$  
也是递推关系式(1 −17)的解。  
【定理1.22】如果递推关系式(1 −17)的$k$ 个特征根$q_{1}\,,\;\;q_{2}\,,\;\;\cdots\,,\;\;q_{k}$彼此相异，则  
$$
u_{n}=c_{1}q_{1}^{n}+c_{2}q_{2}^{n}+\cdots+c_{k}q_{k}^{n}
$$  
是递推关系式(1 −17)的通解。其中$c_{1}\,,\;\;c_{2}\,,\;\;\cdots\,,\;\;c_{k}$为任意常数。",定理1.20建立了特征根与常系数齐次线性递推关系解之间的联系
常系数齐次线性递推关系,结构,定理1.21,,"递推关系是复杂问题和动态问题求解重要工具，要使递推关系在问题求解中发挥作用特别是在计数问题中发挥作用，有时需要实现对递推关系式的求解，也就是说要找到满足递推公式的所有数列或部分数列的显示通项表达式。对递推关系式的求解是一个非常复杂的数学问题，属于离散数学及相关学科的前沿研究课题，有兴趣的读者可以查阅相关资料做进一步深入研究。作为抛砖引玉，我们仅介绍其中两种最常用的基本解法，即针对简单递推关系的迭代求解方法和针对常系数齐次线性递推关系的特征根求解方法。  
迭代求解法是一种最基本的解法，该方法主要用于求解一些比较简单的递推关系式，由如下两个基本步骤构成：  
第一、利用递推关系式对其右边的表达式进行迭代，并推测通项的显示表达式；  
第二、用数学归纳法证明得到的公式。  
目前还没有一个一般性的方法或公式能够实现对任意递推关系式的求解，通常需要针对对递推关系式的具体特点给出相应的求解方法。常系数齐次线性递推关系是一种特殊的递推关系，针对这类递推关系有一套完备可行的求解理论和方法。这套求解理论和方法是求解其它递推关系式的基础，因为很多其它递推关系式都是通过设法将其转化为某种常系数齐次线性递推关系的途径实现求解。下面给出常系数齐次线性递推关系的定义：  
【定义1.27】设$a_{1}$，$a_{2}$，⋯，$a_{k}$是$k$个常数且$a_{k}\neq0$，则下列递推关系：  
$$
u_{n}=a_{1}u_{n-1}+a_{2}u_{n-2}+\cdots+a_{k}u_{n-k}(n\geq k)
$$  
称为$k$阶常系数线性齐次递推关系。  
如果数列 $\{b_{n}\}_{n\geq0}$ 满足 $.b_{n}=a_{1}b_{n-1}+a_{2}b_{n-2}+\cdots+a_{k}b_{n-k}(n\geq k)$ ，则称数列 $\{b_{n}\}_{n\geq O}$ 或 $u_{n}=b_{n}{\big(}n=0,~1,~2,~\cdots{\big)}$是递推关系式(1 −17)的一个解。  
问题：递推关系式(1 −17)有没有解？如果有解，有多少个解？如何求解？下面的定理表明常系数齐次线性递推关系在满足初始条件的情况下有唯一解：  
【定理1.19】任意给出$k$个常数$b_{0}\,,\;\;b_{1}\,,\;\;\cdots\,,\;\;b_{k-1}$，有且仅有唯一一个数列是递推关系式 (1 −17) 满足初始条件 $v_{0}=b_{0}$ ， $v_{1}=b_{1}$ ， ⋯ ， $v_{k-1}=b_{k-1}$ 的解。  
对于常系数齐次线性递推关系的求解，基本思路是采用一种所谓特征根的方法，通过引入特征方程和特征根的概念，巧妙地将递推关系的求解问题转化为求代数方程根的求解问题。为此，我们引入如下特征方程和特征根的定义：  
【定义1.27】如下方程：  
$$
x^{k}-a_{1}x^{k-1}-a_{2}x^{k-2}-\cdots-a_{k-1}x-a_{k}=0
$$  
称为递推关系式(1 −17)的特征方程，它的根称为递推关系式(1 −17)的特征根。  
因为$a_{k}\neq0$，所以0 不是递推关系式(1 −17)的特征根。 下面的定理非常关键，它给出了特征根与常系数齐次线性递推关系解之间的联系：  
【定理1.20】设$q$ 是非0 复数，则$u_{n}=q^{n}$是递推关系式(1 −17)的一个解当且仅当$q$是递推关系式(1 −17)的一个特征根。  
下面定理给出了常系数齐次线性递推关系解的结构特点：  
【定理1.21】设$\cdot u_{n}=g_{i}(n)(i=1,2,\cdots,s)$均为递推关系式(1 −17)的解，$c_{i}(i=1,\!2,\cdots,s)$为任意常数，则有：  
$$
=\sum_{i=1}^{s}c_{i}g_{i}(n)
$$  
也是递推关系式(1 −17)的解。  
【定理1.22】如果递推关系式(1 −17)的$k$ 个特征根$q_{1}\,,\;\;q_{2}\,,\;\;\cdots\,,\;\;q_{k}$彼此相异，则  
$$
u_{n}=c_{1}q_{1}^{n}+c_{2}q_{2}^{n}+\cdots+c_{k}q_{k}^{n}
$$  
是递推关系式(1 −17)的通解。其中$c_{1}\,,\;\;c_{2}\,,\;\;\cdots\,,\;\;c_{k}$为任意常数。",定理1.21描述了常系数齐次线性递推关系解的结构特点
常系数齐次线性递推关系,通解,定理1.22,,"递推关系是复杂问题和动态问题求解重要工具，要使递推关系在问题求解中发挥作用特别是在计数问题中发挥作用，有时需要实现对递推关系式的求解，也就是说要找到满足递推公式的所有数列或部分数列的显示通项表达式。对递推关系式的求解是一个非常复杂的数学问题，属于离散数学及相关学科的前沿研究课题，有兴趣的读者可以查阅相关资料做进一步深入研究。作为抛砖引玉，我们仅介绍其中两种最常用的基本解法，即针对简单递推关系的迭代求解方法和针对常系数齐次线性递推关系的特征根求解方法。  
迭代求解法是一种最基本的解法，该方法主要用于求解一些比较简单的递推关系式，由如下两个基本步骤构成：  
第一、利用递推关系式对其右边的表达式进行迭代，并推测通项的显示表达式；  
第二、用数学归纳法证明得到的公式。  
目前还没有一个一般性的方法或公式能够实现对任意递推关系式的求解，通常需要针对对递推关系式的具体特点给出相应的求解方法。常系数齐次线性递推关系是一种特殊的递推关系，针对这类递推关系有一套完备可行的求解理论和方法。这套求解理论和方法是求解其它递推关系式的基础，因为很多其它递推关系式都是通过设法将其转化为某种常系数齐次线性递推关系的途径实现求解。下面给出常系数齐次线性递推关系的定义：  
【定义1.27】设$a_{1}$，$a_{2}$，⋯，$a_{k}$是$k$个常数且$a_{k}\neq0$，则下列递推关系：  
$$
u_{n}=a_{1}u_{n-1}+a_{2}u_{n-2}+\cdots+a_{k}u_{n-k}(n\geq k)
$$  
称为$k$阶常系数线性齐次递推关系。  
如果数列 $\{b_{n}\}_{n\geq0}$ 满足 $.b_{n}=a_{1}b_{n-1}+a_{2}b_{n-2}+\cdots+a_{k}b_{n-k}(n\geq k)$ ，则称数列 $\{b_{n}\}_{n\geq O}$ 或 $u_{n}=b_{n}{\big(}n=0,~1,~2,~\cdots{\big)}$是递推关系式(1 −17)的一个解。  
问题：递推关系式(1 −17)有没有解？如果有解，有多少个解？如何求解？下面的定理表明常系数齐次线性递推关系在满足初始条件的情况下有唯一解：  
【定理1.19】任意给出$k$个常数$b_{0}\,,\;\;b_{1}\,,\;\;\cdots\,,\;\;b_{k-1}$，有且仅有唯一一个数列是递推关系式 (1 −17) 满足初始条件 $v_{0}=b_{0}$ ， $v_{1}=b_{1}$ ， ⋯ ， $v_{k-1}=b_{k-1}$ 的解。  
对于常系数齐次线性递推关系的求解，基本思路是采用一种所谓特征根的方法，通过引入特征方程和特征根的概念，巧妙地将递推关系的求解问题转化为求代数方程根的求解问题。为此，我们引入如下特征方程和特征根的定义：  
【定义1.27】如下方程：  
$$
x^{k}-a_{1}x^{k-1}-a_{2}x^{k-2}-\cdots-a_{k-1}x-a_{k}=0
$$  
称为递推关系式(1 −17)的特征方程，它的根称为递推关系式(1 −17)的特征根。  
因为$a_{k}\neq0$，所以0 不是递推关系式(1 −17)的特征根。 下面的定理非常关键，它给出了特征根与常系数齐次线性递推关系解之间的联系：  
【定理1.20】设$q$ 是非0 复数，则$u_{n}=q^{n}$是递推关系式(1 −17)的一个解当且仅当$q$是递推关系式(1 −17)的一个特征根。  
下面定理给出了常系数齐次线性递推关系解的结构特点：  
【定理1.21】设$\cdot u_{n}=g_{i}(n)(i=1,2,\cdots,s)$均为递推关系式(1 −17)的解，$c_{i}(i=1,\!2,\cdots,s)$为任意常数，则有：  
$$
=\sum_{i=1}^{s}c_{i}g_{i}(n)
$$  
也是递推关系式(1 −17)的解。  
【定理1.22】如果递推关系式(1 −17)的$k$ 个特征根$q_{1}\,,\;\;q_{2}\,,\;\;\cdots\,,\;\;q_{k}$彼此相异，则  
$$
u_{n}=c_{1}q_{1}^{n}+c_{2}q_{2}^{n}+\cdots+c_{k}q_{k}^{n}
$$  
是递推关系式(1 −17)的通解。其中$c_{1}\,,\;\;c_{2}\,,\;\;\cdots\,,\;\;c_{k}$为任意常数。",定理1.22给出了常系数齐次线性递推关系的通解形式
生成函数计数法,使用,生成函数,,"前面我们通过考察数列通项之间的递推关系建立求解问题的动态演化模型并据此实现对有限集合的计数。现在我们仍然以数列为基本工具，通过以数列为系数建立无穷次多项式或幂级数的方式找到联结离散数学与连续数学的桥梁，巧妙地将离散数学中离散量的计数问题转化为连续数学中对幂级数的处理问题。这种幂级数我们称之为数列的生成函数或母函数。生成函数是组合分析与计数的重要工具，运用生成函数求解某些给定条件下的组合数、排列数，以及求解某些递推关系时，有时能获得意想不到的效果。  
【定义1.28】设$\cdot x$为一抽象符号，$a_{n}$（$(n=0{,}1{,}2,\cdots)$）为实数。若函数$F(x)$可表示成  
$$
F(x)=a_{0}+a_{1}x+a_{2}x^{2}+\cdots+a_{n}x^{n}+\cdots
$$  
则称$\cdot F(x)$为数列$a_{n}$$_{\imath}\left(n=0,\!1,\!2,\cdots\right)$）的生成函数。并约定，若某个$\cdot a_{i}=0(i=0,1,2,\cdots)$，则$a_{i}x^{i}$项可以略去。  
比如$|F(x)=1+x+x^{2}+x^{3}+\cdots+x^{n}+\cdots$是无穷序列1，1，1，⋯的生成函数。  
对于一个有限序列$a_{0}\,,\;\;a_{1}\,,\;\;\cdots,\;\;a_{n}\,.$，可以通过将$a_{n}$之后的项定义为0 的方式扩充成一个无限序列，由此定义生成函数。对于有限序列，当$j>n$时没有形如$|a_{j}x^{j}$的项出现，即有：  
$$
G(x)=a_{0}+a_{1}x+\cdots+a_{n}x^{n}
$$  
【定理1.23】无穷重数的$m$元重集$\left\{\infty\cdot a_{1},\ \infty\cdot a_{2},\ \ \cdots,\ \infty\cdot a_{m-1},\ \infty\cdot a_{m}\right\}|$的$r$-组合数的母函数是$f(x)=(1+x+x^{2}+\cdots+x^{n}+\cdots)^{m}$，$f(x)$中$x^{r}$的系数等于上述$r-$组合数。",生成函数计数法使用生成函数作为工具进行组合分析与计数
生成函数,特例,无穷重数的m元重集的r组合数的母函数,,"前面我们通过考察数列通项之间的递推关系建立求解问题的动态演化模型并据此实现对有限集合的计数。现在我们仍然以数列为基本工具，通过以数列为系数建立无穷次多项式或幂级数的方式找到联结离散数学与连续数学的桥梁，巧妙地将离散数学中离散量的计数问题转化为连续数学中对幂级数的处理问题。这种幂级数我们称之为数列的生成函数或母函数。生成函数是组合分析与计数的重要工具，运用生成函数求解某些给定条件下的组合数、排列数，以及求解某些递推关系时，有时能获得意想不到的效果。  
【定义1.28】设$\cdot x$为一抽象符号，$a_{n}$（$(n=0{,}1{,}2,\cdots)$）为实数。若函数$F(x)$可表示成  
$$
F(x)=a_{0}+a_{1}x+a_{2}x^{2}+\cdots+a_{n}x^{n}+\cdots
$$  
则称$\cdot F(x)$为数列$a_{n}$$_{\imath}\left(n=0,\!1,\!2,\cdots\right)$）的生成函数。并约定，若某个$\cdot a_{i}=0(i=0,1,2,\cdots)$，则$a_{i}x^{i}$项可以略去。  
比如$|F(x)=1+x+x^{2}+x^{3}+\cdots+x^{n}+\cdots$是无穷序列1，1，1，⋯的生成函数。  
对于一个有限序列$a_{0}\,,\;\;a_{1}\,,\;\;\cdots,\;\;a_{n}\,.$，可以通过将$a_{n}$之后的项定义为0 的方式扩充成一个无限序列，由此定义生成函数。对于有限序列，当$j>n$时没有形如$|a_{j}x^{j}$的项出现，即有：  
$$
G(x)=a_{0}+a_{1}x+\cdots+a_{n}x^{n}
$$  
【定理1.23】无穷重数的$m$元重集$\left\{\infty\cdot a_{1},\ \infty\cdot a_{2},\ \ \cdots,\ \infty\cdot a_{m-1},\ \infty\cdot a_{m}\right\}|$的$r$-组合数的母函数是$f(x)=(1+x+x^{2}+\cdots+x^{n}+\cdots)^{m}$，$f(x)$中$x^{r}$的系数等于上述$r-$组合数。",无穷重数的m元重集的r组合数的母函数是生成函数的一种特例
图模型,包含,欧拉图,,"如前所述，图模型及其理论是数学家欧拉为解决哥尼斯堡七桥遍历问题而创立。事实上，图模型作为一种由结点和边组成的离散结构是一种非常强大的离散建模工具，除了能够解决哥尼斯堡七桥遍历问题之外，还可解决很多其它实际问题。例如，旅游的路径规划问题、资源分配与匹配问题、图的着色与并行流程的设计问题、最小费用流问题等等。针对不同的问题，通常需要设计出特定的图模型进行建模与求解。例如，解决哥尼斯堡七桥遍历问题需要使用欧拉图及相关理论、解决旅游的路径规划问题需要哈密顿图及相关理论、解决资源分配与匹配问题需要二分图及相关理论、解决图的着色与并行流程的设计问题需要平面图的相关理论、解决最小费用流问题需要网络流图的相关理论等等。由此产生很多种具有特殊结构和性质的图模型，每种特殊图模型都能针对性地有效地解决某一类或某几类特定问题。因此，要想高效合理地使用图模型实现对实际问题的建模与求解，除了掌握前述图模型的一般理论及算法之外，还需要进一步掌握多种特殊图模型的相关理论及算法。  
本章介绍几种重要的特殊图模型及相关算法，包括欧拉图模型的基本理论及边的遍历算法、哈密顿图的基本理论及结点的近似遍历算法、二分图模型的基本理论及匈牙利匹配构造算法、平面图的基本理论及着色算法、网络流图的基本理论及最大流算法，并结合具体实例分析和讨论这些特殊图模型的应用方法。",图模型包含欧拉图这一特殊类型，用于解决特定问题如哥尼斯堡七桥遍历问题
图模型,包含,哈密顿图,,"如前所述，图模型及其理论是数学家欧拉为解决哥尼斯堡七桥遍历问题而创立。事实上，图模型作为一种由结点和边组成的离散结构是一种非常强大的离散建模工具，除了能够解决哥尼斯堡七桥遍历问题之外，还可解决很多其它实际问题。例如，旅游的路径规划问题、资源分配与匹配问题、图的着色与并行流程的设计问题、最小费用流问题等等。针对不同的问题，通常需要设计出特定的图模型进行建模与求解。例如，解决哥尼斯堡七桥遍历问题需要使用欧拉图及相关理论、解决旅游的路径规划问题需要哈密顿图及相关理论、解决资源分配与匹配问题需要二分图及相关理论、解决图的着色与并行流程的设计问题需要平面图的相关理论、解决最小费用流问题需要网络流图的相关理论等等。由此产生很多种具有特殊结构和性质的图模型，每种特殊图模型都能针对性地有效地解决某一类或某几类特定问题。因此，要想高效合理地使用图模型实现对实际问题的建模与求解，除了掌握前述图模型的一般理论及算法之外，还需要进一步掌握多种特殊图模型的相关理论及算法。  
本章介绍几种重要的特殊图模型及相关算法，包括欧拉图模型的基本理论及边的遍历算法、哈密顿图的基本理论及结点的近似遍历算法、二分图模型的基本理论及匈牙利匹配构造算法、平面图的基本理论及着色算法、网络流图的基本理论及最大流算法，并结合具体实例分析和讨论这些特殊图模型的应用方法。",图模型包含哈密顿图这一特殊类型，用于解决旅游路径规划问题
图模型,包含,二分图,,"如前所述，图模型及其理论是数学家欧拉为解决哥尼斯堡七桥遍历问题而创立。事实上，图模型作为一种由结点和边组成的离散结构是一种非常强大的离散建模工具，除了能够解决哥尼斯堡七桥遍历问题之外，还可解决很多其它实际问题。例如，旅游的路径规划问题、资源分配与匹配问题、图的着色与并行流程的设计问题、最小费用流问题等等。针对不同的问题，通常需要设计出特定的图模型进行建模与求解。例如，解决哥尼斯堡七桥遍历问题需要使用欧拉图及相关理论、解决旅游的路径规划问题需要哈密顿图及相关理论、解决资源分配与匹配问题需要二分图及相关理论、解决图的着色与并行流程的设计问题需要平面图的相关理论、解决最小费用流问题需要网络流图的相关理论等等。由此产生很多种具有特殊结构和性质的图模型，每种特殊图模型都能针对性地有效地解决某一类或某几类特定问题。因此，要想高效合理地使用图模型实现对实际问题的建模与求解，除了掌握前述图模型的一般理论及算法之外，还需要进一步掌握多种特殊图模型的相关理论及算法。  
本章介绍几种重要的特殊图模型及相关算法，包括欧拉图模型的基本理论及边的遍历算法、哈密顿图的基本理论及结点的近似遍历算法、二分图模型的基本理论及匈牙利匹配构造算法、平面图的基本理论及着色算法、网络流图的基本理论及最大流算法，并结合具体实例分析和讨论这些特殊图模型的应用方法。",图模型包含二分图这一特殊类型，用于解决资源分配与匹配问题
图模型,包含,平面图,,"如前所述，图模型及其理论是数学家欧拉为解决哥尼斯堡七桥遍历问题而创立。事实上，图模型作为一种由结点和边组成的离散结构是一种非常强大的离散建模工具，除了能够解决哥尼斯堡七桥遍历问题之外，还可解决很多其它实际问题。例如，旅游的路径规划问题、资源分配与匹配问题、图的着色与并行流程的设计问题、最小费用流问题等等。针对不同的问题，通常需要设计出特定的图模型进行建模与求解。例如，解决哥尼斯堡七桥遍历问题需要使用欧拉图及相关理论、解决旅游的路径规划问题需要哈密顿图及相关理论、解决资源分配与匹配问题需要二分图及相关理论、解决图的着色与并行流程的设计问题需要平面图的相关理论、解决最小费用流问题需要网络流图的相关理论等等。由此产生很多种具有特殊结构和性质的图模型，每种特殊图模型都能针对性地有效地解决某一类或某几类特定问题。因此，要想高效合理地使用图模型实现对实际问题的建模与求解，除了掌握前述图模型的一般理论及算法之外，还需要进一步掌握多种特殊图模型的相关理论及算法。  
本章介绍几种重要的特殊图模型及相关算法，包括欧拉图模型的基本理论及边的遍历算法、哈密顿图的基本理论及结点的近似遍历算法、二分图模型的基本理论及匈牙利匹配构造算法、平面图的基本理论及着色算法、网络流图的基本理论及最大流算法，并结合具体实例分析和讨论这些特殊图模型的应用方法。",图模型包含平面图这一特殊类型，用于解决图的着色与并行流程设计问题
图模型,包含,网络流图,,"如前所述，图模型及其理论是数学家欧拉为解决哥尼斯堡七桥遍历问题而创立。事实上，图模型作为一种由结点和边组成的离散结构是一种非常强大的离散建模工具，除了能够解决哥尼斯堡七桥遍历问题之外，还可解决很多其它实际问题。例如，旅游的路径规划问题、资源分配与匹配问题、图的着色与并行流程的设计问题、最小费用流问题等等。针对不同的问题，通常需要设计出特定的图模型进行建模与求解。例如，解决哥尼斯堡七桥遍历问题需要使用欧拉图及相关理论、解决旅游的路径规划问题需要哈密顿图及相关理论、解决资源分配与匹配问题需要二分图及相关理论、解决图的着色与并行流程的设计问题需要平面图的相关理论、解决最小费用流问题需要网络流图的相关理论等等。由此产生很多种具有特殊结构和性质的图模型，每种特殊图模型都能针对性地有效地解决某一类或某几类特定问题。因此，要想高效合理地使用图模型实现对实际问题的建模与求解，除了掌握前述图模型的一般理论及算法之外，还需要进一步掌握多种特殊图模型的相关理论及算法。  
本章介绍几种重要的特殊图模型及相关算法，包括欧拉图模型的基本理论及边的遍历算法、哈密顿图的基本理论及结点的近似遍历算法、二分图模型的基本理论及匈牙利匹配构造算法、平面图的基本理论及着色算法、网络流图的基本理论及最大流算法，并结合具体实例分析和讨论这些特殊图模型的应用方法。",图模型包含网络流图这一特殊类型，用于解决最小费用流问题
欧拉图,应用,边的遍历算法,,"如前所述，图模型及其理论是数学家欧拉为解决哥尼斯堡七桥遍历问题而创立。事实上，图模型作为一种由结点和边组成的离散结构是一种非常强大的离散建模工具，除了能够解决哥尼斯堡七桥遍历问题之外，还可解决很多其它实际问题。例如，旅游的路径规划问题、资源分配与匹配问题、图的着色与并行流程的设计问题、最小费用流问题等等。针对不同的问题，通常需要设计出特定的图模型进行建模与求解。例如，解决哥尼斯堡七桥遍历问题需要使用欧拉图及相关理论、解决旅游的路径规划问题需要哈密顿图及相关理论、解决资源分配与匹配问题需要二分图及相关理论、解决图的着色与并行流程的设计问题需要平面图的相关理论、解决最小费用流问题需要网络流图的相关理论等等。由此产生很多种具有特殊结构和性质的图模型，每种特殊图模型都能针对性地有效地解决某一类或某几类特定问题。因此，要想高效合理地使用图模型实现对实际问题的建模与求解，除了掌握前述图模型的一般理论及算法之外，还需要进一步掌握多种特殊图模型的相关理论及算法。  
本章介绍几种重要的特殊图模型及相关算法，包括欧拉图模型的基本理论及边的遍历算法、哈密顿图的基本理论及结点的近似遍历算法、二分图模型的基本理论及匈牙利匹配构造算法、平面图的基本理论及着色算法、网络流图的基本理论及最大流算法，并结合具体实例分析和讨论这些特殊图模型的应用方法。",欧拉图模型应用边的遍历算法进行求解
哈密顿图,应用,结点的近似遍历算法,,"如前所述，图模型及其理论是数学家欧拉为解决哥尼斯堡七桥遍历问题而创立。事实上，图模型作为一种由结点和边组成的离散结构是一种非常强大的离散建模工具，除了能够解决哥尼斯堡七桥遍历问题之外，还可解决很多其它实际问题。例如，旅游的路径规划问题、资源分配与匹配问题、图的着色与并行流程的设计问题、最小费用流问题等等。针对不同的问题，通常需要设计出特定的图模型进行建模与求解。例如，解决哥尼斯堡七桥遍历问题需要使用欧拉图及相关理论、解决旅游的路径规划问题需要哈密顿图及相关理论、解决资源分配与匹配问题需要二分图及相关理论、解决图的着色与并行流程的设计问题需要平面图的相关理论、解决最小费用流问题需要网络流图的相关理论等等。由此产生很多种具有特殊结构和性质的图模型，每种特殊图模型都能针对性地有效地解决某一类或某几类特定问题。因此，要想高效合理地使用图模型实现对实际问题的建模与求解，除了掌握前述图模型的一般理论及算法之外，还需要进一步掌握多种特殊图模型的相关理论及算法。  
本章介绍几种重要的特殊图模型及相关算法，包括欧拉图模型的基本理论及边的遍历算法、哈密顿图的基本理论及结点的近似遍历算法、二分图模型的基本理论及匈牙利匹配构造算法、平面图的基本理论及着色算法、网络流图的基本理论及最大流算法，并结合具体实例分析和讨论这些特殊图模型的应用方法。",哈密顿图模型应用结点的近似遍历算法进行求解
二分图,应用,匈牙利匹配构造算法,,"如前所述，图模型及其理论是数学家欧拉为解决哥尼斯堡七桥遍历问题而创立。事实上，图模型作为一种由结点和边组成的离散结构是一种非常强大的离散建模工具，除了能够解决哥尼斯堡七桥遍历问题之外，还可解决很多其它实际问题。例如，旅游的路径规划问题、资源分配与匹配问题、图的着色与并行流程的设计问题、最小费用流问题等等。针对不同的问题，通常需要设计出特定的图模型进行建模与求解。例如，解决哥尼斯堡七桥遍历问题需要使用欧拉图及相关理论、解决旅游的路径规划问题需要哈密顿图及相关理论、解决资源分配与匹配问题需要二分图及相关理论、解决图的着色与并行流程的设计问题需要平面图的相关理论、解决最小费用流问题需要网络流图的相关理论等等。由此产生很多种具有特殊结构和性质的图模型，每种特殊图模型都能针对性地有效地解决某一类或某几类特定问题。因此，要想高效合理地使用图模型实现对实际问题的建模与求解，除了掌握前述图模型的一般理论及算法之外，还需要进一步掌握多种特殊图模型的相关理论及算法。  
本章介绍几种重要的特殊图模型及相关算法，包括欧拉图模型的基本理论及边的遍历算法、哈密顿图的基本理论及结点的近似遍历算法、二分图模型的基本理论及匈牙利匹配构造算法、平面图的基本理论及着色算法、网络流图的基本理论及最大流算法，并结合具体实例分析和讨论这些特殊图模型的应用方法。",二分图模型应用匈牙利匹配构造算法进行求解
平面图,应用,着色算法,,"如前所述，图模型及其理论是数学家欧拉为解决哥尼斯堡七桥遍历问题而创立。事实上，图模型作为一种由结点和边组成的离散结构是一种非常强大的离散建模工具，除了能够解决哥尼斯堡七桥遍历问题之外，还可解决很多其它实际问题。例如，旅游的路径规划问题、资源分配与匹配问题、图的着色与并行流程的设计问题、最小费用流问题等等。针对不同的问题，通常需要设计出特定的图模型进行建模与求解。例如，解决哥尼斯堡七桥遍历问题需要使用欧拉图及相关理论、解决旅游的路径规划问题需要哈密顿图及相关理论、解决资源分配与匹配问题需要二分图及相关理论、解决图的着色与并行流程的设计问题需要平面图的相关理论、解决最小费用流问题需要网络流图的相关理论等等。由此产生很多种具有特殊结构和性质的图模型，每种特殊图模型都能针对性地有效地解决某一类或某几类特定问题。因此，要想高效合理地使用图模型实现对实际问题的建模与求解，除了掌握前述图模型的一般理论及算法之外，还需要进一步掌握多种特殊图模型的相关理论及算法。  
本章介绍几种重要的特殊图模型及相关算法，包括欧拉图模型的基本理论及边的遍历算法、哈密顿图的基本理论及结点的近似遍历算法、二分图模型的基本理论及匈牙利匹配构造算法、平面图的基本理论及着色算法、网络流图的基本理论及最大流算法，并结合具体实例分析和讨论这些特殊图模型的应用方法。",平面图模型应用着色算法进行求解
网络流图,应用,最大流算法,,"如前所述，图模型及其理论是数学家欧拉为解决哥尼斯堡七桥遍历问题而创立。事实上，图模型作为一种由结点和边组成的离散结构是一种非常强大的离散建模工具，除了能够解决哥尼斯堡七桥遍历问题之外，还可解决很多其它实际问题。例如，旅游的路径规划问题、资源分配与匹配问题、图的着色与并行流程的设计问题、最小费用流问题等等。针对不同的问题，通常需要设计出特定的图模型进行建模与求解。例如，解决哥尼斯堡七桥遍历问题需要使用欧拉图及相关理论、解决旅游的路径规划问题需要哈密顿图及相关理论、解决资源分配与匹配问题需要二分图及相关理论、解决图的着色与并行流程的设计问题需要平面图的相关理论、解决最小费用流问题需要网络流图的相关理论等等。由此产生很多种具有特殊结构和性质的图模型，每种特殊图模型都能针对性地有效地解决某一类或某几类特定问题。因此，要想高效合理地使用图模型实现对实际问题的建模与求解，除了掌握前述图模型的一般理论及算法之外，还需要进一步掌握多种特殊图模型的相关理论及算法。  
本章介绍几种重要的特殊图模型及相关算法，包括欧拉图模型的基本理论及边的遍历算法、哈密顿图的基本理论及结点的近似遍历算法、二分图模型的基本理论及匈牙利匹配构造算法、平面图的基本理论及着色算法、网络流图的基本理论及最大流算法，并结合具体实例分析和讨论这些特殊图模型的应用方法。",网络流图模型应用最大流算法进行求解
欧拉图,遍历问题差异,哈密顿图,,欧拉图和哈密顿图的相关理论要解决问题分别是对图中边和结点的唯一性遍历。这两个遍历问题虽然从表面上看非常相似，但是实际上它们之间无论在问题内涵还是求解难度上都具有非常巨大的差异。边的唯一性遍历问题实际上就是对图模型的一笔画问题。对于这个问题，不仅有明确易用的充要条件实现对问题可解性的判定，而且有简单可行的遍历路径精确构造算法。然而，对图中所有结点的唯一性遍历问题则困难得多。该问题要求每个结点都需要关联一定数量的边供其进行遍历路径的选择，但所需边数又与图模型的具体结构有着比较复杂的联系，目前还没有比较直接的充要条件实现对哈密顿路径存在性的判定。本节主要介绍欧拉图和哈密顿图的基本理论，并讨论与之相关的应用问题。,欧拉图解决边的唯一性遍历问题，哈密顿图解决结点的唯一性遍历问题，两者在问题内涵和求解难度上有巨大差异。
欧拉图,定义区分,半欧拉图,,"为更好地介绍欧拉图，有必要再回顾一下前述哥尼斯堡七桥问题：哥尼斯堡小镇有一条贯穿全市的小河，河上有两个小岛，由七座桥将这两个小岛及其与河两岸进行互联，如图$10-$1(a)所示。问题是怎样才能不重复、不遗漏地走完七座桥，并回到出发点。  
![图10-1 哥尼斯堡七桥问题 ](images/f92d2bafd1492d4ec26c4c92f27d5040f5974fc8bef369b51ff49b676bd82f86.jpg)  
瑞士著名的数学家欧拉把该问题抽象成如图10-1(b)所示的图模型，其中两岸陆地和小岛分别被抽象成了 A, B, C, D 四个结点， 每个桥分别被抽象成了连接相应结点的无向边。 于是， 哥尼斯堡七桥问题就等价于图10-1(b)中是否存在一条从图中任意结点出发，经过图中所有边一次且仅一次的回路。由此得到如下欧拉图的相关定义：  
【定义10.1】设 $G=\langle V,E\rangle$是任意给定的一个图模型，通过图𝐺中所有边一次且仅一次的通路称为欧拉通路，通过图$G$中所有边一次且仅一的回路称为欧拉回路。如果图𝐺中存在欧拉回路，则称之为欧拉图，如果$G$中存在欧拉通路但不存在欧拉回路，则称之为半欧拉图。 规定平凡图为欧拉图。  
以上定义既适合无向图也适合有向图。从定义可以看出，欧拉通路是经过图中所有边的通路中长度最短的通路；欧拉回路是经过图中所有边的回路中长度最短的回路。如果仅用边来描述，那么欧拉通路和欧拉回路其实都是图中所有边的一个全排列。  
【定理10.1】设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$是欧拉图当且仅当 $G=\langle V,E\rangle$为连通图且所有结点度数均为偶数。  
【  
【推论10.1】设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$是半欧拉图当  
且仅当 $G=\langle V,E\rangle$为连通图且恰有2 个奇度数结点。  
由推论10.1 可知，如果$G$是连通图且刚好有奇度结点，那么在$G$中存在一条欧拉道路，且一定以其中一个奇度结点为始点，以另一个奇度结点为终点。  
下面进一步给出有向欧拉图和半欧拉图的判定定理：  
【定理10.2】设 $G=\langle V,E\rangle$是任意给定的一个有向图模型，则有：$G=\langle V,E\rangle$是欧拉图当且仅当 $G=\langle V,E\rangle$为连通图且所有结点的入度等等于出度；$G=\langle V,E\rangle$是半欧拉图，当且仅当$G=\langle V,E\rangle$连通且仅有一个结点的入度比出度大1，另外一个结点的出度比入度大1，其余结点的入度等于出度。  
对于一个欧拉图或半欧拉图，可以使用弗洛莱算法自动找到其欧拉回路或欧拉通路。该算法的基本思路是首先从图中的任一点出发，随机去掉与此点相连的边，然后在保证以下两个条件的基础上，依次去掉与之相连的边：  
1）如果去掉某边后使得该边的某端点为孤立结点，则将该端点与该边一并去掉。  
2）在去掉某边后，不能造成图模型的不连通。  
当算法停止时，获得的路径$L=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\ldots e_{n}v_{n}(v_{0}=v_{n})$就是图$G=\langle V,E\rangle$的一条欧拉回路。弗洛莱算法的具体步骤如下：  
1) 首先，在结点集𝑉中任选一个结点$v_{0}$为初始结点，并设初始通路为$L_{0}=v_{0}$。 2) 设已选好的简单通路为$\boldsymbol{\cdot}L_{i}=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\ldots e_{i}v_{i}$，按照下列条件从边集合：  
$$
E-\{e_{1},e_{2},e_{3},\ldots,e_{i}\}
$$  
中选取边]${e}_{i+1}$，其中$G_{1}$是从$G$删除边集合$\{e_{1},e_{2},e_{3},\ldots,e_{i}\}.$后得到的图：  
$\bullet$ 结点$v_{i}$是边$\boldsymbol{\cdot}\boldsymbol{e}_{i+1}$的端点。  
$\bullet$ 除非无其他边可以选取，否则删除边$\boldsymbol{\cdot}\boldsymbol{e}_{i+1}$后不改变图$G_{1}$的连通性。  
3）将$e_{i+1}v_{i+1}$加入到$L_{i}$中，形成新路径$\mathopen:L_{i+1}=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\dots e_{i}v_{i}e_{i+1}v_{i+1}$，令$i=i+1$  
4）返回步骤2）重复上述过程，直到 $i=|E|$ 。  
当图模型是一个半欧拉图时候，使用上述弗洛莱算法显然也可得到其欧拉通路，请读者自己思考算法的具体步骤和要点，不再赘述。  
![图10-10 房间布局的设计图     图10-11 图模型与欧拉通路       图10-12 行走路径 ](images/1200dfbb0792a6069379408b8f0f3304dd4b6248c5b1e2f4c4917b8d0bf94d23.jpg)",欧拉图是存在欧拉回路的图，而半欧拉图是存在欧拉通路但不存在欧拉回路的图
欧拉图,判定条件,定理10.1,,"为更好地介绍欧拉图，有必要再回顾一下前述哥尼斯堡七桥问题：哥尼斯堡小镇有一条贯穿全市的小河，河上有两个小岛，由七座桥将这两个小岛及其与河两岸进行互联，如图$10-$1(a)所示。问题是怎样才能不重复、不遗漏地走完七座桥，并回到出发点。  
![图10-1 哥尼斯堡七桥问题 ](images/f92d2bafd1492d4ec26c4c92f27d5040f5974fc8bef369b51ff49b676bd82f86.jpg)  
瑞士著名的数学家欧拉把该问题抽象成如图10-1(b)所示的图模型，其中两岸陆地和小岛分别被抽象成了 A, B, C, D 四个结点， 每个桥分别被抽象成了连接相应结点的无向边。 于是， 哥尼斯堡七桥问题就等价于图10-1(b)中是否存在一条从图中任意结点出发，经过图中所有边一次且仅一次的回路。由此得到如下欧拉图的相关定义：  
【定义10.1】设 $G=\langle V,E\rangle$是任意给定的一个图模型，通过图𝐺中所有边一次且仅一次的通路称为欧拉通路，通过图$G$中所有边一次且仅一的回路称为欧拉回路。如果图𝐺中存在欧拉回路，则称之为欧拉图，如果$G$中存在欧拉通路但不存在欧拉回路，则称之为半欧拉图。 规定平凡图为欧拉图。  
以上定义既适合无向图也适合有向图。从定义可以看出，欧拉通路是经过图中所有边的通路中长度最短的通路；欧拉回路是经过图中所有边的回路中长度最短的回路。如果仅用边来描述，那么欧拉通路和欧拉回路其实都是图中所有边的一个全排列。  
【定理10.1】设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$是欧拉图当且仅当 $G=\langle V,E\rangle$为连通图且所有结点度数均为偶数。  
【  
【推论10.1】设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$是半欧拉图当  
且仅当 $G=\langle V,E\rangle$为连通图且恰有2 个奇度数结点。  
由推论10.1 可知，如果$G$是连通图且刚好有奇度结点，那么在$G$中存在一条欧拉道路，且一定以其中一个奇度结点为始点，以另一个奇度结点为终点。  
下面进一步给出有向欧拉图和半欧拉图的判定定理：  
【定理10.2】设 $G=\langle V,E\rangle$是任意给定的一个有向图模型，则有：$G=\langle V,E\rangle$是欧拉图当且仅当 $G=\langle V,E\rangle$为连通图且所有结点的入度等等于出度；$G=\langle V,E\rangle$是半欧拉图，当且仅当$G=\langle V,E\rangle$连通且仅有一个结点的入度比出度大1，另外一个结点的出度比入度大1，其余结点的入度等于出度。  
对于一个欧拉图或半欧拉图，可以使用弗洛莱算法自动找到其欧拉回路或欧拉通路。该算法的基本思路是首先从图中的任一点出发，随机去掉与此点相连的边，然后在保证以下两个条件的基础上，依次去掉与之相连的边：  
1）如果去掉某边后使得该边的某端点为孤立结点，则将该端点与该边一并去掉。  
2）在去掉某边后，不能造成图模型的不连通。  
当算法停止时，获得的路径$L=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\ldots e_{n}v_{n}(v_{0}=v_{n})$就是图$G=\langle V,E\rangle$的一条欧拉回路。弗洛莱算法的具体步骤如下：  
1) 首先，在结点集𝑉中任选一个结点$v_{0}$为初始结点，并设初始通路为$L_{0}=v_{0}$。 2) 设已选好的简单通路为$\boldsymbol{\cdot}L_{i}=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\ldots e_{i}v_{i}$，按照下列条件从边集合：  
$$
E-\{e_{1},e_{2},e_{3},\ldots,e_{i}\}
$$  
中选取边]${e}_{i+1}$，其中$G_{1}$是从$G$删除边集合$\{e_{1},e_{2},e_{3},\ldots,e_{i}\}.$后得到的图：  
$\bullet$ 结点$v_{i}$是边$\boldsymbol{\cdot}\boldsymbol{e}_{i+1}$的端点。  
$\bullet$ 除非无其他边可以选取，否则删除边$\boldsymbol{\cdot}\boldsymbol{e}_{i+1}$后不改变图$G_{1}$的连通性。  
3）将$e_{i+1}v_{i+1}$加入到$L_{i}$中，形成新路径$\mathopen:L_{i+1}=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\dots e_{i}v_{i}e_{i+1}v_{i+1}$，令$i=i+1$  
4）返回步骤2）重复上述过程，直到 $i=|E|$ 。  
当图模型是一个半欧拉图时候，使用上述弗洛莱算法显然也可得到其欧拉通路，请读者自己思考算法的具体步骤和要点，不再赘述。  
![图10-10 房间布局的设计图     图10-11 图模型与欧拉通路       图10-12 行走路径 ](images/1200dfbb0792a6069379408b8f0f3304dd4b6248c5b1e2f4c4917b8d0bf94d23.jpg)",定理10.1指出，一个无向图是欧拉图当且仅当它是连通图且所有结点度数均为偶数
半欧拉图,判定条件,推论10.1,,"为更好地介绍欧拉图，有必要再回顾一下前述哥尼斯堡七桥问题：哥尼斯堡小镇有一条贯穿全市的小河，河上有两个小岛，由七座桥将这两个小岛及其与河两岸进行互联，如图$10-$1(a)所示。问题是怎样才能不重复、不遗漏地走完七座桥，并回到出发点。  
![图10-1 哥尼斯堡七桥问题 ](images/f92d2bafd1492d4ec26c4c92f27d5040f5974fc8bef369b51ff49b676bd82f86.jpg)  
瑞士著名的数学家欧拉把该问题抽象成如图10-1(b)所示的图模型，其中两岸陆地和小岛分别被抽象成了 A, B, C, D 四个结点， 每个桥分别被抽象成了连接相应结点的无向边。 于是， 哥尼斯堡七桥问题就等价于图10-1(b)中是否存在一条从图中任意结点出发，经过图中所有边一次且仅一次的回路。由此得到如下欧拉图的相关定义：  
【定义10.1】设 $G=\langle V,E\rangle$是任意给定的一个图模型，通过图𝐺中所有边一次且仅一次的通路称为欧拉通路，通过图$G$中所有边一次且仅一的回路称为欧拉回路。如果图𝐺中存在欧拉回路，则称之为欧拉图，如果$G$中存在欧拉通路但不存在欧拉回路，则称之为半欧拉图。 规定平凡图为欧拉图。  
以上定义既适合无向图也适合有向图。从定义可以看出，欧拉通路是经过图中所有边的通路中长度最短的通路；欧拉回路是经过图中所有边的回路中长度最短的回路。如果仅用边来描述，那么欧拉通路和欧拉回路其实都是图中所有边的一个全排列。  
【定理10.1】设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$是欧拉图当且仅当 $G=\langle V,E\rangle$为连通图且所有结点度数均为偶数。  
【  
【推论10.1】设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$是半欧拉图当  
且仅当 $G=\langle V,E\rangle$为连通图且恰有2 个奇度数结点。  
由推论10.1 可知，如果$G$是连通图且刚好有奇度结点，那么在$G$中存在一条欧拉道路，且一定以其中一个奇度结点为始点，以另一个奇度结点为终点。  
下面进一步给出有向欧拉图和半欧拉图的判定定理：  
【定理10.2】设 $G=\langle V,E\rangle$是任意给定的一个有向图模型，则有：$G=\langle V,E\rangle$是欧拉图当且仅当 $G=\langle V,E\rangle$为连通图且所有结点的入度等等于出度；$G=\langle V,E\rangle$是半欧拉图，当且仅当$G=\langle V,E\rangle$连通且仅有一个结点的入度比出度大1，另外一个结点的出度比入度大1，其余结点的入度等于出度。  
对于一个欧拉图或半欧拉图，可以使用弗洛莱算法自动找到其欧拉回路或欧拉通路。该算法的基本思路是首先从图中的任一点出发，随机去掉与此点相连的边，然后在保证以下两个条件的基础上，依次去掉与之相连的边：  
1）如果去掉某边后使得该边的某端点为孤立结点，则将该端点与该边一并去掉。  
2）在去掉某边后，不能造成图模型的不连通。  
当算法停止时，获得的路径$L=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\ldots e_{n}v_{n}(v_{0}=v_{n})$就是图$G=\langle V,E\rangle$的一条欧拉回路。弗洛莱算法的具体步骤如下：  
1) 首先，在结点集𝑉中任选一个结点$v_{0}$为初始结点，并设初始通路为$L_{0}=v_{0}$。 2) 设已选好的简单通路为$\boldsymbol{\cdot}L_{i}=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\ldots e_{i}v_{i}$，按照下列条件从边集合：  
$$
E-\{e_{1},e_{2},e_{3},\ldots,e_{i}\}
$$  
中选取边]${e}_{i+1}$，其中$G_{1}$是从$G$删除边集合$\{e_{1},e_{2},e_{3},\ldots,e_{i}\}.$后得到的图：  
$\bullet$ 结点$v_{i}$是边$\boldsymbol{\cdot}\boldsymbol{e}_{i+1}$的端点。  
$\bullet$ 除非无其他边可以选取，否则删除边$\boldsymbol{\cdot}\boldsymbol{e}_{i+1}$后不改变图$G_{1}$的连通性。  
3）将$e_{i+1}v_{i+1}$加入到$L_{i}$中，形成新路径$\mathopen:L_{i+1}=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\dots e_{i}v_{i}e_{i+1}v_{i+1}$，令$i=i+1$  
4）返回步骤2）重复上述过程，直到 $i=|E|$ 。  
当图模型是一个半欧拉图时候，使用上述弗洛莱算法显然也可得到其欧拉通路，请读者自己思考算法的具体步骤和要点，不再赘述。  
![图10-10 房间布局的设计图     图10-11 图模型与欧拉通路       图10-12 行走路径 ](images/1200dfbb0792a6069379408b8f0f3304dd4b6248c5b1e2f4c4917b8d0bf94d23.jpg)",推论10.1指出，一个无向图是半欧拉图当且仅当它是连通图且恰有2个奇度数结点
欧拉图,判定条件,定理10.2,,"为更好地介绍欧拉图，有必要再回顾一下前述哥尼斯堡七桥问题：哥尼斯堡小镇有一条贯穿全市的小河，河上有两个小岛，由七座桥将这两个小岛及其与河两岸进行互联，如图$10-$1(a)所示。问题是怎样才能不重复、不遗漏地走完七座桥，并回到出发点。  
![图10-1 哥尼斯堡七桥问题 ](images/f92d2bafd1492d4ec26c4c92f27d5040f5974fc8bef369b51ff49b676bd82f86.jpg)  
瑞士著名的数学家欧拉把该问题抽象成如图10-1(b)所示的图模型，其中两岸陆地和小岛分别被抽象成了 A, B, C, D 四个结点， 每个桥分别被抽象成了连接相应结点的无向边。 于是， 哥尼斯堡七桥问题就等价于图10-1(b)中是否存在一条从图中任意结点出发，经过图中所有边一次且仅一次的回路。由此得到如下欧拉图的相关定义：  
【定义10.1】设 $G=\langle V,E\rangle$是任意给定的一个图模型，通过图𝐺中所有边一次且仅一次的通路称为欧拉通路，通过图$G$中所有边一次且仅一的回路称为欧拉回路。如果图𝐺中存在欧拉回路，则称之为欧拉图，如果$G$中存在欧拉通路但不存在欧拉回路，则称之为半欧拉图。 规定平凡图为欧拉图。  
以上定义既适合无向图也适合有向图。从定义可以看出，欧拉通路是经过图中所有边的通路中长度最短的通路；欧拉回路是经过图中所有边的回路中长度最短的回路。如果仅用边来描述，那么欧拉通路和欧拉回路其实都是图中所有边的一个全排列。  
【定理10.1】设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$是欧拉图当且仅当 $G=\langle V,E\rangle$为连通图且所有结点度数均为偶数。  
【  
【推论10.1】设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$是半欧拉图当  
且仅当 $G=\langle V,E\rangle$为连通图且恰有2 个奇度数结点。  
由推论10.1 可知，如果$G$是连通图且刚好有奇度结点，那么在$G$中存在一条欧拉道路，且一定以其中一个奇度结点为始点，以另一个奇度结点为终点。  
下面进一步给出有向欧拉图和半欧拉图的判定定理：  
【定理10.2】设 $G=\langle V,E\rangle$是任意给定的一个有向图模型，则有：$G=\langle V,E\rangle$是欧拉图当且仅当 $G=\langle V,E\rangle$为连通图且所有结点的入度等等于出度；$G=\langle V,E\rangle$是半欧拉图，当且仅当$G=\langle V,E\rangle$连通且仅有一个结点的入度比出度大1，另外一个结点的出度比入度大1，其余结点的入度等于出度。  
对于一个欧拉图或半欧拉图，可以使用弗洛莱算法自动找到其欧拉回路或欧拉通路。该算法的基本思路是首先从图中的任一点出发，随机去掉与此点相连的边，然后在保证以下两个条件的基础上，依次去掉与之相连的边：  
1）如果去掉某边后使得该边的某端点为孤立结点，则将该端点与该边一并去掉。  
2）在去掉某边后，不能造成图模型的不连通。  
当算法停止时，获得的路径$L=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\ldots e_{n}v_{n}(v_{0}=v_{n})$就是图$G=\langle V,E\rangle$的一条欧拉回路。弗洛莱算法的具体步骤如下：  
1) 首先，在结点集𝑉中任选一个结点$v_{0}$为初始结点，并设初始通路为$L_{0}=v_{0}$。 2) 设已选好的简单通路为$\boldsymbol{\cdot}L_{i}=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\ldots e_{i}v_{i}$，按照下列条件从边集合：  
$$
E-\{e_{1},e_{2},e_{3},\ldots,e_{i}\}
$$  
中选取边]${e}_{i+1}$，其中$G_{1}$是从$G$删除边集合$\{e_{1},e_{2},e_{3},\ldots,e_{i}\}.$后得到的图：  
$\bullet$ 结点$v_{i}$是边$\boldsymbol{\cdot}\boldsymbol{e}_{i+1}$的端点。  
$\bullet$ 除非无其他边可以选取，否则删除边$\boldsymbol{\cdot}\boldsymbol{e}_{i+1}$后不改变图$G_{1}$的连通性。  
3）将$e_{i+1}v_{i+1}$加入到$L_{i}$中，形成新路径$\mathopen:L_{i+1}=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\dots e_{i}v_{i}e_{i+1}v_{i+1}$，令$i=i+1$  
4）返回步骤2）重复上述过程，直到 $i=|E|$ 。  
当图模型是一个半欧拉图时候，使用上述弗洛莱算法显然也可得到其欧拉通路，请读者自己思考算法的具体步骤和要点，不再赘述。  
![图10-10 房间布局的设计图     图10-11 图模型与欧拉通路       图10-12 行走路径 ](images/1200dfbb0792a6069379408b8f0f3304dd4b6248c5b1e2f4c4917b8d0bf94d23.jpg)",定理10.2指出，一个有向图是欧拉图当且仅当它是连通图且所有结点的入度等于出度
半欧拉图,判定条件,定理10.2,,"为更好地介绍欧拉图，有必要再回顾一下前述哥尼斯堡七桥问题：哥尼斯堡小镇有一条贯穿全市的小河，河上有两个小岛，由七座桥将这两个小岛及其与河两岸进行互联，如图$10-$1(a)所示。问题是怎样才能不重复、不遗漏地走完七座桥，并回到出发点。  
![图10-1 哥尼斯堡七桥问题 ](images/f92d2bafd1492d4ec26c4c92f27d5040f5974fc8bef369b51ff49b676bd82f86.jpg)  
瑞士著名的数学家欧拉把该问题抽象成如图10-1(b)所示的图模型，其中两岸陆地和小岛分别被抽象成了 A, B, C, D 四个结点， 每个桥分别被抽象成了连接相应结点的无向边。 于是， 哥尼斯堡七桥问题就等价于图10-1(b)中是否存在一条从图中任意结点出发，经过图中所有边一次且仅一次的回路。由此得到如下欧拉图的相关定义：  
【定义10.1】设 $G=\langle V,E\rangle$是任意给定的一个图模型，通过图𝐺中所有边一次且仅一次的通路称为欧拉通路，通过图$G$中所有边一次且仅一的回路称为欧拉回路。如果图𝐺中存在欧拉回路，则称之为欧拉图，如果$G$中存在欧拉通路但不存在欧拉回路，则称之为半欧拉图。 规定平凡图为欧拉图。  
以上定义既适合无向图也适合有向图。从定义可以看出，欧拉通路是经过图中所有边的通路中长度最短的通路；欧拉回路是经过图中所有边的回路中长度最短的回路。如果仅用边来描述，那么欧拉通路和欧拉回路其实都是图中所有边的一个全排列。  
【定理10.1】设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$是欧拉图当且仅当 $G=\langle V,E\rangle$为连通图且所有结点度数均为偶数。  
【  
【推论10.1】设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$是半欧拉图当  
且仅当 $G=\langle V,E\rangle$为连通图且恰有2 个奇度数结点。  
由推论10.1 可知，如果$G$是连通图且刚好有奇度结点，那么在$G$中存在一条欧拉道路，且一定以其中一个奇度结点为始点，以另一个奇度结点为终点。  
下面进一步给出有向欧拉图和半欧拉图的判定定理：  
【定理10.2】设 $G=\langle V,E\rangle$是任意给定的一个有向图模型，则有：$G=\langle V,E\rangle$是欧拉图当且仅当 $G=\langle V,E\rangle$为连通图且所有结点的入度等等于出度；$G=\langle V,E\rangle$是半欧拉图，当且仅当$G=\langle V,E\rangle$连通且仅有一个结点的入度比出度大1，另外一个结点的出度比入度大1，其余结点的入度等于出度。  
对于一个欧拉图或半欧拉图，可以使用弗洛莱算法自动找到其欧拉回路或欧拉通路。该算法的基本思路是首先从图中的任一点出发，随机去掉与此点相连的边，然后在保证以下两个条件的基础上，依次去掉与之相连的边：  
1）如果去掉某边后使得该边的某端点为孤立结点，则将该端点与该边一并去掉。  
2）在去掉某边后，不能造成图模型的不连通。  
当算法停止时，获得的路径$L=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\ldots e_{n}v_{n}(v_{0}=v_{n})$就是图$G=\langle V,E\rangle$的一条欧拉回路。弗洛莱算法的具体步骤如下：  
1) 首先，在结点集𝑉中任选一个结点$v_{0}$为初始结点，并设初始通路为$L_{0}=v_{0}$。 2) 设已选好的简单通路为$\boldsymbol{\cdot}L_{i}=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\ldots e_{i}v_{i}$，按照下列条件从边集合：  
$$
E-\{e_{1},e_{2},e_{3},\ldots,e_{i}\}
$$  
中选取边]${e}_{i+1}$，其中$G_{1}$是从$G$删除边集合$\{e_{1},e_{2},e_{3},\ldots,e_{i}\}.$后得到的图：  
$\bullet$ 结点$v_{i}$是边$\boldsymbol{\cdot}\boldsymbol{e}_{i+1}$的端点。  
$\bullet$ 除非无其他边可以选取，否则删除边$\boldsymbol{\cdot}\boldsymbol{e}_{i+1}$后不改变图$G_{1}$的连通性。  
3）将$e_{i+1}v_{i+1}$加入到$L_{i}$中，形成新路径$\mathopen:L_{i+1}=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\dots e_{i}v_{i}e_{i+1}v_{i+1}$，令$i=i+1$  
4）返回步骤2）重复上述过程，直到 $i=|E|$ 。  
当图模型是一个半欧拉图时候，使用上述弗洛莱算法显然也可得到其欧拉通路，请读者自己思考算法的具体步骤和要点，不再赘述。  
![图10-10 房间布局的设计图     图10-11 图模型与欧拉通路       图10-12 行走路径 ](images/1200dfbb0792a6069379408b8f0f3304dd4b6248c5b1e2f4c4917b8d0bf94d23.jpg)",定理10.2指出，一个有向图是半欧拉图当且仅当它是连通图且仅有一个结点的入度比出度大1，另外一个结点的出度比入度大1，其余结点的入度等于出度
欧拉图,应用,弗洛莱算法,,"为更好地介绍欧拉图，有必要再回顾一下前述哥尼斯堡七桥问题：哥尼斯堡小镇有一条贯穿全市的小河，河上有两个小岛，由七座桥将这两个小岛及其与河两岸进行互联，如图$10-$1(a)所示。问题是怎样才能不重复、不遗漏地走完七座桥，并回到出发点。  
![图10-1 哥尼斯堡七桥问题 ](images/f92d2bafd1492d4ec26c4c92f27d5040f5974fc8bef369b51ff49b676bd82f86.jpg)  
瑞士著名的数学家欧拉把该问题抽象成如图10-1(b)所示的图模型，其中两岸陆地和小岛分别被抽象成了 A, B, C, D 四个结点， 每个桥分别被抽象成了连接相应结点的无向边。 于是， 哥尼斯堡七桥问题就等价于图10-1(b)中是否存在一条从图中任意结点出发，经过图中所有边一次且仅一次的回路。由此得到如下欧拉图的相关定义：  
【定义10.1】设 $G=\langle V,E\rangle$是任意给定的一个图模型，通过图𝐺中所有边一次且仅一次的通路称为欧拉通路，通过图$G$中所有边一次且仅一的回路称为欧拉回路。如果图𝐺中存在欧拉回路，则称之为欧拉图，如果$G$中存在欧拉通路但不存在欧拉回路，则称之为半欧拉图。 规定平凡图为欧拉图。  
以上定义既适合无向图也适合有向图。从定义可以看出，欧拉通路是经过图中所有边的通路中长度最短的通路；欧拉回路是经过图中所有边的回路中长度最短的回路。如果仅用边来描述，那么欧拉通路和欧拉回路其实都是图中所有边的一个全排列。  
【定理10.1】设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$是欧拉图当且仅当 $G=\langle V,E\rangle$为连通图且所有结点度数均为偶数。  
【  
【推论10.1】设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$是半欧拉图当  
且仅当 $G=\langle V,E\rangle$为连通图且恰有2 个奇度数结点。  
由推论10.1 可知，如果$G$是连通图且刚好有奇度结点，那么在$G$中存在一条欧拉道路，且一定以其中一个奇度结点为始点，以另一个奇度结点为终点。  
下面进一步给出有向欧拉图和半欧拉图的判定定理：  
【定理10.2】设 $G=\langle V,E\rangle$是任意给定的一个有向图模型，则有：$G=\langle V,E\rangle$是欧拉图当且仅当 $G=\langle V,E\rangle$为连通图且所有结点的入度等等于出度；$G=\langle V,E\rangle$是半欧拉图，当且仅当$G=\langle V,E\rangle$连通且仅有一个结点的入度比出度大1，另外一个结点的出度比入度大1，其余结点的入度等于出度。  
对于一个欧拉图或半欧拉图，可以使用弗洛莱算法自动找到其欧拉回路或欧拉通路。该算法的基本思路是首先从图中的任一点出发，随机去掉与此点相连的边，然后在保证以下两个条件的基础上，依次去掉与之相连的边：  
1）如果去掉某边后使得该边的某端点为孤立结点，则将该端点与该边一并去掉。  
2）在去掉某边后，不能造成图模型的不连通。  
当算法停止时，获得的路径$L=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\ldots e_{n}v_{n}(v_{0}=v_{n})$就是图$G=\langle V,E\rangle$的一条欧拉回路。弗洛莱算法的具体步骤如下：  
1) 首先，在结点集𝑉中任选一个结点$v_{0}$为初始结点，并设初始通路为$L_{0}=v_{0}$。 2) 设已选好的简单通路为$\boldsymbol{\cdot}L_{i}=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\ldots e_{i}v_{i}$，按照下列条件从边集合：  
$$
E-\{e_{1},e_{2},e_{3},\ldots,e_{i}\}
$$  
中选取边]${e}_{i+1}$，其中$G_{1}$是从$G$删除边集合$\{e_{1},e_{2},e_{3},\ldots,e_{i}\}.$后得到的图：  
$\bullet$ 结点$v_{i}$是边$\boldsymbol{\cdot}\boldsymbol{e}_{i+1}$的端点。  
$\bullet$ 除非无其他边可以选取，否则删除边$\boldsymbol{\cdot}\boldsymbol{e}_{i+1}$后不改变图$G_{1}$的连通性。  
3）将$e_{i+1}v_{i+1}$加入到$L_{i}$中，形成新路径$\mathopen:L_{i+1}=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\dots e_{i}v_{i}e_{i+1}v_{i+1}$，令$i=i+1$  
4）返回步骤2）重复上述过程，直到 $i=|E|$ 。  
当图模型是一个半欧拉图时候，使用上述弗洛莱算法显然也可得到其欧拉通路，请读者自己思考算法的具体步骤和要点，不再赘述。  
![图10-10 房间布局的设计图     图10-11 图模型与欧拉通路       图10-12 行走路径 ](images/1200dfbb0792a6069379408b8f0f3304dd4b6248c5b1e2f4c4917b8d0bf94d23.jpg)",弗洛莱算法可以用于找到欧拉图的欧拉回路
半欧拉图,应用,弗洛莱算法,,"为更好地介绍欧拉图，有必要再回顾一下前述哥尼斯堡七桥问题：哥尼斯堡小镇有一条贯穿全市的小河，河上有两个小岛，由七座桥将这两个小岛及其与河两岸进行互联，如图$10-$1(a)所示。问题是怎样才能不重复、不遗漏地走完七座桥，并回到出发点。  
![图10-1 哥尼斯堡七桥问题 ](images/f92d2bafd1492d4ec26c4c92f27d5040f5974fc8bef369b51ff49b676bd82f86.jpg)  
瑞士著名的数学家欧拉把该问题抽象成如图10-1(b)所示的图模型，其中两岸陆地和小岛分别被抽象成了 A, B, C, D 四个结点， 每个桥分别被抽象成了连接相应结点的无向边。 于是， 哥尼斯堡七桥问题就等价于图10-1(b)中是否存在一条从图中任意结点出发，经过图中所有边一次且仅一次的回路。由此得到如下欧拉图的相关定义：  
【定义10.1】设 $G=\langle V,E\rangle$是任意给定的一个图模型，通过图𝐺中所有边一次且仅一次的通路称为欧拉通路，通过图$G$中所有边一次且仅一的回路称为欧拉回路。如果图𝐺中存在欧拉回路，则称之为欧拉图，如果$G$中存在欧拉通路但不存在欧拉回路，则称之为半欧拉图。 规定平凡图为欧拉图。  
以上定义既适合无向图也适合有向图。从定义可以看出，欧拉通路是经过图中所有边的通路中长度最短的通路；欧拉回路是经过图中所有边的回路中长度最短的回路。如果仅用边来描述，那么欧拉通路和欧拉回路其实都是图中所有边的一个全排列。  
【定理10.1】设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$是欧拉图当且仅当 $G=\langle V,E\rangle$为连通图且所有结点度数均为偶数。  
【  
【推论10.1】设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$是半欧拉图当  
且仅当 $G=\langle V,E\rangle$为连通图且恰有2 个奇度数结点。  
由推论10.1 可知，如果$G$是连通图且刚好有奇度结点，那么在$G$中存在一条欧拉道路，且一定以其中一个奇度结点为始点，以另一个奇度结点为终点。  
下面进一步给出有向欧拉图和半欧拉图的判定定理：  
【定理10.2】设 $G=\langle V,E\rangle$是任意给定的一个有向图模型，则有：$G=\langle V,E\rangle$是欧拉图当且仅当 $G=\langle V,E\rangle$为连通图且所有结点的入度等等于出度；$G=\langle V,E\rangle$是半欧拉图，当且仅当$G=\langle V,E\rangle$连通且仅有一个结点的入度比出度大1，另外一个结点的出度比入度大1，其余结点的入度等于出度。  
对于一个欧拉图或半欧拉图，可以使用弗洛莱算法自动找到其欧拉回路或欧拉通路。该算法的基本思路是首先从图中的任一点出发，随机去掉与此点相连的边，然后在保证以下两个条件的基础上，依次去掉与之相连的边：  
1）如果去掉某边后使得该边的某端点为孤立结点，则将该端点与该边一并去掉。  
2）在去掉某边后，不能造成图模型的不连通。  
当算法停止时，获得的路径$L=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\ldots e_{n}v_{n}(v_{0}=v_{n})$就是图$G=\langle V,E\rangle$的一条欧拉回路。弗洛莱算法的具体步骤如下：  
1) 首先，在结点集𝑉中任选一个结点$v_{0}$为初始结点，并设初始通路为$L_{0}=v_{0}$。 2) 设已选好的简单通路为$\boldsymbol{\cdot}L_{i}=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\ldots e_{i}v_{i}$，按照下列条件从边集合：  
$$
E-\{e_{1},e_{2},e_{3},\ldots,e_{i}\}
$$  
中选取边]${e}_{i+1}$，其中$G_{1}$是从$G$删除边集合$\{e_{1},e_{2},e_{3},\ldots,e_{i}\}.$后得到的图：  
$\bullet$ 结点$v_{i}$是边$\boldsymbol{\cdot}\boldsymbol{e}_{i+1}$的端点。  
$\bullet$ 除非无其他边可以选取，否则删除边$\boldsymbol{\cdot}\boldsymbol{e}_{i+1}$后不改变图$G_{1}$的连通性。  
3）将$e_{i+1}v_{i+1}$加入到$L_{i}$中，形成新路径$\mathopen:L_{i+1}=v_{0}e_{1}v_{1}e_{2}v_{2}e_{3}\dots e_{i}v_{i}e_{i+1}v_{i+1}$，令$i=i+1$  
4）返回步骤2）重复上述过程，直到 $i=|E|$ 。  
当图模型是一个半欧拉图时候，使用上述弗洛莱算法显然也可得到其欧拉通路，请读者自己思考算法的具体步骤和要点，不再赘述。  
![图10-10 房间布局的设计图     图10-11 图模型与欧拉通路       图10-12 行走路径 ](images/1200dfbb0792a6069379408b8f0f3304dd4b6248c5b1e2f4c4917b8d0bf94d23.jpg)",弗洛莱算法可以用于找到半欧拉图的欧拉通路
哈密顿图,包含,哈密顿通路,,"与哥尼斯堡七桥问题类似，哈密顿图模型也是来源于一个有趣的实例。1856 年，著名的爱尔兰数学家哈密顿在给朋友的信中谈到一个关于如图10-13 所示十二面体的数学问题：把每个结点看成是一个城市，连接两个结点的边看成交通线，能否找到一条旅行线路，沿着交通线经过十二面体的全部20 个城市一次且仅一次，然后再回到原来的出发点？对于这个问题，哈密顿将如图10-13（a）所示十二面体展开成如图10-13（b）所示的图模型，并给出了如图10-12（c）所示的回路，哈密顿图和哈密顿回路由此得名。  
![图10-13 十二面体的数学问题  ](images/f9d9b1ce93d10109a19c31e0468e3a1ce9ead26e329e520a14ed719c39c74609.jpg)  
【定义10.2】经过图中每个结点一次且仅一次的通路称为哈密顿通路。经过图中每个结点一次且仅一次的回路称为哈密顿回路。存在哈密顿回路的图称为哈密顿图；存在哈密顿通路的图称为半哈密顿图。规定平凡图为哈密顿图。  
显然，哈密顿通路是经过图中所有结点的最短通路，即经过图中所有结点的基本通路。哈密顿回路是经过图中所有结点的最短回路，即经过图中所有结点的基本回路。事实上，哈密顿通路就是图中所有结点的一个全排列。  
![图 10-14  哈密顿图与非哈密顿图 ](images/428b9e316b5acee7d3001e928f0a06090173f2550480e12bbb7942d43098f612.jpg)  
例如，在图10-14 中，图$G_{1}$存在哈密顿通路，但是不存在哈密顿回路，故图$G_{1}$是半哈密顿图；图$G_{2}$存在哈密顿回路，故图$G_{2}$是哈密顿图；图$G_{3}$既不存在哈密顿通路，更不存在哈密顿回路，故图$G_{3}$既不是哈密顿图，更不是半哈密顿图。  
相比欧拉图，哈密顿图的研究要困难得多。因为对图中每个结点的遍历需要让每个结点都具有一定数量的边供遍历路径的选择，也是就说对每个结点的度有一定的数量要求，但是这种度的数量又与图模型的具体结构有非常密切且隐含关系。总的来说，就是要求图中结点的度数不能太少且分布比较均衡，但是又很难量化这种条件。因此，目前还没有找到能够直接判定一个图是哈密顿图的充分必要条件。首先给出哈密顿图的一个必要条件：  
【定理10.3】设无向图$G=\langle V,E\rangle$是哈密顿图，则对于𝑉的任意非空子集$.V_{1}$，均有：
$$
p(G-V_{1})\leq|V_{1}|
$$  
其中$p(G-V_{1})$是从图$G$中删除$\cdot V_{1}$后所得图的连通分支数。  
【推论10.2】设无向图$G=\langle V,E\rangle$是半哈密顿图，则$V_{1}$是𝑉的任意非空子集，均有：  
$$
p(G-V_{1})\leq|V_{1}|+1
$$  
定理10.3 和推论10.2 表明，在图中所有结点总度数确定的情况下，要使一个图模型为哈密顿图，就必须使得度数的分配比较均衡。因为如果图的度数集中分布到某一个或某几个结点，则删除这些结点后，会使得图中的边数大量减少，导致图的连通分支数目大量增加，即有 $p(G-V_{1})>|V_{1}|$ 或 $p(G-V_{1})>|V_{1}|+1$ ，此时就违背了上述定理或推论的条件。  
值得注意的是，定理10.3 和推论10.2 是必要而非充分条件。例如，对于图10-16 所示的彼得森图，该图显然满足定理10.3 的条件，但它不是哈密顿图。因此，定理10.3 和推论10.2 主要用于对哈密顿图的证伪。下面给出判定哈密顿图或者半哈密顿图的充分条件：  
【定理10.4】设图$G=\langle V,E\rangle$是任意给定的$n$阶无向简单图，如果对任意两个不相邻的结点$u,v\in V$，均有：  
$$
\deg(u)+\deg(v)\geq n-1
$$  
则图$G$中存在哈密顿通路。  
【定理10.5】（奥尔定理）设图$G=\langle V,E\rangle$是$n$阶无向简单图，如果对任意两个不相邻的结点$u,v\in V$，均有：  
$$
\deg(u)+\deg(v)\geq n
$$  
则图$G$中存在哈密顿回路。  
【定理10.6】（狄拉克定理）设图$G=\langle V,E\rangle$是$n$阶无向简单图，如果对于图中结点𝑣∈𝑉，均有$\deg(v)\geq n/2$ ，则图$G$中存在哈密顿回路。  
定理10.4、定理10.5 和定理10.6 给出了判定哈密顿图的充分条件，其中狄拉克定理可以看成是奥尔定理的一个推论。上述3 个定理表明，如果要使得一个图是哈密顿图，就必须保证图中有足够多的边并分布基本均衡，或者说图中每个结点都要关联足够多的边。不难看出，这些条件是比较强的或者说是比较苛刻的。事实上，这些条件并非必要条件。例如，一条具10 个结点的链显然是半哈密顿图，但该图并不满足定理10.4 的条件，将该链的首尾一条边相连构成的圈图显然是哈密顿图，但并不满足定理10.5 和定理10.6 的条件。",哈密顿图包含哈密顿回路，而哈密顿回路是特殊的哈密顿通路
哈密顿图,区别,半哈密顿图,,"与哥尼斯堡七桥问题类似，哈密顿图模型也是来源于一个有趣的实例。1856 年，著名的爱尔兰数学家哈密顿在给朋友的信中谈到一个关于如图10-13 所示十二面体的数学问题：把每个结点看成是一个城市，连接两个结点的边看成交通线，能否找到一条旅行线路，沿着交通线经过十二面体的全部20 个城市一次且仅一次，然后再回到原来的出发点？对于这个问题，哈密顿将如图10-13（a）所示十二面体展开成如图10-13（b）所示的图模型，并给出了如图10-12（c）所示的回路，哈密顿图和哈密顿回路由此得名。  
![图10-13 十二面体的数学问题  ](images/f9d9b1ce93d10109a19c31e0468e3a1ce9ead26e329e520a14ed719c39c74609.jpg)  
【定义10.2】经过图中每个结点一次且仅一次的通路称为哈密顿通路。经过图中每个结点一次且仅一次的回路称为哈密顿回路。存在哈密顿回路的图称为哈密顿图；存在哈密顿通路的图称为半哈密顿图。规定平凡图为哈密顿图。  
显然，哈密顿通路是经过图中所有结点的最短通路，即经过图中所有结点的基本通路。哈密顿回路是经过图中所有结点的最短回路，即经过图中所有结点的基本回路。事实上，哈密顿通路就是图中所有结点的一个全排列。  
![图 10-14  哈密顿图与非哈密顿图 ](images/428b9e316b5acee7d3001e928f0a06090173f2550480e12bbb7942d43098f612.jpg)  
例如，在图10-14 中，图$G_{1}$存在哈密顿通路，但是不存在哈密顿回路，故图$G_{1}$是半哈密顿图；图$G_{2}$存在哈密顿回路，故图$G_{2}$是哈密顿图；图$G_{3}$既不存在哈密顿通路，更不存在哈密顿回路，故图$G_{3}$既不是哈密顿图，更不是半哈密顿图。  
相比欧拉图，哈密顿图的研究要困难得多。因为对图中每个结点的遍历需要让每个结点都具有一定数量的边供遍历路径的选择，也是就说对每个结点的度有一定的数量要求，但是这种度的数量又与图模型的具体结构有非常密切且隐含关系。总的来说，就是要求图中结点的度数不能太少且分布比较均衡，但是又很难量化这种条件。因此，目前还没有找到能够直接判定一个图是哈密顿图的充分必要条件。首先给出哈密顿图的一个必要条件：  
【定理10.3】设无向图$G=\langle V,E\rangle$是哈密顿图，则对于𝑉的任意非空子集$.V_{1}$，均有：
$$
p(G-V_{1})\leq|V_{1}|
$$  
其中$p(G-V_{1})$是从图$G$中删除$\cdot V_{1}$后所得图的连通分支数。  
【推论10.2】设无向图$G=\langle V,E\rangle$是半哈密顿图，则$V_{1}$是𝑉的任意非空子集，均有：  
$$
p(G-V_{1})\leq|V_{1}|+1
$$  
定理10.3 和推论10.2 表明，在图中所有结点总度数确定的情况下，要使一个图模型为哈密顿图，就必须使得度数的分配比较均衡。因为如果图的度数集中分布到某一个或某几个结点，则删除这些结点后，会使得图中的边数大量减少，导致图的连通分支数目大量增加，即有 $p(G-V_{1})>|V_{1}|$ 或 $p(G-V_{1})>|V_{1}|+1$ ，此时就违背了上述定理或推论的条件。  
值得注意的是，定理10.3 和推论10.2 是必要而非充分条件。例如，对于图10-16 所示的彼得森图，该图显然满足定理10.3 的条件，但它不是哈密顿图。因此，定理10.3 和推论10.2 主要用于对哈密顿图的证伪。下面给出判定哈密顿图或者半哈密顿图的充分条件：  
【定理10.4】设图$G=\langle V,E\rangle$是任意给定的$n$阶无向简单图，如果对任意两个不相邻的结点$u,v\in V$，均有：  
$$
\deg(u)+\deg(v)\geq n-1
$$  
则图$G$中存在哈密顿通路。  
【定理10.5】（奥尔定理）设图$G=\langle V,E\rangle$是$n$阶无向简单图，如果对任意两个不相邻的结点$u,v\in V$，均有：  
$$
\deg(u)+\deg(v)\geq n
$$  
则图$G$中存在哈密顿回路。  
【定理10.6】（狄拉克定理）设图$G=\langle V,E\rangle$是$n$阶无向简单图，如果对于图中结点𝑣∈𝑉，均有$\deg(v)\geq n/2$ ，则图$G$中存在哈密顿回路。  
定理10.4、定理10.5 和定理10.6 给出了判定哈密顿图的充分条件，其中狄拉克定理可以看成是奥尔定理的一个推论。上述3 个定理表明，如果要使得一个图是哈密顿图，就必须保证图中有足够多的边并分布基本均衡，或者说图中每个结点都要关联足够多的边。不难看出，这些条件是比较强的或者说是比较苛刻的。事实上，这些条件并非必要条件。例如，一条具10 个结点的链显然是半哈密顿图，但该图并不满足定理10.4 的条件，将该链的首尾一条边相连构成的圈图显然是哈密顿图，但并不满足定理10.5 和定理10.6 的条件。",哈密顿图存在哈密顿回路，而半哈密顿图只存在哈密顿通路
定理10.3,必要条件,哈密顿图,,"与哥尼斯堡七桥问题类似，哈密顿图模型也是来源于一个有趣的实例。1856 年，著名的爱尔兰数学家哈密顿在给朋友的信中谈到一个关于如图10-13 所示十二面体的数学问题：把每个结点看成是一个城市，连接两个结点的边看成交通线，能否找到一条旅行线路，沿着交通线经过十二面体的全部20 个城市一次且仅一次，然后再回到原来的出发点？对于这个问题，哈密顿将如图10-13（a）所示十二面体展开成如图10-13（b）所示的图模型，并给出了如图10-12（c）所示的回路，哈密顿图和哈密顿回路由此得名。  
![图10-13 十二面体的数学问题  ](images/f9d9b1ce93d10109a19c31e0468e3a1ce9ead26e329e520a14ed719c39c74609.jpg)  
【定义10.2】经过图中每个结点一次且仅一次的通路称为哈密顿通路。经过图中每个结点一次且仅一次的回路称为哈密顿回路。存在哈密顿回路的图称为哈密顿图；存在哈密顿通路的图称为半哈密顿图。规定平凡图为哈密顿图。  
显然，哈密顿通路是经过图中所有结点的最短通路，即经过图中所有结点的基本通路。哈密顿回路是经过图中所有结点的最短回路，即经过图中所有结点的基本回路。事实上，哈密顿通路就是图中所有结点的一个全排列。  
![图 10-14  哈密顿图与非哈密顿图 ](images/428b9e316b5acee7d3001e928f0a06090173f2550480e12bbb7942d43098f612.jpg)  
例如，在图10-14 中，图$G_{1}$存在哈密顿通路，但是不存在哈密顿回路，故图$G_{1}$是半哈密顿图；图$G_{2}$存在哈密顿回路，故图$G_{2}$是哈密顿图；图$G_{3}$既不存在哈密顿通路，更不存在哈密顿回路，故图$G_{3}$既不是哈密顿图，更不是半哈密顿图。  
相比欧拉图，哈密顿图的研究要困难得多。因为对图中每个结点的遍历需要让每个结点都具有一定数量的边供遍历路径的选择，也是就说对每个结点的度有一定的数量要求，但是这种度的数量又与图模型的具体结构有非常密切且隐含关系。总的来说，就是要求图中结点的度数不能太少且分布比较均衡，但是又很难量化这种条件。因此，目前还没有找到能够直接判定一个图是哈密顿图的充分必要条件。首先给出哈密顿图的一个必要条件：  
【定理10.3】设无向图$G=\langle V,E\rangle$是哈密顿图，则对于𝑉的任意非空子集$.V_{1}$，均有：
$$
p(G-V_{1})\leq|V_{1}|
$$  
其中$p(G-V_{1})$是从图$G$中删除$\cdot V_{1}$后所得图的连通分支数。  
【推论10.2】设无向图$G=\langle V,E\rangle$是半哈密顿图，则$V_{1}$是𝑉的任意非空子集，均有：  
$$
p(G-V_{1})\leq|V_{1}|+1
$$  
定理10.3 和推论10.2 表明，在图中所有结点总度数确定的情况下，要使一个图模型为哈密顿图，就必须使得度数的分配比较均衡。因为如果图的度数集中分布到某一个或某几个结点，则删除这些结点后，会使得图中的边数大量减少，导致图的连通分支数目大量增加，即有 $p(G-V_{1})>|V_{1}|$ 或 $p(G-V_{1})>|V_{1}|+1$ ，此时就违背了上述定理或推论的条件。  
值得注意的是，定理10.3 和推论10.2 是必要而非充分条件。例如，对于图10-16 所示的彼得森图，该图显然满足定理10.3 的条件，但它不是哈密顿图。因此，定理10.3 和推论10.2 主要用于对哈密顿图的证伪。下面给出判定哈密顿图或者半哈密顿图的充分条件：  
【定理10.4】设图$G=\langle V,E\rangle$是任意给定的$n$阶无向简单图，如果对任意两个不相邻的结点$u,v\in V$，均有：  
$$
\deg(u)+\deg(v)\geq n-1
$$  
则图$G$中存在哈密顿通路。  
【定理10.5】（奥尔定理）设图$G=\langle V,E\rangle$是$n$阶无向简单图，如果对任意两个不相邻的结点$u,v\in V$，均有：  
$$
\deg(u)+\deg(v)\geq n
$$  
则图$G$中存在哈密顿回路。  
【定理10.6】（狄拉克定理）设图$G=\langle V,E\rangle$是$n$阶无向简单图，如果对于图中结点𝑣∈𝑉，均有$\deg(v)\geq n/2$ ，则图$G$中存在哈密顿回路。  
定理10.4、定理10.5 和定理10.6 给出了判定哈密顿图的充分条件，其中狄拉克定理可以看成是奥尔定理的一个推论。上述3 个定理表明，如果要使得一个图是哈密顿图，就必须保证图中有足够多的边并分布基本均衡，或者说图中每个结点都要关联足够多的边。不难看出，这些条件是比较强的或者说是比较苛刻的。事实上，这些条件并非必要条件。例如，一条具10 个结点的链显然是半哈密顿图，但该图并不满足定理10.4 的条件，将该链的首尾一条边相连构成的圈图显然是哈密顿图，但并不满足定理10.5 和定理10.6 的条件。",定理10.3给出了哈密顿图的一个必要条件，即对于任意非空子集，删除后所得图的连通分支数不超过子集的大小
推论10.2,必要条件,半哈密顿图,,"与哥尼斯堡七桥问题类似，哈密顿图模型也是来源于一个有趣的实例。1856 年，著名的爱尔兰数学家哈密顿在给朋友的信中谈到一个关于如图10-13 所示十二面体的数学问题：把每个结点看成是一个城市，连接两个结点的边看成交通线，能否找到一条旅行线路，沿着交通线经过十二面体的全部20 个城市一次且仅一次，然后再回到原来的出发点？对于这个问题，哈密顿将如图10-13（a）所示十二面体展开成如图10-13（b）所示的图模型，并给出了如图10-12（c）所示的回路，哈密顿图和哈密顿回路由此得名。  
![图10-13 十二面体的数学问题  ](images/f9d9b1ce93d10109a19c31e0468e3a1ce9ead26e329e520a14ed719c39c74609.jpg)  
【定义10.2】经过图中每个结点一次且仅一次的通路称为哈密顿通路。经过图中每个结点一次且仅一次的回路称为哈密顿回路。存在哈密顿回路的图称为哈密顿图；存在哈密顿通路的图称为半哈密顿图。规定平凡图为哈密顿图。  
显然，哈密顿通路是经过图中所有结点的最短通路，即经过图中所有结点的基本通路。哈密顿回路是经过图中所有结点的最短回路，即经过图中所有结点的基本回路。事实上，哈密顿通路就是图中所有结点的一个全排列。  
![图 10-14  哈密顿图与非哈密顿图 ](images/428b9e316b5acee7d3001e928f0a06090173f2550480e12bbb7942d43098f612.jpg)  
例如，在图10-14 中，图$G_{1}$存在哈密顿通路，但是不存在哈密顿回路，故图$G_{1}$是半哈密顿图；图$G_{2}$存在哈密顿回路，故图$G_{2}$是哈密顿图；图$G_{3}$既不存在哈密顿通路，更不存在哈密顿回路，故图$G_{3}$既不是哈密顿图，更不是半哈密顿图。  
相比欧拉图，哈密顿图的研究要困难得多。因为对图中每个结点的遍历需要让每个结点都具有一定数量的边供遍历路径的选择，也是就说对每个结点的度有一定的数量要求，但是这种度的数量又与图模型的具体结构有非常密切且隐含关系。总的来说，就是要求图中结点的度数不能太少且分布比较均衡，但是又很难量化这种条件。因此，目前还没有找到能够直接判定一个图是哈密顿图的充分必要条件。首先给出哈密顿图的一个必要条件：  
【定理10.3】设无向图$G=\langle V,E\rangle$是哈密顿图，则对于𝑉的任意非空子集$.V_{1}$，均有：
$$
p(G-V_{1})\leq|V_{1}|
$$  
其中$p(G-V_{1})$是从图$G$中删除$\cdot V_{1}$后所得图的连通分支数。  
【推论10.2】设无向图$G=\langle V,E\rangle$是半哈密顿图，则$V_{1}$是𝑉的任意非空子集，均有：  
$$
p(G-V_{1})\leq|V_{1}|+1
$$  
定理10.3 和推论10.2 表明，在图中所有结点总度数确定的情况下，要使一个图模型为哈密顿图，就必须使得度数的分配比较均衡。因为如果图的度数集中分布到某一个或某几个结点，则删除这些结点后，会使得图中的边数大量减少，导致图的连通分支数目大量增加，即有 $p(G-V_{1})>|V_{1}|$ 或 $p(G-V_{1})>|V_{1}|+1$ ，此时就违背了上述定理或推论的条件。  
值得注意的是，定理10.3 和推论10.2 是必要而非充分条件。例如，对于图10-16 所示的彼得森图，该图显然满足定理10.3 的条件，但它不是哈密顿图。因此，定理10.3 和推论10.2 主要用于对哈密顿图的证伪。下面给出判定哈密顿图或者半哈密顿图的充分条件：  
【定理10.4】设图$G=\langle V,E\rangle$是任意给定的$n$阶无向简单图，如果对任意两个不相邻的结点$u,v\in V$，均有：  
$$
\deg(u)+\deg(v)\geq n-1
$$  
则图$G$中存在哈密顿通路。  
【定理10.5】（奥尔定理）设图$G=\langle V,E\rangle$是$n$阶无向简单图，如果对任意两个不相邻的结点$u,v\in V$，均有：  
$$
\deg(u)+\deg(v)\geq n
$$  
则图$G$中存在哈密顿回路。  
【定理10.6】（狄拉克定理）设图$G=\langle V,E\rangle$是$n$阶无向简单图，如果对于图中结点𝑣∈𝑉，均有$\deg(v)\geq n/2$ ，则图$G$中存在哈密顿回路。  
定理10.4、定理10.5 和定理10.6 给出了判定哈密顿图的充分条件，其中狄拉克定理可以看成是奥尔定理的一个推论。上述3 个定理表明，如果要使得一个图是哈密顿图，就必须保证图中有足够多的边并分布基本均衡，或者说图中每个结点都要关联足够多的边。不难看出，这些条件是比较强的或者说是比较苛刻的。事实上，这些条件并非必要条件。例如，一条具10 个结点的链显然是半哈密顿图，但该图并不满足定理10.4 的条件，将该链的首尾一条边相连构成的圈图显然是哈密顿图，但并不满足定理10.5 和定理10.6 的条件。",推论10.2给出了半哈密顿图的一个必要条件，即对于任意非空子集，删除后所得图的连通分支数不超过子集的大小加一
定理10.4,充分条件,哈密顿通路,,"与哥尼斯堡七桥问题类似，哈密顿图模型也是来源于一个有趣的实例。1856 年，著名的爱尔兰数学家哈密顿在给朋友的信中谈到一个关于如图10-13 所示十二面体的数学问题：把每个结点看成是一个城市，连接两个结点的边看成交通线，能否找到一条旅行线路，沿着交通线经过十二面体的全部20 个城市一次且仅一次，然后再回到原来的出发点？对于这个问题，哈密顿将如图10-13（a）所示十二面体展开成如图10-13（b）所示的图模型，并给出了如图10-12（c）所示的回路，哈密顿图和哈密顿回路由此得名。  
![图10-13 十二面体的数学问题  ](images/f9d9b1ce93d10109a19c31e0468e3a1ce9ead26e329e520a14ed719c39c74609.jpg)  
【定义10.2】经过图中每个结点一次且仅一次的通路称为哈密顿通路。经过图中每个结点一次且仅一次的回路称为哈密顿回路。存在哈密顿回路的图称为哈密顿图；存在哈密顿通路的图称为半哈密顿图。规定平凡图为哈密顿图。  
显然，哈密顿通路是经过图中所有结点的最短通路，即经过图中所有结点的基本通路。哈密顿回路是经过图中所有结点的最短回路，即经过图中所有结点的基本回路。事实上，哈密顿通路就是图中所有结点的一个全排列。  
![图 10-14  哈密顿图与非哈密顿图 ](images/428b9e316b5acee7d3001e928f0a06090173f2550480e12bbb7942d43098f612.jpg)  
例如，在图10-14 中，图$G_{1}$存在哈密顿通路，但是不存在哈密顿回路，故图$G_{1}$是半哈密顿图；图$G_{2}$存在哈密顿回路，故图$G_{2}$是哈密顿图；图$G_{3}$既不存在哈密顿通路，更不存在哈密顿回路，故图$G_{3}$既不是哈密顿图，更不是半哈密顿图。  
相比欧拉图，哈密顿图的研究要困难得多。因为对图中每个结点的遍历需要让每个结点都具有一定数量的边供遍历路径的选择，也是就说对每个结点的度有一定的数量要求，但是这种度的数量又与图模型的具体结构有非常密切且隐含关系。总的来说，就是要求图中结点的度数不能太少且分布比较均衡，但是又很难量化这种条件。因此，目前还没有找到能够直接判定一个图是哈密顿图的充分必要条件。首先给出哈密顿图的一个必要条件：  
【定理10.3】设无向图$G=\langle V,E\rangle$是哈密顿图，则对于𝑉的任意非空子集$.V_{1}$，均有：
$$
p(G-V_{1})\leq|V_{1}|
$$  
其中$p(G-V_{1})$是从图$G$中删除$\cdot V_{1}$后所得图的连通分支数。  
【推论10.2】设无向图$G=\langle V,E\rangle$是半哈密顿图，则$V_{1}$是𝑉的任意非空子集，均有：  
$$
p(G-V_{1})\leq|V_{1}|+1
$$  
定理10.3 和推论10.2 表明，在图中所有结点总度数确定的情况下，要使一个图模型为哈密顿图，就必须使得度数的分配比较均衡。因为如果图的度数集中分布到某一个或某几个结点，则删除这些结点后，会使得图中的边数大量减少，导致图的连通分支数目大量增加，即有 $p(G-V_{1})>|V_{1}|$ 或 $p(G-V_{1})>|V_{1}|+1$ ，此时就违背了上述定理或推论的条件。  
值得注意的是，定理10.3 和推论10.2 是必要而非充分条件。例如，对于图10-16 所示的彼得森图，该图显然满足定理10.3 的条件，但它不是哈密顿图。因此，定理10.3 和推论10.2 主要用于对哈密顿图的证伪。下面给出判定哈密顿图或者半哈密顿图的充分条件：  
【定理10.4】设图$G=\langle V,E\rangle$是任意给定的$n$阶无向简单图，如果对任意两个不相邻的结点$u,v\in V$，均有：  
$$
\deg(u)+\deg(v)\geq n-1
$$  
则图$G$中存在哈密顿通路。  
【定理10.5】（奥尔定理）设图$G=\langle V,E\rangle$是$n$阶无向简单图，如果对任意两个不相邻的结点$u,v\in V$，均有：  
$$
\deg(u)+\deg(v)\geq n
$$  
则图$G$中存在哈密顿回路。  
【定理10.6】（狄拉克定理）设图$G=\langle V,E\rangle$是$n$阶无向简单图，如果对于图中结点𝑣∈𝑉，均有$\deg(v)\geq n/2$ ，则图$G$中存在哈密顿回路。  
定理10.4、定理10.5 和定理10.6 给出了判定哈密顿图的充分条件，其中狄拉克定理可以看成是奥尔定理的一个推论。上述3 个定理表明，如果要使得一个图是哈密顿图，就必须保证图中有足够多的边并分布基本均衡，或者说图中每个结点都要关联足够多的边。不难看出，这些条件是比较强的或者说是比较苛刻的。事实上，这些条件并非必要条件。例如，一条具10 个结点的链显然是半哈密顿图，但该图并不满足定理10.4 的条件，将该链的首尾一条边相连构成的圈图显然是哈密顿图，但并不满足定理10.5 和定理10.6 的条件。",定理10.4给出了存在哈密顿通路的充分条件，即任意两个不相邻结点的度数之和大于等于图阶数减一
定理10.5,充分条件,哈密顿回路,,"与哥尼斯堡七桥问题类似，哈密顿图模型也是来源于一个有趣的实例。1856 年，著名的爱尔兰数学家哈密顿在给朋友的信中谈到一个关于如图10-13 所示十二面体的数学问题：把每个结点看成是一个城市，连接两个结点的边看成交通线，能否找到一条旅行线路，沿着交通线经过十二面体的全部20 个城市一次且仅一次，然后再回到原来的出发点？对于这个问题，哈密顿将如图10-13（a）所示十二面体展开成如图10-13（b）所示的图模型，并给出了如图10-12（c）所示的回路，哈密顿图和哈密顿回路由此得名。  
![图10-13 十二面体的数学问题  ](images/f9d9b1ce93d10109a19c31e0468e3a1ce9ead26e329e520a14ed719c39c74609.jpg)  
【定义10.2】经过图中每个结点一次且仅一次的通路称为哈密顿通路。经过图中每个结点一次且仅一次的回路称为哈密顿回路。存在哈密顿回路的图称为哈密顿图；存在哈密顿通路的图称为半哈密顿图。规定平凡图为哈密顿图。  
显然，哈密顿通路是经过图中所有结点的最短通路，即经过图中所有结点的基本通路。哈密顿回路是经过图中所有结点的最短回路，即经过图中所有结点的基本回路。事实上，哈密顿通路就是图中所有结点的一个全排列。  
![图 10-14  哈密顿图与非哈密顿图 ](images/428b9e316b5acee7d3001e928f0a06090173f2550480e12bbb7942d43098f612.jpg)  
例如，在图10-14 中，图$G_{1}$存在哈密顿通路，但是不存在哈密顿回路，故图$G_{1}$是半哈密顿图；图$G_{2}$存在哈密顿回路，故图$G_{2}$是哈密顿图；图$G_{3}$既不存在哈密顿通路，更不存在哈密顿回路，故图$G_{3}$既不是哈密顿图，更不是半哈密顿图。  
相比欧拉图，哈密顿图的研究要困难得多。因为对图中每个结点的遍历需要让每个结点都具有一定数量的边供遍历路径的选择，也是就说对每个结点的度有一定的数量要求，但是这种度的数量又与图模型的具体结构有非常密切且隐含关系。总的来说，就是要求图中结点的度数不能太少且分布比较均衡，但是又很难量化这种条件。因此，目前还没有找到能够直接判定一个图是哈密顿图的充分必要条件。首先给出哈密顿图的一个必要条件：  
【定理10.3】设无向图$G=\langle V,E\rangle$是哈密顿图，则对于𝑉的任意非空子集$.V_{1}$，均有：
$$
p(G-V_{1})\leq|V_{1}|
$$  
其中$p(G-V_{1})$是从图$G$中删除$\cdot V_{1}$后所得图的连通分支数。  
【推论10.2】设无向图$G=\langle V,E\rangle$是半哈密顿图，则$V_{1}$是𝑉的任意非空子集，均有：  
$$
p(G-V_{1})\leq|V_{1}|+1
$$  
定理10.3 和推论10.2 表明，在图中所有结点总度数确定的情况下，要使一个图模型为哈密顿图，就必须使得度数的分配比较均衡。因为如果图的度数集中分布到某一个或某几个结点，则删除这些结点后，会使得图中的边数大量减少，导致图的连通分支数目大量增加，即有 $p(G-V_{1})>|V_{1}|$ 或 $p(G-V_{1})>|V_{1}|+1$ ，此时就违背了上述定理或推论的条件。  
值得注意的是，定理10.3 和推论10.2 是必要而非充分条件。例如，对于图10-16 所示的彼得森图，该图显然满足定理10.3 的条件，但它不是哈密顿图。因此，定理10.3 和推论10.2 主要用于对哈密顿图的证伪。下面给出判定哈密顿图或者半哈密顿图的充分条件：  
【定理10.4】设图$G=\langle V,E\rangle$是任意给定的$n$阶无向简单图，如果对任意两个不相邻的结点$u,v\in V$，均有：  
$$
\deg(u)+\deg(v)\geq n-1
$$  
则图$G$中存在哈密顿通路。  
【定理10.5】（奥尔定理）设图$G=\langle V,E\rangle$是$n$阶无向简单图，如果对任意两个不相邻的结点$u,v\in V$，均有：  
$$
\deg(u)+\deg(v)\geq n
$$  
则图$G$中存在哈密顿回路。  
【定理10.6】（狄拉克定理）设图$G=\langle V,E\rangle$是$n$阶无向简单图，如果对于图中结点𝑣∈𝑉，均有$\deg(v)\geq n/2$ ，则图$G$中存在哈密顿回路。  
定理10.4、定理10.5 和定理10.6 给出了判定哈密顿图的充分条件，其中狄拉克定理可以看成是奥尔定理的一个推论。上述3 个定理表明，如果要使得一个图是哈密顿图，就必须保证图中有足够多的边并分布基本均衡，或者说图中每个结点都要关联足够多的边。不难看出，这些条件是比较强的或者说是比较苛刻的。事实上，这些条件并非必要条件。例如，一条具10 个结点的链显然是半哈密顿图，但该图并不满足定理10.4 的条件，将该链的首尾一条边相连构成的圈图显然是哈密顿图，但并不满足定理10.5 和定理10.6 的条件。",定理10.5给出了存在哈密顿回路的充分条件，即任意两个不相邻结点的度数之和大于等于图阶数
定理10.6,充分条件,哈密顿回路,,"与哥尼斯堡七桥问题类似，哈密顿图模型也是来源于一个有趣的实例。1856 年，著名的爱尔兰数学家哈密顿在给朋友的信中谈到一个关于如图10-13 所示十二面体的数学问题：把每个结点看成是一个城市，连接两个结点的边看成交通线，能否找到一条旅行线路，沿着交通线经过十二面体的全部20 个城市一次且仅一次，然后再回到原来的出发点？对于这个问题，哈密顿将如图10-13（a）所示十二面体展开成如图10-13（b）所示的图模型，并给出了如图10-12（c）所示的回路，哈密顿图和哈密顿回路由此得名。  
![图10-13 十二面体的数学问题  ](images/f9d9b1ce93d10109a19c31e0468e3a1ce9ead26e329e520a14ed719c39c74609.jpg)  
【定义10.2】经过图中每个结点一次且仅一次的通路称为哈密顿通路。经过图中每个结点一次且仅一次的回路称为哈密顿回路。存在哈密顿回路的图称为哈密顿图；存在哈密顿通路的图称为半哈密顿图。规定平凡图为哈密顿图。  
显然，哈密顿通路是经过图中所有结点的最短通路，即经过图中所有结点的基本通路。哈密顿回路是经过图中所有结点的最短回路，即经过图中所有结点的基本回路。事实上，哈密顿通路就是图中所有结点的一个全排列。  
![图 10-14  哈密顿图与非哈密顿图 ](images/428b9e316b5acee7d3001e928f0a06090173f2550480e12bbb7942d43098f612.jpg)  
例如，在图10-14 中，图$G_{1}$存在哈密顿通路，但是不存在哈密顿回路，故图$G_{1}$是半哈密顿图；图$G_{2}$存在哈密顿回路，故图$G_{2}$是哈密顿图；图$G_{3}$既不存在哈密顿通路，更不存在哈密顿回路，故图$G_{3}$既不是哈密顿图，更不是半哈密顿图。  
相比欧拉图，哈密顿图的研究要困难得多。因为对图中每个结点的遍历需要让每个结点都具有一定数量的边供遍历路径的选择，也是就说对每个结点的度有一定的数量要求，但是这种度的数量又与图模型的具体结构有非常密切且隐含关系。总的来说，就是要求图中结点的度数不能太少且分布比较均衡，但是又很难量化这种条件。因此，目前还没有找到能够直接判定一个图是哈密顿图的充分必要条件。首先给出哈密顿图的一个必要条件：  
【定理10.3】设无向图$G=\langle V,E\rangle$是哈密顿图，则对于𝑉的任意非空子集$.V_{1}$，均有：
$$
p(G-V_{1})\leq|V_{1}|
$$  
其中$p(G-V_{1})$是从图$G$中删除$\cdot V_{1}$后所得图的连通分支数。  
【推论10.2】设无向图$G=\langle V,E\rangle$是半哈密顿图，则$V_{1}$是𝑉的任意非空子集，均有：  
$$
p(G-V_{1})\leq|V_{1}|+1
$$  
定理10.3 和推论10.2 表明，在图中所有结点总度数确定的情况下，要使一个图模型为哈密顿图，就必须使得度数的分配比较均衡。因为如果图的度数集中分布到某一个或某几个结点，则删除这些结点后，会使得图中的边数大量减少，导致图的连通分支数目大量增加，即有 $p(G-V_{1})>|V_{1}|$ 或 $p(G-V_{1})>|V_{1}|+1$ ，此时就违背了上述定理或推论的条件。  
值得注意的是，定理10.3 和推论10.2 是必要而非充分条件。例如，对于图10-16 所示的彼得森图，该图显然满足定理10.3 的条件，但它不是哈密顿图。因此，定理10.3 和推论10.2 主要用于对哈密顿图的证伪。下面给出判定哈密顿图或者半哈密顿图的充分条件：  
【定理10.4】设图$G=\langle V,E\rangle$是任意给定的$n$阶无向简单图，如果对任意两个不相邻的结点$u,v\in V$，均有：  
$$
\deg(u)+\deg(v)\geq n-1
$$  
则图$G$中存在哈密顿通路。  
【定理10.5】（奥尔定理）设图$G=\langle V,E\rangle$是$n$阶无向简单图，如果对任意两个不相邻的结点$u,v\in V$，均有：  
$$
\deg(u)+\deg(v)\geq n
$$  
则图$G$中存在哈密顿回路。  
【定理10.6】（狄拉克定理）设图$G=\langle V,E\rangle$是$n$阶无向简单图，如果对于图中结点𝑣∈𝑉，均有$\deg(v)\geq n/2$ ，则图$G$中存在哈密顿回路。  
定理10.4、定理10.5 和定理10.6 给出了判定哈密顿图的充分条件，其中狄拉克定理可以看成是奥尔定理的一个推论。上述3 个定理表明，如果要使得一个图是哈密顿图，就必须保证图中有足够多的边并分布基本均衡，或者说图中每个结点都要关联足够多的边。不难看出，这些条件是比较强的或者说是比较苛刻的。事实上，这些条件并非必要条件。例如，一条具10 个结点的链显然是半哈密顿图，但该图并不满足定理10.4 的条件，将该链的首尾一条边相连构成的圈图显然是哈密顿图，但并不满足定理10.5 和定理10.6 的条件。",定理10.6给出了存在哈密顿回路的充分条件，即每个结点的度数大于等于图阶数的一半
中国邮路问题,转化为,欧拉图,,"中国邮路问题是我国数学家管梅谷教授在1960 年提出的一个著名网络优化问题：某邮递员从邮局出发去送信，期间要走完他负责投递的所有街道，最后返回邮局。该邮递员如何选择路径才能使得所走的总路程最短？  
可以用图模型对该问题进行建模。具体地说，就是将该邮递员负责投递的每条街道抽象成一条无向边，街道道口抽象成结点，构成一个无向连通图$G=\langle V,E\rangle$。若将每条道路的长度抽象成其所对应边的权值，则中国邮路问题可转化为如下关于图模型的问题：对于任意给定的一个连通图$G=\langle V,E\rangle$，如何遍历图中每条边，使得总路线最短（权重之和最小）。  
如果$G=\langle V,E\rangle$是一个欧拉图，则中国邮路问题的解显然就是该图的欧拉回路。因为根据问题要求，图中每条边必须至少经过一次，欧拉回路则是每条边经过且仅经过一次。这是最好的情形，可用弗洛莱算法得到具体的欧拉回路实现对该问题的求解。  
然而，如果$G=\langle V,E\rangle$不是一个欧拉图，那么就不能保证每条边仅通过一次，有些边需要两次。此时，让哪条边或哪些边通过两次则是一个需要认真考虑的问题。最直观的想法就是让权最小的边通过两次，但如此并不能保证能够遍历每条边。因此，基本的求解思路是在保证完成对边遍历的前提下，让权值尽可能小的边通过两次。换句话说，就是如何在图中添加权值尽可能小重复边，使得该图变成一个欧拉图。下面给出具体求解方案：  
我们知道，一个连通图之所以不是欧拉图，是因为图中存在偶数个奇度数结点。因此，需要将这些，将其强制性变成欧拉图。具体地说，就是以这些奇度点为结点，添加一些边，使得这些奇度结点变成偶度结点。 得到欧拉图之后，还要判断该欧拉图是否为最优， 也就是 说通过该欧拉图得到的总权值是否最小，否则就要对其做进一步优化。  
因此，中国邮路问题的基本求解思路为：若抽象出的图是欧拉图，则总路线固定，使用弗洛莱算法求解一条欧拉回路即可；若抽象出来图不是欧拉图，则需要添加重复边，将其变为欧拉图，并对当前欧拉图进行调优。下面给出后一种情况的具体求解方法：  
假设奇度数结点为$v_{1},v_{2},\cdots,v_{2h}$，则可依次添加重复边（可以有多种添加方案，只要能保证两两奇度数结点相连就好），即添加边$(v_{2i-1},v_{2i})$，其中$i=1,2,\cdots,h$，将图扩展为一个欧拉图。然后，基于如下两个规则对当前欧拉图进行优化：  
(1) 保证图中的每条边重数小于等于2：若边的重数大于或等于3，就去掉偶数条边。显然，在去掉偶数条边后，得到的图依然是欧拉图。  
(2) 保证图中的每个基本回路上平行边的总权值不大于该回路权值的一半：如果平行边的总权值大于了该回路权值的一半，则去掉该平行边，并在不影响图中结点度数奇偶性的前提下，给原来没有平行边的边加上平行边。  
下面结合具体实例介绍具体计算过程：",中国邮路问题可以转化为寻找欧拉图的问题，如果图是欧拉图，则问题的解为该图的欧拉回路
中国邮路问题,应用,弗洛莱算法,,"中国邮路问题是我国数学家管梅谷教授在1960 年提出的一个著名网络优化问题：某邮递员从邮局出发去送信，期间要走完他负责投递的所有街道，最后返回邮局。该邮递员如何选择路径才能使得所走的总路程最短？  
可以用图模型对该问题进行建模。具体地说，就是将该邮递员负责投递的每条街道抽象成一条无向边，街道道口抽象成结点，构成一个无向连通图$G=\langle V,E\rangle$。若将每条道路的长度抽象成其所对应边的权值，则中国邮路问题可转化为如下关于图模型的问题：对于任意给定的一个连通图$G=\langle V,E\rangle$，如何遍历图中每条边，使得总路线最短（权重之和最小）。  
如果$G=\langle V,E\rangle$是一个欧拉图，则中国邮路问题的解显然就是该图的欧拉回路。因为根据问题要求，图中每条边必须至少经过一次，欧拉回路则是每条边经过且仅经过一次。这是最好的情形，可用弗洛莱算法得到具体的欧拉回路实现对该问题的求解。  
然而，如果$G=\langle V,E\rangle$不是一个欧拉图，那么就不能保证每条边仅通过一次，有些边需要两次。此时，让哪条边或哪些边通过两次则是一个需要认真考虑的问题。最直观的想法就是让权最小的边通过两次，但如此并不能保证能够遍历每条边。因此，基本的求解思路是在保证完成对边遍历的前提下，让权值尽可能小的边通过两次。换句话说，就是如何在图中添加权值尽可能小重复边，使得该图变成一个欧拉图。下面给出具体求解方案：  
我们知道，一个连通图之所以不是欧拉图，是因为图中存在偶数个奇度数结点。因此，需要将这些，将其强制性变成欧拉图。具体地说，就是以这些奇度点为结点，添加一些边，使得这些奇度结点变成偶度结点。 得到欧拉图之后，还要判断该欧拉图是否为最优， 也就是 说通过该欧拉图得到的总权值是否最小，否则就要对其做进一步优化。  
因此，中国邮路问题的基本求解思路为：若抽象出的图是欧拉图，则总路线固定，使用弗洛莱算法求解一条欧拉回路即可；若抽象出来图不是欧拉图，则需要添加重复边，将其变为欧拉图，并对当前欧拉图进行调优。下面给出后一种情况的具体求解方法：  
假设奇度数结点为$v_{1},v_{2},\cdots,v_{2h}$，则可依次添加重复边（可以有多种添加方案，只要能保证两两奇度数结点相连就好），即添加边$(v_{2i-1},v_{2i})$，其中$i=1,2,\cdots,h$，将图扩展为一个欧拉图。然后，基于如下两个规则对当前欧拉图进行优化：  
(1) 保证图中的每条边重数小于等于2：若边的重数大于或等于3，就去掉偶数条边。显然，在去掉偶数条边后，得到的图依然是欧拉图。  
(2) 保证图中的每个基本回路上平行边的总权值不大于该回路权值的一半：如果平行边的总权值大于了该回路权值的一半，则去掉该平行边，并在不影响图中结点度数奇偶性的前提下，给原来没有平行边的边加上平行边。  
下面结合具体实例介绍具体计算过程：",当图是欧拉图时，中国邮路问题可以通过弗洛莱算法求解欧拉回路来解决
欧拉图,求解,弗洛莱算法,,"中国邮路问题是我国数学家管梅谷教授在1960 年提出的一个著名网络优化问题：某邮递员从邮局出发去送信，期间要走完他负责投递的所有街道，最后返回邮局。该邮递员如何选择路径才能使得所走的总路程最短？  
可以用图模型对该问题进行建模。具体地说，就是将该邮递员负责投递的每条街道抽象成一条无向边，街道道口抽象成结点，构成一个无向连通图$G=\langle V,E\rangle$。若将每条道路的长度抽象成其所对应边的权值，则中国邮路问题可转化为如下关于图模型的问题：对于任意给定的一个连通图$G=\langle V,E\rangle$，如何遍历图中每条边，使得总路线最短（权重之和最小）。  
如果$G=\langle V,E\rangle$是一个欧拉图，则中国邮路问题的解显然就是该图的欧拉回路。因为根据问题要求，图中每条边必须至少经过一次，欧拉回路则是每条边经过且仅经过一次。这是最好的情形，可用弗洛莱算法得到具体的欧拉回路实现对该问题的求解。  
然而，如果$G=\langle V,E\rangle$不是一个欧拉图，那么就不能保证每条边仅通过一次，有些边需要两次。此时，让哪条边或哪些边通过两次则是一个需要认真考虑的问题。最直观的想法就是让权最小的边通过两次，但如此并不能保证能够遍历每条边。因此，基本的求解思路是在保证完成对边遍历的前提下，让权值尽可能小的边通过两次。换句话说，就是如何在图中添加权值尽可能小重复边，使得该图变成一个欧拉图。下面给出具体求解方案：  
我们知道，一个连通图之所以不是欧拉图，是因为图中存在偶数个奇度数结点。因此，需要将这些，将其强制性变成欧拉图。具体地说，就是以这些奇度点为结点，添加一些边，使得这些奇度结点变成偶度结点。 得到欧拉图之后，还要判断该欧拉图是否为最优， 也就是 说通过该欧拉图得到的总权值是否最小，否则就要对其做进一步优化。  
因此，中国邮路问题的基本求解思路为：若抽象出的图是欧拉图，则总路线固定，使用弗洛莱算法求解一条欧拉回路即可；若抽象出来图不是欧拉图，则需要添加重复边，将其变为欧拉图，并对当前欧拉图进行调优。下面给出后一种情况的具体求解方法：  
假设奇度数结点为$v_{1},v_{2},\cdots,v_{2h}$，则可依次添加重复边（可以有多种添加方案，只要能保证两两奇度数结点相连就好），即添加边$(v_{2i-1},v_{2i})$，其中$i=1,2,\cdots,h$，将图扩展为一个欧拉图。然后，基于如下两个规则对当前欧拉图进行优化：  
(1) 保证图中的每条边重数小于等于2：若边的重数大于或等于3，就去掉偶数条边。显然，在去掉偶数条边后，得到的图依然是欧拉图。  
(2) 保证图中的每个基本回路上平行边的总权值不大于该回路权值的一半：如果平行边的总权值大于了该回路权值的一半，则去掉该平行边，并在不影响图中结点度数奇偶性的前提下，给原来没有平行边的边加上平行边。  
下面结合具体实例介绍具体计算过程：",弗洛莱算法用于求解欧拉图中的欧拉回路
二分图,表示和处理,匹配问题,,在很多实际问题中需要表示和处理两类对象之间的联系，例如学生选课问题会涉及学生集合中元素与课程集合中元素之间的关系，工作任务安排问题会涉及员工集合中元素与任务集合中元素之间的关系，恋爱婚姻问题会涉及男性集合中元素与女性集合中元素之间的关系。可以使用一种名为二分图的特殊图模型表示和处理这类问题。二分图中的所有结点被划分为两种基本类型，同一类型的结点之间无边联结，图中每条边仅联结分属不同类型的结点，故能很好地表示和处理上述问题。本节主要介绍二分图模型的基本概念和性质，并讨论与其具有密切联系的完备匹配与最大匹配问题。,二分图模型用于表示和处理匹配问题，通过将结点划分为两种类型并仅在不同类型结点之间建立边，能够有效处理如学生选课、工作任务安排和恋爱婚姻等问题中的匹配关系
二分图,包含,完全二分图,,"在给出二分图模型的概念之前，先考察这样一个问题：假设某单位有文秘、程序员、推销员和清洁工这四个空缺的岗位需要招聘员工，现在有甲、乙、丙三人前来应聘。其中甲能够胜任程序员、文秘、推销员岗位，乙能胜任程序员、推销员岗位，丙只能胜任清洁工岗位。则可用如图10-25 所示的图模型表示岗位和应聘者之间的关系，其中结点$A,B,C,D$分别表示程序员、文秘、推销员和清洁工这四个岗位。  
![图10-25 二分图模型  ](images/8864c10116e26697fbf05b1f18e2401c9842cde25d081b310532369c11ee7ce7.jpg)  
不难看出，可将如图10-25 所示图模型的所有结点划分为应聘者和岗位这两个不同的集合，属于同一个集合的结点之间无边联结，图中所有边的两个端点均分属两个不同的集合。具有这种特征的图模型就是二分图，其具体定义如下：  
【定义10.3】设$G=\langle V,E\rangle$是任意给定的一个无向图，若存在结点集𝑉的两个子集$X,Y$，满足$X\cap Y=\varnothing$且$X\cup Y=V$，图$G$中任何一条边的两个端点均分别属于 $X$和$𝑌$，则称$G$是一个二分图或偶图,$X$和$𝑌$称为互补结点子集，记为$G=\langle X,E,Y\rangle$。对于二分图$G=\langle X,E,Y\rangle$，若$ X$中每个结点与𝑌中每个结点都有且仅有一边联结，则称$G$为完全二分图或完全偶图，记作$K_{i,j}$，其中$|X|=i$，$|Y|=j$。平凡图和零图可看成是特殊二分图。  
![图10-26 完全二分图模型  ](images/ae1a646a89e375aa1b8c1c870d1cd9274cf83b1ce9ba6ad8326f6e1c44eef5ab.jpg)  
由定义10.3 可知，在二分图$G=\langle X,E,Y\rangle$中，没有两个端点同属𝑋或𝑌的边，故二分图没有自回路。如图10-25 表示两个为完全二分图：$K_{2,3}$，$K_{3,6}$。  
![（a）图𝐺                         （b）图$H$【例题10.8】如图10-27 所示的图$G$和$H$是否为二分图。  ](images/b80fa71a1e3c63a74ff7d12be601081cc8b875225af5fcb246ba93539d56929b.jpg)  
由于同构的图模型尽管结构相同但表现形式多种多样，故有时很难直接使用定义实现对二分图的判定。下面给出关于二分图判定的充要条件：  
【定理10.7】设$G=\langle V,E\rangle$是任意给定的一个无向图，则$G$是一个二分图当且仅当$G$中所有回路的长度均为偶数。",完全二分图是二分图的一种特殊形式，其中每个结点与另一个集合中的每个结点都有且仅有一边联结。
二分图,判定依据,二分图判定定理,,"在给出二分图模型的概念之前，先考察这样一个问题：假设某单位有文秘、程序员、推销员和清洁工这四个空缺的岗位需要招聘员工，现在有甲、乙、丙三人前来应聘。其中甲能够胜任程序员、文秘、推销员岗位，乙能胜任程序员、推销员岗位，丙只能胜任清洁工岗位。则可用如图10-25 所示的图模型表示岗位和应聘者之间的关系，其中结点$A,B,C,D$分别表示程序员、文秘、推销员和清洁工这四个岗位。  
![图10-25 二分图模型  ](images/8864c10116e26697fbf05b1f18e2401c9842cde25d081b310532369c11ee7ce7.jpg)  
不难看出，可将如图10-25 所示图模型的所有结点划分为应聘者和岗位这两个不同的集合，属于同一个集合的结点之间无边联结，图中所有边的两个端点均分属两个不同的集合。具有这种特征的图模型就是二分图，其具体定义如下：  
【定义10.3】设$G=\langle V,E\rangle$是任意给定的一个无向图，若存在结点集𝑉的两个子集$X,Y$，满足$X\cap Y=\varnothing$且$X\cup Y=V$，图$G$中任何一条边的两个端点均分别属于 $X$和$𝑌$，则称$G$是一个二分图或偶图,$X$和$𝑌$称为互补结点子集，记为$G=\langle X,E,Y\rangle$。对于二分图$G=\langle X,E,Y\rangle$，若$ X$中每个结点与𝑌中每个结点都有且仅有一边联结，则称$G$为完全二分图或完全偶图，记作$K_{i,j}$，其中$|X|=i$，$|Y|=j$。平凡图和零图可看成是特殊二分图。  
![图10-26 完全二分图模型  ](images/ae1a646a89e375aa1b8c1c870d1cd9274cf83b1ce9ba6ad8326f6e1c44eef5ab.jpg)  
由定义10.3 可知，在二分图$G=\langle X,E,Y\rangle$中，没有两个端点同属𝑋或𝑌的边，故二分图没有自回路。如图10-25 表示两个为完全二分图：$K_{2,3}$，$K_{3,6}$。  
![（a）图𝐺                         （b）图$H$【例题10.8】如图10-27 所示的图$G$和$H$是否为二分图。  ](images/b80fa71a1e3c63a74ff7d12be601081cc8b875225af5fcb246ba93539d56929b.jpg)  
由于同构的图模型尽管结构相同但表现形式多种多样，故有时很难直接使用定义实现对二分图的判定。下面给出关于二分图判定的充要条件：  
【定理10.7】设$G=\langle V,E\rangle$是任意给定的一个无向图，则$G$是一个二分图当且仅当$G$中所有回路的长度均为偶数。",二分图判定定理提供了判断一个无向图是否为二分图的充要条件，即所有回路的长度均为偶数。
完全二分图,适用,二分图判定定理,,"在给出二分图模型的概念之前，先考察这样一个问题：假设某单位有文秘、程序员、推销员和清洁工这四个空缺的岗位需要招聘员工，现在有甲、乙、丙三人前来应聘。其中甲能够胜任程序员、文秘、推销员岗位，乙能胜任程序员、推销员岗位，丙只能胜任清洁工岗位。则可用如图10-25 所示的图模型表示岗位和应聘者之间的关系，其中结点$A,B,C,D$分别表示程序员、文秘、推销员和清洁工这四个岗位。  
![图10-25 二分图模型  ](images/8864c10116e26697fbf05b1f18e2401c9842cde25d081b310532369c11ee7ce7.jpg)  
不难看出，可将如图10-25 所示图模型的所有结点划分为应聘者和岗位这两个不同的集合，属于同一个集合的结点之间无边联结，图中所有边的两个端点均分属两个不同的集合。具有这种特征的图模型就是二分图，其具体定义如下：  
【定义10.3】设$G=\langle V,E\rangle$是任意给定的一个无向图，若存在结点集𝑉的两个子集$X,Y$，满足$X\cap Y=\varnothing$且$X\cup Y=V$，图$G$中任何一条边的两个端点均分别属于 $X$和$𝑌$，则称$G$是一个二分图或偶图,$X$和$𝑌$称为互补结点子集，记为$G=\langle X,E,Y\rangle$。对于二分图$G=\langle X,E,Y\rangle$，若$ X$中每个结点与𝑌中每个结点都有且仅有一边联结，则称$G$为完全二分图或完全偶图，记作$K_{i,j}$，其中$|X|=i$，$|Y|=j$。平凡图和零图可看成是特殊二分图。  
![图10-26 完全二分图模型  ](images/ae1a646a89e375aa1b8c1c870d1cd9274cf83b1ce9ba6ad8326f6e1c44eef5ab.jpg)  
由定义10.3 可知，在二分图$G=\langle X,E,Y\rangle$中，没有两个端点同属𝑋或𝑌的边，故二分图没有自回路。如图10-25 表示两个为完全二分图：$K_{2,3}$，$K_{3,6}$。  
![（a）图𝐺                         （b）图$H$【例题10.8】如图10-27 所示的图$G$和$H$是否为二分图。  ](images/b80fa71a1e3c63a74ff7d12be601081cc8b875225af5fcb246ba93539d56929b.jpg)  
由于同构的图模型尽管结构相同但表现形式多种多样，故有时很难直接使用定义实现对二分图的判定。下面给出关于二分图判定的充要条件：  
【定理10.7】设$G=\langle V,E\rangle$是任意给定的一个无向图，则$G$是一个二分图当且仅当$G$中所有回路的长度均为偶数。",完全二分图作为二分图的一种，同样适用于二分图判定定理，即其所有回路的长度均为偶数。
二分图,包含,匹配,,"首先考察一个有趣的问题：假设在某个小型舞会上有5 名男士和5 名女士，其中某些男士与某些女士之间相互认识，问如何安排才能使得相互认识的男生和女士人成为舞伴。  
可用如图10-30（a）所示的二分图模型$G=\langle X,E,Y\rangle$表示上述舞伴配对问题，其中结点集合$X=\{x_{1},x_{2},x_{3},x_{4},x_{5}\}$和$Y=\{y_{1},y_{2},y_{3},y_{4},y_{5}\}$分别表示5 名男士和5 名女士构成的集合，图中有无向边$(x_{i},y_{j})$当且仅当男士$x_{i}$与女士$y_{j}$相互认识。  
![图10-30  舞伴的安排问题 ](images/e92b7888a1cc6a1b77006b78c8c42919c89a7e806394091bb76e5c5538b07826.jpg)  
通过观察，不难得到如图10-30（b）中实线边所示的一种安排方案。由于每个人最多只能与一个异性匹配成舞伴，故所得到的安排方案其实就是图$G=\langle X,E,Y\rangle$中5 条不相邻边组成的$E$的子集：$M=\{(x_{1},y_{3}),(x_{2},y_{1}),(x_{3},y_{2}),(x_{4},y_{5}),(x_{5},y_{4})\}_{\circ}$。  
不难看出，上述问题其实就是在两类不同性质的对象之间寻找某种配对或者匹配的问题。事实上，日常生活和工作中的很多问题，例如学生选课、工作任务安排等等，都可以归结为这种匹配问题。对上述实例进行抽象，得到如下匹配的相关概念：  
【定义10.4】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，图中互不相邻的边构成$.E$的子集$M$称为$G$的一个匹配，$G$中与$M$中的边关联的结点称为匹配$M$的饱和结点。如果$X$中每个结点都是某个匹配的饱和结点，则称该匹配为$G$的一个$X^{.}$-完备匹配；如果𝑌中每个结点都是某个匹配的饱和结点，则称该匹配为$G$的一个𝑌-完备匹配；如果$G$的某个匹配既是$X-$完备匹配，又是𝑌-完备匹配，则称该匹配为完备匹配。$G$中基数最大的匹配称为𝐺的最大匹配，最大匹配中的边数称为$G$的匹配数，记作$\alpha^{\prime}(G)$。  
由定义10.4 可知，二分图的$X^{-}$完备匹配、$Y-$完备匹配和完备匹配肯定是最大匹配，反之不然，最大匹配不一定是$X-$完备匹配、$Y-$完备匹配或完备匹配。对于任意一个给定的二分图，其最大匹配总是存在，但其$X{-}$完备匹配、$Y-$完备匹配或完备匹配不一定存在。如果一个二分图存在完备匹配，则必有$|X|=|Y|$，反之不然。  
![图10-31  二分图及其最大匹配  ](images/426797d69400c6077f0021e199ce3acdf2169381fe7ee70516dbf26e96f0ac68.jpg)  
例如，对于图10-31（a）所示的二分图，图10-31（b）所示的全部实线边构成的集合：  
$$
M=\{(x_{1},y_{3}),(x_{2},y_{1}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
是该二分图的一个最大匹配。该匹配显然不是$X^{-}$完备匹配、$Y-$完备匹配或完备匹配，因为$x_{4}$和$y_{4}$均是其非饱和点。再如，图10-30（b）中实线边所示的匹配显然是一个完备匹配，自然也是最大匹配。  
下面考察对于一个给定的二分图$G=\langle X,E,Y\rangle$，当$G$满足什么条件时存在完备匹配。这里仅讨论$X^{-}$完备匹配的情形，至于$Y-$完备匹配和完备匹配的情况，可类似讨论。  
首先给出著名的霍尔婚姻定理，该定理给出了二分图$G=\langle X,E,Y\rangle$存在$X^{-}$完备匹配的一个充分必要条件，具体如下：  
【定理10.8】（霍尔婚姻定理）设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，则$G$存在$X^{-}$完备匹配的充分必要条件是$X$中任意$k$个结点至少与𝑌中$k$个结点相邻。具体地说，就是对于$\forall S\subseteq X$，有$|S|\leq|\mathsf{N}(\mathsf{S})|$，其中N(S)表示𝑌中所有与S中结点相邻的结点组成的集合。  
![图10-32  $X$-完备匹配存在性的判定](images/e5661ccfd2ab0df27e3feadf55016324a2bdd2f775f9de7183f592d16a209926.jpg)  
例如，图10-32（a）所示二分图满足霍尔婚姻定理的条件，故存在$X^{-}$完备匹配，图$10-$32（b）所示二分图不满足霍尔婚姻定理的条件，故不存在$X^{-}$完备匹配。  
定理10.8 中需要计算𝑋中所有子集在𝑌中邻接结点的集合，在很多情况下计算量很大，不便使用。为此，下面给出一个名为$t-$条件的充分条件，具体如下：  
【定理10.9】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，如果$G$满足：$X$中每个结点至少关联t-条边且𝑌中每个结点至多关联$t^{-}$条边，则图$G$一定存在$X^{-}$完备匹配。  
判断𝑡条件非常简单，只需计算$X$中结点最小度$\delta(X)$和$\Delta(Y)$中结点最大度$\Delta$即可。例如，对于图10-32（a）所示二分图，显然有$\delta(X)=\Delta(Y)=2=t$，故存在$X{-}$完备匹配。",二分图中互不相邻的边构成的子集称为匹配
匹配,特化,完备匹配,,"首先考察一个有趣的问题：假设在某个小型舞会上有5 名男士和5 名女士，其中某些男士与某些女士之间相互认识，问如何安排才能使得相互认识的男生和女士人成为舞伴。  
可用如图10-30（a）所示的二分图模型$G=\langle X,E,Y\rangle$表示上述舞伴配对问题，其中结点集合$X=\{x_{1},x_{2},x_{3},x_{4},x_{5}\}$和$Y=\{y_{1},y_{2},y_{3},y_{4},y_{5}\}$分别表示5 名男士和5 名女士构成的集合，图中有无向边$(x_{i},y_{j})$当且仅当男士$x_{i}$与女士$y_{j}$相互认识。  
![图10-30  舞伴的安排问题 ](images/e92b7888a1cc6a1b77006b78c8c42919c89a7e806394091bb76e5c5538b07826.jpg)  
通过观察，不难得到如图10-30（b）中实线边所示的一种安排方案。由于每个人最多只能与一个异性匹配成舞伴，故所得到的安排方案其实就是图$G=\langle X,E,Y\rangle$中5 条不相邻边组成的$E$的子集：$M=\{(x_{1},y_{3}),(x_{2},y_{1}),(x_{3},y_{2}),(x_{4},y_{5}),(x_{5},y_{4})\}_{\circ}$。  
不难看出，上述问题其实就是在两类不同性质的对象之间寻找某种配对或者匹配的问题。事实上，日常生活和工作中的很多问题，例如学生选课、工作任务安排等等，都可以归结为这种匹配问题。对上述实例进行抽象，得到如下匹配的相关概念：  
【定义10.4】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，图中互不相邻的边构成$.E$的子集$M$称为$G$的一个匹配，$G$中与$M$中的边关联的结点称为匹配$M$的饱和结点。如果$X$中每个结点都是某个匹配的饱和结点，则称该匹配为$G$的一个$X^{.}$-完备匹配；如果𝑌中每个结点都是某个匹配的饱和结点，则称该匹配为$G$的一个𝑌-完备匹配；如果$G$的某个匹配既是$X-$完备匹配，又是𝑌-完备匹配，则称该匹配为完备匹配。$G$中基数最大的匹配称为𝐺的最大匹配，最大匹配中的边数称为$G$的匹配数，记作$\alpha^{\prime}(G)$。  
由定义10.4 可知，二分图的$X^{-}$完备匹配、$Y-$完备匹配和完备匹配肯定是最大匹配，反之不然，最大匹配不一定是$X-$完备匹配、$Y-$完备匹配或完备匹配。对于任意一个给定的二分图，其最大匹配总是存在，但其$X{-}$完备匹配、$Y-$完备匹配或完备匹配不一定存在。如果一个二分图存在完备匹配，则必有$|X|=|Y|$，反之不然。  
![图10-31  二分图及其最大匹配  ](images/426797d69400c6077f0021e199ce3acdf2169381fe7ee70516dbf26e96f0ac68.jpg)  
例如，对于图10-31（a）所示的二分图，图10-31（b）所示的全部实线边构成的集合：  
$$
M=\{(x_{1},y_{3}),(x_{2},y_{1}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
是该二分图的一个最大匹配。该匹配显然不是$X^{-}$完备匹配、$Y-$完备匹配或完备匹配，因为$x_{4}$和$y_{4}$均是其非饱和点。再如，图10-30（b）中实线边所示的匹配显然是一个完备匹配，自然也是最大匹配。  
下面考察对于一个给定的二分图$G=\langle X,E,Y\rangle$，当$G$满足什么条件时存在完备匹配。这里仅讨论$X^{-}$完备匹配的情形，至于$Y-$完备匹配和完备匹配的情况，可类似讨论。  
首先给出著名的霍尔婚姻定理，该定理给出了二分图$G=\langle X,E,Y\rangle$存在$X^{-}$完备匹配的一个充分必要条件，具体如下：  
【定理10.8】（霍尔婚姻定理）设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，则$G$存在$X^{-}$完备匹配的充分必要条件是$X$中任意$k$个结点至少与𝑌中$k$个结点相邻。具体地说，就是对于$\forall S\subseteq X$，有$|S|\leq|\mathsf{N}(\mathsf{S})|$，其中N(S)表示𝑌中所有与S中结点相邻的结点组成的集合。  
![图10-32  $X$-完备匹配存在性的判定](images/e5661ccfd2ab0df27e3feadf55016324a2bdd2f775f9de7183f592d16a209926.jpg)  
例如，图10-32（a）所示二分图满足霍尔婚姻定理的条件，故存在$X^{-}$完备匹配，图$10-$32（b）所示二分图不满足霍尔婚姻定理的条件，故不存在$X^{-}$完备匹配。  
定理10.8 中需要计算𝑋中所有子集在𝑌中邻接结点的集合，在很多情况下计算量很大，不便使用。为此，下面给出一个名为$t-$条件的充分条件，具体如下：  
【定理10.9】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，如果$G$满足：$X$中每个结点至少关联t-条边且𝑌中每个结点至多关联$t^{-}$条边，则图$G$一定存在$X^{-}$完备匹配。  
判断𝑡条件非常简单，只需计算$X$中结点最小度$\delta(X)$和$\Delta(Y)$中结点最大度$\Delta$即可。例如，对于图10-32（a）所示二分图，显然有$\delta(X)=\Delta(Y)=2=t$，故存在$X{-}$完备匹配。",如果二分图中X和Y的每个结点都是匹配的饱和结点，则该匹配为完备匹配
匹配,特化,最大匹配,,"首先考察一个有趣的问题：假设在某个小型舞会上有5 名男士和5 名女士，其中某些男士与某些女士之间相互认识，问如何安排才能使得相互认识的男生和女士人成为舞伴。  
可用如图10-30（a）所示的二分图模型$G=\langle X,E,Y\rangle$表示上述舞伴配对问题，其中结点集合$X=\{x_{1},x_{2},x_{3},x_{4},x_{5}\}$和$Y=\{y_{1},y_{2},y_{3},y_{4},y_{5}\}$分别表示5 名男士和5 名女士构成的集合，图中有无向边$(x_{i},y_{j})$当且仅当男士$x_{i}$与女士$y_{j}$相互认识。  
![图10-30  舞伴的安排问题 ](images/e92b7888a1cc6a1b77006b78c8c42919c89a7e806394091bb76e5c5538b07826.jpg)  
通过观察，不难得到如图10-30（b）中实线边所示的一种安排方案。由于每个人最多只能与一个异性匹配成舞伴，故所得到的安排方案其实就是图$G=\langle X,E,Y\rangle$中5 条不相邻边组成的$E$的子集：$M=\{(x_{1},y_{3}),(x_{2},y_{1}),(x_{3},y_{2}),(x_{4},y_{5}),(x_{5},y_{4})\}_{\circ}$。  
不难看出，上述问题其实就是在两类不同性质的对象之间寻找某种配对或者匹配的问题。事实上，日常生活和工作中的很多问题，例如学生选课、工作任务安排等等，都可以归结为这种匹配问题。对上述实例进行抽象，得到如下匹配的相关概念：  
【定义10.4】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，图中互不相邻的边构成$.E$的子集$M$称为$G$的一个匹配，$G$中与$M$中的边关联的结点称为匹配$M$的饱和结点。如果$X$中每个结点都是某个匹配的饱和结点，则称该匹配为$G$的一个$X^{.}$-完备匹配；如果𝑌中每个结点都是某个匹配的饱和结点，则称该匹配为$G$的一个𝑌-完备匹配；如果$G$的某个匹配既是$X-$完备匹配，又是𝑌-完备匹配，则称该匹配为完备匹配。$G$中基数最大的匹配称为𝐺的最大匹配，最大匹配中的边数称为$G$的匹配数，记作$\alpha^{\prime}(G)$。  
由定义10.4 可知，二分图的$X^{-}$完备匹配、$Y-$完备匹配和完备匹配肯定是最大匹配，反之不然，最大匹配不一定是$X-$完备匹配、$Y-$完备匹配或完备匹配。对于任意一个给定的二分图，其最大匹配总是存在，但其$X{-}$完备匹配、$Y-$完备匹配或完备匹配不一定存在。如果一个二分图存在完备匹配，则必有$|X|=|Y|$，反之不然。  
![图10-31  二分图及其最大匹配  ](images/426797d69400c6077f0021e199ce3acdf2169381fe7ee70516dbf26e96f0ac68.jpg)  
例如，对于图10-31（a）所示的二分图，图10-31（b）所示的全部实线边构成的集合：  
$$
M=\{(x_{1},y_{3}),(x_{2},y_{1}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
是该二分图的一个最大匹配。该匹配显然不是$X^{-}$完备匹配、$Y-$完备匹配或完备匹配，因为$x_{4}$和$y_{4}$均是其非饱和点。再如，图10-30（b）中实线边所示的匹配显然是一个完备匹配，自然也是最大匹配。  
下面考察对于一个给定的二分图$G=\langle X,E,Y\rangle$，当$G$满足什么条件时存在完备匹配。这里仅讨论$X^{-}$完备匹配的情形，至于$Y-$完备匹配和完备匹配的情况，可类似讨论。  
首先给出著名的霍尔婚姻定理，该定理给出了二分图$G=\langle X,E,Y\rangle$存在$X^{-}$完备匹配的一个充分必要条件，具体如下：  
【定理10.8】（霍尔婚姻定理）设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，则$G$存在$X^{-}$完备匹配的充分必要条件是$X$中任意$k$个结点至少与𝑌中$k$个结点相邻。具体地说，就是对于$\forall S\subseteq X$，有$|S|\leq|\mathsf{N}(\mathsf{S})|$，其中N(S)表示𝑌中所有与S中结点相邻的结点组成的集合。  
![图10-32  $X$-完备匹配存在性的判定](images/e5661ccfd2ab0df27e3feadf55016324a2bdd2f775f9de7183f592d16a209926.jpg)  
例如，图10-32（a）所示二分图满足霍尔婚姻定理的条件，故存在$X^{-}$完备匹配，图$10-$32（b）所示二分图不满足霍尔婚姻定理的条件，故不存在$X^{-}$完备匹配。  
定理10.8 中需要计算𝑋中所有子集在𝑌中邻接结点的集合，在很多情况下计算量很大，不便使用。为此，下面给出一个名为$t-$条件的充分条件，具体如下：  
【定理10.9】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，如果$G$满足：$X$中每个结点至少关联t-条边且𝑌中每个结点至多关联$t^{-}$条边，则图$G$一定存在$X^{-}$完备匹配。  
判断𝑡条件非常简单，只需计算$X$中结点最小度$\delta(X)$和$\Delta(Y)$中结点最大度$\Delta$即可。例如，对于图10-32（a）所示二分图，显然有$\delta(X)=\Delta(Y)=2=t$，故存在$X{-}$完备匹配。",二分图中基数最大的匹配称为最大匹配
完备匹配,蕴含,最大匹配,,"首先考察一个有趣的问题：假设在某个小型舞会上有5 名男士和5 名女士，其中某些男士与某些女士之间相互认识，问如何安排才能使得相互认识的男生和女士人成为舞伴。  
可用如图10-30（a）所示的二分图模型$G=\langle X,E,Y\rangle$表示上述舞伴配对问题，其中结点集合$X=\{x_{1},x_{2},x_{3},x_{4},x_{5}\}$和$Y=\{y_{1},y_{2},y_{3},y_{4},y_{5}\}$分别表示5 名男士和5 名女士构成的集合，图中有无向边$(x_{i},y_{j})$当且仅当男士$x_{i}$与女士$y_{j}$相互认识。  
![图10-30  舞伴的安排问题 ](images/e92b7888a1cc6a1b77006b78c8c42919c89a7e806394091bb76e5c5538b07826.jpg)  
通过观察，不难得到如图10-30（b）中实线边所示的一种安排方案。由于每个人最多只能与一个异性匹配成舞伴，故所得到的安排方案其实就是图$G=\langle X,E,Y\rangle$中5 条不相邻边组成的$E$的子集：$M=\{(x_{1},y_{3}),(x_{2},y_{1}),(x_{3},y_{2}),(x_{4},y_{5}),(x_{5},y_{4})\}_{\circ}$。  
不难看出，上述问题其实就是在两类不同性质的对象之间寻找某种配对或者匹配的问题。事实上，日常生活和工作中的很多问题，例如学生选课、工作任务安排等等，都可以归结为这种匹配问题。对上述实例进行抽象，得到如下匹配的相关概念：  
【定义10.4】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，图中互不相邻的边构成$.E$的子集$M$称为$G$的一个匹配，$G$中与$M$中的边关联的结点称为匹配$M$的饱和结点。如果$X$中每个结点都是某个匹配的饱和结点，则称该匹配为$G$的一个$X^{.}$-完备匹配；如果𝑌中每个结点都是某个匹配的饱和结点，则称该匹配为$G$的一个𝑌-完备匹配；如果$G$的某个匹配既是$X-$完备匹配，又是𝑌-完备匹配，则称该匹配为完备匹配。$G$中基数最大的匹配称为𝐺的最大匹配，最大匹配中的边数称为$G$的匹配数，记作$\alpha^{\prime}(G)$。  
由定义10.4 可知，二分图的$X^{-}$完备匹配、$Y-$完备匹配和完备匹配肯定是最大匹配，反之不然，最大匹配不一定是$X-$完备匹配、$Y-$完备匹配或完备匹配。对于任意一个给定的二分图，其最大匹配总是存在，但其$X{-}$完备匹配、$Y-$完备匹配或完备匹配不一定存在。如果一个二分图存在完备匹配，则必有$|X|=|Y|$，反之不然。  
![图10-31  二分图及其最大匹配  ](images/426797d69400c6077f0021e199ce3acdf2169381fe7ee70516dbf26e96f0ac68.jpg)  
例如，对于图10-31（a）所示的二分图，图10-31（b）所示的全部实线边构成的集合：  
$$
M=\{(x_{1},y_{3}),(x_{2},y_{1}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
是该二分图的一个最大匹配。该匹配显然不是$X^{-}$完备匹配、$Y-$完备匹配或完备匹配，因为$x_{4}$和$y_{4}$均是其非饱和点。再如，图10-30（b）中实线边所示的匹配显然是一个完备匹配，自然也是最大匹配。  
下面考察对于一个给定的二分图$G=\langle X,E,Y\rangle$，当$G$满足什么条件时存在完备匹配。这里仅讨论$X^{-}$完备匹配的情形，至于$Y-$完备匹配和完备匹配的情况，可类似讨论。  
首先给出著名的霍尔婚姻定理，该定理给出了二分图$G=\langle X,E,Y\rangle$存在$X^{-}$完备匹配的一个充分必要条件，具体如下：  
【定理10.8】（霍尔婚姻定理）设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，则$G$存在$X^{-}$完备匹配的充分必要条件是$X$中任意$k$个结点至少与𝑌中$k$个结点相邻。具体地说，就是对于$\forall S\subseteq X$，有$|S|\leq|\mathsf{N}(\mathsf{S})|$，其中N(S)表示𝑌中所有与S中结点相邻的结点组成的集合。  
![图10-32  $X$-完备匹配存在性的判定](images/e5661ccfd2ab0df27e3feadf55016324a2bdd2f775f9de7183f592d16a209926.jpg)  
例如，图10-32（a）所示二分图满足霍尔婚姻定理的条件，故存在$X^{-}$完备匹配，图$10-$32（b）所示二分图不满足霍尔婚姻定理的条件，故不存在$X^{-}$完备匹配。  
定理10.8 中需要计算𝑋中所有子集在𝑌中邻接结点的集合，在很多情况下计算量很大，不便使用。为此，下面给出一个名为$t-$条件的充分条件，具体如下：  
【定理10.9】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，如果$G$满足：$X$中每个结点至少关联t-条边且𝑌中每个结点至多关联$t^{-}$条边，则图$G$一定存在$X^{-}$完备匹配。  
判断𝑡条件非常简单，只需计算$X$中结点最小度$\delta(X)$和$\Delta(Y)$中结点最大度$\Delta$即可。例如，对于图10-32（a）所示二分图，显然有$\delta(X)=\Delta(Y)=2=t$，故存在$X{-}$完备匹配。",完备匹配肯定是最大匹配，但最大匹配不一定是完备匹配
二分图,条件,霍尔婚姻定理,,"首先考察一个有趣的问题：假设在某个小型舞会上有5 名男士和5 名女士，其中某些男士与某些女士之间相互认识，问如何安排才能使得相互认识的男生和女士人成为舞伴。  
可用如图10-30（a）所示的二分图模型$G=\langle X,E,Y\rangle$表示上述舞伴配对问题，其中结点集合$X=\{x_{1},x_{2},x_{3},x_{4},x_{5}\}$和$Y=\{y_{1},y_{2},y_{3},y_{4},y_{5}\}$分别表示5 名男士和5 名女士构成的集合，图中有无向边$(x_{i},y_{j})$当且仅当男士$x_{i}$与女士$y_{j}$相互认识。  
![图10-30  舞伴的安排问题 ](images/e92b7888a1cc6a1b77006b78c8c42919c89a7e806394091bb76e5c5538b07826.jpg)  
通过观察，不难得到如图10-30（b）中实线边所示的一种安排方案。由于每个人最多只能与一个异性匹配成舞伴，故所得到的安排方案其实就是图$G=\langle X,E,Y\rangle$中5 条不相邻边组成的$E$的子集：$M=\{(x_{1},y_{3}),(x_{2},y_{1}),(x_{3},y_{2}),(x_{4},y_{5}),(x_{5},y_{4})\}_{\circ}$。  
不难看出，上述问题其实就是在两类不同性质的对象之间寻找某种配对或者匹配的问题。事实上，日常生活和工作中的很多问题，例如学生选课、工作任务安排等等，都可以归结为这种匹配问题。对上述实例进行抽象，得到如下匹配的相关概念：  
【定义10.4】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，图中互不相邻的边构成$.E$的子集$M$称为$G$的一个匹配，$G$中与$M$中的边关联的结点称为匹配$M$的饱和结点。如果$X$中每个结点都是某个匹配的饱和结点，则称该匹配为$G$的一个$X^{.}$-完备匹配；如果𝑌中每个结点都是某个匹配的饱和结点，则称该匹配为$G$的一个𝑌-完备匹配；如果$G$的某个匹配既是$X-$完备匹配，又是𝑌-完备匹配，则称该匹配为完备匹配。$G$中基数最大的匹配称为𝐺的最大匹配，最大匹配中的边数称为$G$的匹配数，记作$\alpha^{\prime}(G)$。  
由定义10.4 可知，二分图的$X^{-}$完备匹配、$Y-$完备匹配和完备匹配肯定是最大匹配，反之不然，最大匹配不一定是$X-$完备匹配、$Y-$完备匹配或完备匹配。对于任意一个给定的二分图，其最大匹配总是存在，但其$X{-}$完备匹配、$Y-$完备匹配或完备匹配不一定存在。如果一个二分图存在完备匹配，则必有$|X|=|Y|$，反之不然。  
![图10-31  二分图及其最大匹配  ](images/426797d69400c6077f0021e199ce3acdf2169381fe7ee70516dbf26e96f0ac68.jpg)  
例如，对于图10-31（a）所示的二分图，图10-31（b）所示的全部实线边构成的集合：  
$$
M=\{(x_{1},y_{3}),(x_{2},y_{1}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
是该二分图的一个最大匹配。该匹配显然不是$X^{-}$完备匹配、$Y-$完备匹配或完备匹配，因为$x_{4}$和$y_{4}$均是其非饱和点。再如，图10-30（b）中实线边所示的匹配显然是一个完备匹配，自然也是最大匹配。  
下面考察对于一个给定的二分图$G=\langle X,E,Y\rangle$，当$G$满足什么条件时存在完备匹配。这里仅讨论$X^{-}$完备匹配的情形，至于$Y-$完备匹配和完备匹配的情况，可类似讨论。  
首先给出著名的霍尔婚姻定理，该定理给出了二分图$G=\langle X,E,Y\rangle$存在$X^{-}$完备匹配的一个充分必要条件，具体如下：  
【定理10.8】（霍尔婚姻定理）设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，则$G$存在$X^{-}$完备匹配的充分必要条件是$X$中任意$k$个结点至少与𝑌中$k$个结点相邻。具体地说，就是对于$\forall S\subseteq X$，有$|S|\leq|\mathsf{N}(\mathsf{S})|$，其中N(S)表示𝑌中所有与S中结点相邻的结点组成的集合。  
![图10-32  $X$-完备匹配存在性的判定](images/e5661ccfd2ab0df27e3feadf55016324a2bdd2f775f9de7183f592d16a209926.jpg)  
例如，图10-32（a）所示二分图满足霍尔婚姻定理的条件，故存在$X^{-}$完备匹配，图$10-$32（b）所示二分图不满足霍尔婚姻定理的条件，故不存在$X^{-}$完备匹配。  
定理10.8 中需要计算𝑋中所有子集在𝑌中邻接结点的集合，在很多情况下计算量很大，不便使用。为此，下面给出一个名为$t-$条件的充分条件，具体如下：  
【定理10.9】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，如果$G$满足：$X$中每个结点至少关联t-条边且𝑌中每个结点至多关联$t^{-}$条边，则图$G$一定存在$X^{-}$完备匹配。  
判断𝑡条件非常简单，只需计算$X$中结点最小度$\delta(X)$和$\Delta(Y)$中结点最大度$\Delta$即可。例如，对于图10-32（a）所示二分图，显然有$\delta(X)=\Delta(Y)=2=t$，故存在$X{-}$完备匹配。",霍尔婚姻定理给出了二分图存在X-完备匹配的充分必要条件
二分图,条件,t-条件,,"首先考察一个有趣的问题：假设在某个小型舞会上有5 名男士和5 名女士，其中某些男士与某些女士之间相互认识，问如何安排才能使得相互认识的男生和女士人成为舞伴。  
可用如图10-30（a）所示的二分图模型$G=\langle X,E,Y\rangle$表示上述舞伴配对问题，其中结点集合$X=\{x_{1},x_{2},x_{3},x_{4},x_{5}\}$和$Y=\{y_{1},y_{2},y_{3},y_{4},y_{5}\}$分别表示5 名男士和5 名女士构成的集合，图中有无向边$(x_{i},y_{j})$当且仅当男士$x_{i}$与女士$y_{j}$相互认识。  
![图10-30  舞伴的安排问题 ](images/e92b7888a1cc6a1b77006b78c8c42919c89a7e806394091bb76e5c5538b07826.jpg)  
通过观察，不难得到如图10-30（b）中实线边所示的一种安排方案。由于每个人最多只能与一个异性匹配成舞伴，故所得到的安排方案其实就是图$G=\langle X,E,Y\rangle$中5 条不相邻边组成的$E$的子集：$M=\{(x_{1},y_{3}),(x_{2},y_{1}),(x_{3},y_{2}),(x_{4},y_{5}),(x_{5},y_{4})\}_{\circ}$。  
不难看出，上述问题其实就是在两类不同性质的对象之间寻找某种配对或者匹配的问题。事实上，日常生活和工作中的很多问题，例如学生选课、工作任务安排等等，都可以归结为这种匹配问题。对上述实例进行抽象，得到如下匹配的相关概念：  
【定义10.4】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，图中互不相邻的边构成$.E$的子集$M$称为$G$的一个匹配，$G$中与$M$中的边关联的结点称为匹配$M$的饱和结点。如果$X$中每个结点都是某个匹配的饱和结点，则称该匹配为$G$的一个$X^{.}$-完备匹配；如果𝑌中每个结点都是某个匹配的饱和结点，则称该匹配为$G$的一个𝑌-完备匹配；如果$G$的某个匹配既是$X-$完备匹配，又是𝑌-完备匹配，则称该匹配为完备匹配。$G$中基数最大的匹配称为𝐺的最大匹配，最大匹配中的边数称为$G$的匹配数，记作$\alpha^{\prime}(G)$。  
由定义10.4 可知，二分图的$X^{-}$完备匹配、$Y-$完备匹配和完备匹配肯定是最大匹配，反之不然，最大匹配不一定是$X-$完备匹配、$Y-$完备匹配或完备匹配。对于任意一个给定的二分图，其最大匹配总是存在，但其$X{-}$完备匹配、$Y-$完备匹配或完备匹配不一定存在。如果一个二分图存在完备匹配，则必有$|X|=|Y|$，反之不然。  
![图10-31  二分图及其最大匹配  ](images/426797d69400c6077f0021e199ce3acdf2169381fe7ee70516dbf26e96f0ac68.jpg)  
例如，对于图10-31（a）所示的二分图，图10-31（b）所示的全部实线边构成的集合：  
$$
M=\{(x_{1},y_{3}),(x_{2},y_{1}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
是该二分图的一个最大匹配。该匹配显然不是$X^{-}$完备匹配、$Y-$完备匹配或完备匹配，因为$x_{4}$和$y_{4}$均是其非饱和点。再如，图10-30（b）中实线边所示的匹配显然是一个完备匹配，自然也是最大匹配。  
下面考察对于一个给定的二分图$G=\langle X,E,Y\rangle$，当$G$满足什么条件时存在完备匹配。这里仅讨论$X^{-}$完备匹配的情形，至于$Y-$完备匹配和完备匹配的情况，可类似讨论。  
首先给出著名的霍尔婚姻定理，该定理给出了二分图$G=\langle X,E,Y\rangle$存在$X^{-}$完备匹配的一个充分必要条件，具体如下：  
【定理10.8】（霍尔婚姻定理）设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，则$G$存在$X^{-}$完备匹配的充分必要条件是$X$中任意$k$个结点至少与𝑌中$k$个结点相邻。具体地说，就是对于$\forall S\subseteq X$，有$|S|\leq|\mathsf{N}(\mathsf{S})|$，其中N(S)表示𝑌中所有与S中结点相邻的结点组成的集合。  
![图10-32  $X$-完备匹配存在性的判定](images/e5661ccfd2ab0df27e3feadf55016324a2bdd2f775f9de7183f592d16a209926.jpg)  
例如，图10-32（a）所示二分图满足霍尔婚姻定理的条件，故存在$X^{-}$完备匹配，图$10-$32（b）所示二分图不满足霍尔婚姻定理的条件，故不存在$X^{-}$完备匹配。  
定理10.8 中需要计算𝑋中所有子集在𝑌中邻接结点的集合，在很多情况下计算量很大，不便使用。为此，下面给出一个名为$t-$条件的充分条件，具体如下：  
【定理10.9】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，如果$G$满足：$X$中每个结点至少关联t-条边且𝑌中每个结点至多关联$t^{-}$条边，则图$G$一定存在$X^{-}$完备匹配。  
判断𝑡条件非常简单，只需计算$X$中结点最小度$\delta(X)$和$\Delta(Y)$中结点最大度$\Delta$即可。例如，对于图10-32（a）所示二分图，显然有$\delta(X)=\Delta(Y)=2=t$，故存在$X{-}$完备匹配。",t-条件是二分图存在X-完备匹配的一个充分条件
二分图,包含,匹配,,"对于任意给定的一个二分图，首先讨论如何判断该图中某个给定的匹配是否为最大匹配。为此，引入交错道和可增广道的概念，具体如下：  
【定义10.5】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图， $M$是图$G$的某个匹配，若从𝐺中的某个结点到另一个结点之间存在一条通路，且该通路由属于$\cdot M$和不属于$M$的边交替构成，则称此通路为 𝑴 交错道。若 $M$ 交错道的两端点均为 $M$ 非饱和点，则称其为 𝑴 可增广道。  
例如，对于图10-35（a）所示匹配，$P=y_{1}x_{2}y_{5}x_{4}y_{3}x_{1}$是一条交错道，对于图10-35（b）所示匹配，$P=y_{1}x_{2}y_{5}x_{4}y_{3}x_{1}$则是一条可增广道，具体见图10-35（b）的粗线部分。  
![图10-35  交错道与可增广道  ](images/f5e335487e12a671cc013f6ede9981700aa6193018e616b34157cc9869d086b6.jpg)  
在1957 年，法国著名数学家贝尔格给出了判定某个匹配是最大匹配的充分必要条件。这就是著名的贝尔格定理，具体如下：  
【定理10.10】（贝尔格定理）设$G=\langle X,E,Y\rangle$是任意给定的一个二分图， 𝑀是图𝐺的某个匹配，则$M$是图$G$最大匹配的充要条件是$G$中不存在$M$可增广道。  
在1965 年，匈牙利的著名数学家埃德蒙兹基于贝尔格定理提出构造二分图最大匹配的著名算法，为纪念他的祖国，将该算法命名为匈牙利算法。算法基本思路如下：  
假设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，如果对于该图的某个匹配𝑀，结点集合𝑋的每个结点都是饱和结点，则该匹配就是最大匹配。否则，任取𝑋中的某个非饱和结点为起点做匹配$M$的交错道。此时，如果该交错道最后一个结点是饱和结点，如图10-36 中$P_{1}$所示，则匹配$M$就是最大匹配。否则，如果该交错道最后一个结点也是一个非饱和结点，则得到一条可增广道，如图10-36 中$P_{2}$所示。  
![图 10-36   对可增广道的增广 ](images/18f50be9390d6af7d21020996653e950e5f8bda427f6af3f0640cd631a139c62.jpg)  
不难看出，该交错道$P_{2}$中不属于$M$的所有边数比属于属于$M$的边数多一个，而且交错道中不属于$M$的所有边数也是互不相邻的，故可由这些边构成一个新的匹配$M^{*}$。由于${\mathbf{\nabla}}^{*}$的边数比$M$的边数多一个，故称$M^{*}$是对$M$的一个增广。继续上述过程，直到图中没有可增广道路为止，此时的匹配就是所求的最大匹配。  
从上述讨论不难发现，匈牙利算法的核心思想就是首先在当前匹配基础上寻找可增广道，找到可增广道后，就通过对该可增广道上所有边的匹配属性取反，即对可增广道上所有边的集合$ E(P)$与匹配$M$做集合的对称差运算$\oplus$，由此得到新的集合就是一个规模更大的新匹配，然后在这个新匹配的基础上继续寻找新可增广道，如此下去，直到没有可增广道路为止。  
对于任意给定的二分图$G=\langle X,E,Y\rangle$，匈牙利算法的具体计算流程如下：  
（1）任给初始匹配$M$；  
（2）若𝑋中任一结点均饱和，则$M$即为所求，算法结束，否则转（3）；  
（3）在𝑋中找到一非$M$饱和点$x$，置$S=\{x\}$，$T=\varnothing$；  
（4）若$N_{G}(S)=T$，则停止，否则任选一点$y\in N_{G}(S)-T$；  
（5）若𝑦为$M$饱和点转（6），否则：求一条从$x$到𝑦的$M$可增广路$P$，置$M=M\oplus P$，转（2）  
（6）由于$ y$是$M$饱和点，故$M$中有一边 $(y,u)$，置$S=S\cup\{u\}$，$T=T\cup\{y\}$，转（4）。算法中$N_{G}(S)$表示 $G$上与$S$中任一结点相邻的所有结点组成的集合，$\oplus$表示集合的对称差运算。下面以图10-37 为例，详细介绍匈牙利算法的具体执行过程：  
![图10-37 二分图 ](images/e75e6b51eaa2d7dcbd869cabf1198a4ab254d8c498cf74b11e8db5905f80f0b4.jpg)  
![图10-38 步骤1 效果图 ](images/a85e16b732f3f408c1a3f889dd66171d41954384c66b3a6769a239cb765226ce.jpg)  
（1）首先任给一个初始匹配$M=\{(x_{1},y_{1}),\;\;(x_{3},y_{5}),\;\;(x_{5},y_{3})\}$，如图10-38 所示。  
（2）$x_{2},x_{4}$非饱和，故$X$非饱和。确定其中一个非饱和点$x_{2}$，令${S}=\{x_{2}\}$，$T=\varnothing$。  
（3）$S$邻接结点集${N}_{G}(S)=\{y_{2},y_{3}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{3}\}$，选择$y_{3}$  
（4）$y_{3}$已饱和，因$M$中有边$(y_{3},x_{5})$，故令：  
$$
S=S\cup\{x_{5}\}=\{x_{2},x_{5}\},\ T=T\cup\{y_{3}\}=\{y_{3}\}
$$  
（5）因为$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{4},y_{5}\}$，选择${{y}}_{5}$  
（6）$y_{5}$已饱和，因为$M$存在边$(y_{5},x_{3})$，故令：
$$
S=S\cup\{x_{3}\}=\{x_{2},x_{3},x_{5}\},\,\,\,T=T\cup\{y_{5}\}=\{y_{3},y_{5}\}
$$  
（7）$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{4}\},$,选择$y_{2}$  
（8）$y_{2}$不饱和，故存在从$x_{2}$到$y_{2}$的可增广道$P$。对于当前匹配$M=\{(x_{1},y_{1}),(x_{3},y_{5}),$$(x_{5},y_{3})\}$，求得可增广路$P$如图10 −39 加粗部分所示，得到$P$的边集：  
$$
E(P)=\{(x_{2},y_{3}),(y_{3},x_{5}),(x_{5},y_{5}),(y_{5},x_{3}),(x_{3},y_{2})\}
$$  
按下十重新调整匹配$M$，得到如图10 −40 所示一个新匹配$M$  
$$
M=M\oplus E(P)=\{(x_{1},y_{1}),(x_{2},y_{3}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
10-39 步骤8 过程图  
图10-40 步骤8 过程图2  
（9）在新匹配下继续查找可增广道。查看$ X$是否饱和，显然${{x}}_{4}$非饱和，选择该非饱和点$x_{4}$，并令$S=\{x_{4}\}$，$T=\varnothing$。  
（10）$N_{G}(S)=\{y_{3}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{3}\}$，选择$y_{3}$  
（11）$y_{3}$已饱和，因为匹配$M$中存在$(y_{3},x_{2})$，故令：
$$
S=S\cup\{x_{2}\}=\{x_{2},x_{4}\},\,\,\,T=T\cup\{y_{3}\}=\{y_{3}\}
$$  
（12）$N_{G}(S)=\{y_{2},y_{3}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{2}\}$，选择$y_{2}$（13）$y_{2}$已饱和，因为匹配$M$中存在$(y_{2},x_{3})$，故令：  
$$
S=S\cup\{x_{3}\}=\{x_{2},x_{3},x_{4}\},\,\,\,T=T\cup\{y_{2}\}=\{y_{2},y_{3}\}
$$  
（14）$N_{G}(S)=\{y_{2},y_{3},y_{5}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{5}\}$，选择$y_{5}$（15）$y_{5}$已饱和，因为匹配$M$中存在了$(y_{5},x_{5})$，故令：  
$$
S=S\cup\{x_{5}\}=\{x_{2},x_{3},x_{4},x_{5}\},\,\,\,T=T\cup\{y_{5}\}=\{y_{2},y_{3},y_{5}\}
$$  
（16 ）$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{4}\}$，选择${\cdot}y_{4}$（17）$y_{4}$不饱和，故可求一条从$x_{4}$到$y_{4}$的可增广路$ P$。对于当前匹配：  
$$
M=\{(x_{1},y_{1}),(x_{2},y_{3}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
求得如图10 −41 加粗部分所示的可增广道路$P$， $P$的边集为：  
$$
E(P)=\{(x_{4},y_{3}),(y_{3},x_{2}),(x_{2},y_{2}),(y_{2},x_{3}),(x_{3},y_{5}),(y_{5},x_{5}),(x_{5},y_{4})\}
$$  
按下式重新调整匹配$M$，得到如图10 −43 所示的一个新匹配  
![](images/ee96514b37bbad784ca2a76b1641bd0dbdac20d6a3f2ab76c80847e37bff2151.jpg)  
至此，集合$\cdot X$已经饱和，求得的如下最大匹配：  
$$
M=\{(x_{1},y_{1}),(x_{2},y_{2}),(x_{3},y_{5}),(x_{4},y_{3}),(x_{5},y_{4})\}
$$  
设二分图$G$有${n}$个结点$m$条边，使用匈牙利算法最大匹配时，初始匹配可以空，故算法最多找$n$条可增广道，每找一条可增广路，最多比较$m$条边。因此，匈牙利算法的最坏时间复杂度为$O(m n)$。由此可见，匈牙利算法是一个有效算法。",二分图中包含匹配
匹配,定义,交错道,,"对于任意给定的一个二分图，首先讨论如何判断该图中某个给定的匹配是否为最大匹配。为此，引入交错道和可增广道的概念，具体如下：  
【定义10.5】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图， $M$是图$G$的某个匹配，若从𝐺中的某个结点到另一个结点之间存在一条通路，且该通路由属于$\cdot M$和不属于$M$的边交替构成，则称此通路为 𝑴 交错道。若 $M$ 交错道的两端点均为 $M$ 非饱和点，则称其为 𝑴 可增广道。  
例如，对于图10-35（a）所示匹配，$P=y_{1}x_{2}y_{5}x_{4}y_{3}x_{1}$是一条交错道，对于图10-35（b）所示匹配，$P=y_{1}x_{2}y_{5}x_{4}y_{3}x_{1}$则是一条可增广道，具体见图10-35（b）的粗线部分。  
![图10-35  交错道与可增广道  ](images/f5e335487e12a671cc013f6ede9981700aa6193018e616b34157cc9869d086b6.jpg)  
在1957 年，法国著名数学家贝尔格给出了判定某个匹配是最大匹配的充分必要条件。这就是著名的贝尔格定理，具体如下：  
【定理10.10】（贝尔格定理）设$G=\langle X,E,Y\rangle$是任意给定的一个二分图， 𝑀是图𝐺的某个匹配，则$M$是图$G$最大匹配的充要条件是$G$中不存在$M$可增广道。  
在1965 年，匈牙利的著名数学家埃德蒙兹基于贝尔格定理提出构造二分图最大匹配的著名算法，为纪念他的祖国，将该算法命名为匈牙利算法。算法基本思路如下：  
假设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，如果对于该图的某个匹配𝑀，结点集合𝑋的每个结点都是饱和结点，则该匹配就是最大匹配。否则，任取𝑋中的某个非饱和结点为起点做匹配$M$的交错道。此时，如果该交错道最后一个结点是饱和结点，如图10-36 中$P_{1}$所示，则匹配$M$就是最大匹配。否则，如果该交错道最后一个结点也是一个非饱和结点，则得到一条可增广道，如图10-36 中$P_{2}$所示。  
![图 10-36   对可增广道的增广 ](images/18f50be9390d6af7d21020996653e950e5f8bda427f6af3f0640cd631a139c62.jpg)  
不难看出，该交错道$P_{2}$中不属于$M$的所有边数比属于属于$M$的边数多一个，而且交错道中不属于$M$的所有边数也是互不相邻的，故可由这些边构成一个新的匹配$M^{*}$。由于${\mathbf{\nabla}}^{*}$的边数比$M$的边数多一个，故称$M^{*}$是对$M$的一个增广。继续上述过程，直到图中没有可增广道路为止，此时的匹配就是所求的最大匹配。  
从上述讨论不难发现，匈牙利算法的核心思想就是首先在当前匹配基础上寻找可增广道，找到可增广道后，就通过对该可增广道上所有边的匹配属性取反，即对可增广道上所有边的集合$ E(P)$与匹配$M$做集合的对称差运算$\oplus$，由此得到新的集合就是一个规模更大的新匹配，然后在这个新匹配的基础上继续寻找新可增广道，如此下去，直到没有可增广道路为止。  
对于任意给定的二分图$G=\langle X,E,Y\rangle$，匈牙利算法的具体计算流程如下：  
（1）任给初始匹配$M$；  
（2）若𝑋中任一结点均饱和，则$M$即为所求，算法结束，否则转（3）；  
（3）在𝑋中找到一非$M$饱和点$x$，置$S=\{x\}$，$T=\varnothing$；  
（4）若$N_{G}(S)=T$，则停止，否则任选一点$y\in N_{G}(S)-T$；  
（5）若𝑦为$M$饱和点转（6），否则：求一条从$x$到𝑦的$M$可增广路$P$，置$M=M\oplus P$，转（2）  
（6）由于$ y$是$M$饱和点，故$M$中有一边 $(y,u)$，置$S=S\cup\{u\}$，$T=T\cup\{y\}$，转（4）。算法中$N_{G}(S)$表示 $G$上与$S$中任一结点相邻的所有结点组成的集合，$\oplus$表示集合的对称差运算。下面以图10-37 为例，详细介绍匈牙利算法的具体执行过程：  
![图10-37 二分图 ](images/e75e6b51eaa2d7dcbd869cabf1198a4ab254d8c498cf74b11e8db5905f80f0b4.jpg)  
![图10-38 步骤1 效果图 ](images/a85e16b732f3f408c1a3f889dd66171d41954384c66b3a6769a239cb765226ce.jpg)  
（1）首先任给一个初始匹配$M=\{(x_{1},y_{1}),\;\;(x_{3},y_{5}),\;\;(x_{5},y_{3})\}$，如图10-38 所示。  
（2）$x_{2},x_{4}$非饱和，故$X$非饱和。确定其中一个非饱和点$x_{2}$，令${S}=\{x_{2}\}$，$T=\varnothing$。  
（3）$S$邻接结点集${N}_{G}(S)=\{y_{2},y_{3}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{3}\}$，选择$y_{3}$  
（4）$y_{3}$已饱和，因$M$中有边$(y_{3},x_{5})$，故令：  
$$
S=S\cup\{x_{5}\}=\{x_{2},x_{5}\},\ T=T\cup\{y_{3}\}=\{y_{3}\}
$$  
（5）因为$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{4},y_{5}\}$，选择${{y}}_{5}$  
（6）$y_{5}$已饱和，因为$M$存在边$(y_{5},x_{3})$，故令：
$$
S=S\cup\{x_{3}\}=\{x_{2},x_{3},x_{5}\},\,\,\,T=T\cup\{y_{5}\}=\{y_{3},y_{5}\}
$$  
（7）$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{4}\},$,选择$y_{2}$  
（8）$y_{2}$不饱和，故存在从$x_{2}$到$y_{2}$的可增广道$P$。对于当前匹配$M=\{(x_{1},y_{1}),(x_{3},y_{5}),$$(x_{5},y_{3})\}$，求得可增广路$P$如图10 −39 加粗部分所示，得到$P$的边集：  
$$
E(P)=\{(x_{2},y_{3}),(y_{3},x_{5}),(x_{5},y_{5}),(y_{5},x_{3}),(x_{3},y_{2})\}
$$  
按下十重新调整匹配$M$，得到如图10 −40 所示一个新匹配$M$  
$$
M=M\oplus E(P)=\{(x_{1},y_{1}),(x_{2},y_{3}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
10-39 步骤8 过程图  
图10-40 步骤8 过程图2  
（9）在新匹配下继续查找可增广道。查看$ X$是否饱和，显然${{x}}_{4}$非饱和，选择该非饱和点$x_{4}$，并令$S=\{x_{4}\}$，$T=\varnothing$。  
（10）$N_{G}(S)=\{y_{3}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{3}\}$，选择$y_{3}$  
（11）$y_{3}$已饱和，因为匹配$M$中存在$(y_{3},x_{2})$，故令：
$$
S=S\cup\{x_{2}\}=\{x_{2},x_{4}\},\,\,\,T=T\cup\{y_{3}\}=\{y_{3}\}
$$  
（12）$N_{G}(S)=\{y_{2},y_{3}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{2}\}$，选择$y_{2}$（13）$y_{2}$已饱和，因为匹配$M$中存在$(y_{2},x_{3})$，故令：  
$$
S=S\cup\{x_{3}\}=\{x_{2},x_{3},x_{4}\},\,\,\,T=T\cup\{y_{2}\}=\{y_{2},y_{3}\}
$$  
（14）$N_{G}(S)=\{y_{2},y_{3},y_{5}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{5}\}$，选择$y_{5}$（15）$y_{5}$已饱和，因为匹配$M$中存在了$(y_{5},x_{5})$，故令：  
$$
S=S\cup\{x_{5}\}=\{x_{2},x_{3},x_{4},x_{5}\},\,\,\,T=T\cup\{y_{5}\}=\{y_{2},y_{3},y_{5}\}
$$  
（16 ）$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{4}\}$，选择${\cdot}y_{4}$（17）$y_{4}$不饱和，故可求一条从$x_{4}$到$y_{4}$的可增广路$ P$。对于当前匹配：  
$$
M=\{(x_{1},y_{1}),(x_{2},y_{3}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
求得如图10 −41 加粗部分所示的可增广道路$P$， $P$的边集为：  
$$
E(P)=\{(x_{4},y_{3}),(y_{3},x_{2}),(x_{2},y_{2}),(y_{2},x_{3}),(x_{3},y_{5}),(y_{5},x_{5}),(x_{5},y_{4})\}
$$  
按下式重新调整匹配$M$，得到如图10 −43 所示的一个新匹配  
![](images/ee96514b37bbad784ca2a76b1641bd0dbdac20d6a3f2ab76c80847e37bff2151.jpg)  
至此，集合$\cdot X$已经饱和，求得的如下最大匹配：  
$$
M=\{(x_{1},y_{1}),(x_{2},y_{2}),(x_{3},y_{5}),(x_{4},y_{3}),(x_{5},y_{4})\}
$$  
设二分图$G$有${n}$个结点$m$条边，使用匈牙利算法最大匹配时，初始匹配可以空，故算法最多找$n$条可增广道，每找一条可增广路，最多比较$m$条边。因此，匈牙利算法的最坏时间复杂度为$O(m n)$。由此可见，匈牙利算法是一个有效算法。",交错道是匹配中边交替构成的通路
匹配,定义,可增广道,,"对于任意给定的一个二分图，首先讨论如何判断该图中某个给定的匹配是否为最大匹配。为此，引入交错道和可增广道的概念，具体如下：  
【定义10.5】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图， $M$是图$G$的某个匹配，若从𝐺中的某个结点到另一个结点之间存在一条通路，且该通路由属于$\cdot M$和不属于$M$的边交替构成，则称此通路为 𝑴 交错道。若 $M$ 交错道的两端点均为 $M$ 非饱和点，则称其为 𝑴 可增广道。  
例如，对于图10-35（a）所示匹配，$P=y_{1}x_{2}y_{5}x_{4}y_{3}x_{1}$是一条交错道，对于图10-35（b）所示匹配，$P=y_{1}x_{2}y_{5}x_{4}y_{3}x_{1}$则是一条可增广道，具体见图10-35（b）的粗线部分。  
![图10-35  交错道与可增广道  ](images/f5e335487e12a671cc013f6ede9981700aa6193018e616b34157cc9869d086b6.jpg)  
在1957 年，法国著名数学家贝尔格给出了判定某个匹配是最大匹配的充分必要条件。这就是著名的贝尔格定理，具体如下：  
【定理10.10】（贝尔格定理）设$G=\langle X,E,Y\rangle$是任意给定的一个二分图， 𝑀是图𝐺的某个匹配，则$M$是图$G$最大匹配的充要条件是$G$中不存在$M$可增广道。  
在1965 年，匈牙利的著名数学家埃德蒙兹基于贝尔格定理提出构造二分图最大匹配的著名算法，为纪念他的祖国，将该算法命名为匈牙利算法。算法基本思路如下：  
假设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，如果对于该图的某个匹配𝑀，结点集合𝑋的每个结点都是饱和结点，则该匹配就是最大匹配。否则，任取𝑋中的某个非饱和结点为起点做匹配$M$的交错道。此时，如果该交错道最后一个结点是饱和结点，如图10-36 中$P_{1}$所示，则匹配$M$就是最大匹配。否则，如果该交错道最后一个结点也是一个非饱和结点，则得到一条可增广道，如图10-36 中$P_{2}$所示。  
![图 10-36   对可增广道的增广 ](images/18f50be9390d6af7d21020996653e950e5f8bda427f6af3f0640cd631a139c62.jpg)  
不难看出，该交错道$P_{2}$中不属于$M$的所有边数比属于属于$M$的边数多一个，而且交错道中不属于$M$的所有边数也是互不相邻的，故可由这些边构成一个新的匹配$M^{*}$。由于${\mathbf{\nabla}}^{*}$的边数比$M$的边数多一个，故称$M^{*}$是对$M$的一个增广。继续上述过程，直到图中没有可增广道路为止，此时的匹配就是所求的最大匹配。  
从上述讨论不难发现，匈牙利算法的核心思想就是首先在当前匹配基础上寻找可增广道，找到可增广道后，就通过对该可增广道上所有边的匹配属性取反，即对可增广道上所有边的集合$ E(P)$与匹配$M$做集合的对称差运算$\oplus$，由此得到新的集合就是一个规模更大的新匹配，然后在这个新匹配的基础上继续寻找新可增广道，如此下去，直到没有可增广道路为止。  
对于任意给定的二分图$G=\langle X,E,Y\rangle$，匈牙利算法的具体计算流程如下：  
（1）任给初始匹配$M$；  
（2）若𝑋中任一结点均饱和，则$M$即为所求，算法结束，否则转（3）；  
（3）在𝑋中找到一非$M$饱和点$x$，置$S=\{x\}$，$T=\varnothing$；  
（4）若$N_{G}(S)=T$，则停止，否则任选一点$y\in N_{G}(S)-T$；  
（5）若𝑦为$M$饱和点转（6），否则：求一条从$x$到𝑦的$M$可增广路$P$，置$M=M\oplus P$，转（2）  
（6）由于$ y$是$M$饱和点，故$M$中有一边 $(y,u)$，置$S=S\cup\{u\}$，$T=T\cup\{y\}$，转（4）。算法中$N_{G}(S)$表示 $G$上与$S$中任一结点相邻的所有结点组成的集合，$\oplus$表示集合的对称差运算。下面以图10-37 为例，详细介绍匈牙利算法的具体执行过程：  
![图10-37 二分图 ](images/e75e6b51eaa2d7dcbd869cabf1198a4ab254d8c498cf74b11e8db5905f80f0b4.jpg)  
![图10-38 步骤1 效果图 ](images/a85e16b732f3f408c1a3f889dd66171d41954384c66b3a6769a239cb765226ce.jpg)  
（1）首先任给一个初始匹配$M=\{(x_{1},y_{1}),\;\;(x_{3},y_{5}),\;\;(x_{5},y_{3})\}$，如图10-38 所示。  
（2）$x_{2},x_{4}$非饱和，故$X$非饱和。确定其中一个非饱和点$x_{2}$，令${S}=\{x_{2}\}$，$T=\varnothing$。  
（3）$S$邻接结点集${N}_{G}(S)=\{y_{2},y_{3}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{3}\}$，选择$y_{3}$  
（4）$y_{3}$已饱和，因$M$中有边$(y_{3},x_{5})$，故令：  
$$
S=S\cup\{x_{5}\}=\{x_{2},x_{5}\},\ T=T\cup\{y_{3}\}=\{y_{3}\}
$$  
（5）因为$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{4},y_{5}\}$，选择${{y}}_{5}$  
（6）$y_{5}$已饱和，因为$M$存在边$(y_{5},x_{3})$，故令：
$$
S=S\cup\{x_{3}\}=\{x_{2},x_{3},x_{5}\},\,\,\,T=T\cup\{y_{5}\}=\{y_{3},y_{5}\}
$$  
（7）$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{4}\},$,选择$y_{2}$  
（8）$y_{2}$不饱和，故存在从$x_{2}$到$y_{2}$的可增广道$P$。对于当前匹配$M=\{(x_{1},y_{1}),(x_{3},y_{5}),$$(x_{5},y_{3})\}$，求得可增广路$P$如图10 −39 加粗部分所示，得到$P$的边集：  
$$
E(P)=\{(x_{2},y_{3}),(y_{3},x_{5}),(x_{5},y_{5}),(y_{5},x_{3}),(x_{3},y_{2})\}
$$  
按下十重新调整匹配$M$，得到如图10 −40 所示一个新匹配$M$  
$$
M=M\oplus E(P)=\{(x_{1},y_{1}),(x_{2},y_{3}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
10-39 步骤8 过程图  
图10-40 步骤8 过程图2  
（9）在新匹配下继续查找可增广道。查看$ X$是否饱和，显然${{x}}_{4}$非饱和，选择该非饱和点$x_{4}$，并令$S=\{x_{4}\}$，$T=\varnothing$。  
（10）$N_{G}(S)=\{y_{3}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{3}\}$，选择$y_{3}$  
（11）$y_{3}$已饱和，因为匹配$M$中存在$(y_{3},x_{2})$，故令：
$$
S=S\cup\{x_{2}\}=\{x_{2},x_{4}\},\,\,\,T=T\cup\{y_{3}\}=\{y_{3}\}
$$  
（12）$N_{G}(S)=\{y_{2},y_{3}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{2}\}$，选择$y_{2}$（13）$y_{2}$已饱和，因为匹配$M$中存在$(y_{2},x_{3})$，故令：  
$$
S=S\cup\{x_{3}\}=\{x_{2},x_{3},x_{4}\},\,\,\,T=T\cup\{y_{2}\}=\{y_{2},y_{3}\}
$$  
（14）$N_{G}(S)=\{y_{2},y_{3},y_{5}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{5}\}$，选择$y_{5}$（15）$y_{5}$已饱和，因为匹配$M$中存在了$(y_{5},x_{5})$，故令：  
$$
S=S\cup\{x_{5}\}=\{x_{2},x_{3},x_{4},x_{5}\},\,\,\,T=T\cup\{y_{5}\}=\{y_{2},y_{3},y_{5}\}
$$  
（16 ）$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{4}\}$，选择${\cdot}y_{4}$（17）$y_{4}$不饱和，故可求一条从$x_{4}$到$y_{4}$的可增广路$ P$。对于当前匹配：  
$$
M=\{(x_{1},y_{1}),(x_{2},y_{3}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
求得如图10 −41 加粗部分所示的可增广道路$P$， $P$的边集为：  
$$
E(P)=\{(x_{4},y_{3}),(y_{3},x_{2}),(x_{2},y_{2}),(y_{2},x_{3}),(x_{3},y_{5}),(y_{5},x_{5}),(x_{5},y_{4})\}
$$  
按下式重新调整匹配$M$，得到如图10 −43 所示的一个新匹配  
![](images/ee96514b37bbad784ca2a76b1641bd0dbdac20d6a3f2ab76c80847e37bff2151.jpg)  
至此，集合$\cdot X$已经饱和，求得的如下最大匹配：  
$$
M=\{(x_{1},y_{1}),(x_{2},y_{2}),(x_{3},y_{5}),(x_{4},y_{3}),(x_{5},y_{4})\}
$$  
设二分图$G$有${n}$个结点$m$条边，使用匈牙利算法最大匹配时，初始匹配可以空，故算法最多找$n$条可增广道，每找一条可增广路，最多比较$m$条边。因此，匈牙利算法的最坏时间复杂度为$O(m n)$。由此可见，匈牙利算法是一个有效算法。",可增广道是交错道的两端点均为非饱和点的通路
贝尔格定理,判定,匹配,,"对于任意给定的一个二分图，首先讨论如何判断该图中某个给定的匹配是否为最大匹配。为此，引入交错道和可增广道的概念，具体如下：  
【定义10.5】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图， $M$是图$G$的某个匹配，若从𝐺中的某个结点到另一个结点之间存在一条通路，且该通路由属于$\cdot M$和不属于$M$的边交替构成，则称此通路为 𝑴 交错道。若 $M$ 交错道的两端点均为 $M$ 非饱和点，则称其为 𝑴 可增广道。  
例如，对于图10-35（a）所示匹配，$P=y_{1}x_{2}y_{5}x_{4}y_{3}x_{1}$是一条交错道，对于图10-35（b）所示匹配，$P=y_{1}x_{2}y_{5}x_{4}y_{3}x_{1}$则是一条可增广道，具体见图10-35（b）的粗线部分。  
![图10-35  交错道与可增广道  ](images/f5e335487e12a671cc013f6ede9981700aa6193018e616b34157cc9869d086b6.jpg)  
在1957 年，法国著名数学家贝尔格给出了判定某个匹配是最大匹配的充分必要条件。这就是著名的贝尔格定理，具体如下：  
【定理10.10】（贝尔格定理）设$G=\langle X,E,Y\rangle$是任意给定的一个二分图， 𝑀是图𝐺的某个匹配，则$M$是图$G$最大匹配的充要条件是$G$中不存在$M$可增广道。  
在1965 年，匈牙利的著名数学家埃德蒙兹基于贝尔格定理提出构造二分图最大匹配的著名算法，为纪念他的祖国，将该算法命名为匈牙利算法。算法基本思路如下：  
假设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，如果对于该图的某个匹配𝑀，结点集合𝑋的每个结点都是饱和结点，则该匹配就是最大匹配。否则，任取𝑋中的某个非饱和结点为起点做匹配$M$的交错道。此时，如果该交错道最后一个结点是饱和结点，如图10-36 中$P_{1}$所示，则匹配$M$就是最大匹配。否则，如果该交错道最后一个结点也是一个非饱和结点，则得到一条可增广道，如图10-36 中$P_{2}$所示。  
![图 10-36   对可增广道的增广 ](images/18f50be9390d6af7d21020996653e950e5f8bda427f6af3f0640cd631a139c62.jpg)  
不难看出，该交错道$P_{2}$中不属于$M$的所有边数比属于属于$M$的边数多一个，而且交错道中不属于$M$的所有边数也是互不相邻的，故可由这些边构成一个新的匹配$M^{*}$。由于${\mathbf{\nabla}}^{*}$的边数比$M$的边数多一个，故称$M^{*}$是对$M$的一个增广。继续上述过程，直到图中没有可增广道路为止，此时的匹配就是所求的最大匹配。  
从上述讨论不难发现，匈牙利算法的核心思想就是首先在当前匹配基础上寻找可增广道，找到可增广道后，就通过对该可增广道上所有边的匹配属性取反，即对可增广道上所有边的集合$ E(P)$与匹配$M$做集合的对称差运算$\oplus$，由此得到新的集合就是一个规模更大的新匹配，然后在这个新匹配的基础上继续寻找新可增广道，如此下去，直到没有可增广道路为止。  
对于任意给定的二分图$G=\langle X,E,Y\rangle$，匈牙利算法的具体计算流程如下：  
（1）任给初始匹配$M$；  
（2）若𝑋中任一结点均饱和，则$M$即为所求，算法结束，否则转（3）；  
（3）在𝑋中找到一非$M$饱和点$x$，置$S=\{x\}$，$T=\varnothing$；  
（4）若$N_{G}(S)=T$，则停止，否则任选一点$y\in N_{G}(S)-T$；  
（5）若𝑦为$M$饱和点转（6），否则：求一条从$x$到𝑦的$M$可增广路$P$，置$M=M\oplus P$，转（2）  
（6）由于$ y$是$M$饱和点，故$M$中有一边 $(y,u)$，置$S=S\cup\{u\}$，$T=T\cup\{y\}$，转（4）。算法中$N_{G}(S)$表示 $G$上与$S$中任一结点相邻的所有结点组成的集合，$\oplus$表示集合的对称差运算。下面以图10-37 为例，详细介绍匈牙利算法的具体执行过程：  
![图10-37 二分图 ](images/e75e6b51eaa2d7dcbd869cabf1198a4ab254d8c498cf74b11e8db5905f80f0b4.jpg)  
![图10-38 步骤1 效果图 ](images/a85e16b732f3f408c1a3f889dd66171d41954384c66b3a6769a239cb765226ce.jpg)  
（1）首先任给一个初始匹配$M=\{(x_{1},y_{1}),\;\;(x_{3},y_{5}),\;\;(x_{5},y_{3})\}$，如图10-38 所示。  
（2）$x_{2},x_{4}$非饱和，故$X$非饱和。确定其中一个非饱和点$x_{2}$，令${S}=\{x_{2}\}$，$T=\varnothing$。  
（3）$S$邻接结点集${N}_{G}(S)=\{y_{2},y_{3}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{3}\}$，选择$y_{3}$  
（4）$y_{3}$已饱和，因$M$中有边$(y_{3},x_{5})$，故令：  
$$
S=S\cup\{x_{5}\}=\{x_{2},x_{5}\},\ T=T\cup\{y_{3}\}=\{y_{3}\}
$$  
（5）因为$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{4},y_{5}\}$，选择${{y}}_{5}$  
（6）$y_{5}$已饱和，因为$M$存在边$(y_{5},x_{3})$，故令：
$$
S=S\cup\{x_{3}\}=\{x_{2},x_{3},x_{5}\},\,\,\,T=T\cup\{y_{5}\}=\{y_{3},y_{5}\}
$$  
（7）$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{4}\},$,选择$y_{2}$  
（8）$y_{2}$不饱和，故存在从$x_{2}$到$y_{2}$的可增广道$P$。对于当前匹配$M=\{(x_{1},y_{1}),(x_{3},y_{5}),$$(x_{5},y_{3})\}$，求得可增广路$P$如图10 −39 加粗部分所示，得到$P$的边集：  
$$
E(P)=\{(x_{2},y_{3}),(y_{3},x_{5}),(x_{5},y_{5}),(y_{5},x_{3}),(x_{3},y_{2})\}
$$  
按下十重新调整匹配$M$，得到如图10 −40 所示一个新匹配$M$  
$$
M=M\oplus E(P)=\{(x_{1},y_{1}),(x_{2},y_{3}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
10-39 步骤8 过程图  
图10-40 步骤8 过程图2  
（9）在新匹配下继续查找可增广道。查看$ X$是否饱和，显然${{x}}_{4}$非饱和，选择该非饱和点$x_{4}$，并令$S=\{x_{4}\}$，$T=\varnothing$。  
（10）$N_{G}(S)=\{y_{3}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{3}\}$，选择$y_{3}$  
（11）$y_{3}$已饱和，因为匹配$M$中存在$(y_{3},x_{2})$，故令：
$$
S=S\cup\{x_{2}\}=\{x_{2},x_{4}\},\,\,\,T=T\cup\{y_{3}\}=\{y_{3}\}
$$  
（12）$N_{G}(S)=\{y_{2},y_{3}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{2}\}$，选择$y_{2}$（13）$y_{2}$已饱和，因为匹配$M$中存在$(y_{2},x_{3})$，故令：  
$$
S=S\cup\{x_{3}\}=\{x_{2},x_{3},x_{4}\},\,\,\,T=T\cup\{y_{2}\}=\{y_{2},y_{3}\}
$$  
（14）$N_{G}(S)=\{y_{2},y_{3},y_{5}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{5}\}$，选择$y_{5}$（15）$y_{5}$已饱和，因为匹配$M$中存在了$(y_{5},x_{5})$，故令：  
$$
S=S\cup\{x_{5}\}=\{x_{2},x_{3},x_{4},x_{5}\},\,\,\,T=T\cup\{y_{5}\}=\{y_{2},y_{3},y_{5}\}
$$  
（16 ）$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{4}\}$，选择${\cdot}y_{4}$（17）$y_{4}$不饱和，故可求一条从$x_{4}$到$y_{4}$的可增广路$ P$。对于当前匹配：  
$$
M=\{(x_{1},y_{1}),(x_{2},y_{3}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
求得如图10 −41 加粗部分所示的可增广道路$P$， $P$的边集为：  
$$
E(P)=\{(x_{4},y_{3}),(y_{3},x_{2}),(x_{2},y_{2}),(y_{2},x_{3}),(x_{3},y_{5}),(y_{5},x_{5}),(x_{5},y_{4})\}
$$  
按下式重新调整匹配$M$，得到如图10 −43 所示的一个新匹配  
![](images/ee96514b37bbad784ca2a76b1641bd0dbdac20d6a3f2ab76c80847e37bff2151.jpg)  
至此，集合$\cdot X$已经饱和，求得的如下最大匹配：  
$$
M=\{(x_{1},y_{1}),(x_{2},y_{2}),(x_{3},y_{5}),(x_{4},y_{3}),(x_{5},y_{4})\}
$$  
设二分图$G$有${n}$个结点$m$条边，使用匈牙利算法最大匹配时，初始匹配可以空，故算法最多找$n$条可增广道，每找一条可增广路，最多比较$m$条边。因此，匈牙利算法的最坏时间复杂度为$O(m n)$。由此可见，匈牙利算法是一个有效算法。",贝尔格定理判定匹配是否为最大匹配
匈牙利算法,基于,贝尔格定理,,"对于任意给定的一个二分图，首先讨论如何判断该图中某个给定的匹配是否为最大匹配。为此，引入交错道和可增广道的概念，具体如下：  
【定义10.5】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图， $M$是图$G$的某个匹配，若从𝐺中的某个结点到另一个结点之间存在一条通路，且该通路由属于$\cdot M$和不属于$M$的边交替构成，则称此通路为 𝑴 交错道。若 $M$ 交错道的两端点均为 $M$ 非饱和点，则称其为 𝑴 可增广道。  
例如，对于图10-35（a）所示匹配，$P=y_{1}x_{2}y_{5}x_{4}y_{3}x_{1}$是一条交错道，对于图10-35（b）所示匹配，$P=y_{1}x_{2}y_{5}x_{4}y_{3}x_{1}$则是一条可增广道，具体见图10-35（b）的粗线部分。  
![图10-35  交错道与可增广道  ](images/f5e335487e12a671cc013f6ede9981700aa6193018e616b34157cc9869d086b6.jpg)  
在1957 年，法国著名数学家贝尔格给出了判定某个匹配是最大匹配的充分必要条件。这就是著名的贝尔格定理，具体如下：  
【定理10.10】（贝尔格定理）设$G=\langle X,E,Y\rangle$是任意给定的一个二分图， 𝑀是图𝐺的某个匹配，则$M$是图$G$最大匹配的充要条件是$G$中不存在$M$可增广道。  
在1965 年，匈牙利的著名数学家埃德蒙兹基于贝尔格定理提出构造二分图最大匹配的著名算法，为纪念他的祖国，将该算法命名为匈牙利算法。算法基本思路如下：  
假设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，如果对于该图的某个匹配𝑀，结点集合𝑋的每个结点都是饱和结点，则该匹配就是最大匹配。否则，任取𝑋中的某个非饱和结点为起点做匹配$M$的交错道。此时，如果该交错道最后一个结点是饱和结点，如图10-36 中$P_{1}$所示，则匹配$M$就是最大匹配。否则，如果该交错道最后一个结点也是一个非饱和结点，则得到一条可增广道，如图10-36 中$P_{2}$所示。  
![图 10-36   对可增广道的增广 ](images/18f50be9390d6af7d21020996653e950e5f8bda427f6af3f0640cd631a139c62.jpg)  
不难看出，该交错道$P_{2}$中不属于$M$的所有边数比属于属于$M$的边数多一个，而且交错道中不属于$M$的所有边数也是互不相邻的，故可由这些边构成一个新的匹配$M^{*}$。由于${\mathbf{\nabla}}^{*}$的边数比$M$的边数多一个，故称$M^{*}$是对$M$的一个增广。继续上述过程，直到图中没有可增广道路为止，此时的匹配就是所求的最大匹配。  
从上述讨论不难发现，匈牙利算法的核心思想就是首先在当前匹配基础上寻找可增广道，找到可增广道后，就通过对该可增广道上所有边的匹配属性取反，即对可增广道上所有边的集合$ E(P)$与匹配$M$做集合的对称差运算$\oplus$，由此得到新的集合就是一个规模更大的新匹配，然后在这个新匹配的基础上继续寻找新可增广道，如此下去，直到没有可增广道路为止。  
对于任意给定的二分图$G=\langle X,E,Y\rangle$，匈牙利算法的具体计算流程如下：  
（1）任给初始匹配$M$；  
（2）若𝑋中任一结点均饱和，则$M$即为所求，算法结束，否则转（3）；  
（3）在𝑋中找到一非$M$饱和点$x$，置$S=\{x\}$，$T=\varnothing$；  
（4）若$N_{G}(S)=T$，则停止，否则任选一点$y\in N_{G}(S)-T$；  
（5）若𝑦为$M$饱和点转（6），否则：求一条从$x$到𝑦的$M$可增广路$P$，置$M=M\oplus P$，转（2）  
（6）由于$ y$是$M$饱和点，故$M$中有一边 $(y,u)$，置$S=S\cup\{u\}$，$T=T\cup\{y\}$，转（4）。算法中$N_{G}(S)$表示 $G$上与$S$中任一结点相邻的所有结点组成的集合，$\oplus$表示集合的对称差运算。下面以图10-37 为例，详细介绍匈牙利算法的具体执行过程：  
![图10-37 二分图 ](images/e75e6b51eaa2d7dcbd869cabf1198a4ab254d8c498cf74b11e8db5905f80f0b4.jpg)  
![图10-38 步骤1 效果图 ](images/a85e16b732f3f408c1a3f889dd66171d41954384c66b3a6769a239cb765226ce.jpg)  
（1）首先任给一个初始匹配$M=\{(x_{1},y_{1}),\;\;(x_{3},y_{5}),\;\;(x_{5},y_{3})\}$，如图10-38 所示。  
（2）$x_{2},x_{4}$非饱和，故$X$非饱和。确定其中一个非饱和点$x_{2}$，令${S}=\{x_{2}\}$，$T=\varnothing$。  
（3）$S$邻接结点集${N}_{G}(S)=\{y_{2},y_{3}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{3}\}$，选择$y_{3}$  
（4）$y_{3}$已饱和，因$M$中有边$(y_{3},x_{5})$，故令：  
$$
S=S\cup\{x_{5}\}=\{x_{2},x_{5}\},\ T=T\cup\{y_{3}\}=\{y_{3}\}
$$  
（5）因为$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{4},y_{5}\}$，选择${{y}}_{5}$  
（6）$y_{5}$已饱和，因为$M$存在边$(y_{5},x_{3})$，故令：
$$
S=S\cup\{x_{3}\}=\{x_{2},x_{3},x_{5}\},\,\,\,T=T\cup\{y_{5}\}=\{y_{3},y_{5}\}
$$  
（7）$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{4}\},$,选择$y_{2}$  
（8）$y_{2}$不饱和，故存在从$x_{2}$到$y_{2}$的可增广道$P$。对于当前匹配$M=\{(x_{1},y_{1}),(x_{3},y_{5}),$$(x_{5},y_{3})\}$，求得可增广路$P$如图10 −39 加粗部分所示，得到$P$的边集：  
$$
E(P)=\{(x_{2},y_{3}),(y_{3},x_{5}),(x_{5},y_{5}),(y_{5},x_{3}),(x_{3},y_{2})\}
$$  
按下十重新调整匹配$M$，得到如图10 −40 所示一个新匹配$M$  
$$
M=M\oplus E(P)=\{(x_{1},y_{1}),(x_{2},y_{3}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
10-39 步骤8 过程图  
图10-40 步骤8 过程图2  
（9）在新匹配下继续查找可增广道。查看$ X$是否饱和，显然${{x}}_{4}$非饱和，选择该非饱和点$x_{4}$，并令$S=\{x_{4}\}$，$T=\varnothing$。  
（10）$N_{G}(S)=\{y_{3}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{3}\}$，选择$y_{3}$  
（11）$y_{3}$已饱和，因为匹配$M$中存在$(y_{3},x_{2})$，故令：
$$
S=S\cup\{x_{2}\}=\{x_{2},x_{4}\},\,\,\,T=T\cup\{y_{3}\}=\{y_{3}\}
$$  
（12）$N_{G}(S)=\{y_{2},y_{3}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{2}\}$，选择$y_{2}$（13）$y_{2}$已饱和，因为匹配$M$中存在$(y_{2},x_{3})$，故令：  
$$
S=S\cup\{x_{3}\}=\{x_{2},x_{3},x_{4}\},\,\,\,T=T\cup\{y_{2}\}=\{y_{2},y_{3}\}
$$  
（14）$N_{G}(S)=\{y_{2},y_{3},y_{5}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{5}\}$，选择$y_{5}$（15）$y_{5}$已饱和，因为匹配$M$中存在了$(y_{5},x_{5})$，故令：  
$$
S=S\cup\{x_{5}\}=\{x_{2},x_{3},x_{4},x_{5}\},\,\,\,T=T\cup\{y_{5}\}=\{y_{2},y_{3},y_{5}\}
$$  
（16 ）$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{4}\}$，选择${\cdot}y_{4}$（17）$y_{4}$不饱和，故可求一条从$x_{4}$到$y_{4}$的可增广路$ P$。对于当前匹配：  
$$
M=\{(x_{1},y_{1}),(x_{2},y_{3}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
求得如图10 −41 加粗部分所示的可增广道路$P$， $P$的边集为：  
$$
E(P)=\{(x_{4},y_{3}),(y_{3},x_{2}),(x_{2},y_{2}),(y_{2},x_{3}),(x_{3},y_{5}),(y_{5},x_{5}),(x_{5},y_{4})\}
$$  
按下式重新调整匹配$M$，得到如图10 −43 所示的一个新匹配  
![](images/ee96514b37bbad784ca2a76b1641bd0dbdac20d6a3f2ab76c80847e37bff2151.jpg)  
至此，集合$\cdot X$已经饱和，求得的如下最大匹配：  
$$
M=\{(x_{1},y_{1}),(x_{2},y_{2}),(x_{3},y_{5}),(x_{4},y_{3}),(x_{5},y_{4})\}
$$  
设二分图$G$有${n}$个结点$m$条边，使用匈牙利算法最大匹配时，初始匹配可以空，故算法最多找$n$条可增广道，每找一条可增广路，最多比较$m$条边。因此，匈牙利算法的最坏时间复杂度为$O(m n)$。由此可见，匈牙利算法是一个有效算法。",匈牙利算法基于贝尔格定理构造最大匹配
匈牙利算法,寻找,可增广道,,"对于任意给定的一个二分图，首先讨论如何判断该图中某个给定的匹配是否为最大匹配。为此，引入交错道和可增广道的概念，具体如下：  
【定义10.5】设$G=\langle X,E,Y\rangle$是任意给定的一个二分图， $M$是图$G$的某个匹配，若从𝐺中的某个结点到另一个结点之间存在一条通路，且该通路由属于$\cdot M$和不属于$M$的边交替构成，则称此通路为 𝑴 交错道。若 $M$ 交错道的两端点均为 $M$ 非饱和点，则称其为 𝑴 可增广道。  
例如，对于图10-35（a）所示匹配，$P=y_{1}x_{2}y_{5}x_{4}y_{3}x_{1}$是一条交错道，对于图10-35（b）所示匹配，$P=y_{1}x_{2}y_{5}x_{4}y_{3}x_{1}$则是一条可增广道，具体见图10-35（b）的粗线部分。  
![图10-35  交错道与可增广道  ](images/f5e335487e12a671cc013f6ede9981700aa6193018e616b34157cc9869d086b6.jpg)  
在1957 年，法国著名数学家贝尔格给出了判定某个匹配是最大匹配的充分必要条件。这就是著名的贝尔格定理，具体如下：  
【定理10.10】（贝尔格定理）设$G=\langle X,E,Y\rangle$是任意给定的一个二分图， 𝑀是图𝐺的某个匹配，则$M$是图$G$最大匹配的充要条件是$G$中不存在$M$可增广道。  
在1965 年，匈牙利的著名数学家埃德蒙兹基于贝尔格定理提出构造二分图最大匹配的著名算法，为纪念他的祖国，将该算法命名为匈牙利算法。算法基本思路如下：  
假设$G=\langle X,E,Y\rangle$是任意给定的一个二分图，如果对于该图的某个匹配𝑀，结点集合𝑋的每个结点都是饱和结点，则该匹配就是最大匹配。否则，任取𝑋中的某个非饱和结点为起点做匹配$M$的交错道。此时，如果该交错道最后一个结点是饱和结点，如图10-36 中$P_{1}$所示，则匹配$M$就是最大匹配。否则，如果该交错道最后一个结点也是一个非饱和结点，则得到一条可增广道，如图10-36 中$P_{2}$所示。  
![图 10-36   对可增广道的增广 ](images/18f50be9390d6af7d21020996653e950e5f8bda427f6af3f0640cd631a139c62.jpg)  
不难看出，该交错道$P_{2}$中不属于$M$的所有边数比属于属于$M$的边数多一个，而且交错道中不属于$M$的所有边数也是互不相邻的，故可由这些边构成一个新的匹配$M^{*}$。由于${\mathbf{\nabla}}^{*}$的边数比$M$的边数多一个，故称$M^{*}$是对$M$的一个增广。继续上述过程，直到图中没有可增广道路为止，此时的匹配就是所求的最大匹配。  
从上述讨论不难发现，匈牙利算法的核心思想就是首先在当前匹配基础上寻找可增广道，找到可增广道后，就通过对该可增广道上所有边的匹配属性取反，即对可增广道上所有边的集合$ E(P)$与匹配$M$做集合的对称差运算$\oplus$，由此得到新的集合就是一个规模更大的新匹配，然后在这个新匹配的基础上继续寻找新可增广道，如此下去，直到没有可增广道路为止。  
对于任意给定的二分图$G=\langle X,E,Y\rangle$，匈牙利算法的具体计算流程如下：  
（1）任给初始匹配$M$；  
（2）若𝑋中任一结点均饱和，则$M$即为所求，算法结束，否则转（3）；  
（3）在𝑋中找到一非$M$饱和点$x$，置$S=\{x\}$，$T=\varnothing$；  
（4）若$N_{G}(S)=T$，则停止，否则任选一点$y\in N_{G}(S)-T$；  
（5）若𝑦为$M$饱和点转（6），否则：求一条从$x$到𝑦的$M$可增广路$P$，置$M=M\oplus P$，转（2）  
（6）由于$ y$是$M$饱和点，故$M$中有一边 $(y,u)$，置$S=S\cup\{u\}$，$T=T\cup\{y\}$，转（4）。算法中$N_{G}(S)$表示 $G$上与$S$中任一结点相邻的所有结点组成的集合，$\oplus$表示集合的对称差运算。下面以图10-37 为例，详细介绍匈牙利算法的具体执行过程：  
![图10-37 二分图 ](images/e75e6b51eaa2d7dcbd869cabf1198a4ab254d8c498cf74b11e8db5905f80f0b4.jpg)  
![图10-38 步骤1 效果图 ](images/a85e16b732f3f408c1a3f889dd66171d41954384c66b3a6769a239cb765226ce.jpg)  
（1）首先任给一个初始匹配$M=\{(x_{1},y_{1}),\;\;(x_{3},y_{5}),\;\;(x_{5},y_{3})\}$，如图10-38 所示。  
（2）$x_{2},x_{4}$非饱和，故$X$非饱和。确定其中一个非饱和点$x_{2}$，令${S}=\{x_{2}\}$，$T=\varnothing$。  
（3）$S$邻接结点集${N}_{G}(S)=\{y_{2},y_{3}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{3}\}$，选择$y_{3}$  
（4）$y_{3}$已饱和，因$M$中有边$(y_{3},x_{5})$，故令：  
$$
S=S\cup\{x_{5}\}=\{x_{2},x_{5}\},\ T=T\cup\{y_{3}\}=\{y_{3}\}
$$  
（5）因为$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{4},y_{5}\}$，选择${{y}}_{5}$  
（6）$y_{5}$已饱和，因为$M$存在边$(y_{5},x_{3})$，故令：
$$
S=S\cup\{x_{3}\}=\{x_{2},x_{3},x_{5}\},\,\,\,T=T\cup\{y_{5}\}=\{y_{3},y_{5}\}
$$  
（7）$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故任选$y\in N_{G}(S)-T=\{y_{2},y_{4}\},$,选择$y_{2}$  
（8）$y_{2}$不饱和，故存在从$x_{2}$到$y_{2}$的可增广道$P$。对于当前匹配$M=\{(x_{1},y_{1}),(x_{3},y_{5}),$$(x_{5},y_{3})\}$，求得可增广路$P$如图10 −39 加粗部分所示，得到$P$的边集：  
$$
E(P)=\{(x_{2},y_{3}),(y_{3},x_{5}),(x_{5},y_{5}),(y_{5},x_{3}),(x_{3},y_{2})\}
$$  
按下十重新调整匹配$M$，得到如图10 −40 所示一个新匹配$M$  
$$
M=M\oplus E(P)=\{(x_{1},y_{1}),(x_{2},y_{3}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
10-39 步骤8 过程图  
图10-40 步骤8 过程图2  
（9）在新匹配下继续查找可增广道。查看$ X$是否饱和，显然${{x}}_{4}$非饱和，选择该非饱和点$x_{4}$，并令$S=\{x_{4}\}$，$T=\varnothing$。  
（10）$N_{G}(S)=\{y_{3}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{3}\}$，选择$y_{3}$  
（11）$y_{3}$已饱和，因为匹配$M$中存在$(y_{3},x_{2})$，故令：
$$
S=S\cup\{x_{2}\}=\{x_{2},x_{4}\},\,\,\,T=T\cup\{y_{3}\}=\{y_{3}\}
$$  
（12）$N_{G}(S)=\{y_{2},y_{3}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{2}\}$，选择$y_{2}$（13）$y_{2}$已饱和，因为匹配$M$中存在$(y_{2},x_{3})$，故令：  
$$
S=S\cup\{x_{3}\}=\{x_{2},x_{3},x_{4}\},\,\,\,T=T\cup\{y_{2}\}=\{y_{2},y_{3}\}
$$  
（14）$N_{G}(S)=\{y_{2},y_{3},y_{5}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{5}\}$，选择$y_{5}$（15）$y_{5}$已饱和，因为匹配$M$中存在了$(y_{5},x_{5})$，故令：  
$$
S=S\cup\{x_{5}\}=\{x_{2},x_{3},x_{4},x_{5}\},\,\,\,T=T\cup\{y_{5}\}=\{y_{2},y_{3},y_{5}\}
$$  
（16 ）$N_{G}(S)=\{y_{2},y_{3},y_{4},y_{5}\}\neq T$，故选择$y\in N_{G}(S)-T=\{y_{4}\}$，选择${\cdot}y_{4}$（17）$y_{4}$不饱和，故可求一条从$x_{4}$到$y_{4}$的可增广路$ P$。对于当前匹配：  
$$
M=\{(x_{1},y_{1}),(x_{2},y_{3}),(x_{3},y_{2}),(x_{5},y_{5})\}
$$  
求得如图10 −41 加粗部分所示的可增广道路$P$， $P$的边集为：  
$$
E(P)=\{(x_{4},y_{3}),(y_{3},x_{2}),(x_{2},y_{2}),(y_{2},x_{3}),(x_{3},y_{5}),(y_{5},x_{5}),(x_{5},y_{4})\}
$$  
按下式重新调整匹配$M$，得到如图10 −43 所示的一个新匹配  
![](images/ee96514b37bbad784ca2a76b1641bd0dbdac20d6a3f2ab76c80847e37bff2151.jpg)  
至此，集合$\cdot X$已经饱和，求得的如下最大匹配：  
$$
M=\{(x_{1},y_{1}),(x_{2},y_{2}),(x_{3},y_{5}),(x_{4},y_{3}),(x_{5},y_{4})\}
$$  
设二分图$G$有${n}$个结点$m$条边，使用匈牙利算法最大匹配时，初始匹配可以空，故算法最多找$n$条可增广道，每找一条可增广路，最多比较$m$条边。因此，匈牙利算法的最坏时间复杂度为$O(m n)$。由此可见，匈牙利算法是一个有效算法。",匈牙利算法通过寻找可增广道来增广匹配
平面图,包含,可平面图,,"所谓平面图，直观地说就是可以将该图嵌入到某个平面上。如图10-46（a）所示，图模型的边有时不仅在结点处相交，而且还在某些非结点处有交叉，这些非结点处交叉点的边重叠特征显然会导致图模型不能嵌入在同一个平面上。因此，为了将图模型嵌入平面，首先必须适当调整该图中边的走向，以保证任意两条边不会在非结点处有交叉，如图10-46（b）所示。由此得到可平面图和平面图的相关概念。  
【定义10.6】设$G=\langle V,E\rangle$是任意给定的一个图模型，如果该图中有两条边在非结点处有交叉，则称这两条边为该图的交叉边，交叉的具体位置称为交叉点。如果可将图𝐺画在同一个平面上，并且所有边除在结点处之外均不交叉，则称图𝐺可嵌入平面，或称𝐺为可平面图，否则称该图为不可平面图或非平面图。对于可平面图𝐺，将其边不交叉的画法称为𝐺的平面嵌入表示。以平面嵌入方式表示的图可平面图𝐺称为平面图。对于一个平面图𝐺，若对其再加一条边就变成不可平面图，则称𝐺为最大平面图。  
![](images/ad5984e0ab09600028eb4068193d74e75743de0f027a20b4d084511a312873d4.jpg)  
![（a）完全二分图$K_{3,3}$  （b）无法消除交叉  ](images/aa69f9dcec49f0e95a534b493200688a98dae4f4be8a347fbd35c04b8c21413b.jpg)  
例如，对于图10-46（a）所示的图，该图有三对交叉边，即$(v_{1},v_{4})$和$(v_{2},v_{3}),~(v_{1},v_{4})$和$(v_{2},v_{5})$、$(v_{1},v_{5})$和$(v_{2},v_{3})$。由于可将该图表示成图10-46（b）的形式，故该图是一个可平面图。图10-46（b）所示的图就是一个平面图。显然，如果在该平面图上增加一条边，则该图就变成一个不可平面图，故该是一个最大平面图。再如，对于图10-47（a）所示的图模型，无论怎么调整边的走向都不能将其以平面嵌入方式表示，如图10-47（b）所示。故图10-47（a）所示的图模型为不可平面图或非平面图。  
在没有特别要求的情况下，通常将可平面图与平面图不加区分地统称为平面图。与一般图模型显著不同的是，平面图模型除了具有结点和边这两个基本构件之外，还有一般图模型所没有的面的概念，并且由进一步面衍生出边界的概念。因此，平面图是一类非常重要的特殊图模型，无论在理论上还是在应用方面都具有非常重要的价值，在印刷电路板的设计、城市管网设计与规划等多个领域得到实际应用。  
图论之父欧拉对平面图有着比较深刻的研究，发现并论证了平面图的结点、边和面之间的数量关系，提出了著名的欧拉公式。下面给出平面图中面的相关概念：  
【定义10.7】设$G=\langle V,E\rangle$是任意给定的一个平面图，由𝐺中边所包围且内部不包含结点与边的区域，称为$G$的一个面。区域面积有限的面称为有限面，区域面积无限的面称为无限面。对于$G$的任意一个面$R$，包围面$R$的所有边构成的回路称为面𝑅的边界，面𝑅边界中边的个数称为面$R$的次数或度，记为${\bf d e g}(R)$。  
通俗地说，如果把一个平面图画在平面上，然后用小刀沿着图的边将平面切开，那么整个平面就被切成若干块，其中每一块就是图的一个面。或者说，平面图的一个面就是平面中一个以边为界线不能再分割的区域块。例如，对于图10-46（b）所示的平面图，一共有六个面，其中有一个面是无限面，其余五个是有限面。需要注意的是，对于任何一个平面图，该图有且仅有一个无限面。下面的定理10.11 给出了平面图中面数与边数的数量关系：  
【定理10.11】平面图中所有面的次数之和等于边数的两倍。  
下面定理10.12 是著名的欧拉公式，给出了平面图中结点、边和面之间的数量关系：  
【定理10.12】设$G=\langle V,E\rangle$是任意给定的一个连通平面图，若它有$n$个结点、$m$条边、$r$ 个面，则有  
$$
n-m+r=2\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
【定理10.13】如果平面连通图$G$每个面的次数均为$l(l\geq3)$，则有：  
$$
m=l(n-2)/(l-2)
$$  
其中$m$为$G$的边数，$n$为$G$的结点数。  
【定理10.14】设$G$是一个$(n,m)$简单连通平面图，若$m>1$，则有：  
$$
m\leq3n-6\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
由定理10.4 的逆命题不成立，也就是说满足不等式$m\leq3n-6$的简单连通图不一定是平面图。但是对于一个简单连通图，若不满足$m\leq3n-6$，则一定是非平面图。因此，可用定理10.4 的结论证明某个简单连通图不是非平面图。  
【定理10.15】设$G$为一平面连通简单图，其结点数$n\geq4$，边数为$m$，且$G$不以$K_{3}$为其子图，则有$m\leq2n-4$。  
【定义10.8】对于是任意给定的一个图模型$G=\langle V,E\rangle$  
设$e=(u,v)$是$G$的任意一条边，如果在图$G$中删除该边并新增一个结点$w$及两条边$e_{1}=$$(u,w)$、$e_{2}=(w,v)$ ，则称该操作为对图$G$的边切割操作；  
设𝑤是$G$中任意一个度数为2 的结点，且是边${e_{1}=(u,w)}$和$e_{2}=(w,v)$的公共结点，如果在图$G$中删除结点$w$及边$e_{1},\,e_{2}$，并增加边$e=(u,v)$，则称该操作为对图$G$的结点贯通操作；  
对图$G$的边切割操作和结点贯通操作统称为对图$G$的同胚操作。  
显然，边切割操作和结点贯通操作是一对互逆操作。例如，对于图10-48 所示的两个图模型，可通过对边的切割操作将$G_{1}$变成$G_{2}$，也可通过对结点做贯通操作将$G_{2}$变成$G_{1}$。  
![图10-48  图的同胚操作与同胚关系  ](images/17b45e1706460a818a5492fb4df19f0ddd6b072e9cf57afef7db0852f0c58237.jpg)  
下面在同胚操作的基础上，引入如下两个图之间的同胚关系：  
【定义10.9】设$G_{1}=\langle V_{1},E_{1}\rangle$和$G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，如果可用同胚操作将其中一个转化为另外一个，则称$G_{1}$与$G_{2}$具有同胚关系，简称为$G_{1}$与$G_{2}$同胚。  
根据上述同胚的概念，可以得到如下关于平面图判定的库拉托夫斯基定理：  
【定理10.16】（库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是$G$的任何子图都不同胚于$K_{5}$或$K_{3,3}$。  
【定理10.17】(库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是𝐺的任何子图都不能通过边的收缩得到$K_{5}$或$K_{3,3}$。  
![图10-51 彼得森图收缩为$ K_{5}$](images/b6cd48c8bf37519af48b0cc187afdf1adc13d2c5e160a08fe418ce5c94762fd6.jpg)  
库拉托夫斯基定理是一个非常著名定理，通常将$K_{5}$和$K_{3,3}$称为库拉托夫斯基图。可以使用该定理判定一个图是否为平面图。例如，对于图$10{-}51\mathrm{a}$）所示的彼得森图，收缩其边$(v_{i},u_{i})(i=1,2,3,4,5)$，则可得到图$K_{5}$，见图10-51b)。故彼得森图不是平面图。  
值得注意的是，虽然库拉托夫斯基定理给出了平面图判定的充分必要条件，但是目前还没有基于该定理得到一个有效的判定算法。因此，对于一个比较复杂的图模型，要判定其是否为平面图，有时并不是一件容易的事情。",平面图是可平面图的一种特殊形式
可平面图,互斥,不可平面图,,"所谓平面图，直观地说就是可以将该图嵌入到某个平面上。如图10-46（a）所示，图模型的边有时不仅在结点处相交，而且还在某些非结点处有交叉，这些非结点处交叉点的边重叠特征显然会导致图模型不能嵌入在同一个平面上。因此，为了将图模型嵌入平面，首先必须适当调整该图中边的走向，以保证任意两条边不会在非结点处有交叉，如图10-46（b）所示。由此得到可平面图和平面图的相关概念。  
【定义10.6】设$G=\langle V,E\rangle$是任意给定的一个图模型，如果该图中有两条边在非结点处有交叉，则称这两条边为该图的交叉边，交叉的具体位置称为交叉点。如果可将图𝐺画在同一个平面上，并且所有边除在结点处之外均不交叉，则称图𝐺可嵌入平面，或称𝐺为可平面图，否则称该图为不可平面图或非平面图。对于可平面图𝐺，将其边不交叉的画法称为𝐺的平面嵌入表示。以平面嵌入方式表示的图可平面图𝐺称为平面图。对于一个平面图𝐺，若对其再加一条边就变成不可平面图，则称𝐺为最大平面图。  
![](images/ad5984e0ab09600028eb4068193d74e75743de0f027a20b4d084511a312873d4.jpg)  
![（a）完全二分图$K_{3,3}$  （b）无法消除交叉  ](images/aa69f9dcec49f0e95a534b493200688a98dae4f4be8a347fbd35c04b8c21413b.jpg)  
例如，对于图10-46（a）所示的图，该图有三对交叉边，即$(v_{1},v_{4})$和$(v_{2},v_{3}),~(v_{1},v_{4})$和$(v_{2},v_{5})$、$(v_{1},v_{5})$和$(v_{2},v_{3})$。由于可将该图表示成图10-46（b）的形式，故该图是一个可平面图。图10-46（b）所示的图就是一个平面图。显然，如果在该平面图上增加一条边，则该图就变成一个不可平面图，故该是一个最大平面图。再如，对于图10-47（a）所示的图模型，无论怎么调整边的走向都不能将其以平面嵌入方式表示，如图10-47（b）所示。故图10-47（a）所示的图模型为不可平面图或非平面图。  
在没有特别要求的情况下，通常将可平面图与平面图不加区分地统称为平面图。与一般图模型显著不同的是，平面图模型除了具有结点和边这两个基本构件之外，还有一般图模型所没有的面的概念，并且由进一步面衍生出边界的概念。因此，平面图是一类非常重要的特殊图模型，无论在理论上还是在应用方面都具有非常重要的价值，在印刷电路板的设计、城市管网设计与规划等多个领域得到实际应用。  
图论之父欧拉对平面图有着比较深刻的研究，发现并论证了平面图的结点、边和面之间的数量关系，提出了著名的欧拉公式。下面给出平面图中面的相关概念：  
【定义10.7】设$G=\langle V,E\rangle$是任意给定的一个平面图，由𝐺中边所包围且内部不包含结点与边的区域，称为$G$的一个面。区域面积有限的面称为有限面，区域面积无限的面称为无限面。对于$G$的任意一个面$R$，包围面$R$的所有边构成的回路称为面𝑅的边界，面𝑅边界中边的个数称为面$R$的次数或度，记为${\bf d e g}(R)$。  
通俗地说，如果把一个平面图画在平面上，然后用小刀沿着图的边将平面切开，那么整个平面就被切成若干块，其中每一块就是图的一个面。或者说，平面图的一个面就是平面中一个以边为界线不能再分割的区域块。例如，对于图10-46（b）所示的平面图，一共有六个面，其中有一个面是无限面，其余五个是有限面。需要注意的是，对于任何一个平面图，该图有且仅有一个无限面。下面的定理10.11 给出了平面图中面数与边数的数量关系：  
【定理10.11】平面图中所有面的次数之和等于边数的两倍。  
下面定理10.12 是著名的欧拉公式，给出了平面图中结点、边和面之间的数量关系：  
【定理10.12】设$G=\langle V,E\rangle$是任意给定的一个连通平面图，若它有$n$个结点、$m$条边、$r$ 个面，则有  
$$
n-m+r=2\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
【定理10.13】如果平面连通图$G$每个面的次数均为$l(l\geq3)$，则有：  
$$
m=l(n-2)/(l-2)
$$  
其中$m$为$G$的边数，$n$为$G$的结点数。  
【定理10.14】设$G$是一个$(n,m)$简单连通平面图，若$m>1$，则有：  
$$
m\leq3n-6\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
由定理10.4 的逆命题不成立，也就是说满足不等式$m\leq3n-6$的简单连通图不一定是平面图。但是对于一个简单连通图，若不满足$m\leq3n-6$，则一定是非平面图。因此，可用定理10.4 的结论证明某个简单连通图不是非平面图。  
【定理10.15】设$G$为一平面连通简单图，其结点数$n\geq4$，边数为$m$，且$G$不以$K_{3}$为其子图，则有$m\leq2n-4$。  
【定义10.8】对于是任意给定的一个图模型$G=\langle V,E\rangle$  
设$e=(u,v)$是$G$的任意一条边，如果在图$G$中删除该边并新增一个结点$w$及两条边$e_{1}=$$(u,w)$、$e_{2}=(w,v)$ ，则称该操作为对图$G$的边切割操作；  
设𝑤是$G$中任意一个度数为2 的结点，且是边${e_{1}=(u,w)}$和$e_{2}=(w,v)$的公共结点，如果在图$G$中删除结点$w$及边$e_{1},\,e_{2}$，并增加边$e=(u,v)$，则称该操作为对图$G$的结点贯通操作；  
对图$G$的边切割操作和结点贯通操作统称为对图$G$的同胚操作。  
显然，边切割操作和结点贯通操作是一对互逆操作。例如，对于图10-48 所示的两个图模型，可通过对边的切割操作将$G_{1}$变成$G_{2}$，也可通过对结点做贯通操作将$G_{2}$变成$G_{1}$。  
![图10-48  图的同胚操作与同胚关系  ](images/17b45e1706460a818a5492fb4df19f0ddd6b072e9cf57afef7db0852f0c58237.jpg)  
下面在同胚操作的基础上，引入如下两个图之间的同胚关系：  
【定义10.9】设$G_{1}=\langle V_{1},E_{1}\rangle$和$G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，如果可用同胚操作将其中一个转化为另外一个，则称$G_{1}$与$G_{2}$具有同胚关系，简称为$G_{1}$与$G_{2}$同胚。  
根据上述同胚的概念，可以得到如下关于平面图判定的库拉托夫斯基定理：  
【定理10.16】（库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是$G$的任何子图都不同胚于$K_{5}$或$K_{3,3}$。  
【定理10.17】(库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是𝐺的任何子图都不能通过边的收缩得到$K_{5}$或$K_{3,3}$。  
![图10-51 彼得森图收缩为$ K_{5}$](images/b6cd48c8bf37519af48b0cc187afdf1adc13d2c5e160a08fe418ce5c94762fd6.jpg)  
库拉托夫斯基定理是一个非常著名定理，通常将$K_{5}$和$K_{3,3}$称为库拉托夫斯基图。可以使用该定理判定一个图是否为平面图。例如，对于图$10{-}51\mathrm{a}$）所示的彼得森图，收缩其边$(v_{i},u_{i})(i=1,2,3,4,5)$，则可得到图$K_{5}$，见图10-51b)。故彼得森图不是平面图。  
值得注意的是，虽然库拉托夫斯基定理给出了平面图判定的充分必要条件，但是目前还没有基于该定理得到一个有效的判定算法。因此，对于一个比较复杂的图模型，要判定其是否为平面图，有时并不是一件容易的事情。",图要么是可平面图，要么是不可平面图
平面图,特殊化,最大平面图,,"所谓平面图，直观地说就是可以将该图嵌入到某个平面上。如图10-46（a）所示，图模型的边有时不仅在结点处相交，而且还在某些非结点处有交叉，这些非结点处交叉点的边重叠特征显然会导致图模型不能嵌入在同一个平面上。因此，为了将图模型嵌入平面，首先必须适当调整该图中边的走向，以保证任意两条边不会在非结点处有交叉，如图10-46（b）所示。由此得到可平面图和平面图的相关概念。  
【定义10.6】设$G=\langle V,E\rangle$是任意给定的一个图模型，如果该图中有两条边在非结点处有交叉，则称这两条边为该图的交叉边，交叉的具体位置称为交叉点。如果可将图𝐺画在同一个平面上，并且所有边除在结点处之外均不交叉，则称图𝐺可嵌入平面，或称𝐺为可平面图，否则称该图为不可平面图或非平面图。对于可平面图𝐺，将其边不交叉的画法称为𝐺的平面嵌入表示。以平面嵌入方式表示的图可平面图𝐺称为平面图。对于一个平面图𝐺，若对其再加一条边就变成不可平面图，则称𝐺为最大平面图。  
![](images/ad5984e0ab09600028eb4068193d74e75743de0f027a20b4d084511a312873d4.jpg)  
![（a）完全二分图$K_{3,3}$  （b）无法消除交叉  ](images/aa69f9dcec49f0e95a534b493200688a98dae4f4be8a347fbd35c04b8c21413b.jpg)  
例如，对于图10-46（a）所示的图，该图有三对交叉边，即$(v_{1},v_{4})$和$(v_{2},v_{3}),~(v_{1},v_{4})$和$(v_{2},v_{5})$、$(v_{1},v_{5})$和$(v_{2},v_{3})$。由于可将该图表示成图10-46（b）的形式，故该图是一个可平面图。图10-46（b）所示的图就是一个平面图。显然，如果在该平面图上增加一条边，则该图就变成一个不可平面图，故该是一个最大平面图。再如，对于图10-47（a）所示的图模型，无论怎么调整边的走向都不能将其以平面嵌入方式表示，如图10-47（b）所示。故图10-47（a）所示的图模型为不可平面图或非平面图。  
在没有特别要求的情况下，通常将可平面图与平面图不加区分地统称为平面图。与一般图模型显著不同的是，平面图模型除了具有结点和边这两个基本构件之外，还有一般图模型所没有的面的概念，并且由进一步面衍生出边界的概念。因此，平面图是一类非常重要的特殊图模型，无论在理论上还是在应用方面都具有非常重要的价值，在印刷电路板的设计、城市管网设计与规划等多个领域得到实际应用。  
图论之父欧拉对平面图有着比较深刻的研究，发现并论证了平面图的结点、边和面之间的数量关系，提出了著名的欧拉公式。下面给出平面图中面的相关概念：  
【定义10.7】设$G=\langle V,E\rangle$是任意给定的一个平面图，由𝐺中边所包围且内部不包含结点与边的区域，称为$G$的一个面。区域面积有限的面称为有限面，区域面积无限的面称为无限面。对于$G$的任意一个面$R$，包围面$R$的所有边构成的回路称为面𝑅的边界，面𝑅边界中边的个数称为面$R$的次数或度，记为${\bf d e g}(R)$。  
通俗地说，如果把一个平面图画在平面上，然后用小刀沿着图的边将平面切开，那么整个平面就被切成若干块，其中每一块就是图的一个面。或者说，平面图的一个面就是平面中一个以边为界线不能再分割的区域块。例如，对于图10-46（b）所示的平面图，一共有六个面，其中有一个面是无限面，其余五个是有限面。需要注意的是，对于任何一个平面图，该图有且仅有一个无限面。下面的定理10.11 给出了平面图中面数与边数的数量关系：  
【定理10.11】平面图中所有面的次数之和等于边数的两倍。  
下面定理10.12 是著名的欧拉公式，给出了平面图中结点、边和面之间的数量关系：  
【定理10.12】设$G=\langle V,E\rangle$是任意给定的一个连通平面图，若它有$n$个结点、$m$条边、$r$ 个面，则有  
$$
n-m+r=2\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
【定理10.13】如果平面连通图$G$每个面的次数均为$l(l\geq3)$，则有：  
$$
m=l(n-2)/(l-2)
$$  
其中$m$为$G$的边数，$n$为$G$的结点数。  
【定理10.14】设$G$是一个$(n,m)$简单连通平面图，若$m>1$，则有：  
$$
m\leq3n-6\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
由定理10.4 的逆命题不成立，也就是说满足不等式$m\leq3n-6$的简单连通图不一定是平面图。但是对于一个简单连通图，若不满足$m\leq3n-6$，则一定是非平面图。因此，可用定理10.4 的结论证明某个简单连通图不是非平面图。  
【定理10.15】设$G$为一平面连通简单图，其结点数$n\geq4$，边数为$m$，且$G$不以$K_{3}$为其子图，则有$m\leq2n-4$。  
【定义10.8】对于是任意给定的一个图模型$G=\langle V,E\rangle$  
设$e=(u,v)$是$G$的任意一条边，如果在图$G$中删除该边并新增一个结点$w$及两条边$e_{1}=$$(u,w)$、$e_{2}=(w,v)$ ，则称该操作为对图$G$的边切割操作；  
设𝑤是$G$中任意一个度数为2 的结点，且是边${e_{1}=(u,w)}$和$e_{2}=(w,v)$的公共结点，如果在图$G$中删除结点$w$及边$e_{1},\,e_{2}$，并增加边$e=(u,v)$，则称该操作为对图$G$的结点贯通操作；  
对图$G$的边切割操作和结点贯通操作统称为对图$G$的同胚操作。  
显然，边切割操作和结点贯通操作是一对互逆操作。例如，对于图10-48 所示的两个图模型，可通过对边的切割操作将$G_{1}$变成$G_{2}$，也可通过对结点做贯通操作将$G_{2}$变成$G_{1}$。  
![图10-48  图的同胚操作与同胚关系  ](images/17b45e1706460a818a5492fb4df19f0ddd6b072e9cf57afef7db0852f0c58237.jpg)  
下面在同胚操作的基础上，引入如下两个图之间的同胚关系：  
【定义10.9】设$G_{1}=\langle V_{1},E_{1}\rangle$和$G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，如果可用同胚操作将其中一个转化为另外一个，则称$G_{1}$与$G_{2}$具有同胚关系，简称为$G_{1}$与$G_{2}$同胚。  
根据上述同胚的概念，可以得到如下关于平面图判定的库拉托夫斯基定理：  
【定理10.16】（库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是$G$的任何子图都不同胚于$K_{5}$或$K_{3,3}$。  
【定理10.17】(库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是𝐺的任何子图都不能通过边的收缩得到$K_{5}$或$K_{3,3}$。  
![图10-51 彼得森图收缩为$ K_{5}$](images/b6cd48c8bf37519af48b0cc187afdf1adc13d2c5e160a08fe418ce5c94762fd6.jpg)  
库拉托夫斯基定理是一个非常著名定理，通常将$K_{5}$和$K_{3,3}$称为库拉托夫斯基图。可以使用该定理判定一个图是否为平面图。例如，对于图$10{-}51\mathrm{a}$）所示的彼得森图，收缩其边$(v_{i},u_{i})(i=1,2,3,4,5)$，则可得到图$K_{5}$，见图10-51b)。故彼得森图不是平面图。  
值得注意的是，虽然库拉托夫斯基定理给出了平面图判定的充分必要条件，但是目前还没有基于该定理得到一个有效的判定算法。因此，对于一个比较复杂的图模型，要判定其是否为平面图，有时并不是一件容易的事情。",最大平面图是再加一条边就变成不可平面图的平面图
平面图,包含,面,,"所谓平面图，直观地说就是可以将该图嵌入到某个平面上。如图10-46（a）所示，图模型的边有时不仅在结点处相交，而且还在某些非结点处有交叉，这些非结点处交叉点的边重叠特征显然会导致图模型不能嵌入在同一个平面上。因此，为了将图模型嵌入平面，首先必须适当调整该图中边的走向，以保证任意两条边不会在非结点处有交叉，如图10-46（b）所示。由此得到可平面图和平面图的相关概念。  
【定义10.6】设$G=\langle V,E\rangle$是任意给定的一个图模型，如果该图中有两条边在非结点处有交叉，则称这两条边为该图的交叉边，交叉的具体位置称为交叉点。如果可将图𝐺画在同一个平面上，并且所有边除在结点处之外均不交叉，则称图𝐺可嵌入平面，或称𝐺为可平面图，否则称该图为不可平面图或非平面图。对于可平面图𝐺，将其边不交叉的画法称为𝐺的平面嵌入表示。以平面嵌入方式表示的图可平面图𝐺称为平面图。对于一个平面图𝐺，若对其再加一条边就变成不可平面图，则称𝐺为最大平面图。  
![](images/ad5984e0ab09600028eb4068193d74e75743de0f027a20b4d084511a312873d4.jpg)  
![（a）完全二分图$K_{3,3}$  （b）无法消除交叉  ](images/aa69f9dcec49f0e95a534b493200688a98dae4f4be8a347fbd35c04b8c21413b.jpg)  
例如，对于图10-46（a）所示的图，该图有三对交叉边，即$(v_{1},v_{4})$和$(v_{2},v_{3}),~(v_{1},v_{4})$和$(v_{2},v_{5})$、$(v_{1},v_{5})$和$(v_{2},v_{3})$。由于可将该图表示成图10-46（b）的形式，故该图是一个可平面图。图10-46（b）所示的图就是一个平面图。显然，如果在该平面图上增加一条边，则该图就变成一个不可平面图，故该是一个最大平面图。再如，对于图10-47（a）所示的图模型，无论怎么调整边的走向都不能将其以平面嵌入方式表示，如图10-47（b）所示。故图10-47（a）所示的图模型为不可平面图或非平面图。  
在没有特别要求的情况下，通常将可平面图与平面图不加区分地统称为平面图。与一般图模型显著不同的是，平面图模型除了具有结点和边这两个基本构件之外，还有一般图模型所没有的面的概念，并且由进一步面衍生出边界的概念。因此，平面图是一类非常重要的特殊图模型，无论在理论上还是在应用方面都具有非常重要的价值，在印刷电路板的设计、城市管网设计与规划等多个领域得到实际应用。  
图论之父欧拉对平面图有着比较深刻的研究，发现并论证了平面图的结点、边和面之间的数量关系，提出了著名的欧拉公式。下面给出平面图中面的相关概念：  
【定义10.7】设$G=\langle V,E\rangle$是任意给定的一个平面图，由𝐺中边所包围且内部不包含结点与边的区域，称为$G$的一个面。区域面积有限的面称为有限面，区域面积无限的面称为无限面。对于$G$的任意一个面$R$，包围面$R$的所有边构成的回路称为面𝑅的边界，面𝑅边界中边的个数称为面$R$的次数或度，记为${\bf d e g}(R)$。  
通俗地说，如果把一个平面图画在平面上，然后用小刀沿着图的边将平面切开，那么整个平面就被切成若干块，其中每一块就是图的一个面。或者说，平面图的一个面就是平面中一个以边为界线不能再分割的区域块。例如，对于图10-46（b）所示的平面图，一共有六个面，其中有一个面是无限面，其余五个是有限面。需要注意的是，对于任何一个平面图，该图有且仅有一个无限面。下面的定理10.11 给出了平面图中面数与边数的数量关系：  
【定理10.11】平面图中所有面的次数之和等于边数的两倍。  
下面定理10.12 是著名的欧拉公式，给出了平面图中结点、边和面之间的数量关系：  
【定理10.12】设$G=\langle V,E\rangle$是任意给定的一个连通平面图，若它有$n$个结点、$m$条边、$r$ 个面，则有  
$$
n-m+r=2\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
【定理10.13】如果平面连通图$G$每个面的次数均为$l(l\geq3)$，则有：  
$$
m=l(n-2)/(l-2)
$$  
其中$m$为$G$的边数，$n$为$G$的结点数。  
【定理10.14】设$G$是一个$(n,m)$简单连通平面图，若$m>1$，则有：  
$$
m\leq3n-6\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
由定理10.4 的逆命题不成立，也就是说满足不等式$m\leq3n-6$的简单连通图不一定是平面图。但是对于一个简单连通图，若不满足$m\leq3n-6$，则一定是非平面图。因此，可用定理10.4 的结论证明某个简单连通图不是非平面图。  
【定理10.15】设$G$为一平面连通简单图，其结点数$n\geq4$，边数为$m$，且$G$不以$K_{3}$为其子图，则有$m\leq2n-4$。  
【定义10.8】对于是任意给定的一个图模型$G=\langle V,E\rangle$  
设$e=(u,v)$是$G$的任意一条边，如果在图$G$中删除该边并新增一个结点$w$及两条边$e_{1}=$$(u,w)$、$e_{2}=(w,v)$ ，则称该操作为对图$G$的边切割操作；  
设𝑤是$G$中任意一个度数为2 的结点，且是边${e_{1}=(u,w)}$和$e_{2}=(w,v)$的公共结点，如果在图$G$中删除结点$w$及边$e_{1},\,e_{2}$，并增加边$e=(u,v)$，则称该操作为对图$G$的结点贯通操作；  
对图$G$的边切割操作和结点贯通操作统称为对图$G$的同胚操作。  
显然，边切割操作和结点贯通操作是一对互逆操作。例如，对于图10-48 所示的两个图模型，可通过对边的切割操作将$G_{1}$变成$G_{2}$，也可通过对结点做贯通操作将$G_{2}$变成$G_{1}$。  
![图10-48  图的同胚操作与同胚关系  ](images/17b45e1706460a818a5492fb4df19f0ddd6b072e9cf57afef7db0852f0c58237.jpg)  
下面在同胚操作的基础上，引入如下两个图之间的同胚关系：  
【定义10.9】设$G_{1}=\langle V_{1},E_{1}\rangle$和$G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，如果可用同胚操作将其中一个转化为另外一个，则称$G_{1}$与$G_{2}$具有同胚关系，简称为$G_{1}$与$G_{2}$同胚。  
根据上述同胚的概念，可以得到如下关于平面图判定的库拉托夫斯基定理：  
【定理10.16】（库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是$G$的任何子图都不同胚于$K_{5}$或$K_{3,3}$。  
【定理10.17】(库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是𝐺的任何子图都不能通过边的收缩得到$K_{5}$或$K_{3,3}$。  
![图10-51 彼得森图收缩为$ K_{5}$](images/b6cd48c8bf37519af48b0cc187afdf1adc13d2c5e160a08fe418ce5c94762fd6.jpg)  
库拉托夫斯基定理是一个非常著名定理，通常将$K_{5}$和$K_{3,3}$称为库拉托夫斯基图。可以使用该定理判定一个图是否为平面图。例如，对于图$10{-}51\mathrm{a}$）所示的彼得森图，收缩其边$(v_{i},u_{i})(i=1,2,3,4,5)$，则可得到图$K_{5}$，见图10-51b)。故彼得森图不是平面图。  
值得注意的是，虽然库拉托夫斯基定理给出了平面图判定的充分必要条件，但是目前还没有基于该定理得到一个有效的判定算法。因此，对于一个比较复杂的图模型，要判定其是否为平面图，有时并不是一件容易的事情。",平面图包含面的概念
面,衍生,边界,,"所谓平面图，直观地说就是可以将该图嵌入到某个平面上。如图10-46（a）所示，图模型的边有时不仅在结点处相交，而且还在某些非结点处有交叉，这些非结点处交叉点的边重叠特征显然会导致图模型不能嵌入在同一个平面上。因此，为了将图模型嵌入平面，首先必须适当调整该图中边的走向，以保证任意两条边不会在非结点处有交叉，如图10-46（b）所示。由此得到可平面图和平面图的相关概念。  
【定义10.6】设$G=\langle V,E\rangle$是任意给定的一个图模型，如果该图中有两条边在非结点处有交叉，则称这两条边为该图的交叉边，交叉的具体位置称为交叉点。如果可将图𝐺画在同一个平面上，并且所有边除在结点处之外均不交叉，则称图𝐺可嵌入平面，或称𝐺为可平面图，否则称该图为不可平面图或非平面图。对于可平面图𝐺，将其边不交叉的画法称为𝐺的平面嵌入表示。以平面嵌入方式表示的图可平面图𝐺称为平面图。对于一个平面图𝐺，若对其再加一条边就变成不可平面图，则称𝐺为最大平面图。  
![](images/ad5984e0ab09600028eb4068193d74e75743de0f027a20b4d084511a312873d4.jpg)  
![（a）完全二分图$K_{3,3}$  （b）无法消除交叉  ](images/aa69f9dcec49f0e95a534b493200688a98dae4f4be8a347fbd35c04b8c21413b.jpg)  
例如，对于图10-46（a）所示的图，该图有三对交叉边，即$(v_{1},v_{4})$和$(v_{2},v_{3}),~(v_{1},v_{4})$和$(v_{2},v_{5})$、$(v_{1},v_{5})$和$(v_{2},v_{3})$。由于可将该图表示成图10-46（b）的形式，故该图是一个可平面图。图10-46（b）所示的图就是一个平面图。显然，如果在该平面图上增加一条边，则该图就变成一个不可平面图，故该是一个最大平面图。再如，对于图10-47（a）所示的图模型，无论怎么调整边的走向都不能将其以平面嵌入方式表示，如图10-47（b）所示。故图10-47（a）所示的图模型为不可平面图或非平面图。  
在没有特别要求的情况下，通常将可平面图与平面图不加区分地统称为平面图。与一般图模型显著不同的是，平面图模型除了具有结点和边这两个基本构件之外，还有一般图模型所没有的面的概念，并且由进一步面衍生出边界的概念。因此，平面图是一类非常重要的特殊图模型，无论在理论上还是在应用方面都具有非常重要的价值，在印刷电路板的设计、城市管网设计与规划等多个领域得到实际应用。  
图论之父欧拉对平面图有着比较深刻的研究，发现并论证了平面图的结点、边和面之间的数量关系，提出了著名的欧拉公式。下面给出平面图中面的相关概念：  
【定义10.7】设$G=\langle V,E\rangle$是任意给定的一个平面图，由𝐺中边所包围且内部不包含结点与边的区域，称为$G$的一个面。区域面积有限的面称为有限面，区域面积无限的面称为无限面。对于$G$的任意一个面$R$，包围面$R$的所有边构成的回路称为面𝑅的边界，面𝑅边界中边的个数称为面$R$的次数或度，记为${\bf d e g}(R)$。  
通俗地说，如果把一个平面图画在平面上，然后用小刀沿着图的边将平面切开，那么整个平面就被切成若干块，其中每一块就是图的一个面。或者说，平面图的一个面就是平面中一个以边为界线不能再分割的区域块。例如，对于图10-46（b）所示的平面图，一共有六个面，其中有一个面是无限面，其余五个是有限面。需要注意的是，对于任何一个平面图，该图有且仅有一个无限面。下面的定理10.11 给出了平面图中面数与边数的数量关系：  
【定理10.11】平面图中所有面的次数之和等于边数的两倍。  
下面定理10.12 是著名的欧拉公式，给出了平面图中结点、边和面之间的数量关系：  
【定理10.12】设$G=\langle V,E\rangle$是任意给定的一个连通平面图，若它有$n$个结点、$m$条边、$r$ 个面，则有  
$$
n-m+r=2\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
【定理10.13】如果平面连通图$G$每个面的次数均为$l(l\geq3)$，则有：  
$$
m=l(n-2)/(l-2)
$$  
其中$m$为$G$的边数，$n$为$G$的结点数。  
【定理10.14】设$G$是一个$(n,m)$简单连通平面图，若$m>1$，则有：  
$$
m\leq3n-6\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
由定理10.4 的逆命题不成立，也就是说满足不等式$m\leq3n-6$的简单连通图不一定是平面图。但是对于一个简单连通图，若不满足$m\leq3n-6$，则一定是非平面图。因此，可用定理10.4 的结论证明某个简单连通图不是非平面图。  
【定理10.15】设$G$为一平面连通简单图，其结点数$n\geq4$，边数为$m$，且$G$不以$K_{3}$为其子图，则有$m\leq2n-4$。  
【定义10.8】对于是任意给定的一个图模型$G=\langle V,E\rangle$  
设$e=(u,v)$是$G$的任意一条边，如果在图$G$中删除该边并新增一个结点$w$及两条边$e_{1}=$$(u,w)$、$e_{2}=(w,v)$ ，则称该操作为对图$G$的边切割操作；  
设𝑤是$G$中任意一个度数为2 的结点，且是边${e_{1}=(u,w)}$和$e_{2}=(w,v)$的公共结点，如果在图$G$中删除结点$w$及边$e_{1},\,e_{2}$，并增加边$e=(u,v)$，则称该操作为对图$G$的结点贯通操作；  
对图$G$的边切割操作和结点贯通操作统称为对图$G$的同胚操作。  
显然，边切割操作和结点贯通操作是一对互逆操作。例如，对于图10-48 所示的两个图模型，可通过对边的切割操作将$G_{1}$变成$G_{2}$，也可通过对结点做贯通操作将$G_{2}$变成$G_{1}$。  
![图10-48  图的同胚操作与同胚关系  ](images/17b45e1706460a818a5492fb4df19f0ddd6b072e9cf57afef7db0852f0c58237.jpg)  
下面在同胚操作的基础上，引入如下两个图之间的同胚关系：  
【定义10.9】设$G_{1}=\langle V_{1},E_{1}\rangle$和$G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，如果可用同胚操作将其中一个转化为另外一个，则称$G_{1}$与$G_{2}$具有同胚关系，简称为$G_{1}$与$G_{2}$同胚。  
根据上述同胚的概念，可以得到如下关于平面图判定的库拉托夫斯基定理：  
【定理10.16】（库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是$G$的任何子图都不同胚于$K_{5}$或$K_{3,3}$。  
【定理10.17】(库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是𝐺的任何子图都不能通过边的收缩得到$K_{5}$或$K_{3,3}$。  
![图10-51 彼得森图收缩为$ K_{5}$](images/b6cd48c8bf37519af48b0cc187afdf1adc13d2c5e160a08fe418ce5c94762fd6.jpg)  
库拉托夫斯基定理是一个非常著名定理，通常将$K_{5}$和$K_{3,3}$称为库拉托夫斯基图。可以使用该定理判定一个图是否为平面图。例如，对于图$10{-}51\mathrm{a}$）所示的彼得森图，收缩其边$(v_{i},u_{i})(i=1,2,3,4,5)$，则可得到图$K_{5}$，见图10-51b)。故彼得森图不是平面图。  
值得注意的是，虽然库拉托夫斯基定理给出了平面图判定的充分必要条件，但是目前还没有基于该定理得到一个有效的判定算法。因此，对于一个比较复杂的图模型，要判定其是否为平面图，有时并不是一件容易的事情。",面由边界的概念衍生而来
平面图,关联,欧拉公式,,"所谓平面图，直观地说就是可以将该图嵌入到某个平面上。如图10-46（a）所示，图模型的边有时不仅在结点处相交，而且还在某些非结点处有交叉，这些非结点处交叉点的边重叠特征显然会导致图模型不能嵌入在同一个平面上。因此，为了将图模型嵌入平面，首先必须适当调整该图中边的走向，以保证任意两条边不会在非结点处有交叉，如图10-46（b）所示。由此得到可平面图和平面图的相关概念。  
【定义10.6】设$G=\langle V,E\rangle$是任意给定的一个图模型，如果该图中有两条边在非结点处有交叉，则称这两条边为该图的交叉边，交叉的具体位置称为交叉点。如果可将图𝐺画在同一个平面上，并且所有边除在结点处之外均不交叉，则称图𝐺可嵌入平面，或称𝐺为可平面图，否则称该图为不可平面图或非平面图。对于可平面图𝐺，将其边不交叉的画法称为𝐺的平面嵌入表示。以平面嵌入方式表示的图可平面图𝐺称为平面图。对于一个平面图𝐺，若对其再加一条边就变成不可平面图，则称𝐺为最大平面图。  
![](images/ad5984e0ab09600028eb4068193d74e75743de0f027a20b4d084511a312873d4.jpg)  
![（a）完全二分图$K_{3,3}$  （b）无法消除交叉  ](images/aa69f9dcec49f0e95a534b493200688a98dae4f4be8a347fbd35c04b8c21413b.jpg)  
例如，对于图10-46（a）所示的图，该图有三对交叉边，即$(v_{1},v_{4})$和$(v_{2},v_{3}),~(v_{1},v_{4})$和$(v_{2},v_{5})$、$(v_{1},v_{5})$和$(v_{2},v_{3})$。由于可将该图表示成图10-46（b）的形式，故该图是一个可平面图。图10-46（b）所示的图就是一个平面图。显然，如果在该平面图上增加一条边，则该图就变成一个不可平面图，故该是一个最大平面图。再如，对于图10-47（a）所示的图模型，无论怎么调整边的走向都不能将其以平面嵌入方式表示，如图10-47（b）所示。故图10-47（a）所示的图模型为不可平面图或非平面图。  
在没有特别要求的情况下，通常将可平面图与平面图不加区分地统称为平面图。与一般图模型显著不同的是，平面图模型除了具有结点和边这两个基本构件之外，还有一般图模型所没有的面的概念，并且由进一步面衍生出边界的概念。因此，平面图是一类非常重要的特殊图模型，无论在理论上还是在应用方面都具有非常重要的价值，在印刷电路板的设计、城市管网设计与规划等多个领域得到实际应用。  
图论之父欧拉对平面图有着比较深刻的研究，发现并论证了平面图的结点、边和面之间的数量关系，提出了著名的欧拉公式。下面给出平面图中面的相关概念：  
【定义10.7】设$G=\langle V,E\rangle$是任意给定的一个平面图，由𝐺中边所包围且内部不包含结点与边的区域，称为$G$的一个面。区域面积有限的面称为有限面，区域面积无限的面称为无限面。对于$G$的任意一个面$R$，包围面$R$的所有边构成的回路称为面𝑅的边界，面𝑅边界中边的个数称为面$R$的次数或度，记为${\bf d e g}(R)$。  
通俗地说，如果把一个平面图画在平面上，然后用小刀沿着图的边将平面切开，那么整个平面就被切成若干块，其中每一块就是图的一个面。或者说，平面图的一个面就是平面中一个以边为界线不能再分割的区域块。例如，对于图10-46（b）所示的平面图，一共有六个面，其中有一个面是无限面，其余五个是有限面。需要注意的是，对于任何一个平面图，该图有且仅有一个无限面。下面的定理10.11 给出了平面图中面数与边数的数量关系：  
【定理10.11】平面图中所有面的次数之和等于边数的两倍。  
下面定理10.12 是著名的欧拉公式，给出了平面图中结点、边和面之间的数量关系：  
【定理10.12】设$G=\langle V,E\rangle$是任意给定的一个连通平面图，若它有$n$个结点、$m$条边、$r$ 个面，则有  
$$
n-m+r=2\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
【定理10.13】如果平面连通图$G$每个面的次数均为$l(l\geq3)$，则有：  
$$
m=l(n-2)/(l-2)
$$  
其中$m$为$G$的边数，$n$为$G$的结点数。  
【定理10.14】设$G$是一个$(n,m)$简单连通平面图，若$m>1$，则有：  
$$
m\leq3n-6\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
由定理10.4 的逆命题不成立，也就是说满足不等式$m\leq3n-6$的简单连通图不一定是平面图。但是对于一个简单连通图，若不满足$m\leq3n-6$，则一定是非平面图。因此，可用定理10.4 的结论证明某个简单连通图不是非平面图。  
【定理10.15】设$G$为一平面连通简单图，其结点数$n\geq4$，边数为$m$，且$G$不以$K_{3}$为其子图，则有$m\leq2n-4$。  
【定义10.8】对于是任意给定的一个图模型$G=\langle V,E\rangle$  
设$e=(u,v)$是$G$的任意一条边，如果在图$G$中删除该边并新增一个结点$w$及两条边$e_{1}=$$(u,w)$、$e_{2}=(w,v)$ ，则称该操作为对图$G$的边切割操作；  
设𝑤是$G$中任意一个度数为2 的结点，且是边${e_{1}=(u,w)}$和$e_{2}=(w,v)$的公共结点，如果在图$G$中删除结点$w$及边$e_{1},\,e_{2}$，并增加边$e=(u,v)$，则称该操作为对图$G$的结点贯通操作；  
对图$G$的边切割操作和结点贯通操作统称为对图$G$的同胚操作。  
显然，边切割操作和结点贯通操作是一对互逆操作。例如，对于图10-48 所示的两个图模型，可通过对边的切割操作将$G_{1}$变成$G_{2}$，也可通过对结点做贯通操作将$G_{2}$变成$G_{1}$。  
![图10-48  图的同胚操作与同胚关系  ](images/17b45e1706460a818a5492fb4df19f0ddd6b072e9cf57afef7db0852f0c58237.jpg)  
下面在同胚操作的基础上，引入如下两个图之间的同胚关系：  
【定义10.9】设$G_{1}=\langle V_{1},E_{1}\rangle$和$G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，如果可用同胚操作将其中一个转化为另外一个，则称$G_{1}$与$G_{2}$具有同胚关系，简称为$G_{1}$与$G_{2}$同胚。  
根据上述同胚的概念，可以得到如下关于平面图判定的库拉托夫斯基定理：  
【定理10.16】（库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是$G$的任何子图都不同胚于$K_{5}$或$K_{3,3}$。  
【定理10.17】(库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是𝐺的任何子图都不能通过边的收缩得到$K_{5}$或$K_{3,3}$。  
![图10-51 彼得森图收缩为$ K_{5}$](images/b6cd48c8bf37519af48b0cc187afdf1adc13d2c5e160a08fe418ce5c94762fd6.jpg)  
库拉托夫斯基定理是一个非常著名定理，通常将$K_{5}$和$K_{3,3}$称为库拉托夫斯基图。可以使用该定理判定一个图是否为平面图。例如，对于图$10{-}51\mathrm{a}$）所示的彼得森图，收缩其边$(v_{i},u_{i})(i=1,2,3,4,5)$，则可得到图$K_{5}$，见图10-51b)。故彼得森图不是平面图。  
值得注意的是，虽然库拉托夫斯基定理给出了平面图判定的充分必要条件，但是目前还没有基于该定理得到一个有效的判定算法。因此，对于一个比较复杂的图模型，要判定其是否为平面图，有时并不是一件容易的事情。",欧拉公式描述了平面图中结点、边和面之间的数量关系
定理10.11,描述,平面图,,"所谓平面图，直观地说就是可以将该图嵌入到某个平面上。如图10-46（a）所示，图模型的边有时不仅在结点处相交，而且还在某些非结点处有交叉，这些非结点处交叉点的边重叠特征显然会导致图模型不能嵌入在同一个平面上。因此，为了将图模型嵌入平面，首先必须适当调整该图中边的走向，以保证任意两条边不会在非结点处有交叉，如图10-46（b）所示。由此得到可平面图和平面图的相关概念。  
【定义10.6】设$G=\langle V,E\rangle$是任意给定的一个图模型，如果该图中有两条边在非结点处有交叉，则称这两条边为该图的交叉边，交叉的具体位置称为交叉点。如果可将图𝐺画在同一个平面上，并且所有边除在结点处之外均不交叉，则称图𝐺可嵌入平面，或称𝐺为可平面图，否则称该图为不可平面图或非平面图。对于可平面图𝐺，将其边不交叉的画法称为𝐺的平面嵌入表示。以平面嵌入方式表示的图可平面图𝐺称为平面图。对于一个平面图𝐺，若对其再加一条边就变成不可平面图，则称𝐺为最大平面图。  
![](images/ad5984e0ab09600028eb4068193d74e75743de0f027a20b4d084511a312873d4.jpg)  
![（a）完全二分图$K_{3,3}$  （b）无法消除交叉  ](images/aa69f9dcec49f0e95a534b493200688a98dae4f4be8a347fbd35c04b8c21413b.jpg)  
例如，对于图10-46（a）所示的图，该图有三对交叉边，即$(v_{1},v_{4})$和$(v_{2},v_{3}),~(v_{1},v_{4})$和$(v_{2},v_{5})$、$(v_{1},v_{5})$和$(v_{2},v_{3})$。由于可将该图表示成图10-46（b）的形式，故该图是一个可平面图。图10-46（b）所示的图就是一个平面图。显然，如果在该平面图上增加一条边，则该图就变成一个不可平面图，故该是一个最大平面图。再如，对于图10-47（a）所示的图模型，无论怎么调整边的走向都不能将其以平面嵌入方式表示，如图10-47（b）所示。故图10-47（a）所示的图模型为不可平面图或非平面图。  
在没有特别要求的情况下，通常将可平面图与平面图不加区分地统称为平面图。与一般图模型显著不同的是，平面图模型除了具有结点和边这两个基本构件之外，还有一般图模型所没有的面的概念，并且由进一步面衍生出边界的概念。因此，平面图是一类非常重要的特殊图模型，无论在理论上还是在应用方面都具有非常重要的价值，在印刷电路板的设计、城市管网设计与规划等多个领域得到实际应用。  
图论之父欧拉对平面图有着比较深刻的研究，发现并论证了平面图的结点、边和面之间的数量关系，提出了著名的欧拉公式。下面给出平面图中面的相关概念：  
【定义10.7】设$G=\langle V,E\rangle$是任意给定的一个平面图，由𝐺中边所包围且内部不包含结点与边的区域，称为$G$的一个面。区域面积有限的面称为有限面，区域面积无限的面称为无限面。对于$G$的任意一个面$R$，包围面$R$的所有边构成的回路称为面𝑅的边界，面𝑅边界中边的个数称为面$R$的次数或度，记为${\bf d e g}(R)$。  
通俗地说，如果把一个平面图画在平面上，然后用小刀沿着图的边将平面切开，那么整个平面就被切成若干块，其中每一块就是图的一个面。或者说，平面图的一个面就是平面中一个以边为界线不能再分割的区域块。例如，对于图10-46（b）所示的平面图，一共有六个面，其中有一个面是无限面，其余五个是有限面。需要注意的是，对于任何一个平面图，该图有且仅有一个无限面。下面的定理10.11 给出了平面图中面数与边数的数量关系：  
【定理10.11】平面图中所有面的次数之和等于边数的两倍。  
下面定理10.12 是著名的欧拉公式，给出了平面图中结点、边和面之间的数量关系：  
【定理10.12】设$G=\langle V,E\rangle$是任意给定的一个连通平面图，若它有$n$个结点、$m$条边、$r$ 个面，则有  
$$
n-m+r=2\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
【定理10.13】如果平面连通图$G$每个面的次数均为$l(l\geq3)$，则有：  
$$
m=l(n-2)/(l-2)
$$  
其中$m$为$G$的边数，$n$为$G$的结点数。  
【定理10.14】设$G$是一个$(n,m)$简单连通平面图，若$m>1$，则有：  
$$
m\leq3n-6\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
由定理10.4 的逆命题不成立，也就是说满足不等式$m\leq3n-6$的简单连通图不一定是平面图。但是对于一个简单连通图，若不满足$m\leq3n-6$，则一定是非平面图。因此，可用定理10.4 的结论证明某个简单连通图不是非平面图。  
【定理10.15】设$G$为一平面连通简单图，其结点数$n\geq4$，边数为$m$，且$G$不以$K_{3}$为其子图，则有$m\leq2n-4$。  
【定义10.8】对于是任意给定的一个图模型$G=\langle V,E\rangle$  
设$e=(u,v)$是$G$的任意一条边，如果在图$G$中删除该边并新增一个结点$w$及两条边$e_{1}=$$(u,w)$、$e_{2}=(w,v)$ ，则称该操作为对图$G$的边切割操作；  
设𝑤是$G$中任意一个度数为2 的结点，且是边${e_{1}=(u,w)}$和$e_{2}=(w,v)$的公共结点，如果在图$G$中删除结点$w$及边$e_{1},\,e_{2}$，并增加边$e=(u,v)$，则称该操作为对图$G$的结点贯通操作；  
对图$G$的边切割操作和结点贯通操作统称为对图$G$的同胚操作。  
显然，边切割操作和结点贯通操作是一对互逆操作。例如，对于图10-48 所示的两个图模型，可通过对边的切割操作将$G_{1}$变成$G_{2}$，也可通过对结点做贯通操作将$G_{2}$变成$G_{1}$。  
![图10-48  图的同胚操作与同胚关系  ](images/17b45e1706460a818a5492fb4df19f0ddd6b072e9cf57afef7db0852f0c58237.jpg)  
下面在同胚操作的基础上，引入如下两个图之间的同胚关系：  
【定义10.9】设$G_{1}=\langle V_{1},E_{1}\rangle$和$G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，如果可用同胚操作将其中一个转化为另外一个，则称$G_{1}$与$G_{2}$具有同胚关系，简称为$G_{1}$与$G_{2}$同胚。  
根据上述同胚的概念，可以得到如下关于平面图判定的库拉托夫斯基定理：  
【定理10.16】（库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是$G$的任何子图都不同胚于$K_{5}$或$K_{3,3}$。  
【定理10.17】(库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是𝐺的任何子图都不能通过边的收缩得到$K_{5}$或$K_{3,3}$。  
![图10-51 彼得森图收缩为$ K_{5}$](images/b6cd48c8bf37519af48b0cc187afdf1adc13d2c5e160a08fe418ce5c94762fd6.jpg)  
库拉托夫斯基定理是一个非常著名定理，通常将$K_{5}$和$K_{3,3}$称为库拉托夫斯基图。可以使用该定理判定一个图是否为平面图。例如，对于图$10{-}51\mathrm{a}$）所示的彼得森图，收缩其边$(v_{i},u_{i})(i=1,2,3,4,5)$，则可得到图$K_{5}$，见图10-51b)。故彼得森图不是平面图。  
值得注意的是，虽然库拉托夫斯基定理给出了平面图判定的充分必要条件，但是目前还没有基于该定理得到一个有效的判定算法。因此，对于一个比较复杂的图模型，要判定其是否为平面图，有时并不是一件容易的事情。",定理10.11描述了平面图中面数与边数的数量关系
定理10.13,描述,平面图,,"所谓平面图，直观地说就是可以将该图嵌入到某个平面上。如图10-46（a）所示，图模型的边有时不仅在结点处相交，而且还在某些非结点处有交叉，这些非结点处交叉点的边重叠特征显然会导致图模型不能嵌入在同一个平面上。因此，为了将图模型嵌入平面，首先必须适当调整该图中边的走向，以保证任意两条边不会在非结点处有交叉，如图10-46（b）所示。由此得到可平面图和平面图的相关概念。  
【定义10.6】设$G=\langle V,E\rangle$是任意给定的一个图模型，如果该图中有两条边在非结点处有交叉，则称这两条边为该图的交叉边，交叉的具体位置称为交叉点。如果可将图𝐺画在同一个平面上，并且所有边除在结点处之外均不交叉，则称图𝐺可嵌入平面，或称𝐺为可平面图，否则称该图为不可平面图或非平面图。对于可平面图𝐺，将其边不交叉的画法称为𝐺的平面嵌入表示。以平面嵌入方式表示的图可平面图𝐺称为平面图。对于一个平面图𝐺，若对其再加一条边就变成不可平面图，则称𝐺为最大平面图。  
![](images/ad5984e0ab09600028eb4068193d74e75743de0f027a20b4d084511a312873d4.jpg)  
![（a）完全二分图$K_{3,3}$  （b）无法消除交叉  ](images/aa69f9dcec49f0e95a534b493200688a98dae4f4be8a347fbd35c04b8c21413b.jpg)  
例如，对于图10-46（a）所示的图，该图有三对交叉边，即$(v_{1},v_{4})$和$(v_{2},v_{3}),~(v_{1},v_{4})$和$(v_{2},v_{5})$、$(v_{1},v_{5})$和$(v_{2},v_{3})$。由于可将该图表示成图10-46（b）的形式，故该图是一个可平面图。图10-46（b）所示的图就是一个平面图。显然，如果在该平面图上增加一条边，则该图就变成一个不可平面图，故该是一个最大平面图。再如，对于图10-47（a）所示的图模型，无论怎么调整边的走向都不能将其以平面嵌入方式表示，如图10-47（b）所示。故图10-47（a）所示的图模型为不可平面图或非平面图。  
在没有特别要求的情况下，通常将可平面图与平面图不加区分地统称为平面图。与一般图模型显著不同的是，平面图模型除了具有结点和边这两个基本构件之外，还有一般图模型所没有的面的概念，并且由进一步面衍生出边界的概念。因此，平面图是一类非常重要的特殊图模型，无论在理论上还是在应用方面都具有非常重要的价值，在印刷电路板的设计、城市管网设计与规划等多个领域得到实际应用。  
图论之父欧拉对平面图有着比较深刻的研究，发现并论证了平面图的结点、边和面之间的数量关系，提出了著名的欧拉公式。下面给出平面图中面的相关概念：  
【定义10.7】设$G=\langle V,E\rangle$是任意给定的一个平面图，由𝐺中边所包围且内部不包含结点与边的区域，称为$G$的一个面。区域面积有限的面称为有限面，区域面积无限的面称为无限面。对于$G$的任意一个面$R$，包围面$R$的所有边构成的回路称为面𝑅的边界，面𝑅边界中边的个数称为面$R$的次数或度，记为${\bf d e g}(R)$。  
通俗地说，如果把一个平面图画在平面上，然后用小刀沿着图的边将平面切开，那么整个平面就被切成若干块，其中每一块就是图的一个面。或者说，平面图的一个面就是平面中一个以边为界线不能再分割的区域块。例如，对于图10-46（b）所示的平面图，一共有六个面，其中有一个面是无限面，其余五个是有限面。需要注意的是，对于任何一个平面图，该图有且仅有一个无限面。下面的定理10.11 给出了平面图中面数与边数的数量关系：  
【定理10.11】平面图中所有面的次数之和等于边数的两倍。  
下面定理10.12 是著名的欧拉公式，给出了平面图中结点、边和面之间的数量关系：  
【定理10.12】设$G=\langle V,E\rangle$是任意给定的一个连通平面图，若它有$n$个结点、$m$条边、$r$ 个面，则有  
$$
n-m+r=2\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
【定理10.13】如果平面连通图$G$每个面的次数均为$l(l\geq3)$，则有：  
$$
m=l(n-2)/(l-2)
$$  
其中$m$为$G$的边数，$n$为$G$的结点数。  
【定理10.14】设$G$是一个$(n,m)$简单连通平面图，若$m>1$，则有：  
$$
m\leq3n-6\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
由定理10.4 的逆命题不成立，也就是说满足不等式$m\leq3n-6$的简单连通图不一定是平面图。但是对于一个简单连通图，若不满足$m\leq3n-6$，则一定是非平面图。因此，可用定理10.4 的结论证明某个简单连通图不是非平面图。  
【定理10.15】设$G$为一平面连通简单图，其结点数$n\geq4$，边数为$m$，且$G$不以$K_{3}$为其子图，则有$m\leq2n-4$。  
【定义10.8】对于是任意给定的一个图模型$G=\langle V,E\rangle$  
设$e=(u,v)$是$G$的任意一条边，如果在图$G$中删除该边并新增一个结点$w$及两条边$e_{1}=$$(u,w)$、$e_{2}=(w,v)$ ，则称该操作为对图$G$的边切割操作；  
设𝑤是$G$中任意一个度数为2 的结点，且是边${e_{1}=(u,w)}$和$e_{2}=(w,v)$的公共结点，如果在图$G$中删除结点$w$及边$e_{1},\,e_{2}$，并增加边$e=(u,v)$，则称该操作为对图$G$的结点贯通操作；  
对图$G$的边切割操作和结点贯通操作统称为对图$G$的同胚操作。  
显然，边切割操作和结点贯通操作是一对互逆操作。例如，对于图10-48 所示的两个图模型，可通过对边的切割操作将$G_{1}$变成$G_{2}$，也可通过对结点做贯通操作将$G_{2}$变成$G_{1}$。  
![图10-48  图的同胚操作与同胚关系  ](images/17b45e1706460a818a5492fb4df19f0ddd6b072e9cf57afef7db0852f0c58237.jpg)  
下面在同胚操作的基础上，引入如下两个图之间的同胚关系：  
【定义10.9】设$G_{1}=\langle V_{1},E_{1}\rangle$和$G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，如果可用同胚操作将其中一个转化为另外一个，则称$G_{1}$与$G_{2}$具有同胚关系，简称为$G_{1}$与$G_{2}$同胚。  
根据上述同胚的概念，可以得到如下关于平面图判定的库拉托夫斯基定理：  
【定理10.16】（库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是$G$的任何子图都不同胚于$K_{5}$或$K_{3,3}$。  
【定理10.17】(库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是𝐺的任何子图都不能通过边的收缩得到$K_{5}$或$K_{3,3}$。  
![图10-51 彼得森图收缩为$ K_{5}$](images/b6cd48c8bf37519af48b0cc187afdf1adc13d2c5e160a08fe418ce5c94762fd6.jpg)  
库拉托夫斯基定理是一个非常著名定理，通常将$K_{5}$和$K_{3,3}$称为库拉托夫斯基图。可以使用该定理判定一个图是否为平面图。例如，对于图$10{-}51\mathrm{a}$）所示的彼得森图，收缩其边$(v_{i},u_{i})(i=1,2,3,4,5)$，则可得到图$K_{5}$，见图10-51b)。故彼得森图不是平面图。  
值得注意的是，虽然库拉托夫斯基定理给出了平面图判定的充分必要条件，但是目前还没有基于该定理得到一个有效的判定算法。因此，对于一个比较复杂的图模型，要判定其是否为平面图，有时并不是一件容易的事情。",定理10.13描述了平面连通图中边数与结点数的关系
定理10.14,描述,平面图,,"所谓平面图，直观地说就是可以将该图嵌入到某个平面上。如图10-46（a）所示，图模型的边有时不仅在结点处相交，而且还在某些非结点处有交叉，这些非结点处交叉点的边重叠特征显然会导致图模型不能嵌入在同一个平面上。因此，为了将图模型嵌入平面，首先必须适当调整该图中边的走向，以保证任意两条边不会在非结点处有交叉，如图10-46（b）所示。由此得到可平面图和平面图的相关概念。  
【定义10.6】设$G=\langle V,E\rangle$是任意给定的一个图模型，如果该图中有两条边在非结点处有交叉，则称这两条边为该图的交叉边，交叉的具体位置称为交叉点。如果可将图𝐺画在同一个平面上，并且所有边除在结点处之外均不交叉，则称图𝐺可嵌入平面，或称𝐺为可平面图，否则称该图为不可平面图或非平面图。对于可平面图𝐺，将其边不交叉的画法称为𝐺的平面嵌入表示。以平面嵌入方式表示的图可平面图𝐺称为平面图。对于一个平面图𝐺，若对其再加一条边就变成不可平面图，则称𝐺为最大平面图。  
![](images/ad5984e0ab09600028eb4068193d74e75743de0f027a20b4d084511a312873d4.jpg)  
![（a）完全二分图$K_{3,3}$  （b）无法消除交叉  ](images/aa69f9dcec49f0e95a534b493200688a98dae4f4be8a347fbd35c04b8c21413b.jpg)  
例如，对于图10-46（a）所示的图，该图有三对交叉边，即$(v_{1},v_{4})$和$(v_{2},v_{3}),~(v_{1},v_{4})$和$(v_{2},v_{5})$、$(v_{1},v_{5})$和$(v_{2},v_{3})$。由于可将该图表示成图10-46（b）的形式，故该图是一个可平面图。图10-46（b）所示的图就是一个平面图。显然，如果在该平面图上增加一条边，则该图就变成一个不可平面图，故该是一个最大平面图。再如，对于图10-47（a）所示的图模型，无论怎么调整边的走向都不能将其以平面嵌入方式表示，如图10-47（b）所示。故图10-47（a）所示的图模型为不可平面图或非平面图。  
在没有特别要求的情况下，通常将可平面图与平面图不加区分地统称为平面图。与一般图模型显著不同的是，平面图模型除了具有结点和边这两个基本构件之外，还有一般图模型所没有的面的概念，并且由进一步面衍生出边界的概念。因此，平面图是一类非常重要的特殊图模型，无论在理论上还是在应用方面都具有非常重要的价值，在印刷电路板的设计、城市管网设计与规划等多个领域得到实际应用。  
图论之父欧拉对平面图有着比较深刻的研究，发现并论证了平面图的结点、边和面之间的数量关系，提出了著名的欧拉公式。下面给出平面图中面的相关概念：  
【定义10.7】设$G=\langle V,E\rangle$是任意给定的一个平面图，由𝐺中边所包围且内部不包含结点与边的区域，称为$G$的一个面。区域面积有限的面称为有限面，区域面积无限的面称为无限面。对于$G$的任意一个面$R$，包围面$R$的所有边构成的回路称为面𝑅的边界，面𝑅边界中边的个数称为面$R$的次数或度，记为${\bf d e g}(R)$。  
通俗地说，如果把一个平面图画在平面上，然后用小刀沿着图的边将平面切开，那么整个平面就被切成若干块，其中每一块就是图的一个面。或者说，平面图的一个面就是平面中一个以边为界线不能再分割的区域块。例如，对于图10-46（b）所示的平面图，一共有六个面，其中有一个面是无限面，其余五个是有限面。需要注意的是，对于任何一个平面图，该图有且仅有一个无限面。下面的定理10.11 给出了平面图中面数与边数的数量关系：  
【定理10.11】平面图中所有面的次数之和等于边数的两倍。  
下面定理10.12 是著名的欧拉公式，给出了平面图中结点、边和面之间的数量关系：  
【定理10.12】设$G=\langle V,E\rangle$是任意给定的一个连通平面图，若它有$n$个结点、$m$条边、$r$ 个面，则有  
$$
n-m+r=2\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
【定理10.13】如果平面连通图$G$每个面的次数均为$l(l\geq3)$，则有：  
$$
m=l(n-2)/(l-2)
$$  
其中$m$为$G$的边数，$n$为$G$的结点数。  
【定理10.14】设$G$是一个$(n,m)$简单连通平面图，若$m>1$，则有：  
$$
m\leq3n-6\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
由定理10.4 的逆命题不成立，也就是说满足不等式$m\leq3n-6$的简单连通图不一定是平面图。但是对于一个简单连通图，若不满足$m\leq3n-6$，则一定是非平面图。因此，可用定理10.4 的结论证明某个简单连通图不是非平面图。  
【定理10.15】设$G$为一平面连通简单图，其结点数$n\geq4$，边数为$m$，且$G$不以$K_{3}$为其子图，则有$m\leq2n-4$。  
【定义10.8】对于是任意给定的一个图模型$G=\langle V,E\rangle$  
设$e=(u,v)$是$G$的任意一条边，如果在图$G$中删除该边并新增一个结点$w$及两条边$e_{1}=$$(u,w)$、$e_{2}=(w,v)$ ，则称该操作为对图$G$的边切割操作；  
设𝑤是$G$中任意一个度数为2 的结点，且是边${e_{1}=(u,w)}$和$e_{2}=(w,v)$的公共结点，如果在图$G$中删除结点$w$及边$e_{1},\,e_{2}$，并增加边$e=(u,v)$，则称该操作为对图$G$的结点贯通操作；  
对图$G$的边切割操作和结点贯通操作统称为对图$G$的同胚操作。  
显然，边切割操作和结点贯通操作是一对互逆操作。例如，对于图10-48 所示的两个图模型，可通过对边的切割操作将$G_{1}$变成$G_{2}$，也可通过对结点做贯通操作将$G_{2}$变成$G_{1}$。  
![图10-48  图的同胚操作与同胚关系  ](images/17b45e1706460a818a5492fb4df19f0ddd6b072e9cf57afef7db0852f0c58237.jpg)  
下面在同胚操作的基础上，引入如下两个图之间的同胚关系：  
【定义10.9】设$G_{1}=\langle V_{1},E_{1}\rangle$和$G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，如果可用同胚操作将其中一个转化为另外一个，则称$G_{1}$与$G_{2}$具有同胚关系，简称为$G_{1}$与$G_{2}$同胚。  
根据上述同胚的概念，可以得到如下关于平面图判定的库拉托夫斯基定理：  
【定理10.16】（库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是$G$的任何子图都不同胚于$K_{5}$或$K_{3,3}$。  
【定理10.17】(库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是𝐺的任何子图都不能通过边的收缩得到$K_{5}$或$K_{3,3}$。  
![图10-51 彼得森图收缩为$ K_{5}$](images/b6cd48c8bf37519af48b0cc187afdf1adc13d2c5e160a08fe418ce5c94762fd6.jpg)  
库拉托夫斯基定理是一个非常著名定理，通常将$K_{5}$和$K_{3,3}$称为库拉托夫斯基图。可以使用该定理判定一个图是否为平面图。例如，对于图$10{-}51\mathrm{a}$）所示的彼得森图，收缩其边$(v_{i},u_{i})(i=1,2,3,4,5)$，则可得到图$K_{5}$，见图10-51b)。故彼得森图不是平面图。  
值得注意的是，虽然库拉托夫斯基定理给出了平面图判定的充分必要条件，但是目前还没有基于该定理得到一个有效的判定算法。因此，对于一个比较复杂的图模型，要判定其是否为平面图，有时并不是一件容易的事情。",定理10.14给出了简单连通平面图中边数与结点数的不等式关系
定理10.15,描述,平面图,,"所谓平面图，直观地说就是可以将该图嵌入到某个平面上。如图10-46（a）所示，图模型的边有时不仅在结点处相交，而且还在某些非结点处有交叉，这些非结点处交叉点的边重叠特征显然会导致图模型不能嵌入在同一个平面上。因此，为了将图模型嵌入平面，首先必须适当调整该图中边的走向，以保证任意两条边不会在非结点处有交叉，如图10-46（b）所示。由此得到可平面图和平面图的相关概念。  
【定义10.6】设$G=\langle V,E\rangle$是任意给定的一个图模型，如果该图中有两条边在非结点处有交叉，则称这两条边为该图的交叉边，交叉的具体位置称为交叉点。如果可将图𝐺画在同一个平面上，并且所有边除在结点处之外均不交叉，则称图𝐺可嵌入平面，或称𝐺为可平面图，否则称该图为不可平面图或非平面图。对于可平面图𝐺，将其边不交叉的画法称为𝐺的平面嵌入表示。以平面嵌入方式表示的图可平面图𝐺称为平面图。对于一个平面图𝐺，若对其再加一条边就变成不可平面图，则称𝐺为最大平面图。  
![](images/ad5984e0ab09600028eb4068193d74e75743de0f027a20b4d084511a312873d4.jpg)  
![（a）完全二分图$K_{3,3}$  （b）无法消除交叉  ](images/aa69f9dcec49f0e95a534b493200688a98dae4f4be8a347fbd35c04b8c21413b.jpg)  
例如，对于图10-46（a）所示的图，该图有三对交叉边，即$(v_{1},v_{4})$和$(v_{2},v_{3}),~(v_{1},v_{4})$和$(v_{2},v_{5})$、$(v_{1},v_{5})$和$(v_{2},v_{3})$。由于可将该图表示成图10-46（b）的形式，故该图是一个可平面图。图10-46（b）所示的图就是一个平面图。显然，如果在该平面图上增加一条边，则该图就变成一个不可平面图，故该是一个最大平面图。再如，对于图10-47（a）所示的图模型，无论怎么调整边的走向都不能将其以平面嵌入方式表示，如图10-47（b）所示。故图10-47（a）所示的图模型为不可平面图或非平面图。  
在没有特别要求的情况下，通常将可平面图与平面图不加区分地统称为平面图。与一般图模型显著不同的是，平面图模型除了具有结点和边这两个基本构件之外，还有一般图模型所没有的面的概念，并且由进一步面衍生出边界的概念。因此，平面图是一类非常重要的特殊图模型，无论在理论上还是在应用方面都具有非常重要的价值，在印刷电路板的设计、城市管网设计与规划等多个领域得到实际应用。  
图论之父欧拉对平面图有着比较深刻的研究，发现并论证了平面图的结点、边和面之间的数量关系，提出了著名的欧拉公式。下面给出平面图中面的相关概念：  
【定义10.7】设$G=\langle V,E\rangle$是任意给定的一个平面图，由𝐺中边所包围且内部不包含结点与边的区域，称为$G$的一个面。区域面积有限的面称为有限面，区域面积无限的面称为无限面。对于$G$的任意一个面$R$，包围面$R$的所有边构成的回路称为面𝑅的边界，面𝑅边界中边的个数称为面$R$的次数或度，记为${\bf d e g}(R)$。  
通俗地说，如果把一个平面图画在平面上，然后用小刀沿着图的边将平面切开，那么整个平面就被切成若干块，其中每一块就是图的一个面。或者说，平面图的一个面就是平面中一个以边为界线不能再分割的区域块。例如，对于图10-46（b）所示的平面图，一共有六个面，其中有一个面是无限面，其余五个是有限面。需要注意的是，对于任何一个平面图，该图有且仅有一个无限面。下面的定理10.11 给出了平面图中面数与边数的数量关系：  
【定理10.11】平面图中所有面的次数之和等于边数的两倍。  
下面定理10.12 是著名的欧拉公式，给出了平面图中结点、边和面之间的数量关系：  
【定理10.12】设$G=\langle V,E\rangle$是任意给定的一个连通平面图，若它有$n$个结点、$m$条边、$r$ 个面，则有  
$$
n-m+r=2\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
【定理10.13】如果平面连通图$G$每个面的次数均为$l(l\geq3)$，则有：  
$$
m=l(n-2)/(l-2)
$$  
其中$m$为$G$的边数，$n$为$G$的结点数。  
【定理10.14】设$G$是一个$(n,m)$简单连通平面图，若$m>1$，则有：  
$$
m\leq3n-6\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
由定理10.4 的逆命题不成立，也就是说满足不等式$m\leq3n-6$的简单连通图不一定是平面图。但是对于一个简单连通图，若不满足$m\leq3n-6$，则一定是非平面图。因此，可用定理10.4 的结论证明某个简单连通图不是非平面图。  
【定理10.15】设$G$为一平面连通简单图，其结点数$n\geq4$，边数为$m$，且$G$不以$K_{3}$为其子图，则有$m\leq2n-4$。  
【定义10.8】对于是任意给定的一个图模型$G=\langle V,E\rangle$  
设$e=(u,v)$是$G$的任意一条边，如果在图$G$中删除该边并新增一个结点$w$及两条边$e_{1}=$$(u,w)$、$e_{2}=(w,v)$ ，则称该操作为对图$G$的边切割操作；  
设𝑤是$G$中任意一个度数为2 的结点，且是边${e_{1}=(u,w)}$和$e_{2}=(w,v)$的公共结点，如果在图$G$中删除结点$w$及边$e_{1},\,e_{2}$，并增加边$e=(u,v)$，则称该操作为对图$G$的结点贯通操作；  
对图$G$的边切割操作和结点贯通操作统称为对图$G$的同胚操作。  
显然，边切割操作和结点贯通操作是一对互逆操作。例如，对于图10-48 所示的两个图模型，可通过对边的切割操作将$G_{1}$变成$G_{2}$，也可通过对结点做贯通操作将$G_{2}$变成$G_{1}$。  
![图10-48  图的同胚操作与同胚关系  ](images/17b45e1706460a818a5492fb4df19f0ddd6b072e9cf57afef7db0852f0c58237.jpg)  
下面在同胚操作的基础上，引入如下两个图之间的同胚关系：  
【定义10.9】设$G_{1}=\langle V_{1},E_{1}\rangle$和$G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，如果可用同胚操作将其中一个转化为另外一个，则称$G_{1}$与$G_{2}$具有同胚关系，简称为$G_{1}$与$G_{2}$同胚。  
根据上述同胚的概念，可以得到如下关于平面图判定的库拉托夫斯基定理：  
【定理10.16】（库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是$G$的任何子图都不同胚于$K_{5}$或$K_{3,3}$。  
【定理10.17】(库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是𝐺的任何子图都不能通过边的收缩得到$K_{5}$或$K_{3,3}$。  
![图10-51 彼得森图收缩为$ K_{5}$](images/b6cd48c8bf37519af48b0cc187afdf1adc13d2c5e160a08fe418ce5c94762fd6.jpg)  
库拉托夫斯基定理是一个非常著名定理，通常将$K_{5}$和$K_{3,3}$称为库拉托夫斯基图。可以使用该定理判定一个图是否为平面图。例如，对于图$10{-}51\mathrm{a}$）所示的彼得森图，收缩其边$(v_{i},u_{i})(i=1,2,3,4,5)$，则可得到图$K_{5}$，见图10-51b)。故彼得森图不是平面图。  
值得注意的是，虽然库拉托夫斯基定理给出了平面图判定的充分必要条件，但是目前还没有基于该定理得到一个有效的判定算法。因此，对于一个比较复杂的图模型，要判定其是否为平面图，有时并不是一件容易的事情。",定理10.15描述了特定条件下平面连通简单图中边数与结点数的关系
同胚操作,基础,同胚关系,,"所谓平面图，直观地说就是可以将该图嵌入到某个平面上。如图10-46（a）所示，图模型的边有时不仅在结点处相交，而且还在某些非结点处有交叉，这些非结点处交叉点的边重叠特征显然会导致图模型不能嵌入在同一个平面上。因此，为了将图模型嵌入平面，首先必须适当调整该图中边的走向，以保证任意两条边不会在非结点处有交叉，如图10-46（b）所示。由此得到可平面图和平面图的相关概念。  
【定义10.6】设$G=\langle V,E\rangle$是任意给定的一个图模型，如果该图中有两条边在非结点处有交叉，则称这两条边为该图的交叉边，交叉的具体位置称为交叉点。如果可将图𝐺画在同一个平面上，并且所有边除在结点处之外均不交叉，则称图𝐺可嵌入平面，或称𝐺为可平面图，否则称该图为不可平面图或非平面图。对于可平面图𝐺，将其边不交叉的画法称为𝐺的平面嵌入表示。以平面嵌入方式表示的图可平面图𝐺称为平面图。对于一个平面图𝐺，若对其再加一条边就变成不可平面图，则称𝐺为最大平面图。  
![](images/ad5984e0ab09600028eb4068193d74e75743de0f027a20b4d084511a312873d4.jpg)  
![（a）完全二分图$K_{3,3}$  （b）无法消除交叉  ](images/aa69f9dcec49f0e95a534b493200688a98dae4f4be8a347fbd35c04b8c21413b.jpg)  
例如，对于图10-46（a）所示的图，该图有三对交叉边，即$(v_{1},v_{4})$和$(v_{2},v_{3}),~(v_{1},v_{4})$和$(v_{2},v_{5})$、$(v_{1},v_{5})$和$(v_{2},v_{3})$。由于可将该图表示成图10-46（b）的形式，故该图是一个可平面图。图10-46（b）所示的图就是一个平面图。显然，如果在该平面图上增加一条边，则该图就变成一个不可平面图，故该是一个最大平面图。再如，对于图10-47（a）所示的图模型，无论怎么调整边的走向都不能将其以平面嵌入方式表示，如图10-47（b）所示。故图10-47（a）所示的图模型为不可平面图或非平面图。  
在没有特别要求的情况下，通常将可平面图与平面图不加区分地统称为平面图。与一般图模型显著不同的是，平面图模型除了具有结点和边这两个基本构件之外，还有一般图模型所没有的面的概念，并且由进一步面衍生出边界的概念。因此，平面图是一类非常重要的特殊图模型，无论在理论上还是在应用方面都具有非常重要的价值，在印刷电路板的设计、城市管网设计与规划等多个领域得到实际应用。  
图论之父欧拉对平面图有着比较深刻的研究，发现并论证了平面图的结点、边和面之间的数量关系，提出了著名的欧拉公式。下面给出平面图中面的相关概念：  
【定义10.7】设$G=\langle V,E\rangle$是任意给定的一个平面图，由𝐺中边所包围且内部不包含结点与边的区域，称为$G$的一个面。区域面积有限的面称为有限面，区域面积无限的面称为无限面。对于$G$的任意一个面$R$，包围面$R$的所有边构成的回路称为面𝑅的边界，面𝑅边界中边的个数称为面$R$的次数或度，记为${\bf d e g}(R)$。  
通俗地说，如果把一个平面图画在平面上，然后用小刀沿着图的边将平面切开，那么整个平面就被切成若干块，其中每一块就是图的一个面。或者说，平面图的一个面就是平面中一个以边为界线不能再分割的区域块。例如，对于图10-46（b）所示的平面图，一共有六个面，其中有一个面是无限面，其余五个是有限面。需要注意的是，对于任何一个平面图，该图有且仅有一个无限面。下面的定理10.11 给出了平面图中面数与边数的数量关系：  
【定理10.11】平面图中所有面的次数之和等于边数的两倍。  
下面定理10.12 是著名的欧拉公式，给出了平面图中结点、边和面之间的数量关系：  
【定理10.12】设$G=\langle V,E\rangle$是任意给定的一个连通平面图，若它有$n$个结点、$m$条边、$r$ 个面，则有  
$$
n-m+r=2\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
【定理10.13】如果平面连通图$G$每个面的次数均为$l(l\geq3)$，则有：  
$$
m=l(n-2)/(l-2)
$$  
其中$m$为$G$的边数，$n$为$G$的结点数。  
【定理10.14】设$G$是一个$(n,m)$简单连通平面图，若$m>1$，则有：  
$$
m\leq3n-6\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
由定理10.4 的逆命题不成立，也就是说满足不等式$m\leq3n-6$的简单连通图不一定是平面图。但是对于一个简单连通图，若不满足$m\leq3n-6$，则一定是非平面图。因此，可用定理10.4 的结论证明某个简单连通图不是非平面图。  
【定理10.15】设$G$为一平面连通简单图，其结点数$n\geq4$，边数为$m$，且$G$不以$K_{3}$为其子图，则有$m\leq2n-4$。  
【定义10.8】对于是任意给定的一个图模型$G=\langle V,E\rangle$  
设$e=(u,v)$是$G$的任意一条边，如果在图$G$中删除该边并新增一个结点$w$及两条边$e_{1}=$$(u,w)$、$e_{2}=(w,v)$ ，则称该操作为对图$G$的边切割操作；  
设𝑤是$G$中任意一个度数为2 的结点，且是边${e_{1}=(u,w)}$和$e_{2}=(w,v)$的公共结点，如果在图$G$中删除结点$w$及边$e_{1},\,e_{2}$，并增加边$e=(u,v)$，则称该操作为对图$G$的结点贯通操作；  
对图$G$的边切割操作和结点贯通操作统称为对图$G$的同胚操作。  
显然，边切割操作和结点贯通操作是一对互逆操作。例如，对于图10-48 所示的两个图模型，可通过对边的切割操作将$G_{1}$变成$G_{2}$，也可通过对结点做贯通操作将$G_{2}$变成$G_{1}$。  
![图10-48  图的同胚操作与同胚关系  ](images/17b45e1706460a818a5492fb4df19f0ddd6b072e9cf57afef7db0852f0c58237.jpg)  
下面在同胚操作的基础上，引入如下两个图之间的同胚关系：  
【定义10.9】设$G_{1}=\langle V_{1},E_{1}\rangle$和$G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，如果可用同胚操作将其中一个转化为另外一个，则称$G_{1}$与$G_{2}$具有同胚关系，简称为$G_{1}$与$G_{2}$同胚。  
根据上述同胚的概念，可以得到如下关于平面图判定的库拉托夫斯基定理：  
【定理10.16】（库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是$G$的任何子图都不同胚于$K_{5}$或$K_{3,3}$。  
【定理10.17】(库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是𝐺的任何子图都不能通过边的收缩得到$K_{5}$或$K_{3,3}$。  
![图10-51 彼得森图收缩为$ K_{5}$](images/b6cd48c8bf37519af48b0cc187afdf1adc13d2c5e160a08fe418ce5c94762fd6.jpg)  
库拉托夫斯基定理是一个非常著名定理，通常将$K_{5}$和$K_{3,3}$称为库拉托夫斯基图。可以使用该定理判定一个图是否为平面图。例如，对于图$10{-}51\mathrm{a}$）所示的彼得森图，收缩其边$(v_{i},u_{i})(i=1,2,3,4,5)$，则可得到图$K_{5}$，见图10-51b)。故彼得森图不是平面图。  
值得注意的是，虽然库拉托夫斯基定理给出了平面图判定的充分必要条件，但是目前还没有基于该定理得到一个有效的判定算法。因此，对于一个比较复杂的图模型，要判定其是否为平面图，有时并不是一件容易的事情。",同胚关系基于同胚操作定义
库拉托夫斯基定理,判定,平面图,,"所谓平面图，直观地说就是可以将该图嵌入到某个平面上。如图10-46（a）所示，图模型的边有时不仅在结点处相交，而且还在某些非结点处有交叉，这些非结点处交叉点的边重叠特征显然会导致图模型不能嵌入在同一个平面上。因此，为了将图模型嵌入平面，首先必须适当调整该图中边的走向，以保证任意两条边不会在非结点处有交叉，如图10-46（b）所示。由此得到可平面图和平面图的相关概念。  
【定义10.6】设$G=\langle V,E\rangle$是任意给定的一个图模型，如果该图中有两条边在非结点处有交叉，则称这两条边为该图的交叉边，交叉的具体位置称为交叉点。如果可将图𝐺画在同一个平面上，并且所有边除在结点处之外均不交叉，则称图𝐺可嵌入平面，或称𝐺为可平面图，否则称该图为不可平面图或非平面图。对于可平面图𝐺，将其边不交叉的画法称为𝐺的平面嵌入表示。以平面嵌入方式表示的图可平面图𝐺称为平面图。对于一个平面图𝐺，若对其再加一条边就变成不可平面图，则称𝐺为最大平面图。  
![](images/ad5984e0ab09600028eb4068193d74e75743de0f027a20b4d084511a312873d4.jpg)  
![（a）完全二分图$K_{3,3}$  （b）无法消除交叉  ](images/aa69f9dcec49f0e95a534b493200688a98dae4f4be8a347fbd35c04b8c21413b.jpg)  
例如，对于图10-46（a）所示的图，该图有三对交叉边，即$(v_{1},v_{4})$和$(v_{2},v_{3}),~(v_{1},v_{4})$和$(v_{2},v_{5})$、$(v_{1},v_{5})$和$(v_{2},v_{3})$。由于可将该图表示成图10-46（b）的形式，故该图是一个可平面图。图10-46（b）所示的图就是一个平面图。显然，如果在该平面图上增加一条边，则该图就变成一个不可平面图，故该是一个最大平面图。再如，对于图10-47（a）所示的图模型，无论怎么调整边的走向都不能将其以平面嵌入方式表示，如图10-47（b）所示。故图10-47（a）所示的图模型为不可平面图或非平面图。  
在没有特别要求的情况下，通常将可平面图与平面图不加区分地统称为平面图。与一般图模型显著不同的是，平面图模型除了具有结点和边这两个基本构件之外，还有一般图模型所没有的面的概念，并且由进一步面衍生出边界的概念。因此，平面图是一类非常重要的特殊图模型，无论在理论上还是在应用方面都具有非常重要的价值，在印刷电路板的设计、城市管网设计与规划等多个领域得到实际应用。  
图论之父欧拉对平面图有着比较深刻的研究，发现并论证了平面图的结点、边和面之间的数量关系，提出了著名的欧拉公式。下面给出平面图中面的相关概念：  
【定义10.7】设$G=\langle V,E\rangle$是任意给定的一个平面图，由𝐺中边所包围且内部不包含结点与边的区域，称为$G$的一个面。区域面积有限的面称为有限面，区域面积无限的面称为无限面。对于$G$的任意一个面$R$，包围面$R$的所有边构成的回路称为面𝑅的边界，面𝑅边界中边的个数称为面$R$的次数或度，记为${\bf d e g}(R)$。  
通俗地说，如果把一个平面图画在平面上，然后用小刀沿着图的边将平面切开，那么整个平面就被切成若干块，其中每一块就是图的一个面。或者说，平面图的一个面就是平面中一个以边为界线不能再分割的区域块。例如，对于图10-46（b）所示的平面图，一共有六个面，其中有一个面是无限面，其余五个是有限面。需要注意的是，对于任何一个平面图，该图有且仅有一个无限面。下面的定理10.11 给出了平面图中面数与边数的数量关系：  
【定理10.11】平面图中所有面的次数之和等于边数的两倍。  
下面定理10.12 是著名的欧拉公式，给出了平面图中结点、边和面之间的数量关系：  
【定理10.12】设$G=\langle V,E\rangle$是任意给定的一个连通平面图，若它有$n$个结点、$m$条边、$r$ 个面，则有  
$$
n-m+r=2\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
【定理10.13】如果平面连通图$G$每个面的次数均为$l(l\geq3)$，则有：  
$$
m=l(n-2)/(l-2)
$$  
其中$m$为$G$的边数，$n$为$G$的结点数。  
【定理10.14】设$G$是一个$(n,m)$简单连通平面图，若$m>1$，则有：  
$$
m\leq3n-6\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,\,
$$  
由定理10.4 的逆命题不成立，也就是说满足不等式$m\leq3n-6$的简单连通图不一定是平面图。但是对于一个简单连通图，若不满足$m\leq3n-6$，则一定是非平面图。因此，可用定理10.4 的结论证明某个简单连通图不是非平面图。  
【定理10.15】设$G$为一平面连通简单图，其结点数$n\geq4$，边数为$m$，且$G$不以$K_{3}$为其子图，则有$m\leq2n-4$。  
【定义10.8】对于是任意给定的一个图模型$G=\langle V,E\rangle$  
设$e=(u,v)$是$G$的任意一条边，如果在图$G$中删除该边并新增一个结点$w$及两条边$e_{1}=$$(u,w)$、$e_{2}=(w,v)$ ，则称该操作为对图$G$的边切割操作；  
设𝑤是$G$中任意一个度数为2 的结点，且是边${e_{1}=(u,w)}$和$e_{2}=(w,v)$的公共结点，如果在图$G$中删除结点$w$及边$e_{1},\,e_{2}$，并增加边$e=(u,v)$，则称该操作为对图$G$的结点贯通操作；  
对图$G$的边切割操作和结点贯通操作统称为对图$G$的同胚操作。  
显然，边切割操作和结点贯通操作是一对互逆操作。例如，对于图10-48 所示的两个图模型，可通过对边的切割操作将$G_{1}$变成$G_{2}$，也可通过对结点做贯通操作将$G_{2}$变成$G_{1}$。  
![图10-48  图的同胚操作与同胚关系  ](images/17b45e1706460a818a5492fb4df19f0ddd6b072e9cf57afef7db0852f0c58237.jpg)  
下面在同胚操作的基础上，引入如下两个图之间的同胚关系：  
【定义10.9】设$G_{1}=\langle V_{1},E_{1}\rangle$和$G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，如果可用同胚操作将其中一个转化为另外一个，则称$G_{1}$与$G_{2}$具有同胚关系，简称为$G_{1}$与$G_{2}$同胚。  
根据上述同胚的概念，可以得到如下关于平面图判定的库拉托夫斯基定理：  
【定理10.16】（库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是$G$的任何子图都不同胚于$K_{5}$或$K_{3,3}$。  
【定理10.17】(库拉托夫斯基定理) 设$G=\langle V,E\rangle$是任意给定的一个图模型，则$G$是平面图的充分必要条件是𝐺的任何子图都不能通过边的收缩得到$K_{5}$或$K_{3,3}$。  
![图10-51 彼得森图收缩为$ K_{5}$](images/b6cd48c8bf37519af48b0cc187afdf1adc13d2c5e160a08fe418ce5c94762fd6.jpg)  
库拉托夫斯基定理是一个非常著名定理，通常将$K_{5}$和$K_{3,3}$称为库拉托夫斯基图。可以使用该定理判定一个图是否为平面图。例如，对于图$10{-}51\mathrm{a}$）所示的彼得森图，收缩其边$(v_{i},u_{i})(i=1,2,3,4,5)$，则可得到图$K_{5}$，见图10-51b)。故彼得森图不是平面图。  
值得注意的是，虽然库拉托夫斯基定理给出了平面图判定的充分必要条件，但是目前还没有基于该定理得到一个有效的判定算法。因此，对于一个比较复杂的图模型，要判定其是否为平面图，有时并不是一件容易的事情。",库拉托夫斯基定理提供了判定一个图是否为平面图的充分必要条件
平面图的对偶图,对偶关系,平面图,,"我们知道，任何一个给定的平面图都具有结点、边和面这三个基本要素。如果将其中结点和面的概念进行对换，具体地说，就是将平面图中现有的所有结点分别变换成面，将现有的所有面分别变换成结点，则可以得到一个新的图模型。可以证明，这种新的图模型与现有平面图之间在很多方面具有相同的运算性质，彼此形成一种相互对偶的关系，故称之为平面图的对偶图。本节主要讨论对偶图的概念与性质，首先给出对偶图的定义：  
【定义10.10】设$G=\langle V,E\rangle$是任意给定的一个连通平面图，并且图中具有$n$个面，则对$G=\langle V,E\rangle$实施下列步骤所得到的图$G^{*}=\langle V^{*},E^{*}\rangle$称为$G$的对偶图：  
（1）在$G$的每个面$r_{i}$中设置$G^{*}$的一个结点${v_{i}}^{*}(1\leq i\leq n)$ ；  
（2）若$G$的面$r_{i}$和$r_{j}$有公共边界，那么经过界的每条边$\boldsymbol{\mathscr{e}}_{k}$分别作关联${v_{i}}^{*}$与${v_{j}}^{*}$的一条边${e}_{k}^{\ast}$且${e}_{k}^{*}$与$G^{*}$的其它边不相交$(1\leq i,j\leq n)$；  
（3）当$e_{k}$为面${r}_{i}$的边界但不是$r_{i}$与其它面的公共边界时，作${v_{i}}^{*}$的一条环与$e_{k}$相交，且不与$G^{*}$中其它边相交。  
![](images/fafbaa2a39700aee1a0d05561e456a1d09b8cc93cd865dffe10e0cd70d34d343.jpg)  
通过例题10.14，不难看出连通平面图$G$的对偶图为$G^{*}$，具有以下基本性质：  
（1）连通平面图$G$的对偶图$G^{*}$也是一个连通平面图。  
（2）若边$e$是$G$的环，则其对应边$e^{*}$为$G^{*}$的桥，若边$e$是$G$的桥，则去对应边$e^{*}$为$G^{*}$的环。  
（3）若$G$的面$r_{i}$与$r_{j}$在边界上至少有两条公共边，则关联${v_{i}}^{*}$与${v_{j}}^{*}$的边有平行边。  
（4）同构图的对偶图不一定同构，图的不同平面表示可能得到不同的对偶图。 下面的定理10.18 给出了连通平面图$G$的对偶图为$G^{*}$之间的数量关系：  
【定理10.18】若连通平面图$G$的对偶图为$G^{*}$，则有如下结论：  
（1）$G^{*}$结点数等于$G$的面数； $G^{*}$边数等于$G$的边数； $G^{*}$面数等于$G$的结点数。 （2）设$G^{*}$的结点${v_{i}}^{*}$位于$G$的面${r_{i}}$内部，则结点${v_{i}}^{*}$的度与面${r}_{i}$的度相等，即有：  
$$
\deg({v_{i}}^{*})=\deg({r_{i}})
$$",平面图的对偶图是通过将平面图的结点和面进行对换得到的图模型，两者在很多方面具有相同的运算性质，形成相互对偶的关系。
着色问题,包含,结点着色算法,,图的着色问题起源对平面图（地图）四色猜想，即至多用四种不同颜色给地图着色，就可使相互接壤的国家通过不同的颜色进行区分。四色猜想虽然针对平面图的面着色，但图的着色问题并不局限于平面图。事实上，对于一般的非平面图，可以研究其结点着色和边着色问题，对于平面图，可以研究结点着色、边着色和面着色问题。由于边着色和面着色问题可以通过适当方式转化为结点着色问题，故一般仅讨论结点着色算法。本节讨论图的着色问题与算法，主要包括点着色与边着色、面着色与五色定理、结点着色算法。,着色问题包含结点着色算法的研究内容
着色问题,相关,五色定理,,图的着色问题起源对平面图（地图）四色猜想，即至多用四种不同颜色给地图着色，就可使相互接壤的国家通过不同的颜色进行区分。四色猜想虽然针对平面图的面着色，但图的着色问题并不局限于平面图。事实上，对于一般的非平面图，可以研究其结点着色和边着色问题，对于平面图，可以研究结点着色、边着色和面着色问题。由于边着色和面着色问题可以通过适当方式转化为结点着色问题，故一般仅讨论结点着色算法。本节讨论图的着色问题与算法，主要包括点着色与边着色、面着色与五色定理、结点着色算法。,着色问题与五色定理相关，特别是在平面图的着色研究中
二分图,性质,点着色,,"首先考察一个实例，我们通常在同一台冰箱内存放不同种类的食物，其中有些食品必须分别保存在不同冰箱隔间以免串味或污染。例如，苹果和鸡蛋应该分开存放、腊肉和蔬菜应该分开存放等等。现有$A,B,C,D,E,F$六种食品，若要求$𝐴$与$𝐵$、$𝐴$与$C$、$𝐴$与$𝐷$、$B$与$C$、$C$与$D$、$C$与$F$、$D$与$E$、$E$与$F$不能放在一起，则至少需要几个隔间才能存放这些食物。  
![图10-56 冰箱中食物存放问题  ](images/557fa53c5bf02920ef35e88225888a1b53ecb35568cc495b689ec5f32f0de05e.jpg)  
可用一个无向图模型表示上述问题，图的每个结点分别代表一种食物，如果两种食物不能放在一起，则在这两种食物之间画一条无向边，如图10-55（a）所示。可通过对该图的结进行着色的方法实现对上述问题的求解。具体地说，就是对图中每个结点分别涂上或者标注一种颜色，并满足相邻的结点之间具有不同的颜色，将相同颜色结点所代表的食物放在同一个隔间，则所需要的最少颜色数目显然就是所求的冰箱隔间数目。  
不难知道，最少需要三种颜色才能实现对图10-55（a）所示无向图全部结点的着色，图10-55（b）表示其中一种着色方案。  
事实上，如果将上述六种食物分别看成是某个工程中的六项不同的任务，将不能存放在同一个隔间的两种食物理解为不能同时执行的两个任务，则可按照图10-55（b）所示的结点着色方案将这些任务以同色为标准分成3 个并行执行的任务集合。因此，无向图的着色理论与方法在并行计算与任务规划等领域具有非常重要的作用。  
对于一个比较复杂的无向图，要实现对该图所有结点的着色，在很多情况下不是一件很显然的事情。下面具体考察点着色问题，首先给出结点着色的定义，具体如下：  
【定义10.11】设$G=\langle V,E\rangle$是任意给定的一个无向图，如果对图𝐺的每个结点都涂上或标注一种颜色，并满足相邻的两个点具有不同的颜色，则称这种操作是对图$G$的结点着色，简称为对图𝐺的点着色。如果这些颜色选自于一个有𝑘种颜色的集合而不管$k$种颜色是否都用到，则称这样的点作色为称为𝒌着色，并称𝐺是${k}$-可着色的。若𝐺是$k{-}$可着色的，但不是$(k-$$1)-$可着色的，则称𝐺是一个${k}$-色图，并称$k$为图𝐺的点色数或色数，记为$𝜒(𝐺)$。  
![](images/53a26dc56eb7520c616c57e24f7d17f1e7686d610feaf89b55e20658f6ec1e28.jpg)  
例如，对于图10-55（a）所示无向图，该图就是一个3-色图，其射数$\chi(G)=3$。再如，图56（a）所示完全图$K_{5}$是一个5-色图；图56（b）所示完全二分图$K_{3,4}$是一个2-色图；图56（c）所示回路$C_{6}$是一个2-色图；图56（d）所示回路$C_{5}$为一个3-色图。  
通过上述例题不难看出，对于$G$的任何子图$H$，均有$\chi(H)\leq\chi(G)$，若$G$是$n$阶完全图，则$\chi(G)=n$；若$G$是至少有一边的二分图，则$\chi(G)=2$；若$G$是长为奇数的圈，则$\chi(G)=3$。一般地，关于无向图$G$的点色数，有如下定理：  
【定理10.19】设$G=\langle V,E\rangle$是任意给定的一个无向图，则有：  
（1）$\chi(G)=1$当且仅当$G$为零图。  
（2）对于完全图$K_{n}$：$\chi(K_{n})=n$。  
（3）$G$是一条回路：则若$|V|$是偶数，$\chi(G)=2$；若$|V|$是奇数，$\chi(G)=3$（4）$G$是一棵非平凡树，则$\chi(G)=2$。  
（5）$\chi(G)=2$的充要条件是：（a）$|E|\ge1$；（b）$G$为二分图。  
（6）对于任意无向线图$G$，若其结点的最大度为$\Delta(G)$  
$$
\chi(G)\leq\Delta(G)+1
$$  
【定理10.20】（布鲁克斯定理）设$G$是一个连通简单图，其结点的最大度为$\Delta(G)$。如果$G$既不是完全图，也不是长度奇数的基本回路，则$\chi(G)\leq\Delta(G)$。  
我们知道，任意一个不是零图的无向图都是由结点和边这两个要素构成，既然可对结点进行着色，自然也可对边进行着色。由此得到如下边着色的相关定义：  
【定义10.12】设$G=\langle V,E\rangle$是任意给定的一个无向图，如果对图$G$的每条边都涂上或标注一种颜色，并满足相邻的两条边具有不同的颜色，则称这种操作是对图$G$的边着色。如果这些颜色选自于一个有$k$种颜色的集合而不管$k$种颜色是否都用到，则称这样的边作色为称为𝒌边着色，并称$G$是$\pmb{k}$-边可着色的。若$G$是$k^{-}$边可着色的，但不是$\,(k-1)$-边可着色的，则称$G$是一个$\pmb{k}$-边色图，并称$k$为图$G$的边色数，记为$\chi^{\prime}(G)$。  
关于边色数的问题, 可以说目前已得到较好的解决。乌克兰数学家维津在1964 年提出的维津定理给出一个比较满意答案，具体如下：  
【定理10.21】（维津定理）设$G=\langle V,E\rangle$是任意给定的一个无向图，则有：  
（1）若图$G$是简单图，图中结点最大度为$\Delta(G)$，则$\chi^{\prime}(G)=\Delta(G)$或$\Delta(G)+1$；  
（2）若图$G$是二分图，图中结点最大度为$\Delta(G)$，则$\chi^{\prime}(G)=\Delta(G)$；  
（3）对于完全图$K_{n}$，若$n(n\neq1)$为奇数，$\chi^{\prime}(K_{n})=n$；若$_{n}$为偶数，$\chi^{\prime}(K_{n})=n-1$",二分图的点色数为2
二分图,性质,边着色,,"首先考察一个实例，我们通常在同一台冰箱内存放不同种类的食物，其中有些食品必须分别保存在不同冰箱隔间以免串味或污染。例如，苹果和鸡蛋应该分开存放、腊肉和蔬菜应该分开存放等等。现有$A,B,C,D,E,F$六种食品，若要求$𝐴$与$𝐵$、$𝐴$与$C$、$𝐴$与$𝐷$、$B$与$C$、$C$与$D$、$C$与$F$、$D$与$E$、$E$与$F$不能放在一起，则至少需要几个隔间才能存放这些食物。  
![图10-56 冰箱中食物存放问题  ](images/557fa53c5bf02920ef35e88225888a1b53ecb35568cc495b689ec5f32f0de05e.jpg)  
可用一个无向图模型表示上述问题，图的每个结点分别代表一种食物，如果两种食物不能放在一起，则在这两种食物之间画一条无向边，如图10-55（a）所示。可通过对该图的结进行着色的方法实现对上述问题的求解。具体地说，就是对图中每个结点分别涂上或者标注一种颜色，并满足相邻的结点之间具有不同的颜色，将相同颜色结点所代表的食物放在同一个隔间，则所需要的最少颜色数目显然就是所求的冰箱隔间数目。  
不难知道，最少需要三种颜色才能实现对图10-55（a）所示无向图全部结点的着色，图10-55（b）表示其中一种着色方案。  
事实上，如果将上述六种食物分别看成是某个工程中的六项不同的任务，将不能存放在同一个隔间的两种食物理解为不能同时执行的两个任务，则可按照图10-55（b）所示的结点着色方案将这些任务以同色为标准分成3 个并行执行的任务集合。因此，无向图的着色理论与方法在并行计算与任务规划等领域具有非常重要的作用。  
对于一个比较复杂的无向图，要实现对该图所有结点的着色，在很多情况下不是一件很显然的事情。下面具体考察点着色问题，首先给出结点着色的定义，具体如下：  
【定义10.11】设$G=\langle V,E\rangle$是任意给定的一个无向图，如果对图𝐺的每个结点都涂上或标注一种颜色，并满足相邻的两个点具有不同的颜色，则称这种操作是对图$G$的结点着色，简称为对图𝐺的点着色。如果这些颜色选自于一个有𝑘种颜色的集合而不管$k$种颜色是否都用到，则称这样的点作色为称为𝒌着色，并称𝐺是${k}$-可着色的。若𝐺是$k{-}$可着色的，但不是$(k-$$1)-$可着色的，则称𝐺是一个${k}$-色图，并称$k$为图𝐺的点色数或色数，记为$𝜒(𝐺)$。  
![](images/53a26dc56eb7520c616c57e24f7d17f1e7686d610feaf89b55e20658f6ec1e28.jpg)  
例如，对于图10-55（a）所示无向图，该图就是一个3-色图，其射数$\chi(G)=3$。再如，图56（a）所示完全图$K_{5}$是一个5-色图；图56（b）所示完全二分图$K_{3,4}$是一个2-色图；图56（c）所示回路$C_{6}$是一个2-色图；图56（d）所示回路$C_{5}$为一个3-色图。  
通过上述例题不难看出，对于$G$的任何子图$H$，均有$\chi(H)\leq\chi(G)$，若$G$是$n$阶完全图，则$\chi(G)=n$；若$G$是至少有一边的二分图，则$\chi(G)=2$；若$G$是长为奇数的圈，则$\chi(G)=3$。一般地，关于无向图$G$的点色数，有如下定理：  
【定理10.19】设$G=\langle V,E\rangle$是任意给定的一个无向图，则有：  
（1）$\chi(G)=1$当且仅当$G$为零图。  
（2）对于完全图$K_{n}$：$\chi(K_{n})=n$。  
（3）$G$是一条回路：则若$|V|$是偶数，$\chi(G)=2$；若$|V|$是奇数，$\chi(G)=3$（4）$G$是一棵非平凡树，则$\chi(G)=2$。  
（5）$\chi(G)=2$的充要条件是：（a）$|E|\ge1$；（b）$G$为二分图。  
（6）对于任意无向线图$G$，若其结点的最大度为$\Delta(G)$  
$$
\chi(G)\leq\Delta(G)+1
$$  
【定理10.20】（布鲁克斯定理）设$G$是一个连通简单图，其结点的最大度为$\Delta(G)$。如果$G$既不是完全图，也不是长度奇数的基本回路，则$\chi(G)\leq\Delta(G)$。  
我们知道，任意一个不是零图的无向图都是由结点和边这两个要素构成，既然可对结点进行着色，自然也可对边进行着色。由此得到如下边着色的相关定义：  
【定义10.12】设$G=\langle V,E\rangle$是任意给定的一个无向图，如果对图$G$的每条边都涂上或标注一种颜色，并满足相邻的两条边具有不同的颜色，则称这种操作是对图$G$的边着色。如果这些颜色选自于一个有$k$种颜色的集合而不管$k$种颜色是否都用到，则称这样的边作色为称为𝒌边着色，并称$G$是$\pmb{k}$-边可着色的。若$G$是$k^{-}$边可着色的，但不是$\,(k-1)$-边可着色的，则称$G$是一个$\pmb{k}$-边色图，并称$k$为图$G$的边色数，记为$\chi^{\prime}(G)$。  
关于边色数的问题, 可以说目前已得到较好的解决。乌克兰数学家维津在1964 年提出的维津定理给出一个比较满意答案，具体如下：  
【定理10.21】（维津定理）设$G=\langle V,E\rangle$是任意给定的一个无向图，则有：  
（1）若图$G$是简单图，图中结点最大度为$\Delta(G)$，则$\chi^{\prime}(G)=\Delta(G)$或$\Delta(G)+1$；  
（2）若图$G$是二分图，图中结点最大度为$\Delta(G)$，则$\chi^{\prime}(G)=\Delta(G)$；  
（3）对于完全图$K_{n}$，若$n(n\neq1)$为奇数，$\chi^{\prime}(K_{n})=n$；若$_{n}$为偶数，$\chi^{\prime}(K_{n})=n-1$",二分图的边色数等于其结点的最大度
点着色,应用,布鲁克斯定理,,"首先考察一个实例，我们通常在同一台冰箱内存放不同种类的食物，其中有些食品必须分别保存在不同冰箱隔间以免串味或污染。例如，苹果和鸡蛋应该分开存放、腊肉和蔬菜应该分开存放等等。现有$A,B,C,D,E,F$六种食品，若要求$𝐴$与$𝐵$、$𝐴$与$C$、$𝐴$与$𝐷$、$B$与$C$、$C$与$D$、$C$与$F$、$D$与$E$、$E$与$F$不能放在一起，则至少需要几个隔间才能存放这些食物。  
![图10-56 冰箱中食物存放问题  ](images/557fa53c5bf02920ef35e88225888a1b53ecb35568cc495b689ec5f32f0de05e.jpg)  
可用一个无向图模型表示上述问题，图的每个结点分别代表一种食物，如果两种食物不能放在一起，则在这两种食物之间画一条无向边，如图10-55（a）所示。可通过对该图的结进行着色的方法实现对上述问题的求解。具体地说，就是对图中每个结点分别涂上或者标注一种颜色，并满足相邻的结点之间具有不同的颜色，将相同颜色结点所代表的食物放在同一个隔间，则所需要的最少颜色数目显然就是所求的冰箱隔间数目。  
不难知道，最少需要三种颜色才能实现对图10-55（a）所示无向图全部结点的着色，图10-55（b）表示其中一种着色方案。  
事实上，如果将上述六种食物分别看成是某个工程中的六项不同的任务，将不能存放在同一个隔间的两种食物理解为不能同时执行的两个任务，则可按照图10-55（b）所示的结点着色方案将这些任务以同色为标准分成3 个并行执行的任务集合。因此，无向图的着色理论与方法在并行计算与任务规划等领域具有非常重要的作用。  
对于一个比较复杂的无向图，要实现对该图所有结点的着色，在很多情况下不是一件很显然的事情。下面具体考察点着色问题，首先给出结点着色的定义，具体如下：  
【定义10.11】设$G=\langle V,E\rangle$是任意给定的一个无向图，如果对图𝐺的每个结点都涂上或标注一种颜色，并满足相邻的两个点具有不同的颜色，则称这种操作是对图$G$的结点着色，简称为对图𝐺的点着色。如果这些颜色选自于一个有𝑘种颜色的集合而不管$k$种颜色是否都用到，则称这样的点作色为称为𝒌着色，并称𝐺是${k}$-可着色的。若𝐺是$k{-}$可着色的，但不是$(k-$$1)-$可着色的，则称𝐺是一个${k}$-色图，并称$k$为图𝐺的点色数或色数，记为$𝜒(𝐺)$。  
![](images/53a26dc56eb7520c616c57e24f7d17f1e7686d610feaf89b55e20658f6ec1e28.jpg)  
例如，对于图10-55（a）所示无向图，该图就是一个3-色图，其射数$\chi(G)=3$。再如，图56（a）所示完全图$K_{5}$是一个5-色图；图56（b）所示完全二分图$K_{3,4}$是一个2-色图；图56（c）所示回路$C_{6}$是一个2-色图；图56（d）所示回路$C_{5}$为一个3-色图。  
通过上述例题不难看出，对于$G$的任何子图$H$，均有$\chi(H)\leq\chi(G)$，若$G$是$n$阶完全图，则$\chi(G)=n$；若$G$是至少有一边的二分图，则$\chi(G)=2$；若$G$是长为奇数的圈，则$\chi(G)=3$。一般地，关于无向图$G$的点色数，有如下定理：  
【定理10.19】设$G=\langle V,E\rangle$是任意给定的一个无向图，则有：  
（1）$\chi(G)=1$当且仅当$G$为零图。  
（2）对于完全图$K_{n}$：$\chi(K_{n})=n$。  
（3）$G$是一条回路：则若$|V|$是偶数，$\chi(G)=2$；若$|V|$是奇数，$\chi(G)=3$（4）$G$是一棵非平凡树，则$\chi(G)=2$。  
（5）$\chi(G)=2$的充要条件是：（a）$|E|\ge1$；（b）$G$为二分图。  
（6）对于任意无向线图$G$，若其结点的最大度为$\Delta(G)$  
$$
\chi(G)\leq\Delta(G)+1
$$  
【定理10.20】（布鲁克斯定理）设$G$是一个连通简单图，其结点的最大度为$\Delta(G)$。如果$G$既不是完全图，也不是长度奇数的基本回路，则$\chi(G)\leq\Delta(G)$。  
我们知道，任意一个不是零图的无向图都是由结点和边这两个要素构成，既然可对结点进行着色，自然也可对边进行着色。由此得到如下边着色的相关定义：  
【定义10.12】设$G=\langle V,E\rangle$是任意给定的一个无向图，如果对图$G$的每条边都涂上或标注一种颜色，并满足相邻的两条边具有不同的颜色，则称这种操作是对图$G$的边着色。如果这些颜色选自于一个有$k$种颜色的集合而不管$k$种颜色是否都用到，则称这样的边作色为称为𝒌边着色，并称$G$是$\pmb{k}$-边可着色的。若$G$是$k^{-}$边可着色的，但不是$\,(k-1)$-边可着色的，则称$G$是一个$\pmb{k}$-边色图，并称$k$为图$G$的边色数，记为$\chi^{\prime}(G)$。  
关于边色数的问题, 可以说目前已得到较好的解决。乌克兰数学家维津在1964 年提出的维津定理给出一个比较满意答案，具体如下：  
【定理10.21】（维津定理）设$G=\langle V,E\rangle$是任意给定的一个无向图，则有：  
（1）若图$G$是简单图，图中结点最大度为$\Delta(G)$，则$\chi^{\prime}(G)=\Delta(G)$或$\Delta(G)+1$；  
（2）若图$G$是二分图，图中结点最大度为$\Delta(G)$，则$\chi^{\prime}(G)=\Delta(G)$；  
（3）对于完全图$K_{n}$，若$n(n\neq1)$为奇数，$\chi^{\prime}(K_{n})=n$；若$_{n}$为偶数，$\chi^{\prime}(K_{n})=n-1$",布鲁克斯定理用于确定非完全图和非奇数长度回路的点色数上限
边着色,应用,维津定理,,"首先考察一个实例，我们通常在同一台冰箱内存放不同种类的食物，其中有些食品必须分别保存在不同冰箱隔间以免串味或污染。例如，苹果和鸡蛋应该分开存放、腊肉和蔬菜应该分开存放等等。现有$A,B,C,D,E,F$六种食品，若要求$𝐴$与$𝐵$、$𝐴$与$C$、$𝐴$与$𝐷$、$B$与$C$、$C$与$D$、$C$与$F$、$D$与$E$、$E$与$F$不能放在一起，则至少需要几个隔间才能存放这些食物。  
![图10-56 冰箱中食物存放问题  ](images/557fa53c5bf02920ef35e88225888a1b53ecb35568cc495b689ec5f32f0de05e.jpg)  
可用一个无向图模型表示上述问题，图的每个结点分别代表一种食物，如果两种食物不能放在一起，则在这两种食物之间画一条无向边，如图10-55（a）所示。可通过对该图的结进行着色的方法实现对上述问题的求解。具体地说，就是对图中每个结点分别涂上或者标注一种颜色，并满足相邻的结点之间具有不同的颜色，将相同颜色结点所代表的食物放在同一个隔间，则所需要的最少颜色数目显然就是所求的冰箱隔间数目。  
不难知道，最少需要三种颜色才能实现对图10-55（a）所示无向图全部结点的着色，图10-55（b）表示其中一种着色方案。  
事实上，如果将上述六种食物分别看成是某个工程中的六项不同的任务，将不能存放在同一个隔间的两种食物理解为不能同时执行的两个任务，则可按照图10-55（b）所示的结点着色方案将这些任务以同色为标准分成3 个并行执行的任务集合。因此，无向图的着色理论与方法在并行计算与任务规划等领域具有非常重要的作用。  
对于一个比较复杂的无向图，要实现对该图所有结点的着色，在很多情况下不是一件很显然的事情。下面具体考察点着色问题，首先给出结点着色的定义，具体如下：  
【定义10.11】设$G=\langle V,E\rangle$是任意给定的一个无向图，如果对图𝐺的每个结点都涂上或标注一种颜色，并满足相邻的两个点具有不同的颜色，则称这种操作是对图$G$的结点着色，简称为对图𝐺的点着色。如果这些颜色选自于一个有𝑘种颜色的集合而不管$k$种颜色是否都用到，则称这样的点作色为称为𝒌着色，并称𝐺是${k}$-可着色的。若𝐺是$k{-}$可着色的，但不是$(k-$$1)-$可着色的，则称𝐺是一个${k}$-色图，并称$k$为图𝐺的点色数或色数，记为$𝜒(𝐺)$。  
![](images/53a26dc56eb7520c616c57e24f7d17f1e7686d610feaf89b55e20658f6ec1e28.jpg)  
例如，对于图10-55（a）所示无向图，该图就是一个3-色图，其射数$\chi(G)=3$。再如，图56（a）所示完全图$K_{5}$是一个5-色图；图56（b）所示完全二分图$K_{3,4}$是一个2-色图；图56（c）所示回路$C_{6}$是一个2-色图；图56（d）所示回路$C_{5}$为一个3-色图。  
通过上述例题不难看出，对于$G$的任何子图$H$，均有$\chi(H)\leq\chi(G)$，若$G$是$n$阶完全图，则$\chi(G)=n$；若$G$是至少有一边的二分图，则$\chi(G)=2$；若$G$是长为奇数的圈，则$\chi(G)=3$。一般地，关于无向图$G$的点色数，有如下定理：  
【定理10.19】设$G=\langle V,E\rangle$是任意给定的一个无向图，则有：  
（1）$\chi(G)=1$当且仅当$G$为零图。  
（2）对于完全图$K_{n}$：$\chi(K_{n})=n$。  
（3）$G$是一条回路：则若$|V|$是偶数，$\chi(G)=2$；若$|V|$是奇数，$\chi(G)=3$（4）$G$是一棵非平凡树，则$\chi(G)=2$。  
（5）$\chi(G)=2$的充要条件是：（a）$|E|\ge1$；（b）$G$为二分图。  
（6）对于任意无向线图$G$，若其结点的最大度为$\Delta(G)$  
$$
\chi(G)\leq\Delta(G)+1
$$  
【定理10.20】（布鲁克斯定理）设$G$是一个连通简单图，其结点的最大度为$\Delta(G)$。如果$G$既不是完全图，也不是长度奇数的基本回路，则$\chi(G)\leq\Delta(G)$。  
我们知道，任意一个不是零图的无向图都是由结点和边这两个要素构成，既然可对结点进行着色，自然也可对边进行着色。由此得到如下边着色的相关定义：  
【定义10.12】设$G=\langle V,E\rangle$是任意给定的一个无向图，如果对图$G$的每条边都涂上或标注一种颜色，并满足相邻的两条边具有不同的颜色，则称这种操作是对图$G$的边着色。如果这些颜色选自于一个有$k$种颜色的集合而不管$k$种颜色是否都用到，则称这样的边作色为称为𝒌边着色，并称$G$是$\pmb{k}$-边可着色的。若$G$是$k^{-}$边可着色的，但不是$\,(k-1)$-边可着色的，则称$G$是一个$\pmb{k}$-边色图，并称$k$为图$G$的边色数，记为$\chi^{\prime}(G)$。  
关于边色数的问题, 可以说目前已得到较好的解决。乌克兰数学家维津在1964 年提出的维津定理给出一个比较满意答案，具体如下：  
【定理10.21】（维津定理）设$G=\langle V,E\rangle$是任意给定的一个无向图，则有：  
（1）若图$G$是简单图，图中结点最大度为$\Delta(G)$，则$\chi^{\prime}(G)=\Delta(G)$或$\Delta(G)+1$；  
（2）若图$G$是二分图，图中结点最大度为$\Delta(G)$，则$\chi^{\prime}(G)=\Delta(G)$；  
（3）对于完全图$K_{n}$，若$n(n\neq1)$为奇数，$\chi^{\prime}(K_{n})=n$；若$_{n}$为偶数，$\chi^{\prime}(K_{n})=n-1$",维津定理用于确定图的边色数
着色问题,包含,点着色,,"首先考察一个实例，我们通常在同一台冰箱内存放不同种类的食物，其中有些食品必须分别保存在不同冰箱隔间以免串味或污染。例如，苹果和鸡蛋应该分开存放、腊肉和蔬菜应该分开存放等等。现有$A,B,C,D,E,F$六种食品，若要求$𝐴$与$𝐵$、$𝐴$与$C$、$𝐴$与$𝐷$、$B$与$C$、$C$与$D$、$C$与$F$、$D$与$E$、$E$与$F$不能放在一起，则至少需要几个隔间才能存放这些食物。  
![图10-56 冰箱中食物存放问题  ](images/557fa53c5bf02920ef35e88225888a1b53ecb35568cc495b689ec5f32f0de05e.jpg)  
可用一个无向图模型表示上述问题，图的每个结点分别代表一种食物，如果两种食物不能放在一起，则在这两种食物之间画一条无向边，如图10-55（a）所示。可通过对该图的结进行着色的方法实现对上述问题的求解。具体地说，就是对图中每个结点分别涂上或者标注一种颜色，并满足相邻的结点之间具有不同的颜色，将相同颜色结点所代表的食物放在同一个隔间，则所需要的最少颜色数目显然就是所求的冰箱隔间数目。  
不难知道，最少需要三种颜色才能实现对图10-55（a）所示无向图全部结点的着色，图10-55（b）表示其中一种着色方案。  
事实上，如果将上述六种食物分别看成是某个工程中的六项不同的任务，将不能存放在同一个隔间的两种食物理解为不能同时执行的两个任务，则可按照图10-55（b）所示的结点着色方案将这些任务以同色为标准分成3 个并行执行的任务集合。因此，无向图的着色理论与方法在并行计算与任务规划等领域具有非常重要的作用。  
对于一个比较复杂的无向图，要实现对该图所有结点的着色，在很多情况下不是一件很显然的事情。下面具体考察点着色问题，首先给出结点着色的定义，具体如下：  
【定义10.11】设$G=\langle V,E\rangle$是任意给定的一个无向图，如果对图𝐺的每个结点都涂上或标注一种颜色，并满足相邻的两个点具有不同的颜色，则称这种操作是对图$G$的结点着色，简称为对图𝐺的点着色。如果这些颜色选自于一个有𝑘种颜色的集合而不管$k$种颜色是否都用到，则称这样的点作色为称为𝒌着色，并称𝐺是${k}$-可着色的。若𝐺是$k{-}$可着色的，但不是$(k-$$1)-$可着色的，则称𝐺是一个${k}$-色图，并称$k$为图𝐺的点色数或色数，记为$𝜒(𝐺)$。  
![](images/53a26dc56eb7520c616c57e24f7d17f1e7686d610feaf89b55e20658f6ec1e28.jpg)  
例如，对于图10-55（a）所示无向图，该图就是一个3-色图，其射数$\chi(G)=3$。再如，图56（a）所示完全图$K_{5}$是一个5-色图；图56（b）所示完全二分图$K_{3,4}$是一个2-色图；图56（c）所示回路$C_{6}$是一个2-色图；图56（d）所示回路$C_{5}$为一个3-色图。  
通过上述例题不难看出，对于$G$的任何子图$H$，均有$\chi(H)\leq\chi(G)$，若$G$是$n$阶完全图，则$\chi(G)=n$；若$G$是至少有一边的二分图，则$\chi(G)=2$；若$G$是长为奇数的圈，则$\chi(G)=3$。一般地，关于无向图$G$的点色数，有如下定理：  
【定理10.19】设$G=\langle V,E\rangle$是任意给定的一个无向图，则有：  
（1）$\chi(G)=1$当且仅当$G$为零图。  
（2）对于完全图$K_{n}$：$\chi(K_{n})=n$。  
（3）$G$是一条回路：则若$|V|$是偶数，$\chi(G)=2$；若$|V|$是奇数，$\chi(G)=3$（4）$G$是一棵非平凡树，则$\chi(G)=2$。  
（5）$\chi(G)=2$的充要条件是：（a）$|E|\ge1$；（b）$G$为二分图。  
（6）对于任意无向线图$G$，若其结点的最大度为$\Delta(G)$  
$$
\chi(G)\leq\Delta(G)+1
$$  
【定理10.20】（布鲁克斯定理）设$G$是一个连通简单图，其结点的最大度为$\Delta(G)$。如果$G$既不是完全图，也不是长度奇数的基本回路，则$\chi(G)\leq\Delta(G)$。  
我们知道，任意一个不是零图的无向图都是由结点和边这两个要素构成，既然可对结点进行着色，自然也可对边进行着色。由此得到如下边着色的相关定义：  
【定义10.12】设$G=\langle V,E\rangle$是任意给定的一个无向图，如果对图$G$的每条边都涂上或标注一种颜色，并满足相邻的两条边具有不同的颜色，则称这种操作是对图$G$的边着色。如果这些颜色选自于一个有$k$种颜色的集合而不管$k$种颜色是否都用到，则称这样的边作色为称为𝒌边着色，并称$G$是$\pmb{k}$-边可着色的。若$G$是$k^{-}$边可着色的，但不是$\,(k-1)$-边可着色的，则称$G$是一个$\pmb{k}$-边色图，并称$k$为图$G$的边色数，记为$\chi^{\prime}(G)$。  
关于边色数的问题, 可以说目前已得到较好的解决。乌克兰数学家维津在1964 年提出的维津定理给出一个比较满意答案，具体如下：  
【定理10.21】（维津定理）设$G=\langle V,E\rangle$是任意给定的一个无向图，则有：  
（1）若图$G$是简单图，图中结点最大度为$\Delta(G)$，则$\chi^{\prime}(G)=\Delta(G)$或$\Delta(G)+1$；  
（2）若图$G$是二分图，图中结点最大度为$\Delta(G)$，则$\chi^{\prime}(G)=\Delta(G)$；  
（3）对于完全图$K_{n}$，若$n(n\neq1)$为奇数，$\chi^{\prime}(K_{n})=n$；若$_{n}$为偶数，$\chi^{\prime}(K_{n})=n-1$",点着色是着色问题的一种类型
着色问题,包含,边着色,,"首先考察一个实例，我们通常在同一台冰箱内存放不同种类的食物，其中有些食品必须分别保存在不同冰箱隔间以免串味或污染。例如，苹果和鸡蛋应该分开存放、腊肉和蔬菜应该分开存放等等。现有$A,B,C,D,E,F$六种食品，若要求$𝐴$与$𝐵$、$𝐴$与$C$、$𝐴$与$𝐷$、$B$与$C$、$C$与$D$、$C$与$F$、$D$与$E$、$E$与$F$不能放在一起，则至少需要几个隔间才能存放这些食物。  
![图10-56 冰箱中食物存放问题  ](images/557fa53c5bf02920ef35e88225888a1b53ecb35568cc495b689ec5f32f0de05e.jpg)  
可用一个无向图模型表示上述问题，图的每个结点分别代表一种食物，如果两种食物不能放在一起，则在这两种食物之间画一条无向边，如图10-55（a）所示。可通过对该图的结进行着色的方法实现对上述问题的求解。具体地说，就是对图中每个结点分别涂上或者标注一种颜色，并满足相邻的结点之间具有不同的颜色，将相同颜色结点所代表的食物放在同一个隔间，则所需要的最少颜色数目显然就是所求的冰箱隔间数目。  
不难知道，最少需要三种颜色才能实现对图10-55（a）所示无向图全部结点的着色，图10-55（b）表示其中一种着色方案。  
事实上，如果将上述六种食物分别看成是某个工程中的六项不同的任务，将不能存放在同一个隔间的两种食物理解为不能同时执行的两个任务，则可按照图10-55（b）所示的结点着色方案将这些任务以同色为标准分成3 个并行执行的任务集合。因此，无向图的着色理论与方法在并行计算与任务规划等领域具有非常重要的作用。  
对于一个比较复杂的无向图，要实现对该图所有结点的着色，在很多情况下不是一件很显然的事情。下面具体考察点着色问题，首先给出结点着色的定义，具体如下：  
【定义10.11】设$G=\langle V,E\rangle$是任意给定的一个无向图，如果对图𝐺的每个结点都涂上或标注一种颜色，并满足相邻的两个点具有不同的颜色，则称这种操作是对图$G$的结点着色，简称为对图𝐺的点着色。如果这些颜色选自于一个有𝑘种颜色的集合而不管$k$种颜色是否都用到，则称这样的点作色为称为𝒌着色，并称𝐺是${k}$-可着色的。若𝐺是$k{-}$可着色的，但不是$(k-$$1)-$可着色的，则称𝐺是一个${k}$-色图，并称$k$为图𝐺的点色数或色数，记为$𝜒(𝐺)$。  
![](images/53a26dc56eb7520c616c57e24f7d17f1e7686d610feaf89b55e20658f6ec1e28.jpg)  
例如，对于图10-55（a）所示无向图，该图就是一个3-色图，其射数$\chi(G)=3$。再如，图56（a）所示完全图$K_{5}$是一个5-色图；图56（b）所示完全二分图$K_{3,4}$是一个2-色图；图56（c）所示回路$C_{6}$是一个2-色图；图56（d）所示回路$C_{5}$为一个3-色图。  
通过上述例题不难看出，对于$G$的任何子图$H$，均有$\chi(H)\leq\chi(G)$，若$G$是$n$阶完全图，则$\chi(G)=n$；若$G$是至少有一边的二分图，则$\chi(G)=2$；若$G$是长为奇数的圈，则$\chi(G)=3$。一般地，关于无向图$G$的点色数，有如下定理：  
【定理10.19】设$G=\langle V,E\rangle$是任意给定的一个无向图，则有：  
（1）$\chi(G)=1$当且仅当$G$为零图。  
（2）对于完全图$K_{n}$：$\chi(K_{n})=n$。  
（3）$G$是一条回路：则若$|V|$是偶数，$\chi(G)=2$；若$|V|$是奇数，$\chi(G)=3$（4）$G$是一棵非平凡树，则$\chi(G)=2$。  
（5）$\chi(G)=2$的充要条件是：（a）$|E|\ge1$；（b）$G$为二分图。  
（6）对于任意无向线图$G$，若其结点的最大度为$\Delta(G)$  
$$
\chi(G)\leq\Delta(G)+1
$$  
【定理10.20】（布鲁克斯定理）设$G$是一个连通简单图，其结点的最大度为$\Delta(G)$。如果$G$既不是完全图，也不是长度奇数的基本回路，则$\chi(G)\leq\Delta(G)$。  
我们知道，任意一个不是零图的无向图都是由结点和边这两个要素构成，既然可对结点进行着色，自然也可对边进行着色。由此得到如下边着色的相关定义：  
【定义10.12】设$G=\langle V,E\rangle$是任意给定的一个无向图，如果对图$G$的每条边都涂上或标注一种颜色，并满足相邻的两条边具有不同的颜色，则称这种操作是对图$G$的边着色。如果这些颜色选自于一个有$k$种颜色的集合而不管$k$种颜色是否都用到，则称这样的边作色为称为𝒌边着色，并称$G$是$\pmb{k}$-边可着色的。若$G$是$k^{-}$边可着色的，但不是$\,(k-1)$-边可着色的，则称$G$是一个$\pmb{k}$-边色图，并称$k$为图$G$的边色数，记为$\chi^{\prime}(G)$。  
关于边色数的问题, 可以说目前已得到较好的解决。乌克兰数学家维津在1964 年提出的维津定理给出一个比较满意答案，具体如下：  
【定理10.21】（维津定理）设$G=\langle V,E\rangle$是任意给定的一个无向图，则有：  
（1）若图$G$是简单图，图中结点最大度为$\Delta(G)$，则$\chi^{\prime}(G)=\Delta(G)$或$\Delta(G)+1$；  
（2）若图$G$是二分图，图中结点最大度为$\Delta(G)$，则$\chi^{\prime}(G)=\Delta(G)$；  
（3）对于完全图$K_{n}$，若$n(n\neq1)$为奇数，$\chi^{\prime}(K_{n})=n$；若$_{n}$为偶数，$\chi^{\prime}(K_{n})=n-1$",边着色是着色问题的一种类型
着色问题,转化,平面图,,"如前所述，图的着色问题起源于对地图中每个国家领土的着色问题。例如，对于如图$10-$62 所示的地图，显然可以用4 种颜色对该地图中每个国家的领土进行标定。不难看出，该地图其实是一种连通无桥平面图，每个国家的领土范围对应于该平面图的一个面。因此，对地图中每个国家领土的着色问题，可转化为对这种特殊平面图中面的着色问题。  
![10-62 平面图的着色问题  ](images/0f1d899dc5071bbbd74c74607374e17794ff18cb387057f7c4c58b59ecbd991c.jpg)  
下面考察基于这种特殊平面图的面着色问题，首先给出面着色的相关定义：  
【定义10.13】连通无桥平面图及其所有有限面称为地图。地图中每有限面分别称为一个国家，若两个国家至少有一条公共边，则称这两个国家相邻。如果对给定地图$G$上每个国家涂上或标注一种颜色，使得相邻的国家具有不同的颜色，则称这种操作是对图$G$的面着色。若可用$k$种颜色就可完成对地图$G$的面着色，则称$G$是$k{-}$面可着色的。若$G$是$k{-}$面可着色的，但不是$(k-1){-}$面可着色的，则称$G$是${k}$-色地图，称$ k$为$G$的面色数，记为$\chi^{*}(G)$。  
事实上，对地图的面着色可以通过平面图的结点着色来研究。这是因为平面图$G$的对偶图$G^{*}$也是一个平面图，并且图$G$的每个面与图$G^{*}$的每个结点之间具有一一对应的关系。例如，对10-62（a）所示的面着色问题，可以转化为10-62（b）所示的结点着色问题。下面的定理10.22 揭示了作为地图的一种特殊平面图与其对偶图之间的色数关系：  
【定理10.22】地图$G$是$k^{-}$面可着色图，当且仅当它的对偶图$G^{*}$是$k^{-}$可着色图。  
【定理10.23】设$G=\langle V,E\rangle$是简单平面图，则$G$中至少存在一个度数不超过5 的结点。  
下面给出关于平面图结点着色的五色定理：  
【定理10.24】（五色定理）设$G=\langle V,E\rangle$是任意给定的一个连通简单平面图，则$G$的点色数为5。  
上述五色定理是数学家赫伍德在研究四色猜想时给出的一个重要结论，可以说是四色猜想研究历史上的一个重大突破。四色猜想是一个与哥德巴赫猜想、黎曼猜想同样著名的数学猜想。该猜想最初由英国青年佛朗西斯·格里斯在1852 年提出：  
四色猜想：连通简单平面图的色数不超过4。  
公元1852 年，毕业于英国伦敦大学并从事地图着色工作的佛朗西斯·格里斯，发现了一个奇怪的现象：无论多么复杂的地图，只要用四种颜色，就可以区分有公共边界的国家和地区。佛朗西斯觉得这中间一定有什么奥妙，便求教著名的英国数学家摩根。摩根对此苦苦思索了几个昼夜后还是不得其解，便写信给著名数学家哈密顿，希望哈密尔顿要么能证明这个问题，要么构造出一个需要五种或更多种颜色的图来。然而，智慧超人的哈密尔顿耗费了整整13 年心血，终于一筹莫展，抱恨逝去！  
哈密尔顿死后，又过了13 年，英国数学家凯莱在一次数学年会上把这个问题归纳为四色猜想，并于公元1879 年在英国皇家地理会刊的创刊号上，公开征求对四色猜想的解答。在征解消息发出的同年，一位半路出家的数学家肯普，发表了一个关于四色定理的证明。人们普遍以为四色猜想已经成为历史。不料过了11 年，即公元1890 年，一个名叫赫伍德的青年，指出了肯普在证明中的错误。与此同时，赫伍德匠心独运，利用肯普提供的方法，成功地证明了上述五色定理。由于存在不可3-着色的平面图$K_{4}$，故四色定理若得到证明，将是平面图色数问题的最佳结果。  
1976 年6 月，美国两位著名数学家阿佩尔和海肯通过计算机计算了1200 小时，通过数组计算的方法验证了四色猜想的正确性。据此，人们将四色猜想改名为四色定理。但是，四色定理并没有得到所以数学家的认可，因为目前还没理论上严谨的数学证明。",地图中每个国家领土的着色问题可转化为对特殊平面图中面的着色问题
平面图,对应,面着色,,"如前所述，图的着色问题起源于对地图中每个国家领土的着色问题。例如，对于如图$10-$62 所示的地图，显然可以用4 种颜色对该地图中每个国家的领土进行标定。不难看出，该地图其实是一种连通无桥平面图，每个国家的领土范围对应于该平面图的一个面。因此，对地图中每个国家领土的着色问题，可转化为对这种特殊平面图中面的着色问题。  
![10-62 平面图的着色问题  ](images/0f1d899dc5071bbbd74c74607374e17794ff18cb387057f7c4c58b59ecbd991c.jpg)  
下面考察基于这种特殊平面图的面着色问题，首先给出面着色的相关定义：  
【定义10.13】连通无桥平面图及其所有有限面称为地图。地图中每有限面分别称为一个国家，若两个国家至少有一条公共边，则称这两个国家相邻。如果对给定地图$G$上每个国家涂上或标注一种颜色，使得相邻的国家具有不同的颜色，则称这种操作是对图$G$的面着色。若可用$k$种颜色就可完成对地图$G$的面着色，则称$G$是$k{-}$面可着色的。若$G$是$k{-}$面可着色的，但不是$(k-1){-}$面可着色的，则称$G$是${k}$-色地图，称$ k$为$G$的面色数，记为$\chi^{*}(G)$。  
事实上，对地图的面着色可以通过平面图的结点着色来研究。这是因为平面图$G$的对偶图$G^{*}$也是一个平面图，并且图$G$的每个面与图$G^{*}$的每个结点之间具有一一对应的关系。例如，对10-62（a）所示的面着色问题，可以转化为10-62（b）所示的结点着色问题。下面的定理10.22 揭示了作为地图的一种特殊平面图与其对偶图之间的色数关系：  
【定理10.22】地图$G$是$k^{-}$面可着色图，当且仅当它的对偶图$G^{*}$是$k^{-}$可着色图。  
【定理10.23】设$G=\langle V,E\rangle$是简单平面图，则$G$中至少存在一个度数不超过5 的结点。  
下面给出关于平面图结点着色的五色定理：  
【定理10.24】（五色定理）设$G=\langle V,E\rangle$是任意给定的一个连通简单平面图，则$G$的点色数为5。  
上述五色定理是数学家赫伍德在研究四色猜想时给出的一个重要结论，可以说是四色猜想研究历史上的一个重大突破。四色猜想是一个与哥德巴赫猜想、黎曼猜想同样著名的数学猜想。该猜想最初由英国青年佛朗西斯·格里斯在1852 年提出：  
四色猜想：连通简单平面图的色数不超过4。  
公元1852 年，毕业于英国伦敦大学并从事地图着色工作的佛朗西斯·格里斯，发现了一个奇怪的现象：无论多么复杂的地图，只要用四种颜色，就可以区分有公共边界的国家和地区。佛朗西斯觉得这中间一定有什么奥妙，便求教著名的英国数学家摩根。摩根对此苦苦思索了几个昼夜后还是不得其解，便写信给著名数学家哈密顿，希望哈密尔顿要么能证明这个问题，要么构造出一个需要五种或更多种颜色的图来。然而，智慧超人的哈密尔顿耗费了整整13 年心血，终于一筹莫展，抱恨逝去！  
哈密尔顿死后，又过了13 年，英国数学家凯莱在一次数学年会上把这个问题归纳为四色猜想，并于公元1879 年在英国皇家地理会刊的创刊号上，公开征求对四色猜想的解答。在征解消息发出的同年，一位半路出家的数学家肯普，发表了一个关于四色定理的证明。人们普遍以为四色猜想已经成为历史。不料过了11 年，即公元1890 年，一个名叫赫伍德的青年，指出了肯普在证明中的错误。与此同时，赫伍德匠心独运，利用肯普提供的方法，成功地证明了上述五色定理。由于存在不可3-着色的平面图$K_{4}$，故四色定理若得到证明，将是平面图色数问题的最佳结果。  
1976 年6 月，美国两位著名数学家阿佩尔和海肯通过计算机计算了1200 小时，通过数组计算的方法验证了四色猜想的正确性。据此，人们将四色猜想改名为四色定理。但是，四色定理并没有得到所以数学家的认可，因为目前还没理论上严谨的数学证明。",平面图的每个面与对偶图的每个结点之间具有一一对应的关系，面着色问题可转化为结点着色问题
平面图,对应,对偶图,,"如前所述，图的着色问题起源于对地图中每个国家领土的着色问题。例如，对于如图$10-$62 所示的地图，显然可以用4 种颜色对该地图中每个国家的领土进行标定。不难看出，该地图其实是一种连通无桥平面图，每个国家的领土范围对应于该平面图的一个面。因此，对地图中每个国家领土的着色问题，可转化为对这种特殊平面图中面的着色问题。  
![10-62 平面图的着色问题  ](images/0f1d899dc5071bbbd74c74607374e17794ff18cb387057f7c4c58b59ecbd991c.jpg)  
下面考察基于这种特殊平面图的面着色问题，首先给出面着色的相关定义：  
【定义10.13】连通无桥平面图及其所有有限面称为地图。地图中每有限面分别称为一个国家，若两个国家至少有一条公共边，则称这两个国家相邻。如果对给定地图$G$上每个国家涂上或标注一种颜色，使得相邻的国家具有不同的颜色，则称这种操作是对图$G$的面着色。若可用$k$种颜色就可完成对地图$G$的面着色，则称$G$是$k{-}$面可着色的。若$G$是$k{-}$面可着色的，但不是$(k-1){-}$面可着色的，则称$G$是${k}$-色地图，称$ k$为$G$的面色数，记为$\chi^{*}(G)$。  
事实上，对地图的面着色可以通过平面图的结点着色来研究。这是因为平面图$G$的对偶图$G^{*}$也是一个平面图，并且图$G$的每个面与图$G^{*}$的每个结点之间具有一一对应的关系。例如，对10-62（a）所示的面着色问题，可以转化为10-62（b）所示的结点着色问题。下面的定理10.22 揭示了作为地图的一种特殊平面图与其对偶图之间的色数关系：  
【定理10.22】地图$G$是$k^{-}$面可着色图，当且仅当它的对偶图$G^{*}$是$k^{-}$可着色图。  
【定理10.23】设$G=\langle V,E\rangle$是简单平面图，则$G$中至少存在一个度数不超过5 的结点。  
下面给出关于平面图结点着色的五色定理：  
【定理10.24】（五色定理）设$G=\langle V,E\rangle$是任意给定的一个连通简单平面图，则$G$的点色数为5。  
上述五色定理是数学家赫伍德在研究四色猜想时给出的一个重要结论，可以说是四色猜想研究历史上的一个重大突破。四色猜想是一个与哥德巴赫猜想、黎曼猜想同样著名的数学猜想。该猜想最初由英国青年佛朗西斯·格里斯在1852 年提出：  
四色猜想：连通简单平面图的色数不超过4。  
公元1852 年，毕业于英国伦敦大学并从事地图着色工作的佛朗西斯·格里斯，发现了一个奇怪的现象：无论多么复杂的地图，只要用四种颜色，就可以区分有公共边界的国家和地区。佛朗西斯觉得这中间一定有什么奥妙，便求教著名的英国数学家摩根。摩根对此苦苦思索了几个昼夜后还是不得其解，便写信给著名数学家哈密顿，希望哈密尔顿要么能证明这个问题，要么构造出一个需要五种或更多种颜色的图来。然而，智慧超人的哈密尔顿耗费了整整13 年心血，终于一筹莫展，抱恨逝去！  
哈密尔顿死后，又过了13 年，英国数学家凯莱在一次数学年会上把这个问题归纳为四色猜想，并于公元1879 年在英国皇家地理会刊的创刊号上，公开征求对四色猜想的解答。在征解消息发出的同年，一位半路出家的数学家肯普，发表了一个关于四色定理的证明。人们普遍以为四色猜想已经成为历史。不料过了11 年，即公元1890 年，一个名叫赫伍德的青年，指出了肯普在证明中的错误。与此同时，赫伍德匠心独运，利用肯普提供的方法，成功地证明了上述五色定理。由于存在不可3-着色的平面图$K_{4}$，故四色定理若得到证明，将是平面图色数问题的最佳结果。  
1976 年6 月，美国两位著名数学家阿佩尔和海肯通过计算机计算了1200 小时，通过数组计算的方法验证了四色猜想的正确性。据此，人们将四色猜想改名为四色定理。但是，四色定理并没有得到所以数学家的认可，因为目前还没理论上严谨的数学证明。",平面图的对偶图也是一个平面图，且两者之间具有一一对应的关系
五色定理,基础,四色猜想,,"如前所述，图的着色问题起源于对地图中每个国家领土的着色问题。例如，对于如图$10-$62 所示的地图，显然可以用4 种颜色对该地图中每个国家的领土进行标定。不难看出，该地图其实是一种连通无桥平面图，每个国家的领土范围对应于该平面图的一个面。因此，对地图中每个国家领土的着色问题，可转化为对这种特殊平面图中面的着色问题。  
![10-62 平面图的着色问题  ](images/0f1d899dc5071bbbd74c74607374e17794ff18cb387057f7c4c58b59ecbd991c.jpg)  
下面考察基于这种特殊平面图的面着色问题，首先给出面着色的相关定义：  
【定义10.13】连通无桥平面图及其所有有限面称为地图。地图中每有限面分别称为一个国家，若两个国家至少有一条公共边，则称这两个国家相邻。如果对给定地图$G$上每个国家涂上或标注一种颜色，使得相邻的国家具有不同的颜色，则称这种操作是对图$G$的面着色。若可用$k$种颜色就可完成对地图$G$的面着色，则称$G$是$k{-}$面可着色的。若$G$是$k{-}$面可着色的，但不是$(k-1){-}$面可着色的，则称$G$是${k}$-色地图，称$ k$为$G$的面色数，记为$\chi^{*}(G)$。  
事实上，对地图的面着色可以通过平面图的结点着色来研究。这是因为平面图$G$的对偶图$G^{*}$也是一个平面图，并且图$G$的每个面与图$G^{*}$的每个结点之间具有一一对应的关系。例如，对10-62（a）所示的面着色问题，可以转化为10-62（b）所示的结点着色问题。下面的定理10.22 揭示了作为地图的一种特殊平面图与其对偶图之间的色数关系：  
【定理10.22】地图$G$是$k^{-}$面可着色图，当且仅当它的对偶图$G^{*}$是$k^{-}$可着色图。  
【定理10.23】设$G=\langle V,E\rangle$是简单平面图，则$G$中至少存在一个度数不超过5 的结点。  
下面给出关于平面图结点着色的五色定理：  
【定理10.24】（五色定理）设$G=\langle V,E\rangle$是任意给定的一个连通简单平面图，则$G$的点色数为5。  
上述五色定理是数学家赫伍德在研究四色猜想时给出的一个重要结论，可以说是四色猜想研究历史上的一个重大突破。四色猜想是一个与哥德巴赫猜想、黎曼猜想同样著名的数学猜想。该猜想最初由英国青年佛朗西斯·格里斯在1852 年提出：  
四色猜想：连通简单平面图的色数不超过4。  
公元1852 年，毕业于英国伦敦大学并从事地图着色工作的佛朗西斯·格里斯，发现了一个奇怪的现象：无论多么复杂的地图，只要用四种颜色，就可以区分有公共边界的国家和地区。佛朗西斯觉得这中间一定有什么奥妙，便求教著名的英国数学家摩根。摩根对此苦苦思索了几个昼夜后还是不得其解，便写信给著名数学家哈密顿，希望哈密尔顿要么能证明这个问题，要么构造出一个需要五种或更多种颜色的图来。然而，智慧超人的哈密尔顿耗费了整整13 年心血，终于一筹莫展，抱恨逝去！  
哈密尔顿死后，又过了13 年，英国数学家凯莱在一次数学年会上把这个问题归纳为四色猜想，并于公元1879 年在英国皇家地理会刊的创刊号上，公开征求对四色猜想的解答。在征解消息发出的同年，一位半路出家的数学家肯普，发表了一个关于四色定理的证明。人们普遍以为四色猜想已经成为历史。不料过了11 年，即公元1890 年，一个名叫赫伍德的青年，指出了肯普在证明中的错误。与此同时，赫伍德匠心独运，利用肯普提供的方法，成功地证明了上述五色定理。由于存在不可3-着色的平面图$K_{4}$，故四色定理若得到证明，将是平面图色数问题的最佳结果。  
1976 年6 月，美国两位著名数学家阿佩尔和海肯通过计算机计算了1200 小时，通过数组计算的方法验证了四色猜想的正确性。据此，人们将四色猜想改名为四色定理。但是，四色定理并没有得到所以数学家的认可，因为目前还没理论上严谨的数学证明。",五色定理是研究四色猜想时的重要结论，为四色猜想的研究提供了基础
四色猜想,演变,四色定理,,"如前所述，图的着色问题起源于对地图中每个国家领土的着色问题。例如，对于如图$10-$62 所示的地图，显然可以用4 种颜色对该地图中每个国家的领土进行标定。不难看出，该地图其实是一种连通无桥平面图，每个国家的领土范围对应于该平面图的一个面。因此，对地图中每个国家领土的着色问题，可转化为对这种特殊平面图中面的着色问题。  
![10-62 平面图的着色问题  ](images/0f1d899dc5071bbbd74c74607374e17794ff18cb387057f7c4c58b59ecbd991c.jpg)  
下面考察基于这种特殊平面图的面着色问题，首先给出面着色的相关定义：  
【定义10.13】连通无桥平面图及其所有有限面称为地图。地图中每有限面分别称为一个国家，若两个国家至少有一条公共边，则称这两个国家相邻。如果对给定地图$G$上每个国家涂上或标注一种颜色，使得相邻的国家具有不同的颜色，则称这种操作是对图$G$的面着色。若可用$k$种颜色就可完成对地图$G$的面着色，则称$G$是$k{-}$面可着色的。若$G$是$k{-}$面可着色的，但不是$(k-1){-}$面可着色的，则称$G$是${k}$-色地图，称$ k$为$G$的面色数，记为$\chi^{*}(G)$。  
事实上，对地图的面着色可以通过平面图的结点着色来研究。这是因为平面图$G$的对偶图$G^{*}$也是一个平面图，并且图$G$的每个面与图$G^{*}$的每个结点之间具有一一对应的关系。例如，对10-62（a）所示的面着色问题，可以转化为10-62（b）所示的结点着色问题。下面的定理10.22 揭示了作为地图的一种特殊平面图与其对偶图之间的色数关系：  
【定理10.22】地图$G$是$k^{-}$面可着色图，当且仅当它的对偶图$G^{*}$是$k^{-}$可着色图。  
【定理10.23】设$G=\langle V,E\rangle$是简单平面图，则$G$中至少存在一个度数不超过5 的结点。  
下面给出关于平面图结点着色的五色定理：  
【定理10.24】（五色定理）设$G=\langle V,E\rangle$是任意给定的一个连通简单平面图，则$G$的点色数为5。  
上述五色定理是数学家赫伍德在研究四色猜想时给出的一个重要结论，可以说是四色猜想研究历史上的一个重大突破。四色猜想是一个与哥德巴赫猜想、黎曼猜想同样著名的数学猜想。该猜想最初由英国青年佛朗西斯·格里斯在1852 年提出：  
四色猜想：连通简单平面图的色数不超过4。  
公元1852 年，毕业于英国伦敦大学并从事地图着色工作的佛朗西斯·格里斯，发现了一个奇怪的现象：无论多么复杂的地图，只要用四种颜色，就可以区分有公共边界的国家和地区。佛朗西斯觉得这中间一定有什么奥妙，便求教著名的英国数学家摩根。摩根对此苦苦思索了几个昼夜后还是不得其解，便写信给著名数学家哈密顿，希望哈密尔顿要么能证明这个问题，要么构造出一个需要五种或更多种颜色的图来。然而，智慧超人的哈密尔顿耗费了整整13 年心血，终于一筹莫展，抱恨逝去！  
哈密尔顿死后，又过了13 年，英国数学家凯莱在一次数学年会上把这个问题归纳为四色猜想，并于公元1879 年在英国皇家地理会刊的创刊号上，公开征求对四色猜想的解答。在征解消息发出的同年，一位半路出家的数学家肯普，发表了一个关于四色定理的证明。人们普遍以为四色猜想已经成为历史。不料过了11 年，即公元1890 年，一个名叫赫伍德的青年，指出了肯普在证明中的错误。与此同时，赫伍德匠心独运，利用肯普提供的方法，成功地证明了上述五色定理。由于存在不可3-着色的平面图$K_{4}$，故四色定理若得到证明，将是平面图色数问题的最佳结果。  
1976 年6 月，美国两位著名数学家阿佩尔和海肯通过计算机计算了1200 小时，通过数组计算的方法验证了四色猜想的正确性。据此，人们将四色猜想改名为四色定理。但是，四色定理并没有得到所以数学家的认可，因为目前还没理论上严谨的数学证明。",四色猜想经过验证后改名为四色定理，但四色定理尚未得到所有数学家的认可
结点着色算法,包含,贪心策略着色算法,,"如前所述，图的边着色和面着色问题都可转化为对图的结点着色问题。因此，如果掌握了对一个图的结点进行着色的具体设计方法，则边着色和面着色的设计问题便可迎刃而解。因此，我们仅给出结点着色算法。首先介绍一种比较直观的基于贪心策略的着色算法，然后介绍比较巧妙的韦尔奇•鲍威尔着色算法。  
基于贪心策略的着色算法的计算思路比较直观，首先对每个结点构造一个颜色集合，然后通过贪心策略逐步对颜色集合进行优化和排除，最后得到一种优化的着色方案。  
设$G=\langle V,E\rangle$是任意给定的一个连通无向图，令$\{c_{1},c_{2},\cdots,c_{n}\}$为全部可选颜色的集合，$V=\{v_{1},v_{2},\cdots,v_{n}\}$。则基于贪心策略的着色算法具体步骤如下：  
1）对$i=1,2,\cdots,n$，作集合$C_{i}=\{c_{1},c_{2},\cdots,c_{i}\}$。  
2）给结点$v_{i}(i=1,2,\cdots,n)$标上颜色集$C_{i}$的第一种颜色$c_{k}$  
3）对点$v_{i}$的所有邻接点$v_{j}(j>1)$，作$C_{j}=C_{j}-\{c_{k}\}$。  
4）转到步骤2），直到所有结点都着色为止。  
例如，图10-66（a）所示的无向图$G$，使用上述基于贪心策略的着色算法，不难得到如图10-66（b）所示的着色结果。  
![图10-66 无向图𝐺及其结点着色  ](images/0f362f12a7e52ba554944661d9c9e977185a05cbdb94dab0ac96e78d08f2908c.jpg)  
韦尔奇•鲍威尔算法是一个非常著名的结点着色算法。该算法的基本思路如下：首先将图$G$中的结点按度数的递减顺序进行排列；然后用第一种颜色对结点着色，并按排列顺序对与前面着色结点不邻接的每一结点着上同样的颜色；最后用第二种颜色对尚未着色的结点重复前一步骤，并用第三种颜色继续这种做法，直到所有的结点全部着色为止。  
设$G=\langle V,E\rangle$是任意给定的一个连通无向图，令$\cdot V=\{v_{1},v_{2},\cdots,v_{n}\}$且所有结点中共有𝑠种不同的度数，则韦尔奇•鲍威尔结点着色算法的具体步骤如下：  
1）图$G$的所有结点按其度数从大到小进行排列，度数相同的结点次序不究，得到：并设初值$i=j=k=1$，$B=\emptyset$，其中$B$表示已着色结点集合。  
2）用第𝑖种颜色对结点$v_{j k}$进行着色，并按次序对与$v_{j k}$不相邻的结点着同一颜色，将与$v_{j k}$着同色的所有结点放入$B$集合。  
3 ）若 $\,\!V(G)-B=\varnothing$ ，则停止，此时每个结点都已被着色。否则 $i=i+1$ ，取结点 $v_{j k}\in$ $V(G)-B$，且$\deg\!\left(v_{j k}\right)=\operatorname*{max}\{\deg\!\left(v_{x y}\right)\!,v_{x y}\in V(G)-B\}$，转去执行2）。",贪心策略着色算法是一种结点着色算法
结点着色算法,包含,韦尔奇•鲍威尔算法,,"如前所述，图的边着色和面着色问题都可转化为对图的结点着色问题。因此，如果掌握了对一个图的结点进行着色的具体设计方法，则边着色和面着色的设计问题便可迎刃而解。因此，我们仅给出结点着色算法。首先介绍一种比较直观的基于贪心策略的着色算法，然后介绍比较巧妙的韦尔奇•鲍威尔着色算法。  
基于贪心策略的着色算法的计算思路比较直观，首先对每个结点构造一个颜色集合，然后通过贪心策略逐步对颜色集合进行优化和排除，最后得到一种优化的着色方案。  
设$G=\langle V,E\rangle$是任意给定的一个连通无向图，令$\{c_{1},c_{2},\cdots,c_{n}\}$为全部可选颜色的集合，$V=\{v_{1},v_{2},\cdots,v_{n}\}$。则基于贪心策略的着色算法具体步骤如下：  
1）对$i=1,2,\cdots,n$，作集合$C_{i}=\{c_{1},c_{2},\cdots,c_{i}\}$。  
2）给结点$v_{i}(i=1,2,\cdots,n)$标上颜色集$C_{i}$的第一种颜色$c_{k}$  
3）对点$v_{i}$的所有邻接点$v_{j}(j>1)$，作$C_{j}=C_{j}-\{c_{k}\}$。  
4）转到步骤2），直到所有结点都着色为止。  
例如，图10-66（a）所示的无向图$G$，使用上述基于贪心策略的着色算法，不难得到如图10-66（b）所示的着色结果。  
![图10-66 无向图𝐺及其结点着色  ](images/0f362f12a7e52ba554944661d9c9e977185a05cbdb94dab0ac96e78d08f2908c.jpg)  
韦尔奇•鲍威尔算法是一个非常著名的结点着色算法。该算法的基本思路如下：首先将图$G$中的结点按度数的递减顺序进行排列；然后用第一种颜色对结点着色，并按排列顺序对与前面着色结点不邻接的每一结点着上同样的颜色；最后用第二种颜色对尚未着色的结点重复前一步骤，并用第三种颜色继续这种做法，直到所有的结点全部着色为止。  
设$G=\langle V,E\rangle$是任意给定的一个连通无向图，令$\cdot V=\{v_{1},v_{2},\cdots,v_{n}\}$且所有结点中共有𝑠种不同的度数，则韦尔奇•鲍威尔结点着色算法的具体步骤如下：  
1）图$G$的所有结点按其度数从大到小进行排列，度数相同的结点次序不究，得到：并设初值$i=j=k=1$，$B=\emptyset$，其中$B$表示已着色结点集合。  
2）用第𝑖种颜色对结点$v_{j k}$进行着色，并按次序对与$v_{j k}$不相邻的结点着同一颜色，将与$v_{j k}$着同色的所有结点放入$B$集合。  
3 ）若 $\,\!V(G)-B=\varnothing$ ，则停止，此时每个结点都已被着色。否则 $i=i+1$ ，取结点 $v_{j k}\in$ $V(G)-B$，且$\deg\!\left(v_{j k}\right)=\operatorname*{max}\{\deg\!\left(v_{x y}\right)\!,v_{x y}\in V(G)-B\}$，转去执行2）。",韦尔奇•鲍威尔算法是一种结点着色算法
贪心策略着色算法,并列,韦尔奇•鲍威尔算法,,"如前所述，图的边着色和面着色问题都可转化为对图的结点着色问题。因此，如果掌握了对一个图的结点进行着色的具体设计方法，则边着色和面着色的设计问题便可迎刃而解。因此，我们仅给出结点着色算法。首先介绍一种比较直观的基于贪心策略的着色算法，然后介绍比较巧妙的韦尔奇•鲍威尔着色算法。  
基于贪心策略的着色算法的计算思路比较直观，首先对每个结点构造一个颜色集合，然后通过贪心策略逐步对颜色集合进行优化和排除，最后得到一种优化的着色方案。  
设$G=\langle V,E\rangle$是任意给定的一个连通无向图，令$\{c_{1},c_{2},\cdots,c_{n}\}$为全部可选颜色的集合，$V=\{v_{1},v_{2},\cdots,v_{n}\}$。则基于贪心策略的着色算法具体步骤如下：  
1）对$i=1,2,\cdots,n$，作集合$C_{i}=\{c_{1},c_{2},\cdots,c_{i}\}$。  
2）给结点$v_{i}(i=1,2,\cdots,n)$标上颜色集$C_{i}$的第一种颜色$c_{k}$  
3）对点$v_{i}$的所有邻接点$v_{j}(j>1)$，作$C_{j}=C_{j}-\{c_{k}\}$。  
4）转到步骤2），直到所有结点都着色为止。  
例如，图10-66（a）所示的无向图$G$，使用上述基于贪心策略的着色算法，不难得到如图10-66（b）所示的着色结果。  
![图10-66 无向图𝐺及其结点着色  ](images/0f362f12a7e52ba554944661d9c9e977185a05cbdb94dab0ac96e78d08f2908c.jpg)  
韦尔奇•鲍威尔算法是一个非常著名的结点着色算法。该算法的基本思路如下：首先将图$G$中的结点按度数的递减顺序进行排列；然后用第一种颜色对结点着色，并按排列顺序对与前面着色结点不邻接的每一结点着上同样的颜色；最后用第二种颜色对尚未着色的结点重复前一步骤，并用第三种颜色继续这种做法，直到所有的结点全部着色为止。  
设$G=\langle V,E\rangle$是任意给定的一个连通无向图，令$\cdot V=\{v_{1},v_{2},\cdots,v_{n}\}$且所有结点中共有𝑠种不同的度数，则韦尔奇•鲍威尔结点着色算法的具体步骤如下：  
1）图$G$的所有结点按其度数从大到小进行排列，度数相同的结点次序不究，得到：并设初值$i=j=k=1$，$B=\emptyset$，其中$B$表示已着色结点集合。  
2）用第𝑖种颜色对结点$v_{j k}$进行着色，并按次序对与$v_{j k}$不相邻的结点着同一颜色，将与$v_{j k}$着同色的所有结点放入$B$集合。  
3 ）若 $\,\!V(G)-B=\varnothing$ ，则停止，此时每个结点都已被着色。否则 $i=i+1$ ，取结点 $v_{j k}\in$ $V(G)-B$，且$\deg\!\left(v_{j k}\right)=\operatorname*{max}\{\deg\!\left(v_{x y}\right)\!,v_{x y}\in V(G)-B\}$，转去执行2）。",贪心策略着色算法和韦尔奇•鲍威尔算法都是结点着色算法的不同实现
网络流模型,包含,流网络,,对交通运输、网络通信和管道运输等实际问题的建模，不仅需要图模型，而且不可避免地涉及到车流、水流、人流、信息流等流的概念与计算。将图模型与流进行整合，就形成了一个新的数学模型——网络流模型。该模型是一种有向带权图，要求每条边都有一定容量限制，边的流量数不能超过其容量，而且除源点和汇点外，每道流进入某结点的流量数必须等于离开该结点的流量数。目前，随着增益流、多终端流、多商品流以及各种网络流的出现，网络流模型及算法已普遍应用到通讯、运输、电力、工程规划、任务分派、设备更新等诸多领域。本节介绍网络流图的基本概念及算法，主要包括流网络的基本概念、网络切割的基本概念与性质、网络最大流求解算法。,网络流模型包含流网络的基本概念
网络流模型,包含,网络切割,,对交通运输、网络通信和管道运输等实际问题的建模，不仅需要图模型，而且不可避免地涉及到车流、水流、人流、信息流等流的概念与计算。将图模型与流进行整合，就形成了一个新的数学模型——网络流模型。该模型是一种有向带权图，要求每条边都有一定容量限制，边的流量数不能超过其容量，而且除源点和汇点外，每道流进入某结点的流量数必须等于离开该结点的流量数。目前，随着增益流、多终端流、多商品流以及各种网络流的出现，网络流模型及算法已普遍应用到通讯、运输、电力、工程规划、任务分派、设备更新等诸多领域。本节介绍网络流图的基本概念及算法，主要包括流网络的基本概念、网络切割的基本概念与性质、网络最大流求解算法。,网络流模型包含网络切割的基本概念与性质
网络流模型,包含,网络最大流求解算法,,对交通运输、网络通信和管道运输等实际问题的建模，不仅需要图模型，而且不可避免地涉及到车流、水流、人流、信息流等流的概念与计算。将图模型与流进行整合，就形成了一个新的数学模型——网络流模型。该模型是一种有向带权图，要求每条边都有一定容量限制，边的流量数不能超过其容量，而且除源点和汇点外，每道流进入某结点的流量数必须等于离开该结点的流量数。目前，随着增益流、多终端流、多商品流以及各种网络流的出现，网络流模型及算法已普遍应用到通讯、运输、电力、工程规划、任务分派、设备更新等诸多领域。本节介绍网络流图的基本概念及算法，主要包括流网络的基本概念、网络切割的基本概念与性质、网络最大流求解算法。,网络流模型包含网络最大流求解算法
流网络,相关,网络切割,,对交通运输、网络通信和管道运输等实际问题的建模，不仅需要图模型，而且不可避免地涉及到车流、水流、人流、信息流等流的概念与计算。将图模型与流进行整合，就形成了一个新的数学模型——网络流模型。该模型是一种有向带权图，要求每条边都有一定容量限制，边的流量数不能超过其容量，而且除源点和汇点外，每道流进入某结点的流量数必须等于离开该结点的流量数。目前，随着增益流、多终端流、多商品流以及各种网络流的出现，网络流模型及算法已普遍应用到通讯、运输、电力、工程规划、任务分派、设备更新等诸多领域。本节介绍网络流图的基本概念及算法，主要包括流网络的基本概念、网络切割的基本概念与性质、网络最大流求解算法。,流网络与网络切割在基本概念上相关
流网络,应用,网络最大流求解算法,,对交通运输、网络通信和管道运输等实际问题的建模，不仅需要图模型，而且不可避免地涉及到车流、水流、人流、信息流等流的概念与计算。将图模型与流进行整合，就形成了一个新的数学模型——网络流模型。该模型是一种有向带权图，要求每条边都有一定容量限制，边的流量数不能超过其容量，而且除源点和汇点外，每道流进入某结点的流量数必须等于离开该结点的流量数。目前，随着增益流、多终端流、多商品流以及各种网络流的出现，网络流模型及算法已普遍应用到通讯、运输、电力、工程规划、任务分派、设备更新等诸多领域。本节介绍网络流图的基本概念及算法，主要包括流网络的基本概念、网络切割的基本概念与性质、网络最大流求解算法。,网络最大流求解算法应用于流网络
网络切割,相关,网络最大流求解算法,,对交通运输、网络通信和管道运输等实际问题的建模，不仅需要图模型，而且不可避免地涉及到车流、水流、人流、信息流等流的概念与计算。将图模型与流进行整合，就形成了一个新的数学模型——网络流模型。该模型是一种有向带权图，要求每条边都有一定容量限制，边的流量数不能超过其容量，而且除源点和汇点外，每道流进入某结点的流量数必须等于离开该结点的流量数。目前，随着增益流、多终端流、多商品流以及各种网络流的出现，网络流模型及算法已普遍应用到通讯、运输、电力、工程规划、任务分派、设备更新等诸多领域。本节介绍网络流图的基本概念及算法，主要包括流网络的基本概念、网络切割的基本概念与性质、网络最大流求解算法。,网络切割与网络最大流求解算法在性质上相关
流网络,包含,可行流,,"首先介绍流网络模型的相关基本概念及其数据描述。如同每条公路有运输量、每根水管有最大流量限制一样，网络流图的每条边都有容量，或者说每条边都有一定的流量。网络流图其实就是每条边具有附带容量（可理解为权值）的有向图。其具体定义如下：  
【定义10.4.1】设有向图$G=\langle V,E\rangle$，$V$中包含一个源结点𝑠和一个汇结点$t$，且每条边$(u,v)\in E$均有一个非负容量$c(u,v)\geq0$，若$(u,v)\notin E$，则规定其容量$c(u,v)=0$，此时称有向图$G$是一个网络流图，简称为流网络或网络。源结点$s$即起点，汇结点$t$即终点。网络流是定义在网络$G$中关于边的一个实函数，用$f(u,v)$表示有向边$(u,v)\in E$上结点$ u$到结点$v$的网络流。$f(u,v)$表示$u$ 到$v$的净流。  
例如，如果$_{u}$到$v$有6 个单位的实际流，且$v$到$u$有3 个单位的实际流，那么$f(u,v)=$3，$f(v,u)=-3$，互为相反数。净流是实际通过的流量矢量和，可类比合力的概念。  
满足以下三个性质的网络流$f$称之为可行流：  
（1）容量限制：对所有的$(u,v)\in E$，都有$f(u,v)\leq c(u,\textit{}v)$。即一条边的流不能超过它的容量。这也很容易理解，如同自来水管的水流自然不会超过水管本身的容量。  
（2）斜对称：对所有$(u,v)\in E$，都有$f(u,v)=-f(v,u)$。即点$\cdot u$到$v$的净流必须与点𝑣到$u$的净流相反。可以类比物理中矢量概念，如作用力与反作用力，强调的是其方向性。  
（3）流守恒：对所有$u\in V-\{s,t\}$，都有$\textstyle\sum_{v\in V}f(u,v)=0$。即除源结点$𝑠$和汇结点$𝑡$外，其余每个结点的净流之和为0。  
![图10-68 网络及可行流  ](images/bada5974bba3db0db4c82fa8e3076a8834542abfa1641f17fac232a32e6fee29.jpg)  
例如，如图10-68 所示，网络中定义网络流$f(u,v)$是一条可行流。图中每条边所对应的序偶表示该边的容量和流量，第一个数字表示边的容量，第二个数字表示边的流量。  
下面结合图10-68 所示网络实例介绍网络流模型中与边相关的几个概念。可根据边的容量与流的大小关系对网络中的边进行分类：  
（1）满足$f(u,v)=c(u,v)$的边称为饱和边，如边(1,2)、 (2,3)  
（2）满足$f(u,v)<c(u,v)$的边称为非饱和边，如边(2,4)。  
（3）满足 $f(u,v)=0$ 的边称为零流边，如边 (3,4) ；满足 $f(u,v)>0$ 的边称为非零流 边，如边(5,4)。  
（4）既不是零流边也不是饱和边的边，称为弱流边，如边(5,6)  
如果把图10-78 看作是一个公路网，6 个结点分别表示6 座城镇，每条边上的权数表示两城镇间的距离。若现在需要从起点1 将一些物资运送到终点6，应怎样选择路线才能使总运输距离最短。我们知道，这样一类问题称为最短路径问题。类似的，如果把图10-1看作为一个输油管道网，结点1表示为发送点，结点6表示为接收点，其它点表示为中转站，各边的权数表示该段管道的最大运输油量。那么如何安排输油线路才能使从1到6的总运输量最大。这样一类问题就是最大流问题。  
最大流问题是网络优化中的一个典型的问题，简单地说，就是在满足容量约束的前提下将尽可能多的流从源结点流向汇结点。因此，最大流问题就是求流网络$G$中使其流量$f$达到最大的一个可行流，该可行流即为最大流。具体定义如下：  
【定义10.4.2】设有向图$G=\langle V,E\rangle$是任意给定的一个网络流图，若$f$是$G$ 中流量最大的的可行流，则称该可行流$f$是$G$ 的最大流，构构造网络流图$G$ 中最大流的问题，就称为网络流图的最大流问题。  
为了实现对最大流问题的求解，必须对网络流图中的增流空间进行合理的度量，通常使用一种名为残留网络的图模型实现这项工作。残留网络的具体定义如下：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图， $f$为$G$的一个流，对于$G$的任意一条边$(u,v)$，在不超过容量$c(u,v)$条件下，从$u$到$v$可压入的额外流量，称为$(u,v)$的残留容量。由$G$中所有边残留容量构成的带权有向图称为$G$的残留网络，记为$G_{f}=\langle V,E_{f}\rangle$。  
若$c_{f}(u,v)$为残留网络$G_{f}$中边$(u,v)$的残留容量，且边$(u,v)\in E$或边$(v,u)\in E$，则$(u,v)\in$$E_{f}$,$\,c_{f}(u,v)=c(u,v)-f(u,v)\,$。例如，若设$(u,v)$当前流量为(4,3)，此时$c(u,v)=4$，$f(u,v)$）$=3$，则有：$c_{f}(u,v)=1$。  
需要注意的是，残留网络具有这样的性质：假设从$_{.}u$到$v$已经有了3 个单位流量，那么从反方向上看，也就是从$v$ 到$u$ 就有了3 个单位的残留容量，这时$c_{f}(v,u)=3$。换句话说，从$u$ 到$v$ 有3 个单位流量，那么从$v$到$u$ 就有了将这3 个单位流量压回去的能力。因此，残留网络结点之间通常由双向带权边进行联结。例如，对于图10-69（a）所示的一个流网络$G$，图10-69（b）则表示该流网络𝐺的残留网络。  
![图10-69 流网络及其残留网络 ](images/d65d1c72064671125468548ae171a28ede5424f1d36d601972ed76c90131fc8c.jpg)  
对于任意给定的一个网络流图$G=\langle V,E\rangle$，可以通过其残留网络$G_{f}=\langle V,E_{f}\rangle$求得$G$的最大流。基本思路如下：首先，对所有的结点令初始状态时流的值为0，即对于$\forall u,v\in V$，有$f(u,v)=0$。然后，通过迭代方式其残留网络中不断寻找源点𝑠到汇点$t$之间的流量增广路径来增加网络流量值，直到残留网络没有这样的增广路径为止。  
因此，在残留网络$G_{f}=\langle V,E_{f}\rangle$寻找流量增广路径是最大流求解算法的关键。为正确理解该算法，现给出流网络增广路径的具体定义：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，$G_{f}=\langle V,E_{f}\rangle$为$G$在流$f$下的一个残留网络，则$G_{f}=\langle V,E_{f}\rangle$中任意一条从源点$s$到汇点$t$的简单路径$p$称为$G=\langle V,E\rangle$的一条流量增广路径，简称为增广路径。  
事实上，可将增广路径形象地理解为网络流图$G$中从源点𝑠到汇点𝑡的一条不违反流网络边容量限制的路径，并向这条路径压入一定的流量，以增加整个网络的流量值。例如，图10-69（b）所示的残留网络存在这样一条如图10-70 中加粗有向边所示的增广路径。  
![图10-70 增广路径 ](images/1e52dc98ce8f5b49283b093dbb72c0d5308ccdc9782306a98cb168474d58608f.jpg)  
![图10-71 流网络的一个切割](images/c52dd38b6f7d2bc46bb57e2440709d67355577a7b3d5fb2e920f10a5bfeb8598.jpg)  
若将图10-70 所示增广路径在流网络所对应每条边的流量增加4 个单位，得到一个新的流网络，其流量比原网络多4 个单位。然后，在新流网络所对应的残留网络中继续寻找新增广路径，直到找不到新增广路径为止。显然，现在的问题是：如果在残留网络$G_{f}=$$\langle V,E_{f}\rangle$中找不到增广路径，此时该残留网络所对应的流$f$是否就是流网络$G=\langle V,E\rangle$的最大流？要解决这个问题，必须进一步引入流网络切割的相关概念，具体如下：  
【定义10.4.4】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，如果将$G$的结点集合𝑉划分为𝑆和$T=V-S$两部分，使得源点$s\in S$且$t\in T$，则称$(S,T)$是$G=\langle V,E\rangle$的一个切割，简称为割。从集合 𝑆 到集合 𝑇 的所有有向边容量之和称为切割 $(S,T)$ 的容量，穿过切割 $(S,T)$所有边流量的代数和流量称为切割$(S,T)$的净流量，记为$f(S,T)$。  
主要注意的是，定义10.4.4 中边的流量带有正负方向，如果流从结点𝑆流向$T$，则该边的流量值为正，如果流从结点𝑇流向𝑆，则该边的流量值为负。例如，对图10-69（a）所示的流网络，可画一个如图10-71 所示的切割$(S,T)$，其容量为：  
$$
c(u,w)+c(v,x)=12+14=26
$$  
穿过该切割的净流量为：  
$$
f(u,w)+f(v,x)-f(w,v)=12+11-4=19
$$  
显然，对于任意一个切割，穿过该切割的净流量上界就是该切割的容量，即穿过切割的净流量不可能超过割的容量。由于流网络中所有切割的流都相等并且等于网络的流，因此，网络最大流必然无法超过网络的最小割。由此得到如下最大流最小割定理：  
【定理10.4.1】（最大流最小割定理）设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和$t$分别为其源点和汇点，则$G=\langle V,E\rangle$的最大流量等于其最小割切的容量。对于$G=\langle V,E\rangle$上的任意一个流$f$，以下三个结论彼此等价：  
(1) $f$是流网络$G=\langle V,E\rangle$的一个最大流；  
(2) 流网络$G=\langle V,E\rangle$的残留网络中不包括任何增广路径；  
(3) 存在流网络$G=\langle V,E\rangle$的某个切割$(S,T)$，满足：
$$
f(S,T)=c(S,T)
$$",流网络中满足特定性质的流称为可行流
可行流,满足,容量限制,,"首先介绍流网络模型的相关基本概念及其数据描述。如同每条公路有运输量、每根水管有最大流量限制一样，网络流图的每条边都有容量，或者说每条边都有一定的流量。网络流图其实就是每条边具有附带容量（可理解为权值）的有向图。其具体定义如下：  
【定义10.4.1】设有向图$G=\langle V,E\rangle$，$V$中包含一个源结点𝑠和一个汇结点$t$，且每条边$(u,v)\in E$均有一个非负容量$c(u,v)\geq0$，若$(u,v)\notin E$，则规定其容量$c(u,v)=0$，此时称有向图$G$是一个网络流图，简称为流网络或网络。源结点$s$即起点，汇结点$t$即终点。网络流是定义在网络$G$中关于边的一个实函数，用$f(u,v)$表示有向边$(u,v)\in E$上结点$ u$到结点$v$的网络流。$f(u,v)$表示$u$ 到$v$的净流。  
例如，如果$_{u}$到$v$有6 个单位的实际流，且$v$到$u$有3 个单位的实际流，那么$f(u,v)=$3，$f(v,u)=-3$，互为相反数。净流是实际通过的流量矢量和，可类比合力的概念。  
满足以下三个性质的网络流$f$称之为可行流：  
（1）容量限制：对所有的$(u,v)\in E$，都有$f(u,v)\leq c(u,\textit{}v)$。即一条边的流不能超过它的容量。这也很容易理解，如同自来水管的水流自然不会超过水管本身的容量。  
（2）斜对称：对所有$(u,v)\in E$，都有$f(u,v)=-f(v,u)$。即点$\cdot u$到$v$的净流必须与点𝑣到$u$的净流相反。可以类比物理中矢量概念，如作用力与反作用力，强调的是其方向性。  
（3）流守恒：对所有$u\in V-\{s,t\}$，都有$\textstyle\sum_{v\in V}f(u,v)=0$。即除源结点$𝑠$和汇结点$𝑡$外，其余每个结点的净流之和为0。  
![图10-68 网络及可行流  ](images/bada5974bba3db0db4c82fa8e3076a8834542abfa1641f17fac232a32e6fee29.jpg)  
例如，如图10-68 所示，网络中定义网络流$f(u,v)$是一条可行流。图中每条边所对应的序偶表示该边的容量和流量，第一个数字表示边的容量，第二个数字表示边的流量。  
下面结合图10-68 所示网络实例介绍网络流模型中与边相关的几个概念。可根据边的容量与流的大小关系对网络中的边进行分类：  
（1）满足$f(u,v)=c(u,v)$的边称为饱和边，如边(1,2)、 (2,3)  
（2）满足$f(u,v)<c(u,v)$的边称为非饱和边，如边(2,4)。  
（3）满足 $f(u,v)=0$ 的边称为零流边，如边 (3,4) ；满足 $f(u,v)>0$ 的边称为非零流 边，如边(5,4)。  
（4）既不是零流边也不是饱和边的边，称为弱流边，如边(5,6)  
如果把图10-78 看作是一个公路网，6 个结点分别表示6 座城镇，每条边上的权数表示两城镇间的距离。若现在需要从起点1 将一些物资运送到终点6，应怎样选择路线才能使总运输距离最短。我们知道，这样一类问题称为最短路径问题。类似的，如果把图10-1看作为一个输油管道网，结点1表示为发送点，结点6表示为接收点，其它点表示为中转站，各边的权数表示该段管道的最大运输油量。那么如何安排输油线路才能使从1到6的总运输量最大。这样一类问题就是最大流问题。  
最大流问题是网络优化中的一个典型的问题，简单地说，就是在满足容量约束的前提下将尽可能多的流从源结点流向汇结点。因此，最大流问题就是求流网络$G$中使其流量$f$达到最大的一个可行流，该可行流即为最大流。具体定义如下：  
【定义10.4.2】设有向图$G=\langle V,E\rangle$是任意给定的一个网络流图，若$f$是$G$ 中流量最大的的可行流，则称该可行流$f$是$G$ 的最大流，构构造网络流图$G$ 中最大流的问题，就称为网络流图的最大流问题。  
为了实现对最大流问题的求解，必须对网络流图中的增流空间进行合理的度量，通常使用一种名为残留网络的图模型实现这项工作。残留网络的具体定义如下：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图， $f$为$G$的一个流，对于$G$的任意一条边$(u,v)$，在不超过容量$c(u,v)$条件下，从$u$到$v$可压入的额外流量，称为$(u,v)$的残留容量。由$G$中所有边残留容量构成的带权有向图称为$G$的残留网络，记为$G_{f}=\langle V,E_{f}\rangle$。  
若$c_{f}(u,v)$为残留网络$G_{f}$中边$(u,v)$的残留容量，且边$(u,v)\in E$或边$(v,u)\in E$，则$(u,v)\in$$E_{f}$,$\,c_{f}(u,v)=c(u,v)-f(u,v)\,$。例如，若设$(u,v)$当前流量为(4,3)，此时$c(u,v)=4$，$f(u,v)$）$=3$，则有：$c_{f}(u,v)=1$。  
需要注意的是，残留网络具有这样的性质：假设从$_{.}u$到$v$已经有了3 个单位流量，那么从反方向上看，也就是从$v$ 到$u$ 就有了3 个单位的残留容量，这时$c_{f}(v,u)=3$。换句话说，从$u$ 到$v$ 有3 个单位流量，那么从$v$到$u$ 就有了将这3 个单位流量压回去的能力。因此，残留网络结点之间通常由双向带权边进行联结。例如，对于图10-69（a）所示的一个流网络$G$，图10-69（b）则表示该流网络𝐺的残留网络。  
![图10-69 流网络及其残留网络 ](images/d65d1c72064671125468548ae171a28ede5424f1d36d601972ed76c90131fc8c.jpg)  
对于任意给定的一个网络流图$G=\langle V,E\rangle$，可以通过其残留网络$G_{f}=\langle V,E_{f}\rangle$求得$G$的最大流。基本思路如下：首先，对所有的结点令初始状态时流的值为0，即对于$\forall u,v\in V$，有$f(u,v)=0$。然后，通过迭代方式其残留网络中不断寻找源点𝑠到汇点$t$之间的流量增广路径来增加网络流量值，直到残留网络没有这样的增广路径为止。  
因此，在残留网络$G_{f}=\langle V,E_{f}\rangle$寻找流量增广路径是最大流求解算法的关键。为正确理解该算法，现给出流网络增广路径的具体定义：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，$G_{f}=\langle V,E_{f}\rangle$为$G$在流$f$下的一个残留网络，则$G_{f}=\langle V,E_{f}\rangle$中任意一条从源点$s$到汇点$t$的简单路径$p$称为$G=\langle V,E\rangle$的一条流量增广路径，简称为增广路径。  
事实上，可将增广路径形象地理解为网络流图$G$中从源点𝑠到汇点𝑡的一条不违反流网络边容量限制的路径，并向这条路径压入一定的流量，以增加整个网络的流量值。例如，图10-69（b）所示的残留网络存在这样一条如图10-70 中加粗有向边所示的增广路径。  
![图10-70 增广路径 ](images/1e52dc98ce8f5b49283b093dbb72c0d5308ccdc9782306a98cb168474d58608f.jpg)  
![图10-71 流网络的一个切割](images/c52dd38b6f7d2bc46bb57e2440709d67355577a7b3d5fb2e920f10a5bfeb8598.jpg)  
若将图10-70 所示增广路径在流网络所对应每条边的流量增加4 个单位，得到一个新的流网络，其流量比原网络多4 个单位。然后，在新流网络所对应的残留网络中继续寻找新增广路径，直到找不到新增广路径为止。显然，现在的问题是：如果在残留网络$G_{f}=$$\langle V,E_{f}\rangle$中找不到增广路径，此时该残留网络所对应的流$f$是否就是流网络$G=\langle V,E\rangle$的最大流？要解决这个问题，必须进一步引入流网络切割的相关概念，具体如下：  
【定义10.4.4】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，如果将$G$的结点集合𝑉划分为𝑆和$T=V-S$两部分，使得源点$s\in S$且$t\in T$，则称$(S,T)$是$G=\langle V,E\rangle$的一个切割，简称为割。从集合 𝑆 到集合 𝑇 的所有有向边容量之和称为切割 $(S,T)$ 的容量，穿过切割 $(S,T)$所有边流量的代数和流量称为切割$(S,T)$的净流量，记为$f(S,T)$。  
主要注意的是，定义10.4.4 中边的流量带有正负方向，如果流从结点𝑆流向$T$，则该边的流量值为正，如果流从结点𝑇流向𝑆，则该边的流量值为负。例如，对图10-69（a）所示的流网络，可画一个如图10-71 所示的切割$(S,T)$，其容量为：  
$$
c(u,w)+c(v,x)=12+14=26
$$  
穿过该切割的净流量为：  
$$
f(u,w)+f(v,x)-f(w,v)=12+11-4=19
$$  
显然，对于任意一个切割，穿过该切割的净流量上界就是该切割的容量，即穿过切割的净流量不可能超过割的容量。由于流网络中所有切割的流都相等并且等于网络的流，因此，网络最大流必然无法超过网络的最小割。由此得到如下最大流最小割定理：  
【定理10.4.1】（最大流最小割定理）设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和$t$分别为其源点和汇点，则$G=\langle V,E\rangle$的最大流量等于其最小割切的容量。对于$G=\langle V,E\rangle$上的任意一个流$f$，以下三个结论彼此等价：  
(1) $f$是流网络$G=\langle V,E\rangle$的一个最大流；  
(2) 流网络$G=\langle V,E\rangle$的残留网络中不包括任何增广路径；  
(3) 存在流网络$G=\langle V,E\rangle$的某个切割$(S,T)$，满足：
$$
f(S,T)=c(S,T)
$$",可行流必须满足每条边的流量不超过其容量
可行流,满足,斜对称,,"首先介绍流网络模型的相关基本概念及其数据描述。如同每条公路有运输量、每根水管有最大流量限制一样，网络流图的每条边都有容量，或者说每条边都有一定的流量。网络流图其实就是每条边具有附带容量（可理解为权值）的有向图。其具体定义如下：  
【定义10.4.1】设有向图$G=\langle V,E\rangle$，$V$中包含一个源结点𝑠和一个汇结点$t$，且每条边$(u,v)\in E$均有一个非负容量$c(u,v)\geq0$，若$(u,v)\notin E$，则规定其容量$c(u,v)=0$，此时称有向图$G$是一个网络流图，简称为流网络或网络。源结点$s$即起点，汇结点$t$即终点。网络流是定义在网络$G$中关于边的一个实函数，用$f(u,v)$表示有向边$(u,v)\in E$上结点$ u$到结点$v$的网络流。$f(u,v)$表示$u$ 到$v$的净流。  
例如，如果$_{u}$到$v$有6 个单位的实际流，且$v$到$u$有3 个单位的实际流，那么$f(u,v)=$3，$f(v,u)=-3$，互为相反数。净流是实际通过的流量矢量和，可类比合力的概念。  
满足以下三个性质的网络流$f$称之为可行流：  
（1）容量限制：对所有的$(u,v)\in E$，都有$f(u,v)\leq c(u,\textit{}v)$。即一条边的流不能超过它的容量。这也很容易理解，如同自来水管的水流自然不会超过水管本身的容量。  
（2）斜对称：对所有$(u,v)\in E$，都有$f(u,v)=-f(v,u)$。即点$\cdot u$到$v$的净流必须与点𝑣到$u$的净流相反。可以类比物理中矢量概念，如作用力与反作用力，强调的是其方向性。  
（3）流守恒：对所有$u\in V-\{s,t\}$，都有$\textstyle\sum_{v\in V}f(u,v)=0$。即除源结点$𝑠$和汇结点$𝑡$外，其余每个结点的净流之和为0。  
![图10-68 网络及可行流  ](images/bada5974bba3db0db4c82fa8e3076a8834542abfa1641f17fac232a32e6fee29.jpg)  
例如，如图10-68 所示，网络中定义网络流$f(u,v)$是一条可行流。图中每条边所对应的序偶表示该边的容量和流量，第一个数字表示边的容量，第二个数字表示边的流量。  
下面结合图10-68 所示网络实例介绍网络流模型中与边相关的几个概念。可根据边的容量与流的大小关系对网络中的边进行分类：  
（1）满足$f(u,v)=c(u,v)$的边称为饱和边，如边(1,2)、 (2,3)  
（2）满足$f(u,v)<c(u,v)$的边称为非饱和边，如边(2,4)。  
（3）满足 $f(u,v)=0$ 的边称为零流边，如边 (3,4) ；满足 $f(u,v)>0$ 的边称为非零流 边，如边(5,4)。  
（4）既不是零流边也不是饱和边的边，称为弱流边，如边(5,6)  
如果把图10-78 看作是一个公路网，6 个结点分别表示6 座城镇，每条边上的权数表示两城镇间的距离。若现在需要从起点1 将一些物资运送到终点6，应怎样选择路线才能使总运输距离最短。我们知道，这样一类问题称为最短路径问题。类似的，如果把图10-1看作为一个输油管道网，结点1表示为发送点，结点6表示为接收点，其它点表示为中转站，各边的权数表示该段管道的最大运输油量。那么如何安排输油线路才能使从1到6的总运输量最大。这样一类问题就是最大流问题。  
最大流问题是网络优化中的一个典型的问题，简单地说，就是在满足容量约束的前提下将尽可能多的流从源结点流向汇结点。因此，最大流问题就是求流网络$G$中使其流量$f$达到最大的一个可行流，该可行流即为最大流。具体定义如下：  
【定义10.4.2】设有向图$G=\langle V,E\rangle$是任意给定的一个网络流图，若$f$是$G$ 中流量最大的的可行流，则称该可行流$f$是$G$ 的最大流，构构造网络流图$G$ 中最大流的问题，就称为网络流图的最大流问题。  
为了实现对最大流问题的求解，必须对网络流图中的增流空间进行合理的度量，通常使用一种名为残留网络的图模型实现这项工作。残留网络的具体定义如下：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图， $f$为$G$的一个流，对于$G$的任意一条边$(u,v)$，在不超过容量$c(u,v)$条件下，从$u$到$v$可压入的额外流量，称为$(u,v)$的残留容量。由$G$中所有边残留容量构成的带权有向图称为$G$的残留网络，记为$G_{f}=\langle V,E_{f}\rangle$。  
若$c_{f}(u,v)$为残留网络$G_{f}$中边$(u,v)$的残留容量，且边$(u,v)\in E$或边$(v,u)\in E$，则$(u,v)\in$$E_{f}$,$\,c_{f}(u,v)=c(u,v)-f(u,v)\,$。例如，若设$(u,v)$当前流量为(4,3)，此时$c(u,v)=4$，$f(u,v)$）$=3$，则有：$c_{f}(u,v)=1$。  
需要注意的是，残留网络具有这样的性质：假设从$_{.}u$到$v$已经有了3 个单位流量，那么从反方向上看，也就是从$v$ 到$u$ 就有了3 个单位的残留容量，这时$c_{f}(v,u)=3$。换句话说，从$u$ 到$v$ 有3 个单位流量，那么从$v$到$u$ 就有了将这3 个单位流量压回去的能力。因此，残留网络结点之间通常由双向带权边进行联结。例如，对于图10-69（a）所示的一个流网络$G$，图10-69（b）则表示该流网络𝐺的残留网络。  
![图10-69 流网络及其残留网络 ](images/d65d1c72064671125468548ae171a28ede5424f1d36d601972ed76c90131fc8c.jpg)  
对于任意给定的一个网络流图$G=\langle V,E\rangle$，可以通过其残留网络$G_{f}=\langle V,E_{f}\rangle$求得$G$的最大流。基本思路如下：首先，对所有的结点令初始状态时流的值为0，即对于$\forall u,v\in V$，有$f(u,v)=0$。然后，通过迭代方式其残留网络中不断寻找源点𝑠到汇点$t$之间的流量增广路径来增加网络流量值，直到残留网络没有这样的增广路径为止。  
因此，在残留网络$G_{f}=\langle V,E_{f}\rangle$寻找流量增广路径是最大流求解算法的关键。为正确理解该算法，现给出流网络增广路径的具体定义：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，$G_{f}=\langle V,E_{f}\rangle$为$G$在流$f$下的一个残留网络，则$G_{f}=\langle V,E_{f}\rangle$中任意一条从源点$s$到汇点$t$的简单路径$p$称为$G=\langle V,E\rangle$的一条流量增广路径，简称为增广路径。  
事实上，可将增广路径形象地理解为网络流图$G$中从源点𝑠到汇点𝑡的一条不违反流网络边容量限制的路径，并向这条路径压入一定的流量，以增加整个网络的流量值。例如，图10-69（b）所示的残留网络存在这样一条如图10-70 中加粗有向边所示的增广路径。  
![图10-70 增广路径 ](images/1e52dc98ce8f5b49283b093dbb72c0d5308ccdc9782306a98cb168474d58608f.jpg)  
![图10-71 流网络的一个切割](images/c52dd38b6f7d2bc46bb57e2440709d67355577a7b3d5fb2e920f10a5bfeb8598.jpg)  
若将图10-70 所示增广路径在流网络所对应每条边的流量增加4 个单位，得到一个新的流网络，其流量比原网络多4 个单位。然后，在新流网络所对应的残留网络中继续寻找新增广路径，直到找不到新增广路径为止。显然，现在的问题是：如果在残留网络$G_{f}=$$\langle V,E_{f}\rangle$中找不到增广路径，此时该残留网络所对应的流$f$是否就是流网络$G=\langle V,E\rangle$的最大流？要解决这个问题，必须进一步引入流网络切割的相关概念，具体如下：  
【定义10.4.4】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，如果将$G$的结点集合𝑉划分为𝑆和$T=V-S$两部分，使得源点$s\in S$且$t\in T$，则称$(S,T)$是$G=\langle V,E\rangle$的一个切割，简称为割。从集合 𝑆 到集合 𝑇 的所有有向边容量之和称为切割 $(S,T)$ 的容量，穿过切割 $(S,T)$所有边流量的代数和流量称为切割$(S,T)$的净流量，记为$f(S,T)$。  
主要注意的是，定义10.4.4 中边的流量带有正负方向，如果流从结点𝑆流向$T$，则该边的流量值为正，如果流从结点𝑇流向𝑆，则该边的流量值为负。例如，对图10-69（a）所示的流网络，可画一个如图10-71 所示的切割$(S,T)$，其容量为：  
$$
c(u,w)+c(v,x)=12+14=26
$$  
穿过该切割的净流量为：  
$$
f(u,w)+f(v,x)-f(w,v)=12+11-4=19
$$  
显然，对于任意一个切割，穿过该切割的净流量上界就是该切割的容量，即穿过切割的净流量不可能超过割的容量。由于流网络中所有切割的流都相等并且等于网络的流，因此，网络最大流必然无法超过网络的最小割。由此得到如下最大流最小割定理：  
【定理10.4.1】（最大流最小割定理）设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和$t$分别为其源点和汇点，则$G=\langle V,E\rangle$的最大流量等于其最小割切的容量。对于$G=\langle V,E\rangle$上的任意一个流$f$，以下三个结论彼此等价：  
(1) $f$是流网络$G=\langle V,E\rangle$的一个最大流；  
(2) 流网络$G=\langle V,E\rangle$的残留网络中不包括任何增广路径；  
(3) 存在流网络$G=\langle V,E\rangle$的某个切割$(S,T)$，满足：
$$
f(S,T)=c(S,T)
$$",可行流中任意两点的净流互为相反数
可行流,满足,流守恒,,"首先介绍流网络模型的相关基本概念及其数据描述。如同每条公路有运输量、每根水管有最大流量限制一样，网络流图的每条边都有容量，或者说每条边都有一定的流量。网络流图其实就是每条边具有附带容量（可理解为权值）的有向图。其具体定义如下：  
【定义10.4.1】设有向图$G=\langle V,E\rangle$，$V$中包含一个源结点𝑠和一个汇结点$t$，且每条边$(u,v)\in E$均有一个非负容量$c(u,v)\geq0$，若$(u,v)\notin E$，则规定其容量$c(u,v)=0$，此时称有向图$G$是一个网络流图，简称为流网络或网络。源结点$s$即起点，汇结点$t$即终点。网络流是定义在网络$G$中关于边的一个实函数，用$f(u,v)$表示有向边$(u,v)\in E$上结点$ u$到结点$v$的网络流。$f(u,v)$表示$u$ 到$v$的净流。  
例如，如果$_{u}$到$v$有6 个单位的实际流，且$v$到$u$有3 个单位的实际流，那么$f(u,v)=$3，$f(v,u)=-3$，互为相反数。净流是实际通过的流量矢量和，可类比合力的概念。  
满足以下三个性质的网络流$f$称之为可行流：  
（1）容量限制：对所有的$(u,v)\in E$，都有$f(u,v)\leq c(u,\textit{}v)$。即一条边的流不能超过它的容量。这也很容易理解，如同自来水管的水流自然不会超过水管本身的容量。  
（2）斜对称：对所有$(u,v)\in E$，都有$f(u,v)=-f(v,u)$。即点$\cdot u$到$v$的净流必须与点𝑣到$u$的净流相反。可以类比物理中矢量概念，如作用力与反作用力，强调的是其方向性。  
（3）流守恒：对所有$u\in V-\{s,t\}$，都有$\textstyle\sum_{v\in V}f(u,v)=0$。即除源结点$𝑠$和汇结点$𝑡$外，其余每个结点的净流之和为0。  
![图10-68 网络及可行流  ](images/bada5974bba3db0db4c82fa8e3076a8834542abfa1641f17fac232a32e6fee29.jpg)  
例如，如图10-68 所示，网络中定义网络流$f(u,v)$是一条可行流。图中每条边所对应的序偶表示该边的容量和流量，第一个数字表示边的容量，第二个数字表示边的流量。  
下面结合图10-68 所示网络实例介绍网络流模型中与边相关的几个概念。可根据边的容量与流的大小关系对网络中的边进行分类：  
（1）满足$f(u,v)=c(u,v)$的边称为饱和边，如边(1,2)、 (2,3)  
（2）满足$f(u,v)<c(u,v)$的边称为非饱和边，如边(2,4)。  
（3）满足 $f(u,v)=0$ 的边称为零流边，如边 (3,4) ；满足 $f(u,v)>0$ 的边称为非零流 边，如边(5,4)。  
（4）既不是零流边也不是饱和边的边，称为弱流边，如边(5,6)  
如果把图10-78 看作是一个公路网，6 个结点分别表示6 座城镇，每条边上的权数表示两城镇间的距离。若现在需要从起点1 将一些物资运送到终点6，应怎样选择路线才能使总运输距离最短。我们知道，这样一类问题称为最短路径问题。类似的，如果把图10-1看作为一个输油管道网，结点1表示为发送点，结点6表示为接收点，其它点表示为中转站，各边的权数表示该段管道的最大运输油量。那么如何安排输油线路才能使从1到6的总运输量最大。这样一类问题就是最大流问题。  
最大流问题是网络优化中的一个典型的问题，简单地说，就是在满足容量约束的前提下将尽可能多的流从源结点流向汇结点。因此，最大流问题就是求流网络$G$中使其流量$f$达到最大的一个可行流，该可行流即为最大流。具体定义如下：  
【定义10.4.2】设有向图$G=\langle V,E\rangle$是任意给定的一个网络流图，若$f$是$G$ 中流量最大的的可行流，则称该可行流$f$是$G$ 的最大流，构构造网络流图$G$ 中最大流的问题，就称为网络流图的最大流问题。  
为了实现对最大流问题的求解，必须对网络流图中的增流空间进行合理的度量，通常使用一种名为残留网络的图模型实现这项工作。残留网络的具体定义如下：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图， $f$为$G$的一个流，对于$G$的任意一条边$(u,v)$，在不超过容量$c(u,v)$条件下，从$u$到$v$可压入的额外流量，称为$(u,v)$的残留容量。由$G$中所有边残留容量构成的带权有向图称为$G$的残留网络，记为$G_{f}=\langle V,E_{f}\rangle$。  
若$c_{f}(u,v)$为残留网络$G_{f}$中边$(u,v)$的残留容量，且边$(u,v)\in E$或边$(v,u)\in E$，则$(u,v)\in$$E_{f}$,$\,c_{f}(u,v)=c(u,v)-f(u,v)\,$。例如，若设$(u,v)$当前流量为(4,3)，此时$c(u,v)=4$，$f(u,v)$）$=3$，则有：$c_{f}(u,v)=1$。  
需要注意的是，残留网络具有这样的性质：假设从$_{.}u$到$v$已经有了3 个单位流量，那么从反方向上看，也就是从$v$ 到$u$ 就有了3 个单位的残留容量，这时$c_{f}(v,u)=3$。换句话说，从$u$ 到$v$ 有3 个单位流量，那么从$v$到$u$ 就有了将这3 个单位流量压回去的能力。因此，残留网络结点之间通常由双向带权边进行联结。例如，对于图10-69（a）所示的一个流网络$G$，图10-69（b）则表示该流网络𝐺的残留网络。  
![图10-69 流网络及其残留网络 ](images/d65d1c72064671125468548ae171a28ede5424f1d36d601972ed76c90131fc8c.jpg)  
对于任意给定的一个网络流图$G=\langle V,E\rangle$，可以通过其残留网络$G_{f}=\langle V,E_{f}\rangle$求得$G$的最大流。基本思路如下：首先，对所有的结点令初始状态时流的值为0，即对于$\forall u,v\in V$，有$f(u,v)=0$。然后，通过迭代方式其残留网络中不断寻找源点𝑠到汇点$t$之间的流量增广路径来增加网络流量值，直到残留网络没有这样的增广路径为止。  
因此，在残留网络$G_{f}=\langle V,E_{f}\rangle$寻找流量增广路径是最大流求解算法的关键。为正确理解该算法，现给出流网络增广路径的具体定义：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，$G_{f}=\langle V,E_{f}\rangle$为$G$在流$f$下的一个残留网络，则$G_{f}=\langle V,E_{f}\rangle$中任意一条从源点$s$到汇点$t$的简单路径$p$称为$G=\langle V,E\rangle$的一条流量增广路径，简称为增广路径。  
事实上，可将增广路径形象地理解为网络流图$G$中从源点𝑠到汇点𝑡的一条不违反流网络边容量限制的路径，并向这条路径压入一定的流量，以增加整个网络的流量值。例如，图10-69（b）所示的残留网络存在这样一条如图10-70 中加粗有向边所示的增广路径。  
![图10-70 增广路径 ](images/1e52dc98ce8f5b49283b093dbb72c0d5308ccdc9782306a98cb168474d58608f.jpg)  
![图10-71 流网络的一个切割](images/c52dd38b6f7d2bc46bb57e2440709d67355577a7b3d5fb2e920f10a5bfeb8598.jpg)  
若将图10-70 所示增广路径在流网络所对应每条边的流量增加4 个单位，得到一个新的流网络，其流量比原网络多4 个单位。然后，在新流网络所对应的残留网络中继续寻找新增广路径，直到找不到新增广路径为止。显然，现在的问题是：如果在残留网络$G_{f}=$$\langle V,E_{f}\rangle$中找不到增广路径，此时该残留网络所对应的流$f$是否就是流网络$G=\langle V,E\rangle$的最大流？要解决这个问题，必须进一步引入流网络切割的相关概念，具体如下：  
【定义10.4.4】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，如果将$G$的结点集合𝑉划分为𝑆和$T=V-S$两部分，使得源点$s\in S$且$t\in T$，则称$(S,T)$是$G=\langle V,E\rangle$的一个切割，简称为割。从集合 𝑆 到集合 𝑇 的所有有向边容量之和称为切割 $(S,T)$ 的容量，穿过切割 $(S,T)$所有边流量的代数和流量称为切割$(S,T)$的净流量，记为$f(S,T)$。  
主要注意的是，定义10.4.4 中边的流量带有正负方向，如果流从结点𝑆流向$T$，则该边的流量值为正，如果流从结点𝑇流向𝑆，则该边的流量值为负。例如，对图10-69（a）所示的流网络，可画一个如图10-71 所示的切割$(S,T)$，其容量为：  
$$
c(u,w)+c(v,x)=12+14=26
$$  
穿过该切割的净流量为：  
$$
f(u,w)+f(v,x)-f(w,v)=12+11-4=19
$$  
显然，对于任意一个切割，穿过该切割的净流量上界就是该切割的容量，即穿过切割的净流量不可能超过割的容量。由于流网络中所有切割的流都相等并且等于网络的流，因此，网络最大流必然无法超过网络的最小割。由此得到如下最大流最小割定理：  
【定理10.4.1】（最大流最小割定理）设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和$t$分别为其源点和汇点，则$G=\langle V,E\rangle$的最大流量等于其最小割切的容量。对于$G=\langle V,E\rangle$上的任意一个流$f$，以下三个结论彼此等价：  
(1) $f$是流网络$G=\langle V,E\rangle$的一个最大流；  
(2) 流网络$G=\langle V,E\rangle$的残留网络中不包括任何增广路径；  
(3) 存在流网络$G=\langle V,E\rangle$的某个切割$(S,T)$，满足：
$$
f(S,T)=c(S,T)
$$",可行流中除源点和汇点外，其余节点的净流之和为0
饱和边,分类,非饱和边,,"首先介绍流网络模型的相关基本概念及其数据描述。如同每条公路有运输量、每根水管有最大流量限制一样，网络流图的每条边都有容量，或者说每条边都有一定的流量。网络流图其实就是每条边具有附带容量（可理解为权值）的有向图。其具体定义如下：  
【定义10.4.1】设有向图$G=\langle V,E\rangle$，$V$中包含一个源结点𝑠和一个汇结点$t$，且每条边$(u,v)\in E$均有一个非负容量$c(u,v)\geq0$，若$(u,v)\notin E$，则规定其容量$c(u,v)=0$，此时称有向图$G$是一个网络流图，简称为流网络或网络。源结点$s$即起点，汇结点$t$即终点。网络流是定义在网络$G$中关于边的一个实函数，用$f(u,v)$表示有向边$(u,v)\in E$上结点$ u$到结点$v$的网络流。$f(u,v)$表示$u$ 到$v$的净流。  
例如，如果$_{u}$到$v$有6 个单位的实际流，且$v$到$u$有3 个单位的实际流，那么$f(u,v)=$3，$f(v,u)=-3$，互为相反数。净流是实际通过的流量矢量和，可类比合力的概念。  
满足以下三个性质的网络流$f$称之为可行流：  
（1）容量限制：对所有的$(u,v)\in E$，都有$f(u,v)\leq c(u,\textit{}v)$。即一条边的流不能超过它的容量。这也很容易理解，如同自来水管的水流自然不会超过水管本身的容量。  
（2）斜对称：对所有$(u,v)\in E$，都有$f(u,v)=-f(v,u)$。即点$\cdot u$到$v$的净流必须与点𝑣到$u$的净流相反。可以类比物理中矢量概念，如作用力与反作用力，强调的是其方向性。  
（3）流守恒：对所有$u\in V-\{s,t\}$，都有$\textstyle\sum_{v\in V}f(u,v)=0$。即除源结点$𝑠$和汇结点$𝑡$外，其余每个结点的净流之和为0。  
![图10-68 网络及可行流  ](images/bada5974bba3db0db4c82fa8e3076a8834542abfa1641f17fac232a32e6fee29.jpg)  
例如，如图10-68 所示，网络中定义网络流$f(u,v)$是一条可行流。图中每条边所对应的序偶表示该边的容量和流量，第一个数字表示边的容量，第二个数字表示边的流量。  
下面结合图10-68 所示网络实例介绍网络流模型中与边相关的几个概念。可根据边的容量与流的大小关系对网络中的边进行分类：  
（1）满足$f(u,v)=c(u,v)$的边称为饱和边，如边(1,2)、 (2,3)  
（2）满足$f(u,v)<c(u,v)$的边称为非饱和边，如边(2,4)。  
（3）满足 $f(u,v)=0$ 的边称为零流边，如边 (3,4) ；满足 $f(u,v)>0$ 的边称为非零流 边，如边(5,4)。  
（4）既不是零流边也不是饱和边的边，称为弱流边，如边(5,6)  
如果把图10-78 看作是一个公路网，6 个结点分别表示6 座城镇，每条边上的权数表示两城镇间的距离。若现在需要从起点1 将一些物资运送到终点6，应怎样选择路线才能使总运输距离最短。我们知道，这样一类问题称为最短路径问题。类似的，如果把图10-1看作为一个输油管道网，结点1表示为发送点，结点6表示为接收点，其它点表示为中转站，各边的权数表示该段管道的最大运输油量。那么如何安排输油线路才能使从1到6的总运输量最大。这样一类问题就是最大流问题。  
最大流问题是网络优化中的一个典型的问题，简单地说，就是在满足容量约束的前提下将尽可能多的流从源结点流向汇结点。因此，最大流问题就是求流网络$G$中使其流量$f$达到最大的一个可行流，该可行流即为最大流。具体定义如下：  
【定义10.4.2】设有向图$G=\langle V,E\rangle$是任意给定的一个网络流图，若$f$是$G$ 中流量最大的的可行流，则称该可行流$f$是$G$ 的最大流，构构造网络流图$G$ 中最大流的问题，就称为网络流图的最大流问题。  
为了实现对最大流问题的求解，必须对网络流图中的增流空间进行合理的度量，通常使用一种名为残留网络的图模型实现这项工作。残留网络的具体定义如下：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图， $f$为$G$的一个流，对于$G$的任意一条边$(u,v)$，在不超过容量$c(u,v)$条件下，从$u$到$v$可压入的额外流量，称为$(u,v)$的残留容量。由$G$中所有边残留容量构成的带权有向图称为$G$的残留网络，记为$G_{f}=\langle V,E_{f}\rangle$。  
若$c_{f}(u,v)$为残留网络$G_{f}$中边$(u,v)$的残留容量，且边$(u,v)\in E$或边$(v,u)\in E$，则$(u,v)\in$$E_{f}$,$\,c_{f}(u,v)=c(u,v)-f(u,v)\,$。例如，若设$(u,v)$当前流量为(4,3)，此时$c(u,v)=4$，$f(u,v)$）$=3$，则有：$c_{f}(u,v)=1$。  
需要注意的是，残留网络具有这样的性质：假设从$_{.}u$到$v$已经有了3 个单位流量，那么从反方向上看，也就是从$v$ 到$u$ 就有了3 个单位的残留容量，这时$c_{f}(v,u)=3$。换句话说，从$u$ 到$v$ 有3 个单位流量，那么从$v$到$u$ 就有了将这3 个单位流量压回去的能力。因此，残留网络结点之间通常由双向带权边进行联结。例如，对于图10-69（a）所示的一个流网络$G$，图10-69（b）则表示该流网络𝐺的残留网络。  
![图10-69 流网络及其残留网络 ](images/d65d1c72064671125468548ae171a28ede5424f1d36d601972ed76c90131fc8c.jpg)  
对于任意给定的一个网络流图$G=\langle V,E\rangle$，可以通过其残留网络$G_{f}=\langle V,E_{f}\rangle$求得$G$的最大流。基本思路如下：首先，对所有的结点令初始状态时流的值为0，即对于$\forall u,v\in V$，有$f(u,v)=0$。然后，通过迭代方式其残留网络中不断寻找源点𝑠到汇点$t$之间的流量增广路径来增加网络流量值，直到残留网络没有这样的增广路径为止。  
因此，在残留网络$G_{f}=\langle V,E_{f}\rangle$寻找流量增广路径是最大流求解算法的关键。为正确理解该算法，现给出流网络增广路径的具体定义：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，$G_{f}=\langle V,E_{f}\rangle$为$G$在流$f$下的一个残留网络，则$G_{f}=\langle V,E_{f}\rangle$中任意一条从源点$s$到汇点$t$的简单路径$p$称为$G=\langle V,E\rangle$的一条流量增广路径，简称为增广路径。  
事实上，可将增广路径形象地理解为网络流图$G$中从源点𝑠到汇点𝑡的一条不违反流网络边容量限制的路径，并向这条路径压入一定的流量，以增加整个网络的流量值。例如，图10-69（b）所示的残留网络存在这样一条如图10-70 中加粗有向边所示的增广路径。  
![图10-70 增广路径 ](images/1e52dc98ce8f5b49283b093dbb72c0d5308ccdc9782306a98cb168474d58608f.jpg)  
![图10-71 流网络的一个切割](images/c52dd38b6f7d2bc46bb57e2440709d67355577a7b3d5fb2e920f10a5bfeb8598.jpg)  
若将图10-70 所示增广路径在流网络所对应每条边的流量增加4 个单位，得到一个新的流网络，其流量比原网络多4 个单位。然后，在新流网络所对应的残留网络中继续寻找新增广路径，直到找不到新增广路径为止。显然，现在的问题是：如果在残留网络$G_{f}=$$\langle V,E_{f}\rangle$中找不到增广路径，此时该残留网络所对应的流$f$是否就是流网络$G=\langle V,E\rangle$的最大流？要解决这个问题，必须进一步引入流网络切割的相关概念，具体如下：  
【定义10.4.4】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，如果将$G$的结点集合𝑉划分为𝑆和$T=V-S$两部分，使得源点$s\in S$且$t\in T$，则称$(S,T)$是$G=\langle V,E\rangle$的一个切割，简称为割。从集合 𝑆 到集合 𝑇 的所有有向边容量之和称为切割 $(S,T)$ 的容量，穿过切割 $(S,T)$所有边流量的代数和流量称为切割$(S,T)$的净流量，记为$f(S,T)$。  
主要注意的是，定义10.4.4 中边的流量带有正负方向，如果流从结点𝑆流向$T$，则该边的流量值为正，如果流从结点𝑇流向𝑆，则该边的流量值为负。例如，对图10-69（a）所示的流网络，可画一个如图10-71 所示的切割$(S,T)$，其容量为：  
$$
c(u,w)+c(v,x)=12+14=26
$$  
穿过该切割的净流量为：  
$$
f(u,w)+f(v,x)-f(w,v)=12+11-4=19
$$  
显然，对于任意一个切割，穿过该切割的净流量上界就是该切割的容量，即穿过切割的净流量不可能超过割的容量。由于流网络中所有切割的流都相等并且等于网络的流，因此，网络最大流必然无法超过网络的最小割。由此得到如下最大流最小割定理：  
【定理10.4.1】（最大流最小割定理）设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和$t$分别为其源点和汇点，则$G=\langle V,E\rangle$的最大流量等于其最小割切的容量。对于$G=\langle V,E\rangle$上的任意一个流$f$，以下三个结论彼此等价：  
(1) $f$是流网络$G=\langle V,E\rangle$的一个最大流；  
(2) 流网络$G=\langle V,E\rangle$的残留网络中不包括任何增广路径；  
(3) 存在流网络$G=\langle V,E\rangle$的某个切割$(S,T)$，满足：
$$
f(S,T)=c(S,T)
$$",根据边的流量与容量的关系，边可分为饱和边和非饱和边
零流边,分类,非零流边,,"首先介绍流网络模型的相关基本概念及其数据描述。如同每条公路有运输量、每根水管有最大流量限制一样，网络流图的每条边都有容量，或者说每条边都有一定的流量。网络流图其实就是每条边具有附带容量（可理解为权值）的有向图。其具体定义如下：  
【定义10.4.1】设有向图$G=\langle V,E\rangle$，$V$中包含一个源结点𝑠和一个汇结点$t$，且每条边$(u,v)\in E$均有一个非负容量$c(u,v)\geq0$，若$(u,v)\notin E$，则规定其容量$c(u,v)=0$，此时称有向图$G$是一个网络流图，简称为流网络或网络。源结点$s$即起点，汇结点$t$即终点。网络流是定义在网络$G$中关于边的一个实函数，用$f(u,v)$表示有向边$(u,v)\in E$上结点$ u$到结点$v$的网络流。$f(u,v)$表示$u$ 到$v$的净流。  
例如，如果$_{u}$到$v$有6 个单位的实际流，且$v$到$u$有3 个单位的实际流，那么$f(u,v)=$3，$f(v,u)=-3$，互为相反数。净流是实际通过的流量矢量和，可类比合力的概念。  
满足以下三个性质的网络流$f$称之为可行流：  
（1）容量限制：对所有的$(u,v)\in E$，都有$f(u,v)\leq c(u,\textit{}v)$。即一条边的流不能超过它的容量。这也很容易理解，如同自来水管的水流自然不会超过水管本身的容量。  
（2）斜对称：对所有$(u,v)\in E$，都有$f(u,v)=-f(v,u)$。即点$\cdot u$到$v$的净流必须与点𝑣到$u$的净流相反。可以类比物理中矢量概念，如作用力与反作用力，强调的是其方向性。  
（3）流守恒：对所有$u\in V-\{s,t\}$，都有$\textstyle\sum_{v\in V}f(u,v)=0$。即除源结点$𝑠$和汇结点$𝑡$外，其余每个结点的净流之和为0。  
![图10-68 网络及可行流  ](images/bada5974bba3db0db4c82fa8e3076a8834542abfa1641f17fac232a32e6fee29.jpg)  
例如，如图10-68 所示，网络中定义网络流$f(u,v)$是一条可行流。图中每条边所对应的序偶表示该边的容量和流量，第一个数字表示边的容量，第二个数字表示边的流量。  
下面结合图10-68 所示网络实例介绍网络流模型中与边相关的几个概念。可根据边的容量与流的大小关系对网络中的边进行分类：  
（1）满足$f(u,v)=c(u,v)$的边称为饱和边，如边(1,2)、 (2,3)  
（2）满足$f(u,v)<c(u,v)$的边称为非饱和边，如边(2,4)。  
（3）满足 $f(u,v)=0$ 的边称为零流边，如边 (3,4) ；满足 $f(u,v)>0$ 的边称为非零流 边，如边(5,4)。  
（4）既不是零流边也不是饱和边的边，称为弱流边，如边(5,6)  
如果把图10-78 看作是一个公路网，6 个结点分别表示6 座城镇，每条边上的权数表示两城镇间的距离。若现在需要从起点1 将一些物资运送到终点6，应怎样选择路线才能使总运输距离最短。我们知道，这样一类问题称为最短路径问题。类似的，如果把图10-1看作为一个输油管道网，结点1表示为发送点，结点6表示为接收点，其它点表示为中转站，各边的权数表示该段管道的最大运输油量。那么如何安排输油线路才能使从1到6的总运输量最大。这样一类问题就是最大流问题。  
最大流问题是网络优化中的一个典型的问题，简单地说，就是在满足容量约束的前提下将尽可能多的流从源结点流向汇结点。因此，最大流问题就是求流网络$G$中使其流量$f$达到最大的一个可行流，该可行流即为最大流。具体定义如下：  
【定义10.4.2】设有向图$G=\langle V,E\rangle$是任意给定的一个网络流图，若$f$是$G$ 中流量最大的的可行流，则称该可行流$f$是$G$ 的最大流，构构造网络流图$G$ 中最大流的问题，就称为网络流图的最大流问题。  
为了实现对最大流问题的求解，必须对网络流图中的增流空间进行合理的度量，通常使用一种名为残留网络的图模型实现这项工作。残留网络的具体定义如下：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图， $f$为$G$的一个流，对于$G$的任意一条边$(u,v)$，在不超过容量$c(u,v)$条件下，从$u$到$v$可压入的额外流量，称为$(u,v)$的残留容量。由$G$中所有边残留容量构成的带权有向图称为$G$的残留网络，记为$G_{f}=\langle V,E_{f}\rangle$。  
若$c_{f}(u,v)$为残留网络$G_{f}$中边$(u,v)$的残留容量，且边$(u,v)\in E$或边$(v,u)\in E$，则$(u,v)\in$$E_{f}$,$\,c_{f}(u,v)=c(u,v)-f(u,v)\,$。例如，若设$(u,v)$当前流量为(4,3)，此时$c(u,v)=4$，$f(u,v)$）$=3$，则有：$c_{f}(u,v)=1$。  
需要注意的是，残留网络具有这样的性质：假设从$_{.}u$到$v$已经有了3 个单位流量，那么从反方向上看，也就是从$v$ 到$u$ 就有了3 个单位的残留容量，这时$c_{f}(v,u)=3$。换句话说，从$u$ 到$v$ 有3 个单位流量，那么从$v$到$u$ 就有了将这3 个单位流量压回去的能力。因此，残留网络结点之间通常由双向带权边进行联结。例如，对于图10-69（a）所示的一个流网络$G$，图10-69（b）则表示该流网络𝐺的残留网络。  
![图10-69 流网络及其残留网络 ](images/d65d1c72064671125468548ae171a28ede5424f1d36d601972ed76c90131fc8c.jpg)  
对于任意给定的一个网络流图$G=\langle V,E\rangle$，可以通过其残留网络$G_{f}=\langle V,E_{f}\rangle$求得$G$的最大流。基本思路如下：首先，对所有的结点令初始状态时流的值为0，即对于$\forall u,v\in V$，有$f(u,v)=0$。然后，通过迭代方式其残留网络中不断寻找源点𝑠到汇点$t$之间的流量增广路径来增加网络流量值，直到残留网络没有这样的增广路径为止。  
因此，在残留网络$G_{f}=\langle V,E_{f}\rangle$寻找流量增广路径是最大流求解算法的关键。为正确理解该算法，现给出流网络增广路径的具体定义：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，$G_{f}=\langle V,E_{f}\rangle$为$G$在流$f$下的一个残留网络，则$G_{f}=\langle V,E_{f}\rangle$中任意一条从源点$s$到汇点$t$的简单路径$p$称为$G=\langle V,E\rangle$的一条流量增广路径，简称为增广路径。  
事实上，可将增广路径形象地理解为网络流图$G$中从源点𝑠到汇点𝑡的一条不违反流网络边容量限制的路径，并向这条路径压入一定的流量，以增加整个网络的流量值。例如，图10-69（b）所示的残留网络存在这样一条如图10-70 中加粗有向边所示的增广路径。  
![图10-70 增广路径 ](images/1e52dc98ce8f5b49283b093dbb72c0d5308ccdc9782306a98cb168474d58608f.jpg)  
![图10-71 流网络的一个切割](images/c52dd38b6f7d2bc46bb57e2440709d67355577a7b3d5fb2e920f10a5bfeb8598.jpg)  
若将图10-70 所示增广路径在流网络所对应每条边的流量增加4 个单位，得到一个新的流网络，其流量比原网络多4 个单位。然后，在新流网络所对应的残留网络中继续寻找新增广路径，直到找不到新增广路径为止。显然，现在的问题是：如果在残留网络$G_{f}=$$\langle V,E_{f}\rangle$中找不到增广路径，此时该残留网络所对应的流$f$是否就是流网络$G=\langle V,E\rangle$的最大流？要解决这个问题，必须进一步引入流网络切割的相关概念，具体如下：  
【定义10.4.4】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，如果将$G$的结点集合𝑉划分为𝑆和$T=V-S$两部分，使得源点$s\in S$且$t\in T$，则称$(S,T)$是$G=\langle V,E\rangle$的一个切割，简称为割。从集合 𝑆 到集合 𝑇 的所有有向边容量之和称为切割 $(S,T)$ 的容量，穿过切割 $(S,T)$所有边流量的代数和流量称为切割$(S,T)$的净流量，记为$f(S,T)$。  
主要注意的是，定义10.4.4 中边的流量带有正负方向，如果流从结点𝑆流向$T$，则该边的流量值为正，如果流从结点𝑇流向𝑆，则该边的流量值为负。例如，对图10-69（a）所示的流网络，可画一个如图10-71 所示的切割$(S,T)$，其容量为：  
$$
c(u,w)+c(v,x)=12+14=26
$$  
穿过该切割的净流量为：  
$$
f(u,w)+f(v,x)-f(w,v)=12+11-4=19
$$  
显然，对于任意一个切割，穿过该切割的净流量上界就是该切割的容量，即穿过切割的净流量不可能超过割的容量。由于流网络中所有切割的流都相等并且等于网络的流，因此，网络最大流必然无法超过网络的最小割。由此得到如下最大流最小割定理：  
【定理10.4.1】（最大流最小割定理）设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和$t$分别为其源点和汇点，则$G=\langle V,E\rangle$的最大流量等于其最小割切的容量。对于$G=\langle V,E\rangle$上的任意一个流$f$，以下三个结论彼此等价：  
(1) $f$是流网络$G=\langle V,E\rangle$的一个最大流；  
(2) 流网络$G=\langle V,E\rangle$的残留网络中不包括任何增广路径；  
(3) 存在流网络$G=\langle V,E\rangle$的某个切割$(S,T)$，满足：
$$
f(S,T)=c(S,T)
$$",根据边的流量是否为0，边可分为零流边和非零流边
弱流边,分类,边,,"首先介绍流网络模型的相关基本概念及其数据描述。如同每条公路有运输量、每根水管有最大流量限制一样，网络流图的每条边都有容量，或者说每条边都有一定的流量。网络流图其实就是每条边具有附带容量（可理解为权值）的有向图。其具体定义如下：  
【定义10.4.1】设有向图$G=\langle V,E\rangle$，$V$中包含一个源结点𝑠和一个汇结点$t$，且每条边$(u,v)\in E$均有一个非负容量$c(u,v)\geq0$，若$(u,v)\notin E$，则规定其容量$c(u,v)=0$，此时称有向图$G$是一个网络流图，简称为流网络或网络。源结点$s$即起点，汇结点$t$即终点。网络流是定义在网络$G$中关于边的一个实函数，用$f(u,v)$表示有向边$(u,v)\in E$上结点$ u$到结点$v$的网络流。$f(u,v)$表示$u$ 到$v$的净流。  
例如，如果$_{u}$到$v$有6 个单位的实际流，且$v$到$u$有3 个单位的实际流，那么$f(u,v)=$3，$f(v,u)=-3$，互为相反数。净流是实际通过的流量矢量和，可类比合力的概念。  
满足以下三个性质的网络流$f$称之为可行流：  
（1）容量限制：对所有的$(u,v)\in E$，都有$f(u,v)\leq c(u,\textit{}v)$。即一条边的流不能超过它的容量。这也很容易理解，如同自来水管的水流自然不会超过水管本身的容量。  
（2）斜对称：对所有$(u,v)\in E$，都有$f(u,v)=-f(v,u)$。即点$\cdot u$到$v$的净流必须与点𝑣到$u$的净流相反。可以类比物理中矢量概念，如作用力与反作用力，强调的是其方向性。  
（3）流守恒：对所有$u\in V-\{s,t\}$，都有$\textstyle\sum_{v\in V}f(u,v)=0$。即除源结点$𝑠$和汇结点$𝑡$外，其余每个结点的净流之和为0。  
![图10-68 网络及可行流  ](images/bada5974bba3db0db4c82fa8e3076a8834542abfa1641f17fac232a32e6fee29.jpg)  
例如，如图10-68 所示，网络中定义网络流$f(u,v)$是一条可行流。图中每条边所对应的序偶表示该边的容量和流量，第一个数字表示边的容量，第二个数字表示边的流量。  
下面结合图10-68 所示网络实例介绍网络流模型中与边相关的几个概念。可根据边的容量与流的大小关系对网络中的边进行分类：  
（1）满足$f(u,v)=c(u,v)$的边称为饱和边，如边(1,2)、 (2,3)  
（2）满足$f(u,v)<c(u,v)$的边称为非饱和边，如边(2,4)。  
（3）满足 $f(u,v)=0$ 的边称为零流边，如边 (3,4) ；满足 $f(u,v)>0$ 的边称为非零流 边，如边(5,4)。  
（4）既不是零流边也不是饱和边的边，称为弱流边，如边(5,6)  
如果把图10-78 看作是一个公路网，6 个结点分别表示6 座城镇，每条边上的权数表示两城镇间的距离。若现在需要从起点1 将一些物资运送到终点6，应怎样选择路线才能使总运输距离最短。我们知道，这样一类问题称为最短路径问题。类似的，如果把图10-1看作为一个输油管道网，结点1表示为发送点，结点6表示为接收点，其它点表示为中转站，各边的权数表示该段管道的最大运输油量。那么如何安排输油线路才能使从1到6的总运输量最大。这样一类问题就是最大流问题。  
最大流问题是网络优化中的一个典型的问题，简单地说，就是在满足容量约束的前提下将尽可能多的流从源结点流向汇结点。因此，最大流问题就是求流网络$G$中使其流量$f$达到最大的一个可行流，该可行流即为最大流。具体定义如下：  
【定义10.4.2】设有向图$G=\langle V,E\rangle$是任意给定的一个网络流图，若$f$是$G$ 中流量最大的的可行流，则称该可行流$f$是$G$ 的最大流，构构造网络流图$G$ 中最大流的问题，就称为网络流图的最大流问题。  
为了实现对最大流问题的求解，必须对网络流图中的增流空间进行合理的度量，通常使用一种名为残留网络的图模型实现这项工作。残留网络的具体定义如下：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图， $f$为$G$的一个流，对于$G$的任意一条边$(u,v)$，在不超过容量$c(u,v)$条件下，从$u$到$v$可压入的额外流量，称为$(u,v)$的残留容量。由$G$中所有边残留容量构成的带权有向图称为$G$的残留网络，记为$G_{f}=\langle V,E_{f}\rangle$。  
若$c_{f}(u,v)$为残留网络$G_{f}$中边$(u,v)$的残留容量，且边$(u,v)\in E$或边$(v,u)\in E$，则$(u,v)\in$$E_{f}$,$\,c_{f}(u,v)=c(u,v)-f(u,v)\,$。例如，若设$(u,v)$当前流量为(4,3)，此时$c(u,v)=4$，$f(u,v)$）$=3$，则有：$c_{f}(u,v)=1$。  
需要注意的是，残留网络具有这样的性质：假设从$_{.}u$到$v$已经有了3 个单位流量，那么从反方向上看，也就是从$v$ 到$u$ 就有了3 个单位的残留容量，这时$c_{f}(v,u)=3$。换句话说，从$u$ 到$v$ 有3 个单位流量，那么从$v$到$u$ 就有了将这3 个单位流量压回去的能力。因此，残留网络结点之间通常由双向带权边进行联结。例如，对于图10-69（a）所示的一个流网络$G$，图10-69（b）则表示该流网络𝐺的残留网络。  
![图10-69 流网络及其残留网络 ](images/d65d1c72064671125468548ae171a28ede5424f1d36d601972ed76c90131fc8c.jpg)  
对于任意给定的一个网络流图$G=\langle V,E\rangle$，可以通过其残留网络$G_{f}=\langle V,E_{f}\rangle$求得$G$的最大流。基本思路如下：首先，对所有的结点令初始状态时流的值为0，即对于$\forall u,v\in V$，有$f(u,v)=0$。然后，通过迭代方式其残留网络中不断寻找源点𝑠到汇点$t$之间的流量增广路径来增加网络流量值，直到残留网络没有这样的增广路径为止。  
因此，在残留网络$G_{f}=\langle V,E_{f}\rangle$寻找流量增广路径是最大流求解算法的关键。为正确理解该算法，现给出流网络增广路径的具体定义：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，$G_{f}=\langle V,E_{f}\rangle$为$G$在流$f$下的一个残留网络，则$G_{f}=\langle V,E_{f}\rangle$中任意一条从源点$s$到汇点$t$的简单路径$p$称为$G=\langle V,E\rangle$的一条流量增广路径，简称为增广路径。  
事实上，可将增广路径形象地理解为网络流图$G$中从源点𝑠到汇点𝑡的一条不违反流网络边容量限制的路径，并向这条路径压入一定的流量，以增加整个网络的流量值。例如，图10-69（b）所示的残留网络存在这样一条如图10-70 中加粗有向边所示的增广路径。  
![图10-70 增广路径 ](images/1e52dc98ce8f5b49283b093dbb72c0d5308ccdc9782306a98cb168474d58608f.jpg)  
![图10-71 流网络的一个切割](images/c52dd38b6f7d2bc46bb57e2440709d67355577a7b3d5fb2e920f10a5bfeb8598.jpg)  
若将图10-70 所示增广路径在流网络所对应每条边的流量增加4 个单位，得到一个新的流网络，其流量比原网络多4 个单位。然后，在新流网络所对应的残留网络中继续寻找新增广路径，直到找不到新增广路径为止。显然，现在的问题是：如果在残留网络$G_{f}=$$\langle V,E_{f}\rangle$中找不到增广路径，此时该残留网络所对应的流$f$是否就是流网络$G=\langle V,E\rangle$的最大流？要解决这个问题，必须进一步引入流网络切割的相关概念，具体如下：  
【定义10.4.4】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，如果将$G$的结点集合𝑉划分为𝑆和$T=V-S$两部分，使得源点$s\in S$且$t\in T$，则称$(S,T)$是$G=\langle V,E\rangle$的一个切割，简称为割。从集合 𝑆 到集合 𝑇 的所有有向边容量之和称为切割 $(S,T)$ 的容量，穿过切割 $(S,T)$所有边流量的代数和流量称为切割$(S,T)$的净流量，记为$f(S,T)$。  
主要注意的是，定义10.4.4 中边的流量带有正负方向，如果流从结点𝑆流向$T$，则该边的流量值为正，如果流从结点𝑇流向𝑆，则该边的流量值为负。例如，对图10-69（a）所示的流网络，可画一个如图10-71 所示的切割$(S,T)$，其容量为：  
$$
c(u,w)+c(v,x)=12+14=26
$$  
穿过该切割的净流量为：  
$$
f(u,w)+f(v,x)-f(w,v)=12+11-4=19
$$  
显然，对于任意一个切割，穿过该切割的净流量上界就是该切割的容量，即穿过切割的净流量不可能超过割的容量。由于流网络中所有切割的流都相等并且等于网络的流，因此，网络最大流必然无法超过网络的最小割。由此得到如下最大流最小割定理：  
【定理10.4.1】（最大流最小割定理）设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和$t$分别为其源点和汇点，则$G=\langle V,E\rangle$的最大流量等于其最小割切的容量。对于$G=\langle V,E\rangle$上的任意一个流$f$，以下三个结论彼此等价：  
(1) $f$是流网络$G=\langle V,E\rangle$的一个最大流；  
(2) 流网络$G=\langle V,E\rangle$的残留网络中不包括任何增广路径；  
(3) 存在流网络$G=\langle V,E\rangle$的某个切割$(S,T)$，满足：
$$
f(S,T)=c(S,T)
$$",既不是零流边也不是饱和边的边称为弱流边
最大流问题,求解,流网络,,"首先介绍流网络模型的相关基本概念及其数据描述。如同每条公路有运输量、每根水管有最大流量限制一样，网络流图的每条边都有容量，或者说每条边都有一定的流量。网络流图其实就是每条边具有附带容量（可理解为权值）的有向图。其具体定义如下：  
【定义10.4.1】设有向图$G=\langle V,E\rangle$，$V$中包含一个源结点𝑠和一个汇结点$t$，且每条边$(u,v)\in E$均有一个非负容量$c(u,v)\geq0$，若$(u,v)\notin E$，则规定其容量$c(u,v)=0$，此时称有向图$G$是一个网络流图，简称为流网络或网络。源结点$s$即起点，汇结点$t$即终点。网络流是定义在网络$G$中关于边的一个实函数，用$f(u,v)$表示有向边$(u,v)\in E$上结点$ u$到结点$v$的网络流。$f(u,v)$表示$u$ 到$v$的净流。  
例如，如果$_{u}$到$v$有6 个单位的实际流，且$v$到$u$有3 个单位的实际流，那么$f(u,v)=$3，$f(v,u)=-3$，互为相反数。净流是实际通过的流量矢量和，可类比合力的概念。  
满足以下三个性质的网络流$f$称之为可行流：  
（1）容量限制：对所有的$(u,v)\in E$，都有$f(u,v)\leq c(u,\textit{}v)$。即一条边的流不能超过它的容量。这也很容易理解，如同自来水管的水流自然不会超过水管本身的容量。  
（2）斜对称：对所有$(u,v)\in E$，都有$f(u,v)=-f(v,u)$。即点$\cdot u$到$v$的净流必须与点𝑣到$u$的净流相反。可以类比物理中矢量概念，如作用力与反作用力，强调的是其方向性。  
（3）流守恒：对所有$u\in V-\{s,t\}$，都有$\textstyle\sum_{v\in V}f(u,v)=0$。即除源结点$𝑠$和汇结点$𝑡$外，其余每个结点的净流之和为0。  
![图10-68 网络及可行流  ](images/bada5974bba3db0db4c82fa8e3076a8834542abfa1641f17fac232a32e6fee29.jpg)  
例如，如图10-68 所示，网络中定义网络流$f(u,v)$是一条可行流。图中每条边所对应的序偶表示该边的容量和流量，第一个数字表示边的容量，第二个数字表示边的流量。  
下面结合图10-68 所示网络实例介绍网络流模型中与边相关的几个概念。可根据边的容量与流的大小关系对网络中的边进行分类：  
（1）满足$f(u,v)=c(u,v)$的边称为饱和边，如边(1,2)、 (2,3)  
（2）满足$f(u,v)<c(u,v)$的边称为非饱和边，如边(2,4)。  
（3）满足 $f(u,v)=0$ 的边称为零流边，如边 (3,4) ；满足 $f(u,v)>0$ 的边称为非零流 边，如边(5,4)。  
（4）既不是零流边也不是饱和边的边，称为弱流边，如边(5,6)  
如果把图10-78 看作是一个公路网，6 个结点分别表示6 座城镇，每条边上的权数表示两城镇间的距离。若现在需要从起点1 将一些物资运送到终点6，应怎样选择路线才能使总运输距离最短。我们知道，这样一类问题称为最短路径问题。类似的，如果把图10-1看作为一个输油管道网，结点1表示为发送点，结点6表示为接收点，其它点表示为中转站，各边的权数表示该段管道的最大运输油量。那么如何安排输油线路才能使从1到6的总运输量最大。这样一类问题就是最大流问题。  
最大流问题是网络优化中的一个典型的问题，简单地说，就是在满足容量约束的前提下将尽可能多的流从源结点流向汇结点。因此，最大流问题就是求流网络$G$中使其流量$f$达到最大的一个可行流，该可行流即为最大流。具体定义如下：  
【定义10.4.2】设有向图$G=\langle V,E\rangle$是任意给定的一个网络流图，若$f$是$G$ 中流量最大的的可行流，则称该可行流$f$是$G$ 的最大流，构构造网络流图$G$ 中最大流的问题，就称为网络流图的最大流问题。  
为了实现对最大流问题的求解，必须对网络流图中的增流空间进行合理的度量，通常使用一种名为残留网络的图模型实现这项工作。残留网络的具体定义如下：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图， $f$为$G$的一个流，对于$G$的任意一条边$(u,v)$，在不超过容量$c(u,v)$条件下，从$u$到$v$可压入的额外流量，称为$(u,v)$的残留容量。由$G$中所有边残留容量构成的带权有向图称为$G$的残留网络，记为$G_{f}=\langle V,E_{f}\rangle$。  
若$c_{f}(u,v)$为残留网络$G_{f}$中边$(u,v)$的残留容量，且边$(u,v)\in E$或边$(v,u)\in E$，则$(u,v)\in$$E_{f}$,$\,c_{f}(u,v)=c(u,v)-f(u,v)\,$。例如，若设$(u,v)$当前流量为(4,3)，此时$c(u,v)=4$，$f(u,v)$）$=3$，则有：$c_{f}(u,v)=1$。  
需要注意的是，残留网络具有这样的性质：假设从$_{.}u$到$v$已经有了3 个单位流量，那么从反方向上看，也就是从$v$ 到$u$ 就有了3 个单位的残留容量，这时$c_{f}(v,u)=3$。换句话说，从$u$ 到$v$ 有3 个单位流量，那么从$v$到$u$ 就有了将这3 个单位流量压回去的能力。因此，残留网络结点之间通常由双向带权边进行联结。例如，对于图10-69（a）所示的一个流网络$G$，图10-69（b）则表示该流网络𝐺的残留网络。  
![图10-69 流网络及其残留网络 ](images/d65d1c72064671125468548ae171a28ede5424f1d36d601972ed76c90131fc8c.jpg)  
对于任意给定的一个网络流图$G=\langle V,E\rangle$，可以通过其残留网络$G_{f}=\langle V,E_{f}\rangle$求得$G$的最大流。基本思路如下：首先，对所有的结点令初始状态时流的值为0，即对于$\forall u,v\in V$，有$f(u,v)=0$。然后，通过迭代方式其残留网络中不断寻找源点𝑠到汇点$t$之间的流量增广路径来增加网络流量值，直到残留网络没有这样的增广路径为止。  
因此，在残留网络$G_{f}=\langle V,E_{f}\rangle$寻找流量增广路径是最大流求解算法的关键。为正确理解该算法，现给出流网络增广路径的具体定义：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，$G_{f}=\langle V,E_{f}\rangle$为$G$在流$f$下的一个残留网络，则$G_{f}=\langle V,E_{f}\rangle$中任意一条从源点$s$到汇点$t$的简单路径$p$称为$G=\langle V,E\rangle$的一条流量增广路径，简称为增广路径。  
事实上，可将增广路径形象地理解为网络流图$G$中从源点𝑠到汇点𝑡的一条不违反流网络边容量限制的路径，并向这条路径压入一定的流量，以增加整个网络的流量值。例如，图10-69（b）所示的残留网络存在这样一条如图10-70 中加粗有向边所示的增广路径。  
![图10-70 增广路径 ](images/1e52dc98ce8f5b49283b093dbb72c0d5308ccdc9782306a98cb168474d58608f.jpg)  
![图10-71 流网络的一个切割](images/c52dd38b6f7d2bc46bb57e2440709d67355577a7b3d5fb2e920f10a5bfeb8598.jpg)  
若将图10-70 所示增广路径在流网络所对应每条边的流量增加4 个单位，得到一个新的流网络，其流量比原网络多4 个单位。然后，在新流网络所对应的残留网络中继续寻找新增广路径，直到找不到新增广路径为止。显然，现在的问题是：如果在残留网络$G_{f}=$$\langle V,E_{f}\rangle$中找不到增广路径，此时该残留网络所对应的流$f$是否就是流网络$G=\langle V,E\rangle$的最大流？要解决这个问题，必须进一步引入流网络切割的相关概念，具体如下：  
【定义10.4.4】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，如果将$G$的结点集合𝑉划分为𝑆和$T=V-S$两部分，使得源点$s\in S$且$t\in T$，则称$(S,T)$是$G=\langle V,E\rangle$的一个切割，简称为割。从集合 𝑆 到集合 𝑇 的所有有向边容量之和称为切割 $(S,T)$ 的容量，穿过切割 $(S,T)$所有边流量的代数和流量称为切割$(S,T)$的净流量，记为$f(S,T)$。  
主要注意的是，定义10.4.4 中边的流量带有正负方向，如果流从结点𝑆流向$T$，则该边的流量值为正，如果流从结点𝑇流向𝑆，则该边的流量值为负。例如，对图10-69（a）所示的流网络，可画一个如图10-71 所示的切割$(S,T)$，其容量为：  
$$
c(u,w)+c(v,x)=12+14=26
$$  
穿过该切割的净流量为：  
$$
f(u,w)+f(v,x)-f(w,v)=12+11-4=19
$$  
显然，对于任意一个切割，穿过该切割的净流量上界就是该切割的容量，即穿过切割的净流量不可能超过割的容量。由于流网络中所有切割的流都相等并且等于网络的流，因此，网络最大流必然无法超过网络的最小割。由此得到如下最大流最小割定理：  
【定理10.4.1】（最大流最小割定理）设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和$t$分别为其源点和汇点，则$G=\langle V,E\rangle$的最大流量等于其最小割切的容量。对于$G=\langle V,E\rangle$上的任意一个流$f$，以下三个结论彼此等价：  
(1) $f$是流网络$G=\langle V,E\rangle$的一个最大流；  
(2) 流网络$G=\langle V,E\rangle$的残留网络中不包括任何增广路径；  
(3) 存在流网络$G=\langle V,E\rangle$的某个切割$(S,T)$，满足：
$$
f(S,T)=c(S,T)
$$",最大流问题是求解流网络中流量最大的可行流
残留网络,衍生,流网络,,"首先介绍流网络模型的相关基本概念及其数据描述。如同每条公路有运输量、每根水管有最大流量限制一样，网络流图的每条边都有容量，或者说每条边都有一定的流量。网络流图其实就是每条边具有附带容量（可理解为权值）的有向图。其具体定义如下：  
【定义10.4.1】设有向图$G=\langle V,E\rangle$，$V$中包含一个源结点𝑠和一个汇结点$t$，且每条边$(u,v)\in E$均有一个非负容量$c(u,v)\geq0$，若$(u,v)\notin E$，则规定其容量$c(u,v)=0$，此时称有向图$G$是一个网络流图，简称为流网络或网络。源结点$s$即起点，汇结点$t$即终点。网络流是定义在网络$G$中关于边的一个实函数，用$f(u,v)$表示有向边$(u,v)\in E$上结点$ u$到结点$v$的网络流。$f(u,v)$表示$u$ 到$v$的净流。  
例如，如果$_{u}$到$v$有6 个单位的实际流，且$v$到$u$有3 个单位的实际流，那么$f(u,v)=$3，$f(v,u)=-3$，互为相反数。净流是实际通过的流量矢量和，可类比合力的概念。  
满足以下三个性质的网络流$f$称之为可行流：  
（1）容量限制：对所有的$(u,v)\in E$，都有$f(u,v)\leq c(u,\textit{}v)$。即一条边的流不能超过它的容量。这也很容易理解，如同自来水管的水流自然不会超过水管本身的容量。  
（2）斜对称：对所有$(u,v)\in E$，都有$f(u,v)=-f(v,u)$。即点$\cdot u$到$v$的净流必须与点𝑣到$u$的净流相反。可以类比物理中矢量概念，如作用力与反作用力，强调的是其方向性。  
（3）流守恒：对所有$u\in V-\{s,t\}$，都有$\textstyle\sum_{v\in V}f(u,v)=0$。即除源结点$𝑠$和汇结点$𝑡$外，其余每个结点的净流之和为0。  
![图10-68 网络及可行流  ](images/bada5974bba3db0db4c82fa8e3076a8834542abfa1641f17fac232a32e6fee29.jpg)  
例如，如图10-68 所示，网络中定义网络流$f(u,v)$是一条可行流。图中每条边所对应的序偶表示该边的容量和流量，第一个数字表示边的容量，第二个数字表示边的流量。  
下面结合图10-68 所示网络实例介绍网络流模型中与边相关的几个概念。可根据边的容量与流的大小关系对网络中的边进行分类：  
（1）满足$f(u,v)=c(u,v)$的边称为饱和边，如边(1,2)、 (2,3)  
（2）满足$f(u,v)<c(u,v)$的边称为非饱和边，如边(2,4)。  
（3）满足 $f(u,v)=0$ 的边称为零流边，如边 (3,4) ；满足 $f(u,v)>0$ 的边称为非零流 边，如边(5,4)。  
（4）既不是零流边也不是饱和边的边，称为弱流边，如边(5,6)  
如果把图10-78 看作是一个公路网，6 个结点分别表示6 座城镇，每条边上的权数表示两城镇间的距离。若现在需要从起点1 将一些物资运送到终点6，应怎样选择路线才能使总运输距离最短。我们知道，这样一类问题称为最短路径问题。类似的，如果把图10-1看作为一个输油管道网，结点1表示为发送点，结点6表示为接收点，其它点表示为中转站，各边的权数表示该段管道的最大运输油量。那么如何安排输油线路才能使从1到6的总运输量最大。这样一类问题就是最大流问题。  
最大流问题是网络优化中的一个典型的问题，简单地说，就是在满足容量约束的前提下将尽可能多的流从源结点流向汇结点。因此，最大流问题就是求流网络$G$中使其流量$f$达到最大的一个可行流，该可行流即为最大流。具体定义如下：  
【定义10.4.2】设有向图$G=\langle V,E\rangle$是任意给定的一个网络流图，若$f$是$G$ 中流量最大的的可行流，则称该可行流$f$是$G$ 的最大流，构构造网络流图$G$ 中最大流的问题，就称为网络流图的最大流问题。  
为了实现对最大流问题的求解，必须对网络流图中的增流空间进行合理的度量，通常使用一种名为残留网络的图模型实现这项工作。残留网络的具体定义如下：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图， $f$为$G$的一个流，对于$G$的任意一条边$(u,v)$，在不超过容量$c(u,v)$条件下，从$u$到$v$可压入的额外流量，称为$(u,v)$的残留容量。由$G$中所有边残留容量构成的带权有向图称为$G$的残留网络，记为$G_{f}=\langle V,E_{f}\rangle$。  
若$c_{f}(u,v)$为残留网络$G_{f}$中边$(u,v)$的残留容量，且边$(u,v)\in E$或边$(v,u)\in E$，则$(u,v)\in$$E_{f}$,$\,c_{f}(u,v)=c(u,v)-f(u,v)\,$。例如，若设$(u,v)$当前流量为(4,3)，此时$c(u,v)=4$，$f(u,v)$）$=3$，则有：$c_{f}(u,v)=1$。  
需要注意的是，残留网络具有这样的性质：假设从$_{.}u$到$v$已经有了3 个单位流量，那么从反方向上看，也就是从$v$ 到$u$ 就有了3 个单位的残留容量，这时$c_{f}(v,u)=3$。换句话说，从$u$ 到$v$ 有3 个单位流量，那么从$v$到$u$ 就有了将这3 个单位流量压回去的能力。因此，残留网络结点之间通常由双向带权边进行联结。例如，对于图10-69（a）所示的一个流网络$G$，图10-69（b）则表示该流网络𝐺的残留网络。  
![图10-69 流网络及其残留网络 ](images/d65d1c72064671125468548ae171a28ede5424f1d36d601972ed76c90131fc8c.jpg)  
对于任意给定的一个网络流图$G=\langle V,E\rangle$，可以通过其残留网络$G_{f}=\langle V,E_{f}\rangle$求得$G$的最大流。基本思路如下：首先，对所有的结点令初始状态时流的值为0，即对于$\forall u,v\in V$，有$f(u,v)=0$。然后，通过迭代方式其残留网络中不断寻找源点𝑠到汇点$t$之间的流量增广路径来增加网络流量值，直到残留网络没有这样的增广路径为止。  
因此，在残留网络$G_{f}=\langle V,E_{f}\rangle$寻找流量增广路径是最大流求解算法的关键。为正确理解该算法，现给出流网络增广路径的具体定义：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，$G_{f}=\langle V,E_{f}\rangle$为$G$在流$f$下的一个残留网络，则$G_{f}=\langle V,E_{f}\rangle$中任意一条从源点$s$到汇点$t$的简单路径$p$称为$G=\langle V,E\rangle$的一条流量增广路径，简称为增广路径。  
事实上，可将增广路径形象地理解为网络流图$G$中从源点𝑠到汇点𝑡的一条不违反流网络边容量限制的路径，并向这条路径压入一定的流量，以增加整个网络的流量值。例如，图10-69（b）所示的残留网络存在这样一条如图10-70 中加粗有向边所示的增广路径。  
![图10-70 增广路径 ](images/1e52dc98ce8f5b49283b093dbb72c0d5308ccdc9782306a98cb168474d58608f.jpg)  
![图10-71 流网络的一个切割](images/c52dd38b6f7d2bc46bb57e2440709d67355577a7b3d5fb2e920f10a5bfeb8598.jpg)  
若将图10-70 所示增广路径在流网络所对应每条边的流量增加4 个单位，得到一个新的流网络，其流量比原网络多4 个单位。然后，在新流网络所对应的残留网络中继续寻找新增广路径，直到找不到新增广路径为止。显然，现在的问题是：如果在残留网络$G_{f}=$$\langle V,E_{f}\rangle$中找不到增广路径，此时该残留网络所对应的流$f$是否就是流网络$G=\langle V,E\rangle$的最大流？要解决这个问题，必须进一步引入流网络切割的相关概念，具体如下：  
【定义10.4.4】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，如果将$G$的结点集合𝑉划分为𝑆和$T=V-S$两部分，使得源点$s\in S$且$t\in T$，则称$(S,T)$是$G=\langle V,E\rangle$的一个切割，简称为割。从集合 𝑆 到集合 𝑇 的所有有向边容量之和称为切割 $(S,T)$ 的容量，穿过切割 $(S,T)$所有边流量的代数和流量称为切割$(S,T)$的净流量，记为$f(S,T)$。  
主要注意的是，定义10.4.4 中边的流量带有正负方向，如果流从结点𝑆流向$T$，则该边的流量值为正，如果流从结点𝑇流向𝑆，则该边的流量值为负。例如，对图10-69（a）所示的流网络，可画一个如图10-71 所示的切割$(S,T)$，其容量为：  
$$
c(u,w)+c(v,x)=12+14=26
$$  
穿过该切割的净流量为：  
$$
f(u,w)+f(v,x)-f(w,v)=12+11-4=19
$$  
显然，对于任意一个切割，穿过该切割的净流量上界就是该切割的容量，即穿过切割的净流量不可能超过割的容量。由于流网络中所有切割的流都相等并且等于网络的流，因此，网络最大流必然无法超过网络的最小割。由此得到如下最大流最小割定理：  
【定理10.4.1】（最大流最小割定理）设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和$t$分别为其源点和汇点，则$G=\langle V,E\rangle$的最大流量等于其最小割切的容量。对于$G=\langle V,E\rangle$上的任意一个流$f$，以下三个结论彼此等价：  
(1) $f$是流网络$G=\langle V,E\rangle$的一个最大流；  
(2) 流网络$G=\langle V,E\rangle$的残留网络中不包括任何增广路径；  
(3) 存在流网络$G=\langle V,E\rangle$的某个切割$(S,T)$，满足：
$$
f(S,T)=c(S,T)
$$",残留网络是由流网络中所有边的残留容量构成的带权有向图
流量增广路径,存在于,残留网络,,"首先介绍流网络模型的相关基本概念及其数据描述。如同每条公路有运输量、每根水管有最大流量限制一样，网络流图的每条边都有容量，或者说每条边都有一定的流量。网络流图其实就是每条边具有附带容量（可理解为权值）的有向图。其具体定义如下：  
【定义10.4.1】设有向图$G=\langle V,E\rangle$，$V$中包含一个源结点𝑠和一个汇结点$t$，且每条边$(u,v)\in E$均有一个非负容量$c(u,v)\geq0$，若$(u,v)\notin E$，则规定其容量$c(u,v)=0$，此时称有向图$G$是一个网络流图，简称为流网络或网络。源结点$s$即起点，汇结点$t$即终点。网络流是定义在网络$G$中关于边的一个实函数，用$f(u,v)$表示有向边$(u,v)\in E$上结点$ u$到结点$v$的网络流。$f(u,v)$表示$u$ 到$v$的净流。  
例如，如果$_{u}$到$v$有6 个单位的实际流，且$v$到$u$有3 个单位的实际流，那么$f(u,v)=$3，$f(v,u)=-3$，互为相反数。净流是实际通过的流量矢量和，可类比合力的概念。  
满足以下三个性质的网络流$f$称之为可行流：  
（1）容量限制：对所有的$(u,v)\in E$，都有$f(u,v)\leq c(u,\textit{}v)$。即一条边的流不能超过它的容量。这也很容易理解，如同自来水管的水流自然不会超过水管本身的容量。  
（2）斜对称：对所有$(u,v)\in E$，都有$f(u,v)=-f(v,u)$。即点$\cdot u$到$v$的净流必须与点𝑣到$u$的净流相反。可以类比物理中矢量概念，如作用力与反作用力，强调的是其方向性。  
（3）流守恒：对所有$u\in V-\{s,t\}$，都有$\textstyle\sum_{v\in V}f(u,v)=0$。即除源结点$𝑠$和汇结点$𝑡$外，其余每个结点的净流之和为0。  
![图10-68 网络及可行流  ](images/bada5974bba3db0db4c82fa8e3076a8834542abfa1641f17fac232a32e6fee29.jpg)  
例如，如图10-68 所示，网络中定义网络流$f(u,v)$是一条可行流。图中每条边所对应的序偶表示该边的容量和流量，第一个数字表示边的容量，第二个数字表示边的流量。  
下面结合图10-68 所示网络实例介绍网络流模型中与边相关的几个概念。可根据边的容量与流的大小关系对网络中的边进行分类：  
（1）满足$f(u,v)=c(u,v)$的边称为饱和边，如边(1,2)、 (2,3)  
（2）满足$f(u,v)<c(u,v)$的边称为非饱和边，如边(2,4)。  
（3）满足 $f(u,v)=0$ 的边称为零流边，如边 (3,4) ；满足 $f(u,v)>0$ 的边称为非零流 边，如边(5,4)。  
（4）既不是零流边也不是饱和边的边，称为弱流边，如边(5,6)  
如果把图10-78 看作是一个公路网，6 个结点分别表示6 座城镇，每条边上的权数表示两城镇间的距离。若现在需要从起点1 将一些物资运送到终点6，应怎样选择路线才能使总运输距离最短。我们知道，这样一类问题称为最短路径问题。类似的，如果把图10-1看作为一个输油管道网，结点1表示为发送点，结点6表示为接收点，其它点表示为中转站，各边的权数表示该段管道的最大运输油量。那么如何安排输油线路才能使从1到6的总运输量最大。这样一类问题就是最大流问题。  
最大流问题是网络优化中的一个典型的问题，简单地说，就是在满足容量约束的前提下将尽可能多的流从源结点流向汇结点。因此，最大流问题就是求流网络$G$中使其流量$f$达到最大的一个可行流，该可行流即为最大流。具体定义如下：  
【定义10.4.2】设有向图$G=\langle V,E\rangle$是任意给定的一个网络流图，若$f$是$G$ 中流量最大的的可行流，则称该可行流$f$是$G$ 的最大流，构构造网络流图$G$ 中最大流的问题，就称为网络流图的最大流问题。  
为了实现对最大流问题的求解，必须对网络流图中的增流空间进行合理的度量，通常使用一种名为残留网络的图模型实现这项工作。残留网络的具体定义如下：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图， $f$为$G$的一个流，对于$G$的任意一条边$(u,v)$，在不超过容量$c(u,v)$条件下，从$u$到$v$可压入的额外流量，称为$(u,v)$的残留容量。由$G$中所有边残留容量构成的带权有向图称为$G$的残留网络，记为$G_{f}=\langle V,E_{f}\rangle$。  
若$c_{f}(u,v)$为残留网络$G_{f}$中边$(u,v)$的残留容量，且边$(u,v)\in E$或边$(v,u)\in E$，则$(u,v)\in$$E_{f}$,$\,c_{f}(u,v)=c(u,v)-f(u,v)\,$。例如，若设$(u,v)$当前流量为(4,3)，此时$c(u,v)=4$，$f(u,v)$）$=3$，则有：$c_{f}(u,v)=1$。  
需要注意的是，残留网络具有这样的性质：假设从$_{.}u$到$v$已经有了3 个单位流量，那么从反方向上看，也就是从$v$ 到$u$ 就有了3 个单位的残留容量，这时$c_{f}(v,u)=3$。换句话说，从$u$ 到$v$ 有3 个单位流量，那么从$v$到$u$ 就有了将这3 个单位流量压回去的能力。因此，残留网络结点之间通常由双向带权边进行联结。例如，对于图10-69（a）所示的一个流网络$G$，图10-69（b）则表示该流网络𝐺的残留网络。  
![图10-69 流网络及其残留网络 ](images/d65d1c72064671125468548ae171a28ede5424f1d36d601972ed76c90131fc8c.jpg)  
对于任意给定的一个网络流图$G=\langle V,E\rangle$，可以通过其残留网络$G_{f}=\langle V,E_{f}\rangle$求得$G$的最大流。基本思路如下：首先，对所有的结点令初始状态时流的值为0，即对于$\forall u,v\in V$，有$f(u,v)=0$。然后，通过迭代方式其残留网络中不断寻找源点𝑠到汇点$t$之间的流量增广路径来增加网络流量值，直到残留网络没有这样的增广路径为止。  
因此，在残留网络$G_{f}=\langle V,E_{f}\rangle$寻找流量增广路径是最大流求解算法的关键。为正确理解该算法，现给出流网络增广路径的具体定义：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，$G_{f}=\langle V,E_{f}\rangle$为$G$在流$f$下的一个残留网络，则$G_{f}=\langle V,E_{f}\rangle$中任意一条从源点$s$到汇点$t$的简单路径$p$称为$G=\langle V,E\rangle$的一条流量增广路径，简称为增广路径。  
事实上，可将增广路径形象地理解为网络流图$G$中从源点𝑠到汇点𝑡的一条不违反流网络边容量限制的路径，并向这条路径压入一定的流量，以增加整个网络的流量值。例如，图10-69（b）所示的残留网络存在这样一条如图10-70 中加粗有向边所示的增广路径。  
![图10-70 增广路径 ](images/1e52dc98ce8f5b49283b093dbb72c0d5308ccdc9782306a98cb168474d58608f.jpg)  
![图10-71 流网络的一个切割](images/c52dd38b6f7d2bc46bb57e2440709d67355577a7b3d5fb2e920f10a5bfeb8598.jpg)  
若将图10-70 所示增广路径在流网络所对应每条边的流量增加4 个单位，得到一个新的流网络，其流量比原网络多4 个单位。然后，在新流网络所对应的残留网络中继续寻找新增广路径，直到找不到新增广路径为止。显然，现在的问题是：如果在残留网络$G_{f}=$$\langle V,E_{f}\rangle$中找不到增广路径，此时该残留网络所对应的流$f$是否就是流网络$G=\langle V,E\rangle$的最大流？要解决这个问题，必须进一步引入流网络切割的相关概念，具体如下：  
【定义10.4.4】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，如果将$G$的结点集合𝑉划分为𝑆和$T=V-S$两部分，使得源点$s\in S$且$t\in T$，则称$(S,T)$是$G=\langle V,E\rangle$的一个切割，简称为割。从集合 𝑆 到集合 𝑇 的所有有向边容量之和称为切割 $(S,T)$ 的容量，穿过切割 $(S,T)$所有边流量的代数和流量称为切割$(S,T)$的净流量，记为$f(S,T)$。  
主要注意的是，定义10.4.4 中边的流量带有正负方向，如果流从结点𝑆流向$T$，则该边的流量值为正，如果流从结点𝑇流向𝑆，则该边的流量值为负。例如，对图10-69（a）所示的流网络，可画一个如图10-71 所示的切割$(S,T)$，其容量为：  
$$
c(u,w)+c(v,x)=12+14=26
$$  
穿过该切割的净流量为：  
$$
f(u,w)+f(v,x)-f(w,v)=12+11-4=19
$$  
显然，对于任意一个切割，穿过该切割的净流量上界就是该切割的容量，即穿过切割的净流量不可能超过割的容量。由于流网络中所有切割的流都相等并且等于网络的流，因此，网络最大流必然无法超过网络的最小割。由此得到如下最大流最小割定理：  
【定理10.4.1】（最大流最小割定理）设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和$t$分别为其源点和汇点，则$G=\langle V,E\rangle$的最大流量等于其最小割切的容量。对于$G=\langle V,E\rangle$上的任意一个流$f$，以下三个结论彼此等价：  
(1) $f$是流网络$G=\langle V,E\rangle$的一个最大流；  
(2) 流网络$G=\langle V,E\rangle$的残留网络中不包括任何增广路径；  
(3) 存在流网络$G=\langle V,E\rangle$的某个切割$(S,T)$，满足：
$$
f(S,T)=c(S,T)
$$",流量增广路径是残留网络中从源点到汇点的不违反容量限制的路径
切割,划分,流网络,,"首先介绍流网络模型的相关基本概念及其数据描述。如同每条公路有运输量、每根水管有最大流量限制一样，网络流图的每条边都有容量，或者说每条边都有一定的流量。网络流图其实就是每条边具有附带容量（可理解为权值）的有向图。其具体定义如下：  
【定义10.4.1】设有向图$G=\langle V,E\rangle$，$V$中包含一个源结点𝑠和一个汇结点$t$，且每条边$(u,v)\in E$均有一个非负容量$c(u,v)\geq0$，若$(u,v)\notin E$，则规定其容量$c(u,v)=0$，此时称有向图$G$是一个网络流图，简称为流网络或网络。源结点$s$即起点，汇结点$t$即终点。网络流是定义在网络$G$中关于边的一个实函数，用$f(u,v)$表示有向边$(u,v)\in E$上结点$ u$到结点$v$的网络流。$f(u,v)$表示$u$ 到$v$的净流。  
例如，如果$_{u}$到$v$有6 个单位的实际流，且$v$到$u$有3 个单位的实际流，那么$f(u,v)=$3，$f(v,u)=-3$，互为相反数。净流是实际通过的流量矢量和，可类比合力的概念。  
满足以下三个性质的网络流$f$称之为可行流：  
（1）容量限制：对所有的$(u,v)\in E$，都有$f(u,v)\leq c(u,\textit{}v)$。即一条边的流不能超过它的容量。这也很容易理解，如同自来水管的水流自然不会超过水管本身的容量。  
（2）斜对称：对所有$(u,v)\in E$，都有$f(u,v)=-f(v,u)$。即点$\cdot u$到$v$的净流必须与点𝑣到$u$的净流相反。可以类比物理中矢量概念，如作用力与反作用力，强调的是其方向性。  
（3）流守恒：对所有$u\in V-\{s,t\}$，都有$\textstyle\sum_{v\in V}f(u,v)=0$。即除源结点$𝑠$和汇结点$𝑡$外，其余每个结点的净流之和为0。  
![图10-68 网络及可行流  ](images/bada5974bba3db0db4c82fa8e3076a8834542abfa1641f17fac232a32e6fee29.jpg)  
例如，如图10-68 所示，网络中定义网络流$f(u,v)$是一条可行流。图中每条边所对应的序偶表示该边的容量和流量，第一个数字表示边的容量，第二个数字表示边的流量。  
下面结合图10-68 所示网络实例介绍网络流模型中与边相关的几个概念。可根据边的容量与流的大小关系对网络中的边进行分类：  
（1）满足$f(u,v)=c(u,v)$的边称为饱和边，如边(1,2)、 (2,3)  
（2）满足$f(u,v)<c(u,v)$的边称为非饱和边，如边(2,4)。  
（3）满足 $f(u,v)=0$ 的边称为零流边，如边 (3,4) ；满足 $f(u,v)>0$ 的边称为非零流 边，如边(5,4)。  
（4）既不是零流边也不是饱和边的边，称为弱流边，如边(5,6)  
如果把图10-78 看作是一个公路网，6 个结点分别表示6 座城镇，每条边上的权数表示两城镇间的距离。若现在需要从起点1 将一些物资运送到终点6，应怎样选择路线才能使总运输距离最短。我们知道，这样一类问题称为最短路径问题。类似的，如果把图10-1看作为一个输油管道网，结点1表示为发送点，结点6表示为接收点，其它点表示为中转站，各边的权数表示该段管道的最大运输油量。那么如何安排输油线路才能使从1到6的总运输量最大。这样一类问题就是最大流问题。  
最大流问题是网络优化中的一个典型的问题，简单地说，就是在满足容量约束的前提下将尽可能多的流从源结点流向汇结点。因此，最大流问题就是求流网络$G$中使其流量$f$达到最大的一个可行流，该可行流即为最大流。具体定义如下：  
【定义10.4.2】设有向图$G=\langle V,E\rangle$是任意给定的一个网络流图，若$f$是$G$ 中流量最大的的可行流，则称该可行流$f$是$G$ 的最大流，构构造网络流图$G$ 中最大流的问题，就称为网络流图的最大流问题。  
为了实现对最大流问题的求解，必须对网络流图中的增流空间进行合理的度量，通常使用一种名为残留网络的图模型实现这项工作。残留网络的具体定义如下：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图， $f$为$G$的一个流，对于$G$的任意一条边$(u,v)$，在不超过容量$c(u,v)$条件下，从$u$到$v$可压入的额外流量，称为$(u,v)$的残留容量。由$G$中所有边残留容量构成的带权有向图称为$G$的残留网络，记为$G_{f}=\langle V,E_{f}\rangle$。  
若$c_{f}(u,v)$为残留网络$G_{f}$中边$(u,v)$的残留容量，且边$(u,v)\in E$或边$(v,u)\in E$，则$(u,v)\in$$E_{f}$,$\,c_{f}(u,v)=c(u,v)-f(u,v)\,$。例如，若设$(u,v)$当前流量为(4,3)，此时$c(u,v)=4$，$f(u,v)$）$=3$，则有：$c_{f}(u,v)=1$。  
需要注意的是，残留网络具有这样的性质：假设从$_{.}u$到$v$已经有了3 个单位流量，那么从反方向上看，也就是从$v$ 到$u$ 就有了3 个单位的残留容量，这时$c_{f}(v,u)=3$。换句话说，从$u$ 到$v$ 有3 个单位流量，那么从$v$到$u$ 就有了将这3 个单位流量压回去的能力。因此，残留网络结点之间通常由双向带权边进行联结。例如，对于图10-69（a）所示的一个流网络$G$，图10-69（b）则表示该流网络𝐺的残留网络。  
![图10-69 流网络及其残留网络 ](images/d65d1c72064671125468548ae171a28ede5424f1d36d601972ed76c90131fc8c.jpg)  
对于任意给定的一个网络流图$G=\langle V,E\rangle$，可以通过其残留网络$G_{f}=\langle V,E_{f}\rangle$求得$G$的最大流。基本思路如下：首先，对所有的结点令初始状态时流的值为0，即对于$\forall u,v\in V$，有$f(u,v)=0$。然后，通过迭代方式其残留网络中不断寻找源点𝑠到汇点$t$之间的流量增广路径来增加网络流量值，直到残留网络没有这样的增广路径为止。  
因此，在残留网络$G_{f}=\langle V,E_{f}\rangle$寻找流量增广路径是最大流求解算法的关键。为正确理解该算法，现给出流网络增广路径的具体定义：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，$G_{f}=\langle V,E_{f}\rangle$为$G$在流$f$下的一个残留网络，则$G_{f}=\langle V,E_{f}\rangle$中任意一条从源点$s$到汇点$t$的简单路径$p$称为$G=\langle V,E\rangle$的一条流量增广路径，简称为增广路径。  
事实上，可将增广路径形象地理解为网络流图$G$中从源点𝑠到汇点𝑡的一条不违反流网络边容量限制的路径，并向这条路径压入一定的流量，以增加整个网络的流量值。例如，图10-69（b）所示的残留网络存在这样一条如图10-70 中加粗有向边所示的增广路径。  
![图10-70 增广路径 ](images/1e52dc98ce8f5b49283b093dbb72c0d5308ccdc9782306a98cb168474d58608f.jpg)  
![图10-71 流网络的一个切割](images/c52dd38b6f7d2bc46bb57e2440709d67355577a7b3d5fb2e920f10a5bfeb8598.jpg)  
若将图10-70 所示增广路径在流网络所对应每条边的流量增加4 个单位，得到一个新的流网络，其流量比原网络多4 个单位。然后，在新流网络所对应的残留网络中继续寻找新增广路径，直到找不到新增广路径为止。显然，现在的问题是：如果在残留网络$G_{f}=$$\langle V,E_{f}\rangle$中找不到增广路径，此时该残留网络所对应的流$f$是否就是流网络$G=\langle V,E\rangle$的最大流？要解决这个问题，必须进一步引入流网络切割的相关概念，具体如下：  
【定义10.4.4】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，如果将$G$的结点集合𝑉划分为𝑆和$T=V-S$两部分，使得源点$s\in S$且$t\in T$，则称$(S,T)$是$G=\langle V,E\rangle$的一个切割，简称为割。从集合 𝑆 到集合 𝑇 的所有有向边容量之和称为切割 $(S,T)$ 的容量，穿过切割 $(S,T)$所有边流量的代数和流量称为切割$(S,T)$的净流量，记为$f(S,T)$。  
主要注意的是，定义10.4.4 中边的流量带有正负方向，如果流从结点𝑆流向$T$，则该边的流量值为正，如果流从结点𝑇流向𝑆，则该边的流量值为负。例如，对图10-69（a）所示的流网络，可画一个如图10-71 所示的切割$(S,T)$，其容量为：  
$$
c(u,w)+c(v,x)=12+14=26
$$  
穿过该切割的净流量为：  
$$
f(u,w)+f(v,x)-f(w,v)=12+11-4=19
$$  
显然，对于任意一个切割，穿过该切割的净流量上界就是该切割的容量，即穿过切割的净流量不可能超过割的容量。由于流网络中所有切割的流都相等并且等于网络的流，因此，网络最大流必然无法超过网络的最小割。由此得到如下最大流最小割定理：  
【定理10.4.1】（最大流最小割定理）设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和$t$分别为其源点和汇点，则$G=\langle V,E\rangle$的最大流量等于其最小割切的容量。对于$G=\langle V,E\rangle$上的任意一个流$f$，以下三个结论彼此等价：  
(1) $f$是流网络$G=\langle V,E\rangle$的一个最大流；  
(2) 流网络$G=\langle V,E\rangle$的残留网络中不包括任何增广路径；  
(3) 存在流网络$G=\langle V,E\rangle$的某个切割$(S,T)$，满足：
$$
f(S,T)=c(S,T)
$$",切割是将流网络的节点集合划分为两部分，使得源点和汇点分别属于不同部分
最大流最小割定理,描述,流网络,,"首先介绍流网络模型的相关基本概念及其数据描述。如同每条公路有运输量、每根水管有最大流量限制一样，网络流图的每条边都有容量，或者说每条边都有一定的流量。网络流图其实就是每条边具有附带容量（可理解为权值）的有向图。其具体定义如下：  
【定义10.4.1】设有向图$G=\langle V,E\rangle$，$V$中包含一个源结点𝑠和一个汇结点$t$，且每条边$(u,v)\in E$均有一个非负容量$c(u,v)\geq0$，若$(u,v)\notin E$，则规定其容量$c(u,v)=0$，此时称有向图$G$是一个网络流图，简称为流网络或网络。源结点$s$即起点，汇结点$t$即终点。网络流是定义在网络$G$中关于边的一个实函数，用$f(u,v)$表示有向边$(u,v)\in E$上结点$ u$到结点$v$的网络流。$f(u,v)$表示$u$ 到$v$的净流。  
例如，如果$_{u}$到$v$有6 个单位的实际流，且$v$到$u$有3 个单位的实际流，那么$f(u,v)=$3，$f(v,u)=-3$，互为相反数。净流是实际通过的流量矢量和，可类比合力的概念。  
满足以下三个性质的网络流$f$称之为可行流：  
（1）容量限制：对所有的$(u,v)\in E$，都有$f(u,v)\leq c(u,\textit{}v)$。即一条边的流不能超过它的容量。这也很容易理解，如同自来水管的水流自然不会超过水管本身的容量。  
（2）斜对称：对所有$(u,v)\in E$，都有$f(u,v)=-f(v,u)$。即点$\cdot u$到$v$的净流必须与点𝑣到$u$的净流相反。可以类比物理中矢量概念，如作用力与反作用力，强调的是其方向性。  
（3）流守恒：对所有$u\in V-\{s,t\}$，都有$\textstyle\sum_{v\in V}f(u,v)=0$。即除源结点$𝑠$和汇结点$𝑡$外，其余每个结点的净流之和为0。  
![图10-68 网络及可行流  ](images/bada5974bba3db0db4c82fa8e3076a8834542abfa1641f17fac232a32e6fee29.jpg)  
例如，如图10-68 所示，网络中定义网络流$f(u,v)$是一条可行流。图中每条边所对应的序偶表示该边的容量和流量，第一个数字表示边的容量，第二个数字表示边的流量。  
下面结合图10-68 所示网络实例介绍网络流模型中与边相关的几个概念。可根据边的容量与流的大小关系对网络中的边进行分类：  
（1）满足$f(u,v)=c(u,v)$的边称为饱和边，如边(1,2)、 (2,3)  
（2）满足$f(u,v)<c(u,v)$的边称为非饱和边，如边(2,4)。  
（3）满足 $f(u,v)=0$ 的边称为零流边，如边 (3,4) ；满足 $f(u,v)>0$ 的边称为非零流 边，如边(5,4)。  
（4）既不是零流边也不是饱和边的边，称为弱流边，如边(5,6)  
如果把图10-78 看作是一个公路网，6 个结点分别表示6 座城镇，每条边上的权数表示两城镇间的距离。若现在需要从起点1 将一些物资运送到终点6，应怎样选择路线才能使总运输距离最短。我们知道，这样一类问题称为最短路径问题。类似的，如果把图10-1看作为一个输油管道网，结点1表示为发送点，结点6表示为接收点，其它点表示为中转站，各边的权数表示该段管道的最大运输油量。那么如何安排输油线路才能使从1到6的总运输量最大。这样一类问题就是最大流问题。  
最大流问题是网络优化中的一个典型的问题，简单地说，就是在满足容量约束的前提下将尽可能多的流从源结点流向汇结点。因此，最大流问题就是求流网络$G$中使其流量$f$达到最大的一个可行流，该可行流即为最大流。具体定义如下：  
【定义10.4.2】设有向图$G=\langle V,E\rangle$是任意给定的一个网络流图，若$f$是$G$ 中流量最大的的可行流，则称该可行流$f$是$G$ 的最大流，构构造网络流图$G$ 中最大流的问题，就称为网络流图的最大流问题。  
为了实现对最大流问题的求解，必须对网络流图中的增流空间进行合理的度量，通常使用一种名为残留网络的图模型实现这项工作。残留网络的具体定义如下：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图， $f$为$G$的一个流，对于$G$的任意一条边$(u,v)$，在不超过容量$c(u,v)$条件下，从$u$到$v$可压入的额外流量，称为$(u,v)$的残留容量。由$G$中所有边残留容量构成的带权有向图称为$G$的残留网络，记为$G_{f}=\langle V,E_{f}\rangle$。  
若$c_{f}(u,v)$为残留网络$G_{f}$中边$(u,v)$的残留容量，且边$(u,v)\in E$或边$(v,u)\in E$，则$(u,v)\in$$E_{f}$,$\,c_{f}(u,v)=c(u,v)-f(u,v)\,$。例如，若设$(u,v)$当前流量为(4,3)，此时$c(u,v)=4$，$f(u,v)$）$=3$，则有：$c_{f}(u,v)=1$。  
需要注意的是，残留网络具有这样的性质：假设从$_{.}u$到$v$已经有了3 个单位流量，那么从反方向上看，也就是从$v$ 到$u$ 就有了3 个单位的残留容量，这时$c_{f}(v,u)=3$。换句话说，从$u$ 到$v$ 有3 个单位流量，那么从$v$到$u$ 就有了将这3 个单位流量压回去的能力。因此，残留网络结点之间通常由双向带权边进行联结。例如，对于图10-69（a）所示的一个流网络$G$，图10-69（b）则表示该流网络𝐺的残留网络。  
![图10-69 流网络及其残留网络 ](images/d65d1c72064671125468548ae171a28ede5424f1d36d601972ed76c90131fc8c.jpg)  
对于任意给定的一个网络流图$G=\langle V,E\rangle$，可以通过其残留网络$G_{f}=\langle V,E_{f}\rangle$求得$G$的最大流。基本思路如下：首先，对所有的结点令初始状态时流的值为0，即对于$\forall u,v\in V$，有$f(u,v)=0$。然后，通过迭代方式其残留网络中不断寻找源点𝑠到汇点$t$之间的流量增广路径来增加网络流量值，直到残留网络没有这样的增广路径为止。  
因此，在残留网络$G_{f}=\langle V,E_{f}\rangle$寻找流量增广路径是最大流求解算法的关键。为正确理解该算法，现给出流网络增广路径的具体定义：  
【定义10.4.3】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，$G_{f}=\langle V,E_{f}\rangle$为$G$在流$f$下的一个残留网络，则$G_{f}=\langle V,E_{f}\rangle$中任意一条从源点$s$到汇点$t$的简单路径$p$称为$G=\langle V,E\rangle$的一条流量增广路径，简称为增广路径。  
事实上，可将增广路径形象地理解为网络流图$G$中从源点𝑠到汇点𝑡的一条不违反流网络边容量限制的路径，并向这条路径压入一定的流量，以增加整个网络的流量值。例如，图10-69（b）所示的残留网络存在这样一条如图10-70 中加粗有向边所示的增广路径。  
![图10-70 增广路径 ](images/1e52dc98ce8f5b49283b093dbb72c0d5308ccdc9782306a98cb168474d58608f.jpg)  
![图10-71 流网络的一个切割](images/c52dd38b6f7d2bc46bb57e2440709d67355577a7b3d5fb2e920f10a5bfeb8598.jpg)  
若将图10-70 所示增广路径在流网络所对应每条边的流量增加4 个单位，得到一个新的流网络，其流量比原网络多4 个单位。然后，在新流网络所对应的残留网络中继续寻找新增广路径，直到找不到新增广路径为止。显然，现在的问题是：如果在残留网络$G_{f}=$$\langle V,E_{f}\rangle$中找不到增广路径，此时该残留网络所对应的流$f$是否就是流网络$G=\langle V,E\rangle$的最大流？要解决这个问题，必须进一步引入流网络切割的相关概念，具体如下：  
【定义10.4.4】设有向图$G=\langle V,E\rangle$是任意一个网络流图，$f$为$G$的一个流，如果将$G$的结点集合𝑉划分为𝑆和$T=V-S$两部分，使得源点$s\in S$且$t\in T$，则称$(S,T)$是$G=\langle V,E\rangle$的一个切割，简称为割。从集合 𝑆 到集合 𝑇 的所有有向边容量之和称为切割 $(S,T)$ 的容量，穿过切割 $(S,T)$所有边流量的代数和流量称为切割$(S,T)$的净流量，记为$f(S,T)$。  
主要注意的是，定义10.4.4 中边的流量带有正负方向，如果流从结点𝑆流向$T$，则该边的流量值为正，如果流从结点𝑇流向𝑆，则该边的流量值为负。例如，对图10-69（a）所示的流网络，可画一个如图10-71 所示的切割$(S,T)$，其容量为：  
$$
c(u,w)+c(v,x)=12+14=26
$$  
穿过该切割的净流量为：  
$$
f(u,w)+f(v,x)-f(w,v)=12+11-4=19
$$  
显然，对于任意一个切割，穿过该切割的净流量上界就是该切割的容量，即穿过切割的净流量不可能超过割的容量。由于流网络中所有切割的流都相等并且等于网络的流，因此，网络最大流必然无法超过网络的最小割。由此得到如下最大流最小割定理：  
【定理10.4.1】（最大流最小割定理）设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和$t$分别为其源点和汇点，则$G=\langle V,E\rangle$的最大流量等于其最小割切的容量。对于$G=\langle V,E\rangle$上的任意一个流$f$，以下三个结论彼此等价：  
(1) $f$是流网络$G=\langle V,E\rangle$的一个最大流；  
(2) 流网络$G=\langle V,E\rangle$的残留网络中不包括任何增广路径；  
(3) 存在流网络$G=\langle V,E\rangle$的某个切割$(S,T)$，满足：
$$
f(S,T)=c(S,T)
$$",最大流最小割定理表明流网络的最大流量等于其最小切割的容量
网络流图,应用,最大流求解算法,,"网络流理论的创立主要用于解决最大网络流问题，即在一定的约束条件下，如何使得网络中流的总量达到最大。该理论证明了最大流量一定等于最小割容量这个重要结论，并根据这一结论设计并实现了多种最大流的算法。其中比较经典的有Ford-Fulkerson 算法、Edmonds-Karp 算法、Dinic 算法以及预流推进算法等。  
本节主要介绍其中最具代表性的Ford-Fulkerson 算法。该算法由美国普林斯顿大学的两位著名运筹学教授Ford.L.R 和Fulkerson.D.R 提出。Ford-Fulkerson 算法是一种迭代算法，基本思路如下：首先，对所有结点$u,v\in V$令$f(u,v)=0$。然后，通过迭代的方式不断在残留网络中寻找一个增广路径来增加流值，直到残留网络中不包括增广路径为止。  
具体地说：首先，初始化一条容量为0 的流$f$和一个残余网络$G_{f}$，第一个残余网络为原  
图$G$，每条边的残留容量初始化为每条边的初始容量$c_{f}(u,v)=c(u,v)$。然后，在残留网络$G_{f}$中寻找增广路径$P$，取增广路径$P$中的边的残留容量$c_{f}(u,v)$最小值作为流的增量$\triangle\,f$，使得$f^{\prime}=f+\triangle\,f$。修改剩余图中每条边的容量：  
$$
c_{f}^{\prime}(u,v)=c_{f}(u,v)-\triangle\,f
$$  
得到残留网络$ G_{f}$。重复上述过程，直到找不到一条增广路径为止。  
Ford-Fulkerson 算法依赖于残留网络、增广路径和切割这三个概念。算法的正确性可由最大流最小切割定理保证。设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和𝑡分别为其源点和汇点，$f$为$G$的一个流，则该算法基本过程如下：  
1）对网络$G=\langle V,E\rangle$初始化，使$f(e)=0$，$e\in E$  
2）给源点𝑠标号$(-,\ \infty)$，其它结点均未标号；  
3）依次选一个未标号的结点，根据其方向进行标号，若当前标号的结点为汇点𝑡，转步骤4），否则转步骤6）；  
4）选择一条标号过的增流路径进行增流；  
5）转步骤2）  
6）这时得到的$f$就是最大可行流。  
对于如图10-72 为初始网络$G$，其中边上的数字表示对应边的容量，下面介绍通过Ford-Fulkerson 算法寻找其的最大可行流的具体实现过程：  
1）首先初始化$f(e)=0$，$e\in E$，如图10-73 所示；  
2）给源点$𝑠$标号$(-,\infty)$，其它结点均未标号，如图10-74 所示；  
![](images/d01d4ec14f1aff44a86873230240f7edbcb814f97a9366a1ac732e953b2aaa81.jpg)  
3 ）选可进行正向或反向标号的结点进行标号，若当前标号的结点为 𝑡 ，则转步骤 4 ） ； 若 没有这样的结点可选时，则转步骤6），如图10-75 所示；  
4）当前标号的结点为𝑡，对标号过的增流路径进行增流，增流路径为：$(s-\textit{a}-\textit{b}-$$c-\ t)$，增量$\triangle\,f$取增广路径中的边的残留容量$c_{f}(u,v)$最小值2，如图10-76 所示；  
5）转到步骤2），即给源点𝑠标号$(-,\infty)$，其它结点均未标号，如图10-77 所示；  
![](images/34aabd8b5a71470ee2b35d4d37961da9a5f6ada16975b230634ead0f16e07488.jpg)  
6）类似地，按照步骤3 再次进行标号，如图10-78 所示；  
7）当前标号的结点为𝑡，对标号过的增流路径进行增流，增流路径为：$(s-b-a-t)$增量$\triangle\,f$取增广路径中的边的残留容量$c_{f}(u,v)$最小值6，如图10-79 所示；  
8）同理，再对源点𝑠标号$(-,\ \infty)$，其他结点均未标号，如图10-80 所示；  
![](images/0f5b5f38aed586b9e60d5dccb4b3630e897dacff029a529f37f234c7155e86b7.jpg)  
9）按步骤3，再次进行标号，如图10-81 所示；  
10）当前标号的结点为𝑡，对标号过的增流路径进行增流，增流路径为：$\begin{array}{r l r}{~~~}&{{}(s-}&{b-a-}\end{array}$$t)$，增量$\triangle\,f$取增广路径中的边的残留容量$c_{f}(u,v)$最小值2，如图10-82 所示；  
11）同理，再对源点𝑠标号$(-,\ \infty)$，其他结点均未标号，类似的，增流路径为：$(s-\ b-$$c-t)$，增量$\triangle\,f$取1，如图10-83 所示；  
![](images/062c661062259beec86ff3629be8e97fdac80b28c61e2ace5ae35565f4731050.jpg)  
12）同理，再对源点𝑠标号$(-,\ \infty)$，其它结点均未标号，类似地，增流路径为：$\begin{array}{l l}{(s-}&{c-}\end{array}$$t)$，增量$\triangle\,f$取2，如图10-84 所示；  
13）同理，再对源点𝑠标号$(-,\ \infty)$，其它结点均未标号，类似地，增流路径为：$(s-c-$$b-a)$，此时当前结点为$a$，算法结束，所得可行流即为所求最大流，如图10-85 所示。  
![图10-84  增流过程  5](images/1913d4d69345305d204c147879cef0c2b861b90402556b9d5ebafe81eeaf5bff.jpg)  
![图10-85  网络$G$最大流  ](images/d7adb0913e78b96ab009478c7164178b41b7185b8446090115774418a82e3cf7.jpg)  
下面给出网络最大流的一个具体应用实例：  
【例题10.17】某货运车站有$n$个车道，由于车道长度有限，每个车道在某时刻最多只能停靠一列货运列车。车站正常运行后，每天有$m$列货运列车从车站经过，其中第$i$ 列列车到达车站的时间为$𝑅𝑒𝑎𝑐ℎ[𝑖]$，列车上装有价值$𝐶𝑜𝑠𝑡[𝑖]$的货物。如果准许列车𝑖进站，则车站将获得$10\%\times C o s t[i]$的收益，受到货物搬运时间制约，列车在站停留时间长度为$𝑆𝑡𝑎𝑦[𝑖]$。这段时间内，列车将占用车站某个车道；若不允许某列车进站，则该列车直接出站，此时车站无任何收益。现有2 个车道，5 列列车，列车进站时间、停车价值、停留时间如表10-1 所示，如何合理安排列车的进站与出站，才能使得车站的总收益最大？  
![表10-1 时间价值表 ](images/a7dc7c1c3b8b134efa88b94b361c280ae0e7e4db6c3d4edd361dc330595e5076.jpg)  
![图10-86 进出站时间 ](images/2c392864c4179f14536de4f9b63f959455c42ecc7344ede3aef7ced37250a84d.jpg)  
【解】可用一个流网络对该问题进行建模，具体过程如下：  
1）将每一列列车看成是联结两个结点的一条带权边，如第𝑖列列车拆成点$𝑖$和$i^{\prime}$，$𝑖$到$i^{\prime}$之间加一条容量为1，费用为$10\%\times C o s t[i]$的边$i\rightarrow i^{\prime}$；若$i\rightarrow i^{\prime}$的边的流量为1，则表示该列火车进站，并获得$10\%\times C o s t[i]$。  
2）增加一个源点$S$，$S$与每个点$i$连一条容量为1 费用为0 的边$S\rightarrow i$；如果$S\rightarrow i$的流量为1，则表示列车$𝑖$作为某个车道的第一列入站的列车  
3）再增加一个源点$S^{\prime}$，$S^{\prime}{\to}S$的容量为$n$，表示有$n$个车道；  
4）增加一个汇点$T$，每个点$i^{\prime}$与𝑇连一条容量为1 费用为0 的边$i^{\prime}\rightarrow T$；如果𝑖’ $\rightarrow T$的流量为1，则表示列车$𝑖$作为某个车道的最后一列入站的列车；  
5）对于所有$𝑖$和$j(i\neq j)$，如果$R e a c h[i]+S t a y[i]<R e a c h[j]$，则在$i^{\prime}$与$𝑗$之间连一条容量为1，费用为0 边，表示可以在某一个车道先停入列车𝑖，等𝑖出站后再停入列车𝑗。  
![图10-86 列车流量网络模型  ](images/e877c0962ea89c788357a0ce9a48c4f306c3bc33bc71d559136cc0a052c8c375.jpg)  
![图10-87 列车调度问题总收益最大流图  ](images/820628b77bdb2600c45369a5e8ccfe88b488f7bb28ab752799b5e76d0dabc2f0.jpg)  
如图10-86 所示的流网络为列车调度的流量网络模型，其中粗线箭头上的数字表示费用，未标数字的弧的费用为 0 ，未标明容量的弧的容量为 1 。  
![图10-88 列车进站安排  ](images/25158a79180787e9c0c3c5ee956180ccd3bcebdba893d1c1a3d3773d0bfcced1.jpg)  
对于求解出来的所有最大流分别计算整个网络的费用，求得如图10-87 所示的最大流即为安排列车的进站与出站，使得车站的总收益最大的方案，其中粗线箭头上的数字表示流量，未标数字的弧的流量为0。由图10-87 知，列车进站的最优安排方案为：让列车1、3 进站并停留在第一车道，列车2、5 进站并停留在第二车道，具体如图10-88 所示，其中粗线表示先停入列车1 再停入列车3；细线表示先停入列车2 再停入列车5。此时车站最大收益为$0.5+0.6+0.4+0.3=1.8$。",网络流图是最大流求解算法的应用场景
Ford-Fulkerson算法,属于,最大流求解算法,,"网络流理论的创立主要用于解决最大网络流问题，即在一定的约束条件下，如何使得网络中流的总量达到最大。该理论证明了最大流量一定等于最小割容量这个重要结论，并根据这一结论设计并实现了多种最大流的算法。其中比较经典的有Ford-Fulkerson 算法、Edmonds-Karp 算法、Dinic 算法以及预流推进算法等。  
本节主要介绍其中最具代表性的Ford-Fulkerson 算法。该算法由美国普林斯顿大学的两位著名运筹学教授Ford.L.R 和Fulkerson.D.R 提出。Ford-Fulkerson 算法是一种迭代算法，基本思路如下：首先，对所有结点$u,v\in V$令$f(u,v)=0$。然后，通过迭代的方式不断在残留网络中寻找一个增广路径来增加流值，直到残留网络中不包括增广路径为止。  
具体地说：首先，初始化一条容量为0 的流$f$和一个残余网络$G_{f}$，第一个残余网络为原  
图$G$，每条边的残留容量初始化为每条边的初始容量$c_{f}(u,v)=c(u,v)$。然后，在残留网络$G_{f}$中寻找增广路径$P$，取增广路径$P$中的边的残留容量$c_{f}(u,v)$最小值作为流的增量$\triangle\,f$，使得$f^{\prime}=f+\triangle\,f$。修改剩余图中每条边的容量：  
$$
c_{f}^{\prime}(u,v)=c_{f}(u,v)-\triangle\,f
$$  
得到残留网络$ G_{f}$。重复上述过程，直到找不到一条增广路径为止。  
Ford-Fulkerson 算法依赖于残留网络、增广路径和切割这三个概念。算法的正确性可由最大流最小切割定理保证。设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和𝑡分别为其源点和汇点，$f$为$G$的一个流，则该算法基本过程如下：  
1）对网络$G=\langle V,E\rangle$初始化，使$f(e)=0$，$e\in E$  
2）给源点𝑠标号$(-,\ \infty)$，其它结点均未标号；  
3）依次选一个未标号的结点，根据其方向进行标号，若当前标号的结点为汇点𝑡，转步骤4），否则转步骤6）；  
4）选择一条标号过的增流路径进行增流；  
5）转步骤2）  
6）这时得到的$f$就是最大可行流。  
对于如图10-72 为初始网络$G$，其中边上的数字表示对应边的容量，下面介绍通过Ford-Fulkerson 算法寻找其的最大可行流的具体实现过程：  
1）首先初始化$f(e)=0$，$e\in E$，如图10-73 所示；  
2）给源点$𝑠$标号$(-,\infty)$，其它结点均未标号，如图10-74 所示；  
![](images/d01d4ec14f1aff44a86873230240f7edbcb814f97a9366a1ac732e953b2aaa81.jpg)  
3 ）选可进行正向或反向标号的结点进行标号，若当前标号的结点为 𝑡 ，则转步骤 4 ） ； 若 没有这样的结点可选时，则转步骤6），如图10-75 所示；  
4）当前标号的结点为𝑡，对标号过的增流路径进行增流，增流路径为：$(s-\textit{a}-\textit{b}-$$c-\ t)$，增量$\triangle\,f$取增广路径中的边的残留容量$c_{f}(u,v)$最小值2，如图10-76 所示；  
5）转到步骤2），即给源点𝑠标号$(-,\infty)$，其它结点均未标号，如图10-77 所示；  
![](images/34aabd8b5a71470ee2b35d4d37961da9a5f6ada16975b230634ead0f16e07488.jpg)  
6）类似地，按照步骤3 再次进行标号，如图10-78 所示；  
7）当前标号的结点为𝑡，对标号过的增流路径进行增流，增流路径为：$(s-b-a-t)$增量$\triangle\,f$取增广路径中的边的残留容量$c_{f}(u,v)$最小值6，如图10-79 所示；  
8）同理，再对源点𝑠标号$(-,\ \infty)$，其他结点均未标号，如图10-80 所示；  
![](images/0f5b5f38aed586b9e60d5dccb4b3630e897dacff029a529f37f234c7155e86b7.jpg)  
9）按步骤3，再次进行标号，如图10-81 所示；  
10）当前标号的结点为𝑡，对标号过的增流路径进行增流，增流路径为：$\begin{array}{r l r}{~~~}&{{}(s-}&{b-a-}\end{array}$$t)$，增量$\triangle\,f$取增广路径中的边的残留容量$c_{f}(u,v)$最小值2，如图10-82 所示；  
11）同理，再对源点𝑠标号$(-,\ \infty)$，其他结点均未标号，类似的，增流路径为：$(s-\ b-$$c-t)$，增量$\triangle\,f$取1，如图10-83 所示；  
![](images/062c661062259beec86ff3629be8e97fdac80b28c61e2ace5ae35565f4731050.jpg)  
12）同理，再对源点𝑠标号$(-,\ \infty)$，其它结点均未标号，类似地，增流路径为：$\begin{array}{l l}{(s-}&{c-}\end{array}$$t)$，增量$\triangle\,f$取2，如图10-84 所示；  
13）同理，再对源点𝑠标号$(-,\ \infty)$，其它结点均未标号，类似地，增流路径为：$(s-c-$$b-a)$，此时当前结点为$a$，算法结束，所得可行流即为所求最大流，如图10-85 所示。  
![图10-84  增流过程  5](images/1913d4d69345305d204c147879cef0c2b861b90402556b9d5ebafe81eeaf5bff.jpg)  
![图10-85  网络$G$最大流  ](images/d7adb0913e78b96ab009478c7164178b41b7185b8446090115774418a82e3cf7.jpg)  
下面给出网络最大流的一个具体应用实例：  
【例题10.17】某货运车站有$n$个车道，由于车道长度有限，每个车道在某时刻最多只能停靠一列货运列车。车站正常运行后，每天有$m$列货运列车从车站经过，其中第$i$ 列列车到达车站的时间为$𝑅𝑒𝑎𝑐ℎ[𝑖]$，列车上装有价值$𝐶𝑜𝑠𝑡[𝑖]$的货物。如果准许列车𝑖进站，则车站将获得$10\%\times C o s t[i]$的收益，受到货物搬运时间制约，列车在站停留时间长度为$𝑆𝑡𝑎𝑦[𝑖]$。这段时间内，列车将占用车站某个车道；若不允许某列车进站，则该列车直接出站，此时车站无任何收益。现有2 个车道，5 列列车，列车进站时间、停车价值、停留时间如表10-1 所示，如何合理安排列车的进站与出站，才能使得车站的总收益最大？  
![表10-1 时间价值表 ](images/a7dc7c1c3b8b134efa88b94b361c280ae0e7e4db6c3d4edd361dc330595e5076.jpg)  
![图10-86 进出站时间 ](images/2c392864c4179f14536de4f9b63f959455c42ecc7344ede3aef7ced37250a84d.jpg)  
【解】可用一个流网络对该问题进行建模，具体过程如下：  
1）将每一列列车看成是联结两个结点的一条带权边，如第𝑖列列车拆成点$𝑖$和$i^{\prime}$，$𝑖$到$i^{\prime}$之间加一条容量为1，费用为$10\%\times C o s t[i]$的边$i\rightarrow i^{\prime}$；若$i\rightarrow i^{\prime}$的边的流量为1，则表示该列火车进站，并获得$10\%\times C o s t[i]$。  
2）增加一个源点$S$，$S$与每个点$i$连一条容量为1 费用为0 的边$S\rightarrow i$；如果$S\rightarrow i$的流量为1，则表示列车$𝑖$作为某个车道的第一列入站的列车  
3）再增加一个源点$S^{\prime}$，$S^{\prime}{\to}S$的容量为$n$，表示有$n$个车道；  
4）增加一个汇点$T$，每个点$i^{\prime}$与𝑇连一条容量为1 费用为0 的边$i^{\prime}\rightarrow T$；如果𝑖’ $\rightarrow T$的流量为1，则表示列车$𝑖$作为某个车道的最后一列入站的列车；  
5）对于所有$𝑖$和$j(i\neq j)$，如果$R e a c h[i]+S t a y[i]<R e a c h[j]$，则在$i^{\prime}$与$𝑗$之间连一条容量为1，费用为0 边，表示可以在某一个车道先停入列车𝑖，等𝑖出站后再停入列车𝑗。  
![图10-86 列车流量网络模型  ](images/e877c0962ea89c788357a0ce9a48c4f306c3bc33bc71d559136cc0a052c8c375.jpg)  
![图10-87 列车调度问题总收益最大流图  ](images/820628b77bdb2600c45369a5e8ccfe88b488f7bb28ab752799b5e76d0dabc2f0.jpg)  
如图10-86 所示的流网络为列车调度的流量网络模型，其中粗线箭头上的数字表示费用，未标数字的弧的费用为 0 ，未标明容量的弧的容量为 1 。  
![图10-88 列车进站安排  ](images/25158a79180787e9c0c3c5ee956180ccd3bcebdba893d1c1a3d3773d0bfcced1.jpg)  
对于求解出来的所有最大流分别计算整个网络的费用，求得如图10-87 所示的最大流即为安排列车的进站与出站，使得车站的总收益最大的方案，其中粗线箭头上的数字表示流量，未标数字的弧的流量为0。由图10-87 知，列车进站的最优安排方案为：让列车1、3 进站并停留在第一车道，列车2、5 进站并停留在第二车道，具体如图10-88 所示，其中粗线表示先停入列车1 再停入列车3；细线表示先停入列车2 再停入列车5。此时车站最大收益为$0.5+0.6+0.4+0.3=1.8$。",Ford-Fulkerson算法是一种最大流求解算法
最大流最小切割定理,保证,Ford-Fulkerson算法,,"网络流理论的创立主要用于解决最大网络流问题，即在一定的约束条件下，如何使得网络中流的总量达到最大。该理论证明了最大流量一定等于最小割容量这个重要结论，并根据这一结论设计并实现了多种最大流的算法。其中比较经典的有Ford-Fulkerson 算法、Edmonds-Karp 算法、Dinic 算法以及预流推进算法等。  
本节主要介绍其中最具代表性的Ford-Fulkerson 算法。该算法由美国普林斯顿大学的两位著名运筹学教授Ford.L.R 和Fulkerson.D.R 提出。Ford-Fulkerson 算法是一种迭代算法，基本思路如下：首先，对所有结点$u,v\in V$令$f(u,v)=0$。然后，通过迭代的方式不断在残留网络中寻找一个增广路径来增加流值，直到残留网络中不包括增广路径为止。  
具体地说：首先，初始化一条容量为0 的流$f$和一个残余网络$G_{f}$，第一个残余网络为原  
图$G$，每条边的残留容量初始化为每条边的初始容量$c_{f}(u,v)=c(u,v)$。然后，在残留网络$G_{f}$中寻找增广路径$P$，取增广路径$P$中的边的残留容量$c_{f}(u,v)$最小值作为流的增量$\triangle\,f$，使得$f^{\prime}=f+\triangle\,f$。修改剩余图中每条边的容量：  
$$
c_{f}^{\prime}(u,v)=c_{f}(u,v)-\triangle\,f
$$  
得到残留网络$ G_{f}$。重复上述过程，直到找不到一条增广路径为止。  
Ford-Fulkerson 算法依赖于残留网络、增广路径和切割这三个概念。算法的正确性可由最大流最小切割定理保证。设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和𝑡分别为其源点和汇点，$f$为$G$的一个流，则该算法基本过程如下：  
1）对网络$G=\langle V,E\rangle$初始化，使$f(e)=0$，$e\in E$  
2）给源点𝑠标号$(-,\ \infty)$，其它结点均未标号；  
3）依次选一个未标号的结点，根据其方向进行标号，若当前标号的结点为汇点𝑡，转步骤4），否则转步骤6）；  
4）选择一条标号过的增流路径进行增流；  
5）转步骤2）  
6）这时得到的$f$就是最大可行流。  
对于如图10-72 为初始网络$G$，其中边上的数字表示对应边的容量，下面介绍通过Ford-Fulkerson 算法寻找其的最大可行流的具体实现过程：  
1）首先初始化$f(e)=0$，$e\in E$，如图10-73 所示；  
2）给源点$𝑠$标号$(-,\infty)$，其它结点均未标号，如图10-74 所示；  
![](images/d01d4ec14f1aff44a86873230240f7edbcb814f97a9366a1ac732e953b2aaa81.jpg)  
3 ）选可进行正向或反向标号的结点进行标号，若当前标号的结点为 𝑡 ，则转步骤 4 ） ； 若 没有这样的结点可选时，则转步骤6），如图10-75 所示；  
4）当前标号的结点为𝑡，对标号过的增流路径进行增流，增流路径为：$(s-\textit{a}-\textit{b}-$$c-\ t)$，增量$\triangle\,f$取增广路径中的边的残留容量$c_{f}(u,v)$最小值2，如图10-76 所示；  
5）转到步骤2），即给源点𝑠标号$(-,\infty)$，其它结点均未标号，如图10-77 所示；  
![](images/34aabd8b5a71470ee2b35d4d37961da9a5f6ada16975b230634ead0f16e07488.jpg)  
6）类似地，按照步骤3 再次进行标号，如图10-78 所示；  
7）当前标号的结点为𝑡，对标号过的增流路径进行增流，增流路径为：$(s-b-a-t)$增量$\triangle\,f$取增广路径中的边的残留容量$c_{f}(u,v)$最小值6，如图10-79 所示；  
8）同理，再对源点𝑠标号$(-,\ \infty)$，其他结点均未标号，如图10-80 所示；  
![](images/0f5b5f38aed586b9e60d5dccb4b3630e897dacff029a529f37f234c7155e86b7.jpg)  
9）按步骤3，再次进行标号，如图10-81 所示；  
10）当前标号的结点为𝑡，对标号过的增流路径进行增流，增流路径为：$\begin{array}{r l r}{~~~}&{{}(s-}&{b-a-}\end{array}$$t)$，增量$\triangle\,f$取增广路径中的边的残留容量$c_{f}(u,v)$最小值2，如图10-82 所示；  
11）同理，再对源点𝑠标号$(-,\ \infty)$，其他结点均未标号，类似的，增流路径为：$(s-\ b-$$c-t)$，增量$\triangle\,f$取1，如图10-83 所示；  
![](images/062c661062259beec86ff3629be8e97fdac80b28c61e2ace5ae35565f4731050.jpg)  
12）同理，再对源点𝑠标号$(-,\ \infty)$，其它结点均未标号，类似地，增流路径为：$\begin{array}{l l}{(s-}&{c-}\end{array}$$t)$，增量$\triangle\,f$取2，如图10-84 所示；  
13）同理，再对源点𝑠标号$(-,\ \infty)$，其它结点均未标号，类似地，增流路径为：$(s-c-$$b-a)$，此时当前结点为$a$，算法结束，所得可行流即为所求最大流，如图10-85 所示。  
![图10-84  增流过程  5](images/1913d4d69345305d204c147879cef0c2b861b90402556b9d5ebafe81eeaf5bff.jpg)  
![图10-85  网络$G$最大流  ](images/d7adb0913e78b96ab009478c7164178b41b7185b8446090115774418a82e3cf7.jpg)  
下面给出网络最大流的一个具体应用实例：  
【例题10.17】某货运车站有$n$个车道，由于车道长度有限，每个车道在某时刻最多只能停靠一列货运列车。车站正常运行后，每天有$m$列货运列车从车站经过，其中第$i$ 列列车到达车站的时间为$𝑅𝑒𝑎𝑐ℎ[𝑖]$，列车上装有价值$𝐶𝑜𝑠𝑡[𝑖]$的货物。如果准许列车𝑖进站，则车站将获得$10\%\times C o s t[i]$的收益，受到货物搬运时间制约，列车在站停留时间长度为$𝑆𝑡𝑎𝑦[𝑖]$。这段时间内，列车将占用车站某个车道；若不允许某列车进站，则该列车直接出站，此时车站无任何收益。现有2 个车道，5 列列车，列车进站时间、停车价值、停留时间如表10-1 所示，如何合理安排列车的进站与出站，才能使得车站的总收益最大？  
![表10-1 时间价值表 ](images/a7dc7c1c3b8b134efa88b94b361c280ae0e7e4db6c3d4edd361dc330595e5076.jpg)  
![图10-86 进出站时间 ](images/2c392864c4179f14536de4f9b63f959455c42ecc7344ede3aef7ced37250a84d.jpg)  
【解】可用一个流网络对该问题进行建模，具体过程如下：  
1）将每一列列车看成是联结两个结点的一条带权边，如第𝑖列列车拆成点$𝑖$和$i^{\prime}$，$𝑖$到$i^{\prime}$之间加一条容量为1，费用为$10\%\times C o s t[i]$的边$i\rightarrow i^{\prime}$；若$i\rightarrow i^{\prime}$的边的流量为1，则表示该列火车进站，并获得$10\%\times C o s t[i]$。  
2）增加一个源点$S$，$S$与每个点$i$连一条容量为1 费用为0 的边$S\rightarrow i$；如果$S\rightarrow i$的流量为1，则表示列车$𝑖$作为某个车道的第一列入站的列车  
3）再增加一个源点$S^{\prime}$，$S^{\prime}{\to}S$的容量为$n$，表示有$n$个车道；  
4）增加一个汇点$T$，每个点$i^{\prime}$与𝑇连一条容量为1 费用为0 的边$i^{\prime}\rightarrow T$；如果𝑖’ $\rightarrow T$的流量为1，则表示列车$𝑖$作为某个车道的最后一列入站的列车；  
5）对于所有$𝑖$和$j(i\neq j)$，如果$R e a c h[i]+S t a y[i]<R e a c h[j]$，则在$i^{\prime}$与$𝑗$之间连一条容量为1，费用为0 边，表示可以在某一个车道先停入列车𝑖，等𝑖出站后再停入列车𝑗。  
![图10-86 列车流量网络模型  ](images/e877c0962ea89c788357a0ce9a48c4f306c3bc33bc71d559136cc0a052c8c375.jpg)  
![图10-87 列车调度问题总收益最大流图  ](images/820628b77bdb2600c45369a5e8ccfe88b488f7bb28ab752799b5e76d0dabc2f0.jpg)  
如图10-86 所示的流网络为列车调度的流量网络模型，其中粗线箭头上的数字表示费用，未标数字的弧的费用为 0 ，未标明容量的弧的容量为 1 。  
![图10-88 列车进站安排  ](images/25158a79180787e9c0c3c5ee956180ccd3bcebdba893d1c1a3d3773d0bfcced1.jpg)  
对于求解出来的所有最大流分别计算整个网络的费用，求得如图10-87 所示的最大流即为安排列车的进站与出站，使得车站的总收益最大的方案，其中粗线箭头上的数字表示流量，未标数字的弧的流量为0。由图10-87 知，列车进站的最优安排方案为：让列车1、3 进站并停留在第一车道，列车2、5 进站并停留在第二车道，具体如图10-88 所示，其中粗线表示先停入列车1 再停入列车3；细线表示先停入列车2 再停入列车5。此时车站最大收益为$0.5+0.6+0.4+0.3=1.8$。",最大流最小切割定理保证了Ford-Fulkerson算法的正确性
网络流图,相关,最大流最小切割定理,,"网络流理论的创立主要用于解决最大网络流问题，即在一定的约束条件下，如何使得网络中流的总量达到最大。该理论证明了最大流量一定等于最小割容量这个重要结论，并根据这一结论设计并实现了多种最大流的算法。其中比较经典的有Ford-Fulkerson 算法、Edmonds-Karp 算法、Dinic 算法以及预流推进算法等。  
本节主要介绍其中最具代表性的Ford-Fulkerson 算法。该算法由美国普林斯顿大学的两位著名运筹学教授Ford.L.R 和Fulkerson.D.R 提出。Ford-Fulkerson 算法是一种迭代算法，基本思路如下：首先，对所有结点$u,v\in V$令$f(u,v)=0$。然后，通过迭代的方式不断在残留网络中寻找一个增广路径来增加流值，直到残留网络中不包括增广路径为止。  
具体地说：首先，初始化一条容量为0 的流$f$和一个残余网络$G_{f}$，第一个残余网络为原  
图$G$，每条边的残留容量初始化为每条边的初始容量$c_{f}(u,v)=c(u,v)$。然后，在残留网络$G_{f}$中寻找增广路径$P$，取增广路径$P$中的边的残留容量$c_{f}(u,v)$最小值作为流的增量$\triangle\,f$，使得$f^{\prime}=f+\triangle\,f$。修改剩余图中每条边的容量：  
$$
c_{f}^{\prime}(u,v)=c_{f}(u,v)-\triangle\,f
$$  
得到残留网络$ G_{f}$。重复上述过程，直到找不到一条增广路径为止。  
Ford-Fulkerson 算法依赖于残留网络、增广路径和切割这三个概念。算法的正确性可由最大流最小切割定理保证。设有向图$G=\langle V,E\rangle$是任意一个网络流图，结点𝑠和𝑡分别为其源点和汇点，$f$为$G$的一个流，则该算法基本过程如下：  
1）对网络$G=\langle V,E\rangle$初始化，使$f(e)=0$，$e\in E$  
2）给源点𝑠标号$(-,\ \infty)$，其它结点均未标号；  
3）依次选一个未标号的结点，根据其方向进行标号，若当前标号的结点为汇点𝑡，转步骤4），否则转步骤6）；  
4）选择一条标号过的增流路径进行增流；  
5）转步骤2）  
6）这时得到的$f$就是最大可行流。  
对于如图10-72 为初始网络$G$，其中边上的数字表示对应边的容量，下面介绍通过Ford-Fulkerson 算法寻找其的最大可行流的具体实现过程：  
1）首先初始化$f(e)=0$，$e\in E$，如图10-73 所示；  
2）给源点$𝑠$标号$(-,\infty)$，其它结点均未标号，如图10-74 所示；  
![](images/d01d4ec14f1aff44a86873230240f7edbcb814f97a9366a1ac732e953b2aaa81.jpg)  
3 ）选可进行正向或反向标号的结点进行标号，若当前标号的结点为 𝑡 ，则转步骤 4 ） ； 若 没有这样的结点可选时，则转步骤6），如图10-75 所示；  
4）当前标号的结点为𝑡，对标号过的增流路径进行增流，增流路径为：$(s-\textit{a}-\textit{b}-$$c-\ t)$，增量$\triangle\,f$取增广路径中的边的残留容量$c_{f}(u,v)$最小值2，如图10-76 所示；  
5）转到步骤2），即给源点𝑠标号$(-,\infty)$，其它结点均未标号，如图10-77 所示；  
![](images/34aabd8b5a71470ee2b35d4d37961da9a5f6ada16975b230634ead0f16e07488.jpg)  
6）类似地，按照步骤3 再次进行标号，如图10-78 所示；  
7）当前标号的结点为𝑡，对标号过的增流路径进行增流，增流路径为：$(s-b-a-t)$增量$\triangle\,f$取增广路径中的边的残留容量$c_{f}(u,v)$最小值6，如图10-79 所示；  
8）同理，再对源点𝑠标号$(-,\ \infty)$，其他结点均未标号，如图10-80 所示；  
![](images/0f5b5f38aed586b9e60d5dccb4b3630e897dacff029a529f37f234c7155e86b7.jpg)  
9）按步骤3，再次进行标号，如图10-81 所示；  
10）当前标号的结点为𝑡，对标号过的增流路径进行增流，增流路径为：$\begin{array}{r l r}{~~~}&{{}(s-}&{b-a-}\end{array}$$t)$，增量$\triangle\,f$取增广路径中的边的残留容量$c_{f}(u,v)$最小值2，如图10-82 所示；  
11）同理，再对源点𝑠标号$(-,\ \infty)$，其他结点均未标号，类似的，增流路径为：$(s-\ b-$$c-t)$，增量$\triangle\,f$取1，如图10-83 所示；  
![](images/062c661062259beec86ff3629be8e97fdac80b28c61e2ace5ae35565f4731050.jpg)  
12）同理，再对源点𝑠标号$(-,\ \infty)$，其它结点均未标号，类似地，增流路径为：$\begin{array}{l l}{(s-}&{c-}\end{array}$$t)$，增量$\triangle\,f$取2，如图10-84 所示；  
13）同理，再对源点𝑠标号$(-,\ \infty)$，其它结点均未标号，类似地，增流路径为：$(s-c-$$b-a)$，此时当前结点为$a$，算法结束，所得可行流即为所求最大流，如图10-85 所示。  
![图10-84  增流过程  5](images/1913d4d69345305d204c147879cef0c2b861b90402556b9d5ebafe81eeaf5bff.jpg)  
![图10-85  网络$G$最大流  ](images/d7adb0913e78b96ab009478c7164178b41b7185b8446090115774418a82e3cf7.jpg)  
下面给出网络最大流的一个具体应用实例：  
【例题10.17】某货运车站有$n$个车道，由于车道长度有限，每个车道在某时刻最多只能停靠一列货运列车。车站正常运行后，每天有$m$列货运列车从车站经过，其中第$i$ 列列车到达车站的时间为$𝑅𝑒𝑎𝑐ℎ[𝑖]$，列车上装有价值$𝐶𝑜𝑠𝑡[𝑖]$的货物。如果准许列车𝑖进站，则车站将获得$10\%\times C o s t[i]$的收益，受到货物搬运时间制约，列车在站停留时间长度为$𝑆𝑡𝑎𝑦[𝑖]$。这段时间内，列车将占用车站某个车道；若不允许某列车进站，则该列车直接出站，此时车站无任何收益。现有2 个车道，5 列列车，列车进站时间、停车价值、停留时间如表10-1 所示，如何合理安排列车的进站与出站，才能使得车站的总收益最大？  
![表10-1 时间价值表 ](images/a7dc7c1c3b8b134efa88b94b361c280ae0e7e4db6c3d4edd361dc330595e5076.jpg)  
![图10-86 进出站时间 ](images/2c392864c4179f14536de4f9b63f959455c42ecc7344ede3aef7ced37250a84d.jpg)  
【解】可用一个流网络对该问题进行建模，具体过程如下：  
1）将每一列列车看成是联结两个结点的一条带权边，如第𝑖列列车拆成点$𝑖$和$i^{\prime}$，$𝑖$到$i^{\prime}$之间加一条容量为1，费用为$10\%\times C o s t[i]$的边$i\rightarrow i^{\prime}$；若$i\rightarrow i^{\prime}$的边的流量为1，则表示该列火车进站，并获得$10\%\times C o s t[i]$。  
2）增加一个源点$S$，$S$与每个点$i$连一条容量为1 费用为0 的边$S\rightarrow i$；如果$S\rightarrow i$的流量为1，则表示列车$𝑖$作为某个车道的第一列入站的列车  
3）再增加一个源点$S^{\prime}$，$S^{\prime}{\to}S$的容量为$n$，表示有$n$个车道；  
4）增加一个汇点$T$，每个点$i^{\prime}$与𝑇连一条容量为1 费用为0 的边$i^{\prime}\rightarrow T$；如果𝑖’ $\rightarrow T$的流量为1，则表示列车$𝑖$作为某个车道的最后一列入站的列车；  
5）对于所有$𝑖$和$j(i\neq j)$，如果$R e a c h[i]+S t a y[i]<R e a c h[j]$，则在$i^{\prime}$与$𝑗$之间连一条容量为1，费用为0 边，表示可以在某一个车道先停入列车𝑖，等𝑖出站后再停入列车𝑗。  
![图10-86 列车流量网络模型  ](images/e877c0962ea89c788357a0ce9a48c4f306c3bc33bc71d559136cc0a052c8c375.jpg)  
![图10-87 列车调度问题总收益最大流图  ](images/820628b77bdb2600c45369a5e8ccfe88b488f7bb28ab752799b5e76d0dabc2f0.jpg)  
如图10-86 所示的流网络为列车调度的流量网络模型，其中粗线箭头上的数字表示费用，未标数字的弧的费用为 0 ，未标明容量的弧的容量为 1 。  
![图10-88 列车进站安排  ](images/25158a79180787e9c0c3c5ee956180ccd3bcebdba893d1c1a3d3773d0bfcced1.jpg)  
对于求解出来的所有最大流分别计算整个网络的费用，求得如图10-87 所示的最大流即为安排列车的进站与出站，使得车站的总收益最大的方案，其中粗线箭头上的数字表示流量，未标数字的弧的流量为0。由图10-87 知，列车进站的最优安排方案为：让列车1、3 进站并停留在第一车道，列车2、5 进站并停留在第二车道，具体如图10-88 所示，其中粗线表示先停入列车1 再停入列车3；细线表示先停入列车2 再停入列车5。此时车站最大收益为$0.5+0.6+0.4+0.3=1.8$。",网络流图中的最大流问题与最大流最小切割定理相关
鼓轮设计问题,求解方法,欧拉回路,,"计算机鼓轮是由绝缘材料和导电材料制成，主要用于输出二进制数码。例如，对于如图10-7（a）所示的一个轮鼓，旋转鼓的表面分成了8 块扇形，图中阴影区表示用导电材料制成，空白区用绝缘材料制成，终端𝑎、𝑏和 $c$与扇面接触时接触导体输出1，接触绝缘体时输出0。鼓轮按逆时针旋转，触点每转一个扇区就输出一个三位二进制信号。  
问题是如何设计这8 块扇形区域绝缘材料与导电材料的分布，使得鼓轮每旋转一周，就能得到从000 到111 这8 个不同的二进制数。这就是计算机鼓论设计问题。从数学逻辑上看，这个问题也可理解为：如何将8 个二进制数码排成一个圆圈，使得任意3 个依次相连的数码组成的三位二进制数互不相同，而且能够产生全部8 个不同的三位二进制数。  
对于终端$a,b,c$，若某时刻的输出信号为$a_{1}a_{2}a_{3}$，则每转一个扇形，信号变成$a_{2}a_{3}a_{4}$。由此可见，前一次输出信号的右两位决定了后一次输出信号的左两位。故可把所有两位二进制数作为结点，将二进制数码之间传递关系的结点引一条有向边，将这两个二位二进制数进行串接并合并两者重复的部分，产生一个三位二进制数，并用这个三位二进制数表示该有向边。例如，对于结点$a_{1}a_{2}$和$a_{2}a_{3}$，可从$a_{1}a_{2}$到$a_{2}a_{3}$引一条有向边表示$a_{1}a_{2}a_{3}$这个三位的二进制数。由此得到如图10-7（b）所示的有向图。  
![图10-89 三位计算机轮鼓设计问题 ](images/fd2bd5a3740dee863b37e0bc2d2faadb7b3dbae1169c6c42913ac97c999411af.jpg)  
由于图10-7（b）所示有向图中每条边都代表一个三位二进制数，并且不同边表示不同的三位二进制数。因此，若能在该有向图上求出一条欧拉回路，则可得到该全部 8 个三位二进制数的一个圆排列，由该圆排列不难得到所求8 个二进制数码的圆排列。  
由图10-7（b）可知，该有向图4 个结点的出度和入度数均为2 故存在欧拉回路，比如$(e_{0},e_{1},e_{3},e_{7},e_{6},e_{5},e_{2},e_{4})$即是一条欧拉回路，根据该回路不难得到其对应的8 个二进制数码的圆排列为：00011101。按此数码排列分布计算机轮鼓8 块扇形区域绝缘材料与导电材料，则该鼓轮按逆时针每旋转一个扇区就输出一个三位二进制信号，鼓轮每旋转一周，就能得到从000 到111 这8 个不同的二进制数。  
上述所求的8 个二进制数码的圆排列00011101 称为一个8 位布鲁英序列。下面进一步考察16 位布鲁英序列。如图10-90（a）所示，此时旋转鼓的表面分成了16 块扇形，图中阴影区表示用导电材料制成，空白区用绝缘材料制成，终端$a$、$b$、𝑐和 $d$与扇面接触时接触导体输出1，接触绝缘体时输出0。鼓轮按逆时针旋转，触点每转一个扇区就输出一个二进制信号。问题是如何选取这16 块扇形的材料，使鼓轮旋转一周，触点能够输出个不同的四位二进制信号，并且每转一周就能得到从$0000{\sim}1111$ 这全部16 个四位二进制数。  
![图10-90 四位计算机轮鼓设计问题 ](images/5b3de38c173917b97e4ae2bdc5b3b0f102b52c396d35769298cedf57247d3416.jpg)  
从逻辑上看，四位计算机轮鼓设计问题也可理解为：把16 个二进制数排成一个圆圈，使得4 个依次相连的数字所组成的16 个四位二进制数互不相同。  
对于终端$a,b,c,d$，若某时刻的输出信号为$a_{1}a_{2}a_{3}a_{4}$，则每转一个扇形，信号变成$a_{2}a_{3}a_{4}a_{5}$。由此可以看出，前一次输出信号的右三位决定了后一次输出信号的左三位。因此，我们可把所有三位二进制数作结点，从每一个结点$a_{1}a_{2}a_{3}$到$a_{2}a_{3}a_{4}$引一条有向边表示$a_{1}a_{2}a_{3}a_{4}$这个四位的二进制数，作出表示所有可能的码变换的有向图如图10-90（b）所示。于是问题转化为在这个有向图上求一条欧拉回路。  
由图10-90（b）可知，该有向图8 个结点的出度和入度均为2，故存在欧拉回路，例如$e_{0},e_{1},e_{2},e_{4},e_{9},e_{3},e_{6},e_{13},e_{10},e_{5},e_{11},e_{7},e_{15},e_{14},e_{12},e_{8}$是一条欧拉回路，其对应布鲁英序列为0000100110101111。计算机轮鼓绝缘材料与导电材料按此序列分布便可满足要求。",鼓轮设计问题可以通过在有向图中寻找欧拉回路来解决，欧拉回路的存在确保了所有二进制数的圆排列
鼓轮设计问题,生成结果,布鲁英序列,,"计算机鼓轮是由绝缘材料和导电材料制成，主要用于输出二进制数码。例如，对于如图10-7（a）所示的一个轮鼓，旋转鼓的表面分成了8 块扇形，图中阴影区表示用导电材料制成，空白区用绝缘材料制成，终端𝑎、𝑏和 $c$与扇面接触时接触导体输出1，接触绝缘体时输出0。鼓轮按逆时针旋转，触点每转一个扇区就输出一个三位二进制信号。  
问题是如何设计这8 块扇形区域绝缘材料与导电材料的分布，使得鼓轮每旋转一周，就能得到从000 到111 这8 个不同的二进制数。这就是计算机鼓论设计问题。从数学逻辑上看，这个问题也可理解为：如何将8 个二进制数码排成一个圆圈，使得任意3 个依次相连的数码组成的三位二进制数互不相同，而且能够产生全部8 个不同的三位二进制数。  
对于终端$a,b,c$，若某时刻的输出信号为$a_{1}a_{2}a_{3}$，则每转一个扇形，信号变成$a_{2}a_{3}a_{4}$。由此可见，前一次输出信号的右两位决定了后一次输出信号的左两位。故可把所有两位二进制数作为结点，将二进制数码之间传递关系的结点引一条有向边，将这两个二位二进制数进行串接并合并两者重复的部分，产生一个三位二进制数，并用这个三位二进制数表示该有向边。例如，对于结点$a_{1}a_{2}$和$a_{2}a_{3}$，可从$a_{1}a_{2}$到$a_{2}a_{3}$引一条有向边表示$a_{1}a_{2}a_{3}$这个三位的二进制数。由此得到如图10-7（b）所示的有向图。  
![图10-89 三位计算机轮鼓设计问题 ](images/fd2bd5a3740dee863b37e0bc2d2faadb7b3dbae1169c6c42913ac97c999411af.jpg)  
由于图10-7（b）所示有向图中每条边都代表一个三位二进制数，并且不同边表示不同的三位二进制数。因此，若能在该有向图上求出一条欧拉回路，则可得到该全部 8 个三位二进制数的一个圆排列，由该圆排列不难得到所求8 个二进制数码的圆排列。  
由图10-7（b）可知，该有向图4 个结点的出度和入度数均为2 故存在欧拉回路，比如$(e_{0},e_{1},e_{3},e_{7},e_{6},e_{5},e_{2},e_{4})$即是一条欧拉回路，根据该回路不难得到其对应的8 个二进制数码的圆排列为：00011101。按此数码排列分布计算机轮鼓8 块扇形区域绝缘材料与导电材料，则该鼓轮按逆时针每旋转一个扇区就输出一个三位二进制信号，鼓轮每旋转一周，就能得到从000 到111 这8 个不同的二进制数。  
上述所求的8 个二进制数码的圆排列00011101 称为一个8 位布鲁英序列。下面进一步考察16 位布鲁英序列。如图10-90（a）所示，此时旋转鼓的表面分成了16 块扇形，图中阴影区表示用导电材料制成，空白区用绝缘材料制成，终端$a$、$b$、𝑐和 $d$与扇面接触时接触导体输出1，接触绝缘体时输出0。鼓轮按逆时针旋转，触点每转一个扇区就输出一个二进制信号。问题是如何选取这16 块扇形的材料，使鼓轮旋转一周，触点能够输出个不同的四位二进制信号，并且每转一周就能得到从$0000{\sim}1111$ 这全部16 个四位二进制数。  
![图10-90 四位计算机轮鼓设计问题 ](images/5b3de38c173917b97e4ae2bdc5b3b0f102b52c396d35769298cedf57247d3416.jpg)  
从逻辑上看，四位计算机轮鼓设计问题也可理解为：把16 个二进制数排成一个圆圈，使得4 个依次相连的数字所组成的16 个四位二进制数互不相同。  
对于终端$a,b,c,d$，若某时刻的输出信号为$a_{1}a_{2}a_{3}a_{4}$，则每转一个扇形，信号变成$a_{2}a_{3}a_{4}a_{5}$。由此可以看出，前一次输出信号的右三位决定了后一次输出信号的左三位。因此，我们可把所有三位二进制数作结点，从每一个结点$a_{1}a_{2}a_{3}$到$a_{2}a_{3}a_{4}$引一条有向边表示$a_{1}a_{2}a_{3}a_{4}$这个四位的二进制数，作出表示所有可能的码变换的有向图如图10-90（b）所示。于是问题转化为在这个有向图上求一条欧拉回路。  
由图10-90（b）可知，该有向图8 个结点的出度和入度均为2，故存在欧拉回路，例如$e_{0},e_{1},e_{2},e_{4},e_{9},e_{3},e_{6},e_{13},e_{10},e_{5},e_{11},e_{7},e_{15},e_{14},e_{12},e_{8}$是一条欧拉回路，其对应布鲁英序列为0000100110101111。计算机轮鼓绝缘材料与导电材料按此序列分布便可满足要求。",鼓轮设计问题的解决方案生成一个布鲁英序列，该序列表示二进制数的圆排列
欧拉回路,对应关系,布鲁英序列,,"计算机鼓轮是由绝缘材料和导电材料制成，主要用于输出二进制数码。例如，对于如图10-7（a）所示的一个轮鼓，旋转鼓的表面分成了8 块扇形，图中阴影区表示用导电材料制成，空白区用绝缘材料制成，终端𝑎、𝑏和 $c$与扇面接触时接触导体输出1，接触绝缘体时输出0。鼓轮按逆时针旋转，触点每转一个扇区就输出一个三位二进制信号。  
问题是如何设计这8 块扇形区域绝缘材料与导电材料的分布，使得鼓轮每旋转一周，就能得到从000 到111 这8 个不同的二进制数。这就是计算机鼓论设计问题。从数学逻辑上看，这个问题也可理解为：如何将8 个二进制数码排成一个圆圈，使得任意3 个依次相连的数码组成的三位二进制数互不相同，而且能够产生全部8 个不同的三位二进制数。  
对于终端$a,b,c$，若某时刻的输出信号为$a_{1}a_{2}a_{3}$，则每转一个扇形，信号变成$a_{2}a_{3}a_{4}$。由此可见，前一次输出信号的右两位决定了后一次输出信号的左两位。故可把所有两位二进制数作为结点，将二进制数码之间传递关系的结点引一条有向边，将这两个二位二进制数进行串接并合并两者重复的部分，产生一个三位二进制数，并用这个三位二进制数表示该有向边。例如，对于结点$a_{1}a_{2}$和$a_{2}a_{3}$，可从$a_{1}a_{2}$到$a_{2}a_{3}$引一条有向边表示$a_{1}a_{2}a_{3}$这个三位的二进制数。由此得到如图10-7（b）所示的有向图。  
![图10-89 三位计算机轮鼓设计问题 ](images/fd2bd5a3740dee863b37e0bc2d2faadb7b3dbae1169c6c42913ac97c999411af.jpg)  
由于图10-7（b）所示有向图中每条边都代表一个三位二进制数，并且不同边表示不同的三位二进制数。因此，若能在该有向图上求出一条欧拉回路，则可得到该全部 8 个三位二进制数的一个圆排列，由该圆排列不难得到所求8 个二进制数码的圆排列。  
由图10-7（b）可知，该有向图4 个结点的出度和入度数均为2 故存在欧拉回路，比如$(e_{0},e_{1},e_{3},e_{7},e_{6},e_{5},e_{2},e_{4})$即是一条欧拉回路，根据该回路不难得到其对应的8 个二进制数码的圆排列为：00011101。按此数码排列分布计算机轮鼓8 块扇形区域绝缘材料与导电材料，则该鼓轮按逆时针每旋转一个扇区就输出一个三位二进制信号，鼓轮每旋转一周，就能得到从000 到111 这8 个不同的二进制数。  
上述所求的8 个二进制数码的圆排列00011101 称为一个8 位布鲁英序列。下面进一步考察16 位布鲁英序列。如图10-90（a）所示，此时旋转鼓的表面分成了16 块扇形，图中阴影区表示用导电材料制成，空白区用绝缘材料制成，终端$a$、$b$、𝑐和 $d$与扇面接触时接触导体输出1，接触绝缘体时输出0。鼓轮按逆时针旋转，触点每转一个扇区就输出一个二进制信号。问题是如何选取这16 块扇形的材料，使鼓轮旋转一周，触点能够输出个不同的四位二进制信号，并且每转一周就能得到从$0000{\sim}1111$ 这全部16 个四位二进制数。  
![图10-90 四位计算机轮鼓设计问题 ](images/5b3de38c173917b97e4ae2bdc5b3b0f102b52c396d35769298cedf57247d3416.jpg)  
从逻辑上看，四位计算机轮鼓设计问题也可理解为：把16 个二进制数排成一个圆圈，使得4 个依次相连的数字所组成的16 个四位二进制数互不相同。  
对于终端$a,b,c,d$，若某时刻的输出信号为$a_{1}a_{2}a_{3}a_{4}$，则每转一个扇形，信号变成$a_{2}a_{3}a_{4}a_{5}$。由此可以看出，前一次输出信号的右三位决定了后一次输出信号的左三位。因此，我们可把所有三位二进制数作结点，从每一个结点$a_{1}a_{2}a_{3}$到$a_{2}a_{3}a_{4}$引一条有向边表示$a_{1}a_{2}a_{3}a_{4}$这个四位的二进制数，作出表示所有可能的码变换的有向图如图10-90（b）所示。于是问题转化为在这个有向图上求一条欧拉回路。  
由图10-90（b）可知，该有向图8 个结点的出度和入度均为2，故存在欧拉回路，例如$e_{0},e_{1},e_{2},e_{4},e_{9},e_{3},e_{6},e_{13},e_{10},e_{5},e_{11},e_{7},e_{15},e_{14},e_{12},e_{8}$是一条欧拉回路，其对应布鲁英序列为0000100110101111。计算机轮鼓绝缘材料与导电材料按此序列分布便可满足要求。",欧拉回路对应于一个布鲁英序列，通过欧拉回路可以得到二进制数的圆排列
哈密顿图,模型化,最优路线问题,,"如果想在较短的时间内旅游较多的景点，则需要确定一个合理的路线，尽量缩短旅游的路程，使总路程最短。该问题可用哈密顿图模型求解。  
首先，将旅游线路模型化。把每个旅游景点分别看作是加权无向图中的一个结点，各景点之间的直达公路看作加权无向图中对应结点间的边，将各条公路的长度分别看作其对应边上的权。有的景点之间尽管没有直达的公路，但是它们加权无向图中对应结点之间也要用边相连，而这条边的含义是：从其中一个景点出发，通过中转站到达另一景点所需的最短距离。  
此时，旅游景点之间的公路网就转化为加权无向图，寻找旅游各个景点近似最佳旅行线路问题就转化为：在给定的加权无向图中，寻找从给定的结点出发，行遍所有结点仅一次再回到该指定的结点，使得总权数最小，即总路程最短。可以运用图论中的最邻近插入法来寻找近似最佳旅游线路和路程。算法的基本步骤如下：  
步骤1：用沃舍尔∙弗洛伊德算法求出加权无向图中任意两点之间的最短路程，形成仅含一条边的初始道路$\left\langle i,j\right\rangle$，权$w(i,j)$表示道路$\langle i,j\rangle$的长度。  
步骤2：设$x$表示最新加到这道路$\langle i,j\rangle$上的景点，从不属于该条道路上所有景点中选一个与景点$x$距离最近的景点𝑦，把连接景点$x$与景点𝑦的边加到$\langle i,j\rangle$上。重复这个步骤，直到加权无向图中所有景点都包含到$\left\langle i,j\right\rangle$这条路上。  
步骤3：将连接起点与最后加入景点之间的边加到这条路上，就得到一个总权数最小的汉密尔顿回路。  
![](images/3eb5c42c98242b09cf1d107a9f19a39189dbcd95c1ca7e77768503681d0519c4.jpg)  
下面结合具体实例说明寻找近似最佳旅行线路的具体构造过程。  
从上述讨论和例题10.18 可以看出，遍历多个景点的最短旅游路线问题，其实就是从具有$n$个结点的无向带权完全图中寻找一条哈密顿回路的问题。如果景点个数较多的时候，比如说几十个或者上百个，则上述算法就非常复杂甚至不可行。  
这其实是图论中的一个著名问题，通常称之为货郎担问题。因为该问题也可以描述为：某地区共有${n}$个村庄，某售货员从他所在的某个村庄出发，前往其它$𝑛$−1个村庄一次且恰好一次，最后返回到他所在的村庄，求一条满足上述要求且总路程最短的回路。  
货郎担问题是一个十分有趣而且具有实用价值的问题，很多数学家和计算机科学家对该问题做了大量的研究，取得了丰硕的研究成果。但是，遗憾的是至今无法找到一个有效的精  
确算法，这显然是一个 NP-hard 问题，当图中结点较多时，精确算法由于计算量过于巨大而变得不可行。目前，对该问题的求解主要采用近似算法，例如在例题10.18 中使用的最近邻算法，除此之外还有抄近路算法、动态规划算法、模拟退火算法、遗传算法、蚁群算法等等，读者可参阅相关的资料进一步深入学习。",哈密顿图用于模型化最优路线问题，通过寻找哈密顿回路来求解总路程最短的问题
最邻近插入法,求解,最优路线问题,,"如果想在较短的时间内旅游较多的景点，则需要确定一个合理的路线，尽量缩短旅游的路程，使总路程最短。该问题可用哈密顿图模型求解。  
首先，将旅游线路模型化。把每个旅游景点分别看作是加权无向图中的一个结点，各景点之间的直达公路看作加权无向图中对应结点间的边，将各条公路的长度分别看作其对应边上的权。有的景点之间尽管没有直达的公路，但是它们加权无向图中对应结点之间也要用边相连，而这条边的含义是：从其中一个景点出发，通过中转站到达另一景点所需的最短距离。  
此时，旅游景点之间的公路网就转化为加权无向图，寻找旅游各个景点近似最佳旅行线路问题就转化为：在给定的加权无向图中，寻找从给定的结点出发，行遍所有结点仅一次再回到该指定的结点，使得总权数最小，即总路程最短。可以运用图论中的最邻近插入法来寻找近似最佳旅游线路和路程。算法的基本步骤如下：  
步骤1：用沃舍尔∙弗洛伊德算法求出加权无向图中任意两点之间的最短路程，形成仅含一条边的初始道路$\left\langle i,j\right\rangle$，权$w(i,j)$表示道路$\langle i,j\rangle$的长度。  
步骤2：设$x$表示最新加到这道路$\langle i,j\rangle$上的景点，从不属于该条道路上所有景点中选一个与景点$x$距离最近的景点𝑦，把连接景点$x$与景点𝑦的边加到$\langle i,j\rangle$上。重复这个步骤，直到加权无向图中所有景点都包含到$\left\langle i,j\right\rangle$这条路上。  
步骤3：将连接起点与最后加入景点之间的边加到这条路上，就得到一个总权数最小的汉密尔顿回路。  
![](images/3eb5c42c98242b09cf1d107a9f19a39189dbcd95c1ca7e77768503681d0519c4.jpg)  
下面结合具体实例说明寻找近似最佳旅行线路的具体构造过程。  
从上述讨论和例题10.18 可以看出，遍历多个景点的最短旅游路线问题，其实就是从具有$n$个结点的无向带权完全图中寻找一条哈密顿回路的问题。如果景点个数较多的时候，比如说几十个或者上百个，则上述算法就非常复杂甚至不可行。  
这其实是图论中的一个著名问题，通常称之为货郎担问题。因为该问题也可以描述为：某地区共有${n}$个村庄，某售货员从他所在的某个村庄出发，前往其它$𝑛$−1个村庄一次且恰好一次，最后返回到他所在的村庄，求一条满足上述要求且总路程最短的回路。  
货郎担问题是一个十分有趣而且具有实用价值的问题，很多数学家和计算机科学家对该问题做了大量的研究，取得了丰硕的研究成果。但是，遗憾的是至今无法找到一个有效的精  
确算法，这显然是一个 NP-hard 问题，当图中结点较多时，精确算法由于计算量过于巨大而变得不可行。目前，对该问题的求解主要采用近似算法，例如在例题10.18 中使用的最近邻算法，除此之外还有抄近路算法、动态规划算法、模拟退火算法、遗传算法、蚁群算法等等，读者可参阅相关的资料进一步深入学习。",最邻近插入法是一种用于求解最优路线问题的近似算法，通过逐步插入最近景点来构建近似最佳旅游线路
货郎担问题,等价,最优路线问题,,"如果想在较短的时间内旅游较多的景点，则需要确定一个合理的路线，尽量缩短旅游的路程，使总路程最短。该问题可用哈密顿图模型求解。  
首先，将旅游线路模型化。把每个旅游景点分别看作是加权无向图中的一个结点，各景点之间的直达公路看作加权无向图中对应结点间的边，将各条公路的长度分别看作其对应边上的权。有的景点之间尽管没有直达的公路，但是它们加权无向图中对应结点之间也要用边相连，而这条边的含义是：从其中一个景点出发，通过中转站到达另一景点所需的最短距离。  
此时，旅游景点之间的公路网就转化为加权无向图，寻找旅游各个景点近似最佳旅行线路问题就转化为：在给定的加权无向图中，寻找从给定的结点出发，行遍所有结点仅一次再回到该指定的结点，使得总权数最小，即总路程最短。可以运用图论中的最邻近插入法来寻找近似最佳旅游线路和路程。算法的基本步骤如下：  
步骤1：用沃舍尔∙弗洛伊德算法求出加权无向图中任意两点之间的最短路程，形成仅含一条边的初始道路$\left\langle i,j\right\rangle$，权$w(i,j)$表示道路$\langle i,j\rangle$的长度。  
步骤2：设$x$表示最新加到这道路$\langle i,j\rangle$上的景点，从不属于该条道路上所有景点中选一个与景点$x$距离最近的景点𝑦，把连接景点$x$与景点𝑦的边加到$\langle i,j\rangle$上。重复这个步骤，直到加权无向图中所有景点都包含到$\left\langle i,j\right\rangle$这条路上。  
步骤3：将连接起点与最后加入景点之间的边加到这条路上，就得到一个总权数最小的汉密尔顿回路。  
![](images/3eb5c42c98242b09cf1d107a9f19a39189dbcd95c1ca7e77768503681d0519c4.jpg)  
下面结合具体实例说明寻找近似最佳旅行线路的具体构造过程。  
从上述讨论和例题10.18 可以看出，遍历多个景点的最短旅游路线问题，其实就是从具有$n$个结点的无向带权完全图中寻找一条哈密顿回路的问题。如果景点个数较多的时候，比如说几十个或者上百个，则上述算法就非常复杂甚至不可行。  
这其实是图论中的一个著名问题，通常称之为货郎担问题。因为该问题也可以描述为：某地区共有${n}$个村庄，某售货员从他所在的某个村庄出发，前往其它$𝑛$−1个村庄一次且恰好一次，最后返回到他所在的村庄，求一条满足上述要求且总路程最短的回路。  
货郎担问题是一个十分有趣而且具有实用价值的问题，很多数学家和计算机科学家对该问题做了大量的研究，取得了丰硕的研究成果。但是，遗憾的是至今无法找到一个有效的精  
确算法，这显然是一个 NP-hard 问题，当图中结点较多时，精确算法由于计算量过于巨大而变得不可行。目前，对该问题的求解主要采用近似算法，例如在例题10.18 中使用的最近邻算法，除此之外还有抄近路算法、动态规划算法、模拟退火算法、遗传算法、蚁群算法等等，读者可参阅相关的资料进一步深入学习。",货郎担问题与最优路线问题等价，都是寻找遍历所有结点且总路程最短的回路
货郎担问题,应用,最邻近插入法,,"如果想在较短的时间内旅游较多的景点，则需要确定一个合理的路线，尽量缩短旅游的路程，使总路程最短。该问题可用哈密顿图模型求解。  
首先，将旅游线路模型化。把每个旅游景点分别看作是加权无向图中的一个结点，各景点之间的直达公路看作加权无向图中对应结点间的边，将各条公路的长度分别看作其对应边上的权。有的景点之间尽管没有直达的公路，但是它们加权无向图中对应结点之间也要用边相连，而这条边的含义是：从其中一个景点出发，通过中转站到达另一景点所需的最短距离。  
此时，旅游景点之间的公路网就转化为加权无向图，寻找旅游各个景点近似最佳旅行线路问题就转化为：在给定的加权无向图中，寻找从给定的结点出发，行遍所有结点仅一次再回到该指定的结点，使得总权数最小，即总路程最短。可以运用图论中的最邻近插入法来寻找近似最佳旅游线路和路程。算法的基本步骤如下：  
步骤1：用沃舍尔∙弗洛伊德算法求出加权无向图中任意两点之间的最短路程，形成仅含一条边的初始道路$\left\langle i,j\right\rangle$，权$w(i,j)$表示道路$\langle i,j\rangle$的长度。  
步骤2：设$x$表示最新加到这道路$\langle i,j\rangle$上的景点，从不属于该条道路上所有景点中选一个与景点$x$距离最近的景点𝑦，把连接景点$x$与景点𝑦的边加到$\langle i,j\rangle$上。重复这个步骤，直到加权无向图中所有景点都包含到$\left\langle i,j\right\rangle$这条路上。  
步骤3：将连接起点与最后加入景点之间的边加到这条路上，就得到一个总权数最小的汉密尔顿回路。  
![](images/3eb5c42c98242b09cf1d107a9f19a39189dbcd95c1ca7e77768503681d0519c4.jpg)  
下面结合具体实例说明寻找近似最佳旅行线路的具体构造过程。  
从上述讨论和例题10.18 可以看出，遍历多个景点的最短旅游路线问题，其实就是从具有$n$个结点的无向带权完全图中寻找一条哈密顿回路的问题。如果景点个数较多的时候，比如说几十个或者上百个，则上述算法就非常复杂甚至不可行。  
这其实是图论中的一个著名问题，通常称之为货郎担问题。因为该问题也可以描述为：某地区共有${n}$个村庄，某售货员从他所在的某个村庄出发，前往其它$𝑛$−1个村庄一次且恰好一次，最后返回到他所在的村庄，求一条满足上述要求且总路程最短的回路。  
货郎担问题是一个十分有趣而且具有实用价值的问题，很多数学家和计算机科学家对该问题做了大量的研究，取得了丰硕的研究成果。但是，遗憾的是至今无法找到一个有效的精  
确算法，这显然是一个 NP-hard 问题，当图中结点较多时，精确算法由于计算量过于巨大而变得不可行。目前，对该问题的求解主要采用近似算法，例如在例题10.18 中使用的最近邻算法，除此之外还有抄近路算法、动态规划算法、模拟退火算法、遗传算法、蚁群算法等等，读者可参阅相关的资料进一步深入学习。",货郎担问题的求解可以采用最邻近插入法作为近似算法之一
稳定婚配问题,应用,网络流图,,"在某婚姻介绍所，假设有若干个单身男子和同样多的单身女子前来征婚，并且媒人已知其中每个女孩在每个男孩心目中的排名，以及每个男孩在每个女孩心目中的排名，应该怎样为他们牵线配对呢？最好的方案当然是每个人的另一半正好都是自己的第一选择，但是这通常不能实现。例如，如果男1 号最喜欢的是女1 号，而女1 号的最爱不是男1 号，那么两个人的最佳选择不可能被同时满足。再如，如果好几个男孩最喜欢的都是同一个女孩，那么这几个男孩的首选也不会同时得到满足。那么怎样的配对才合理？  
其实，媒人给客户介绍对象，最关心的是成功率，即婚姻的稳定性。找的对象太完美不见得就稳定。例如，如果男1 号和女1 号各有各的对象，但男1 号觉得女1 号比现女友更好一些；女1 号也发现男1 号比现男友更好。此时，两人就会抛弃各自现在的对象。若出现这种情况，则婚姻搭配是不稳定的。因此，媒人给客户牵线配对时，虽然不能让每个人都得到最满意的，但搭配必须得稳定，即实现稳定的婚配问题。换句话说，对于任何男子，在他心目中比他当前伴侣更好的女性，都不会认为他是该女性一个更好的选择，对于任何一个女子也是这样。这就是稳定婚配问题。下面结合具体实例介绍稳定婚配问题求解算法。  
设有${n}$个男士的集合$X=\{X_{1},X_{2},\cdots X_{n}\}$和${n}$个女士$Y=\{Y_{1},Y_{2},\cdots,Y_{n}\}.$。每个男士有一个排序的列表，把女士按照其结婚对象优先级进行排序。同样，每个女士也有一个关于男士的优先级列表，如表10-4 和表10-5 所示。可用如表10-6 所示的$n$维矩阵表示表10-2 和表$10-$3 的信息，其中$p$行$q$列的的元素包含两个序号，第一个为对应女士在该对应男士的优先列表中的序号，第二个为对应女士在该对应男士的优先列表中的序号。例如，第3 行第2 列的元素2,1 表示，女士$b$是男士𝐶的第二选择，而男士$C$是女士$^{\cdot b}$的第一选择。稳定的婚姻搭配总是存在吗？如果存在，应该怎样设计？  
![表10-4 男士的优先选择      表10-5 女士的优先选择        表10-6 等级矩阵](images/eeb4d95ed93c439b00277ad6b2abb0debc1221b5f2be434ac75d9ca0a75c470d.jpg)  
下面给出稳定婚配算法：  
第一步：初始时，集合𝑋所有男士和集合𝑌中女士都是自由的。  
第二步：如果集合𝑋有自由男士，从中任选一个男士$X_{i}$，然后执行以下步骤：  
求婚：选中的自由男士$X_{i}$向女士$Y_{j}$求婚，其中$Y_{j}$是$X_{i}$的优先列表中当前最佳人选，即当前没有拒绝过他且优先级最高女士。  
回应：如果𝑌𝑗是自由的，则她接受求婚并与$X_{i}$配对。如果𝑌𝑗不是自由的，她将$X_{i}$与其当前的配偶做比较。如果她更喜欢$X_{i}$，则接受$X_{i}$的求婚，她的前配偶就变成自由人。否则，她就拒绝$X_{i}$的求婚，$X_{i}$还是自由的。  
第三步：返回$n$个匹配对的集合。  
很容易得出该算法不超过$ n^{2}$迭代就会终止。  
现以表10-6 所示等级矩阵为例，介绍使用稳定婚姻算法的具体计算过程：  
1） 现有自由男士𝐴，$B$，$C。 A$向当前最佳人选$b$女士求婚，由于$𝑏$是自由的，故$𝑏$接受。如表10-7 所示，其中括号表示被接受的求婚，下划线表示被拒绝的求婚，下同。  
2） 现有自由男士$𝐵$，$𝐶$。$B$当前最佳人选$b$女士求婚，由于$𝑏$不是自由的，她把$𝐵$与当前配偶$𝐴$做比较，由于$𝐴$的优先级较高，故拒绝$B$的求婚，如表10-8 所示：  
3） 现有自由男士$ B$，$C$。$B$向当前最佳人选$c$女士求婚，由于$c$是自由的，故$𝑐$接受。如表10-9 所示：  
表10-7 算法步骤1 效果        表10-8 算法步骤2 效果       表10-9 算法步骤3 效果
![](images/04f6613bd702aca04822bcc29a5b6aa1c146fd849ed7d7f1b4075e32f9ac7c21.jpg)  
4） 现有自由男士𝐶。$C$向其当前最佳人选$c$女士求婚，由于$c$不是自由的，她把𝐶和当前配偶$B$做比较，由于$\cdot B$的优先级较高，故拒绝$𝐶$的求婚。如表10-10 所示：  
5） 现有自由男士$𝐶$。$C$向其当前最佳人选$b$女士求婚，由于$b$不是自由的，她把𝐶和当前配偶$𝐴$做比较，由于$C$的优先级较高，故$𝐶$替换掉$𝐴$。如表10-11 所示：  
6） 现在有自由男士𝐴。𝐴其当前最佳人选$a$女士求婚，由于$a$是自由的，所以$a$接受了。如表10-12 所示：  
![表10-10 算法步骤3 效果       表10-11 算法步骤3 效果        表10-12 算法步骤3 效果 ](images/2f07c86d6a24dc95791ee60bf8db01f7f6a3315e5959c792dba3c38b6b45fab3.jpg)  
下面证明以上的匹配是一个稳定的婚姻匹配$𝑀$：由于该算法在所有$n$个男士和$n$个女士一一配对后停止，故仅需证明$𝑀$的稳定性。用反证法。假设$M$是不稳定的，则必然存在一个男士$𝑋$和一个女士$𝑌$，它们在$𝑀$中没有匹配，但比当前$M$中配偶更倾向于对方。  
因为$𝑋$按照降序对其优先列表中的每个女士求婚，而$𝑌$优先于$𝑋$在$M$中的配偶，$X$一定在某次迭代的时候向$𝑌$求过婚。无论$𝑌$拒绝了$𝑋$的求婚，还是先接受然后又在后面的迭代中用其他人替换掉了$𝑋$，$𝑌$的配偶在$𝑌$中的优先级列表中一定比$𝑋$有更高的优先级。根据前面假设：相对于$𝑋$在𝑀中的配偶，$𝑌$更倾向于$𝑋$，故该结论和假设矛盾。因此，$M$是稳定婚配。",稳定婚配问题可以通过构建网络流图来解决，利用网络流图的算法实现稳定的婚姻匹配。
抽象代数结构,包含,代数结构的基本概念,,"我们知道，小学数学中关于整数或分数的四则运算称之为算术，初中数学则将这些具体整数或分数抽象成字母，着重考察这些字母表达式的运算性质与运算技巧，称之为初等代数或代数。从本质上说，所谓代数，其实就是以运算为基本手段寻求针对某一类问题的通用求解方法或计算公式。因此，可运算性和通用性是代数学的两个核心要点。初等代数之所以用抽象字母代替具体的数，是因为字母比数更具一般性和通用性。事实上，我们的处理对象除数之外通常还有很多其它类型，例如向量、矩阵、命题、集合、函数、关系、图模型等等，这些对象都分别具有各自的运算及运算性质。那么就有一个想法：是否可以对这些对象做进一步抽象？具体地说，就是如同用字母表示数一样用一种抽象对象来统一表示这些各种各样的具体对象，并用一些抽象运算统一表示这些具体对象各自的运算及运算性质，从更加抽象的角度来考察这些不同对象所共有的一般性运算性质与规律，或者说从更加抽象的层次上根据运算性质的差异对这些不同对象进行分类。  
基于以上思想，就可得到抽象代数结构的概念。该结构是在初等代数抽象层次上的进一步抽象，其运算和运算性质具有更高层次的通用性和普适性。抽象代数结构的出现使得代数学由主要针对各种运算技巧的研究转变为主要针对各种运算性质和运算结构的研究，开辟了数学代数学发展的新纪元，将代数学带入了一个全新的发展阶段。从计算机的角度看，计算机处理的信息对象多种多样的且分别具有各自的运算和运算性质。对这些信息的处理一般需要建立若干抽象数据类型并将与之相关的数据运算封装于其中，并从抽象的角度考察它们的共同运算性质和运算规律。抽象代数结构的相关理论和技术可以为这些抽象的数据类型及相关运算的设计提供基本思路和方法技巧。此外，还可使用抽象代数结构理论设计出各种各样满足实际问题需要的计算模型。目前，这些计算模型已经在信息编码与纠错、自动机与形式语言、大数据信息处理与知识发现、信息安全等众多领域得到广泛应用。  
学习抽象代数结构知识不仅可以掌握抽象数据类型和计算模型的设计技巧，更为重要的是能够使得读者具备一种高度抽象的思维能力，可以站在比较高的层次上看待、分析和解决问题，获得一种更加宽广的视野。本章主要介绍抽象代数结构的基本知识，包括代数结构的基本概念、代数结构与子代数、代数结构的运算性质、代数结构的同态与同构等。",抽象代数结构的基本知识包括代数结构的基本概念
集合代数,运算性质相同,命题代数,,抽象代数结构的基本思想是以主动的方式定义一个由若干抽象对象为元素构成的集合，并在这个集合上定义一个或多个抽象运算，由此形成一个抽象的代数运算系统，然后通过研究和讨论这个代数运算系统的运算性质获得该运算系统的结构。相对于传统的初等代数，这是一种全新的思维方式和观察问题的角度。从这个角度看过去，会得到很多令人惊讶的新认识。例如，集合代数有交、并、补运算，命题代数有与、或、非运算，从抽象代数结构上看，两者的运算性质完全相同，或者说两者是同一抽象代数不同表现形式；再如，实数集合上的加法和正实数上的乘法也是本质相同外表不同，加法中的0 其实就是乘法中的1。,集合代数和命题代数在抽象代数结构上具有相同的运算性质，是同一抽象代数的不同表现形式
实数集合上的加法,本质相同,正实数上的乘法,,抽象代数结构的基本思想是以主动的方式定义一个由若干抽象对象为元素构成的集合，并在这个集合上定义一个或多个抽象运算，由此形成一个抽象的代数运算系统，然后通过研究和讨论这个代数运算系统的运算性质获得该运算系统的结构。相对于传统的初等代数，这是一种全新的思维方式和观察问题的角度。从这个角度看过去，会得到很多令人惊讶的新认识。例如，集合代数有交、并、补运算，命题代数有与、或、非运算，从抽象代数结构上看，两者的运算性质完全相同，或者说两者是同一抽象代数不同表现形式；再如，实数集合上的加法和正实数上的乘法也是本质相同外表不同，加法中的0 其实就是乘法中的1。,实数集合上的加法和正实数上的乘法在本质上是相同的，只是表现形式不同，加法中的0对应乘法中的1
代数结构,属于,数学结构,,"代数结构作为四大基本数学结构之一，它以运算作为处理机制，在整个数学理论体系和计算机数学建模中占据非常重要的作用。代数结构是一种非常古老的数学结构，具有几千年发展历程，从最初初等代数逐步发展到大代数，然后进一步发展到抽象代数，目前正朝着泛代数的方向发展。本小节主要介绍抽象代数的由来及其基本知识结构。  
用计算机解决实际问题，一般需要对问题进行抽象并建立相应的数学模型，然后在此基础上将对实际问题的求解转化为对数学模型的求解。 因此，数学模型是用计算机解决实际问题的基础。现实问题纷繁复杂、变化万千，所建立的数学模型自然也是五花八门，多种多样，让人无所适从。值得欣慰的是，尽管我们面对的数学模型复杂多样，但从结构上看，所有这些数学模型都建立在四种基本的数学结构基础之上。  
这四种基本数学结构分别为：表示元素之间空间关系的拓扑结构，如图模型、树模型就是一些拓扑结构；表示元素之间运算关系的代数结构，如初等代数、向量代数、矩阵代数、命题代数、集合代数等都是代数结构；表示元素规模度量性质的测度结构，如高等数学里函数的微分和积分都是测度结构，它们主要计算面积、体积、弧长、速度等；表示元素之间次序关系的偏序结构，如整数的整除关系、集合的包含关系等偏序关系都是偏序结构。  
任何一个数学结构都是由载体、处理机制和处理规则这三个基本要素组成：  
（1）载体集合 对于任何一个数学结构，需要定义一些抽象的元素作为处理对象，这些抽象元素组成的集合构成数学结构的载体。载体集合是数学结构存在的基础或平台。  
（2）处理机制 为了实现对数学结构载体中元素的处理，需要定义一些处理机制，不同的数学结构具有不同的处理机制。例如：偏序结构是一种关系结构，它以元素之间的次序关系或者比较关系作为处理机制；代数结构是一种运算结构，它以元素之间的运算作为处理机制；拓扑结构是一种分布结构，它以元素之间的空间分布作为处理机制；测度结构则是一种度量结构，它以元素的规模度量作为处理机制。  
（3）处理规则 为使定义出来的数学结构满足一些合理性要求以及能够在处理实际问题中发挥作用，避免出现一些矛盾或荒诞的处理结果，还必须制定一些处理规则对处理机制做一些必要的限制。在现代数学的公理化系统中，通常称这些处理规则称为公理。不同的数学结构具有不同的处理规则，例如偏序结构限制元素之间的关系必须满足自反性、反对称性和传递性，这些限制或者性质构成了偏序结构公理系统；再如代数结构则是规定元素之间的运算必须满足结合律、交换律、分配律等运算性质。  
数学运算最早起源于算术运算，即使用具体的整数或分数进行四则运算。随着科学技术的不断发展，人们逐步意识到这种方法不能满足对一般性规律的认识。因此，采用抽象的字母来代替具体的整数和分数进行运算以获得通用性结果，并称之为代数运算或简称为代数。在微积分出现之前的数千年历史中，对代数运算的研究一直占据数学研究的核心地位。那时人们普遍信奉一种所谓的万能法则，即世界上所有问题都可以转化为数学问题，所有数学问题都可以转化为代数问题，所有代数问题都可以转化为方程问题。  
因此，在很长一段历史时期内，人们对数学的研究基本上都是对代数学的研究，对代数学的研究基本上是方程或方程组解法的研究。解方程是那个时期内所有数学家的中心任务，大家都非常期望能够通过使用代数运算的方法找到方程或方程组的通用求解公式。这种努力在线性方程组领域取得了非常完美的结果，并由初等代数逐步衍生出线性代数。但是，对于一元高次方程通用求解方法的研究并不是很顺利，对于次数高于四次的一元方程始终找不到通用求解公式或求解方法。一些非常著名的数学家，例如欧拉、高斯、拉格朗日等都对此做了大量非常艰苦的研究，但均告失败。  
在寻求五次方程通用求解方法的过程中，年仅17 岁的法国天才少年伽罗瓦在1828 年提出群的概念，运用群的思想证明了五次方程通用求解公式是不存在的，并给出了五次方程系数在满足一定条件下若干特殊解法，由此一举解决了困扰数学家长达200 多年的数学问题。伽罗瓦取得成功的关键在于不仅将运算对象进行抽象化，而且对运算本身进行抽象，在抽象对象和抽象运算的基础上通过构造一些特殊抽象代数结构进行求解。这个思想在当时实在过于超前以至于没有得到柯西、傅里叶、泊松等著名数学家的认可，泊松的判词是“完全不能理解”。 1832 年5 月31 日年仅21 岁的伽罗瓦死于决斗。在决斗之前，他把关于五次方程代数求解的研究成果写成长信，留给了人类。14 年后，法国数学家刘维尔整理并发表了伽罗瓦的遗作，人们才理解并惊叹他那超越时代的天才思想和巧妙构思。  
至此以后，人们对代数的研究内容由方程或方程组的求解技巧转变为对代数运算性质和运算结构的研究，通过对运算和运算对象进行抽象的方式实现对所有运算依其运算性质进行分类或归类，并将伽罗瓦的群论迅速发展成为一门称之为抽象代数结构的崭新数学分支。 抽象代数结构的诞生，把代数学从传统的初等代数发展到现代的抽象代数，由此打开了现代代数学的大门，开创了代数学研究的新纪元。因此，抽象代数结构通常也称为近世代数以区别于之前的初等代数。若无特别说明，我们通常将抽象代数结构简称为代数结构。  
经过一百多年的发展，抽象代数结构已经形成一个如图11-1 所示的知识体系。对于一个代数系统，我们不仅可以主动设计出它的运算并考察相应的运算规则，而且还可以通过分别对其载体集合进行相关改造或运算得到相应的子代数、积代数和商代数，可以通过映射的方式考察不同代数结构之间的区别与联系，还可根据运算性质对代数结构进行分类，形成若干典型抽象代数系统，如群、环、域、格等。  
![](images/37d476cf884c29ed65924bc021cb612de43bab4df8b1196f64e96cad4f61a01f.jpg)
图11-1 抽象代数结构的知识体系  
代数结构作为一种特殊的数学结构，具有载体、处理机制和处理规则这三个基本要素。如前所述，代数结构的载体就是由一些抽象对象为元素组成的集合，并通过运算机制实现对集合中元素的处理。所谓运算，其实就是通过映射的手段从已有元素中构造出新的元素。载体和运算统称为代数结构的成分。代数结构的处理规则即为运算性质。  
既然代数结构的载体是一个集合，那么就可以考虑通过一定方式由这个集合派生出新的集合并据此构造出新的代数结构。例如，可以考察其子集以及在子集上的运算，得到子代数的概念和性质；可以对作为载体的集合做笛卡尔集构成一个新的集合，并在新集合上定义相关运算，得到积代数的概念和性质；可以通过构造等价关系的方法实现对集合载体的划分，构成一个以等价类为元素的商集，并在这个商集上定义相关运算，得到商代数的概念和性质。子代数、积代数和商代数是构造和研究代数结构的基本方法论。  
当然，还可以考察两个代数结构之间的相似性与差异性。对于任意两个代数系统，可以在这两个代数结构的载体(集合)上建立一种保运算的映射，由此考察代数结构之间的联系。如果存在这种保运算映射，则称这两个代数系统同态。如果这种保运算的映射还是双射，则称这两个代数系统同构。同态和同构是考察代数结构之间联系的基本工具。  
依据代数结构的运算性质，可以将各种具体代数结构划分为若干抽象类型。典型的抽象代数结构类型主要有仅含一个二元运算的半群与群、含有两个二元运算的环与域，以及格与布尔代数。这些典型抽象代数结构构成代数结构知识体系的主要内容。",代数结构是四大基本数学结构之一
代数结构,发展成,抽象代数,,"代数结构作为四大基本数学结构之一，它以运算作为处理机制，在整个数学理论体系和计算机数学建模中占据非常重要的作用。代数结构是一种非常古老的数学结构，具有几千年发展历程，从最初初等代数逐步发展到大代数，然后进一步发展到抽象代数，目前正朝着泛代数的方向发展。本小节主要介绍抽象代数的由来及其基本知识结构。  
用计算机解决实际问题，一般需要对问题进行抽象并建立相应的数学模型，然后在此基础上将对实际问题的求解转化为对数学模型的求解。 因此，数学模型是用计算机解决实际问题的基础。现实问题纷繁复杂、变化万千，所建立的数学模型自然也是五花八门，多种多样，让人无所适从。值得欣慰的是，尽管我们面对的数学模型复杂多样，但从结构上看，所有这些数学模型都建立在四种基本的数学结构基础之上。  
这四种基本数学结构分别为：表示元素之间空间关系的拓扑结构，如图模型、树模型就是一些拓扑结构；表示元素之间运算关系的代数结构，如初等代数、向量代数、矩阵代数、命题代数、集合代数等都是代数结构；表示元素规模度量性质的测度结构，如高等数学里函数的微分和积分都是测度结构，它们主要计算面积、体积、弧长、速度等；表示元素之间次序关系的偏序结构，如整数的整除关系、集合的包含关系等偏序关系都是偏序结构。  
任何一个数学结构都是由载体、处理机制和处理规则这三个基本要素组成：  
（1）载体集合 对于任何一个数学结构，需要定义一些抽象的元素作为处理对象，这些抽象元素组成的集合构成数学结构的载体。载体集合是数学结构存在的基础或平台。  
（2）处理机制 为了实现对数学结构载体中元素的处理，需要定义一些处理机制，不同的数学结构具有不同的处理机制。例如：偏序结构是一种关系结构，它以元素之间的次序关系或者比较关系作为处理机制；代数结构是一种运算结构，它以元素之间的运算作为处理机制；拓扑结构是一种分布结构，它以元素之间的空间分布作为处理机制；测度结构则是一种度量结构，它以元素的规模度量作为处理机制。  
（3）处理规则 为使定义出来的数学结构满足一些合理性要求以及能够在处理实际问题中发挥作用，避免出现一些矛盾或荒诞的处理结果，还必须制定一些处理规则对处理机制做一些必要的限制。在现代数学的公理化系统中，通常称这些处理规则称为公理。不同的数学结构具有不同的处理规则，例如偏序结构限制元素之间的关系必须满足自反性、反对称性和传递性，这些限制或者性质构成了偏序结构公理系统；再如代数结构则是规定元素之间的运算必须满足结合律、交换律、分配律等运算性质。  
数学运算最早起源于算术运算，即使用具体的整数或分数进行四则运算。随着科学技术的不断发展，人们逐步意识到这种方法不能满足对一般性规律的认识。因此，采用抽象的字母来代替具体的整数和分数进行运算以获得通用性结果，并称之为代数运算或简称为代数。在微积分出现之前的数千年历史中，对代数运算的研究一直占据数学研究的核心地位。那时人们普遍信奉一种所谓的万能法则，即世界上所有问题都可以转化为数学问题，所有数学问题都可以转化为代数问题，所有代数问题都可以转化为方程问题。  
因此，在很长一段历史时期内，人们对数学的研究基本上都是对代数学的研究，对代数学的研究基本上是方程或方程组解法的研究。解方程是那个时期内所有数学家的中心任务，大家都非常期望能够通过使用代数运算的方法找到方程或方程组的通用求解公式。这种努力在线性方程组领域取得了非常完美的结果，并由初等代数逐步衍生出线性代数。但是，对于一元高次方程通用求解方法的研究并不是很顺利，对于次数高于四次的一元方程始终找不到通用求解公式或求解方法。一些非常著名的数学家，例如欧拉、高斯、拉格朗日等都对此做了大量非常艰苦的研究，但均告失败。  
在寻求五次方程通用求解方法的过程中，年仅17 岁的法国天才少年伽罗瓦在1828 年提出群的概念，运用群的思想证明了五次方程通用求解公式是不存在的，并给出了五次方程系数在满足一定条件下若干特殊解法，由此一举解决了困扰数学家长达200 多年的数学问题。伽罗瓦取得成功的关键在于不仅将运算对象进行抽象化，而且对运算本身进行抽象，在抽象对象和抽象运算的基础上通过构造一些特殊抽象代数结构进行求解。这个思想在当时实在过于超前以至于没有得到柯西、傅里叶、泊松等著名数学家的认可，泊松的判词是“完全不能理解”。 1832 年5 月31 日年仅21 岁的伽罗瓦死于决斗。在决斗之前，他把关于五次方程代数求解的研究成果写成长信，留给了人类。14 年后，法国数学家刘维尔整理并发表了伽罗瓦的遗作，人们才理解并惊叹他那超越时代的天才思想和巧妙构思。  
至此以后，人们对代数的研究内容由方程或方程组的求解技巧转变为对代数运算性质和运算结构的研究，通过对运算和运算对象进行抽象的方式实现对所有运算依其运算性质进行分类或归类，并将伽罗瓦的群论迅速发展成为一门称之为抽象代数结构的崭新数学分支。 抽象代数结构的诞生，把代数学从传统的初等代数发展到现代的抽象代数，由此打开了现代代数学的大门，开创了代数学研究的新纪元。因此，抽象代数结构通常也称为近世代数以区别于之前的初等代数。若无特别说明，我们通常将抽象代数结构简称为代数结构。  
经过一百多年的发展，抽象代数结构已经形成一个如图11-1 所示的知识体系。对于一个代数系统，我们不仅可以主动设计出它的运算并考察相应的运算规则，而且还可以通过分别对其载体集合进行相关改造或运算得到相应的子代数、积代数和商代数，可以通过映射的方式考察不同代数结构之间的区别与联系，还可根据运算性质对代数结构进行分类，形成若干典型抽象代数系统，如群、环、域、格等。  
![](images/37d476cf884c29ed65924bc021cb612de43bab4df8b1196f64e96cad4f61a01f.jpg)
图11-1 抽象代数结构的知识体系  
代数结构作为一种特殊的数学结构，具有载体、处理机制和处理规则这三个基本要素。如前所述，代数结构的载体就是由一些抽象对象为元素组成的集合，并通过运算机制实现对集合中元素的处理。所谓运算，其实就是通过映射的手段从已有元素中构造出新的元素。载体和运算统称为代数结构的成分。代数结构的处理规则即为运算性质。  
既然代数结构的载体是一个集合，那么就可以考虑通过一定方式由这个集合派生出新的集合并据此构造出新的代数结构。例如，可以考察其子集以及在子集上的运算，得到子代数的概念和性质；可以对作为载体的集合做笛卡尔集构成一个新的集合，并在新集合上定义相关运算，得到积代数的概念和性质；可以通过构造等价关系的方法实现对集合载体的划分，构成一个以等价类为元素的商集，并在这个商集上定义相关运算，得到商代数的概念和性质。子代数、积代数和商代数是构造和研究代数结构的基本方法论。  
当然，还可以考察两个代数结构之间的相似性与差异性。对于任意两个代数系统，可以在这两个代数结构的载体(集合)上建立一种保运算的映射，由此考察代数结构之间的联系。如果存在这种保运算映射，则称这两个代数系统同态。如果这种保运算的映射还是双射，则称这两个代数系统同构。同态和同构是考察代数结构之间联系的基本工具。  
依据代数结构的运算性质，可以将各种具体代数结构划分为若干抽象类型。典型的抽象代数结构类型主要有仅含一个二元运算的半群与群、含有两个二元运算的环与域，以及格与布尔代数。这些典型抽象代数结构构成代数结构知识体系的主要内容。",代数结构从初等代数发展到大代数，再发展到抽象代数
抽象代数,包含,群,,"代数结构作为四大基本数学结构之一，它以运算作为处理机制，在整个数学理论体系和计算机数学建模中占据非常重要的作用。代数结构是一种非常古老的数学结构，具有几千年发展历程，从最初初等代数逐步发展到大代数，然后进一步发展到抽象代数，目前正朝着泛代数的方向发展。本小节主要介绍抽象代数的由来及其基本知识结构。  
用计算机解决实际问题，一般需要对问题进行抽象并建立相应的数学模型，然后在此基础上将对实际问题的求解转化为对数学模型的求解。 因此，数学模型是用计算机解决实际问题的基础。现实问题纷繁复杂、变化万千，所建立的数学模型自然也是五花八门，多种多样，让人无所适从。值得欣慰的是，尽管我们面对的数学模型复杂多样，但从结构上看，所有这些数学模型都建立在四种基本的数学结构基础之上。  
这四种基本数学结构分别为：表示元素之间空间关系的拓扑结构，如图模型、树模型就是一些拓扑结构；表示元素之间运算关系的代数结构，如初等代数、向量代数、矩阵代数、命题代数、集合代数等都是代数结构；表示元素规模度量性质的测度结构，如高等数学里函数的微分和积分都是测度结构，它们主要计算面积、体积、弧长、速度等；表示元素之间次序关系的偏序结构，如整数的整除关系、集合的包含关系等偏序关系都是偏序结构。  
任何一个数学结构都是由载体、处理机制和处理规则这三个基本要素组成：  
（1）载体集合 对于任何一个数学结构，需要定义一些抽象的元素作为处理对象，这些抽象元素组成的集合构成数学结构的载体。载体集合是数学结构存在的基础或平台。  
（2）处理机制 为了实现对数学结构载体中元素的处理，需要定义一些处理机制，不同的数学结构具有不同的处理机制。例如：偏序结构是一种关系结构，它以元素之间的次序关系或者比较关系作为处理机制；代数结构是一种运算结构，它以元素之间的运算作为处理机制；拓扑结构是一种分布结构，它以元素之间的空间分布作为处理机制；测度结构则是一种度量结构，它以元素的规模度量作为处理机制。  
（3）处理规则 为使定义出来的数学结构满足一些合理性要求以及能够在处理实际问题中发挥作用，避免出现一些矛盾或荒诞的处理结果，还必须制定一些处理规则对处理机制做一些必要的限制。在现代数学的公理化系统中，通常称这些处理规则称为公理。不同的数学结构具有不同的处理规则，例如偏序结构限制元素之间的关系必须满足自反性、反对称性和传递性，这些限制或者性质构成了偏序结构公理系统；再如代数结构则是规定元素之间的运算必须满足结合律、交换律、分配律等运算性质。  
数学运算最早起源于算术运算，即使用具体的整数或分数进行四则运算。随着科学技术的不断发展，人们逐步意识到这种方法不能满足对一般性规律的认识。因此，采用抽象的字母来代替具体的整数和分数进行运算以获得通用性结果，并称之为代数运算或简称为代数。在微积分出现之前的数千年历史中，对代数运算的研究一直占据数学研究的核心地位。那时人们普遍信奉一种所谓的万能法则，即世界上所有问题都可以转化为数学问题，所有数学问题都可以转化为代数问题，所有代数问题都可以转化为方程问题。  
因此，在很长一段历史时期内，人们对数学的研究基本上都是对代数学的研究，对代数学的研究基本上是方程或方程组解法的研究。解方程是那个时期内所有数学家的中心任务，大家都非常期望能够通过使用代数运算的方法找到方程或方程组的通用求解公式。这种努力在线性方程组领域取得了非常完美的结果，并由初等代数逐步衍生出线性代数。但是，对于一元高次方程通用求解方法的研究并不是很顺利，对于次数高于四次的一元方程始终找不到通用求解公式或求解方法。一些非常著名的数学家，例如欧拉、高斯、拉格朗日等都对此做了大量非常艰苦的研究，但均告失败。  
在寻求五次方程通用求解方法的过程中，年仅17 岁的法国天才少年伽罗瓦在1828 年提出群的概念，运用群的思想证明了五次方程通用求解公式是不存在的，并给出了五次方程系数在满足一定条件下若干特殊解法，由此一举解决了困扰数学家长达200 多年的数学问题。伽罗瓦取得成功的关键在于不仅将运算对象进行抽象化，而且对运算本身进行抽象，在抽象对象和抽象运算的基础上通过构造一些特殊抽象代数结构进行求解。这个思想在当时实在过于超前以至于没有得到柯西、傅里叶、泊松等著名数学家的认可，泊松的判词是“完全不能理解”。 1832 年5 月31 日年仅21 岁的伽罗瓦死于决斗。在决斗之前，他把关于五次方程代数求解的研究成果写成长信，留给了人类。14 年后，法国数学家刘维尔整理并发表了伽罗瓦的遗作，人们才理解并惊叹他那超越时代的天才思想和巧妙构思。  
至此以后，人们对代数的研究内容由方程或方程组的求解技巧转变为对代数运算性质和运算结构的研究，通过对运算和运算对象进行抽象的方式实现对所有运算依其运算性质进行分类或归类，并将伽罗瓦的群论迅速发展成为一门称之为抽象代数结构的崭新数学分支。 抽象代数结构的诞生，把代数学从传统的初等代数发展到现代的抽象代数，由此打开了现代代数学的大门，开创了代数学研究的新纪元。因此，抽象代数结构通常也称为近世代数以区别于之前的初等代数。若无特别说明，我们通常将抽象代数结构简称为代数结构。  
经过一百多年的发展，抽象代数结构已经形成一个如图11-1 所示的知识体系。对于一个代数系统，我们不仅可以主动设计出它的运算并考察相应的运算规则，而且还可以通过分别对其载体集合进行相关改造或运算得到相应的子代数、积代数和商代数，可以通过映射的方式考察不同代数结构之间的区别与联系，还可根据运算性质对代数结构进行分类，形成若干典型抽象代数系统，如群、环、域、格等。  
![](images/37d476cf884c29ed65924bc021cb612de43bab4df8b1196f64e96cad4f61a01f.jpg)
图11-1 抽象代数结构的知识体系  
代数结构作为一种特殊的数学结构，具有载体、处理机制和处理规则这三个基本要素。如前所述，代数结构的载体就是由一些抽象对象为元素组成的集合，并通过运算机制实现对集合中元素的处理。所谓运算，其实就是通过映射的手段从已有元素中构造出新的元素。载体和运算统称为代数结构的成分。代数结构的处理规则即为运算性质。  
既然代数结构的载体是一个集合，那么就可以考虑通过一定方式由这个集合派生出新的集合并据此构造出新的代数结构。例如，可以考察其子集以及在子集上的运算，得到子代数的概念和性质；可以对作为载体的集合做笛卡尔集构成一个新的集合，并在新集合上定义相关运算，得到积代数的概念和性质；可以通过构造等价关系的方法实现对集合载体的划分，构成一个以等价类为元素的商集，并在这个商集上定义相关运算，得到商代数的概念和性质。子代数、积代数和商代数是构造和研究代数结构的基本方法论。  
当然，还可以考察两个代数结构之间的相似性与差异性。对于任意两个代数系统，可以在这两个代数结构的载体(集合)上建立一种保运算的映射，由此考察代数结构之间的联系。如果存在这种保运算映射，则称这两个代数系统同态。如果这种保运算的映射还是双射，则称这两个代数系统同构。同态和同构是考察代数结构之间联系的基本工具。  
依据代数结构的运算性质，可以将各种具体代数结构划分为若干抽象类型。典型的抽象代数结构类型主要有仅含一个二元运算的半群与群、含有两个二元运算的环与域，以及格与布尔代数。这些典型抽象代数结构构成代数结构知识体系的主要内容。",群是抽象代数结构的一种典型类型
抽象代数,包含,环,,"代数结构作为四大基本数学结构之一，它以运算作为处理机制，在整个数学理论体系和计算机数学建模中占据非常重要的作用。代数结构是一种非常古老的数学结构，具有几千年发展历程，从最初初等代数逐步发展到大代数，然后进一步发展到抽象代数，目前正朝着泛代数的方向发展。本小节主要介绍抽象代数的由来及其基本知识结构。  
用计算机解决实际问题，一般需要对问题进行抽象并建立相应的数学模型，然后在此基础上将对实际问题的求解转化为对数学模型的求解。 因此，数学模型是用计算机解决实际问题的基础。现实问题纷繁复杂、变化万千，所建立的数学模型自然也是五花八门，多种多样，让人无所适从。值得欣慰的是，尽管我们面对的数学模型复杂多样，但从结构上看，所有这些数学模型都建立在四种基本的数学结构基础之上。  
这四种基本数学结构分别为：表示元素之间空间关系的拓扑结构，如图模型、树模型就是一些拓扑结构；表示元素之间运算关系的代数结构，如初等代数、向量代数、矩阵代数、命题代数、集合代数等都是代数结构；表示元素规模度量性质的测度结构，如高等数学里函数的微分和积分都是测度结构，它们主要计算面积、体积、弧长、速度等；表示元素之间次序关系的偏序结构，如整数的整除关系、集合的包含关系等偏序关系都是偏序结构。  
任何一个数学结构都是由载体、处理机制和处理规则这三个基本要素组成：  
（1）载体集合 对于任何一个数学结构，需要定义一些抽象的元素作为处理对象，这些抽象元素组成的集合构成数学结构的载体。载体集合是数学结构存在的基础或平台。  
（2）处理机制 为了实现对数学结构载体中元素的处理，需要定义一些处理机制，不同的数学结构具有不同的处理机制。例如：偏序结构是一种关系结构，它以元素之间的次序关系或者比较关系作为处理机制；代数结构是一种运算结构，它以元素之间的运算作为处理机制；拓扑结构是一种分布结构，它以元素之间的空间分布作为处理机制；测度结构则是一种度量结构，它以元素的规模度量作为处理机制。  
（3）处理规则 为使定义出来的数学结构满足一些合理性要求以及能够在处理实际问题中发挥作用，避免出现一些矛盾或荒诞的处理结果，还必须制定一些处理规则对处理机制做一些必要的限制。在现代数学的公理化系统中，通常称这些处理规则称为公理。不同的数学结构具有不同的处理规则，例如偏序结构限制元素之间的关系必须满足自反性、反对称性和传递性，这些限制或者性质构成了偏序结构公理系统；再如代数结构则是规定元素之间的运算必须满足结合律、交换律、分配律等运算性质。  
数学运算最早起源于算术运算，即使用具体的整数或分数进行四则运算。随着科学技术的不断发展，人们逐步意识到这种方法不能满足对一般性规律的认识。因此，采用抽象的字母来代替具体的整数和分数进行运算以获得通用性结果，并称之为代数运算或简称为代数。在微积分出现之前的数千年历史中，对代数运算的研究一直占据数学研究的核心地位。那时人们普遍信奉一种所谓的万能法则，即世界上所有问题都可以转化为数学问题，所有数学问题都可以转化为代数问题，所有代数问题都可以转化为方程问题。  
因此，在很长一段历史时期内，人们对数学的研究基本上都是对代数学的研究，对代数学的研究基本上是方程或方程组解法的研究。解方程是那个时期内所有数学家的中心任务，大家都非常期望能够通过使用代数运算的方法找到方程或方程组的通用求解公式。这种努力在线性方程组领域取得了非常完美的结果，并由初等代数逐步衍生出线性代数。但是，对于一元高次方程通用求解方法的研究并不是很顺利，对于次数高于四次的一元方程始终找不到通用求解公式或求解方法。一些非常著名的数学家，例如欧拉、高斯、拉格朗日等都对此做了大量非常艰苦的研究，但均告失败。  
在寻求五次方程通用求解方法的过程中，年仅17 岁的法国天才少年伽罗瓦在1828 年提出群的概念，运用群的思想证明了五次方程通用求解公式是不存在的，并给出了五次方程系数在满足一定条件下若干特殊解法，由此一举解决了困扰数学家长达200 多年的数学问题。伽罗瓦取得成功的关键在于不仅将运算对象进行抽象化，而且对运算本身进行抽象，在抽象对象和抽象运算的基础上通过构造一些特殊抽象代数结构进行求解。这个思想在当时实在过于超前以至于没有得到柯西、傅里叶、泊松等著名数学家的认可，泊松的判词是“完全不能理解”。 1832 年5 月31 日年仅21 岁的伽罗瓦死于决斗。在决斗之前，他把关于五次方程代数求解的研究成果写成长信，留给了人类。14 年后，法国数学家刘维尔整理并发表了伽罗瓦的遗作，人们才理解并惊叹他那超越时代的天才思想和巧妙构思。  
至此以后，人们对代数的研究内容由方程或方程组的求解技巧转变为对代数运算性质和运算结构的研究，通过对运算和运算对象进行抽象的方式实现对所有运算依其运算性质进行分类或归类，并将伽罗瓦的群论迅速发展成为一门称之为抽象代数结构的崭新数学分支。 抽象代数结构的诞生，把代数学从传统的初等代数发展到现代的抽象代数，由此打开了现代代数学的大门，开创了代数学研究的新纪元。因此，抽象代数结构通常也称为近世代数以区别于之前的初等代数。若无特别说明，我们通常将抽象代数结构简称为代数结构。  
经过一百多年的发展，抽象代数结构已经形成一个如图11-1 所示的知识体系。对于一个代数系统，我们不仅可以主动设计出它的运算并考察相应的运算规则，而且还可以通过分别对其载体集合进行相关改造或运算得到相应的子代数、积代数和商代数，可以通过映射的方式考察不同代数结构之间的区别与联系，还可根据运算性质对代数结构进行分类，形成若干典型抽象代数系统，如群、环、域、格等。  
![](images/37d476cf884c29ed65924bc021cb612de43bab4df8b1196f64e96cad4f61a01f.jpg)
图11-1 抽象代数结构的知识体系  
代数结构作为一种特殊的数学结构，具有载体、处理机制和处理规则这三个基本要素。如前所述，代数结构的载体就是由一些抽象对象为元素组成的集合，并通过运算机制实现对集合中元素的处理。所谓运算，其实就是通过映射的手段从已有元素中构造出新的元素。载体和运算统称为代数结构的成分。代数结构的处理规则即为运算性质。  
既然代数结构的载体是一个集合，那么就可以考虑通过一定方式由这个集合派生出新的集合并据此构造出新的代数结构。例如，可以考察其子集以及在子集上的运算，得到子代数的概念和性质；可以对作为载体的集合做笛卡尔集构成一个新的集合，并在新集合上定义相关运算，得到积代数的概念和性质；可以通过构造等价关系的方法实现对集合载体的划分，构成一个以等价类为元素的商集，并在这个商集上定义相关运算，得到商代数的概念和性质。子代数、积代数和商代数是构造和研究代数结构的基本方法论。  
当然，还可以考察两个代数结构之间的相似性与差异性。对于任意两个代数系统，可以在这两个代数结构的载体(集合)上建立一种保运算的映射，由此考察代数结构之间的联系。如果存在这种保运算映射，则称这两个代数系统同态。如果这种保运算的映射还是双射，则称这两个代数系统同构。同态和同构是考察代数结构之间联系的基本工具。  
依据代数结构的运算性质，可以将各种具体代数结构划分为若干抽象类型。典型的抽象代数结构类型主要有仅含一个二元运算的半群与群、含有两个二元运算的环与域，以及格与布尔代数。这些典型抽象代数结构构成代数结构知识体系的主要内容。",环是抽象代数结构的一种典型类型
抽象代数,包含,域,,"代数结构作为四大基本数学结构之一，它以运算作为处理机制，在整个数学理论体系和计算机数学建模中占据非常重要的作用。代数结构是一种非常古老的数学结构，具有几千年发展历程，从最初初等代数逐步发展到大代数，然后进一步发展到抽象代数，目前正朝着泛代数的方向发展。本小节主要介绍抽象代数的由来及其基本知识结构。  
用计算机解决实际问题，一般需要对问题进行抽象并建立相应的数学模型，然后在此基础上将对实际问题的求解转化为对数学模型的求解。 因此，数学模型是用计算机解决实际问题的基础。现实问题纷繁复杂、变化万千，所建立的数学模型自然也是五花八门，多种多样，让人无所适从。值得欣慰的是，尽管我们面对的数学模型复杂多样，但从结构上看，所有这些数学模型都建立在四种基本的数学结构基础之上。  
这四种基本数学结构分别为：表示元素之间空间关系的拓扑结构，如图模型、树模型就是一些拓扑结构；表示元素之间运算关系的代数结构，如初等代数、向量代数、矩阵代数、命题代数、集合代数等都是代数结构；表示元素规模度量性质的测度结构，如高等数学里函数的微分和积分都是测度结构，它们主要计算面积、体积、弧长、速度等；表示元素之间次序关系的偏序结构，如整数的整除关系、集合的包含关系等偏序关系都是偏序结构。  
任何一个数学结构都是由载体、处理机制和处理规则这三个基本要素组成：  
（1）载体集合 对于任何一个数学结构，需要定义一些抽象的元素作为处理对象，这些抽象元素组成的集合构成数学结构的载体。载体集合是数学结构存在的基础或平台。  
（2）处理机制 为了实现对数学结构载体中元素的处理，需要定义一些处理机制，不同的数学结构具有不同的处理机制。例如：偏序结构是一种关系结构，它以元素之间的次序关系或者比较关系作为处理机制；代数结构是一种运算结构，它以元素之间的运算作为处理机制；拓扑结构是一种分布结构，它以元素之间的空间分布作为处理机制；测度结构则是一种度量结构，它以元素的规模度量作为处理机制。  
（3）处理规则 为使定义出来的数学结构满足一些合理性要求以及能够在处理实际问题中发挥作用，避免出现一些矛盾或荒诞的处理结果，还必须制定一些处理规则对处理机制做一些必要的限制。在现代数学的公理化系统中，通常称这些处理规则称为公理。不同的数学结构具有不同的处理规则，例如偏序结构限制元素之间的关系必须满足自反性、反对称性和传递性，这些限制或者性质构成了偏序结构公理系统；再如代数结构则是规定元素之间的运算必须满足结合律、交换律、分配律等运算性质。  
数学运算最早起源于算术运算，即使用具体的整数或分数进行四则运算。随着科学技术的不断发展，人们逐步意识到这种方法不能满足对一般性规律的认识。因此，采用抽象的字母来代替具体的整数和分数进行运算以获得通用性结果，并称之为代数运算或简称为代数。在微积分出现之前的数千年历史中，对代数运算的研究一直占据数学研究的核心地位。那时人们普遍信奉一种所谓的万能法则，即世界上所有问题都可以转化为数学问题，所有数学问题都可以转化为代数问题，所有代数问题都可以转化为方程问题。  
因此，在很长一段历史时期内，人们对数学的研究基本上都是对代数学的研究，对代数学的研究基本上是方程或方程组解法的研究。解方程是那个时期内所有数学家的中心任务，大家都非常期望能够通过使用代数运算的方法找到方程或方程组的通用求解公式。这种努力在线性方程组领域取得了非常完美的结果，并由初等代数逐步衍生出线性代数。但是，对于一元高次方程通用求解方法的研究并不是很顺利，对于次数高于四次的一元方程始终找不到通用求解公式或求解方法。一些非常著名的数学家，例如欧拉、高斯、拉格朗日等都对此做了大量非常艰苦的研究，但均告失败。  
在寻求五次方程通用求解方法的过程中，年仅17 岁的法国天才少年伽罗瓦在1828 年提出群的概念，运用群的思想证明了五次方程通用求解公式是不存在的，并给出了五次方程系数在满足一定条件下若干特殊解法，由此一举解决了困扰数学家长达200 多年的数学问题。伽罗瓦取得成功的关键在于不仅将运算对象进行抽象化，而且对运算本身进行抽象，在抽象对象和抽象运算的基础上通过构造一些特殊抽象代数结构进行求解。这个思想在当时实在过于超前以至于没有得到柯西、傅里叶、泊松等著名数学家的认可，泊松的判词是“完全不能理解”。 1832 年5 月31 日年仅21 岁的伽罗瓦死于决斗。在决斗之前，他把关于五次方程代数求解的研究成果写成长信，留给了人类。14 年后，法国数学家刘维尔整理并发表了伽罗瓦的遗作，人们才理解并惊叹他那超越时代的天才思想和巧妙构思。  
至此以后，人们对代数的研究内容由方程或方程组的求解技巧转变为对代数运算性质和运算结构的研究，通过对运算和运算对象进行抽象的方式实现对所有运算依其运算性质进行分类或归类，并将伽罗瓦的群论迅速发展成为一门称之为抽象代数结构的崭新数学分支。 抽象代数结构的诞生，把代数学从传统的初等代数发展到现代的抽象代数，由此打开了现代代数学的大门，开创了代数学研究的新纪元。因此，抽象代数结构通常也称为近世代数以区别于之前的初等代数。若无特别说明，我们通常将抽象代数结构简称为代数结构。  
经过一百多年的发展，抽象代数结构已经形成一个如图11-1 所示的知识体系。对于一个代数系统，我们不仅可以主动设计出它的运算并考察相应的运算规则，而且还可以通过分别对其载体集合进行相关改造或运算得到相应的子代数、积代数和商代数，可以通过映射的方式考察不同代数结构之间的区别与联系，还可根据运算性质对代数结构进行分类，形成若干典型抽象代数系统，如群、环、域、格等。  
![](images/37d476cf884c29ed65924bc021cb612de43bab4df8b1196f64e96cad4f61a01f.jpg)
图11-1 抽象代数结构的知识体系  
代数结构作为一种特殊的数学结构，具有载体、处理机制和处理规则这三个基本要素。如前所述，代数结构的载体就是由一些抽象对象为元素组成的集合，并通过运算机制实现对集合中元素的处理。所谓运算，其实就是通过映射的手段从已有元素中构造出新的元素。载体和运算统称为代数结构的成分。代数结构的处理规则即为运算性质。  
既然代数结构的载体是一个集合，那么就可以考虑通过一定方式由这个集合派生出新的集合并据此构造出新的代数结构。例如，可以考察其子集以及在子集上的运算，得到子代数的概念和性质；可以对作为载体的集合做笛卡尔集构成一个新的集合，并在新集合上定义相关运算，得到积代数的概念和性质；可以通过构造等价关系的方法实现对集合载体的划分，构成一个以等价类为元素的商集，并在这个商集上定义相关运算，得到商代数的概念和性质。子代数、积代数和商代数是构造和研究代数结构的基本方法论。  
当然，还可以考察两个代数结构之间的相似性与差异性。对于任意两个代数系统，可以在这两个代数结构的载体(集合)上建立一种保运算的映射，由此考察代数结构之间的联系。如果存在这种保运算映射，则称这两个代数系统同态。如果这种保运算的映射还是双射，则称这两个代数系统同构。同态和同构是考察代数结构之间联系的基本工具。  
依据代数结构的运算性质，可以将各种具体代数结构划分为若干抽象类型。典型的抽象代数结构类型主要有仅含一个二元运算的半群与群、含有两个二元运算的环与域，以及格与布尔代数。这些典型抽象代数结构构成代数结构知识体系的主要内容。",域是抽象代数结构的一种典型类型
抽象代数,包含,格,,"代数结构作为四大基本数学结构之一，它以运算作为处理机制，在整个数学理论体系和计算机数学建模中占据非常重要的作用。代数结构是一种非常古老的数学结构，具有几千年发展历程，从最初初等代数逐步发展到大代数，然后进一步发展到抽象代数，目前正朝着泛代数的方向发展。本小节主要介绍抽象代数的由来及其基本知识结构。  
用计算机解决实际问题，一般需要对问题进行抽象并建立相应的数学模型，然后在此基础上将对实际问题的求解转化为对数学模型的求解。 因此，数学模型是用计算机解决实际问题的基础。现实问题纷繁复杂、变化万千，所建立的数学模型自然也是五花八门，多种多样，让人无所适从。值得欣慰的是，尽管我们面对的数学模型复杂多样，但从结构上看，所有这些数学模型都建立在四种基本的数学结构基础之上。  
这四种基本数学结构分别为：表示元素之间空间关系的拓扑结构，如图模型、树模型就是一些拓扑结构；表示元素之间运算关系的代数结构，如初等代数、向量代数、矩阵代数、命题代数、集合代数等都是代数结构；表示元素规模度量性质的测度结构，如高等数学里函数的微分和积分都是测度结构，它们主要计算面积、体积、弧长、速度等；表示元素之间次序关系的偏序结构，如整数的整除关系、集合的包含关系等偏序关系都是偏序结构。  
任何一个数学结构都是由载体、处理机制和处理规则这三个基本要素组成：  
（1）载体集合 对于任何一个数学结构，需要定义一些抽象的元素作为处理对象，这些抽象元素组成的集合构成数学结构的载体。载体集合是数学结构存在的基础或平台。  
（2）处理机制 为了实现对数学结构载体中元素的处理，需要定义一些处理机制，不同的数学结构具有不同的处理机制。例如：偏序结构是一种关系结构，它以元素之间的次序关系或者比较关系作为处理机制；代数结构是一种运算结构，它以元素之间的运算作为处理机制；拓扑结构是一种分布结构，它以元素之间的空间分布作为处理机制；测度结构则是一种度量结构，它以元素的规模度量作为处理机制。  
（3）处理规则 为使定义出来的数学结构满足一些合理性要求以及能够在处理实际问题中发挥作用，避免出现一些矛盾或荒诞的处理结果，还必须制定一些处理规则对处理机制做一些必要的限制。在现代数学的公理化系统中，通常称这些处理规则称为公理。不同的数学结构具有不同的处理规则，例如偏序结构限制元素之间的关系必须满足自反性、反对称性和传递性，这些限制或者性质构成了偏序结构公理系统；再如代数结构则是规定元素之间的运算必须满足结合律、交换律、分配律等运算性质。  
数学运算最早起源于算术运算，即使用具体的整数或分数进行四则运算。随着科学技术的不断发展，人们逐步意识到这种方法不能满足对一般性规律的认识。因此，采用抽象的字母来代替具体的整数和分数进行运算以获得通用性结果，并称之为代数运算或简称为代数。在微积分出现之前的数千年历史中，对代数运算的研究一直占据数学研究的核心地位。那时人们普遍信奉一种所谓的万能法则，即世界上所有问题都可以转化为数学问题，所有数学问题都可以转化为代数问题，所有代数问题都可以转化为方程问题。  
因此，在很长一段历史时期内，人们对数学的研究基本上都是对代数学的研究，对代数学的研究基本上是方程或方程组解法的研究。解方程是那个时期内所有数学家的中心任务，大家都非常期望能够通过使用代数运算的方法找到方程或方程组的通用求解公式。这种努力在线性方程组领域取得了非常完美的结果，并由初等代数逐步衍生出线性代数。但是，对于一元高次方程通用求解方法的研究并不是很顺利，对于次数高于四次的一元方程始终找不到通用求解公式或求解方法。一些非常著名的数学家，例如欧拉、高斯、拉格朗日等都对此做了大量非常艰苦的研究，但均告失败。  
在寻求五次方程通用求解方法的过程中，年仅17 岁的法国天才少年伽罗瓦在1828 年提出群的概念，运用群的思想证明了五次方程通用求解公式是不存在的，并给出了五次方程系数在满足一定条件下若干特殊解法，由此一举解决了困扰数学家长达200 多年的数学问题。伽罗瓦取得成功的关键在于不仅将运算对象进行抽象化，而且对运算本身进行抽象，在抽象对象和抽象运算的基础上通过构造一些特殊抽象代数结构进行求解。这个思想在当时实在过于超前以至于没有得到柯西、傅里叶、泊松等著名数学家的认可，泊松的判词是“完全不能理解”。 1832 年5 月31 日年仅21 岁的伽罗瓦死于决斗。在决斗之前，他把关于五次方程代数求解的研究成果写成长信，留给了人类。14 年后，法国数学家刘维尔整理并发表了伽罗瓦的遗作，人们才理解并惊叹他那超越时代的天才思想和巧妙构思。  
至此以后，人们对代数的研究内容由方程或方程组的求解技巧转变为对代数运算性质和运算结构的研究，通过对运算和运算对象进行抽象的方式实现对所有运算依其运算性质进行分类或归类，并将伽罗瓦的群论迅速发展成为一门称之为抽象代数结构的崭新数学分支。 抽象代数结构的诞生，把代数学从传统的初等代数发展到现代的抽象代数，由此打开了现代代数学的大门，开创了代数学研究的新纪元。因此，抽象代数结构通常也称为近世代数以区别于之前的初等代数。若无特别说明，我们通常将抽象代数结构简称为代数结构。  
经过一百多年的发展，抽象代数结构已经形成一个如图11-1 所示的知识体系。对于一个代数系统，我们不仅可以主动设计出它的运算并考察相应的运算规则，而且还可以通过分别对其载体集合进行相关改造或运算得到相应的子代数、积代数和商代数，可以通过映射的方式考察不同代数结构之间的区别与联系，还可根据运算性质对代数结构进行分类，形成若干典型抽象代数系统，如群、环、域、格等。  
![](images/37d476cf884c29ed65924bc021cb612de43bab4df8b1196f64e96cad4f61a01f.jpg)
图11-1 抽象代数结构的知识体系  
代数结构作为一种特殊的数学结构，具有载体、处理机制和处理规则这三个基本要素。如前所述，代数结构的载体就是由一些抽象对象为元素组成的集合，并通过运算机制实现对集合中元素的处理。所谓运算，其实就是通过映射的手段从已有元素中构造出新的元素。载体和运算统称为代数结构的成分。代数结构的处理规则即为运算性质。  
既然代数结构的载体是一个集合，那么就可以考虑通过一定方式由这个集合派生出新的集合并据此构造出新的代数结构。例如，可以考察其子集以及在子集上的运算，得到子代数的概念和性质；可以对作为载体的集合做笛卡尔集构成一个新的集合，并在新集合上定义相关运算，得到积代数的概念和性质；可以通过构造等价关系的方法实现对集合载体的划分，构成一个以等价类为元素的商集，并在这个商集上定义相关运算，得到商代数的概念和性质。子代数、积代数和商代数是构造和研究代数结构的基本方法论。  
当然，还可以考察两个代数结构之间的相似性与差异性。对于任意两个代数系统，可以在这两个代数结构的载体(集合)上建立一种保运算的映射，由此考察代数结构之间的联系。如果存在这种保运算映射，则称这两个代数系统同态。如果这种保运算的映射还是双射，则称这两个代数系统同构。同态和同构是考察代数结构之间联系的基本工具。  
依据代数结构的运算性质，可以将各种具体代数结构划分为若干抽象类型。典型的抽象代数结构类型主要有仅含一个二元运算的半群与群、含有两个二元运算的环与域，以及格与布尔代数。这些典型抽象代数结构构成代数结构知识体系的主要内容。",格是抽象代数结构的一种典型类型
抽象代数,包含,布尔代数,,"代数结构作为四大基本数学结构之一，它以运算作为处理机制，在整个数学理论体系和计算机数学建模中占据非常重要的作用。代数结构是一种非常古老的数学结构，具有几千年发展历程，从最初初等代数逐步发展到大代数，然后进一步发展到抽象代数，目前正朝着泛代数的方向发展。本小节主要介绍抽象代数的由来及其基本知识结构。  
用计算机解决实际问题，一般需要对问题进行抽象并建立相应的数学模型，然后在此基础上将对实际问题的求解转化为对数学模型的求解。 因此，数学模型是用计算机解决实际问题的基础。现实问题纷繁复杂、变化万千，所建立的数学模型自然也是五花八门，多种多样，让人无所适从。值得欣慰的是，尽管我们面对的数学模型复杂多样，但从结构上看，所有这些数学模型都建立在四种基本的数学结构基础之上。  
这四种基本数学结构分别为：表示元素之间空间关系的拓扑结构，如图模型、树模型就是一些拓扑结构；表示元素之间运算关系的代数结构，如初等代数、向量代数、矩阵代数、命题代数、集合代数等都是代数结构；表示元素规模度量性质的测度结构，如高等数学里函数的微分和积分都是测度结构，它们主要计算面积、体积、弧长、速度等；表示元素之间次序关系的偏序结构，如整数的整除关系、集合的包含关系等偏序关系都是偏序结构。  
任何一个数学结构都是由载体、处理机制和处理规则这三个基本要素组成：  
（1）载体集合 对于任何一个数学结构，需要定义一些抽象的元素作为处理对象，这些抽象元素组成的集合构成数学结构的载体。载体集合是数学结构存在的基础或平台。  
（2）处理机制 为了实现对数学结构载体中元素的处理，需要定义一些处理机制，不同的数学结构具有不同的处理机制。例如：偏序结构是一种关系结构，它以元素之间的次序关系或者比较关系作为处理机制；代数结构是一种运算结构，它以元素之间的运算作为处理机制；拓扑结构是一种分布结构，它以元素之间的空间分布作为处理机制；测度结构则是一种度量结构，它以元素的规模度量作为处理机制。  
（3）处理规则 为使定义出来的数学结构满足一些合理性要求以及能够在处理实际问题中发挥作用，避免出现一些矛盾或荒诞的处理结果，还必须制定一些处理规则对处理机制做一些必要的限制。在现代数学的公理化系统中，通常称这些处理规则称为公理。不同的数学结构具有不同的处理规则，例如偏序结构限制元素之间的关系必须满足自反性、反对称性和传递性，这些限制或者性质构成了偏序结构公理系统；再如代数结构则是规定元素之间的运算必须满足结合律、交换律、分配律等运算性质。  
数学运算最早起源于算术运算，即使用具体的整数或分数进行四则运算。随着科学技术的不断发展，人们逐步意识到这种方法不能满足对一般性规律的认识。因此，采用抽象的字母来代替具体的整数和分数进行运算以获得通用性结果，并称之为代数运算或简称为代数。在微积分出现之前的数千年历史中，对代数运算的研究一直占据数学研究的核心地位。那时人们普遍信奉一种所谓的万能法则，即世界上所有问题都可以转化为数学问题，所有数学问题都可以转化为代数问题，所有代数问题都可以转化为方程问题。  
因此，在很长一段历史时期内，人们对数学的研究基本上都是对代数学的研究，对代数学的研究基本上是方程或方程组解法的研究。解方程是那个时期内所有数学家的中心任务，大家都非常期望能够通过使用代数运算的方法找到方程或方程组的通用求解公式。这种努力在线性方程组领域取得了非常完美的结果，并由初等代数逐步衍生出线性代数。但是，对于一元高次方程通用求解方法的研究并不是很顺利，对于次数高于四次的一元方程始终找不到通用求解公式或求解方法。一些非常著名的数学家，例如欧拉、高斯、拉格朗日等都对此做了大量非常艰苦的研究，但均告失败。  
在寻求五次方程通用求解方法的过程中，年仅17 岁的法国天才少年伽罗瓦在1828 年提出群的概念，运用群的思想证明了五次方程通用求解公式是不存在的，并给出了五次方程系数在满足一定条件下若干特殊解法，由此一举解决了困扰数学家长达200 多年的数学问题。伽罗瓦取得成功的关键在于不仅将运算对象进行抽象化，而且对运算本身进行抽象，在抽象对象和抽象运算的基础上通过构造一些特殊抽象代数结构进行求解。这个思想在当时实在过于超前以至于没有得到柯西、傅里叶、泊松等著名数学家的认可，泊松的判词是“完全不能理解”。 1832 年5 月31 日年仅21 岁的伽罗瓦死于决斗。在决斗之前，他把关于五次方程代数求解的研究成果写成长信，留给了人类。14 年后，法国数学家刘维尔整理并发表了伽罗瓦的遗作，人们才理解并惊叹他那超越时代的天才思想和巧妙构思。  
至此以后，人们对代数的研究内容由方程或方程组的求解技巧转变为对代数运算性质和运算结构的研究，通过对运算和运算对象进行抽象的方式实现对所有运算依其运算性质进行分类或归类，并将伽罗瓦的群论迅速发展成为一门称之为抽象代数结构的崭新数学分支。 抽象代数结构的诞生，把代数学从传统的初等代数发展到现代的抽象代数，由此打开了现代代数学的大门，开创了代数学研究的新纪元。因此，抽象代数结构通常也称为近世代数以区别于之前的初等代数。若无特别说明，我们通常将抽象代数结构简称为代数结构。  
经过一百多年的发展，抽象代数结构已经形成一个如图11-1 所示的知识体系。对于一个代数系统，我们不仅可以主动设计出它的运算并考察相应的运算规则，而且还可以通过分别对其载体集合进行相关改造或运算得到相应的子代数、积代数和商代数，可以通过映射的方式考察不同代数结构之间的区别与联系，还可根据运算性质对代数结构进行分类，形成若干典型抽象代数系统，如群、环、域、格等。  
![](images/37d476cf884c29ed65924bc021cb612de43bab4df8b1196f64e96cad4f61a01f.jpg)
图11-1 抽象代数结构的知识体系  
代数结构作为一种特殊的数学结构，具有载体、处理机制和处理规则这三个基本要素。如前所述，代数结构的载体就是由一些抽象对象为元素组成的集合，并通过运算机制实现对集合中元素的处理。所谓运算，其实就是通过映射的手段从已有元素中构造出新的元素。载体和运算统称为代数结构的成分。代数结构的处理规则即为运算性质。  
既然代数结构的载体是一个集合，那么就可以考虑通过一定方式由这个集合派生出新的集合并据此构造出新的代数结构。例如，可以考察其子集以及在子集上的运算，得到子代数的概念和性质；可以对作为载体的集合做笛卡尔集构成一个新的集合，并在新集合上定义相关运算，得到积代数的概念和性质；可以通过构造等价关系的方法实现对集合载体的划分，构成一个以等价类为元素的商集，并在这个商集上定义相关运算，得到商代数的概念和性质。子代数、积代数和商代数是构造和研究代数结构的基本方法论。  
当然，还可以考察两个代数结构之间的相似性与差异性。对于任意两个代数系统，可以在这两个代数结构的载体(集合)上建立一种保运算的映射，由此考察代数结构之间的联系。如果存在这种保运算映射，则称这两个代数系统同态。如果这种保运算的映射还是双射，则称这两个代数系统同构。同态和同构是考察代数结构之间联系的基本工具。  
依据代数结构的运算性质，可以将各种具体代数结构划分为若干抽象类型。典型的抽象代数结构类型主要有仅含一个二元运算的半群与群、含有两个二元运算的环与域，以及格与布尔代数。这些典型抽象代数结构构成代数结构知识体系的主要内容。",布尔代数是抽象代数结构的一种典型类型
代数结构,派生,子代数,,"代数结构作为四大基本数学结构之一，它以运算作为处理机制，在整个数学理论体系和计算机数学建模中占据非常重要的作用。代数结构是一种非常古老的数学结构，具有几千年发展历程，从最初初等代数逐步发展到大代数，然后进一步发展到抽象代数，目前正朝着泛代数的方向发展。本小节主要介绍抽象代数的由来及其基本知识结构。  
用计算机解决实际问题，一般需要对问题进行抽象并建立相应的数学模型，然后在此基础上将对实际问题的求解转化为对数学模型的求解。 因此，数学模型是用计算机解决实际问题的基础。现实问题纷繁复杂、变化万千，所建立的数学模型自然也是五花八门，多种多样，让人无所适从。值得欣慰的是，尽管我们面对的数学模型复杂多样，但从结构上看，所有这些数学模型都建立在四种基本的数学结构基础之上。  
这四种基本数学结构分别为：表示元素之间空间关系的拓扑结构，如图模型、树模型就是一些拓扑结构；表示元素之间运算关系的代数结构，如初等代数、向量代数、矩阵代数、命题代数、集合代数等都是代数结构；表示元素规模度量性质的测度结构，如高等数学里函数的微分和积分都是测度结构，它们主要计算面积、体积、弧长、速度等；表示元素之间次序关系的偏序结构，如整数的整除关系、集合的包含关系等偏序关系都是偏序结构。  
任何一个数学结构都是由载体、处理机制和处理规则这三个基本要素组成：  
（1）载体集合 对于任何一个数学结构，需要定义一些抽象的元素作为处理对象，这些抽象元素组成的集合构成数学结构的载体。载体集合是数学结构存在的基础或平台。  
（2）处理机制 为了实现对数学结构载体中元素的处理，需要定义一些处理机制，不同的数学结构具有不同的处理机制。例如：偏序结构是一种关系结构，它以元素之间的次序关系或者比较关系作为处理机制；代数结构是一种运算结构，它以元素之间的运算作为处理机制；拓扑结构是一种分布结构，它以元素之间的空间分布作为处理机制；测度结构则是一种度量结构，它以元素的规模度量作为处理机制。  
（3）处理规则 为使定义出来的数学结构满足一些合理性要求以及能够在处理实际问题中发挥作用，避免出现一些矛盾或荒诞的处理结果，还必须制定一些处理规则对处理机制做一些必要的限制。在现代数学的公理化系统中，通常称这些处理规则称为公理。不同的数学结构具有不同的处理规则，例如偏序结构限制元素之间的关系必须满足自反性、反对称性和传递性，这些限制或者性质构成了偏序结构公理系统；再如代数结构则是规定元素之间的运算必须满足结合律、交换律、分配律等运算性质。  
数学运算最早起源于算术运算，即使用具体的整数或分数进行四则运算。随着科学技术的不断发展，人们逐步意识到这种方法不能满足对一般性规律的认识。因此，采用抽象的字母来代替具体的整数和分数进行运算以获得通用性结果，并称之为代数运算或简称为代数。在微积分出现之前的数千年历史中，对代数运算的研究一直占据数学研究的核心地位。那时人们普遍信奉一种所谓的万能法则，即世界上所有问题都可以转化为数学问题，所有数学问题都可以转化为代数问题，所有代数问题都可以转化为方程问题。  
因此，在很长一段历史时期内，人们对数学的研究基本上都是对代数学的研究，对代数学的研究基本上是方程或方程组解法的研究。解方程是那个时期内所有数学家的中心任务，大家都非常期望能够通过使用代数运算的方法找到方程或方程组的通用求解公式。这种努力在线性方程组领域取得了非常完美的结果，并由初等代数逐步衍生出线性代数。但是，对于一元高次方程通用求解方法的研究并不是很顺利，对于次数高于四次的一元方程始终找不到通用求解公式或求解方法。一些非常著名的数学家，例如欧拉、高斯、拉格朗日等都对此做了大量非常艰苦的研究，但均告失败。  
在寻求五次方程通用求解方法的过程中，年仅17 岁的法国天才少年伽罗瓦在1828 年提出群的概念，运用群的思想证明了五次方程通用求解公式是不存在的，并给出了五次方程系数在满足一定条件下若干特殊解法，由此一举解决了困扰数学家长达200 多年的数学问题。伽罗瓦取得成功的关键在于不仅将运算对象进行抽象化，而且对运算本身进行抽象，在抽象对象和抽象运算的基础上通过构造一些特殊抽象代数结构进行求解。这个思想在当时实在过于超前以至于没有得到柯西、傅里叶、泊松等著名数学家的认可，泊松的判词是“完全不能理解”。 1832 年5 月31 日年仅21 岁的伽罗瓦死于决斗。在决斗之前，他把关于五次方程代数求解的研究成果写成长信，留给了人类。14 年后，法国数学家刘维尔整理并发表了伽罗瓦的遗作，人们才理解并惊叹他那超越时代的天才思想和巧妙构思。  
至此以后，人们对代数的研究内容由方程或方程组的求解技巧转变为对代数运算性质和运算结构的研究，通过对运算和运算对象进行抽象的方式实现对所有运算依其运算性质进行分类或归类，并将伽罗瓦的群论迅速发展成为一门称之为抽象代数结构的崭新数学分支。 抽象代数结构的诞生，把代数学从传统的初等代数发展到现代的抽象代数，由此打开了现代代数学的大门，开创了代数学研究的新纪元。因此，抽象代数结构通常也称为近世代数以区别于之前的初等代数。若无特别说明，我们通常将抽象代数结构简称为代数结构。  
经过一百多年的发展，抽象代数结构已经形成一个如图11-1 所示的知识体系。对于一个代数系统，我们不仅可以主动设计出它的运算并考察相应的运算规则，而且还可以通过分别对其载体集合进行相关改造或运算得到相应的子代数、积代数和商代数，可以通过映射的方式考察不同代数结构之间的区别与联系，还可根据运算性质对代数结构进行分类，形成若干典型抽象代数系统，如群、环、域、格等。  
![](images/37d476cf884c29ed65924bc021cb612de43bab4df8b1196f64e96cad4f61a01f.jpg)
图11-1 抽象代数结构的知识体系  
代数结构作为一种特殊的数学结构，具有载体、处理机制和处理规则这三个基本要素。如前所述，代数结构的载体就是由一些抽象对象为元素组成的集合，并通过运算机制实现对集合中元素的处理。所谓运算，其实就是通过映射的手段从已有元素中构造出新的元素。载体和运算统称为代数结构的成分。代数结构的处理规则即为运算性质。  
既然代数结构的载体是一个集合，那么就可以考虑通过一定方式由这个集合派生出新的集合并据此构造出新的代数结构。例如，可以考察其子集以及在子集上的运算，得到子代数的概念和性质；可以对作为载体的集合做笛卡尔集构成一个新的集合，并在新集合上定义相关运算，得到积代数的概念和性质；可以通过构造等价关系的方法实现对集合载体的划分，构成一个以等价类为元素的商集，并在这个商集上定义相关运算，得到商代数的概念和性质。子代数、积代数和商代数是构造和研究代数结构的基本方法论。  
当然，还可以考察两个代数结构之间的相似性与差异性。对于任意两个代数系统，可以在这两个代数结构的载体(集合)上建立一种保运算的映射，由此考察代数结构之间的联系。如果存在这种保运算映射，则称这两个代数系统同态。如果这种保运算的映射还是双射，则称这两个代数系统同构。同态和同构是考察代数结构之间联系的基本工具。  
依据代数结构的运算性质，可以将各种具体代数结构划分为若干抽象类型。典型的抽象代数结构类型主要有仅含一个二元运算的半群与群、含有两个二元运算的环与域，以及格与布尔代数。这些典型抽象代数结构构成代数结构知识体系的主要内容。",子代数是由代数结构的子集及其运算构成的
代数结构,派生,积代数,,"代数结构作为四大基本数学结构之一，它以运算作为处理机制，在整个数学理论体系和计算机数学建模中占据非常重要的作用。代数结构是一种非常古老的数学结构，具有几千年发展历程，从最初初等代数逐步发展到大代数，然后进一步发展到抽象代数，目前正朝着泛代数的方向发展。本小节主要介绍抽象代数的由来及其基本知识结构。  
用计算机解决实际问题，一般需要对问题进行抽象并建立相应的数学模型，然后在此基础上将对实际问题的求解转化为对数学模型的求解。 因此，数学模型是用计算机解决实际问题的基础。现实问题纷繁复杂、变化万千，所建立的数学模型自然也是五花八门，多种多样，让人无所适从。值得欣慰的是，尽管我们面对的数学模型复杂多样，但从结构上看，所有这些数学模型都建立在四种基本的数学结构基础之上。  
这四种基本数学结构分别为：表示元素之间空间关系的拓扑结构，如图模型、树模型就是一些拓扑结构；表示元素之间运算关系的代数结构，如初等代数、向量代数、矩阵代数、命题代数、集合代数等都是代数结构；表示元素规模度量性质的测度结构，如高等数学里函数的微分和积分都是测度结构，它们主要计算面积、体积、弧长、速度等；表示元素之间次序关系的偏序结构，如整数的整除关系、集合的包含关系等偏序关系都是偏序结构。  
任何一个数学结构都是由载体、处理机制和处理规则这三个基本要素组成：  
（1）载体集合 对于任何一个数学结构，需要定义一些抽象的元素作为处理对象，这些抽象元素组成的集合构成数学结构的载体。载体集合是数学结构存在的基础或平台。  
（2）处理机制 为了实现对数学结构载体中元素的处理，需要定义一些处理机制，不同的数学结构具有不同的处理机制。例如：偏序结构是一种关系结构，它以元素之间的次序关系或者比较关系作为处理机制；代数结构是一种运算结构，它以元素之间的运算作为处理机制；拓扑结构是一种分布结构，它以元素之间的空间分布作为处理机制；测度结构则是一种度量结构，它以元素的规模度量作为处理机制。  
（3）处理规则 为使定义出来的数学结构满足一些合理性要求以及能够在处理实际问题中发挥作用，避免出现一些矛盾或荒诞的处理结果，还必须制定一些处理规则对处理机制做一些必要的限制。在现代数学的公理化系统中，通常称这些处理规则称为公理。不同的数学结构具有不同的处理规则，例如偏序结构限制元素之间的关系必须满足自反性、反对称性和传递性，这些限制或者性质构成了偏序结构公理系统；再如代数结构则是规定元素之间的运算必须满足结合律、交换律、分配律等运算性质。  
数学运算最早起源于算术运算，即使用具体的整数或分数进行四则运算。随着科学技术的不断发展，人们逐步意识到这种方法不能满足对一般性规律的认识。因此，采用抽象的字母来代替具体的整数和分数进行运算以获得通用性结果，并称之为代数运算或简称为代数。在微积分出现之前的数千年历史中，对代数运算的研究一直占据数学研究的核心地位。那时人们普遍信奉一种所谓的万能法则，即世界上所有问题都可以转化为数学问题，所有数学问题都可以转化为代数问题，所有代数问题都可以转化为方程问题。  
因此，在很长一段历史时期内，人们对数学的研究基本上都是对代数学的研究，对代数学的研究基本上是方程或方程组解法的研究。解方程是那个时期内所有数学家的中心任务，大家都非常期望能够通过使用代数运算的方法找到方程或方程组的通用求解公式。这种努力在线性方程组领域取得了非常完美的结果，并由初等代数逐步衍生出线性代数。但是，对于一元高次方程通用求解方法的研究并不是很顺利，对于次数高于四次的一元方程始终找不到通用求解公式或求解方法。一些非常著名的数学家，例如欧拉、高斯、拉格朗日等都对此做了大量非常艰苦的研究，但均告失败。  
在寻求五次方程通用求解方法的过程中，年仅17 岁的法国天才少年伽罗瓦在1828 年提出群的概念，运用群的思想证明了五次方程通用求解公式是不存在的，并给出了五次方程系数在满足一定条件下若干特殊解法，由此一举解决了困扰数学家长达200 多年的数学问题。伽罗瓦取得成功的关键在于不仅将运算对象进行抽象化，而且对运算本身进行抽象，在抽象对象和抽象运算的基础上通过构造一些特殊抽象代数结构进行求解。这个思想在当时实在过于超前以至于没有得到柯西、傅里叶、泊松等著名数学家的认可，泊松的判词是“完全不能理解”。 1832 年5 月31 日年仅21 岁的伽罗瓦死于决斗。在决斗之前，他把关于五次方程代数求解的研究成果写成长信，留给了人类。14 年后，法国数学家刘维尔整理并发表了伽罗瓦的遗作，人们才理解并惊叹他那超越时代的天才思想和巧妙构思。  
至此以后，人们对代数的研究内容由方程或方程组的求解技巧转变为对代数运算性质和运算结构的研究，通过对运算和运算对象进行抽象的方式实现对所有运算依其运算性质进行分类或归类，并将伽罗瓦的群论迅速发展成为一门称之为抽象代数结构的崭新数学分支。 抽象代数结构的诞生，把代数学从传统的初等代数发展到现代的抽象代数，由此打开了现代代数学的大门，开创了代数学研究的新纪元。因此，抽象代数结构通常也称为近世代数以区别于之前的初等代数。若无特别说明，我们通常将抽象代数结构简称为代数结构。  
经过一百多年的发展，抽象代数结构已经形成一个如图11-1 所示的知识体系。对于一个代数系统，我们不仅可以主动设计出它的运算并考察相应的运算规则，而且还可以通过分别对其载体集合进行相关改造或运算得到相应的子代数、积代数和商代数，可以通过映射的方式考察不同代数结构之间的区别与联系，还可根据运算性质对代数结构进行分类，形成若干典型抽象代数系统，如群、环、域、格等。  
![](images/37d476cf884c29ed65924bc021cb612de43bab4df8b1196f64e96cad4f61a01f.jpg)
图11-1 抽象代数结构的知识体系  
代数结构作为一种特殊的数学结构，具有载体、处理机制和处理规则这三个基本要素。如前所述，代数结构的载体就是由一些抽象对象为元素组成的集合，并通过运算机制实现对集合中元素的处理。所谓运算，其实就是通过映射的手段从已有元素中构造出新的元素。载体和运算统称为代数结构的成分。代数结构的处理规则即为运算性质。  
既然代数结构的载体是一个集合，那么就可以考虑通过一定方式由这个集合派生出新的集合并据此构造出新的代数结构。例如，可以考察其子集以及在子集上的运算，得到子代数的概念和性质；可以对作为载体的集合做笛卡尔集构成一个新的集合，并在新集合上定义相关运算，得到积代数的概念和性质；可以通过构造等价关系的方法实现对集合载体的划分，构成一个以等价类为元素的商集，并在这个商集上定义相关运算，得到商代数的概念和性质。子代数、积代数和商代数是构造和研究代数结构的基本方法论。  
当然，还可以考察两个代数结构之间的相似性与差异性。对于任意两个代数系统，可以在这两个代数结构的载体(集合)上建立一种保运算的映射，由此考察代数结构之间的联系。如果存在这种保运算映射，则称这两个代数系统同态。如果这种保运算的映射还是双射，则称这两个代数系统同构。同态和同构是考察代数结构之间联系的基本工具。  
依据代数结构的运算性质，可以将各种具体代数结构划分为若干抽象类型。典型的抽象代数结构类型主要有仅含一个二元运算的半群与群、含有两个二元运算的环与域，以及格与布尔代数。这些典型抽象代数结构构成代数结构知识体系的主要内容。",积代数是由代数结构的笛卡尔集及其运算构成的
代数结构,派生,商代数,,"代数结构作为四大基本数学结构之一，它以运算作为处理机制，在整个数学理论体系和计算机数学建模中占据非常重要的作用。代数结构是一种非常古老的数学结构，具有几千年发展历程，从最初初等代数逐步发展到大代数，然后进一步发展到抽象代数，目前正朝着泛代数的方向发展。本小节主要介绍抽象代数的由来及其基本知识结构。  
用计算机解决实际问题，一般需要对问题进行抽象并建立相应的数学模型，然后在此基础上将对实际问题的求解转化为对数学模型的求解。 因此，数学模型是用计算机解决实际问题的基础。现实问题纷繁复杂、变化万千，所建立的数学模型自然也是五花八门，多种多样，让人无所适从。值得欣慰的是，尽管我们面对的数学模型复杂多样，但从结构上看，所有这些数学模型都建立在四种基本的数学结构基础之上。  
这四种基本数学结构分别为：表示元素之间空间关系的拓扑结构，如图模型、树模型就是一些拓扑结构；表示元素之间运算关系的代数结构，如初等代数、向量代数、矩阵代数、命题代数、集合代数等都是代数结构；表示元素规模度量性质的测度结构，如高等数学里函数的微分和积分都是测度结构，它们主要计算面积、体积、弧长、速度等；表示元素之间次序关系的偏序结构，如整数的整除关系、集合的包含关系等偏序关系都是偏序结构。  
任何一个数学结构都是由载体、处理机制和处理规则这三个基本要素组成：  
（1）载体集合 对于任何一个数学结构，需要定义一些抽象的元素作为处理对象，这些抽象元素组成的集合构成数学结构的载体。载体集合是数学结构存在的基础或平台。  
（2）处理机制 为了实现对数学结构载体中元素的处理，需要定义一些处理机制，不同的数学结构具有不同的处理机制。例如：偏序结构是一种关系结构，它以元素之间的次序关系或者比较关系作为处理机制；代数结构是一种运算结构，它以元素之间的运算作为处理机制；拓扑结构是一种分布结构，它以元素之间的空间分布作为处理机制；测度结构则是一种度量结构，它以元素的规模度量作为处理机制。  
（3）处理规则 为使定义出来的数学结构满足一些合理性要求以及能够在处理实际问题中发挥作用，避免出现一些矛盾或荒诞的处理结果，还必须制定一些处理规则对处理机制做一些必要的限制。在现代数学的公理化系统中，通常称这些处理规则称为公理。不同的数学结构具有不同的处理规则，例如偏序结构限制元素之间的关系必须满足自反性、反对称性和传递性，这些限制或者性质构成了偏序结构公理系统；再如代数结构则是规定元素之间的运算必须满足结合律、交换律、分配律等运算性质。  
数学运算最早起源于算术运算，即使用具体的整数或分数进行四则运算。随着科学技术的不断发展，人们逐步意识到这种方法不能满足对一般性规律的认识。因此，采用抽象的字母来代替具体的整数和分数进行运算以获得通用性结果，并称之为代数运算或简称为代数。在微积分出现之前的数千年历史中，对代数运算的研究一直占据数学研究的核心地位。那时人们普遍信奉一种所谓的万能法则，即世界上所有问题都可以转化为数学问题，所有数学问题都可以转化为代数问题，所有代数问题都可以转化为方程问题。  
因此，在很长一段历史时期内，人们对数学的研究基本上都是对代数学的研究，对代数学的研究基本上是方程或方程组解法的研究。解方程是那个时期内所有数学家的中心任务，大家都非常期望能够通过使用代数运算的方法找到方程或方程组的通用求解公式。这种努力在线性方程组领域取得了非常完美的结果，并由初等代数逐步衍生出线性代数。但是，对于一元高次方程通用求解方法的研究并不是很顺利，对于次数高于四次的一元方程始终找不到通用求解公式或求解方法。一些非常著名的数学家，例如欧拉、高斯、拉格朗日等都对此做了大量非常艰苦的研究，但均告失败。  
在寻求五次方程通用求解方法的过程中，年仅17 岁的法国天才少年伽罗瓦在1828 年提出群的概念，运用群的思想证明了五次方程通用求解公式是不存在的，并给出了五次方程系数在满足一定条件下若干特殊解法，由此一举解决了困扰数学家长达200 多年的数学问题。伽罗瓦取得成功的关键在于不仅将运算对象进行抽象化，而且对运算本身进行抽象，在抽象对象和抽象运算的基础上通过构造一些特殊抽象代数结构进行求解。这个思想在当时实在过于超前以至于没有得到柯西、傅里叶、泊松等著名数学家的认可，泊松的判词是“完全不能理解”。 1832 年5 月31 日年仅21 岁的伽罗瓦死于决斗。在决斗之前，他把关于五次方程代数求解的研究成果写成长信，留给了人类。14 年后，法国数学家刘维尔整理并发表了伽罗瓦的遗作，人们才理解并惊叹他那超越时代的天才思想和巧妙构思。  
至此以后，人们对代数的研究内容由方程或方程组的求解技巧转变为对代数运算性质和运算结构的研究，通过对运算和运算对象进行抽象的方式实现对所有运算依其运算性质进行分类或归类，并将伽罗瓦的群论迅速发展成为一门称之为抽象代数结构的崭新数学分支。 抽象代数结构的诞生，把代数学从传统的初等代数发展到现代的抽象代数，由此打开了现代代数学的大门，开创了代数学研究的新纪元。因此，抽象代数结构通常也称为近世代数以区别于之前的初等代数。若无特别说明，我们通常将抽象代数结构简称为代数结构。  
经过一百多年的发展，抽象代数结构已经形成一个如图11-1 所示的知识体系。对于一个代数系统，我们不仅可以主动设计出它的运算并考察相应的运算规则，而且还可以通过分别对其载体集合进行相关改造或运算得到相应的子代数、积代数和商代数，可以通过映射的方式考察不同代数结构之间的区别与联系，还可根据运算性质对代数结构进行分类，形成若干典型抽象代数系统，如群、环、域、格等。  
![](images/37d476cf884c29ed65924bc021cb612de43bab4df8b1196f64e96cad4f61a01f.jpg)
图11-1 抽象代数结构的知识体系  
代数结构作为一种特殊的数学结构，具有载体、处理机制和处理规则这三个基本要素。如前所述，代数结构的载体就是由一些抽象对象为元素组成的集合，并通过运算机制实现对集合中元素的处理。所谓运算，其实就是通过映射的手段从已有元素中构造出新的元素。载体和运算统称为代数结构的成分。代数结构的处理规则即为运算性质。  
既然代数结构的载体是一个集合，那么就可以考虑通过一定方式由这个集合派生出新的集合并据此构造出新的代数结构。例如，可以考察其子集以及在子集上的运算，得到子代数的概念和性质；可以对作为载体的集合做笛卡尔集构成一个新的集合，并在新集合上定义相关运算，得到积代数的概念和性质；可以通过构造等价关系的方法实现对集合载体的划分，构成一个以等价类为元素的商集，并在这个商集上定义相关运算，得到商代数的概念和性质。子代数、积代数和商代数是构造和研究代数结构的基本方法论。  
当然，还可以考察两个代数结构之间的相似性与差异性。对于任意两个代数系统，可以在这两个代数结构的载体(集合)上建立一种保运算的映射，由此考察代数结构之间的联系。如果存在这种保运算映射，则称这两个代数系统同态。如果这种保运算的映射还是双射，则称这两个代数系统同构。同态和同构是考察代数结构之间联系的基本工具。  
依据代数结构的运算性质，可以将各种具体代数结构划分为若干抽象类型。典型的抽象代数结构类型主要有仅含一个二元运算的半群与群、含有两个二元运算的环与域，以及格与布尔代数。这些典型抽象代数结构构成代数结构知识体系的主要内容。",商代数是由代数结构的等价类及其运算构成的
代数结构,考察工具,同态,,"代数结构作为四大基本数学结构之一，它以运算作为处理机制，在整个数学理论体系和计算机数学建模中占据非常重要的作用。代数结构是一种非常古老的数学结构，具有几千年发展历程，从最初初等代数逐步发展到大代数，然后进一步发展到抽象代数，目前正朝着泛代数的方向发展。本小节主要介绍抽象代数的由来及其基本知识结构。  
用计算机解决实际问题，一般需要对问题进行抽象并建立相应的数学模型，然后在此基础上将对实际问题的求解转化为对数学模型的求解。 因此，数学模型是用计算机解决实际问题的基础。现实问题纷繁复杂、变化万千，所建立的数学模型自然也是五花八门，多种多样，让人无所适从。值得欣慰的是，尽管我们面对的数学模型复杂多样，但从结构上看，所有这些数学模型都建立在四种基本的数学结构基础之上。  
这四种基本数学结构分别为：表示元素之间空间关系的拓扑结构，如图模型、树模型就是一些拓扑结构；表示元素之间运算关系的代数结构，如初等代数、向量代数、矩阵代数、命题代数、集合代数等都是代数结构；表示元素规模度量性质的测度结构，如高等数学里函数的微分和积分都是测度结构，它们主要计算面积、体积、弧长、速度等；表示元素之间次序关系的偏序结构，如整数的整除关系、集合的包含关系等偏序关系都是偏序结构。  
任何一个数学结构都是由载体、处理机制和处理规则这三个基本要素组成：  
（1）载体集合 对于任何一个数学结构，需要定义一些抽象的元素作为处理对象，这些抽象元素组成的集合构成数学结构的载体。载体集合是数学结构存在的基础或平台。  
（2）处理机制 为了实现对数学结构载体中元素的处理，需要定义一些处理机制，不同的数学结构具有不同的处理机制。例如：偏序结构是一种关系结构，它以元素之间的次序关系或者比较关系作为处理机制；代数结构是一种运算结构，它以元素之间的运算作为处理机制；拓扑结构是一种分布结构，它以元素之间的空间分布作为处理机制；测度结构则是一种度量结构，它以元素的规模度量作为处理机制。  
（3）处理规则 为使定义出来的数学结构满足一些合理性要求以及能够在处理实际问题中发挥作用，避免出现一些矛盾或荒诞的处理结果，还必须制定一些处理规则对处理机制做一些必要的限制。在现代数学的公理化系统中，通常称这些处理规则称为公理。不同的数学结构具有不同的处理规则，例如偏序结构限制元素之间的关系必须满足自反性、反对称性和传递性，这些限制或者性质构成了偏序结构公理系统；再如代数结构则是规定元素之间的运算必须满足结合律、交换律、分配律等运算性质。  
数学运算最早起源于算术运算，即使用具体的整数或分数进行四则运算。随着科学技术的不断发展，人们逐步意识到这种方法不能满足对一般性规律的认识。因此，采用抽象的字母来代替具体的整数和分数进行运算以获得通用性结果，并称之为代数运算或简称为代数。在微积分出现之前的数千年历史中，对代数运算的研究一直占据数学研究的核心地位。那时人们普遍信奉一种所谓的万能法则，即世界上所有问题都可以转化为数学问题，所有数学问题都可以转化为代数问题，所有代数问题都可以转化为方程问题。  
因此，在很长一段历史时期内，人们对数学的研究基本上都是对代数学的研究，对代数学的研究基本上是方程或方程组解法的研究。解方程是那个时期内所有数学家的中心任务，大家都非常期望能够通过使用代数运算的方法找到方程或方程组的通用求解公式。这种努力在线性方程组领域取得了非常完美的结果，并由初等代数逐步衍生出线性代数。但是，对于一元高次方程通用求解方法的研究并不是很顺利，对于次数高于四次的一元方程始终找不到通用求解公式或求解方法。一些非常著名的数学家，例如欧拉、高斯、拉格朗日等都对此做了大量非常艰苦的研究，但均告失败。  
在寻求五次方程通用求解方法的过程中，年仅17 岁的法国天才少年伽罗瓦在1828 年提出群的概念，运用群的思想证明了五次方程通用求解公式是不存在的，并给出了五次方程系数在满足一定条件下若干特殊解法，由此一举解决了困扰数学家长达200 多年的数学问题。伽罗瓦取得成功的关键在于不仅将运算对象进行抽象化，而且对运算本身进行抽象，在抽象对象和抽象运算的基础上通过构造一些特殊抽象代数结构进行求解。这个思想在当时实在过于超前以至于没有得到柯西、傅里叶、泊松等著名数学家的认可，泊松的判词是“完全不能理解”。 1832 年5 月31 日年仅21 岁的伽罗瓦死于决斗。在决斗之前，他把关于五次方程代数求解的研究成果写成长信，留给了人类。14 年后，法国数学家刘维尔整理并发表了伽罗瓦的遗作，人们才理解并惊叹他那超越时代的天才思想和巧妙构思。  
至此以后，人们对代数的研究内容由方程或方程组的求解技巧转变为对代数运算性质和运算结构的研究，通过对运算和运算对象进行抽象的方式实现对所有运算依其运算性质进行分类或归类，并将伽罗瓦的群论迅速发展成为一门称之为抽象代数结构的崭新数学分支。 抽象代数结构的诞生，把代数学从传统的初等代数发展到现代的抽象代数，由此打开了现代代数学的大门，开创了代数学研究的新纪元。因此，抽象代数结构通常也称为近世代数以区别于之前的初等代数。若无特别说明，我们通常将抽象代数结构简称为代数结构。  
经过一百多年的发展，抽象代数结构已经形成一个如图11-1 所示的知识体系。对于一个代数系统，我们不仅可以主动设计出它的运算并考察相应的运算规则，而且还可以通过分别对其载体集合进行相关改造或运算得到相应的子代数、积代数和商代数，可以通过映射的方式考察不同代数结构之间的区别与联系，还可根据运算性质对代数结构进行分类，形成若干典型抽象代数系统，如群、环、域、格等。  
![](images/37d476cf884c29ed65924bc021cb612de43bab4df8b1196f64e96cad4f61a01f.jpg)
图11-1 抽象代数结构的知识体系  
代数结构作为一种特殊的数学结构，具有载体、处理机制和处理规则这三个基本要素。如前所述，代数结构的载体就是由一些抽象对象为元素组成的集合，并通过运算机制实现对集合中元素的处理。所谓运算，其实就是通过映射的手段从已有元素中构造出新的元素。载体和运算统称为代数结构的成分。代数结构的处理规则即为运算性质。  
既然代数结构的载体是一个集合，那么就可以考虑通过一定方式由这个集合派生出新的集合并据此构造出新的代数结构。例如，可以考察其子集以及在子集上的运算，得到子代数的概念和性质；可以对作为载体的集合做笛卡尔集构成一个新的集合，并在新集合上定义相关运算，得到积代数的概念和性质；可以通过构造等价关系的方法实现对集合载体的划分，构成一个以等价类为元素的商集，并在这个商集上定义相关运算，得到商代数的概念和性质。子代数、积代数和商代数是构造和研究代数结构的基本方法论。  
当然，还可以考察两个代数结构之间的相似性与差异性。对于任意两个代数系统，可以在这两个代数结构的载体(集合)上建立一种保运算的映射，由此考察代数结构之间的联系。如果存在这种保运算映射，则称这两个代数系统同态。如果这种保运算的映射还是双射，则称这两个代数系统同构。同态和同构是考察代数结构之间联系的基本工具。  
依据代数结构的运算性质，可以将各种具体代数结构划分为若干抽象类型。典型的抽象代数结构类型主要有仅含一个二元运算的半群与群、含有两个二元运算的环与域，以及格与布尔代数。这些典型抽象代数结构构成代数结构知识体系的主要内容。",同态是考察两个代数结构之间联系的基本工具
代数结构,考察工具,同构,,"代数结构作为四大基本数学结构之一，它以运算作为处理机制，在整个数学理论体系和计算机数学建模中占据非常重要的作用。代数结构是一种非常古老的数学结构，具有几千年发展历程，从最初初等代数逐步发展到大代数，然后进一步发展到抽象代数，目前正朝着泛代数的方向发展。本小节主要介绍抽象代数的由来及其基本知识结构。  
用计算机解决实际问题，一般需要对问题进行抽象并建立相应的数学模型，然后在此基础上将对实际问题的求解转化为对数学模型的求解。 因此，数学模型是用计算机解决实际问题的基础。现实问题纷繁复杂、变化万千，所建立的数学模型自然也是五花八门，多种多样，让人无所适从。值得欣慰的是，尽管我们面对的数学模型复杂多样，但从结构上看，所有这些数学模型都建立在四种基本的数学结构基础之上。  
这四种基本数学结构分别为：表示元素之间空间关系的拓扑结构，如图模型、树模型就是一些拓扑结构；表示元素之间运算关系的代数结构，如初等代数、向量代数、矩阵代数、命题代数、集合代数等都是代数结构；表示元素规模度量性质的测度结构，如高等数学里函数的微分和积分都是测度结构，它们主要计算面积、体积、弧长、速度等；表示元素之间次序关系的偏序结构，如整数的整除关系、集合的包含关系等偏序关系都是偏序结构。  
任何一个数学结构都是由载体、处理机制和处理规则这三个基本要素组成：  
（1）载体集合 对于任何一个数学结构，需要定义一些抽象的元素作为处理对象，这些抽象元素组成的集合构成数学结构的载体。载体集合是数学结构存在的基础或平台。  
（2）处理机制 为了实现对数学结构载体中元素的处理，需要定义一些处理机制，不同的数学结构具有不同的处理机制。例如：偏序结构是一种关系结构，它以元素之间的次序关系或者比较关系作为处理机制；代数结构是一种运算结构，它以元素之间的运算作为处理机制；拓扑结构是一种分布结构，它以元素之间的空间分布作为处理机制；测度结构则是一种度量结构，它以元素的规模度量作为处理机制。  
（3）处理规则 为使定义出来的数学结构满足一些合理性要求以及能够在处理实际问题中发挥作用，避免出现一些矛盾或荒诞的处理结果，还必须制定一些处理规则对处理机制做一些必要的限制。在现代数学的公理化系统中，通常称这些处理规则称为公理。不同的数学结构具有不同的处理规则，例如偏序结构限制元素之间的关系必须满足自反性、反对称性和传递性，这些限制或者性质构成了偏序结构公理系统；再如代数结构则是规定元素之间的运算必须满足结合律、交换律、分配律等运算性质。  
数学运算最早起源于算术运算，即使用具体的整数或分数进行四则运算。随着科学技术的不断发展，人们逐步意识到这种方法不能满足对一般性规律的认识。因此，采用抽象的字母来代替具体的整数和分数进行运算以获得通用性结果，并称之为代数运算或简称为代数。在微积分出现之前的数千年历史中，对代数运算的研究一直占据数学研究的核心地位。那时人们普遍信奉一种所谓的万能法则，即世界上所有问题都可以转化为数学问题，所有数学问题都可以转化为代数问题，所有代数问题都可以转化为方程问题。  
因此，在很长一段历史时期内，人们对数学的研究基本上都是对代数学的研究，对代数学的研究基本上是方程或方程组解法的研究。解方程是那个时期内所有数学家的中心任务，大家都非常期望能够通过使用代数运算的方法找到方程或方程组的通用求解公式。这种努力在线性方程组领域取得了非常完美的结果，并由初等代数逐步衍生出线性代数。但是，对于一元高次方程通用求解方法的研究并不是很顺利，对于次数高于四次的一元方程始终找不到通用求解公式或求解方法。一些非常著名的数学家，例如欧拉、高斯、拉格朗日等都对此做了大量非常艰苦的研究，但均告失败。  
在寻求五次方程通用求解方法的过程中，年仅17 岁的法国天才少年伽罗瓦在1828 年提出群的概念，运用群的思想证明了五次方程通用求解公式是不存在的，并给出了五次方程系数在满足一定条件下若干特殊解法，由此一举解决了困扰数学家长达200 多年的数学问题。伽罗瓦取得成功的关键在于不仅将运算对象进行抽象化，而且对运算本身进行抽象，在抽象对象和抽象运算的基础上通过构造一些特殊抽象代数结构进行求解。这个思想在当时实在过于超前以至于没有得到柯西、傅里叶、泊松等著名数学家的认可，泊松的判词是“完全不能理解”。 1832 年5 月31 日年仅21 岁的伽罗瓦死于决斗。在决斗之前，他把关于五次方程代数求解的研究成果写成长信，留给了人类。14 年后，法国数学家刘维尔整理并发表了伽罗瓦的遗作，人们才理解并惊叹他那超越时代的天才思想和巧妙构思。  
至此以后，人们对代数的研究内容由方程或方程组的求解技巧转变为对代数运算性质和运算结构的研究，通过对运算和运算对象进行抽象的方式实现对所有运算依其运算性质进行分类或归类，并将伽罗瓦的群论迅速发展成为一门称之为抽象代数结构的崭新数学分支。 抽象代数结构的诞生，把代数学从传统的初等代数发展到现代的抽象代数，由此打开了现代代数学的大门，开创了代数学研究的新纪元。因此，抽象代数结构通常也称为近世代数以区别于之前的初等代数。若无特别说明，我们通常将抽象代数结构简称为代数结构。  
经过一百多年的发展，抽象代数结构已经形成一个如图11-1 所示的知识体系。对于一个代数系统，我们不仅可以主动设计出它的运算并考察相应的运算规则，而且还可以通过分别对其载体集合进行相关改造或运算得到相应的子代数、积代数和商代数，可以通过映射的方式考察不同代数结构之间的区别与联系，还可根据运算性质对代数结构进行分类，形成若干典型抽象代数系统，如群、环、域、格等。  
![](images/37d476cf884c29ed65924bc021cb612de43bab4df8b1196f64e96cad4f61a01f.jpg)
图11-1 抽象代数结构的知识体系  
代数结构作为一种特殊的数学结构，具有载体、处理机制和处理规则这三个基本要素。如前所述，代数结构的载体就是由一些抽象对象为元素组成的集合，并通过运算机制实现对集合中元素的处理。所谓运算，其实就是通过映射的手段从已有元素中构造出新的元素。载体和运算统称为代数结构的成分。代数结构的处理规则即为运算性质。  
既然代数结构的载体是一个集合，那么就可以考虑通过一定方式由这个集合派生出新的集合并据此构造出新的代数结构。例如，可以考察其子集以及在子集上的运算，得到子代数的概念和性质；可以对作为载体的集合做笛卡尔集构成一个新的集合，并在新集合上定义相关运算，得到积代数的概念和性质；可以通过构造等价关系的方法实现对集合载体的划分，构成一个以等价类为元素的商集，并在这个商集上定义相关运算，得到商代数的概念和性质。子代数、积代数和商代数是构造和研究代数结构的基本方法论。  
当然，还可以考察两个代数结构之间的相似性与差异性。对于任意两个代数系统，可以在这两个代数结构的载体(集合)上建立一种保运算的映射，由此考察代数结构之间的联系。如果存在这种保运算映射，则称这两个代数系统同态。如果这种保运算的映射还是双射，则称这两个代数系统同构。同态和同构是考察代数结构之间联系的基本工具。  
依据代数结构的运算性质，可以将各种具体代数结构划分为若干抽象类型。典型的抽象代数结构类型主要有仅含一个二元运算的半群与群、含有两个二元运算的环与域，以及格与布尔代数。这些典型抽象代数结构构成代数结构知识体系的主要内容。",同构是考察两个代数结构之间联系的基本工具
代数结构,包含,运算,,"所以代数结构，本质上就是由一个运算对象的集合和若干运算构成的系统。要学好代数结构，首先必须掌握运算的概念和性质。  
对于运算这个概念，其实我们并不陌生。例如实数的加、减、乘、除等二元运算。这些二元运算通过某种机制由两个运算对象构造出一个确定的新的对象，或者说按照某种既定的规则根据两个输入得到一个唯一确定的输出。因此，二元运算可以看成是一种特殊的二元映射或二元函数，具体定义如下：  
【定义11.1】假设$𝐴,B,C$任意给定的三个非空集合，则从$A\times B$到$C$上的二元映射$f$，称为一个从$A\times B$到$C$的二元运算，即有$f：A\times B\to C$。当$A=B=C$时，称$f：A\times A\to A$为$𝑨$上的二元运算。  
【定义11.2】设$A_{1},A_{2},\cdots,A_{n},A$均为一个非空集合，从集合$A_{1}\times A_{2}\times\cdots\times A_{n}$到集合$A$的映射$f$称为一个从集合$A_{1}\times A_{2}\times\cdots\times A_{n}$到集合𝐴的$\pmb{n}$元运算，即有：$f$：$A_{1}\times A_{2}\times\cdots\times$$A_{n}\to A$。若有$\  A_{1}=A_{2}=\cdots=A_{n}=A$，则称$f$：$A\times A\times\cdots\times A\to A$为集合𝑨上的一个$n$元运算。当$n=1$时，称$f$：$A\rightarrow A$为集合𝑨上的一元运算。  
从上述定义可以看出，多元运算其实就是一类特殊的多元函数。 例如，三元函数：  
$$
*\!:R^{3}\rightarrow R\,,\,\,\,*\left(x,y,z\right)=z\,,\,\,\,\forall x,y,z\in R
$$  
就是一个三元运算，该运算表示三维空间上的点$(x,y,z)$到$z$轴上的投影。  
目前，多元运算在关系数据库的多元关系演算等领域具有重要的应用价值。 不过，多元运算是对二元关系的自然推广，与二元关系没有本质上的差异。  因此，我们主要考察一元运算和二元运算的概念与性质。  例如，整数集合$Z$ 上求相反数运算、幂集合上的求补运算、实矩阵集合上的求矩阵转置运算、命题集合中的非运算等等，都是一元运算。  与二元运算的情形完全相同，可以使用运算符或运算表表示一元运算，这里不再赘述。",代数结构由一个运算对象的集合和若干运算构成
运算,特化,二元运算,,"所以代数结构，本质上就是由一个运算对象的集合和若干运算构成的系统。要学好代数结构，首先必须掌握运算的概念和性质。  
对于运算这个概念，其实我们并不陌生。例如实数的加、减、乘、除等二元运算。这些二元运算通过某种机制由两个运算对象构造出一个确定的新的对象，或者说按照某种既定的规则根据两个输入得到一个唯一确定的输出。因此，二元运算可以看成是一种特殊的二元映射或二元函数，具体定义如下：  
【定义11.1】假设$𝐴,B,C$任意给定的三个非空集合，则从$A\times B$到$C$上的二元映射$f$，称为一个从$A\times B$到$C$的二元运算，即有$f：A\times B\to C$。当$A=B=C$时，称$f：A\times A\to A$为$𝑨$上的二元运算。  
【定义11.2】设$A_{1},A_{2},\cdots,A_{n},A$均为一个非空集合，从集合$A_{1}\times A_{2}\times\cdots\times A_{n}$到集合$A$的映射$f$称为一个从集合$A_{1}\times A_{2}\times\cdots\times A_{n}$到集合𝐴的$\pmb{n}$元运算，即有：$f$：$A_{1}\times A_{2}\times\cdots\times$$A_{n}\to A$。若有$\  A_{1}=A_{2}=\cdots=A_{n}=A$，则称$f$：$A\times A\times\cdots\times A\to A$为集合𝑨上的一个$n$元运算。当$n=1$时，称$f$：$A\rightarrow A$为集合𝑨上的一元运算。  
从上述定义可以看出，多元运算其实就是一类特殊的多元函数。 例如，三元函数：  
$$
*\!:R^{3}\rightarrow R\,,\,\,\,*\left(x,y,z\right)=z\,,\,\,\,\forall x,y,z\in R
$$  
就是一个三元运算，该运算表示三维空间上的点$(x,y,z)$到$z$轴上的投影。  
目前，多元运算在关系数据库的多元关系演算等领域具有重要的应用价值。 不过，多元运算是对二元关系的自然推广，与二元关系没有本质上的差异。  因此，我们主要考察一元运算和二元运算的概念与性质。  例如，整数集合$Z$ 上求相反数运算、幂集合上的求补运算、实矩阵集合上的求矩阵转置运算、命题集合中的非运算等等，都是一元运算。  与二元运算的情形完全相同，可以使用运算符或运算表表示一元运算，这里不再赘述。",二元运算是运算的一种特殊形式，涉及两个运算对象
运算,特化,多元运算,,"所以代数结构，本质上就是由一个运算对象的集合和若干运算构成的系统。要学好代数结构，首先必须掌握运算的概念和性质。  
对于运算这个概念，其实我们并不陌生。例如实数的加、减、乘、除等二元运算。这些二元运算通过某种机制由两个运算对象构造出一个确定的新的对象，或者说按照某种既定的规则根据两个输入得到一个唯一确定的输出。因此，二元运算可以看成是一种特殊的二元映射或二元函数，具体定义如下：  
【定义11.1】假设$𝐴,B,C$任意给定的三个非空集合，则从$A\times B$到$C$上的二元映射$f$，称为一个从$A\times B$到$C$的二元运算，即有$f：A\times B\to C$。当$A=B=C$时，称$f：A\times A\to A$为$𝑨$上的二元运算。  
【定义11.2】设$A_{1},A_{2},\cdots,A_{n},A$均为一个非空集合，从集合$A_{1}\times A_{2}\times\cdots\times A_{n}$到集合$A$的映射$f$称为一个从集合$A_{1}\times A_{2}\times\cdots\times A_{n}$到集合𝐴的$\pmb{n}$元运算，即有：$f$：$A_{1}\times A_{2}\times\cdots\times$$A_{n}\to A$。若有$\  A_{1}=A_{2}=\cdots=A_{n}=A$，则称$f$：$A\times A\times\cdots\times A\to A$为集合𝑨上的一个$n$元运算。当$n=1$时，称$f$：$A\rightarrow A$为集合𝑨上的一元运算。  
从上述定义可以看出，多元运算其实就是一类特殊的多元函数。 例如，三元函数：  
$$
*\!:R^{3}\rightarrow R\,,\,\,\,*\left(x,y,z\right)=z\,,\,\,\,\forall x,y,z\in R
$$  
就是一个三元运算，该运算表示三维空间上的点$(x,y,z)$到$z$轴上的投影。  
目前，多元运算在关系数据库的多元关系演算等领域具有重要的应用价值。 不过，多元运算是对二元关系的自然推广，与二元关系没有本质上的差异。  因此，我们主要考察一元运算和二元运算的概念与性质。  例如，整数集合$Z$ 上求相反数运算、幂集合上的求补运算、实矩阵集合上的求矩阵转置运算、命题集合中的非运算等等，都是一元运算。  与二元运算的情形完全相同，可以使用运算符或运算表表示一元运算，这里不再赘述。",多元运算是运算的一种特殊形式，涉及多个运算对象
运算,特化,一元运算,,"所以代数结构，本质上就是由一个运算对象的集合和若干运算构成的系统。要学好代数结构，首先必须掌握运算的概念和性质。  
对于运算这个概念，其实我们并不陌生。例如实数的加、减、乘、除等二元运算。这些二元运算通过某种机制由两个运算对象构造出一个确定的新的对象，或者说按照某种既定的规则根据两个输入得到一个唯一确定的输出。因此，二元运算可以看成是一种特殊的二元映射或二元函数，具体定义如下：  
【定义11.1】假设$𝐴,B,C$任意给定的三个非空集合，则从$A\times B$到$C$上的二元映射$f$，称为一个从$A\times B$到$C$的二元运算，即有$f：A\times B\to C$。当$A=B=C$时，称$f：A\times A\to A$为$𝑨$上的二元运算。  
【定义11.2】设$A_{1},A_{2},\cdots,A_{n},A$均为一个非空集合，从集合$A_{1}\times A_{2}\times\cdots\times A_{n}$到集合$A$的映射$f$称为一个从集合$A_{1}\times A_{2}\times\cdots\times A_{n}$到集合𝐴的$\pmb{n}$元运算，即有：$f$：$A_{1}\times A_{2}\times\cdots\times$$A_{n}\to A$。若有$\  A_{1}=A_{2}=\cdots=A_{n}=A$，则称$f$：$A\times A\times\cdots\times A\to A$为集合𝑨上的一个$n$元运算。当$n=1$时，称$f$：$A\rightarrow A$为集合𝑨上的一元运算。  
从上述定义可以看出，多元运算其实就是一类特殊的多元函数。 例如，三元函数：  
$$
*\!:R^{3}\rightarrow R\,,\,\,\,*\left(x,y,z\right)=z\,,\,\,\,\forall x,y,z\in R
$$  
就是一个三元运算，该运算表示三维空间上的点$(x,y,z)$到$z$轴上的投影。  
目前，多元运算在关系数据库的多元关系演算等领域具有重要的应用价值。 不过，多元运算是对二元关系的自然推广，与二元关系没有本质上的差异。  因此，我们主要考察一元运算和二元运算的概念与性质。  例如，整数集合$Z$ 上求相反数运算、幂集合上的求补运算、实矩阵集合上的求矩阵转置运算、命题集合中的非运算等等，都是一元运算。  与二元运算的情形完全相同，可以使用运算符或运算表表示一元运算，这里不再赘述。",一元运算是运算的一种特殊形式，涉及一个运算对象
二元运算,推广,多元运算,,"所以代数结构，本质上就是由一个运算对象的集合和若干运算构成的系统。要学好代数结构，首先必须掌握运算的概念和性质。  
对于运算这个概念，其实我们并不陌生。例如实数的加、减、乘、除等二元运算。这些二元运算通过某种机制由两个运算对象构造出一个确定的新的对象，或者说按照某种既定的规则根据两个输入得到一个唯一确定的输出。因此，二元运算可以看成是一种特殊的二元映射或二元函数，具体定义如下：  
【定义11.1】假设$𝐴,B,C$任意给定的三个非空集合，则从$A\times B$到$C$上的二元映射$f$，称为一个从$A\times B$到$C$的二元运算，即有$f：A\times B\to C$。当$A=B=C$时，称$f：A\times A\to A$为$𝑨$上的二元运算。  
【定义11.2】设$A_{1},A_{2},\cdots,A_{n},A$均为一个非空集合，从集合$A_{1}\times A_{2}\times\cdots\times A_{n}$到集合$A$的映射$f$称为一个从集合$A_{1}\times A_{2}\times\cdots\times A_{n}$到集合𝐴的$\pmb{n}$元运算，即有：$f$：$A_{1}\times A_{2}\times\cdots\times$$A_{n}\to A$。若有$\  A_{1}=A_{2}=\cdots=A_{n}=A$，则称$f$：$A\times A\times\cdots\times A\to A$为集合𝑨上的一个$n$元运算。当$n=1$时，称$f$：$A\rightarrow A$为集合𝑨上的一元运算。  
从上述定义可以看出，多元运算其实就是一类特殊的多元函数。 例如，三元函数：  
$$
*\!:R^{3}\rightarrow R\,,\,\,\,*\left(x,y,z\right)=z\,,\,\,\,\forall x,y,z\in R
$$  
就是一个三元运算，该运算表示三维空间上的点$(x,y,z)$到$z$轴上的投影。  
目前，多元运算在关系数据库的多元关系演算等领域具有重要的应用价值。 不过，多元运算是对二元关系的自然推广，与二元关系没有本质上的差异。  因此，我们主要考察一元运算和二元运算的概念与性质。  例如，整数集合$Z$ 上求相反数运算、幂集合上的求补运算、实矩阵集合上的求矩阵转置运算、命题集合中的非运算等等，都是一元运算。  与二元运算的情形完全相同，可以使用运算符或运算表表示一元运算，这里不再赘述。",多元运算是对二元运算的自然推广
二元运算,并列,一元运算,,"所以代数结构，本质上就是由一个运算对象的集合和若干运算构成的系统。要学好代数结构，首先必须掌握运算的概念和性质。  
对于运算这个概念，其实我们并不陌生。例如实数的加、减、乘、除等二元运算。这些二元运算通过某种机制由两个运算对象构造出一个确定的新的对象，或者说按照某种既定的规则根据两个输入得到一个唯一确定的输出。因此，二元运算可以看成是一种特殊的二元映射或二元函数，具体定义如下：  
【定义11.1】假设$𝐴,B,C$任意给定的三个非空集合，则从$A\times B$到$C$上的二元映射$f$，称为一个从$A\times B$到$C$的二元运算，即有$f：A\times B\to C$。当$A=B=C$时，称$f：A\times A\to A$为$𝑨$上的二元运算。  
【定义11.2】设$A_{1},A_{2},\cdots,A_{n},A$均为一个非空集合，从集合$A_{1}\times A_{2}\times\cdots\times A_{n}$到集合$A$的映射$f$称为一个从集合$A_{1}\times A_{2}\times\cdots\times A_{n}$到集合𝐴的$\pmb{n}$元运算，即有：$f$：$A_{1}\times A_{2}\times\cdots\times$$A_{n}\to A$。若有$\  A_{1}=A_{2}=\cdots=A_{n}=A$，则称$f$：$A\times A\times\cdots\times A\to A$为集合𝑨上的一个$n$元运算。当$n=1$时，称$f$：$A\rightarrow A$为集合𝑨上的一元运算。  
从上述定义可以看出，多元运算其实就是一类特殊的多元函数。 例如，三元函数：  
$$
*\!:R^{3}\rightarrow R\,,\,\,\,*\left(x,y,z\right)=z\,,\,\,\,\forall x,y,z\in R
$$  
就是一个三元运算，该运算表示三维空间上的点$(x,y,z)$到$z$轴上的投影。  
目前，多元运算在关系数据库的多元关系演算等领域具有重要的应用价值。 不过，多元运算是对二元关系的自然推广，与二元关系没有本质上的差异。  因此，我们主要考察一元运算和二元运算的概念与性质。  例如，整数集合$Z$ 上求相反数运算、幂集合上的求补运算、实矩阵集合上的求矩阵转置运算、命题集合中的非运算等等，都是一元运算。  与二元运算的情形完全相同，可以使用运算符或运算表表示一元运算，这里不再赘述。",二元运算和一元运算都是运算的不同形式，需主要考察其概念与性质
代数结构,等价,代数系统,,"如前所述，代数结构由作为结构载体的集合、作为结构处理机制的运算和作为结构处理规则的运算律这三个部分组成。其中集合和运算是代数结构的构成成分，是代数结构的实体部分，而运算律则是代数结构中的公理系统或规章制度。这里着重介绍代数结构集合和运算，下一节将详细讨论代数结构的运算律。  
假设𝐴是一个任意给定的非空集合，则对于该集合上的一元运算或二运算$^{\ast}$，即：  
$*: A\to A \text{或} *: A\times A\to A$  
其运算结果并没有跑到集合𝐴之外，也就是说运算结果仍然是集合𝐴中的某个元素。这种性质通常称为运算的封闭性。由此可见，集合𝐴上的一元运算或二运算$^*$满足封闭性。  
根据以上讨论，可以得到如下关于代数结构的定义：  
【定义11.3】假设𝐴是一个任意给定的非空集合，$*_{1},*_{2},*_{3},\cdots,*_{k}$是𝐴上$k$个一元或二元运算，则集合𝐴与其上的$k$ 个运算$*_{1},*_{2},*_{3},\cdots,*_{k}$构成的整体称为一个代数结构或代数系统，简称为代数，记为$\langle A,\;\;*_{1},*_{2},*_{3},\cdots,*_{k}\rangle$。  
不难看出：$\langle N,+\rangle,\langle Z,+\rangle,\langle R,-\rangle,\langle N,+,\ \cdot\rangle,\langle R,+,\ \cdot\rangle:$都是代数结构，其中$+$，−，⋅都是普通的加法、减法和乘法；令𝑆表示所有含两个变量的命题公式组成的集合，则$\langle S,\ \wedge,\vee,\lnot\rangle$是一个代数结构，通常称之为命题代数；令𝐴表示任意一个给定的非空集合，则$\langle P(A),\;\cap,\;\cup, -\rangle$一个代数结构，通常称之为集合代数；令$M_{n}(R)$表示实数集合$R$上所有$n\times n$阶矩阵组成的集合，则$\langle M_{n}(R),+,\ \cdot\rangle$是一个代数结构，通常称之为矩阵代数。  
从上述讨论和定义可以看出，正是因为集合𝐴上的一元运算和二运算满足封闭性，才保证了集合𝐴能够成为整个代数结构的载体。由此可知，代数结构肯定也是具有封闭性的。  
例如$\langle N,+\rangle$显然是一个代数结构，而且普通‘$+$’运算在自然数N 上是具有封闭性。但是，在整数除法就不是整数集合𝑍上的二元运算，因为两个整数之商不一定是整数，不满足不封闭性，因此$ Z,+$不是代数结构。  
值得注意的是，有些离散数学书将代数结构和代数系统作为两个不同概念的进行来讨论。 具体地说，就是将运算性质的总和作为代数结构，将代数系统看成是代数结构和集合的集成。本书为了与数学结构的相关理论保持一致，默认代数结构和和代数系统是同一个概念，在后续的介绍和讨论中会不加区分地使用代数结构或代数系统这个两个名词。  
事实上，通过载体集合子集产生子代数系统是一个具有普适性的基本方法，每种具体的代数系统都可以通过这种方法产生子代数系统。例如，环代数系统可以产生各种子环、域代数系统可以产生各种子域、格代数系统可以产生各种子格等等。 其实，还可对代数系统的载 体集合做其它分析以产生新的代数系统，例如可通过集合的笛卡尔产生积代数、通过集合的上的等价关系产生商代数等，后面将会进一步讨论与此相关的内容，这里不再赘述。",代数结构和代数系统在本书中被视为同一个概念，不加区分地使用。
代数系统,包含,子代数系统,,"如前所述，代数结构由作为结构载体的集合、作为结构处理机制的运算和作为结构处理规则的运算律这三个部分组成。其中集合和运算是代数结构的构成成分，是代数结构的实体部分，而运算律则是代数结构中的公理系统或规章制度。这里着重介绍代数结构集合和运算，下一节将详细讨论代数结构的运算律。  
假设𝐴是一个任意给定的非空集合，则对于该集合上的一元运算或二运算$^{\ast}$，即：  
$*: A\to A \text{或} *: A\times A\to A$  
其运算结果并没有跑到集合𝐴之外，也就是说运算结果仍然是集合𝐴中的某个元素。这种性质通常称为运算的封闭性。由此可见，集合𝐴上的一元运算或二运算$^*$满足封闭性。  
根据以上讨论，可以得到如下关于代数结构的定义：  
【定义11.3】假设𝐴是一个任意给定的非空集合，$*_{1},*_{2},*_{3},\cdots,*_{k}$是𝐴上$k$个一元或二元运算，则集合𝐴与其上的$k$ 个运算$*_{1},*_{2},*_{3},\cdots,*_{k}$构成的整体称为一个代数结构或代数系统，简称为代数，记为$\langle A,\;\;*_{1},*_{2},*_{3},\cdots,*_{k}\rangle$。  
不难看出：$\langle N,+\rangle,\langle Z,+\rangle,\langle R,-\rangle,\langle N,+,\ \cdot\rangle,\langle R,+,\ \cdot\rangle:$都是代数结构，其中$+$，−，⋅都是普通的加法、减法和乘法；令𝑆表示所有含两个变量的命题公式组成的集合，则$\langle S,\ \wedge,\vee,\lnot\rangle$是一个代数结构，通常称之为命题代数；令𝐴表示任意一个给定的非空集合，则$\langle P(A),\;\cap,\;\cup, -\rangle$一个代数结构，通常称之为集合代数；令$M_{n}(R)$表示实数集合$R$上所有$n\times n$阶矩阵组成的集合，则$\langle M_{n}(R),+,\ \cdot\rangle$是一个代数结构，通常称之为矩阵代数。  
从上述讨论和定义可以看出，正是因为集合𝐴上的一元运算和二运算满足封闭性，才保证了集合𝐴能够成为整个代数结构的载体。由此可知，代数结构肯定也是具有封闭性的。  
例如$\langle N,+\rangle$显然是一个代数结构，而且普通‘$+$’运算在自然数N 上是具有封闭性。但是，在整数除法就不是整数集合𝑍上的二元运算，因为两个整数之商不一定是整数，不满足不封闭性，因此$ Z,+$不是代数结构。  
值得注意的是，有些离散数学书将代数结构和代数系统作为两个不同概念的进行来讨论。 具体地说，就是将运算性质的总和作为代数结构，将代数系统看成是代数结构和集合的集成。本书为了与数学结构的相关理论保持一致，默认代数结构和和代数系统是同一个概念，在后续的介绍和讨论中会不加区分地使用代数结构或代数系统这个两个名词。  
事实上，通过载体集合子集产生子代数系统是一个具有普适性的基本方法，每种具体的代数系统都可以通过这种方法产生子代数系统。例如，环代数系统可以产生各种子环、域代数系统可以产生各种子域、格代数系统可以产生各种子格等等。 其实，还可对代数系统的载 体集合做其它分析以产生新的代数系统，例如可通过集合的笛卡尔产生积代数、通过集合的上的等价关系产生商代数等，后面将会进一步讨论与此相关的内容，这里不再赘述。",每种具体的代数系统可以通过其载体集合的子集产生相应的子代数系统。
代数结构,依赖,基本运算性质,,具体的代数结构种类繁多、不胜枚举，逐个分析和探讨每个代数结构的性质显然是不可行的。因此，必须通过建立一些标准实现对这些代数结构进行分类，以便进行分门别类的考察和研究，揭示这些代数结构共性和差异。这种做法有点类似前面对二元关系模型的研究，首先总结出二元关系的五个基本性质，即自反性、反自反性、对称性、反对称性和传递性，然后以这五个基本性质为标准来区分各种各样的关系，例如，满足自反性、对称性和传递性的关系为等价关系、满足自反性、反对称性和传递性的关系为偏序关系等等。对于代数结构的研究思路也是如此，首先要考察代数结构的基本运算性质，然后以这些基本运算性质为标准考察和分析各种各样的具体代数结构。这些基本性质主要由若干二元运算律与特殊元素组成，本节比较系统地介绍些二元运算律与特殊元素。,代数结构的研究依赖于其基本运算性质，通过基本运算性质来分类和考察具体代数结构
二元关系模型,类比,基本运算性质,,具体的代数结构种类繁多、不胜枚举，逐个分析和探讨每个代数结构的性质显然是不可行的。因此，必须通过建立一些标准实现对这些代数结构进行分类，以便进行分门别类的考察和研究，揭示这些代数结构共性和差异。这种做法有点类似前面对二元关系模型的研究，首先总结出二元关系的五个基本性质，即自反性、反自反性、对称性、反对称性和传递性，然后以这五个基本性质为标准来区分各种各样的关系，例如，满足自反性、对称性和传递性的关系为等价关系、满足自反性、反对称性和传递性的关系为偏序关系等等。对于代数结构的研究思路也是如此，首先要考察代数结构的基本运算性质，然后以这些基本运算性质为标准考察和分析各种各样的具体代数结构。这些基本性质主要由若干二元运算律与特殊元素组成，本节比较系统地介绍些二元运算律与特殊元素。,二元关系模型的研究通过总结基本性质来区分关系，类比于代数结构通过基本运算性质来分类
二元算律,包含,结合律,,"现在我们介绍和讨论二元运算律。一共有六个二元运算律，即结合律、交换律、幂等律、消去律、分配律和吸收率。其中前面四个基于单个二元运算，后面两个基于两个二元运算。下面分别讨论这些运算律，首先讨论结合律。  
结合律是大家非常熟悉也是非常重要的一个二元运算律，实数加法与乘法运算、矩阵的加法与乘法运算、关系与函数的复合运算、整数集合上的模余运算、幂集合的交运算与并运算等都满足结合律。结合律的具体定义如下：  
【定义11.5】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由$𝐴$和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$，成立$(x*y)*z=x*(y*z)$，则称$\langle A,*\rangle$的运算 $^*$ 在 𝐴 上是可结合的，或者说 $\langle A,*\rangle$ 的运算 $^*$ 在 𝐴 上满足结合律。  
对于任意给定的集合𝐴，由于𝐴上的二元运算${\ast}$满足封闭性，故对于$\forall x,y,z\in A$，有${x\ *}$$y\in A$且$y*z\in A$。因此，$(x*y)*z$和$x*(y*z)$都是有意义的算式，如果$*$满足结合律，则表达式$x*y*z$就有一个确定的计算结果，即有：  
$$
x*y*z=(x*y)*z=x*(y*z)
$$  
如果 $*$ 不满足结合律，则有可能有 $(x*y)*z\neq x*(y*z).$ 。   此时，表达式 $x*y*z$ 的含义就有歧义。因此，只有当某个运算$*$满足结合律时，才能定义其方幂运算。在后续半群与群中元素方幂的的定义中，其元素运算的结合律起着基础性的支撑作用。  
下面考察运算的交换律，首先给出交换律的定义，具体如下：  
【定义11.6】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y\in A$，成立$x*y=y*x$，则称$\langle A,\ *\rangle$的运算$^*$在𝐴上是可交换的，或者说$\langle A,\ *\rangle$的运算$^*$在𝐴上满足交换律。  
交换律表示代数结构载体集合中的任意两个元素在运算时都可以交换次序。 例如，实数加法与乘法运算、矩阵的加法、整数集合上的模余运算、幂集合的交运算与并运算等都满足交换律。 但是，矩阵的乘法运算、关系与函数的复合运算等都不满足交换律。  
【定义11.7】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，若存在某个元素$a\in A$，满足 a$*$$a=a$，则称$a$是$\langle A,\ *\rangle$的一个幂等元。 如果𝐴中的每个元素都是$\langle A,\ *\rangle$的幂等元，则称$\langle A,\ *\rangle$的运算$*$在𝐴上满足幂等律。  
从上述定义可以看出，所谓幂等元，就是该元素与其自身运算之后仍然等于其自身。例如，对于某个幂集合上的交运算和并运算，幂集合中每个元素显然都是幂等元，因此，幂集合上的交运算和并运算均满足幂等性。但是，对于整数上的加法运算，除了整数0 之外，其余整数显然都不是幂等元，因此,整数上的加法运算不满足幂等律。  
【定义11.8】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$：  
（1）若$z*y=z*x$，有$y=x$，则称运算$*$在𝐴上是可左消去的，或者说运算$∗$在𝐴上满足左消去律，并称$\cdot z$是$A$中关于运算$^*$的左可消去元；  
（2）若$y*z=x*z$，有$y=x$，则称运算$^*$在𝐴上是可右消去的，或者说运算$^*$在𝐴上满足右消去律，并称𝑧是$A$中关于运算$^*$的右可消去元。  
（3）若上述两种情况均满足，则称运算$*$在𝐴上满足消去律，并称$z$是𝐴中关于运算$*$的可消去元。  
下面介绍基于两个二元运算的运算律，即分配律和吸收律。首先给出分配律的定义：  
【定义11.9】假设𝐴是任意给定的一个非空集合，$^*$和$\Delta$均为𝐴上的二元运算，在由$𝐴$、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y,z\in A$：  
若有$x*(y\Delta z)=(x*y)\Delta(x*z)$，则称运算$*$对$\Delta$在𝐴上满足左分配律。  
若有$(y\Delta z)*x=(y*x)\Delta(z*x)$，则称运算$*$对$\Delta$在𝐴上满足右分配律。  
若运算$*$对$\Delta$在𝐴上同时满足左右分配律，则称运算$*$对$\Delta$在𝐴上满足分配律。  
例如，实数集合上的普通乘法对加法满足分配律，$M_{n}(R)$上的矩阵乘法对加法满足分配律，幂集$P(B)$上的集合交运算对并运算满足分配律，并且并运算对交运算也满足分配律。  
将上述关于集合的吸收律推广到一般运算对象和一般运算，得到一个新的运算律，即吸收律。其具体定义如下：  
【定义11.10】设𝐴是任意给定的一个非空集合，$*$和$\Delta$均为为𝐴上二元运算，在由𝐴、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y\in A$，成立：  
$$
x*(y\Delta z)=x,\;\;x\Delta(y*z)=x
$$  
则称 $*$ 和 $\Delta$ 在 A  上满足吸收律。",结合律是二元算律的一种
二元算律,包含,交换律,,"现在我们介绍和讨论二元运算律。一共有六个二元运算律，即结合律、交换律、幂等律、消去律、分配律和吸收率。其中前面四个基于单个二元运算，后面两个基于两个二元运算。下面分别讨论这些运算律，首先讨论结合律。  
结合律是大家非常熟悉也是非常重要的一个二元运算律，实数加法与乘法运算、矩阵的加法与乘法运算、关系与函数的复合运算、整数集合上的模余运算、幂集合的交运算与并运算等都满足结合律。结合律的具体定义如下：  
【定义11.5】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由$𝐴$和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$，成立$(x*y)*z=x*(y*z)$，则称$\langle A,*\rangle$的运算 $^*$ 在 𝐴 上是可结合的，或者说 $\langle A,*\rangle$ 的运算 $^*$ 在 𝐴 上满足结合律。  
对于任意给定的集合𝐴，由于𝐴上的二元运算${\ast}$满足封闭性，故对于$\forall x,y,z\in A$，有${x\ *}$$y\in A$且$y*z\in A$。因此，$(x*y)*z$和$x*(y*z)$都是有意义的算式，如果$*$满足结合律，则表达式$x*y*z$就有一个确定的计算结果，即有：  
$$
x*y*z=(x*y)*z=x*(y*z)
$$  
如果 $*$ 不满足结合律，则有可能有 $(x*y)*z\neq x*(y*z).$ 。   此时，表达式 $x*y*z$ 的含义就有歧义。因此，只有当某个运算$*$满足结合律时，才能定义其方幂运算。在后续半群与群中元素方幂的的定义中，其元素运算的结合律起着基础性的支撑作用。  
下面考察运算的交换律，首先给出交换律的定义，具体如下：  
【定义11.6】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y\in A$，成立$x*y=y*x$，则称$\langle A,\ *\rangle$的运算$^*$在𝐴上是可交换的，或者说$\langle A,\ *\rangle$的运算$^*$在𝐴上满足交换律。  
交换律表示代数结构载体集合中的任意两个元素在运算时都可以交换次序。 例如，实数加法与乘法运算、矩阵的加法、整数集合上的模余运算、幂集合的交运算与并运算等都满足交换律。 但是，矩阵的乘法运算、关系与函数的复合运算等都不满足交换律。  
【定义11.7】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，若存在某个元素$a\in A$，满足 a$*$$a=a$，则称$a$是$\langle A,\ *\rangle$的一个幂等元。 如果𝐴中的每个元素都是$\langle A,\ *\rangle$的幂等元，则称$\langle A,\ *\rangle$的运算$*$在𝐴上满足幂等律。  
从上述定义可以看出，所谓幂等元，就是该元素与其自身运算之后仍然等于其自身。例如，对于某个幂集合上的交运算和并运算，幂集合中每个元素显然都是幂等元，因此，幂集合上的交运算和并运算均满足幂等性。但是，对于整数上的加法运算，除了整数0 之外，其余整数显然都不是幂等元，因此,整数上的加法运算不满足幂等律。  
【定义11.8】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$：  
（1）若$z*y=z*x$，有$y=x$，则称运算$*$在𝐴上是可左消去的，或者说运算$∗$在𝐴上满足左消去律，并称$\cdot z$是$A$中关于运算$^*$的左可消去元；  
（2）若$y*z=x*z$，有$y=x$，则称运算$^*$在𝐴上是可右消去的，或者说运算$^*$在𝐴上满足右消去律，并称𝑧是$A$中关于运算$^*$的右可消去元。  
（3）若上述两种情况均满足，则称运算$*$在𝐴上满足消去律，并称$z$是𝐴中关于运算$*$的可消去元。  
下面介绍基于两个二元运算的运算律，即分配律和吸收律。首先给出分配律的定义：  
【定义11.9】假设𝐴是任意给定的一个非空集合，$^*$和$\Delta$均为𝐴上的二元运算，在由$𝐴$、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y,z\in A$：  
若有$x*(y\Delta z)=(x*y)\Delta(x*z)$，则称运算$*$对$\Delta$在𝐴上满足左分配律。  
若有$(y\Delta z)*x=(y*x)\Delta(z*x)$，则称运算$*$对$\Delta$在𝐴上满足右分配律。  
若运算$*$对$\Delta$在𝐴上同时满足左右分配律，则称运算$*$对$\Delta$在𝐴上满足分配律。  
例如，实数集合上的普通乘法对加法满足分配律，$M_{n}(R)$上的矩阵乘法对加法满足分配律，幂集$P(B)$上的集合交运算对并运算满足分配律，并且并运算对交运算也满足分配律。  
将上述关于集合的吸收律推广到一般运算对象和一般运算，得到一个新的运算律，即吸收律。其具体定义如下：  
【定义11.10】设𝐴是任意给定的一个非空集合，$*$和$\Delta$均为为𝐴上二元运算，在由𝐴、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y\in A$，成立：  
$$
x*(y\Delta z)=x,\;\;x\Delta(y*z)=x
$$  
则称 $*$ 和 $\Delta$ 在 A  上满足吸收律。",交换律是二元算律的一种
二元算律,包含,幂等律,,"现在我们介绍和讨论二元运算律。一共有六个二元运算律，即结合律、交换律、幂等律、消去律、分配律和吸收率。其中前面四个基于单个二元运算，后面两个基于两个二元运算。下面分别讨论这些运算律，首先讨论结合律。  
结合律是大家非常熟悉也是非常重要的一个二元运算律，实数加法与乘法运算、矩阵的加法与乘法运算、关系与函数的复合运算、整数集合上的模余运算、幂集合的交运算与并运算等都满足结合律。结合律的具体定义如下：  
【定义11.5】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由$𝐴$和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$，成立$(x*y)*z=x*(y*z)$，则称$\langle A,*\rangle$的运算 $^*$ 在 𝐴 上是可结合的，或者说 $\langle A,*\rangle$ 的运算 $^*$ 在 𝐴 上满足结合律。  
对于任意给定的集合𝐴，由于𝐴上的二元运算${\ast}$满足封闭性，故对于$\forall x,y,z\in A$，有${x\ *}$$y\in A$且$y*z\in A$。因此，$(x*y)*z$和$x*(y*z)$都是有意义的算式，如果$*$满足结合律，则表达式$x*y*z$就有一个确定的计算结果，即有：  
$$
x*y*z=(x*y)*z=x*(y*z)
$$  
如果 $*$ 不满足结合律，则有可能有 $(x*y)*z\neq x*(y*z).$ 。   此时，表达式 $x*y*z$ 的含义就有歧义。因此，只有当某个运算$*$满足结合律时，才能定义其方幂运算。在后续半群与群中元素方幂的的定义中，其元素运算的结合律起着基础性的支撑作用。  
下面考察运算的交换律，首先给出交换律的定义，具体如下：  
【定义11.6】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y\in A$，成立$x*y=y*x$，则称$\langle A,\ *\rangle$的运算$^*$在𝐴上是可交换的，或者说$\langle A,\ *\rangle$的运算$^*$在𝐴上满足交换律。  
交换律表示代数结构载体集合中的任意两个元素在运算时都可以交换次序。 例如，实数加法与乘法运算、矩阵的加法、整数集合上的模余运算、幂集合的交运算与并运算等都满足交换律。 但是，矩阵的乘法运算、关系与函数的复合运算等都不满足交换律。  
【定义11.7】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，若存在某个元素$a\in A$，满足 a$*$$a=a$，则称$a$是$\langle A,\ *\rangle$的一个幂等元。 如果𝐴中的每个元素都是$\langle A,\ *\rangle$的幂等元，则称$\langle A,\ *\rangle$的运算$*$在𝐴上满足幂等律。  
从上述定义可以看出，所谓幂等元，就是该元素与其自身运算之后仍然等于其自身。例如，对于某个幂集合上的交运算和并运算，幂集合中每个元素显然都是幂等元，因此，幂集合上的交运算和并运算均满足幂等性。但是，对于整数上的加法运算，除了整数0 之外，其余整数显然都不是幂等元，因此,整数上的加法运算不满足幂等律。  
【定义11.8】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$：  
（1）若$z*y=z*x$，有$y=x$，则称运算$*$在𝐴上是可左消去的，或者说运算$∗$在𝐴上满足左消去律，并称$\cdot z$是$A$中关于运算$^*$的左可消去元；  
（2）若$y*z=x*z$，有$y=x$，则称运算$^*$在𝐴上是可右消去的，或者说运算$^*$在𝐴上满足右消去律，并称𝑧是$A$中关于运算$^*$的右可消去元。  
（3）若上述两种情况均满足，则称运算$*$在𝐴上满足消去律，并称$z$是𝐴中关于运算$*$的可消去元。  
下面介绍基于两个二元运算的运算律，即分配律和吸收律。首先给出分配律的定义：  
【定义11.9】假设𝐴是任意给定的一个非空集合，$^*$和$\Delta$均为𝐴上的二元运算，在由$𝐴$、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y,z\in A$：  
若有$x*(y\Delta z)=(x*y)\Delta(x*z)$，则称运算$*$对$\Delta$在𝐴上满足左分配律。  
若有$(y\Delta z)*x=(y*x)\Delta(z*x)$，则称运算$*$对$\Delta$在𝐴上满足右分配律。  
若运算$*$对$\Delta$在𝐴上同时满足左右分配律，则称运算$*$对$\Delta$在𝐴上满足分配律。  
例如，实数集合上的普通乘法对加法满足分配律，$M_{n}(R)$上的矩阵乘法对加法满足分配律，幂集$P(B)$上的集合交运算对并运算满足分配律，并且并运算对交运算也满足分配律。  
将上述关于集合的吸收律推广到一般运算对象和一般运算，得到一个新的运算律，即吸收律。其具体定义如下：  
【定义11.10】设𝐴是任意给定的一个非空集合，$*$和$\Delta$均为为𝐴上二元运算，在由𝐴、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y\in A$，成立：  
$$
x*(y\Delta z)=x,\;\;x\Delta(y*z)=x
$$  
则称 $*$ 和 $\Delta$ 在 A  上满足吸收律。",幂等律是二元算律的一种
二元算律,包含,消去律,,"现在我们介绍和讨论二元运算律。一共有六个二元运算律，即结合律、交换律、幂等律、消去律、分配律和吸收率。其中前面四个基于单个二元运算，后面两个基于两个二元运算。下面分别讨论这些运算律，首先讨论结合律。  
结合律是大家非常熟悉也是非常重要的一个二元运算律，实数加法与乘法运算、矩阵的加法与乘法运算、关系与函数的复合运算、整数集合上的模余运算、幂集合的交运算与并运算等都满足结合律。结合律的具体定义如下：  
【定义11.5】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由$𝐴$和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$，成立$(x*y)*z=x*(y*z)$，则称$\langle A,*\rangle$的运算 $^*$ 在 𝐴 上是可结合的，或者说 $\langle A,*\rangle$ 的运算 $^*$ 在 𝐴 上满足结合律。  
对于任意给定的集合𝐴，由于𝐴上的二元运算${\ast}$满足封闭性，故对于$\forall x,y,z\in A$，有${x\ *}$$y\in A$且$y*z\in A$。因此，$(x*y)*z$和$x*(y*z)$都是有意义的算式，如果$*$满足结合律，则表达式$x*y*z$就有一个确定的计算结果，即有：  
$$
x*y*z=(x*y)*z=x*(y*z)
$$  
如果 $*$ 不满足结合律，则有可能有 $(x*y)*z\neq x*(y*z).$ 。   此时，表达式 $x*y*z$ 的含义就有歧义。因此，只有当某个运算$*$满足结合律时，才能定义其方幂运算。在后续半群与群中元素方幂的的定义中，其元素运算的结合律起着基础性的支撑作用。  
下面考察运算的交换律，首先给出交换律的定义，具体如下：  
【定义11.6】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y\in A$，成立$x*y=y*x$，则称$\langle A,\ *\rangle$的运算$^*$在𝐴上是可交换的，或者说$\langle A,\ *\rangle$的运算$^*$在𝐴上满足交换律。  
交换律表示代数结构载体集合中的任意两个元素在运算时都可以交换次序。 例如，实数加法与乘法运算、矩阵的加法、整数集合上的模余运算、幂集合的交运算与并运算等都满足交换律。 但是，矩阵的乘法运算、关系与函数的复合运算等都不满足交换律。  
【定义11.7】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，若存在某个元素$a\in A$，满足 a$*$$a=a$，则称$a$是$\langle A,\ *\rangle$的一个幂等元。 如果𝐴中的每个元素都是$\langle A,\ *\rangle$的幂等元，则称$\langle A,\ *\rangle$的运算$*$在𝐴上满足幂等律。  
从上述定义可以看出，所谓幂等元，就是该元素与其自身运算之后仍然等于其自身。例如，对于某个幂集合上的交运算和并运算，幂集合中每个元素显然都是幂等元，因此，幂集合上的交运算和并运算均满足幂等性。但是，对于整数上的加法运算，除了整数0 之外，其余整数显然都不是幂等元，因此,整数上的加法运算不满足幂等律。  
【定义11.8】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$：  
（1）若$z*y=z*x$，有$y=x$，则称运算$*$在𝐴上是可左消去的，或者说运算$∗$在𝐴上满足左消去律，并称$\cdot z$是$A$中关于运算$^*$的左可消去元；  
（2）若$y*z=x*z$，有$y=x$，则称运算$^*$在𝐴上是可右消去的，或者说运算$^*$在𝐴上满足右消去律，并称𝑧是$A$中关于运算$^*$的右可消去元。  
（3）若上述两种情况均满足，则称运算$*$在𝐴上满足消去律，并称$z$是𝐴中关于运算$*$的可消去元。  
下面介绍基于两个二元运算的运算律，即分配律和吸收律。首先给出分配律的定义：  
【定义11.9】假设𝐴是任意给定的一个非空集合，$^*$和$\Delta$均为𝐴上的二元运算，在由$𝐴$、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y,z\in A$：  
若有$x*(y\Delta z)=(x*y)\Delta(x*z)$，则称运算$*$对$\Delta$在𝐴上满足左分配律。  
若有$(y\Delta z)*x=(y*x)\Delta(z*x)$，则称运算$*$对$\Delta$在𝐴上满足右分配律。  
若运算$*$对$\Delta$在𝐴上同时满足左右分配律，则称运算$*$对$\Delta$在𝐴上满足分配律。  
例如，实数集合上的普通乘法对加法满足分配律，$M_{n}(R)$上的矩阵乘法对加法满足分配律，幂集$P(B)$上的集合交运算对并运算满足分配律，并且并运算对交运算也满足分配律。  
将上述关于集合的吸收律推广到一般运算对象和一般运算，得到一个新的运算律，即吸收律。其具体定义如下：  
【定义11.10】设𝐴是任意给定的一个非空集合，$*$和$\Delta$均为为𝐴上二元运算，在由𝐴、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y\in A$，成立：  
$$
x*(y\Delta z)=x,\;\;x\Delta(y*z)=x
$$  
则称 $*$ 和 $\Delta$ 在 A  上满足吸收律。",消去律是二元算律的一种
二元算律,包含,分配律,,"现在我们介绍和讨论二元运算律。一共有六个二元运算律，即结合律、交换律、幂等律、消去律、分配律和吸收率。其中前面四个基于单个二元运算，后面两个基于两个二元运算。下面分别讨论这些运算律，首先讨论结合律。  
结合律是大家非常熟悉也是非常重要的一个二元运算律，实数加法与乘法运算、矩阵的加法与乘法运算、关系与函数的复合运算、整数集合上的模余运算、幂集合的交运算与并运算等都满足结合律。结合律的具体定义如下：  
【定义11.5】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由$𝐴$和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$，成立$(x*y)*z=x*(y*z)$，则称$\langle A,*\rangle$的运算 $^*$ 在 𝐴 上是可结合的，或者说 $\langle A,*\rangle$ 的运算 $^*$ 在 𝐴 上满足结合律。  
对于任意给定的集合𝐴，由于𝐴上的二元运算${\ast}$满足封闭性，故对于$\forall x,y,z\in A$，有${x\ *}$$y\in A$且$y*z\in A$。因此，$(x*y)*z$和$x*(y*z)$都是有意义的算式，如果$*$满足结合律，则表达式$x*y*z$就有一个确定的计算结果，即有：  
$$
x*y*z=(x*y)*z=x*(y*z)
$$  
如果 $*$ 不满足结合律，则有可能有 $(x*y)*z\neq x*(y*z).$ 。   此时，表达式 $x*y*z$ 的含义就有歧义。因此，只有当某个运算$*$满足结合律时，才能定义其方幂运算。在后续半群与群中元素方幂的的定义中，其元素运算的结合律起着基础性的支撑作用。  
下面考察运算的交换律，首先给出交换律的定义，具体如下：  
【定义11.6】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y\in A$，成立$x*y=y*x$，则称$\langle A,\ *\rangle$的运算$^*$在𝐴上是可交换的，或者说$\langle A,\ *\rangle$的运算$^*$在𝐴上满足交换律。  
交换律表示代数结构载体集合中的任意两个元素在运算时都可以交换次序。 例如，实数加法与乘法运算、矩阵的加法、整数集合上的模余运算、幂集合的交运算与并运算等都满足交换律。 但是，矩阵的乘法运算、关系与函数的复合运算等都不满足交换律。  
【定义11.7】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，若存在某个元素$a\in A$，满足 a$*$$a=a$，则称$a$是$\langle A,\ *\rangle$的一个幂等元。 如果𝐴中的每个元素都是$\langle A,\ *\rangle$的幂等元，则称$\langle A,\ *\rangle$的运算$*$在𝐴上满足幂等律。  
从上述定义可以看出，所谓幂等元，就是该元素与其自身运算之后仍然等于其自身。例如，对于某个幂集合上的交运算和并运算，幂集合中每个元素显然都是幂等元，因此，幂集合上的交运算和并运算均满足幂等性。但是，对于整数上的加法运算，除了整数0 之外，其余整数显然都不是幂等元，因此,整数上的加法运算不满足幂等律。  
【定义11.8】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$：  
（1）若$z*y=z*x$，有$y=x$，则称运算$*$在𝐴上是可左消去的，或者说运算$∗$在𝐴上满足左消去律，并称$\cdot z$是$A$中关于运算$^*$的左可消去元；  
（2）若$y*z=x*z$，有$y=x$，则称运算$^*$在𝐴上是可右消去的，或者说运算$^*$在𝐴上满足右消去律，并称𝑧是$A$中关于运算$^*$的右可消去元。  
（3）若上述两种情况均满足，则称运算$*$在𝐴上满足消去律，并称$z$是𝐴中关于运算$*$的可消去元。  
下面介绍基于两个二元运算的运算律，即分配律和吸收律。首先给出分配律的定义：  
【定义11.9】假设𝐴是任意给定的一个非空集合，$^*$和$\Delta$均为𝐴上的二元运算，在由$𝐴$、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y,z\in A$：  
若有$x*(y\Delta z)=(x*y)\Delta(x*z)$，则称运算$*$对$\Delta$在𝐴上满足左分配律。  
若有$(y\Delta z)*x=(y*x)\Delta(z*x)$，则称运算$*$对$\Delta$在𝐴上满足右分配律。  
若运算$*$对$\Delta$在𝐴上同时满足左右分配律，则称运算$*$对$\Delta$在𝐴上满足分配律。  
例如，实数集合上的普通乘法对加法满足分配律，$M_{n}(R)$上的矩阵乘法对加法满足分配律，幂集$P(B)$上的集合交运算对并运算满足分配律，并且并运算对交运算也满足分配律。  
将上述关于集合的吸收律推广到一般运算对象和一般运算，得到一个新的运算律，即吸收律。其具体定义如下：  
【定义11.10】设𝐴是任意给定的一个非空集合，$*$和$\Delta$均为为𝐴上二元运算，在由𝐴、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y\in A$，成立：  
$$
x*(y\Delta z)=x,\;\;x\Delta(y*z)=x
$$  
则称 $*$ 和 $\Delta$ 在 A  上满足吸收律。",分配律是二元算律的一种
二元算律,包含,吸收律,,"现在我们介绍和讨论二元运算律。一共有六个二元运算律，即结合律、交换律、幂等律、消去律、分配律和吸收率。其中前面四个基于单个二元运算，后面两个基于两个二元运算。下面分别讨论这些运算律，首先讨论结合律。  
结合律是大家非常熟悉也是非常重要的一个二元运算律，实数加法与乘法运算、矩阵的加法与乘法运算、关系与函数的复合运算、整数集合上的模余运算、幂集合的交运算与并运算等都满足结合律。结合律的具体定义如下：  
【定义11.5】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由$𝐴$和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$，成立$(x*y)*z=x*(y*z)$，则称$\langle A,*\rangle$的运算 $^*$ 在 𝐴 上是可结合的，或者说 $\langle A,*\rangle$ 的运算 $^*$ 在 𝐴 上满足结合律。  
对于任意给定的集合𝐴，由于𝐴上的二元运算${\ast}$满足封闭性，故对于$\forall x,y,z\in A$，有${x\ *}$$y\in A$且$y*z\in A$。因此，$(x*y)*z$和$x*(y*z)$都是有意义的算式，如果$*$满足结合律，则表达式$x*y*z$就有一个确定的计算结果，即有：  
$$
x*y*z=(x*y)*z=x*(y*z)
$$  
如果 $*$ 不满足结合律，则有可能有 $(x*y)*z\neq x*(y*z).$ 。   此时，表达式 $x*y*z$ 的含义就有歧义。因此，只有当某个运算$*$满足结合律时，才能定义其方幂运算。在后续半群与群中元素方幂的的定义中，其元素运算的结合律起着基础性的支撑作用。  
下面考察运算的交换律，首先给出交换律的定义，具体如下：  
【定义11.6】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y\in A$，成立$x*y=y*x$，则称$\langle A,\ *\rangle$的运算$^*$在𝐴上是可交换的，或者说$\langle A,\ *\rangle$的运算$^*$在𝐴上满足交换律。  
交换律表示代数结构载体集合中的任意两个元素在运算时都可以交换次序。 例如，实数加法与乘法运算、矩阵的加法、整数集合上的模余运算、幂集合的交运算与并运算等都满足交换律。 但是，矩阵的乘法运算、关系与函数的复合运算等都不满足交换律。  
【定义11.7】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，若存在某个元素$a\in A$，满足 a$*$$a=a$，则称$a$是$\langle A,\ *\rangle$的一个幂等元。 如果𝐴中的每个元素都是$\langle A,\ *\rangle$的幂等元，则称$\langle A,\ *\rangle$的运算$*$在𝐴上满足幂等律。  
从上述定义可以看出，所谓幂等元，就是该元素与其自身运算之后仍然等于其自身。例如，对于某个幂集合上的交运算和并运算，幂集合中每个元素显然都是幂等元，因此，幂集合上的交运算和并运算均满足幂等性。但是，对于整数上的加法运算，除了整数0 之外，其余整数显然都不是幂等元，因此,整数上的加法运算不满足幂等律。  
【定义11.8】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$：  
（1）若$z*y=z*x$，有$y=x$，则称运算$*$在𝐴上是可左消去的，或者说运算$∗$在𝐴上满足左消去律，并称$\cdot z$是$A$中关于运算$^*$的左可消去元；  
（2）若$y*z=x*z$，有$y=x$，则称运算$^*$在𝐴上是可右消去的，或者说运算$^*$在𝐴上满足右消去律，并称𝑧是$A$中关于运算$^*$的右可消去元。  
（3）若上述两种情况均满足，则称运算$*$在𝐴上满足消去律，并称$z$是𝐴中关于运算$*$的可消去元。  
下面介绍基于两个二元运算的运算律，即分配律和吸收律。首先给出分配律的定义：  
【定义11.9】假设𝐴是任意给定的一个非空集合，$^*$和$\Delta$均为𝐴上的二元运算，在由$𝐴$、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y,z\in A$：  
若有$x*(y\Delta z)=(x*y)\Delta(x*z)$，则称运算$*$对$\Delta$在𝐴上满足左分配律。  
若有$(y\Delta z)*x=(y*x)\Delta(z*x)$，则称运算$*$对$\Delta$在𝐴上满足右分配律。  
若运算$*$对$\Delta$在𝐴上同时满足左右分配律，则称运算$*$对$\Delta$在𝐴上满足分配律。  
例如，实数集合上的普通乘法对加法满足分配律，$M_{n}(R)$上的矩阵乘法对加法满足分配律，幂集$P(B)$上的集合交运算对并运算满足分配律，并且并运算对交运算也满足分配律。  
将上述关于集合的吸收律推广到一般运算对象和一般运算，得到一个新的运算律，即吸收律。其具体定义如下：  
【定义11.10】设𝐴是任意给定的一个非空集合，$*$和$\Delta$均为为𝐴上二元运算，在由𝐴、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y\in A$，成立：  
$$
x*(y\Delta z)=x,\;\;x\Delta(y*z)=x
$$  
则称 $*$ 和 $\Delta$ 在 A  上满足吸收律。",吸收律是二元算律的一种
结合律,并列,交换律,,"现在我们介绍和讨论二元运算律。一共有六个二元运算律，即结合律、交换律、幂等律、消去律、分配律和吸收率。其中前面四个基于单个二元运算，后面两个基于两个二元运算。下面分别讨论这些运算律，首先讨论结合律。  
结合律是大家非常熟悉也是非常重要的一个二元运算律，实数加法与乘法运算、矩阵的加法与乘法运算、关系与函数的复合运算、整数集合上的模余运算、幂集合的交运算与并运算等都满足结合律。结合律的具体定义如下：  
【定义11.5】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由$𝐴$和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$，成立$(x*y)*z=x*(y*z)$，则称$\langle A,*\rangle$的运算 $^*$ 在 𝐴 上是可结合的，或者说 $\langle A,*\rangle$ 的运算 $^*$ 在 𝐴 上满足结合律。  
对于任意给定的集合𝐴，由于𝐴上的二元运算${\ast}$满足封闭性，故对于$\forall x,y,z\in A$，有${x\ *}$$y\in A$且$y*z\in A$。因此，$(x*y)*z$和$x*(y*z)$都是有意义的算式，如果$*$满足结合律，则表达式$x*y*z$就有一个确定的计算结果，即有：  
$$
x*y*z=(x*y)*z=x*(y*z)
$$  
如果 $*$ 不满足结合律，则有可能有 $(x*y)*z\neq x*(y*z).$ 。   此时，表达式 $x*y*z$ 的含义就有歧义。因此，只有当某个运算$*$满足结合律时，才能定义其方幂运算。在后续半群与群中元素方幂的的定义中，其元素运算的结合律起着基础性的支撑作用。  
下面考察运算的交换律，首先给出交换律的定义，具体如下：  
【定义11.6】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y\in A$，成立$x*y=y*x$，则称$\langle A,\ *\rangle$的运算$^*$在𝐴上是可交换的，或者说$\langle A,\ *\rangle$的运算$^*$在𝐴上满足交换律。  
交换律表示代数结构载体集合中的任意两个元素在运算时都可以交换次序。 例如，实数加法与乘法运算、矩阵的加法、整数集合上的模余运算、幂集合的交运算与并运算等都满足交换律。 但是，矩阵的乘法运算、关系与函数的复合运算等都不满足交换律。  
【定义11.7】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，若存在某个元素$a\in A$，满足 a$*$$a=a$，则称$a$是$\langle A,\ *\rangle$的一个幂等元。 如果𝐴中的每个元素都是$\langle A,\ *\rangle$的幂等元，则称$\langle A,\ *\rangle$的运算$*$在𝐴上满足幂等律。  
从上述定义可以看出，所谓幂等元，就是该元素与其自身运算之后仍然等于其自身。例如，对于某个幂集合上的交运算和并运算，幂集合中每个元素显然都是幂等元，因此，幂集合上的交运算和并运算均满足幂等性。但是，对于整数上的加法运算，除了整数0 之外，其余整数显然都不是幂等元，因此,整数上的加法运算不满足幂等律。  
【定义11.8】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$：  
（1）若$z*y=z*x$，有$y=x$，则称运算$*$在𝐴上是可左消去的，或者说运算$∗$在𝐴上满足左消去律，并称$\cdot z$是$A$中关于运算$^*$的左可消去元；  
（2）若$y*z=x*z$，有$y=x$，则称运算$^*$在𝐴上是可右消去的，或者说运算$^*$在𝐴上满足右消去律，并称𝑧是$A$中关于运算$^*$的右可消去元。  
（3）若上述两种情况均满足，则称运算$*$在𝐴上满足消去律，并称$z$是𝐴中关于运算$*$的可消去元。  
下面介绍基于两个二元运算的运算律，即分配律和吸收律。首先给出分配律的定义：  
【定义11.9】假设𝐴是任意给定的一个非空集合，$^*$和$\Delta$均为𝐴上的二元运算，在由$𝐴$、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y,z\in A$：  
若有$x*(y\Delta z)=(x*y)\Delta(x*z)$，则称运算$*$对$\Delta$在𝐴上满足左分配律。  
若有$(y\Delta z)*x=(y*x)\Delta(z*x)$，则称运算$*$对$\Delta$在𝐴上满足右分配律。  
若运算$*$对$\Delta$在𝐴上同时满足左右分配律，则称运算$*$对$\Delta$在𝐴上满足分配律。  
例如，实数集合上的普通乘法对加法满足分配律，$M_{n}(R)$上的矩阵乘法对加法满足分配律，幂集$P(B)$上的集合交运算对并运算满足分配律，并且并运算对交运算也满足分配律。  
将上述关于集合的吸收律推广到一般运算对象和一般运算，得到一个新的运算律，即吸收律。其具体定义如下：  
【定义11.10】设𝐴是任意给定的一个非空集合，$*$和$\Delta$均为为𝐴上二元运算，在由𝐴、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y\in A$，成立：  
$$
x*(y\Delta z)=x,\;\;x\Delta(y*z)=x
$$  
则称 $*$ 和 $\Delta$ 在 A  上满足吸收律。",结合律和交换律都是基于单个二元运算的二元算律
结合律,并列,幂等律,,"现在我们介绍和讨论二元运算律。一共有六个二元运算律，即结合律、交换律、幂等律、消去律、分配律和吸收率。其中前面四个基于单个二元运算，后面两个基于两个二元运算。下面分别讨论这些运算律，首先讨论结合律。  
结合律是大家非常熟悉也是非常重要的一个二元运算律，实数加法与乘法运算、矩阵的加法与乘法运算、关系与函数的复合运算、整数集合上的模余运算、幂集合的交运算与并运算等都满足结合律。结合律的具体定义如下：  
【定义11.5】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由$𝐴$和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$，成立$(x*y)*z=x*(y*z)$，则称$\langle A,*\rangle$的运算 $^*$ 在 𝐴 上是可结合的，或者说 $\langle A,*\rangle$ 的运算 $^*$ 在 𝐴 上满足结合律。  
对于任意给定的集合𝐴，由于𝐴上的二元运算${\ast}$满足封闭性，故对于$\forall x,y,z\in A$，有${x\ *}$$y\in A$且$y*z\in A$。因此，$(x*y)*z$和$x*(y*z)$都是有意义的算式，如果$*$满足结合律，则表达式$x*y*z$就有一个确定的计算结果，即有：  
$$
x*y*z=(x*y)*z=x*(y*z)
$$  
如果 $*$ 不满足结合律，则有可能有 $(x*y)*z\neq x*(y*z).$ 。   此时，表达式 $x*y*z$ 的含义就有歧义。因此，只有当某个运算$*$满足结合律时，才能定义其方幂运算。在后续半群与群中元素方幂的的定义中，其元素运算的结合律起着基础性的支撑作用。  
下面考察运算的交换律，首先给出交换律的定义，具体如下：  
【定义11.6】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y\in A$，成立$x*y=y*x$，则称$\langle A,\ *\rangle$的运算$^*$在𝐴上是可交换的，或者说$\langle A,\ *\rangle$的运算$^*$在𝐴上满足交换律。  
交换律表示代数结构载体集合中的任意两个元素在运算时都可以交换次序。 例如，实数加法与乘法运算、矩阵的加法、整数集合上的模余运算、幂集合的交运算与并运算等都满足交换律。 但是，矩阵的乘法运算、关系与函数的复合运算等都不满足交换律。  
【定义11.7】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，若存在某个元素$a\in A$，满足 a$*$$a=a$，则称$a$是$\langle A,\ *\rangle$的一个幂等元。 如果𝐴中的每个元素都是$\langle A,\ *\rangle$的幂等元，则称$\langle A,\ *\rangle$的运算$*$在𝐴上满足幂等律。  
从上述定义可以看出，所谓幂等元，就是该元素与其自身运算之后仍然等于其自身。例如，对于某个幂集合上的交运算和并运算，幂集合中每个元素显然都是幂等元，因此，幂集合上的交运算和并运算均满足幂等性。但是，对于整数上的加法运算，除了整数0 之外，其余整数显然都不是幂等元，因此,整数上的加法运算不满足幂等律。  
【定义11.8】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$：  
（1）若$z*y=z*x$，有$y=x$，则称运算$*$在𝐴上是可左消去的，或者说运算$∗$在𝐴上满足左消去律，并称$\cdot z$是$A$中关于运算$^*$的左可消去元；  
（2）若$y*z=x*z$，有$y=x$，则称运算$^*$在𝐴上是可右消去的，或者说运算$^*$在𝐴上满足右消去律，并称𝑧是$A$中关于运算$^*$的右可消去元。  
（3）若上述两种情况均满足，则称运算$*$在𝐴上满足消去律，并称$z$是𝐴中关于运算$*$的可消去元。  
下面介绍基于两个二元运算的运算律，即分配律和吸收律。首先给出分配律的定义：  
【定义11.9】假设𝐴是任意给定的一个非空集合，$^*$和$\Delta$均为𝐴上的二元运算，在由$𝐴$、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y,z\in A$：  
若有$x*(y\Delta z)=(x*y)\Delta(x*z)$，则称运算$*$对$\Delta$在𝐴上满足左分配律。  
若有$(y\Delta z)*x=(y*x)\Delta(z*x)$，则称运算$*$对$\Delta$在𝐴上满足右分配律。  
若运算$*$对$\Delta$在𝐴上同时满足左右分配律，则称运算$*$对$\Delta$在𝐴上满足分配律。  
例如，实数集合上的普通乘法对加法满足分配律，$M_{n}(R)$上的矩阵乘法对加法满足分配律，幂集$P(B)$上的集合交运算对并运算满足分配律，并且并运算对交运算也满足分配律。  
将上述关于集合的吸收律推广到一般运算对象和一般运算，得到一个新的运算律，即吸收律。其具体定义如下：  
【定义11.10】设𝐴是任意给定的一个非空集合，$*$和$\Delta$均为为𝐴上二元运算，在由𝐴、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y\in A$，成立：  
$$
x*(y\Delta z)=x,\;\;x\Delta(y*z)=x
$$  
则称 $*$ 和 $\Delta$ 在 A  上满足吸收律。",结合律和幂等律都是基于单个二元运算的二元算律
结合律,并列,消去律,,"现在我们介绍和讨论二元运算律。一共有六个二元运算律，即结合律、交换律、幂等律、消去律、分配律和吸收率。其中前面四个基于单个二元运算，后面两个基于两个二元运算。下面分别讨论这些运算律，首先讨论结合律。  
结合律是大家非常熟悉也是非常重要的一个二元运算律，实数加法与乘法运算、矩阵的加法与乘法运算、关系与函数的复合运算、整数集合上的模余运算、幂集合的交运算与并运算等都满足结合律。结合律的具体定义如下：  
【定义11.5】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由$𝐴$和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$，成立$(x*y)*z=x*(y*z)$，则称$\langle A,*\rangle$的运算 $^*$ 在 𝐴 上是可结合的，或者说 $\langle A,*\rangle$ 的运算 $^*$ 在 𝐴 上满足结合律。  
对于任意给定的集合𝐴，由于𝐴上的二元运算${\ast}$满足封闭性，故对于$\forall x,y,z\in A$，有${x\ *}$$y\in A$且$y*z\in A$。因此，$(x*y)*z$和$x*(y*z)$都是有意义的算式，如果$*$满足结合律，则表达式$x*y*z$就有一个确定的计算结果，即有：  
$$
x*y*z=(x*y)*z=x*(y*z)
$$  
如果 $*$ 不满足结合律，则有可能有 $(x*y)*z\neq x*(y*z).$ 。   此时，表达式 $x*y*z$ 的含义就有歧义。因此，只有当某个运算$*$满足结合律时，才能定义其方幂运算。在后续半群与群中元素方幂的的定义中，其元素运算的结合律起着基础性的支撑作用。  
下面考察运算的交换律，首先给出交换律的定义，具体如下：  
【定义11.6】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y\in A$，成立$x*y=y*x$，则称$\langle A,\ *\rangle$的运算$^*$在𝐴上是可交换的，或者说$\langle A,\ *\rangle$的运算$^*$在𝐴上满足交换律。  
交换律表示代数结构载体集合中的任意两个元素在运算时都可以交换次序。 例如，实数加法与乘法运算、矩阵的加法、整数集合上的模余运算、幂集合的交运算与并运算等都满足交换律。 但是，矩阵的乘法运算、关系与函数的复合运算等都不满足交换律。  
【定义11.7】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，若存在某个元素$a\in A$，满足 a$*$$a=a$，则称$a$是$\langle A,\ *\rangle$的一个幂等元。 如果𝐴中的每个元素都是$\langle A,\ *\rangle$的幂等元，则称$\langle A,\ *\rangle$的运算$*$在𝐴上满足幂等律。  
从上述定义可以看出，所谓幂等元，就是该元素与其自身运算之后仍然等于其自身。例如，对于某个幂集合上的交运算和并运算，幂集合中每个元素显然都是幂等元，因此，幂集合上的交运算和并运算均满足幂等性。但是，对于整数上的加法运算，除了整数0 之外，其余整数显然都不是幂等元，因此,整数上的加法运算不满足幂等律。  
【定义11.8】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$：  
（1）若$z*y=z*x$，有$y=x$，则称运算$*$在𝐴上是可左消去的，或者说运算$∗$在𝐴上满足左消去律，并称$\cdot z$是$A$中关于运算$^*$的左可消去元；  
（2）若$y*z=x*z$，有$y=x$，则称运算$^*$在𝐴上是可右消去的，或者说运算$^*$在𝐴上满足右消去律，并称𝑧是$A$中关于运算$^*$的右可消去元。  
（3）若上述两种情况均满足，则称运算$*$在𝐴上满足消去律，并称$z$是𝐴中关于运算$*$的可消去元。  
下面介绍基于两个二元运算的运算律，即分配律和吸收律。首先给出分配律的定义：  
【定义11.9】假设𝐴是任意给定的一个非空集合，$^*$和$\Delta$均为𝐴上的二元运算，在由$𝐴$、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y,z\in A$：  
若有$x*(y\Delta z)=(x*y)\Delta(x*z)$，则称运算$*$对$\Delta$在𝐴上满足左分配律。  
若有$(y\Delta z)*x=(y*x)\Delta(z*x)$，则称运算$*$对$\Delta$在𝐴上满足右分配律。  
若运算$*$对$\Delta$在𝐴上同时满足左右分配律，则称运算$*$对$\Delta$在𝐴上满足分配律。  
例如，实数集合上的普通乘法对加法满足分配律，$M_{n}(R)$上的矩阵乘法对加法满足分配律，幂集$P(B)$上的集合交运算对并运算满足分配律，并且并运算对交运算也满足分配律。  
将上述关于集合的吸收律推广到一般运算对象和一般运算，得到一个新的运算律，即吸收律。其具体定义如下：  
【定义11.10】设𝐴是任意给定的一个非空集合，$*$和$\Delta$均为为𝐴上二元运算，在由𝐴、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y\in A$，成立：  
$$
x*(y\Delta z)=x,\;\;x\Delta(y*z)=x
$$  
则称 $*$ 和 $\Delta$ 在 A  上满足吸收律。",结合律和消去律都是基于单个二元运算的二元算律
交换律,并列,幂等律,,"现在我们介绍和讨论二元运算律。一共有六个二元运算律，即结合律、交换律、幂等律、消去律、分配律和吸收率。其中前面四个基于单个二元运算，后面两个基于两个二元运算。下面分别讨论这些运算律，首先讨论结合律。  
结合律是大家非常熟悉也是非常重要的一个二元运算律，实数加法与乘法运算、矩阵的加法与乘法运算、关系与函数的复合运算、整数集合上的模余运算、幂集合的交运算与并运算等都满足结合律。结合律的具体定义如下：  
【定义11.5】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由$𝐴$和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$，成立$(x*y)*z=x*(y*z)$，则称$\langle A,*\rangle$的运算 $^*$ 在 𝐴 上是可结合的，或者说 $\langle A,*\rangle$ 的运算 $^*$ 在 𝐴 上满足结合律。  
对于任意给定的集合𝐴，由于𝐴上的二元运算${\ast}$满足封闭性，故对于$\forall x,y,z\in A$，有${x\ *}$$y\in A$且$y*z\in A$。因此，$(x*y)*z$和$x*(y*z)$都是有意义的算式，如果$*$满足结合律，则表达式$x*y*z$就有一个确定的计算结果，即有：  
$$
x*y*z=(x*y)*z=x*(y*z)
$$  
如果 $*$ 不满足结合律，则有可能有 $(x*y)*z\neq x*(y*z).$ 。   此时，表达式 $x*y*z$ 的含义就有歧义。因此，只有当某个运算$*$满足结合律时，才能定义其方幂运算。在后续半群与群中元素方幂的的定义中，其元素运算的结合律起着基础性的支撑作用。  
下面考察运算的交换律，首先给出交换律的定义，具体如下：  
【定义11.6】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y\in A$，成立$x*y=y*x$，则称$\langle A,\ *\rangle$的运算$^*$在𝐴上是可交换的，或者说$\langle A,\ *\rangle$的运算$^*$在𝐴上满足交换律。  
交换律表示代数结构载体集合中的任意两个元素在运算时都可以交换次序。 例如，实数加法与乘法运算、矩阵的加法、整数集合上的模余运算、幂集合的交运算与并运算等都满足交换律。 但是，矩阵的乘法运算、关系与函数的复合运算等都不满足交换律。  
【定义11.7】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，若存在某个元素$a\in A$，满足 a$*$$a=a$，则称$a$是$\langle A,\ *\rangle$的一个幂等元。 如果𝐴中的每个元素都是$\langle A,\ *\rangle$的幂等元，则称$\langle A,\ *\rangle$的运算$*$在𝐴上满足幂等律。  
从上述定义可以看出，所谓幂等元，就是该元素与其自身运算之后仍然等于其自身。例如，对于某个幂集合上的交运算和并运算，幂集合中每个元素显然都是幂等元，因此，幂集合上的交运算和并运算均满足幂等性。但是，对于整数上的加法运算，除了整数0 之外，其余整数显然都不是幂等元，因此,整数上的加法运算不满足幂等律。  
【定义11.8】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$：  
（1）若$z*y=z*x$，有$y=x$，则称运算$*$在𝐴上是可左消去的，或者说运算$∗$在𝐴上满足左消去律，并称$\cdot z$是$A$中关于运算$^*$的左可消去元；  
（2）若$y*z=x*z$，有$y=x$，则称运算$^*$在𝐴上是可右消去的，或者说运算$^*$在𝐴上满足右消去律，并称𝑧是$A$中关于运算$^*$的右可消去元。  
（3）若上述两种情况均满足，则称运算$*$在𝐴上满足消去律，并称$z$是𝐴中关于运算$*$的可消去元。  
下面介绍基于两个二元运算的运算律，即分配律和吸收律。首先给出分配律的定义：  
【定义11.9】假设𝐴是任意给定的一个非空集合，$^*$和$\Delta$均为𝐴上的二元运算，在由$𝐴$、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y,z\in A$：  
若有$x*(y\Delta z)=(x*y)\Delta(x*z)$，则称运算$*$对$\Delta$在𝐴上满足左分配律。  
若有$(y\Delta z)*x=(y*x)\Delta(z*x)$，则称运算$*$对$\Delta$在𝐴上满足右分配律。  
若运算$*$对$\Delta$在𝐴上同时满足左右分配律，则称运算$*$对$\Delta$在𝐴上满足分配律。  
例如，实数集合上的普通乘法对加法满足分配律，$M_{n}(R)$上的矩阵乘法对加法满足分配律，幂集$P(B)$上的集合交运算对并运算满足分配律，并且并运算对交运算也满足分配律。  
将上述关于集合的吸收律推广到一般运算对象和一般运算，得到一个新的运算律，即吸收律。其具体定义如下：  
【定义11.10】设𝐴是任意给定的一个非空集合，$*$和$\Delta$均为为𝐴上二元运算，在由𝐴、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y\in A$，成立：  
$$
x*(y\Delta z)=x,\;\;x\Delta(y*z)=x
$$  
则称 $*$ 和 $\Delta$ 在 A  上满足吸收律。",交换律和幂等律都是基于单个二元运算的二元算律
交换律,并列,消去律,,"现在我们介绍和讨论二元运算律。一共有六个二元运算律，即结合律、交换律、幂等律、消去律、分配律和吸收率。其中前面四个基于单个二元运算，后面两个基于两个二元运算。下面分别讨论这些运算律，首先讨论结合律。  
结合律是大家非常熟悉也是非常重要的一个二元运算律，实数加法与乘法运算、矩阵的加法与乘法运算、关系与函数的复合运算、整数集合上的模余运算、幂集合的交运算与并运算等都满足结合律。结合律的具体定义如下：  
【定义11.5】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由$𝐴$和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$，成立$(x*y)*z=x*(y*z)$，则称$\langle A,*\rangle$的运算 $^*$ 在 𝐴 上是可结合的，或者说 $\langle A,*\rangle$ 的运算 $^*$ 在 𝐴 上满足结合律。  
对于任意给定的集合𝐴，由于𝐴上的二元运算${\ast}$满足封闭性，故对于$\forall x,y,z\in A$，有${x\ *}$$y\in A$且$y*z\in A$。因此，$(x*y)*z$和$x*(y*z)$都是有意义的算式，如果$*$满足结合律，则表达式$x*y*z$就有一个确定的计算结果，即有：  
$$
x*y*z=(x*y)*z=x*(y*z)
$$  
如果 $*$ 不满足结合律，则有可能有 $(x*y)*z\neq x*(y*z).$ 。   此时，表达式 $x*y*z$ 的含义就有歧义。因此，只有当某个运算$*$满足结合律时，才能定义其方幂运算。在后续半群与群中元素方幂的的定义中，其元素运算的结合律起着基础性的支撑作用。  
下面考察运算的交换律，首先给出交换律的定义，具体如下：  
【定义11.6】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y\in A$，成立$x*y=y*x$，则称$\langle A,\ *\rangle$的运算$^*$在𝐴上是可交换的，或者说$\langle A,\ *\rangle$的运算$^*$在𝐴上满足交换律。  
交换律表示代数结构载体集合中的任意两个元素在运算时都可以交换次序。 例如，实数加法与乘法运算、矩阵的加法、整数集合上的模余运算、幂集合的交运算与并运算等都满足交换律。 但是，矩阵的乘法运算、关系与函数的复合运算等都不满足交换律。  
【定义11.7】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，若存在某个元素$a\in A$，满足 a$*$$a=a$，则称$a$是$\langle A,\ *\rangle$的一个幂等元。 如果𝐴中的每个元素都是$\langle A,\ *\rangle$的幂等元，则称$\langle A,\ *\rangle$的运算$*$在𝐴上满足幂等律。  
从上述定义可以看出，所谓幂等元，就是该元素与其自身运算之后仍然等于其自身。例如，对于某个幂集合上的交运算和并运算，幂集合中每个元素显然都是幂等元，因此，幂集合上的交运算和并运算均满足幂等性。但是，对于整数上的加法运算，除了整数0 之外，其余整数显然都不是幂等元，因此,整数上的加法运算不满足幂等律。  
【定义11.8】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$：  
（1）若$z*y=z*x$，有$y=x$，则称运算$*$在𝐴上是可左消去的，或者说运算$∗$在𝐴上满足左消去律，并称$\cdot z$是$A$中关于运算$^*$的左可消去元；  
（2）若$y*z=x*z$，有$y=x$，则称运算$^*$在𝐴上是可右消去的，或者说运算$^*$在𝐴上满足右消去律，并称𝑧是$A$中关于运算$^*$的右可消去元。  
（3）若上述两种情况均满足，则称运算$*$在𝐴上满足消去律，并称$z$是𝐴中关于运算$*$的可消去元。  
下面介绍基于两个二元运算的运算律，即分配律和吸收律。首先给出分配律的定义：  
【定义11.9】假设𝐴是任意给定的一个非空集合，$^*$和$\Delta$均为𝐴上的二元运算，在由$𝐴$、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y,z\in A$：  
若有$x*(y\Delta z)=(x*y)\Delta(x*z)$，则称运算$*$对$\Delta$在𝐴上满足左分配律。  
若有$(y\Delta z)*x=(y*x)\Delta(z*x)$，则称运算$*$对$\Delta$在𝐴上满足右分配律。  
若运算$*$对$\Delta$在𝐴上同时满足左右分配律，则称运算$*$对$\Delta$在𝐴上满足分配律。  
例如，实数集合上的普通乘法对加法满足分配律，$M_{n}(R)$上的矩阵乘法对加法满足分配律，幂集$P(B)$上的集合交运算对并运算满足分配律，并且并运算对交运算也满足分配律。  
将上述关于集合的吸收律推广到一般运算对象和一般运算，得到一个新的运算律，即吸收律。其具体定义如下：  
【定义11.10】设𝐴是任意给定的一个非空集合，$*$和$\Delta$均为为𝐴上二元运算，在由𝐴、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y\in A$，成立：  
$$
x*(y\Delta z)=x,\;\;x\Delta(y*z)=x
$$  
则称 $*$ 和 $\Delta$ 在 A  上满足吸收律。",交换律和消去律都是基于单个二元运算的二元算律
幂等律,并列,消去律,,"现在我们介绍和讨论二元运算律。一共有六个二元运算律，即结合律、交换律、幂等律、消去律、分配律和吸收率。其中前面四个基于单个二元运算，后面两个基于两个二元运算。下面分别讨论这些运算律，首先讨论结合律。  
结合律是大家非常熟悉也是非常重要的一个二元运算律，实数加法与乘法运算、矩阵的加法与乘法运算、关系与函数的复合运算、整数集合上的模余运算、幂集合的交运算与并运算等都满足结合律。结合律的具体定义如下：  
【定义11.5】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由$𝐴$和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$，成立$(x*y)*z=x*(y*z)$，则称$\langle A,*\rangle$的运算 $^*$ 在 𝐴 上是可结合的，或者说 $\langle A,*\rangle$ 的运算 $^*$ 在 𝐴 上满足结合律。  
对于任意给定的集合𝐴，由于𝐴上的二元运算${\ast}$满足封闭性，故对于$\forall x,y,z\in A$，有${x\ *}$$y\in A$且$y*z\in A$。因此，$(x*y)*z$和$x*(y*z)$都是有意义的算式，如果$*$满足结合律，则表达式$x*y*z$就有一个确定的计算结果，即有：  
$$
x*y*z=(x*y)*z=x*(y*z)
$$  
如果 $*$ 不满足结合律，则有可能有 $(x*y)*z\neq x*(y*z).$ 。   此时，表达式 $x*y*z$ 的含义就有歧义。因此，只有当某个运算$*$满足结合律时，才能定义其方幂运算。在后续半群与群中元素方幂的的定义中，其元素运算的结合律起着基础性的支撑作用。  
下面考察运算的交换律，首先给出交换律的定义，具体如下：  
【定义11.6】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y\in A$，成立$x*y=y*x$，则称$\langle A,\ *\rangle$的运算$^*$在𝐴上是可交换的，或者说$\langle A,\ *\rangle$的运算$^*$在𝐴上满足交换律。  
交换律表示代数结构载体集合中的任意两个元素在运算时都可以交换次序。 例如，实数加法与乘法运算、矩阵的加法、整数集合上的模余运算、幂集合的交运算与并运算等都满足交换律。 但是，矩阵的乘法运算、关系与函数的复合运算等都不满足交换律。  
【定义11.7】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，若存在某个元素$a\in A$，满足 a$*$$a=a$，则称$a$是$\langle A,\ *\rangle$的一个幂等元。 如果𝐴中的每个元素都是$\langle A,\ *\rangle$的幂等元，则称$\langle A,\ *\rangle$的运算$*$在𝐴上满足幂等律。  
从上述定义可以看出，所谓幂等元，就是该元素与其自身运算之后仍然等于其自身。例如，对于某个幂集合上的交运算和并运算，幂集合中每个元素显然都是幂等元，因此，幂集合上的交运算和并运算均满足幂等性。但是，对于整数上的加法运算，除了整数0 之外，其余整数显然都不是幂等元，因此,整数上的加法运算不满足幂等律。  
【定义11.8】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$：  
（1）若$z*y=z*x$，有$y=x$，则称运算$*$在𝐴上是可左消去的，或者说运算$∗$在𝐴上满足左消去律，并称$\cdot z$是$A$中关于运算$^*$的左可消去元；  
（2）若$y*z=x*z$，有$y=x$，则称运算$^*$在𝐴上是可右消去的，或者说运算$^*$在𝐴上满足右消去律，并称𝑧是$A$中关于运算$^*$的右可消去元。  
（3）若上述两种情况均满足，则称运算$*$在𝐴上满足消去律，并称$z$是𝐴中关于运算$*$的可消去元。  
下面介绍基于两个二元运算的运算律，即分配律和吸收律。首先给出分配律的定义：  
【定义11.9】假设𝐴是任意给定的一个非空集合，$^*$和$\Delta$均为𝐴上的二元运算，在由$𝐴$、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y,z\in A$：  
若有$x*(y\Delta z)=(x*y)\Delta(x*z)$，则称运算$*$对$\Delta$在𝐴上满足左分配律。  
若有$(y\Delta z)*x=(y*x)\Delta(z*x)$，则称运算$*$对$\Delta$在𝐴上满足右分配律。  
若运算$*$对$\Delta$在𝐴上同时满足左右分配律，则称运算$*$对$\Delta$在𝐴上满足分配律。  
例如，实数集合上的普通乘法对加法满足分配律，$M_{n}(R)$上的矩阵乘法对加法满足分配律，幂集$P(B)$上的集合交运算对并运算满足分配律，并且并运算对交运算也满足分配律。  
将上述关于集合的吸收律推广到一般运算对象和一般运算，得到一个新的运算律，即吸收律。其具体定义如下：  
【定义11.10】设𝐴是任意给定的一个非空集合，$*$和$\Delta$均为为𝐴上二元运算，在由𝐴、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y\in A$，成立：  
$$
x*(y\Delta z)=x,\;\;x\Delta(y*z)=x
$$  
则称 $*$ 和 $\Delta$ 在 A  上满足吸收律。",幂等律和消去律都是基于单个二元运算的二元算律
分配律,并列,吸收律,,"现在我们介绍和讨论二元运算律。一共有六个二元运算律，即结合律、交换律、幂等律、消去律、分配律和吸收率。其中前面四个基于单个二元运算，后面两个基于两个二元运算。下面分别讨论这些运算律，首先讨论结合律。  
结合律是大家非常熟悉也是非常重要的一个二元运算律，实数加法与乘法运算、矩阵的加法与乘法运算、关系与函数的复合运算、整数集合上的模余运算、幂集合的交运算与并运算等都满足结合律。结合律的具体定义如下：  
【定义11.5】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由$𝐴$和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$，成立$(x*y)*z=x*(y*z)$，则称$\langle A,*\rangle$的运算 $^*$ 在 𝐴 上是可结合的，或者说 $\langle A,*\rangle$ 的运算 $^*$ 在 𝐴 上满足结合律。  
对于任意给定的集合𝐴，由于𝐴上的二元运算${\ast}$满足封闭性，故对于$\forall x,y,z\in A$，有${x\ *}$$y\in A$且$y*z\in A$。因此，$(x*y)*z$和$x*(y*z)$都是有意义的算式，如果$*$满足结合律，则表达式$x*y*z$就有一个确定的计算结果，即有：  
$$
x*y*z=(x*y)*z=x*(y*z)
$$  
如果 $*$ 不满足结合律，则有可能有 $(x*y)*z\neq x*(y*z).$ 。   此时，表达式 $x*y*z$ 的含义就有歧义。因此，只有当某个运算$*$满足结合律时，才能定义其方幂运算。在后续半群与群中元素方幂的的定义中，其元素运算的结合律起着基础性的支撑作用。  
下面考察运算的交换律，首先给出交换律的定义，具体如下：  
【定义11.6】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y\in A$，成立$x*y=y*x$，则称$\langle A,\ *\rangle$的运算$^*$在𝐴上是可交换的，或者说$\langle A,\ *\rangle$的运算$^*$在𝐴上满足交换律。  
交换律表示代数结构载体集合中的任意两个元素在运算时都可以交换次序。 例如，实数加法与乘法运算、矩阵的加法、整数集合上的模余运算、幂集合的交运算与并运算等都满足交换律。 但是，矩阵的乘法运算、关系与函数的复合运算等都不满足交换律。  
【定义11.7】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，若存在某个元素$a\in A$，满足 a$*$$a=a$，则称$a$是$\langle A,\ *\rangle$的一个幂等元。 如果𝐴中的每个元素都是$\langle A,\ *\rangle$的幂等元，则称$\langle A,\ *\rangle$的运算$*$在𝐴上满足幂等律。  
从上述定义可以看出，所谓幂等元，就是该元素与其自身运算之后仍然等于其自身。例如，对于某个幂集合上的交运算和并运算，幂集合中每个元素显然都是幂等元，因此，幂集合上的交运算和并运算均满足幂等性。但是，对于整数上的加法运算，除了整数0 之外，其余整数显然都不是幂等元，因此,整数上的加法运算不满足幂等律。  
【定义11.8】假设𝐴是任意给定的一个非空集合，$*$为𝐴上的一个二元运算，在由𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，对于$\forall x,y,z\in A$：  
（1）若$z*y=z*x$，有$y=x$，则称运算$*$在𝐴上是可左消去的，或者说运算$∗$在𝐴上满足左消去律，并称$\cdot z$是$A$中关于运算$^*$的左可消去元；  
（2）若$y*z=x*z$，有$y=x$，则称运算$^*$在𝐴上是可右消去的，或者说运算$^*$在𝐴上满足右消去律，并称𝑧是$A$中关于运算$^*$的右可消去元。  
（3）若上述两种情况均满足，则称运算$*$在𝐴上满足消去律，并称$z$是𝐴中关于运算$*$的可消去元。  
下面介绍基于两个二元运算的运算律，即分配律和吸收律。首先给出分配律的定义：  
【定义11.9】假设𝐴是任意给定的一个非空集合，$^*$和$\Delta$均为𝐴上的二元运算，在由$𝐴$、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y,z\in A$：  
若有$x*(y\Delta z)=(x*y)\Delta(x*z)$，则称运算$*$对$\Delta$在𝐴上满足左分配律。  
若有$(y\Delta z)*x=(y*x)\Delta(z*x)$，则称运算$*$对$\Delta$在𝐴上满足右分配律。  
若运算$*$对$\Delta$在𝐴上同时满足左右分配律，则称运算$*$对$\Delta$在𝐴上满足分配律。  
例如，实数集合上的普通乘法对加法满足分配律，$M_{n}(R)$上的矩阵乘法对加法满足分配律，幂集$P(B)$上的集合交运算对并运算满足分配律，并且并运算对交运算也满足分配律。  
将上述关于集合的吸收律推广到一般运算对象和一般运算，得到一个新的运算律，即吸收律。其具体定义如下：  
【定义11.10】设𝐴是任意给定的一个非空集合，$*$和$\Delta$均为为𝐴上二元运算，在由𝐴、$*$和$\Delta$组成的二元代数结构$\langle A,\ *,\ \Delta\rangle$中，对于$\forall x,y\in A$，成立：  
$$
x*(y\Delta z)=x,\;\;x\Delta(y*z)=x
$$  
则称 $*$ 和 $\Delta$ 在 A  上满足吸收律。",分配律和吸收律都是基于两个二元运算的二元算律
特殊元素,包含,单位元,,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)",特殊元素包括单位元
特殊元素,包含,零元,,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)",特殊元素包括零元
特殊元素,包含,逆元,,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)",特殊元素包括逆元
单位元,包含,左单位元,,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)",单位元包括左单位元
单位元,包含,右单位元,,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)",单位元包括右单位元
零元,包含,左零元,,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)",零元包括左零元
零元,包含,右零元,,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)",零元包括右零元
逆元,包含,左逆元,,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)",逆元包括左逆元
逆元,包含,右逆元,,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)",逆元包括右逆元
定理11.1,描述,左单位元,,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)",定理11.1描述了左单位元、右单位元及单位元之间的关系
定理11.1,描述,右单位元,,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)",定理11.1描述了左单位元、右单位元及单位元之间的关系
定理11.1,描述,单位元,,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)",定理11.1描述了左单位元、右单位元及单位元之间的关系
定理11.3,描述,左逆元,,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)",定理11.3描述了左逆元、右逆元及逆元之间的关系
定理11.3,描述,右逆元,,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)",定理11.3描述了左逆元、右逆元及逆元之间的关系
定理11.3,描述,逆元,,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)",定理11.3描述了左逆元、右逆元及逆元之间的关系
定理11.4,描述,逆元,,"有些代数结构中存在一个或多个运算性质非常独特的元素，例如，对于实数集合及其上的乘法运算构成的代数结构$\langle R,\ \times\rangle$，实数1 与任何数相乘都等于这个数，实数0 与任何数相乘都等于0。通常称这些元素为特殊元素。特殊元素主要有单位元、零元、逆元和幂等元这四种基本类型。值得注意的是，并不是任何运算都具有任何特殊元素。特殊元的存在与否与代数结构中的具体运算密切相关。因此，特殊元素能够与运算律一样刻画运算的基本性质和运算结构，通常将是否存在特殊元素作为考察运算性质的一个重要内容。幂等元前文已作介绍，本小节主要介绍单位元、零元和逆元概念和性质。  
事实上，单位元是大家比较熟悉的概念，对于任意一个运算对象，单位元与该对象的运算结果仍然是该运算对象。例如：对于实数集及普通加法运算构成的代数系统$\langle R,+\rangle$，实数0 是其单位元；对于实数集及普通乘法运算构成的代数系统$\langle R,+\rangle$，实数1 是其单位元。下面给出单位元的具体定义：  
【定义11.11】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists e_{l}\in A$，使得$\forall x\in A$，都有$e_{l}*x=x$，则称$ e_{l}$是$\langle A,\ *\rangle$的一个左单位元或左幺元；若$\exists e_{r}\in A$，使得$\forall x\in A$，都有$x*e_{r}=x$，则称$.e_{r}$是$\langle A,\ *\rangle$的一个右单位元或右幺元；若$∃|e\in A$同时为𝐴上关于$*$的左单位元和右单位元，则称$e$是$\langle A,\ *\rangle$的一个单位元或幺元。  
从上述定义不难看出：对于$n$阶实矩阵集合$ M_{n}(R)$上的矩阵加法运算，零矩阵是其单位元；对于$n$阶实矩阵集合$M_{n}(R)$上的矩阵乘法运算，单位矩阵是其单位元；对于全集$U$的幂集合$ P(U)$上的集合交运算，全集$U$是其单位元；对于全集$U$的幂集合$ P(U)$上的集合并运算，空集∅是其单位元；对于𝐴上全体函数集合$A^{A}$上的复合运算，恒等函数是其单位元。  
下面的定理给出了代数结构中左单位元、右单位元及单位元之间的关系：  
【定理11.1】设”$^*$""是集合𝐴中的二元运算，$\langle A,*\rangle$是一个代数系统。  
（1）如果$\langle A,*\rangle$存在幺元，则幺元唯一；  
（2）如果$\langle A,*\rangle$存在幺元，则该幺元一定是左、右幺元；  
（3）如果$\langle A,*\rangle$存在左、右幺元，则该左、右幺元相等，且是幺元。  
【定义11.12】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中：若$\exists\theta_{l}\in A$，使得$\forall x\in A$，都有$\theta_{l}*x=\theta_{l}$，则称$\theta_{l}$是$\langle A,\ *\rangle$的一个左零元；若$\exists\theta_{r}\in A$，使得$\forall x\in A$，都有$x*\theta_{r}=\theta_{r}$，则称$e_{r}$是$\langle A,\ *\rangle$的一个右零元；若$\exists e\in A$同时为𝐴上关于$^*$的左单位元和右单位元，则称$\cdot\theta$是$\langle A,\ *\rangle$的一个零元。  
最后介绍逆元的概念。 我们知道，实数上的加法运算有互为相反数的概念、乘法有互为倒数的概念。 互为相反数的和为0，而0 正是实数上的加法运算的单位元，互为倒数的积为1，而1 正是乘法运算的单位元。 事实上，除此之外，还有类似的例子。 例如：函数与其反函数的复合为恒等映射，而恒等映射正是复合运算的单位元，矩阵与其逆矩阵的乘积为单位矩阵，而单位矩阵正是矩阵乘法运算的单位元。 对上述具体实例中的类似运算特征进行抽象，就可得代数结构中另外一个特殊元素，即逆元素的概念。 其具体定义如下：  
【定义11.13】设𝐴是任意一个非空集合，$*$是𝐴上的二元运算，在𝐴和$*$组成的二元代数结构$\langle A,\ *\rangle$中，$e$是𝐴上关于运算‘$*$’的一个幺元，若$\exists y_{l}\in A$，使得$\forall x\in A$，都有$y_{l}*x=e$，则称$y_{l}$是$𝐴$上关于运算$^*$的一个左逆元；若$\exists y_{r}\in A$，使得$\forall x\in A$，都有$\,x*y_{r}=e$，则称$y_{r}$是𝐴上关于运算‘$*$’的一个右逆元；若$\exists y\in A$同时为𝐴上关于$*$的左逆元和右逆元，则称$y$是$\langle A,\ *\rangle$的一个逆元。  
从上述定义可以看出，只有在单位元存在的情况下才能够讨论左逆元、右逆元和逆元。因此，在讨论一个代数结构逆元的时候，首先需要计算出其单位元。 此外，值得注意的是单位元的逆元就是其自身。  
下面的定理11. 3 给出了左逆元、右逆元和逆元之间的关系：  
【定理11. 3】设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，且设$e$是$\langle A,\ *\rangle$幺元，则对$\forall a\in A$，有：  
（1）如果$a$存在逆元，则逆元唯一；  
（2）如果$a$存在逆元，则该逆元一定是左逆元，右逆元；  
（3）如果$a$存在逆元，右逆元，则该左逆元，右逆元相等且是逆元。  
【定理11. 4】假设$\langle A,\ *\rangle$是一个代数系统，集合𝐴上的二元运算‘$*$’满足结合律，则对于  
$\forall a,b\in A$ ，有： （ 1 ）如果 $a,b$ 分别有逆元 $a^{-1},b^{-1}$ ，则 $(a*b)^{-1}=b^{-1}*a^{-1}$ ； （ 2 ）如果 $a$ 是左  
（右）可逆元，则$a$是左（右）可消去元；如果$a$是可逆元，则$a$是可消去元。  
需要注意的是，当代数系统中的二元运算不满足结合律时，可逆元的逆元素不一定唯一，请看下例。例如，对于代数系统$\langle A,\ *\rangle$，其中$X=\{e,a,b,c,d\}$，$*$是$X$上的二元运算，$*$的运算表表11-18 所示。从该表可知$e$是关于$^*$的幺元，由于有：  
$$
b*c=c*b=e\,;\ b*d=d*b=e
$$  
故$c$和$d$均是$b$的逆元，即$b$的逆元不唯一。其原因其实就是运算$*$不满足结合律，即有：  
$$
(a*b)*c=a*c=e\neq a=a*e=a*(b*c)
$$  
因此，当代数系统的二元运算不满足结合律时，逆元的情况将变得比较复杂。  
表11-18  $*$是𝑋上的二元运算
![](images/bf5c2423c35571a526919e2e95d23a2481f4c08b43bff99f5c13f388680669c9.jpg)  
以上讨论了单位元、零元、逆元的基本概念和性质，表11-19 给出了若干常用代数结构中特殊元素的存在情况：  
表11-19  常用代数结构中特殊元素
![](images/b8e2606043c2ca2d9be084b0f9be72f8e6da7df6f04f6edc831decd3e31d1b31.jpg)",定理11.4描述了逆元的性质和运算规则
同构,推广,同态,,"前面介绍了代数结构及其运算的基本概念，并对运算律及特殊元素等基本运算性质进行讨论，主要分析考察单个代数结构的基本成分和基本特性。使用不同的集合载体和运算可以建立大量不同种类的代数结构。现在我们就来考察这些不同种类代数结构之间的区别与联系。事实上，在前述图论的有关内容中也处理过类似问题，为了考察不同图模型之间区别与联系，我们通过使用不同图模型的结点之间的双射函数来建立图模型之间的映射联系，如果这种双射函数能够保持图模型的结构不变，则认为这两个图模型具有相同的结构，即这两个图模型是同构的，并称这种双射函数为同构映射或同构函数。  
可以采用与之类似的映射方法建立和考察不同代数结构之间的联系，由此得到代数结构同构及同构映射的相关概念。由此更进一步，也可以取消同构映射中为双射的要求，将同构映射推广到一般的映射，则可由此得到代数结构同态及同态映射的相关概念。事实上，不难看出两个代数结构之间的同构映射建立了这两个代数结构载体集合之间的一种特殊等价关系，如果考察由同态映射导出的一般性等价关系，则还可得到代数结构的另外一种关系，即同余关系。 本节主要介绍代数结构之间的同构、同态和同余关系。",同构映射通过取消双射要求可以推广为同态映射
同构,导出,同余,,"前面介绍了代数结构及其运算的基本概念，并对运算律及特殊元素等基本运算性质进行讨论，主要分析考察单个代数结构的基本成分和基本特性。使用不同的集合载体和运算可以建立大量不同种类的代数结构。现在我们就来考察这些不同种类代数结构之间的区别与联系。事实上，在前述图论的有关内容中也处理过类似问题，为了考察不同图模型之间区别与联系，我们通过使用不同图模型的结点之间的双射函数来建立图模型之间的映射联系，如果这种双射函数能够保持图模型的结构不变，则认为这两个图模型具有相同的结构，即这两个图模型是同构的，并称这种双射函数为同构映射或同构函数。  
可以采用与之类似的映射方法建立和考察不同代数结构之间的联系，由此得到代数结构同构及同构映射的相关概念。由此更进一步，也可以取消同构映射中为双射的要求，将同构映射推广到一般的映射，则可由此得到代数结构同态及同态映射的相关概念。事实上，不难看出两个代数结构之间的同构映射建立了这两个代数结构载体集合之间的一种特殊等价关系，如果考察由同态映射导出的一般性等价关系，则还可得到代数结构的另外一种关系，即同余关系。 本节主要介绍代数结构之间的同构、同态和同余关系。",同构映射建立了特殊等价关系，而同态映射导出一般性等价关系即同余关系
同态,导出,同余,,"前面介绍了代数结构及其运算的基本概念，并对运算律及特殊元素等基本运算性质进行讨论，主要分析考察单个代数结构的基本成分和基本特性。使用不同的集合载体和运算可以建立大量不同种类的代数结构。现在我们就来考察这些不同种类代数结构之间的区别与联系。事实上，在前述图论的有关内容中也处理过类似问题，为了考察不同图模型之间区别与联系，我们通过使用不同图模型的结点之间的双射函数来建立图模型之间的映射联系，如果这种双射函数能够保持图模型的结构不变，则认为这两个图模型具有相同的结构，即这两个图模型是同构的，并称这种双射函数为同构映射或同构函数。  
可以采用与之类似的映射方法建立和考察不同代数结构之间的联系，由此得到代数结构同构及同构映射的相关概念。由此更进一步，也可以取消同构映射中为双射的要求，将同构映射推广到一般的映射，则可由此得到代数结构同态及同态映射的相关概念。事实上，不难看出两个代数结构之间的同构映射建立了这两个代数结构载体集合之间的一种特殊等价关系，如果考察由同态映射导出的一般性等价关系，则还可得到代数结构的另外一种关系，即同余关系。 本节主要介绍代数结构之间的同构、同态和同余关系。",同态映射导出的一般性等价关系即为同余关系
同构,包含,同态,,"实数集𝑅上的普通加法$+$和正实数集$R^{+}$上的普通乘法$\times$是大家非常熟悉的两个二元运算，现在考察由这两个运算组成的代数结构$\langle R,+\rangle$和$\langle R^{+}\mathrm{,}\times\rangle$之间的关系。从表面上看，这两个代数结构具有很大差异，实际上两者的运算性质非常相似甚至相同。例如，它们都满足交换律、  
结合律，均有单位元且每个元素都可逆，等等。  
![](images/58bedb4315e0b7299c6a20d064394c58417fc3ffaaf479a3146b9186292e8fe3.jpg)
图 11-2  
事实上，注意到实数0 和1 分别是$\langle R,+\rangle$和$\langle R^{+}\mathrm{,}\times\rangle$的单位元，2 和-2 在$\langle R,+\rangle$中是互逆元素，而100 和0。01 在$\langle R^{+}\mathrm{,}\times\rangle$中是互逆元素。因此，如果在集合$R^{+}$到$R$之间使用常用对数函数$y=f(x)=\lg x$建立一个如图11-2 所示的双射关系，则对于$\forall x_{1},x_{2}\in R^{+}$，有：  
$$
f(x_{1}\times x_{2})=\lg(x_{1}\times x_{2})=\lg x_{1}+\lg x_{2}=f(x_{1})+f(x_{2})
$$  
由此可见，函数$y=\mathbf{log}x$不仅是集合$R^{+}$到$R$之间一个双射，而且保持了运算$\times$和$+$的对应性。具体地说，就是将$R^{+}$上任意两个元素的乘法运算映射成这两个元素在$R$上映射像的加法运算。简单地说，就是先运算再映射等于先映射再运算。  
因此，对于$\langle R,+\rangle$和$\langle R^{+}\mathrm{,}\times\rangle$这两个代数结构，函数$y=\lg x$不仅建立两者在载体集合上的双射关系，而且建立了两者在运算对应转化关系，完整地表达了这两个代数结构之间的联系。由此可以得到关于两个代数结构之间同构及同构映射的概念，具体定义如下：  
【定义11.14】设$\langle A,\ *\rangle$和$\langle B,\ \circ\rangle$是任意两个给定的二元代数结构，如果存在集合𝐴到集合$\cdot B$上的双射函数$\psi$，使得对于$\forall x_{1},x_{2}\in\begin{array}{l}{A}\end{array}$，有：  
$$
\psi(x_{1}*x_{2})=\psi(x_{1})\circ\psi(x_{2})\tag{11-5}
$$  
则称$\psi$是从$\langle A,\ *\rangle$到$\langle B,\ \circ\rangle$的同构映射，并称$\langle A,\ *\rangle$与$\langle B,\ \circ\rangle$同构，记为$\langle A,\ *\rangle\cong\langle B,\ \circ\rangle$  。  
例如，设$A=\{a\}$，$B=\{0,\!1\}$，对于$\langle2^{A},\cup\rangle$和$\langle B,\ \vee\rangle$这两个代数系统，定义从$2^{A}$到$B$的双射为：$\psi(\emptyset)=0;\psi(A)=1$，则由表11-21 所示的运算表可知，$\psi$是一个同构映射。因此，$\langle2^{A},\cup\rangle$和$\langle B,\ \vee\rangle$是两个同构的代数系统。  
表11-21(a) ∪的运算表∨的  表11-21(b) $\vee$的运算表
![](images/67baf77732c0c1ae7c4671f234b8b35e1976f92052d9429cf5289591bcb48cb0.jpg)  
不难看出， $\langle2^{A},\cup\rangle$和$\langle B,\ \vee\rangle$的运算表除了在符号表达形式上有所差异之外，其实质内容是完全一样的。因此，如果使用统一的表达形式，则两者就同一个代数结构。  
【定义11.15】设$\langle A,\ *,\ \triangle\rangle$和$\langle B,\ \circ,\ \diamond\ \rangle$是任意两个给定的代数结构，其中$*$和∘分别为二元运算，$\triangle$和$\diamond$分别为一元运算，若存在$𝐴$到$B$的双射函数$\mathcal{\psi}$，对于$\forall x_{1},x_{2},x\in\ A$，有：  
$$
\psi(x_{1}*x_{2})=\psi(x_{1})\circ\psi(x_{2});\,\,\,\psi(\triangle\,x)=\circ\,\psi(x)
$$  
则称映射$\psi$是从$\langle A,\ *,\ \triangle\rangle$到$\langle B,\ \circ,\ \diamond\ \rangle$的同构映射，并称代数结构$\langle A,\ *,\ \triangle\rangle$与$\langle B,\ \circ,\ \diamond\ \rangle$同构，记为$\langle A,\ *,\ \triangle\rangle\cong\langle B,\ \circ,\ \diamond\ \rangle\,$。  
例如，对于代数结构$\langle P(A),\ \cap,\ \cup,\sim\rangle$和$\langle L,\ \land,\ \lor,\lnot\rangle$，其中$A=\{a,b\}$$L=\{00,\!01,\!10,\!11\}$  
$\cap,\;\cup,\sim$分别为集合的交、并、补运算；$\land,\lor,\lnot$分别按位与、或、非运算。如果定义如下从$P(A)$到$L$双射函数$\mathcal{\psi}$：  
$$
\psi(\emptyset)=00;\,\,\,\psi(\{b\})=01;\,\,\,\psi(\{a\})=10;\,\,\,\psi(\{a,b\})=11
$$  
易证$\psi$是一个同构映射，故$\langle P(A),\ \cap,\ \cup,\sim\rangle$与$\langle L,\ \land,\ \lor,\lnot\rangle$同构。  
从上述例题可以看出，同构的两个代数结构具有完全相同的结构，后文我们将对此进行数学证明。然而，对于有些代数结构，它们虽然在结构上不完全一致，但是在一些方面具有一定的相似性，为了能够刻画这种相似性，有必要放弃同构映射中双射的要求，可将上述两个代数结构之间的同构映射从双射推广到一般的映射，由此得到两个代数结构之间同态的相关概念，具体定义如下：  
【定义11.16】设$\langle A,\ *\rangle$和$\langle B,\ \circ\rangle$是任意两个给定的二元代数结构，如果存在集合𝐴到集合$\cdot B$上的函数$\mathcal{\psi}$，使得对于$\forall x_{1},x_{2}\in\begin{array}{l}{A}\end{array}$，有：  
$$
\psi(x_{1}*x_{2})=\psi(x_{1})\circ\psi(x_{2})
$$  
则称$\psi$是从$\langle A,\ *\rangle$到$\langle B,\ \circ\rangle$的同态映射，并称$\langle A,\ *\rangle$与$\langle B,\ \circ\rangle$同态，记为$\langle A,\ *\rangle{\sim}\langle B,\ \circ\rangle$，称代数结构$\langle\psi(A),\;\circ\rangle$为$\langle A,\ *\rangle$在映射$\cdot\psi$下的同态像。若$\psi$为单射，则称$\langle A,\ *\rangle$与$\langle B,\ \circ\rangle$为单同态；若 $\psi$ 为满射，则称 $\langle A,\ *\rangle$ 与 $\langle B,\ \circ\rangle$ 为满同态；若 $A=B$ ，则称 $\langle A,\ *\rangle$ 与 $\langle B,\ \circ\rangle$ 为满同态。  
从上述定义可以看出，$\langle A,\ *\rangle$和$\langle B,\ \circ\rangle$之间的同态关系如图11-3 所示，显然，若$\psi$为满射，则$\langle A,\ *\rangle$在映射$\psi$下的同态像$\langle\psi(A),\ \circ\rangle$就是$\langle B,\ \circ\rangle$。  
![](images/e8626ab454b382b9f885b275d78ff124565747a18c7fb336bb7865456c5d148c.jpg)
图11-3  
【定义11.17】设$\langle A,\ *,\ \triangle\rangle$和$\langle B,\ \circ,\ \diamond\ \rangle$是任意两个给定的代数结构，其中$*$和∘分别为二元运算，$\triangle$和$\diamond$分别为一元运算，若存在𝐴到$B$的函数$\mathcal{\psi}$，对于$\forall x_{1},x_{2},x\in\textit{A}$，有：  
$$
\psi(x_{1}*x_{2})=\psi(x_{1})\circ\psi(x_{2});\,\,\,\psi(\triangle\,x)=\circ\,\psi(x)
$$  
则称映射$\psi $是从$\langle A,\ *,\ \triangle\rangle$到$\langle B,\ \circ,\ \diamond\ \rangle$的同态映射，并称代数结构$\langle A,\ *,\ \triangle\rangle$与$\langle B,\ \circ,\ \diamond\ \rangle$同态，记为$\langle A,\ *,\ \triangle\rangle{\sim}\langle B,\ \circ,\ \diamond\ \rangle$。称代数结构$\langle\psi(A),\ \circ,\ \circ\rangle$为$\langle A,\ *\rangle$在映射$\psi$下的同态像。 若函数$\mathcal{\psi}$为单射， 则称 $\langle A,\ *\rangle$ 与 $\langle B,\ \circ\rangle$ 为单同态； 若函数 $\psi$ 为满射， 则称 $\langle A,\ *\rangle$ 与 $\langle B,\ \circ\rangle$ 为满同态； 若 $ A=$ $B$，则称$\langle A,\ *\rangle$与$\langle B,\ \circ\rangle$为满同态。",同构是同态的一种特殊情况，即同构映射要求双射，而同态映射不要求双射。
同构,无关,同余,,"实数集𝑅上的普通加法$+$和正实数集$R^{+}$上的普通乘法$\times$是大家非常熟悉的两个二元运算，现在考察由这两个运算组成的代数结构$\langle R,+\rangle$和$\langle R^{+}\mathrm{,}\times\rangle$之间的关系。从表面上看，这两个代数结构具有很大差异，实际上两者的运算性质非常相似甚至相同。例如，它们都满足交换律、  
结合律，均有单位元且每个元素都可逆，等等。  
![](images/58bedb4315e0b7299c6a20d064394c58417fc3ffaaf479a3146b9186292e8fe3.jpg)
图 11-2  
事实上，注意到实数0 和1 分别是$\langle R,+\rangle$和$\langle R^{+}\mathrm{,}\times\rangle$的单位元，2 和-2 在$\langle R,+\rangle$中是互逆元素，而100 和0。01 在$\langle R^{+}\mathrm{,}\times\rangle$中是互逆元素。因此，如果在集合$R^{+}$到$R$之间使用常用对数函数$y=f(x)=\lg x$建立一个如图11-2 所示的双射关系，则对于$\forall x_{1},x_{2}\in R^{+}$，有：  
$$
f(x_{1}\times x_{2})=\lg(x_{1}\times x_{2})=\lg x_{1}+\lg x_{2}=f(x_{1})+f(x_{2})
$$  
由此可见，函数$y=\mathbf{log}x$不仅是集合$R^{+}$到$R$之间一个双射，而且保持了运算$\times$和$+$的对应性。具体地说，就是将$R^{+}$上任意两个元素的乘法运算映射成这两个元素在$R$上映射像的加法运算。简单地说，就是先运算再映射等于先映射再运算。  
因此，对于$\langle R,+\rangle$和$\langle R^{+}\mathrm{,}\times\rangle$这两个代数结构，函数$y=\lg x$不仅建立两者在载体集合上的双射关系，而且建立了两者在运算对应转化关系，完整地表达了这两个代数结构之间的联系。由此可以得到关于两个代数结构之间同构及同构映射的概念，具体定义如下：  
【定义11.14】设$\langle A,\ *\rangle$和$\langle B,\ \circ\rangle$是任意两个给定的二元代数结构，如果存在集合𝐴到集合$\cdot B$上的双射函数$\psi$，使得对于$\forall x_{1},x_{2}\in\begin{array}{l}{A}\end{array}$，有：  
$$
\psi(x_{1}*x_{2})=\psi(x_{1})\circ\psi(x_{2})\tag{11-5}
$$  
则称$\psi$是从$\langle A,\ *\rangle$到$\langle B,\ \circ\rangle$的同构映射，并称$\langle A,\ *\rangle$与$\langle B,\ \circ\rangle$同构，记为$\langle A,\ *\rangle\cong\langle B,\ \circ\rangle$  。  
例如，设$A=\{a\}$，$B=\{0,\!1\}$，对于$\langle2^{A},\cup\rangle$和$\langle B,\ \vee\rangle$这两个代数系统，定义从$2^{A}$到$B$的双射为：$\psi(\emptyset)=0;\psi(A)=1$，则由表11-21 所示的运算表可知，$\psi$是一个同构映射。因此，$\langle2^{A},\cup\rangle$和$\langle B,\ \vee\rangle$是两个同构的代数系统。  
表11-21(a) ∪的运算表∨的  表11-21(b) $\vee$的运算表
![](images/67baf77732c0c1ae7c4671f234b8b35e1976f92052d9429cf5289591bcb48cb0.jpg)  
不难看出， $\langle2^{A},\cup\rangle$和$\langle B,\ \vee\rangle$的运算表除了在符号表达形式上有所差异之外，其实质内容是完全一样的。因此，如果使用统一的表达形式，则两者就同一个代数结构。  
【定义11.15】设$\langle A,\ *,\ \triangle\rangle$和$\langle B,\ \circ,\ \diamond\ \rangle$是任意两个给定的代数结构，其中$*$和∘分别为二元运算，$\triangle$和$\diamond$分别为一元运算，若存在$𝐴$到$B$的双射函数$\mathcal{\psi}$，对于$\forall x_{1},x_{2},x\in\ A$，有：  
$$
\psi(x_{1}*x_{2})=\psi(x_{1})\circ\psi(x_{2});\,\,\,\psi(\triangle\,x)=\circ\,\psi(x)
$$  
则称映射$\psi$是从$\langle A,\ *,\ \triangle\rangle$到$\langle B,\ \circ,\ \diamond\ \rangle$的同构映射，并称代数结构$\langle A,\ *,\ \triangle\rangle$与$\langle B,\ \circ,\ \diamond\ \rangle$同构，记为$\langle A,\ *,\ \triangle\rangle\cong\langle B,\ \circ,\ \diamond\ \rangle\,$。  
例如，对于代数结构$\langle P(A),\ \cap,\ \cup,\sim\rangle$和$\langle L,\ \land,\ \lor,\lnot\rangle$，其中$A=\{a,b\}$$L=\{00,\!01,\!10,\!11\}$  
$\cap,\;\cup,\sim$分别为集合的交、并、补运算；$\land,\lor,\lnot$分别按位与、或、非运算。如果定义如下从$P(A)$到$L$双射函数$\mathcal{\psi}$：  
$$
\psi(\emptyset)=00;\,\,\,\psi(\{b\})=01;\,\,\,\psi(\{a\})=10;\,\,\,\psi(\{a,b\})=11
$$  
易证$\psi$是一个同构映射，故$\langle P(A),\ \cap,\ \cup,\sim\rangle$与$\langle L,\ \land,\ \lor,\lnot\rangle$同构。  
从上述例题可以看出，同构的两个代数结构具有完全相同的结构，后文我们将对此进行数学证明。然而，对于有些代数结构，它们虽然在结构上不完全一致，但是在一些方面具有一定的相似性，为了能够刻画这种相似性，有必要放弃同构映射中双射的要求，可将上述两个代数结构之间的同构映射从双射推广到一般的映射，由此得到两个代数结构之间同态的相关概念，具体定义如下：  
【定义11.16】设$\langle A,\ *\rangle$和$\langle B,\ \circ\rangle$是任意两个给定的二元代数结构，如果存在集合𝐴到集合$\cdot B$上的函数$\mathcal{\psi}$，使得对于$\forall x_{1},x_{2}\in\begin{array}{l}{A}\end{array}$，有：  
$$
\psi(x_{1}*x_{2})=\psi(x_{1})\circ\psi(x_{2})
$$  
则称$\psi$是从$\langle A,\ *\rangle$到$\langle B,\ \circ\rangle$的同态映射，并称$\langle A,\ *\rangle$与$\langle B,\ \circ\rangle$同态，记为$\langle A,\ *\rangle{\sim}\langle B,\ \circ\rangle$，称代数结构$\langle\psi(A),\;\circ\rangle$为$\langle A,\ *\rangle$在映射$\cdot\psi$下的同态像。若$\psi$为单射，则称$\langle A,\ *\rangle$与$\langle B,\ \circ\rangle$为单同态；若 $\psi$ 为满射，则称 $\langle A,\ *\rangle$ 与 $\langle B,\ \circ\rangle$ 为满同态；若 $A=B$ ，则称 $\langle A,\ *\rangle$ 与 $\langle B,\ \circ\rangle$ 为满同态。  
从上述定义可以看出，$\langle A,\ *\rangle$和$\langle B,\ \circ\rangle$之间的同态关系如图11-3 所示，显然，若$\psi$为满射，则$\langle A,\ *\rangle$在映射$\psi$下的同态像$\langle\psi(A),\ \circ\rangle$就是$\langle B,\ \circ\rangle$。  
![](images/e8626ab454b382b9f885b275d78ff124565747a18c7fb336bb7865456c5d148c.jpg)
图11-3  
【定义11.17】设$\langle A,\ *,\ \triangle\rangle$和$\langle B,\ \circ,\ \diamond\ \rangle$是任意两个给定的代数结构，其中$*$和∘分别为二元运算，$\triangle$和$\diamond$分别为一元运算，若存在𝐴到$B$的函数$\mathcal{\psi}$，对于$\forall x_{1},x_{2},x\in\textit{A}$，有：  
$$
\psi(x_{1}*x_{2})=\psi(x_{1})\circ\psi(x_{2});\,\,\,\psi(\triangle\,x)=\circ\,\psi(x)
$$  
则称映射$\psi $是从$\langle A,\ *,\ \triangle\rangle$到$\langle B,\ \circ,\ \diamond\ \rangle$的同态映射，并称代数结构$\langle A,\ *,\ \triangle\rangle$与$\langle B,\ \circ,\ \diamond\ \rangle$同态，记为$\langle A,\ *,\ \triangle\rangle{\sim}\langle B,\ \circ,\ \diamond\ \rangle$。称代数结构$\langle\psi(A),\ \circ,\ \circ\rangle$为$\langle A,\ *\rangle$在映射$\psi$下的同态像。 若函数$\mathcal{\psi}$为单射， 则称 $\langle A,\ *\rangle$ 与 $\langle B,\ \circ\rangle$ 为单同态； 若函数 $\psi$ 为满射， 则称 $\langle A,\ *\rangle$ 与 $\langle B,\ \circ\rangle$ 为满同态； 若 $ A=$ $B$，则称$\langle A,\ *\rangle$与$\langle B,\ \circ\rangle$为满同态。",文本中未提及同构与同余之间的直接关系。
同态,无关,同余,,"实数集𝑅上的普通加法$+$和正实数集$R^{+}$上的普通乘法$\times$是大家非常熟悉的两个二元运算，现在考察由这两个运算组成的代数结构$\langle R,+\rangle$和$\langle R^{+}\mathrm{,}\times\rangle$之间的关系。从表面上看，这两个代数结构具有很大差异，实际上两者的运算性质非常相似甚至相同。例如，它们都满足交换律、  
结合律，均有单位元且每个元素都可逆，等等。  
![](images/58bedb4315e0b7299c6a20d064394c58417fc3ffaaf479a3146b9186292e8fe3.jpg)
图 11-2  
事实上，注意到实数0 和1 分别是$\langle R,+\rangle$和$\langle R^{+}\mathrm{,}\times\rangle$的单位元，2 和-2 在$\langle R,+\rangle$中是互逆元素，而100 和0。01 在$\langle R^{+}\mathrm{,}\times\rangle$中是互逆元素。因此，如果在集合$R^{+}$到$R$之间使用常用对数函数$y=f(x)=\lg x$建立一个如图11-2 所示的双射关系，则对于$\forall x_{1},x_{2}\in R^{+}$，有：  
$$
f(x_{1}\times x_{2})=\lg(x_{1}\times x_{2})=\lg x_{1}+\lg x_{2}=f(x_{1})+f(x_{2})
$$  
由此可见，函数$y=\mathbf{log}x$不仅是集合$R^{+}$到$R$之间一个双射，而且保持了运算$\times$和$+$的对应性。具体地说，就是将$R^{+}$上任意两个元素的乘法运算映射成这两个元素在$R$上映射像的加法运算。简单地说，就是先运算再映射等于先映射再运算。  
因此，对于$\langle R,+\rangle$和$\langle R^{+}\mathrm{,}\times\rangle$这两个代数结构，函数$y=\lg x$不仅建立两者在载体集合上的双射关系，而且建立了两者在运算对应转化关系，完整地表达了这两个代数结构之间的联系。由此可以得到关于两个代数结构之间同构及同构映射的概念，具体定义如下：  
【定义11.14】设$\langle A,\ *\rangle$和$\langle B,\ \circ\rangle$是任意两个给定的二元代数结构，如果存在集合𝐴到集合$\cdot B$上的双射函数$\psi$，使得对于$\forall x_{1},x_{2}\in\begin{array}{l}{A}\end{array}$，有：  
$$
\psi(x_{1}*x_{2})=\psi(x_{1})\circ\psi(x_{2})\tag{11-5}
$$  
则称$\psi$是从$\langle A,\ *\rangle$到$\langle B,\ \circ\rangle$的同构映射，并称$\langle A,\ *\rangle$与$\langle B,\ \circ\rangle$同构，记为$\langle A,\ *\rangle\cong\langle B,\ \circ\rangle$  。  
例如，设$A=\{a\}$，$B=\{0,\!1\}$，对于$\langle2^{A},\cup\rangle$和$\langle B,\ \vee\rangle$这两个代数系统，定义从$2^{A}$到$B$的双射为：$\psi(\emptyset)=0;\psi(A)=1$，则由表11-21 所示的运算表可知，$\psi$是一个同构映射。因此，$\langle2^{A},\cup\rangle$和$\langle B,\ \vee\rangle$是两个同构的代数系统。  
表11-21(a) ∪的运算表∨的  表11-21(b) $\vee$的运算表
![](images/67baf77732c0c1ae7c4671f234b8b35e1976f92052d9429cf5289591bcb48cb0.jpg)  
不难看出， $\langle2^{A},\cup\rangle$和$\langle B,\ \vee\rangle$的运算表除了在符号表达形式上有所差异之外，其实质内容是完全一样的。因此，如果使用统一的表达形式，则两者就同一个代数结构。  
【定义11.15】设$\langle A,\ *,\ \triangle\rangle$和$\langle B,\ \circ,\ \diamond\ \rangle$是任意两个给定的代数结构，其中$*$和∘分别为二元运算，$\triangle$和$\diamond$分别为一元运算，若存在$𝐴$到$B$的双射函数$\mathcal{\psi}$，对于$\forall x_{1},x_{2},x\in\ A$，有：  
$$
\psi(x_{1}*x_{2})=\psi(x_{1})\circ\psi(x_{2});\,\,\,\psi(\triangle\,x)=\circ\,\psi(x)
$$  
则称映射$\psi$是从$\langle A,\ *,\ \triangle\rangle$到$\langle B,\ \circ,\ \diamond\ \rangle$的同构映射，并称代数结构$\langle A,\ *,\ \triangle\rangle$与$\langle B,\ \circ,\ \diamond\ \rangle$同构，记为$\langle A,\ *,\ \triangle\rangle\cong\langle B,\ \circ,\ \diamond\ \rangle\,$。  
例如，对于代数结构$\langle P(A),\ \cap,\ \cup,\sim\rangle$和$\langle L,\ \land,\ \lor,\lnot\rangle$，其中$A=\{a,b\}$$L=\{00,\!01,\!10,\!11\}$  
$\cap,\;\cup,\sim$分别为集合的交、并、补运算；$\land,\lor,\lnot$分别按位与、或、非运算。如果定义如下从$P(A)$到$L$双射函数$\mathcal{\psi}$：  
$$
\psi(\emptyset)=00;\,\,\,\psi(\{b\})=01;\,\,\,\psi(\{a\})=10;\,\,\,\psi(\{a,b\})=11
$$  
易证$\psi$是一个同构映射，故$\langle P(A),\ \cap,\ \cup,\sim\rangle$与$\langle L,\ \land,\ \lor,\lnot\rangle$同构。  
从上述例题可以看出，同构的两个代数结构具有完全相同的结构，后文我们将对此进行数学证明。然而，对于有些代数结构，它们虽然在结构上不完全一致，但是在一些方面具有一定的相似性，为了能够刻画这种相似性，有必要放弃同构映射中双射的要求，可将上述两个代数结构之间的同构映射从双射推广到一般的映射，由此得到两个代数结构之间同态的相关概念，具体定义如下：  
【定义11.16】设$\langle A,\ *\rangle$和$\langle B,\ \circ\rangle$是任意两个给定的二元代数结构，如果存在集合𝐴到集合$\cdot B$上的函数$\mathcal{\psi}$，使得对于$\forall x_{1},x_{2}\in\begin{array}{l}{A}\end{array}$，有：  
$$
\psi(x_{1}*x_{2})=\psi(x_{1})\circ\psi(x_{2})
$$  
则称$\psi$是从$\langle A,\ *\rangle$到$\langle B,\ \circ\rangle$的同态映射，并称$\langle A,\ *\rangle$与$\langle B,\ \circ\rangle$同态，记为$\langle A,\ *\rangle{\sim}\langle B,\ \circ\rangle$，称代数结构$\langle\psi(A),\;\circ\rangle$为$\langle A,\ *\rangle$在映射$\cdot\psi$下的同态像。若$\psi$为单射，则称$\langle A,\ *\rangle$与$\langle B,\ \circ\rangle$为单同态；若 $\psi$ 为满射，则称 $\langle A,\ *\rangle$ 与 $\langle B,\ \circ\rangle$ 为满同态；若 $A=B$ ，则称 $\langle A,\ *\rangle$ 与 $\langle B,\ \circ\rangle$ 为满同态。  
从上述定义可以看出，$\langle A,\ *\rangle$和$\langle B,\ \circ\rangle$之间的同态关系如图11-3 所示，显然，若$\psi$为满射，则$\langle A,\ *\rangle$在映射$\psi$下的同态像$\langle\psi(A),\ \circ\rangle$就是$\langle B,\ \circ\rangle$。  
![](images/e8626ab454b382b9f885b275d78ff124565747a18c7fb336bb7865456c5d148c.jpg)
图11-3  
【定义11.17】设$\langle A,\ *,\ \triangle\rangle$和$\langle B,\ \circ,\ \diamond\ \rangle$是任意两个给定的代数结构，其中$*$和∘分别为二元运算，$\triangle$和$\diamond$分别为一元运算，若存在𝐴到$B$的函数$\mathcal{\psi}$，对于$\forall x_{1},x_{2},x\in\textit{A}$，有：  
$$
\psi(x_{1}*x_{2})=\psi(x_{1})\circ\psi(x_{2});\,\,\,\psi(\triangle\,x)=\circ\,\psi(x)
$$  
则称映射$\psi $是从$\langle A,\ *,\ \triangle\rangle$到$\langle B,\ \circ,\ \diamond\ \rangle$的同态映射，并称代数结构$\langle A,\ *,\ \triangle\rangle$与$\langle B,\ \circ,\ \diamond\ \rangle$同态，记为$\langle A,\ *,\ \triangle\rangle{\sim}\langle B,\ \circ,\ \diamond\ \rangle$。称代数结构$\langle\psi(A),\ \circ,\ \circ\rangle$为$\langle A,\ *\rangle$在映射$\psi$下的同态像。 若函数$\mathcal{\psi}$为单射， 则称 $\langle A,\ *\rangle$ 与 $\langle B,\ \circ\rangle$ 为单同态； 若函数 $\psi$ 为满射， 则称 $\langle A,\ *\rangle$ 与 $\langle B,\ \circ\rangle$ 为满同态； 若 $ A=$ $B$，则称$\langle A,\ *\rangle$与$\langle B,\ \circ\rangle$为满同态。",文本中未提及同态与同余之间的直接关系。
同余,定义,同余关系,,"在整数理论中，我们学过整数之间的同余关系。整数的模$\boldsymbol{\cdot}\boldsymbol{k}$同余关系作为一种等价关系其实是整数相等关系的一种扩展。我们知道，整数之间的相等关系是一种最强的等价关系。 由运算的单值映射性质可知，对于任意两个相等的整数进行某种运算之后仍然保持相等。 现将整数相等关系这种对运算的保持性质推广到一般的等价关系？具体地说，就是对于一个任意给定的代数结构$\langle A,\ *\rangle$，$R$是载体集合𝐴上的一个等价关系，考察在$A$中具有关系𝑅的元素经过运算后是否仍然具有等价关系$R$。由此得到如下同余关系的相关定义：  
【定义11.18】设$\langle A,\ *,\!\triangle\rangle$是一个代数结构，$*$和$\triangle$分别是二元运算和一元运算，$\sim$是载体$𝐴$上的等价关系，对于$\forall a,b,c\in A$且$a{\sim}b$：若有$\triangle\;a\!\sim\triangle\;b$，则称$\sim$是关于运算$△$的同余关系；若有 $a*c{\sim}b*c$ 且 $c*a{\sim}c*b$ ，则称 $\sim$ 是关于运算 ${\ast}$ 的同余关系；若 $\sim$ 是关于 △ 和 $*$ 的同余 关系，则称$\sim$是代数结构$\langle A,\ *,\triangle\rangle$上的同余关系，此时称等价类$[x]_{\sim}$为同余类。  
我们知道，集合𝐴上的等价关系𝑅将𝐴划分为一个一个的等价类，如果𝐴中具有等价关系$R$的元素在运算$^*$下仍然保持等价关系$R$不变，那就说明，集合𝐴在等价关系$R$下的划分在运算$^*$的映射变换下保持不变。具体地说：就是运算$^*$将𝐴中任意彼此等价的两个元素从其所处的等价类映射到另外一个等价类中，如图11.4 所示，图中每个小方格分别代表一个等价类。 此时，可以将运算$^*$看成是对集合𝐴中元素在等价类之间进行的一次置换。  
![](images/fae0b5be5e5b684797945d41e251f779b67578792deb6bd81af14b0e79ffcf00.jpg)
图11.4  同余关系与等价类  
从上述定义可以看出，若等价关系$\sim$在𝐴上的所有运算下都是可保持的，则$\sim$为代数系统$𝐴$上的同余关系。  
【定理11.11】等价关系$\sim$关于二元运算∗是一个同余关系，当且仅当$a{\sim}b$和$c{\sim}d$时，有  
$ a c\sim b d$。  
现在讨论同态和同余之间的联系，首先给出由同态映射导出的一个等价关系：  
【定理11.12】假设$\langle A,+,\ \times\rangle$和$\langle B,\,\oplus,\,\otimes\,\rangle$是任意两个同态的代数结构，$\psi$：$A\rightarrow B$是其同态映射，则集合$\cdot A$中元素在映射$\cdot\psi$下具有同像的关系$\sim$，即有：  
$$
\sim\;=\{\langle x,y\rangle|x,y\in A\land\psi(x)=\psi(y)\}\tag{11-11}
$$  
是一个等价关系，并称之为由同态映射$\cdot\psi$导出的𝐴上自然等价关系。  
【定理11.13】假设$\langle A,+,\ \times\rangle$和$\langle B,\,\oplus,\,\otimes\,\rangle$是任意两个同态的代数结构，$\psi$：$A\rightarrow B$是其同态映射，则由同态映射$\cdot\psi$导出的自然等价关系：  
$$
\sim\;=\{\langle x,y\rangle|x,y\in A\land\psi(x)=\psi(y)\}
$$  
是一个同余关系。  
事实上，对于代数结构$\langle A,+,\ \times\rangle$上的任意一个同余关系$\sim$，可以构造出一个与之相应的商代数，并且$\langle A,+,\ \times\rangle$与该商代数之间是一种满同态关系，称之为自然同态关系。因此，由同余关系也可以构造出一个与之相应的同态关系，并且该同态映射下的同态像与该商代数之间具体同构关系。具体内容可查阅商代数的相关知识，这里不再赘述。",同余是代数结构上的等价关系，满足特定运算下的保持性质
定理11.11,条件,同余关系,,"在整数理论中，我们学过整数之间的同余关系。整数的模$\boldsymbol{\cdot}\boldsymbol{k}$同余关系作为一种等价关系其实是整数相等关系的一种扩展。我们知道，整数之间的相等关系是一种最强的等价关系。 由运算的单值映射性质可知，对于任意两个相等的整数进行某种运算之后仍然保持相等。 现将整数相等关系这种对运算的保持性质推广到一般的等价关系？具体地说，就是对于一个任意给定的代数结构$\langle A,\ *\rangle$，$R$是载体集合𝐴上的一个等价关系，考察在$A$中具有关系𝑅的元素经过运算后是否仍然具有等价关系$R$。由此得到如下同余关系的相关定义：  
【定义11.18】设$\langle A,\ *,\!\triangle\rangle$是一个代数结构，$*$和$\triangle$分别是二元运算和一元运算，$\sim$是载体$𝐴$上的等价关系，对于$\forall a,b,c\in A$且$a{\sim}b$：若有$\triangle\;a\!\sim\triangle\;b$，则称$\sim$是关于运算$△$的同余关系；若有 $a*c{\sim}b*c$ 且 $c*a{\sim}c*b$ ，则称 $\sim$ 是关于运算 ${\ast}$ 的同余关系；若 $\sim$ 是关于 △ 和 $*$ 的同余 关系，则称$\sim$是代数结构$\langle A,\ *,\triangle\rangle$上的同余关系，此时称等价类$[x]_{\sim}$为同余类。  
我们知道，集合𝐴上的等价关系𝑅将𝐴划分为一个一个的等价类，如果𝐴中具有等价关系$R$的元素在运算$^*$下仍然保持等价关系$R$不变，那就说明，集合𝐴在等价关系$R$下的划分在运算$^*$的映射变换下保持不变。具体地说：就是运算$^*$将𝐴中任意彼此等价的两个元素从其所处的等价类映射到另外一个等价类中，如图11.4 所示，图中每个小方格分别代表一个等价类。 此时，可以将运算$^*$看成是对集合𝐴中元素在等价类之间进行的一次置换。  
![](images/fae0b5be5e5b684797945d41e251f779b67578792deb6bd81af14b0e79ffcf00.jpg)
图11.4  同余关系与等价类  
从上述定义可以看出，若等价关系$\sim$在𝐴上的所有运算下都是可保持的，则$\sim$为代数系统$𝐴$上的同余关系。  
【定理11.11】等价关系$\sim$关于二元运算∗是一个同余关系，当且仅当$a{\sim}b$和$c{\sim}d$时，有  
$ a c\sim b d$。  
现在讨论同态和同余之间的联系，首先给出由同态映射导出的一个等价关系：  
【定理11.12】假设$\langle A,+,\ \times\rangle$和$\langle B,\,\oplus,\,\otimes\,\rangle$是任意两个同态的代数结构，$\psi$：$A\rightarrow B$是其同态映射，则集合$\cdot A$中元素在映射$\cdot\psi$下具有同像的关系$\sim$，即有：  
$$
\sim\;=\{\langle x,y\rangle|x,y\in A\land\psi(x)=\psi(y)\}\tag{11-11}
$$  
是一个等价关系，并称之为由同态映射$\cdot\psi$导出的𝐴上自然等价关系。  
【定理11.13】假设$\langle A,+,\ \times\rangle$和$\langle B,\,\oplus,\,\otimes\,\rangle$是任意两个同态的代数结构，$\psi$：$A\rightarrow B$是其同态映射，则由同态映射$\cdot\psi$导出的自然等价关系：  
$$
\sim\;=\{\langle x,y\rangle|x,y\in A\land\psi(x)=\psi(y)\}
$$  
是一个同余关系。  
事实上，对于代数结构$\langle A,+,\ \times\rangle$上的任意一个同余关系$\sim$，可以构造出一个与之相应的商代数，并且$\langle A,+,\ \times\rangle$与该商代数之间是一种满同态关系，称之为自然同态关系。因此，由同余关系也可以构造出一个与之相应的同态关系，并且该同态映射下的同态像与该商代数之间具体同构关系。具体内容可查阅商代数的相关知识，这里不再赘述。",等价关系是关于二元运算的同余关系，当且仅当满足特定条件
定理11.12,导出,同余关系,,"在整数理论中，我们学过整数之间的同余关系。整数的模$\boldsymbol{\cdot}\boldsymbol{k}$同余关系作为一种等价关系其实是整数相等关系的一种扩展。我们知道，整数之间的相等关系是一种最强的等价关系。 由运算的单值映射性质可知，对于任意两个相等的整数进行某种运算之后仍然保持相等。 现将整数相等关系这种对运算的保持性质推广到一般的等价关系？具体地说，就是对于一个任意给定的代数结构$\langle A,\ *\rangle$，$R$是载体集合𝐴上的一个等价关系，考察在$A$中具有关系𝑅的元素经过运算后是否仍然具有等价关系$R$。由此得到如下同余关系的相关定义：  
【定义11.18】设$\langle A,\ *,\!\triangle\rangle$是一个代数结构，$*$和$\triangle$分别是二元运算和一元运算，$\sim$是载体$𝐴$上的等价关系，对于$\forall a,b,c\in A$且$a{\sim}b$：若有$\triangle\;a\!\sim\triangle\;b$，则称$\sim$是关于运算$△$的同余关系；若有 $a*c{\sim}b*c$ 且 $c*a{\sim}c*b$ ，则称 $\sim$ 是关于运算 ${\ast}$ 的同余关系；若 $\sim$ 是关于 △ 和 $*$ 的同余 关系，则称$\sim$是代数结构$\langle A,\ *,\triangle\rangle$上的同余关系，此时称等价类$[x]_{\sim}$为同余类。  
我们知道，集合𝐴上的等价关系𝑅将𝐴划分为一个一个的等价类，如果𝐴中具有等价关系$R$的元素在运算$^*$下仍然保持等价关系$R$不变，那就说明，集合𝐴在等价关系$R$下的划分在运算$^*$的映射变换下保持不变。具体地说：就是运算$^*$将𝐴中任意彼此等价的两个元素从其所处的等价类映射到另外一个等价类中，如图11.4 所示，图中每个小方格分别代表一个等价类。 此时，可以将运算$^*$看成是对集合𝐴中元素在等价类之间进行的一次置换。  
![](images/fae0b5be5e5b684797945d41e251f779b67578792deb6bd81af14b0e79ffcf00.jpg)
图11.4  同余关系与等价类  
从上述定义可以看出，若等价关系$\sim$在𝐴上的所有运算下都是可保持的，则$\sim$为代数系统$𝐴$上的同余关系。  
【定理11.11】等价关系$\sim$关于二元运算∗是一个同余关系，当且仅当$a{\sim}b$和$c{\sim}d$时，有  
$ a c\sim b d$。  
现在讨论同态和同余之间的联系，首先给出由同态映射导出的一个等价关系：  
【定理11.12】假设$\langle A,+,\ \times\rangle$和$\langle B,\,\oplus,\,\otimes\,\rangle$是任意两个同态的代数结构，$\psi$：$A\rightarrow B$是其同态映射，则集合$\cdot A$中元素在映射$\cdot\psi$下具有同像的关系$\sim$，即有：  
$$
\sim\;=\{\langle x,y\rangle|x,y\in A\land\psi(x)=\psi(y)\}\tag{11-11}
$$  
是一个等价关系，并称之为由同态映射$\cdot\psi$导出的𝐴上自然等价关系。  
【定理11.13】假设$\langle A,+,\ \times\rangle$和$\langle B,\,\oplus,\,\otimes\,\rangle$是任意两个同态的代数结构，$\psi$：$A\rightarrow B$是其同态映射，则由同态映射$\cdot\psi$导出的自然等价关系：  
$$
\sim\;=\{\langle x,y\rangle|x,y\in A\land\psi(x)=\psi(y)\}
$$  
是一个同余关系。  
事实上，对于代数结构$\langle A,+,\ \times\rangle$上的任意一个同余关系$\sim$，可以构造出一个与之相应的商代数，并且$\langle A,+,\ \times\rangle$与该商代数之间是一种满同态关系，称之为自然同态关系。因此，由同余关系也可以构造出一个与之相应的同态关系，并且该同态映射下的同态像与该商代数之间具体同构关系。具体内容可查阅商代数的相关知识，这里不再赘述。",同态映射导出的等价关系是同余关系
定理11.13,确认,同余关系,,"在整数理论中，我们学过整数之间的同余关系。整数的模$\boldsymbol{\cdot}\boldsymbol{k}$同余关系作为一种等价关系其实是整数相等关系的一种扩展。我们知道，整数之间的相等关系是一种最强的等价关系。 由运算的单值映射性质可知，对于任意两个相等的整数进行某种运算之后仍然保持相等。 现将整数相等关系这种对运算的保持性质推广到一般的等价关系？具体地说，就是对于一个任意给定的代数结构$\langle A,\ *\rangle$，$R$是载体集合𝐴上的一个等价关系，考察在$A$中具有关系𝑅的元素经过运算后是否仍然具有等价关系$R$。由此得到如下同余关系的相关定义：  
【定义11.18】设$\langle A,\ *,\!\triangle\rangle$是一个代数结构，$*$和$\triangle$分别是二元运算和一元运算，$\sim$是载体$𝐴$上的等价关系，对于$\forall a,b,c\in A$且$a{\sim}b$：若有$\triangle\;a\!\sim\triangle\;b$，则称$\sim$是关于运算$△$的同余关系；若有 $a*c{\sim}b*c$ 且 $c*a{\sim}c*b$ ，则称 $\sim$ 是关于运算 ${\ast}$ 的同余关系；若 $\sim$ 是关于 △ 和 $*$ 的同余 关系，则称$\sim$是代数结构$\langle A,\ *,\triangle\rangle$上的同余关系，此时称等价类$[x]_{\sim}$为同余类。  
我们知道，集合𝐴上的等价关系𝑅将𝐴划分为一个一个的等价类，如果𝐴中具有等价关系$R$的元素在运算$^*$下仍然保持等价关系$R$不变，那就说明，集合𝐴在等价关系$R$下的划分在运算$^*$的映射变换下保持不变。具体地说：就是运算$^*$将𝐴中任意彼此等价的两个元素从其所处的等价类映射到另外一个等价类中，如图11.4 所示，图中每个小方格分别代表一个等价类。 此时，可以将运算$^*$看成是对集合𝐴中元素在等价类之间进行的一次置换。  
![](images/fae0b5be5e5b684797945d41e251f779b67578792deb6bd81af14b0e79ffcf00.jpg)
图11.4  同余关系与等价类  
从上述定义可以看出，若等价关系$\sim$在𝐴上的所有运算下都是可保持的，则$\sim$为代数系统$𝐴$上的同余关系。  
【定理11.11】等价关系$\sim$关于二元运算∗是一个同余关系，当且仅当$a{\sim}b$和$c{\sim}d$时，有  
$ a c\sim b d$。  
现在讨论同态和同余之间的联系，首先给出由同态映射导出的一个等价关系：  
【定理11.12】假设$\langle A,+,\ \times\rangle$和$\langle B,\,\oplus,\,\otimes\,\rangle$是任意两个同态的代数结构，$\psi$：$A\rightarrow B$是其同态映射，则集合$\cdot A$中元素在映射$\cdot\psi$下具有同像的关系$\sim$，即有：  
$$
\sim\;=\{\langle x,y\rangle|x,y\in A\land\psi(x)=\psi(y)\}\tag{11-11}
$$  
是一个等价关系，并称之为由同态映射$\cdot\psi$导出的𝐴上自然等价关系。  
【定理11.13】假设$\langle A,+,\ \times\rangle$和$\langle B,\,\oplus,\,\otimes\,\rangle$是任意两个同态的代数结构，$\psi$：$A\rightarrow B$是其同态映射，则由同态映射$\cdot\psi$导出的自然等价关系：  
$$
\sim\;=\{\langle x,y\rangle|x,y\in A\land\psi(x)=\psi(y)\}
$$  
是一个同余关系。  
事实上，对于代数结构$\langle A,+,\ \times\rangle$上的任意一个同余关系$\sim$，可以构造出一个与之相应的商代数，并且$\langle A,+,\ \times\rangle$与该商代数之间是一种满同态关系，称之为自然同态关系。因此，由同余关系也可以构造出一个与之相应的同态关系，并且该同态映射下的同态像与该商代数之间具体同构关系。具体内容可查阅商代数的相关知识，这里不再赘述。",同态映射导出的自然等价关系是同余关系
代数结构,包含,群,,"如前所述，代数结构作为四大数学结构之一，主要研究给定集合上的运算及运算性质。现实世界中的集合和运算种类繁多，不可能通过枚举方法一一进行研究。因此，代数结构主要以抽象集合和抽象运算为其研究对象，考察抽象元素在抽象运算上的一般运算性质，即结合律、交换律、幂等律、消去律、分配律和吸收律这六大二元算律，以及幺元、零元、逆元、幂等元、消去元这五个特殊元素的存在性。当然，不同的具体代数结构对这些运算性质的满足程度也会有所差异。因此，可以这些运算性质为标准对所有的代数结构进行分类，并抽象出一些特殊的代数结构。事实上，前面我们对关系模型的研究也是这样做的：首先给出关系的自反性、反自反性、对称性、反对称性和传递性这五个基本性质，然后就以这五个基本性质为标准考察各个具体的关系模型，并抽象出一些典型的抽象关系模型，例如满足自反性、对称性和传递性的关系为等价关系，满足自反性、对称性的关系为相容关系，满足自反性、反对称性和传递性的关系为偏序关系等。同样，以二元算律和特殊元素为标准也可抽象出很多典型的抽象代数结构，如群、环、域、格等代数结构。  
对这些典型抽象代数结构的分析和讨论是抽象代数领域的主要研究内容。其中群结构由法国天才少年伽罗瓦提出的伽罗瓦群衍生而成，是最早发明也是最重要一种抽象代数结构，不仅在数字加密与编码、形式语言与自动机、组合计算与分析等领域有着非常重要的应用价值，而且关于群的研究方法和思维方式对抽象代数其它分支的研究具有非常重要的影响。如果能够较好地掌握群结构的基本理论和基本方法，则学好环、域、格等其它典型抽象代数就不是一件难事。因此，本章着重考察群结构的基本理论并给出环、域、格的基本知识，具体包括半群的概念与性质、群结构的基本知识、群的同余关系与商群、环与域基本概念与性质、格的基本概念与性质。",群是代数结构的一种典型抽象形式
代数结构,包含,环,,"如前所述，代数结构作为四大数学结构之一，主要研究给定集合上的运算及运算性质。现实世界中的集合和运算种类繁多，不可能通过枚举方法一一进行研究。因此，代数结构主要以抽象集合和抽象运算为其研究对象，考察抽象元素在抽象运算上的一般运算性质，即结合律、交换律、幂等律、消去律、分配律和吸收律这六大二元算律，以及幺元、零元、逆元、幂等元、消去元这五个特殊元素的存在性。当然，不同的具体代数结构对这些运算性质的满足程度也会有所差异。因此，可以这些运算性质为标准对所有的代数结构进行分类，并抽象出一些特殊的代数结构。事实上，前面我们对关系模型的研究也是这样做的：首先给出关系的自反性、反自反性、对称性、反对称性和传递性这五个基本性质，然后就以这五个基本性质为标准考察各个具体的关系模型，并抽象出一些典型的抽象关系模型，例如满足自反性、对称性和传递性的关系为等价关系，满足自反性、对称性的关系为相容关系，满足自反性、反对称性和传递性的关系为偏序关系等。同样，以二元算律和特殊元素为标准也可抽象出很多典型的抽象代数结构，如群、环、域、格等代数结构。  
对这些典型抽象代数结构的分析和讨论是抽象代数领域的主要研究内容。其中群结构由法国天才少年伽罗瓦提出的伽罗瓦群衍生而成，是最早发明也是最重要一种抽象代数结构，不仅在数字加密与编码、形式语言与自动机、组合计算与分析等领域有着非常重要的应用价值，而且关于群的研究方法和思维方式对抽象代数其它分支的研究具有非常重要的影响。如果能够较好地掌握群结构的基本理论和基本方法，则学好环、域、格等其它典型抽象代数就不是一件难事。因此，本章着重考察群结构的基本理论并给出环、域、格的基本知识，具体包括半群的概念与性质、群结构的基本知识、群的同余关系与商群、环与域基本概念与性质、格的基本概念与性质。",环是代数结构的一种典型抽象形式
代数结构,包含,域,,"如前所述，代数结构作为四大数学结构之一，主要研究给定集合上的运算及运算性质。现实世界中的集合和运算种类繁多，不可能通过枚举方法一一进行研究。因此，代数结构主要以抽象集合和抽象运算为其研究对象，考察抽象元素在抽象运算上的一般运算性质，即结合律、交换律、幂等律、消去律、分配律和吸收律这六大二元算律，以及幺元、零元、逆元、幂等元、消去元这五个特殊元素的存在性。当然，不同的具体代数结构对这些运算性质的满足程度也会有所差异。因此，可以这些运算性质为标准对所有的代数结构进行分类，并抽象出一些特殊的代数结构。事实上，前面我们对关系模型的研究也是这样做的：首先给出关系的自反性、反自反性、对称性、反对称性和传递性这五个基本性质，然后就以这五个基本性质为标准考察各个具体的关系模型，并抽象出一些典型的抽象关系模型，例如满足自反性、对称性和传递性的关系为等价关系，满足自反性、对称性的关系为相容关系，满足自反性、反对称性和传递性的关系为偏序关系等。同样，以二元算律和特殊元素为标准也可抽象出很多典型的抽象代数结构，如群、环、域、格等代数结构。  
对这些典型抽象代数结构的分析和讨论是抽象代数领域的主要研究内容。其中群结构由法国天才少年伽罗瓦提出的伽罗瓦群衍生而成，是最早发明也是最重要一种抽象代数结构，不仅在数字加密与编码、形式语言与自动机、组合计算与分析等领域有着非常重要的应用价值，而且关于群的研究方法和思维方式对抽象代数其它分支的研究具有非常重要的影响。如果能够较好地掌握群结构的基本理论和基本方法，则学好环、域、格等其它典型抽象代数就不是一件难事。因此，本章着重考察群结构的基本理论并给出环、域、格的基本知识，具体包括半群的概念与性质、群结构的基本知识、群的同余关系与商群、环与域基本概念与性质、格的基本概念与性质。",域是代数结构的一种典型抽象形式
代数结构,包含,格,,"如前所述，代数结构作为四大数学结构之一，主要研究给定集合上的运算及运算性质。现实世界中的集合和运算种类繁多，不可能通过枚举方法一一进行研究。因此，代数结构主要以抽象集合和抽象运算为其研究对象，考察抽象元素在抽象运算上的一般运算性质，即结合律、交换律、幂等律、消去律、分配律和吸收律这六大二元算律，以及幺元、零元、逆元、幂等元、消去元这五个特殊元素的存在性。当然，不同的具体代数结构对这些运算性质的满足程度也会有所差异。因此，可以这些运算性质为标准对所有的代数结构进行分类，并抽象出一些特殊的代数结构。事实上，前面我们对关系模型的研究也是这样做的：首先给出关系的自反性、反自反性、对称性、反对称性和传递性这五个基本性质，然后就以这五个基本性质为标准考察各个具体的关系模型，并抽象出一些典型的抽象关系模型，例如满足自反性、对称性和传递性的关系为等价关系，满足自反性、对称性的关系为相容关系，满足自反性、反对称性和传递性的关系为偏序关系等。同样，以二元算律和特殊元素为标准也可抽象出很多典型的抽象代数结构，如群、环、域、格等代数结构。  
对这些典型抽象代数结构的分析和讨论是抽象代数领域的主要研究内容。其中群结构由法国天才少年伽罗瓦提出的伽罗瓦群衍生而成，是最早发明也是最重要一种抽象代数结构，不仅在数字加密与编码、形式语言与自动机、组合计算与分析等领域有着非常重要的应用价值，而且关于群的研究方法和思维方式对抽象代数其它分支的研究具有非常重要的影响。如果能够较好地掌握群结构的基本理论和基本方法，则学好环、域、格等其它典型抽象代数就不是一件难事。因此，本章着重考察群结构的基本理论并给出环、域、格的基本知识，具体包括半群的概念与性质、群结构的基本知识、群的同余关系与商群、环与域基本概念与性质、格的基本概念与性质。",格是代数结构的一种典型抽象形式
群,相关,同余关系,,"如前所述，代数结构作为四大数学结构之一，主要研究给定集合上的运算及运算性质。现实世界中的集合和运算种类繁多，不可能通过枚举方法一一进行研究。因此，代数结构主要以抽象集合和抽象运算为其研究对象，考察抽象元素在抽象运算上的一般运算性质，即结合律、交换律、幂等律、消去律、分配律和吸收律这六大二元算律，以及幺元、零元、逆元、幂等元、消去元这五个特殊元素的存在性。当然，不同的具体代数结构对这些运算性质的满足程度也会有所差异。因此，可以这些运算性质为标准对所有的代数结构进行分类，并抽象出一些特殊的代数结构。事实上，前面我们对关系模型的研究也是这样做的：首先给出关系的自反性、反自反性、对称性、反对称性和传递性这五个基本性质，然后就以这五个基本性质为标准考察各个具体的关系模型，并抽象出一些典型的抽象关系模型，例如满足自反性、对称性和传递性的关系为等价关系，满足自反性、对称性的关系为相容关系，满足自反性、反对称性和传递性的关系为偏序关系等。同样，以二元算律和特殊元素为标准也可抽象出很多典型的抽象代数结构，如群、环、域、格等代数结构。  
对这些典型抽象代数结构的分析和讨论是抽象代数领域的主要研究内容。其中群结构由法国天才少年伽罗瓦提出的伽罗瓦群衍生而成，是最早发明也是最重要一种抽象代数结构，不仅在数字加密与编码、形式语言与自动机、组合计算与分析等领域有着非常重要的应用价值，而且关于群的研究方法和思维方式对抽象代数其它分支的研究具有非常重要的影响。如果能够较好地掌握群结构的基本理论和基本方法，则学好环、域、格等其它典型抽象代数就不是一件难事。因此，本章着重考察群结构的基本理论并给出环、域、格的基本知识，具体包括半群的概念与性质、群结构的基本知识、群的同余关系与商群、环与域基本概念与性质、格的基本概念与性质。",群的研究包括对其同余关系及商群的探讨
代数结构,包含,半群,,"如前所述，代数结构作为四大数学结构之一，主要研究给定集合上的运算及运算性质。现实世界中的集合和运算种类繁多，不可能通过枚举方法一一进行研究。因此，代数结构主要以抽象集合和抽象运算为其研究对象，考察抽象元素在抽象运算上的一般运算性质，即结合律、交换律、幂等律、消去律、分配律和吸收律这六大二元算律，以及幺元、零元、逆元、幂等元、消去元这五个特殊元素的存在性。当然，不同的具体代数结构对这些运算性质的满足程度也会有所差异。因此，可以这些运算性质为标准对所有的代数结构进行分类，并抽象出一些特殊的代数结构。事实上，前面我们对关系模型的研究也是这样做的：首先给出关系的自反性、反自反性、对称性、反对称性和传递性这五个基本性质，然后就以这五个基本性质为标准考察各个具体的关系模型，并抽象出一些典型的抽象关系模型，例如满足自反性、对称性和传递性的关系为等价关系，满足自反性、对称性的关系为相容关系，满足自反性、反对称性和传递性的关系为偏序关系等。同样，以二元算律和特殊元素为标准也可抽象出很多典型的抽象代数结构，如群、环、域、格等代数结构。  
对这些典型抽象代数结构的分析和讨论是抽象代数领域的主要研究内容。其中群结构由法国天才少年伽罗瓦提出的伽罗瓦群衍生而成，是最早发明也是最重要一种抽象代数结构，不仅在数字加密与编码、形式语言与自动机、组合计算与分析等领域有着非常重要的应用价值，而且关于群的研究方法和思维方式对抽象代数其它分支的研究具有非常重要的影响。如果能够较好地掌握群结构的基本理论和基本方法，则学好环、域、格等其它典型抽象代数就不是一件难事。因此，本章着重考察群结构的基本理论并给出环、域、格的基本知识，具体包括半群的概念与性质、群结构的基本知识、群的同余关系与商群、环与域基本概念与性质、格的基本概念与性质。",半群是代数结构的一种形式，包含在代数结构的研究范围内
半群,包含,含幺半群,,"与群相关的抽象代数结构有很多个，其共同特征是只含一个二元运算，具体包括广群、半群、含幺半群、群、交换群等。如图12-1 所示，这些抽象代数结构按照由一般到特殊的次序逐步递进。其中：广群是最具一般性，只需满足运算的封闭性即可，其实就是一般的只含一个二元运算的代数结构或代数系统；半群则比广群稍微特殊一些，即在广群的基础上增加一个满足结合律的限制；含幺半群则是在半群的基础上再增加存在单位元的限制；群则是在含幺半群的基础上再增加存在逆元的限制，即要求半群不仅含有单位元，而且还必须保证载体集合中每个元素都必须含有逆元；交换群则是一种满足交换律的特殊群。  
![](images/c6e03e109e469ca83f4980264e0b87779198ee1bcaf3a206ea39fe5f280b87e9.jpg)
图12-1 与群相关的抽象代数结构  
我们将按照图12-1-1 所示次序展开讨论，其中广群作为最一般的代数结构在前面第十一章已做介绍。因此，本节着重介绍半群的基本理论，主要包括半群、含幺半群、元素方幂、循环半群的基本概念与性质。",含幺半群是半群的一种，增加了存在单位元的限制
含幺半群,包含,群,,"与群相关的抽象代数结构有很多个，其共同特征是只含一个二元运算，具体包括广群、半群、含幺半群、群、交换群等。如图12-1 所示，这些抽象代数结构按照由一般到特殊的次序逐步递进。其中：广群是最具一般性，只需满足运算的封闭性即可，其实就是一般的只含一个二元运算的代数结构或代数系统；半群则比广群稍微特殊一些，即在广群的基础上增加一个满足结合律的限制；含幺半群则是在半群的基础上再增加存在单位元的限制；群则是在含幺半群的基础上再增加存在逆元的限制，即要求半群不仅含有单位元，而且还必须保证载体集合中每个元素都必须含有逆元；交换群则是一种满足交换律的特殊群。  
![](images/c6e03e109e469ca83f4980264e0b87779198ee1bcaf3a206ea39fe5f280b87e9.jpg)
图12-1 与群相关的抽象代数结构  
我们将按照图12-1-1 所示次序展开讨论，其中广群作为最一般的代数结构在前面第十一章已做介绍。因此，本节着重介绍半群的基本理论，主要包括半群、含幺半群、元素方幂、循环半群的基本概念与性质。",群是含幺半群的一种，增加了存在逆元的限制
群,包含,交换群,,"与群相关的抽象代数结构有很多个，其共同特征是只含一个二元运算，具体包括广群、半群、含幺半群、群、交换群等。如图12-1 所示，这些抽象代数结构按照由一般到特殊的次序逐步递进。其中：广群是最具一般性，只需满足运算的封闭性即可，其实就是一般的只含一个二元运算的代数结构或代数系统；半群则比广群稍微特殊一些，即在广群的基础上增加一个满足结合律的限制；含幺半群则是在半群的基础上再增加存在单位元的限制；群则是在含幺半群的基础上再增加存在逆元的限制，即要求半群不仅含有单位元，而且还必须保证载体集合中每个元素都必须含有逆元；交换群则是一种满足交换律的特殊群。  
![](images/c6e03e109e469ca83f4980264e0b87779198ee1bcaf3a206ea39fe5f280b87e9.jpg)
图12-1 与群相关的抽象代数结构  
我们将按照图12-1-1 所示次序展开讨论，其中广群作为最一般的代数结构在前面第十一章已做介绍。因此，本节着重介绍半群的基本理论，主要包括半群、含幺半群、元素方幂、循环半群的基本概念与性质。",交换群是满足交换律的特殊群
半群,相关,元素方幂,,"与群相关的抽象代数结构有很多个，其共同特征是只含一个二元运算，具体包括广群、半群、含幺半群、群、交换群等。如图12-1 所示，这些抽象代数结构按照由一般到特殊的次序逐步递进。其中：广群是最具一般性，只需满足运算的封闭性即可，其实就是一般的只含一个二元运算的代数结构或代数系统；半群则比广群稍微特殊一些，即在广群的基础上增加一个满足结合律的限制；含幺半群则是在半群的基础上再增加存在单位元的限制；群则是在含幺半群的基础上再增加存在逆元的限制，即要求半群不仅含有单位元，而且还必须保证载体集合中每个元素都必须含有逆元；交换群则是一种满足交换律的特殊群。  
![](images/c6e03e109e469ca83f4980264e0b87779198ee1bcaf3a206ea39fe5f280b87e9.jpg)
图12-1 与群相关的抽象代数结构  
我们将按照图12-1-1 所示次序展开讨论，其中广群作为最一般的代数结构在前面第十一章已做介绍。因此，本节着重介绍半群的基本理论，主要包括半群、含幺半群、元素方幂、循环半群的基本概念与性质。",元素方幂是半群中的一个基本概念
半群,包含,循环半群,,"与群相关的抽象代数结构有很多个，其共同特征是只含一个二元运算，具体包括广群、半群、含幺半群、群、交换群等。如图12-1 所示，这些抽象代数结构按照由一般到特殊的次序逐步递进。其中：广群是最具一般性，只需满足运算的封闭性即可，其实就是一般的只含一个二元运算的代数结构或代数系统；半群则比广群稍微特殊一些，即在广群的基础上增加一个满足结合律的限制；含幺半群则是在半群的基础上再增加存在单位元的限制；群则是在含幺半群的基础上再增加存在逆元的限制，即要求半群不仅含有单位元，而且还必须保证载体集合中每个元素都必须含有逆元；交换群则是一种满足交换律的特殊群。  
![](images/c6e03e109e469ca83f4980264e0b87779198ee1bcaf3a206ea39fe5f280b87e9.jpg)
图12-1 与群相关的抽象代数结构  
我们将按照图12-1-1 所示次序展开讨论，其中广群作为最一般的代数结构在前面第十一章已做介绍。因此，本节着重介绍半群的基本理论，主要包括半群、含幺半群、元素方幂、循环半群的基本概念与性质。",循环半群是半群的一种特殊类型
半群,包含,含幺半群,,"半群是一种比较简单而基本的抽象代数结构，要求其载体上的二元运算满足封闭性和结合律。半群的具体定义如下：  
【定义12.1】假设$G$是任意给定的一个非空集合，$*$为$G$上的一个二元运算且满足结合律，即对于$\forall $$\mathrm x,\mathrm{y,z\in~}G$，成立：  
$$
(x\circ y)\circ z=x\circ(y\circ z)\quad\text{(12-1)}
$$  
则称由𝐴和*组成的二元代数结构$\langle G,\ *\rangle$是一个半群。  
半群是一种非常常见的抽象代数结构，例如$\langle R, +\rangle_、\ \langle R,\ \times\rangle_、\ \langle P(A),\ \cup\rangle_、\ \langle P(A),\ \cap\rangle_、$$\langle A^{A},\ \circ\rangle$、$\langle M_{n}(R),\ +\rangle$、$\langle M_{n}(R)$, ⋅〉等，都是半群。  
在上述定义中，由于运算$*$为集合$G$上的二元运算，故对$G$满足运算的封闭性。因此，运算满足封闭性和结合律是半群的两个基本特征。另外，一般习惯上使用字母$G$表示群代数结构的载体集合，我们一般遵循这种习惯并总是假定$G$为非空集合。  
【定义12.2】假设$\langle G,\ *\rangle$是任意给定的一个半群，如果$\langle G,\ *\rangle$中含有关于运算${\ast}$的单位元𝑒，则称$\langle G,\ *\rangle$是一个含幺半群或独异点，记为$\langle G,\ *,\ e\rangle$。  
从上述定义可以看出，所谓含幺半群，其实就是一种含有幺元或单位元的特殊半群。例如$\mathsf\langle R,\ +\rangle_、\ \langle R,\ \times\rangle_、\ \langle P(A),\ \cup\rangle_、\ \langle P(A),\ \cap\rangle_、\ \langle A^{A},\ \circ\rangle_、\ \langle M_{n}(R),\ +\rangle_、\ \langle M_{n}(R),\ \cdot\}$ 等，都是含幺半群，0、1、空集$\varnothing$、全集$𝐴$、恒等映射、零矩阵、单位矩阵分别是其幺元。但是，$\langle R^{+},~+\rangle$则不是一个含幺半群，因为$R^{+}$作为正实数集合没有运算${+}$的单位元。  
【定义12.3】假设$\langle G,\ *\rangle$是一个半群，$S$是$G$的一个非空子集且运算$^*$对𝑆封闭，则称$\langle S,\ *\rangle$是$\langle G,\ *\rangle$的一个子半群；假设$\langle G,*,e\rangle$是一个含幺半群，$S$是$G$的一个非空子集且运算$^*$对𝑆封闭，则称$\langle S,*,e\rangle$是$\langle G,*,e\rangle$的一个子含幺半群。  
例如，对于含幺半群$\left<Z,\ +\right>$，令$Z_{n}=\{n x|x\in Z\}$，则对于$ n$取任何自然数，$\left\langle Z_{n},\ +\right\rangle$显然是$\left\langle Z,\ +\right\rangle$含幺子半群，且整数0 既是$\langle Z,\ +\rangle$的单位元也是$\left\langle Z_{n},\ +\right\rangle$的单位元。  
【定义12.4】假设$\langle G,*\rangle$和$\langle H,\circ\rangle$是任意给定的两个半群，如果存在从$G$到$H$的保运算映射  
$\psi$，即对于$\forall x,y\in G$，满足：  
$$
\psi(x*y)=\psi(x)\circ\psi(y)\quad\text{(12-5)}
$$  
则称$\psi$为从$\langle G,*\rangle$到$\langle H,\circ\rangle$的一个同态映射，并称$\langle G,*\rangle$与$\langle H,\circ\rangle$为同态。若$\psi$为单射，则称$\langle G,*\rangle$与$\langle H,\circ\rangle$为单同态；若$\psi$为满射，则称$\langle G,*\rangle$与$\langle H,\circ\rangle$为满同态；若$\psi$为双射，则称$\mathcal{\Psi}$为同构映射，并称$\langle G,*\rangle$与$\langle H,\circ\rangle$为同构。  
【定义12.5】假设$\langle G,*,e\rangle$和$\langle H,\circ,r\rangle$是任意给定的两个含幺半群，如果存在从$G$到$H$的保运算映射$\psi$，即对于$\forall x,y\in G$，满足：  
$$
\psi(x*y)=\psi(x)\circ\psi(y)\mathbb且\psi(e)=r
$$  
则称$\psi$为从$\langle G,*,e\rangle$到$\langle H,\circ,r\rangle$的一个同态映射，并称$\langle G,*,e\rangle$与$\langle H,\circ,r\rangle$为同态。若$\psi$为单射，则称 $\langle G,*,e\rangle$ 与 $\langle H,\circ,r\rangle$ 为单同态；若 $\psi$ 为满射，则称 $\langle G,*,e\rangle$ 与 $\langle H,\circ,r\rangle$ 为满同态；若 $\psi$ 为双射，则 称$\psi$为同构映射，并称$\langle G,*,e\rangle$与$\langle H,\circ,r\rangle$为同构。  
由于同构或同态的代数结构之间具有很多相同或相似的性质，因此，可在一般抽象代数结构与某个具体的代数结构之间建立一种同构或同态关系，通过比较直观考察具体代数结构的运算性质来研究一般抽象代数结构的运算性质，从而得到普适性的结论。这是研究和考察抽象代数结构的一种典型方法。下面结合具体实例介绍这种方法：",含幺半群是含有单位元的特殊半群
半群,包含,子半群,,"半群是一种比较简单而基本的抽象代数结构，要求其载体上的二元运算满足封闭性和结合律。半群的具体定义如下：  
【定义12.1】假设$G$是任意给定的一个非空集合，$*$为$G$上的一个二元运算且满足结合律，即对于$\forall $$\mathrm x,\mathrm{y,z\in~}G$，成立：  
$$
(x\circ y)\circ z=x\circ(y\circ z)\quad\text{(12-1)}
$$  
则称由𝐴和*组成的二元代数结构$\langle G,\ *\rangle$是一个半群。  
半群是一种非常常见的抽象代数结构，例如$\langle R, +\rangle_、\ \langle R,\ \times\rangle_、\ \langle P(A),\ \cup\rangle_、\ \langle P(A),\ \cap\rangle_、$$\langle A^{A},\ \circ\rangle$、$\langle M_{n}(R),\ +\rangle$、$\langle M_{n}(R)$, ⋅〉等，都是半群。  
在上述定义中，由于运算$*$为集合$G$上的二元运算，故对$G$满足运算的封闭性。因此，运算满足封闭性和结合律是半群的两个基本特征。另外，一般习惯上使用字母$G$表示群代数结构的载体集合，我们一般遵循这种习惯并总是假定$G$为非空集合。  
【定义12.2】假设$\langle G,\ *\rangle$是任意给定的一个半群，如果$\langle G,\ *\rangle$中含有关于运算${\ast}$的单位元𝑒，则称$\langle G,\ *\rangle$是一个含幺半群或独异点，记为$\langle G,\ *,\ e\rangle$。  
从上述定义可以看出，所谓含幺半群，其实就是一种含有幺元或单位元的特殊半群。例如$\mathsf\langle R,\ +\rangle_、\ \langle R,\ \times\rangle_、\ \langle P(A),\ \cup\rangle_、\ \langle P(A),\ \cap\rangle_、\ \langle A^{A},\ \circ\rangle_、\ \langle M_{n}(R),\ +\rangle_、\ \langle M_{n}(R),\ \cdot\}$ 等，都是含幺半群，0、1、空集$\varnothing$、全集$𝐴$、恒等映射、零矩阵、单位矩阵分别是其幺元。但是，$\langle R^{+},~+\rangle$则不是一个含幺半群，因为$R^{+}$作为正实数集合没有运算${+}$的单位元。  
【定义12.3】假设$\langle G,\ *\rangle$是一个半群，$S$是$G$的一个非空子集且运算$^*$对𝑆封闭，则称$\langle S,\ *\rangle$是$\langle G,\ *\rangle$的一个子半群；假设$\langle G,*,e\rangle$是一个含幺半群，$S$是$G$的一个非空子集且运算$^*$对𝑆封闭，则称$\langle S,*,e\rangle$是$\langle G,*,e\rangle$的一个子含幺半群。  
例如，对于含幺半群$\left<Z,\ +\right>$，令$Z_{n}=\{n x|x\in Z\}$，则对于$ n$取任何自然数，$\left\langle Z_{n},\ +\right\rangle$显然是$\left\langle Z,\ +\right\rangle$含幺子半群，且整数0 既是$\langle Z,\ +\rangle$的单位元也是$\left\langle Z_{n},\ +\right\rangle$的单位元。  
【定义12.4】假设$\langle G,*\rangle$和$\langle H,\circ\rangle$是任意给定的两个半群，如果存在从$G$到$H$的保运算映射  
$\psi$，即对于$\forall x,y\in G$，满足：  
$$
\psi(x*y)=\psi(x)\circ\psi(y)\quad\text{(12-5)}
$$  
则称$\psi$为从$\langle G,*\rangle$到$\langle H,\circ\rangle$的一个同态映射，并称$\langle G,*\rangle$与$\langle H,\circ\rangle$为同态。若$\psi$为单射，则称$\langle G,*\rangle$与$\langle H,\circ\rangle$为单同态；若$\psi$为满射，则称$\langle G,*\rangle$与$\langle H,\circ\rangle$为满同态；若$\psi$为双射，则称$\mathcal{\Psi}$为同构映射，并称$\langle G,*\rangle$与$\langle H,\circ\rangle$为同构。  
【定义12.5】假设$\langle G,*,e\rangle$和$\langle H,\circ,r\rangle$是任意给定的两个含幺半群，如果存在从$G$到$H$的保运算映射$\psi$，即对于$\forall x,y\in G$，满足：  
$$
\psi(x*y)=\psi(x)\circ\psi(y)\mathbb且\psi(e)=r
$$  
则称$\psi$为从$\langle G,*,e\rangle$到$\langle H,\circ,r\rangle$的一个同态映射，并称$\langle G,*,e\rangle$与$\langle H,\circ,r\rangle$为同态。若$\psi$为单射，则称 $\langle G,*,e\rangle$ 与 $\langle H,\circ,r\rangle$ 为单同态；若 $\psi$ 为满射，则称 $\langle G,*,e\rangle$ 与 $\langle H,\circ,r\rangle$ 为满同态；若 $\psi$ 为双射，则 称$\psi$为同构映射，并称$\langle G,*,e\rangle$与$\langle H,\circ,r\rangle$为同构。  
由于同构或同态的代数结构之间具有很多相同或相似的性质，因此，可在一般抽象代数结构与某个具体的代数结构之间建立一种同构或同态关系，通过比较直观考察具体代数结构的运算性质来研究一般抽象代数结构的运算性质，从而得到普适性的结论。这是研究和考察抽象代数结构的一种典型方法。下面结合具体实例介绍这种方法：",子半群是半群的一个非空子集且运算封闭
含幺半群,包含,子含幺半群,,"半群是一种比较简单而基本的抽象代数结构，要求其载体上的二元运算满足封闭性和结合律。半群的具体定义如下：  
【定义12.1】假设$G$是任意给定的一个非空集合，$*$为$G$上的一个二元运算且满足结合律，即对于$\forall $$\mathrm x,\mathrm{y,z\in~}G$，成立：  
$$
(x\circ y)\circ z=x\circ(y\circ z)\quad\text{(12-1)}
$$  
则称由𝐴和*组成的二元代数结构$\langle G,\ *\rangle$是一个半群。  
半群是一种非常常见的抽象代数结构，例如$\langle R, +\rangle_、\ \langle R,\ \times\rangle_、\ \langle P(A),\ \cup\rangle_、\ \langle P(A),\ \cap\rangle_、$$\langle A^{A},\ \circ\rangle$、$\langle M_{n}(R),\ +\rangle$、$\langle M_{n}(R)$, ⋅〉等，都是半群。  
在上述定义中，由于运算$*$为集合$G$上的二元运算，故对$G$满足运算的封闭性。因此，运算满足封闭性和结合律是半群的两个基本特征。另外，一般习惯上使用字母$G$表示群代数结构的载体集合，我们一般遵循这种习惯并总是假定$G$为非空集合。  
【定义12.2】假设$\langle G,\ *\rangle$是任意给定的一个半群，如果$\langle G,\ *\rangle$中含有关于运算${\ast}$的单位元𝑒，则称$\langle G,\ *\rangle$是一个含幺半群或独异点，记为$\langle G,\ *,\ e\rangle$。  
从上述定义可以看出，所谓含幺半群，其实就是一种含有幺元或单位元的特殊半群。例如$\mathsf\langle R,\ +\rangle_、\ \langle R,\ \times\rangle_、\ \langle P(A),\ \cup\rangle_、\ \langle P(A),\ \cap\rangle_、\ \langle A^{A},\ \circ\rangle_、\ \langle M_{n}(R),\ +\rangle_、\ \langle M_{n}(R),\ \cdot\}$ 等，都是含幺半群，0、1、空集$\varnothing$、全集$𝐴$、恒等映射、零矩阵、单位矩阵分别是其幺元。但是，$\langle R^{+},~+\rangle$则不是一个含幺半群，因为$R^{+}$作为正实数集合没有运算${+}$的单位元。  
【定义12.3】假设$\langle G,\ *\rangle$是一个半群，$S$是$G$的一个非空子集且运算$^*$对𝑆封闭，则称$\langle S,\ *\rangle$是$\langle G,\ *\rangle$的一个子半群；假设$\langle G,*,e\rangle$是一个含幺半群，$S$是$G$的一个非空子集且运算$^*$对𝑆封闭，则称$\langle S,*,e\rangle$是$\langle G,*,e\rangle$的一个子含幺半群。  
例如，对于含幺半群$\left<Z,\ +\right>$，令$Z_{n}=\{n x|x\in Z\}$，则对于$ n$取任何自然数，$\left\langle Z_{n},\ +\right\rangle$显然是$\left\langle Z,\ +\right\rangle$含幺子半群，且整数0 既是$\langle Z,\ +\rangle$的单位元也是$\left\langle Z_{n},\ +\right\rangle$的单位元。  
【定义12.4】假设$\langle G,*\rangle$和$\langle H,\circ\rangle$是任意给定的两个半群，如果存在从$G$到$H$的保运算映射  
$\psi$，即对于$\forall x,y\in G$，满足：  
$$
\psi(x*y)=\psi(x)\circ\psi(y)\quad\text{(12-5)}
$$  
则称$\psi$为从$\langle G,*\rangle$到$\langle H,\circ\rangle$的一个同态映射，并称$\langle G,*\rangle$与$\langle H,\circ\rangle$为同态。若$\psi$为单射，则称$\langle G,*\rangle$与$\langle H,\circ\rangle$为单同态；若$\psi$为满射，则称$\langle G,*\rangle$与$\langle H,\circ\rangle$为满同态；若$\psi$为双射，则称$\mathcal{\Psi}$为同构映射，并称$\langle G,*\rangle$与$\langle H,\circ\rangle$为同构。  
【定义12.5】假设$\langle G,*,e\rangle$和$\langle H,\circ,r\rangle$是任意给定的两个含幺半群，如果存在从$G$到$H$的保运算映射$\psi$，即对于$\forall x,y\in G$，满足：  
$$
\psi(x*y)=\psi(x)\circ\psi(y)\mathbb且\psi(e)=r
$$  
则称$\psi$为从$\langle G,*,e\rangle$到$\langle H,\circ,r\rangle$的一个同态映射，并称$\langle G,*,e\rangle$与$\langle H,\circ,r\rangle$为同态。若$\psi$为单射，则称 $\langle G,*,e\rangle$ 与 $\langle H,\circ,r\rangle$ 为单同态；若 $\psi$ 为满射，则称 $\langle G,*,e\rangle$ 与 $\langle H,\circ,r\rangle$ 为满同态；若 $\psi$ 为双射，则 称$\psi$为同构映射，并称$\langle G,*,e\rangle$与$\langle H,\circ,r\rangle$为同构。  
由于同构或同态的代数结构之间具有很多相同或相似的性质，因此，可在一般抽象代数结构与某个具体的代数结构之间建立一种同构或同态关系，通过比较直观考察具体代数结构的运算性质来研究一般抽象代数结构的运算性质，从而得到普适性的结论。这是研究和考察抽象代数结构的一种典型方法。下面结合具体实例介绍这种方法：",子含幺半群是含幺半群的一个非空子集且运算封闭
半群,存在,同态映射,,"半群是一种比较简单而基本的抽象代数结构，要求其载体上的二元运算满足封闭性和结合律。半群的具体定义如下：  
【定义12.1】假设$G$是任意给定的一个非空集合，$*$为$G$上的一个二元运算且满足结合律，即对于$\forall $$\mathrm x,\mathrm{y,z\in~}G$，成立：  
$$
(x\circ y)\circ z=x\circ(y\circ z)\quad\text{(12-1)}
$$  
则称由𝐴和*组成的二元代数结构$\langle G,\ *\rangle$是一个半群。  
半群是一种非常常见的抽象代数结构，例如$\langle R, +\rangle_、\ \langle R,\ \times\rangle_、\ \langle P(A),\ \cup\rangle_、\ \langle P(A),\ \cap\rangle_、$$\langle A^{A},\ \circ\rangle$、$\langle M_{n}(R),\ +\rangle$、$\langle M_{n}(R)$, ⋅〉等，都是半群。  
在上述定义中，由于运算$*$为集合$G$上的二元运算，故对$G$满足运算的封闭性。因此，运算满足封闭性和结合律是半群的两个基本特征。另外，一般习惯上使用字母$G$表示群代数结构的载体集合，我们一般遵循这种习惯并总是假定$G$为非空集合。  
【定义12.2】假设$\langle G,\ *\rangle$是任意给定的一个半群，如果$\langle G,\ *\rangle$中含有关于运算${\ast}$的单位元𝑒，则称$\langle G,\ *\rangle$是一个含幺半群或独异点，记为$\langle G,\ *,\ e\rangle$。  
从上述定义可以看出，所谓含幺半群，其实就是一种含有幺元或单位元的特殊半群。例如$\mathsf\langle R,\ +\rangle_、\ \langle R,\ \times\rangle_、\ \langle P(A),\ \cup\rangle_、\ \langle P(A),\ \cap\rangle_、\ \langle A^{A},\ \circ\rangle_、\ \langle M_{n}(R),\ +\rangle_、\ \langle M_{n}(R),\ \cdot\}$ 等，都是含幺半群，0、1、空集$\varnothing$、全集$𝐴$、恒等映射、零矩阵、单位矩阵分别是其幺元。但是，$\langle R^{+},~+\rangle$则不是一个含幺半群，因为$R^{+}$作为正实数集合没有运算${+}$的单位元。  
【定义12.3】假设$\langle G,\ *\rangle$是一个半群，$S$是$G$的一个非空子集且运算$^*$对𝑆封闭，则称$\langle S,\ *\rangle$是$\langle G,\ *\rangle$的一个子半群；假设$\langle G,*,e\rangle$是一个含幺半群，$S$是$G$的一个非空子集且运算$^*$对𝑆封闭，则称$\langle S,*,e\rangle$是$\langle G,*,e\rangle$的一个子含幺半群。  
例如，对于含幺半群$\left<Z,\ +\right>$，令$Z_{n}=\{n x|x\in Z\}$，则对于$ n$取任何自然数，$\left\langle Z_{n},\ +\right\rangle$显然是$\left\langle Z,\ +\right\rangle$含幺子半群，且整数0 既是$\langle Z,\ +\rangle$的单位元也是$\left\langle Z_{n},\ +\right\rangle$的单位元。  
【定义12.4】假设$\langle G,*\rangle$和$\langle H,\circ\rangle$是任意给定的两个半群，如果存在从$G$到$H$的保运算映射  
$\psi$，即对于$\forall x,y\in G$，满足：  
$$
\psi(x*y)=\psi(x)\circ\psi(y)\quad\text{(12-5)}
$$  
则称$\psi$为从$\langle G,*\rangle$到$\langle H,\circ\rangle$的一个同态映射，并称$\langle G,*\rangle$与$\langle H,\circ\rangle$为同态。若$\psi$为单射，则称$\langle G,*\rangle$与$\langle H,\circ\rangle$为单同态；若$\psi$为满射，则称$\langle G,*\rangle$与$\langle H,\circ\rangle$为满同态；若$\psi$为双射，则称$\mathcal{\Psi}$为同构映射，并称$\langle G,*\rangle$与$\langle H,\circ\rangle$为同构。  
【定义12.5】假设$\langle G,*,e\rangle$和$\langle H,\circ,r\rangle$是任意给定的两个含幺半群，如果存在从$G$到$H$的保运算映射$\psi$，即对于$\forall x,y\in G$，满足：  
$$
\psi(x*y)=\psi(x)\circ\psi(y)\mathbb且\psi(e)=r
$$  
则称$\psi$为从$\langle G,*,e\rangle$到$\langle H,\circ,r\rangle$的一个同态映射，并称$\langle G,*,e\rangle$与$\langle H,\circ,r\rangle$为同态。若$\psi$为单射，则称 $\langle G,*,e\rangle$ 与 $\langle H,\circ,r\rangle$ 为单同态；若 $\psi$ 为满射，则称 $\langle G,*,e\rangle$ 与 $\langle H,\circ,r\rangle$ 为满同态；若 $\psi$ 为双射，则 称$\psi$为同构映射，并称$\langle G,*,e\rangle$与$\langle H,\circ,r\rangle$为同构。  
由于同构或同态的代数结构之间具有很多相同或相似的性质，因此，可在一般抽象代数结构与某个具体的代数结构之间建立一种同构或同态关系，通过比较直观考察具体代数结构的运算性质来研究一般抽象代数结构的运算性质，从而得到普适性的结论。这是研究和考察抽象代数结构的一种典型方法。下面结合具体实例介绍这种方法：",同态映射是保运算的映射，存在于两个半群之间
含幺半群,存在,同态映射,,"半群是一种比较简单而基本的抽象代数结构，要求其载体上的二元运算满足封闭性和结合律。半群的具体定义如下：  
【定义12.1】假设$G$是任意给定的一个非空集合，$*$为$G$上的一个二元运算且满足结合律，即对于$\forall $$\mathrm x,\mathrm{y,z\in~}G$，成立：  
$$
(x\circ y)\circ z=x\circ(y\circ z)\quad\text{(12-1)}
$$  
则称由𝐴和*组成的二元代数结构$\langle G,\ *\rangle$是一个半群。  
半群是一种非常常见的抽象代数结构，例如$\langle R, +\rangle_、\ \langle R,\ \times\rangle_、\ \langle P(A),\ \cup\rangle_、\ \langle P(A),\ \cap\rangle_、$$\langle A^{A},\ \circ\rangle$、$\langle M_{n}(R),\ +\rangle$、$\langle M_{n}(R)$, ⋅〉等，都是半群。  
在上述定义中，由于运算$*$为集合$G$上的二元运算，故对$G$满足运算的封闭性。因此，运算满足封闭性和结合律是半群的两个基本特征。另外，一般习惯上使用字母$G$表示群代数结构的载体集合，我们一般遵循这种习惯并总是假定$G$为非空集合。  
【定义12.2】假设$\langle G,\ *\rangle$是任意给定的一个半群，如果$\langle G,\ *\rangle$中含有关于运算${\ast}$的单位元𝑒，则称$\langle G,\ *\rangle$是一个含幺半群或独异点，记为$\langle G,\ *,\ e\rangle$。  
从上述定义可以看出，所谓含幺半群，其实就是一种含有幺元或单位元的特殊半群。例如$\mathsf\langle R,\ +\rangle_、\ \langle R,\ \times\rangle_、\ \langle P(A),\ \cup\rangle_、\ \langle P(A),\ \cap\rangle_、\ \langle A^{A},\ \circ\rangle_、\ \langle M_{n}(R),\ +\rangle_、\ \langle M_{n}(R),\ \cdot\}$ 等，都是含幺半群，0、1、空集$\varnothing$、全集$𝐴$、恒等映射、零矩阵、单位矩阵分别是其幺元。但是，$\langle R^{+},~+\rangle$则不是一个含幺半群，因为$R^{+}$作为正实数集合没有运算${+}$的单位元。  
【定义12.3】假设$\langle G,\ *\rangle$是一个半群，$S$是$G$的一个非空子集且运算$^*$对𝑆封闭，则称$\langle S,\ *\rangle$是$\langle G,\ *\rangle$的一个子半群；假设$\langle G,*,e\rangle$是一个含幺半群，$S$是$G$的一个非空子集且运算$^*$对𝑆封闭，则称$\langle S,*,e\rangle$是$\langle G,*,e\rangle$的一个子含幺半群。  
例如，对于含幺半群$\left<Z,\ +\right>$，令$Z_{n}=\{n x|x\in Z\}$，则对于$ n$取任何自然数，$\left\langle Z_{n},\ +\right\rangle$显然是$\left\langle Z,\ +\right\rangle$含幺子半群，且整数0 既是$\langle Z,\ +\rangle$的单位元也是$\left\langle Z_{n},\ +\right\rangle$的单位元。  
【定义12.4】假设$\langle G,*\rangle$和$\langle H,\circ\rangle$是任意给定的两个半群，如果存在从$G$到$H$的保运算映射  
$\psi$，即对于$\forall x,y\in G$，满足：  
$$
\psi(x*y)=\psi(x)\circ\psi(y)\quad\text{(12-5)}
$$  
则称$\psi$为从$\langle G,*\rangle$到$\langle H,\circ\rangle$的一个同态映射，并称$\langle G,*\rangle$与$\langle H,\circ\rangle$为同态。若$\psi$为单射，则称$\langle G,*\rangle$与$\langle H,\circ\rangle$为单同态；若$\psi$为满射，则称$\langle G,*\rangle$与$\langle H,\circ\rangle$为满同态；若$\psi$为双射，则称$\mathcal{\Psi}$为同构映射，并称$\langle G,*\rangle$与$\langle H,\circ\rangle$为同构。  
【定义12.5】假设$\langle G,*,e\rangle$和$\langle H,\circ,r\rangle$是任意给定的两个含幺半群，如果存在从$G$到$H$的保运算映射$\psi$，即对于$\forall x,y\in G$，满足：  
$$
\psi(x*y)=\psi(x)\circ\psi(y)\mathbb且\psi(e)=r
$$  
则称$\psi$为从$\langle G,*,e\rangle$到$\langle H,\circ,r\rangle$的一个同态映射，并称$\langle G,*,e\rangle$与$\langle H,\circ,r\rangle$为同态。若$\psi$为单射，则称 $\langle G,*,e\rangle$ 与 $\langle H,\circ,r\rangle$ 为单同态；若 $\psi$ 为满射，则称 $\langle G,*,e\rangle$ 与 $\langle H,\circ,r\rangle$ 为满同态；若 $\psi$ 为双射，则 称$\psi$为同构映射，并称$\langle G,*,e\rangle$与$\langle H,\circ,r\rangle$为同构。  
由于同构或同态的代数结构之间具有很多相同或相似的性质，因此，可在一般抽象代数结构与某个具体的代数结构之间建立一种同构或同态关系，通过比较直观考察具体代数结构的运算性质来研究一般抽象代数结构的运算性质，从而得到普适性的结论。这是研究和考察抽象代数结构的一种典型方法。下面结合具体实例介绍这种方法：",同态映射是保运算且保单位元的映射，存在于两个含幺半群之间
半群,存在,同构,,"半群是一种比较简单而基本的抽象代数结构，要求其载体上的二元运算满足封闭性和结合律。半群的具体定义如下：  
【定义12.1】假设$G$是任意给定的一个非空集合，$*$为$G$上的一个二元运算且满足结合律，即对于$\forall $$\mathrm x,\mathrm{y,z\in~}G$，成立：  
$$
(x\circ y)\circ z=x\circ(y\circ z)\quad\text{(12-1)}
$$  
则称由𝐴和*组成的二元代数结构$\langle G,\ *\rangle$是一个半群。  
半群是一种非常常见的抽象代数结构，例如$\langle R, +\rangle_、\ \langle R,\ \times\rangle_、\ \langle P(A),\ \cup\rangle_、\ \langle P(A),\ \cap\rangle_、$$\langle A^{A},\ \circ\rangle$、$\langle M_{n}(R),\ +\rangle$、$\langle M_{n}(R)$, ⋅〉等，都是半群。  
在上述定义中，由于运算$*$为集合$G$上的二元运算，故对$G$满足运算的封闭性。因此，运算满足封闭性和结合律是半群的两个基本特征。另外，一般习惯上使用字母$G$表示群代数结构的载体集合，我们一般遵循这种习惯并总是假定$G$为非空集合。  
【定义12.2】假设$\langle G,\ *\rangle$是任意给定的一个半群，如果$\langle G,\ *\rangle$中含有关于运算${\ast}$的单位元𝑒，则称$\langle G,\ *\rangle$是一个含幺半群或独异点，记为$\langle G,\ *,\ e\rangle$。  
从上述定义可以看出，所谓含幺半群，其实就是一种含有幺元或单位元的特殊半群。例如$\mathsf\langle R,\ +\rangle_、\ \langle R,\ \times\rangle_、\ \langle P(A),\ \cup\rangle_、\ \langle P(A),\ \cap\rangle_、\ \langle A^{A},\ \circ\rangle_、\ \langle M_{n}(R),\ +\rangle_、\ \langle M_{n}(R),\ \cdot\}$ 等，都是含幺半群，0、1、空集$\varnothing$、全集$𝐴$、恒等映射、零矩阵、单位矩阵分别是其幺元。但是，$\langle R^{+},~+\rangle$则不是一个含幺半群，因为$R^{+}$作为正实数集合没有运算${+}$的单位元。  
【定义12.3】假设$\langle G,\ *\rangle$是一个半群，$S$是$G$的一个非空子集且运算$^*$对𝑆封闭，则称$\langle S,\ *\rangle$是$\langle G,\ *\rangle$的一个子半群；假设$\langle G,*,e\rangle$是一个含幺半群，$S$是$G$的一个非空子集且运算$^*$对𝑆封闭，则称$\langle S,*,e\rangle$是$\langle G,*,e\rangle$的一个子含幺半群。  
例如，对于含幺半群$\left<Z,\ +\right>$，令$Z_{n}=\{n x|x\in Z\}$，则对于$ n$取任何自然数，$\left\langle Z_{n},\ +\right\rangle$显然是$\left\langle Z,\ +\right\rangle$含幺子半群，且整数0 既是$\langle Z,\ +\rangle$的单位元也是$\left\langle Z_{n},\ +\right\rangle$的单位元。  
【定义12.4】假设$\langle G,*\rangle$和$\langle H,\circ\rangle$是任意给定的两个半群，如果存在从$G$到$H$的保运算映射  
$\psi$，即对于$\forall x,y\in G$，满足：  
$$
\psi(x*y)=\psi(x)\circ\psi(y)\quad\text{(12-5)}
$$  
则称$\psi$为从$\langle G,*\rangle$到$\langle H,\circ\rangle$的一个同态映射，并称$\langle G,*\rangle$与$\langle H,\circ\rangle$为同态。若$\psi$为单射，则称$\langle G,*\rangle$与$\langle H,\circ\rangle$为单同态；若$\psi$为满射，则称$\langle G,*\rangle$与$\langle H,\circ\rangle$为满同态；若$\psi$为双射，则称$\mathcal{\Psi}$为同构映射，并称$\langle G,*\rangle$与$\langle H,\circ\rangle$为同构。  
【定义12.5】假设$\langle G,*,e\rangle$和$\langle H,\circ,r\rangle$是任意给定的两个含幺半群，如果存在从$G$到$H$的保运算映射$\psi$，即对于$\forall x,y\in G$，满足：  
$$
\psi(x*y)=\psi(x)\circ\psi(y)\mathbb且\psi(e)=r
$$  
则称$\psi$为从$\langle G,*,e\rangle$到$\langle H,\circ,r\rangle$的一个同态映射，并称$\langle G,*,e\rangle$与$\langle H,\circ,r\rangle$为同态。若$\psi$为单射，则称 $\langle G,*,e\rangle$ 与 $\langle H,\circ,r\rangle$ 为单同态；若 $\psi$ 为满射，则称 $\langle G,*,e\rangle$ 与 $\langle H,\circ,r\rangle$ 为满同态；若 $\psi$ 为双射，则 称$\psi$为同构映射，并称$\langle G,*,e\rangle$与$\langle H,\circ,r\rangle$为同构。  
由于同构或同态的代数结构之间具有很多相同或相似的性质，因此，可在一般抽象代数结构与某个具体的代数结构之间建立一种同构或同态关系，通过比较直观考察具体代数结构的运算性质来研究一般抽象代数结构的运算性质，从而得到普适性的结论。这是研究和考察抽象代数结构的一种典型方法。下面结合具体实例介绍这种方法：",同构是双射的同态映射，存在于两个半群之间
含幺半群,存在,同构,,"半群是一种比较简单而基本的抽象代数结构，要求其载体上的二元运算满足封闭性和结合律。半群的具体定义如下：  
【定义12.1】假设$G$是任意给定的一个非空集合，$*$为$G$上的一个二元运算且满足结合律，即对于$\forall $$\mathrm x,\mathrm{y,z\in~}G$，成立：  
$$
(x\circ y)\circ z=x\circ(y\circ z)\quad\text{(12-1)}
$$  
则称由𝐴和*组成的二元代数结构$\langle G,\ *\rangle$是一个半群。  
半群是一种非常常见的抽象代数结构，例如$\langle R, +\rangle_、\ \langle R,\ \times\rangle_、\ \langle P(A),\ \cup\rangle_、\ \langle P(A),\ \cap\rangle_、$$\langle A^{A},\ \circ\rangle$、$\langle M_{n}(R),\ +\rangle$、$\langle M_{n}(R)$, ⋅〉等，都是半群。  
在上述定义中，由于运算$*$为集合$G$上的二元运算，故对$G$满足运算的封闭性。因此，运算满足封闭性和结合律是半群的两个基本特征。另外，一般习惯上使用字母$G$表示群代数结构的载体集合，我们一般遵循这种习惯并总是假定$G$为非空集合。  
【定义12.2】假设$\langle G,\ *\rangle$是任意给定的一个半群，如果$\langle G,\ *\rangle$中含有关于运算${\ast}$的单位元𝑒，则称$\langle G,\ *\rangle$是一个含幺半群或独异点，记为$\langle G,\ *,\ e\rangle$。  
从上述定义可以看出，所谓含幺半群，其实就是一种含有幺元或单位元的特殊半群。例如$\mathsf\langle R,\ +\rangle_、\ \langle R,\ \times\rangle_、\ \langle P(A),\ \cup\rangle_、\ \langle P(A),\ \cap\rangle_、\ \langle A^{A},\ \circ\rangle_、\ \langle M_{n}(R),\ +\rangle_、\ \langle M_{n}(R),\ \cdot\}$ 等，都是含幺半群，0、1、空集$\varnothing$、全集$𝐴$、恒等映射、零矩阵、单位矩阵分别是其幺元。但是，$\langle R^{+},~+\rangle$则不是一个含幺半群，因为$R^{+}$作为正实数集合没有运算${+}$的单位元。  
【定义12.3】假设$\langle G,\ *\rangle$是一个半群，$S$是$G$的一个非空子集且运算$^*$对𝑆封闭，则称$\langle S,\ *\rangle$是$\langle G,\ *\rangle$的一个子半群；假设$\langle G,*,e\rangle$是一个含幺半群，$S$是$G$的一个非空子集且运算$^*$对𝑆封闭，则称$\langle S,*,e\rangle$是$\langle G,*,e\rangle$的一个子含幺半群。  
例如，对于含幺半群$\left<Z,\ +\right>$，令$Z_{n}=\{n x|x\in Z\}$，则对于$ n$取任何自然数，$\left\langle Z_{n},\ +\right\rangle$显然是$\left\langle Z,\ +\right\rangle$含幺子半群，且整数0 既是$\langle Z,\ +\rangle$的单位元也是$\left\langle Z_{n},\ +\right\rangle$的单位元。  
【定义12.4】假设$\langle G,*\rangle$和$\langle H,\circ\rangle$是任意给定的两个半群，如果存在从$G$到$H$的保运算映射  
$\psi$，即对于$\forall x,y\in G$，满足：  
$$
\psi(x*y)=\psi(x)\circ\psi(y)\quad\text{(12-5)}
$$  
则称$\psi$为从$\langle G,*\rangle$到$\langle H,\circ\rangle$的一个同态映射，并称$\langle G,*\rangle$与$\langle H,\circ\rangle$为同态。若$\psi$为单射，则称$\langle G,*\rangle$与$\langle H,\circ\rangle$为单同态；若$\psi$为满射，则称$\langle G,*\rangle$与$\langle H,\circ\rangle$为满同态；若$\psi$为双射，则称$\mathcal{\Psi}$为同构映射，并称$\langle G,*\rangle$与$\langle H,\circ\rangle$为同构。  
【定义12.5】假设$\langle G,*,e\rangle$和$\langle H,\circ,r\rangle$是任意给定的两个含幺半群，如果存在从$G$到$H$的保运算映射$\psi$，即对于$\forall x,y\in G$，满足：  
$$
\psi(x*y)=\psi(x)\circ\psi(y)\mathbb且\psi(e)=r
$$  
则称$\psi$为从$\langle G,*,e\rangle$到$\langle H,\circ,r\rangle$的一个同态映射，并称$\langle G,*,e\rangle$与$\langle H,\circ,r\rangle$为同态。若$\psi$为单射，则称 $\langle G,*,e\rangle$ 与 $\langle H,\circ,r\rangle$ 为单同态；若 $\psi$ 为满射，则称 $\langle G,*,e\rangle$ 与 $\langle H,\circ,r\rangle$ 为满同态；若 $\psi$ 为双射，则 称$\psi$为同构映射，并称$\langle G,*,e\rangle$与$\langle H,\circ,r\rangle$为同构。  
由于同构或同态的代数结构之间具有很多相同或相似的性质，因此，可在一般抽象代数结构与某个具体的代数结构之间建立一种同构或同态关系，通过比较直观考察具体代数结构的运算性质来研究一般抽象代数结构的运算性质，从而得到普适性的结论。这是研究和考察抽象代数结构的一种典型方法。下面结合具体实例介绍这种方法：",同构是双射且保单位元的同态映射，存在于两个含幺半群之间
半群,定义,方幂运算,,"我们知道半群和含幺半群都满足结合律，如果对载体集合中任意给定的某个元素进行多次重复运算，那么得到的运算结果与运算次序无关。也就是说，无论以怎样的次序对该元素进行多次重复运算，其结果仅与该元素和运算次数有关。因此，可对半群和含幺半群载体集合中的任意元素定义其方幂运算，具体如下：  
【定义12.6】假设$\langle G,*\rangle$是任意给定的一个半群，对于$\forall a\in G$和正整数$n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个 a}
$$  
如果$\langle G,*\rangle$是一个含幺半群且$e$是其单位元素，则定义$a^{0}=e$。  
例如，对于实数集合上的加法运算构成的含幺半群$\langle R,+\rangle$，显然有：  
$5^{3}=5+5+5=15;\;\;1^{4}=1+1+1+1=4;\;\;5^{0}=1^{0}=0;\;\;0^{0}=0^{1}=0^{2}=0$  
根据上述定义，显然成立方幂运算法则，即对于任意非负整数$ n$和$m$，有：
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
对于任意一个给定的半群或含幺半群$\langle G,*\rangle$，既然可以对其载体中的任意一个元素构造其任何次方幂，并且根据运算$*$在载体集合$ G$上的封闭性知，该元素所有方幂组成的集合必然是$G$的一个子集，那么自然就需要考察该子集以及运算$*$在该子集上的运算性质。下面的定理12.1 表明运算$*$可以在该子集上构成子半群或子含幺半群：  
【定理 12.1 】设 $\langle G,*\rangle$ 是任一给定的半群且对 $\forall a\in G$ ，令 $H=\{a^{n}|n\in Z^{+}\}$ ，则 $\langle H,*\rangle$ 是 $\langle G,*\rangle$的子半群。此时，若$\langle G,*\rangle$是含幺半群，则$\langle H,*\rangle$是$\langle G,*\rangle$的子含幺半群。  
如果$\langle G,*\rangle$是一个含幺半群，设$e$为其单位元。由于$e=a^{0}\in H$，故$e$也是$\langle H,*\rangle$的单位元。因此，$\langle H,*\rangle$也是一个含幺半群。  
从上述定理可知，对于任一给定的半群或含幺半群$\langle G,*\rangle$，载体集合$G$中任一给定元素$a$的所有方幂组成的集合$ H$可与运算$*$一起构成一种半群或含幺半群$\langle H,*\rangle$。事实上，$\langle H,*\rangle$是一种特殊的半群或含幺半群，其特殊性在于载体集合中$H$每个元素都是给定元素$a$的某个方幂。现在考察这种特殊半群或含幺半群的基本概念和性质，首先给出如下定义：  
【定义12.7】设$\langle G,*\rangle$是任一给定的半群，如果$\exists a\in G$，使得$G$中的任意元素$x$都能够写成元素$a$的方幂形式，即对于$\forall x\in G$，$\exists n\in N$,使得$x=a^{n}$，则称$\langle G,*\rangle$是一个循环半群，并称$a$是$\langle G,*\rangle$的一个生成元，$\langle G,*\rangle$的所有生成元组成的集合$C$称为$\langle G,*\rangle$的生成集。此时，如果$\langle G,*\rangle$还是一个含幺半群，则称$\langle G,*\rangle$是一个循环含幺半群。  
【定理 12.2】每个循环半群都是可交换半群。",半群中的元素可以进行方幂运算，定义为多次重复运算
含幺半群,定义,方幂运算,,"我们知道半群和含幺半群都满足结合律，如果对载体集合中任意给定的某个元素进行多次重复运算，那么得到的运算结果与运算次序无关。也就是说，无论以怎样的次序对该元素进行多次重复运算，其结果仅与该元素和运算次数有关。因此，可对半群和含幺半群载体集合中的任意元素定义其方幂运算，具体如下：  
【定义12.6】假设$\langle G,*\rangle$是任意给定的一个半群，对于$\forall a\in G$和正整数$n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个 a}
$$  
如果$\langle G,*\rangle$是一个含幺半群且$e$是其单位元素，则定义$a^{0}=e$。  
例如，对于实数集合上的加法运算构成的含幺半群$\langle R,+\rangle$，显然有：  
$5^{3}=5+5+5=15;\;\;1^{4}=1+1+1+1=4;\;\;5^{0}=1^{0}=0;\;\;0^{0}=0^{1}=0^{2}=0$  
根据上述定义，显然成立方幂运算法则，即对于任意非负整数$ n$和$m$，有：
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
对于任意一个给定的半群或含幺半群$\langle G,*\rangle$，既然可以对其载体中的任意一个元素构造其任何次方幂，并且根据运算$*$在载体集合$ G$上的封闭性知，该元素所有方幂组成的集合必然是$G$的一个子集，那么自然就需要考察该子集以及运算$*$在该子集上的运算性质。下面的定理12.1 表明运算$*$可以在该子集上构成子半群或子含幺半群：  
【定理 12.1 】设 $\langle G,*\rangle$ 是任一给定的半群且对 $\forall a\in G$ ，令 $H=\{a^{n}|n\in Z^{+}\}$ ，则 $\langle H,*\rangle$ 是 $\langle G,*\rangle$的子半群。此时，若$\langle G,*\rangle$是含幺半群，则$\langle H,*\rangle$是$\langle G,*\rangle$的子含幺半群。  
如果$\langle G,*\rangle$是一个含幺半群，设$e$为其单位元。由于$e=a^{0}\in H$，故$e$也是$\langle H,*\rangle$的单位元。因此，$\langle H,*\rangle$也是一个含幺半群。  
从上述定理可知，对于任一给定的半群或含幺半群$\langle G,*\rangle$，载体集合$G$中任一给定元素$a$的所有方幂组成的集合$ H$可与运算$*$一起构成一种半群或含幺半群$\langle H,*\rangle$。事实上，$\langle H,*\rangle$是一种特殊的半群或含幺半群，其特殊性在于载体集合中$H$每个元素都是给定元素$a$的某个方幂。现在考察这种特殊半群或含幺半群的基本概念和性质，首先给出如下定义：  
【定义12.7】设$\langle G,*\rangle$是任一给定的半群，如果$\exists a\in G$，使得$G$中的任意元素$x$都能够写成元素$a$的方幂形式，即对于$\forall x\in G$，$\exists n\in N$,使得$x=a^{n}$，则称$\langle G,*\rangle$是一个循环半群，并称$a$是$\langle G,*\rangle$的一个生成元，$\langle G,*\rangle$的所有生成元组成的集合$C$称为$\langle G,*\rangle$的生成集。此时，如果$\langle G,*\rangle$还是一个含幺半群，则称$\langle G,*\rangle$是一个循环含幺半群。  
【定理 12.2】每个循环半群都是可交换半群。",含幺半群中的元素可以进行方幂运算，且单位元素的零次方幂为单位元素
半群,包含,子半群,,"我们知道半群和含幺半群都满足结合律，如果对载体集合中任意给定的某个元素进行多次重复运算，那么得到的运算结果与运算次序无关。也就是说，无论以怎样的次序对该元素进行多次重复运算，其结果仅与该元素和运算次数有关。因此，可对半群和含幺半群载体集合中的任意元素定义其方幂运算，具体如下：  
【定义12.6】假设$\langle G,*\rangle$是任意给定的一个半群，对于$\forall a\in G$和正整数$n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个 a}
$$  
如果$\langle G,*\rangle$是一个含幺半群且$e$是其单位元素，则定义$a^{0}=e$。  
例如，对于实数集合上的加法运算构成的含幺半群$\langle R,+\rangle$，显然有：  
$5^{3}=5+5+5=15;\;\;1^{4}=1+1+1+1=4;\;\;5^{0}=1^{0}=0;\;\;0^{0}=0^{1}=0^{2}=0$  
根据上述定义，显然成立方幂运算法则，即对于任意非负整数$ n$和$m$，有：
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
对于任意一个给定的半群或含幺半群$\langle G,*\rangle$，既然可以对其载体中的任意一个元素构造其任何次方幂，并且根据运算$*$在载体集合$ G$上的封闭性知，该元素所有方幂组成的集合必然是$G$的一个子集，那么自然就需要考察该子集以及运算$*$在该子集上的运算性质。下面的定理12.1 表明运算$*$可以在该子集上构成子半群或子含幺半群：  
【定理 12.1 】设 $\langle G,*\rangle$ 是任一给定的半群且对 $\forall a\in G$ ，令 $H=\{a^{n}|n\in Z^{+}\}$ ，则 $\langle H,*\rangle$ 是 $\langle G,*\rangle$的子半群。此时，若$\langle G,*\rangle$是含幺半群，则$\langle H,*\rangle$是$\langle G,*\rangle$的子含幺半群。  
如果$\langle G,*\rangle$是一个含幺半群，设$e$为其单位元。由于$e=a^{0}\in H$，故$e$也是$\langle H,*\rangle$的单位元。因此，$\langle H,*\rangle$也是一个含幺半群。  
从上述定理可知，对于任一给定的半群或含幺半群$\langle G,*\rangle$，载体集合$G$中任一给定元素$a$的所有方幂组成的集合$ H$可与运算$*$一起构成一种半群或含幺半群$\langle H,*\rangle$。事实上，$\langle H,*\rangle$是一种特殊的半群或含幺半群，其特殊性在于载体集合中$H$每个元素都是给定元素$a$的某个方幂。现在考察这种特殊半群或含幺半群的基本概念和性质，首先给出如下定义：  
【定义12.7】设$\langle G,*\rangle$是任一给定的半群，如果$\exists a\in G$，使得$G$中的任意元素$x$都能够写成元素$a$的方幂形式，即对于$\forall x\in G$，$\exists n\in N$,使得$x=a^{n}$，则称$\langle G,*\rangle$是一个循环半群，并称$a$是$\langle G,*\rangle$的一个生成元，$\langle G,*\rangle$的所有生成元组成的集合$C$称为$\langle G,*\rangle$的生成集。此时，如果$\langle G,*\rangle$还是一个含幺半群，则称$\langle G,*\rangle$是一个循环含幺半群。  
【定理 12.2】每个循环半群都是可交换半群。",半群中元素的方幂集合可以构成子半群
含幺半群,包含,子含幺半群,,"我们知道半群和含幺半群都满足结合律，如果对载体集合中任意给定的某个元素进行多次重复运算，那么得到的运算结果与运算次序无关。也就是说，无论以怎样的次序对该元素进行多次重复运算，其结果仅与该元素和运算次数有关。因此，可对半群和含幺半群载体集合中的任意元素定义其方幂运算，具体如下：  
【定义12.6】假设$\langle G,*\rangle$是任意给定的一个半群，对于$\forall a\in G$和正整数$n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个 a}
$$  
如果$\langle G,*\rangle$是一个含幺半群且$e$是其单位元素，则定义$a^{0}=e$。  
例如，对于实数集合上的加法运算构成的含幺半群$\langle R,+\rangle$，显然有：  
$5^{3}=5+5+5=15;\;\;1^{4}=1+1+1+1=4;\;\;5^{0}=1^{0}=0;\;\;0^{0}=0^{1}=0^{2}=0$  
根据上述定义，显然成立方幂运算法则，即对于任意非负整数$ n$和$m$，有：
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
对于任意一个给定的半群或含幺半群$\langle G,*\rangle$，既然可以对其载体中的任意一个元素构造其任何次方幂，并且根据运算$*$在载体集合$ G$上的封闭性知，该元素所有方幂组成的集合必然是$G$的一个子集，那么自然就需要考察该子集以及运算$*$在该子集上的运算性质。下面的定理12.1 表明运算$*$可以在该子集上构成子半群或子含幺半群：  
【定理 12.1 】设 $\langle G,*\rangle$ 是任一给定的半群且对 $\forall a\in G$ ，令 $H=\{a^{n}|n\in Z^{+}\}$ ，则 $\langle H,*\rangle$ 是 $\langle G,*\rangle$的子半群。此时，若$\langle G,*\rangle$是含幺半群，则$\langle H,*\rangle$是$\langle G,*\rangle$的子含幺半群。  
如果$\langle G,*\rangle$是一个含幺半群，设$e$为其单位元。由于$e=a^{0}\in H$，故$e$也是$\langle H,*\rangle$的单位元。因此，$\langle H,*\rangle$也是一个含幺半群。  
从上述定理可知，对于任一给定的半群或含幺半群$\langle G,*\rangle$，载体集合$G$中任一给定元素$a$的所有方幂组成的集合$ H$可与运算$*$一起构成一种半群或含幺半群$\langle H,*\rangle$。事实上，$\langle H,*\rangle$是一种特殊的半群或含幺半群，其特殊性在于载体集合中$H$每个元素都是给定元素$a$的某个方幂。现在考察这种特殊半群或含幺半群的基本概念和性质，首先给出如下定义：  
【定义12.7】设$\langle G,*\rangle$是任一给定的半群，如果$\exists a\in G$，使得$G$中的任意元素$x$都能够写成元素$a$的方幂形式，即对于$\forall x\in G$，$\exists n\in N$,使得$x=a^{n}$，则称$\langle G,*\rangle$是一个循环半群，并称$a$是$\langle G,*\rangle$的一个生成元，$\langle G,*\rangle$的所有生成元组成的集合$C$称为$\langle G,*\rangle$的生成集。此时，如果$\langle G,*\rangle$还是一个含幺半群，则称$\langle G,*\rangle$是一个循环含幺半群。  
【定理 12.2】每个循环半群都是可交换半群。",含幺半群中元素的方幂集合可以构成子含幺半群
循环半群,定义,生成元,,"我们知道半群和含幺半群都满足结合律，如果对载体集合中任意给定的某个元素进行多次重复运算，那么得到的运算结果与运算次序无关。也就是说，无论以怎样的次序对该元素进行多次重复运算，其结果仅与该元素和运算次数有关。因此，可对半群和含幺半群载体集合中的任意元素定义其方幂运算，具体如下：  
【定义12.6】假设$\langle G,*\rangle$是任意给定的一个半群，对于$\forall a\in G$和正整数$n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个 a}
$$  
如果$\langle G,*\rangle$是一个含幺半群且$e$是其单位元素，则定义$a^{0}=e$。  
例如，对于实数集合上的加法运算构成的含幺半群$\langle R,+\rangle$，显然有：  
$5^{3}=5+5+5=15;\;\;1^{4}=1+1+1+1=4;\;\;5^{0}=1^{0}=0;\;\;0^{0}=0^{1}=0^{2}=0$  
根据上述定义，显然成立方幂运算法则，即对于任意非负整数$ n$和$m$，有：
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
对于任意一个给定的半群或含幺半群$\langle G,*\rangle$，既然可以对其载体中的任意一个元素构造其任何次方幂，并且根据运算$*$在载体集合$ G$上的封闭性知，该元素所有方幂组成的集合必然是$G$的一个子集，那么自然就需要考察该子集以及运算$*$在该子集上的运算性质。下面的定理12.1 表明运算$*$可以在该子集上构成子半群或子含幺半群：  
【定理 12.1 】设 $\langle G,*\rangle$ 是任一给定的半群且对 $\forall a\in G$ ，令 $H=\{a^{n}|n\in Z^{+}\}$ ，则 $\langle H,*\rangle$ 是 $\langle G,*\rangle$的子半群。此时，若$\langle G,*\rangle$是含幺半群，则$\langle H,*\rangle$是$\langle G,*\rangle$的子含幺半群。  
如果$\langle G,*\rangle$是一个含幺半群，设$e$为其单位元。由于$e=a^{0}\in H$，故$e$也是$\langle H,*\rangle$的单位元。因此，$\langle H,*\rangle$也是一个含幺半群。  
从上述定理可知，对于任一给定的半群或含幺半群$\langle G,*\rangle$，载体集合$G$中任一给定元素$a$的所有方幂组成的集合$ H$可与运算$*$一起构成一种半群或含幺半群$\langle H,*\rangle$。事实上，$\langle H,*\rangle$是一种特殊的半群或含幺半群，其特殊性在于载体集合中$H$每个元素都是给定元素$a$的某个方幂。现在考察这种特殊半群或含幺半群的基本概念和性质，首先给出如下定义：  
【定义12.7】设$\langle G,*\rangle$是任一给定的半群，如果$\exists a\in G$，使得$G$中的任意元素$x$都能够写成元素$a$的方幂形式，即对于$\forall x\in G$，$\exists n\in N$,使得$x=a^{n}$，则称$\langle G,*\rangle$是一个循环半群，并称$a$是$\langle G,*\rangle$的一个生成元，$\langle G,*\rangle$的所有生成元组成的集合$C$称为$\langle G,*\rangle$的生成集。此时，如果$\langle G,*\rangle$还是一个含幺半群，则称$\langle G,*\rangle$是一个循环含幺半群。  
【定理 12.2】每个循环半群都是可交换半群。",循环半群中的每个元素都可以表示为某个生成元的方幂
循环半群,性质,定理12.2,,"我们知道半群和含幺半群都满足结合律，如果对载体集合中任意给定的某个元素进行多次重复运算，那么得到的运算结果与运算次序无关。也就是说，无论以怎样的次序对该元素进行多次重复运算，其结果仅与该元素和运算次数有关。因此，可对半群和含幺半群载体集合中的任意元素定义其方幂运算，具体如下：  
【定义12.6】假设$\langle G,*\rangle$是任意给定的一个半群，对于$\forall a\in G$和正整数$n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个 a}
$$  
如果$\langle G,*\rangle$是一个含幺半群且$e$是其单位元素，则定义$a^{0}=e$。  
例如，对于实数集合上的加法运算构成的含幺半群$\langle R,+\rangle$，显然有：  
$5^{3}=5+5+5=15;\;\;1^{4}=1+1+1+1=4;\;\;5^{0}=1^{0}=0;\;\;0^{0}=0^{1}=0^{2}=0$  
根据上述定义，显然成立方幂运算法则，即对于任意非负整数$ n$和$m$，有：
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
对于任意一个给定的半群或含幺半群$\langle G,*\rangle$，既然可以对其载体中的任意一个元素构造其任何次方幂，并且根据运算$*$在载体集合$ G$上的封闭性知，该元素所有方幂组成的集合必然是$G$的一个子集，那么自然就需要考察该子集以及运算$*$在该子集上的运算性质。下面的定理12.1 表明运算$*$可以在该子集上构成子半群或子含幺半群：  
【定理 12.1 】设 $\langle G,*\rangle$ 是任一给定的半群且对 $\forall a\in G$ ，令 $H=\{a^{n}|n\in Z^{+}\}$ ，则 $\langle H,*\rangle$ 是 $\langle G,*\rangle$的子半群。此时，若$\langle G,*\rangle$是含幺半群，则$\langle H,*\rangle$是$\langle G,*\rangle$的子含幺半群。  
如果$\langle G,*\rangle$是一个含幺半群，设$e$为其单位元。由于$e=a^{0}\in H$，故$e$也是$\langle H,*\rangle$的单位元。因此，$\langle H,*\rangle$也是一个含幺半群。  
从上述定理可知，对于任一给定的半群或含幺半群$\langle G,*\rangle$，载体集合$G$中任一给定元素$a$的所有方幂组成的集合$ H$可与运算$*$一起构成一种半群或含幺半群$\langle H,*\rangle$。事实上，$\langle H,*\rangle$是一种特殊的半群或含幺半群，其特殊性在于载体集合中$H$每个元素都是给定元素$a$的某个方幂。现在考察这种特殊半群或含幺半群的基本概念和性质，首先给出如下定义：  
【定义12.7】设$\langle G,*\rangle$是任一给定的半群，如果$\exists a\in G$，使得$G$中的任意元素$x$都能够写成元素$a$的方幂形式，即对于$\forall x\in G$，$\exists n\in N$,使得$x=a^{n}$，则称$\langle G,*\rangle$是一个循环半群，并称$a$是$\langle G,*\rangle$的一个生成元，$\langle G,*\rangle$的所有生成元组成的集合$C$称为$\langle G,*\rangle$的生成集。此时，如果$\langle G,*\rangle$还是一个含幺半群，则称$\langle G,*\rangle$是一个循环含幺半群。  
【定理 12.2】每个循环半群都是可交换半群。",每个循环半群都是可交换半群
半群,性质,定理12.1,,"我们知道半群和含幺半群都满足结合律，如果对载体集合中任意给定的某个元素进行多次重复运算，那么得到的运算结果与运算次序无关。也就是说，无论以怎样的次序对该元素进行多次重复运算，其结果仅与该元素和运算次数有关。因此，可对半群和含幺半群载体集合中的任意元素定义其方幂运算，具体如下：  
【定义12.6】假设$\langle G,*\rangle$是任意给定的一个半群，对于$\forall a\in G$和正整数$n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个 a}
$$  
如果$\langle G,*\rangle$是一个含幺半群且$e$是其单位元素，则定义$a^{0}=e$。  
例如，对于实数集合上的加法运算构成的含幺半群$\langle R,+\rangle$，显然有：  
$5^{3}=5+5+5=15;\;\;1^{4}=1+1+1+1=4;\;\;5^{0}=1^{0}=0;\;\;0^{0}=0^{1}=0^{2}=0$  
根据上述定义，显然成立方幂运算法则，即对于任意非负整数$ n$和$m$，有：
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
对于任意一个给定的半群或含幺半群$\langle G,*\rangle$，既然可以对其载体中的任意一个元素构造其任何次方幂，并且根据运算$*$在载体集合$ G$上的封闭性知，该元素所有方幂组成的集合必然是$G$的一个子集，那么自然就需要考察该子集以及运算$*$在该子集上的运算性质。下面的定理12.1 表明运算$*$可以在该子集上构成子半群或子含幺半群：  
【定理 12.1 】设 $\langle G,*\rangle$ 是任一给定的半群且对 $\forall a\in G$ ，令 $H=\{a^{n}|n\in Z^{+}\}$ ，则 $\langle H,*\rangle$ 是 $\langle G,*\rangle$的子半群。此时，若$\langle G,*\rangle$是含幺半群，则$\langle H,*\rangle$是$\langle G,*\rangle$的子含幺半群。  
如果$\langle G,*\rangle$是一个含幺半群，设$e$为其单位元。由于$e=a^{0}\in H$，故$e$也是$\langle H,*\rangle$的单位元。因此，$\langle H,*\rangle$也是一个含幺半群。  
从上述定理可知，对于任一给定的半群或含幺半群$\langle G,*\rangle$，载体集合$G$中任一给定元素$a$的所有方幂组成的集合$ H$可与运算$*$一起构成一种半群或含幺半群$\langle H,*\rangle$。事实上，$\langle H,*\rangle$是一种特殊的半群或含幺半群，其特殊性在于载体集合中$H$每个元素都是给定元素$a$的某个方幂。现在考察这种特殊半群或含幺半群的基本概念和性质，首先给出如下定义：  
【定义12.7】设$\langle G,*\rangle$是任一给定的半群，如果$\exists a\in G$，使得$G$中的任意元素$x$都能够写成元素$a$的方幂形式，即对于$\forall x\in G$，$\exists n\in N$,使得$x=a^{n}$，则称$\langle G,*\rangle$是一个循环半群，并称$a$是$\langle G,*\rangle$的一个生成元，$\langle G,*\rangle$的所有生成元组成的集合$C$称为$\langle G,*\rangle$的生成集。此时，如果$\langle G,*\rangle$还是一个含幺半群，则称$\langle G,*\rangle$是一个循环含幺半群。  
【定理 12.2】每个循环半群都是可交换半群。",半群中元素的方幂集合可以构成子半群
含幺半群,性质,定理12.1,,"我们知道半群和含幺半群都满足结合律，如果对载体集合中任意给定的某个元素进行多次重复运算，那么得到的运算结果与运算次序无关。也就是说，无论以怎样的次序对该元素进行多次重复运算，其结果仅与该元素和运算次数有关。因此，可对半群和含幺半群载体集合中的任意元素定义其方幂运算，具体如下：  
【定义12.6】假设$\langle G,*\rangle$是任意给定的一个半群，对于$\forall a\in G$和正整数$n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个 a}
$$  
如果$\langle G,*\rangle$是一个含幺半群且$e$是其单位元素，则定义$a^{0}=e$。  
例如，对于实数集合上的加法运算构成的含幺半群$\langle R,+\rangle$，显然有：  
$5^{3}=5+5+5=15;\;\;1^{4}=1+1+1+1=4;\;\;5^{0}=1^{0}=0;\;\;0^{0}=0^{1}=0^{2}=0$  
根据上述定义，显然成立方幂运算法则，即对于任意非负整数$ n$和$m$，有：
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
对于任意一个给定的半群或含幺半群$\langle G,*\rangle$，既然可以对其载体中的任意一个元素构造其任何次方幂，并且根据运算$*$在载体集合$ G$上的封闭性知，该元素所有方幂组成的集合必然是$G$的一个子集，那么自然就需要考察该子集以及运算$*$在该子集上的运算性质。下面的定理12.1 表明运算$*$可以在该子集上构成子半群或子含幺半群：  
【定理 12.1 】设 $\langle G,*\rangle$ 是任一给定的半群且对 $\forall a\in G$ ，令 $H=\{a^{n}|n\in Z^{+}\}$ ，则 $\langle H,*\rangle$ 是 $\langle G,*\rangle$的子半群。此时，若$\langle G,*\rangle$是含幺半群，则$\langle H,*\rangle$是$\langle G,*\rangle$的子含幺半群。  
如果$\langle G,*\rangle$是一个含幺半群，设$e$为其单位元。由于$e=a^{0}\in H$，故$e$也是$\langle H,*\rangle$的单位元。因此，$\langle H,*\rangle$也是一个含幺半群。  
从上述定理可知，对于任一给定的半群或含幺半群$\langle G,*\rangle$，载体集合$G$中任一给定元素$a$的所有方幂组成的集合$ H$可与运算$*$一起构成一种半群或含幺半群$\langle H,*\rangle$。事实上，$\langle H,*\rangle$是一种特殊的半群或含幺半群，其特殊性在于载体集合中$H$每个元素都是给定元素$a$的某个方幂。现在考察这种特殊半群或含幺半群的基本概念和性质，首先给出如下定义：  
【定义12.7】设$\langle G,*\rangle$是任一给定的半群，如果$\exists a\in G$，使得$G$中的任意元素$x$都能够写成元素$a$的方幂形式，即对于$\forall x\in G$，$\exists n\in N$,使得$x=a^{n}$，则称$\langle G,*\rangle$是一个循环半群，并称$a$是$\langle G,*\rangle$的一个生成元，$\langle G,*\rangle$的所有生成元组成的集合$C$称为$\langle G,*\rangle$的生成集。此时，如果$\langle G,*\rangle$还是一个含幺半群，则称$\langle G,*\rangle$是一个循环含幺半群。  
【定理 12.2】每个循环半群都是可交换半群。",含幺半群中元素的方幂集合可以构成子含幺半群
群结构,是,代数结构,,"群的概念最初由法国数学家伽罗瓦为解决五次代数方程通用求根公式而提出。要使用前述含幺半群结构$\langle G,*\rangle$解决代数方程求根等问题，显然必须在$\langle G,*\rangle$中进一步引入运算$*$的逆运算，也就是要求载体集合$G$中每个元素均有逆元素，使得$\langle G,*\rangle$构成一个相对完备的代数结构，这种完备的代数结构就是群结构。事实上，群结构作为一种仅含单个运算的抽象代数结构，具有一套比较完备的理论，在代数编码与数字通信、形式语言与自动机等多个领域都具有非常重要的应用价值。本节主要介绍群结构的基本知识，主要包括群的基本概念与性质、子群的概念与判定、群的同态与同构关系。",群结构是一种完备的代数结构
群结构,属于,抽象代数结构,,"群的概念最初由法国数学家伽罗瓦为解决五次代数方程通用求根公式而提出。要使用前述含幺半群结构$\langle G,*\rangle$解决代数方程求根等问题，显然必须在$\langle G,*\rangle$中进一步引入运算$*$的逆运算，也就是要求载体集合$G$中每个元素均有逆元素，使得$\langle G,*\rangle$构成一个相对完备的代数结构，这种完备的代数结构就是群结构。事实上，群结构作为一种仅含单个运算的抽象代数结构，具有一套比较完备的理论，在代数编码与数字通信、形式语言与自动机等多个领域都具有非常重要的应用价值。本节主要介绍群结构的基本知识，主要包括群的基本概念与性质、子群的概念与判定、群的同态与同构关系。",群结构属于仅含单个运算的抽象代数结构
群结构,应用于,应用领域,,"群的概念最初由法国数学家伽罗瓦为解决五次代数方程通用求根公式而提出。要使用前述含幺半群结构$\langle G,*\rangle$解决代数方程求根等问题，显然必须在$\langle G,*\rangle$中进一步引入运算$*$的逆运算，也就是要求载体集合$G$中每个元素均有逆元素，使得$\langle G,*\rangle$构成一个相对完备的代数结构，这种完备的代数结构就是群结构。事实上，群结构作为一种仅含单个运算的抽象代数结构，具有一套比较完备的理论，在代数编码与数字通信、形式语言与自动机等多个领域都具有非常重要的应用价值。本节主要介绍群结构的基本知识，主要包括群的基本概念与性质、子群的概念与判定、群的同态与同构关系。",群结构在代数编码与数字通信、形式语言与自动机等领域具有应用价值
群结构,包含,单位元,,"如前所述，群代数结构是对幺半群结构在逆元方面的进一步扩充，其具体定义如下：  
【定义12.8】假设$\langle G,*\rangle$是任意给定的一个二元代数结构，如果$\langle G,*\rangle$满足如下性质：  
（1）结合律：对于$\forall x,y,z\in G$，成立：$(x\ \ *y)*z=x\ \ *(y*z)$；  
（2）含单位元：$\exists e\in G$，使得对于$\forall x\in G$，成立$\,\!e*x=x*e=x$；  
（3）运算$*$可逆：对于$\forall x\in G$，都存在$x^{-1}\in G$，使得$x^{-1}*x=x*x^{-1}=e$。  
则称$\langle G,*\rangle$是一个群代数结构，简称为群结构或群。  
从上述定义可知，对于任意给定的非空集合 $G$ 以及该集合上某个二元运算 $*$ ，$\langle G,*\rangle$ 能够 形成一个群结构的充分必要条件是$\langle G,*\rangle$必须满足封闭性、结合律、含幺性和可逆性这四个基本运算性质。例如，对于实数集合及其上的普通加法运算构成的代数结构$\langle R,+\rangle$，显然满足群的四条基本性质，其中0 是其单位元，对于$\forall x\in R$，$-x$是$x$的逆元。但是，对于实数集合及其上的普通乘法运算构成的代数结构$\langle R,\times\rangle$则不是一个群，因为在$\langle R,\times\rangle$中0 没有逆元素。不难发现，对于任意给定的集合$𝐴$，$\langle{ P}(A),\cup\rangle$和$\langle{ P}(A),\cap\rangle$都不能构成群结构，因为在$\langle{ P}(A),\cup\rangle$中$𝐴$没有逆元，在$\langle{P}(A),\cap\rangle$中$\varnothing$没有逆元。  
【定义12.9】设$\langle G,*\rangle$是任意给定的一个群，称$|G|$为$\langle G,*\rangle$的阶，如果$|G|$为有限数，则称  
$\langle G,*\rangle$为有限群，否则$\langle G,*\rangle$为无限群。如果运算$^*$满足交换律，即对于$\forall x,y\in G$，有$x*y=y*$$x$则称群$\langle G,*\rangle$是一个交换群或阿贝尔群。  
【定理12.3】设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$的单位元是$\langle G,*\rangle$中唯一的一个幂等元，若$|G|>1$，则$\langle G,*\rangle$中无零元且满足消去律。  
下面的定理12.2.2 给出了群中逆元素的基本性质：  
【定理12.4】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，有：  
$$
(a^{-1})^{-1}=a\,\exists(a*b)^{-1}=b^{-1}*a^{-1}
$$  
下面的定理12.5 给出了群与方程可解性之间的关系：  
【定理12.5】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，方程$a\circ x=b$和$y\circ a=$$b$在$\langle G,*\rangle$中有且仅有唯一解。  
由于群结构满足结合律，故可类似于半群和含幺半群定义元素的方幂：  
【定义12.10】设$\langle G,*\rangle$是任意给定的一个群，对于$\forall a\in G$和正整数$ n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$ a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个a}
$$  
定义$a^{0}=e$且$a^{-n}=(a^{-1})^{n}$  
从上述定义可以看出，对于一个群结构$\langle G,*\rangle$可以定义其任意整数的方幂运算，包括负指数方幂。因此，对于$G$中的任何一个元素$a$，均可以通过其正方幂、零方幂和负方幂构成一个向胜负两端无限延伸的序列，具体如下：  
$$
\cdots,a^{-n},\cdots,a^{-2},a^{-1},a^{0}\ \ ,a^{1},a^{2},\cdots,a^{n},\cdots
$$  
这些序列显然满足幂的运算法则，即对于任意整数$n$和$m$，有：  
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
如果$\langle G,*\rangle$是一个有限群$\langle G,*\rangle$，则根据运算的封闭性和鸽笼原理易知，在$G$中任意一个元素的无穷多个方幂中，必然至少有两个是相等的。具体地说，对于任意给定的$G$中某个元素$a$，必然存在两个不相等的整数$m$和$|n$，不妨设$m<n$，满足：  
$$
a^n=a^m\text{或}a^{n-m}=e
$$  
此时，可将正整数$n-m$看成是元素$a$方幂变化的一个周期。一般地，有如下定义：  
【定义12.11】设$\langle G,*\rangle$是任意给定的一个群，$e$是该群的单位元，对于$G$中任意给定的某个元素$a$，如果存在正整数$n$，满足$a^{n}=e$，则其中最小的正整数称为元素$a$的周期或阶，记为$|a|$，否则称元素$a$的周期为无限大或元素$a$的阶为无限大。  
例如，对于群$\langle\underline{{6}},+_{6}\rangle$，元素1 的阶为6，元素2 的阶为3，元素3 的阶为2，元素4 的阶为3，元素5 的阶为6，元素0 的阶为1。对于整数集合上的加法群$\langle Z,+\rangle$，显然，除了元素0 的周期为1 之外，其余任一非零元素的周期均为无穷大。事实上，不难看出，对于任何一个群，有且只有其单位元的阶为1。  
下面给出关于元素阶的两个重要性质：  
【定理12.6】有限群$\langle G,*\rangle$的每个元素都有有限阶，且其阶数不超过群的阶数|G|。  
【定理12.7】设$\langle G,*\rangle$为群，$G$中元素$a$的阶为$ k$，那么$a^{n}=e$当且仅当$k$整除$ n$  。",群结构包含单位元
群结构,包含,逆元,,"如前所述，群代数结构是对幺半群结构在逆元方面的进一步扩充，其具体定义如下：  
【定义12.8】假设$\langle G,*\rangle$是任意给定的一个二元代数结构，如果$\langle G,*\rangle$满足如下性质：  
（1）结合律：对于$\forall x,y,z\in G$，成立：$(x\ \ *y)*z=x\ \ *(y*z)$；  
（2）含单位元：$\exists e\in G$，使得对于$\forall x\in G$，成立$\,\!e*x=x*e=x$；  
（3）运算$*$可逆：对于$\forall x\in G$，都存在$x^{-1}\in G$，使得$x^{-1}*x=x*x^{-1}=e$。  
则称$\langle G,*\rangle$是一个群代数结构，简称为群结构或群。  
从上述定义可知，对于任意给定的非空集合 $G$ 以及该集合上某个二元运算 $*$ ，$\langle G,*\rangle$ 能够 形成一个群结构的充分必要条件是$\langle G,*\rangle$必须满足封闭性、结合律、含幺性和可逆性这四个基本运算性质。例如，对于实数集合及其上的普通加法运算构成的代数结构$\langle R,+\rangle$，显然满足群的四条基本性质，其中0 是其单位元，对于$\forall x\in R$，$-x$是$x$的逆元。但是，对于实数集合及其上的普通乘法运算构成的代数结构$\langle R,\times\rangle$则不是一个群，因为在$\langle R,\times\rangle$中0 没有逆元素。不难发现，对于任意给定的集合$𝐴$，$\langle{ P}(A),\cup\rangle$和$\langle{ P}(A),\cap\rangle$都不能构成群结构，因为在$\langle{ P}(A),\cup\rangle$中$𝐴$没有逆元，在$\langle{P}(A),\cap\rangle$中$\varnothing$没有逆元。  
【定义12.9】设$\langle G,*\rangle$是任意给定的一个群，称$|G|$为$\langle G,*\rangle$的阶，如果$|G|$为有限数，则称  
$\langle G,*\rangle$为有限群，否则$\langle G,*\rangle$为无限群。如果运算$^*$满足交换律，即对于$\forall x,y\in G$，有$x*y=y*$$x$则称群$\langle G,*\rangle$是一个交换群或阿贝尔群。  
【定理12.3】设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$的单位元是$\langle G,*\rangle$中唯一的一个幂等元，若$|G|>1$，则$\langle G,*\rangle$中无零元且满足消去律。  
下面的定理12.2.2 给出了群中逆元素的基本性质：  
【定理12.4】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，有：  
$$
(a^{-1})^{-1}=a\,\exists(a*b)^{-1}=b^{-1}*a^{-1}
$$  
下面的定理12.5 给出了群与方程可解性之间的关系：  
【定理12.5】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，方程$a\circ x=b$和$y\circ a=$$b$在$\langle G,*\rangle$中有且仅有唯一解。  
由于群结构满足结合律，故可类似于半群和含幺半群定义元素的方幂：  
【定义12.10】设$\langle G,*\rangle$是任意给定的一个群，对于$\forall a\in G$和正整数$ n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$ a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个a}
$$  
定义$a^{0}=e$且$a^{-n}=(a^{-1})^{n}$  
从上述定义可以看出，对于一个群结构$\langle G,*\rangle$可以定义其任意整数的方幂运算，包括负指数方幂。因此，对于$G$中的任何一个元素$a$，均可以通过其正方幂、零方幂和负方幂构成一个向胜负两端无限延伸的序列，具体如下：  
$$
\cdots,a^{-n},\cdots,a^{-2},a^{-1},a^{0}\ \ ,a^{1},a^{2},\cdots,a^{n},\cdots
$$  
这些序列显然满足幂的运算法则，即对于任意整数$n$和$m$，有：  
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
如果$\langle G,*\rangle$是一个有限群$\langle G,*\rangle$，则根据运算的封闭性和鸽笼原理易知，在$G$中任意一个元素的无穷多个方幂中，必然至少有两个是相等的。具体地说，对于任意给定的$G$中某个元素$a$，必然存在两个不相等的整数$m$和$|n$，不妨设$m<n$，满足：  
$$
a^n=a^m\text{或}a^{n-m}=e
$$  
此时，可将正整数$n-m$看成是元素$a$方幂变化的一个周期。一般地，有如下定义：  
【定义12.11】设$\langle G,*\rangle$是任意给定的一个群，$e$是该群的单位元，对于$G$中任意给定的某个元素$a$，如果存在正整数$n$，满足$a^{n}=e$，则其中最小的正整数称为元素$a$的周期或阶，记为$|a|$，否则称元素$a$的周期为无限大或元素$a$的阶为无限大。  
例如，对于群$\langle\underline{{6}},+_{6}\rangle$，元素1 的阶为6，元素2 的阶为3，元素3 的阶为2，元素4 的阶为3，元素5 的阶为6，元素0 的阶为1。对于整数集合上的加法群$\langle Z,+\rangle$，显然，除了元素0 的周期为1 之外，其余任一非零元素的周期均为无穷大。事实上，不难看出，对于任何一个群，有且只有其单位元的阶为1。  
下面给出关于元素阶的两个重要性质：  
【定理12.6】有限群$\langle G,*\rangle$的每个元素都有有限阶，且其阶数不超过群的阶数|G|。  
【定理12.7】设$\langle G,*\rangle$为群，$G$中元素$a$的阶为$ k$，那么$a^{n}=e$当且仅当$k$整除$ n$  。",群结构包含逆元
群结构,满足,结合律,,"如前所述，群代数结构是对幺半群结构在逆元方面的进一步扩充，其具体定义如下：  
【定义12.8】假设$\langle G,*\rangle$是任意给定的一个二元代数结构，如果$\langle G,*\rangle$满足如下性质：  
（1）结合律：对于$\forall x,y,z\in G$，成立：$(x\ \ *y)*z=x\ \ *(y*z)$；  
（2）含单位元：$\exists e\in G$，使得对于$\forall x\in G$，成立$\,\!e*x=x*e=x$；  
（3）运算$*$可逆：对于$\forall x\in G$，都存在$x^{-1}\in G$，使得$x^{-1}*x=x*x^{-1}=e$。  
则称$\langle G,*\rangle$是一个群代数结构，简称为群结构或群。  
从上述定义可知，对于任意给定的非空集合 $G$ 以及该集合上某个二元运算 $*$ ，$\langle G,*\rangle$ 能够 形成一个群结构的充分必要条件是$\langle G,*\rangle$必须满足封闭性、结合律、含幺性和可逆性这四个基本运算性质。例如，对于实数集合及其上的普通加法运算构成的代数结构$\langle R,+\rangle$，显然满足群的四条基本性质，其中0 是其单位元，对于$\forall x\in R$，$-x$是$x$的逆元。但是，对于实数集合及其上的普通乘法运算构成的代数结构$\langle R,\times\rangle$则不是一个群，因为在$\langle R,\times\rangle$中0 没有逆元素。不难发现，对于任意给定的集合$𝐴$，$\langle{ P}(A),\cup\rangle$和$\langle{ P}(A),\cap\rangle$都不能构成群结构，因为在$\langle{ P}(A),\cup\rangle$中$𝐴$没有逆元，在$\langle{P}(A),\cap\rangle$中$\varnothing$没有逆元。  
【定义12.9】设$\langle G,*\rangle$是任意给定的一个群，称$|G|$为$\langle G,*\rangle$的阶，如果$|G|$为有限数，则称  
$\langle G,*\rangle$为有限群，否则$\langle G,*\rangle$为无限群。如果运算$^*$满足交换律，即对于$\forall x,y\in G$，有$x*y=y*$$x$则称群$\langle G,*\rangle$是一个交换群或阿贝尔群。  
【定理12.3】设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$的单位元是$\langle G,*\rangle$中唯一的一个幂等元，若$|G|>1$，则$\langle G,*\rangle$中无零元且满足消去律。  
下面的定理12.2.2 给出了群中逆元素的基本性质：  
【定理12.4】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，有：  
$$
(a^{-1})^{-1}=a\,\exists(a*b)^{-1}=b^{-1}*a^{-1}
$$  
下面的定理12.5 给出了群与方程可解性之间的关系：  
【定理12.5】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，方程$a\circ x=b$和$y\circ a=$$b$在$\langle G,*\rangle$中有且仅有唯一解。  
由于群结构满足结合律，故可类似于半群和含幺半群定义元素的方幂：  
【定义12.10】设$\langle G,*\rangle$是任意给定的一个群，对于$\forall a\in G$和正整数$ n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$ a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个a}
$$  
定义$a^{0}=e$且$a^{-n}=(a^{-1})^{n}$  
从上述定义可以看出，对于一个群结构$\langle G,*\rangle$可以定义其任意整数的方幂运算，包括负指数方幂。因此，对于$G$中的任何一个元素$a$，均可以通过其正方幂、零方幂和负方幂构成一个向胜负两端无限延伸的序列，具体如下：  
$$
\cdots,a^{-n},\cdots,a^{-2},a^{-1},a^{0}\ \ ,a^{1},a^{2},\cdots,a^{n},\cdots
$$  
这些序列显然满足幂的运算法则，即对于任意整数$n$和$m$，有：  
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
如果$\langle G,*\rangle$是一个有限群$\langle G,*\rangle$，则根据运算的封闭性和鸽笼原理易知，在$G$中任意一个元素的无穷多个方幂中，必然至少有两个是相等的。具体地说，对于任意给定的$G$中某个元素$a$，必然存在两个不相等的整数$m$和$|n$，不妨设$m<n$，满足：  
$$
a^n=a^m\text{或}a^{n-m}=e
$$  
此时，可将正整数$n-m$看成是元素$a$方幂变化的一个周期。一般地，有如下定义：  
【定义12.11】设$\langle G,*\rangle$是任意给定的一个群，$e$是该群的单位元，对于$G$中任意给定的某个元素$a$，如果存在正整数$n$，满足$a^{n}=e$，则其中最小的正整数称为元素$a$的周期或阶，记为$|a|$，否则称元素$a$的周期为无限大或元素$a$的阶为无限大。  
例如，对于群$\langle\underline{{6}},+_{6}\rangle$，元素1 的阶为6，元素2 的阶为3，元素3 的阶为2，元素4 的阶为3，元素5 的阶为6，元素0 的阶为1。对于整数集合上的加法群$\langle Z,+\rangle$，显然，除了元素0 的周期为1 之外，其余任一非零元素的周期均为无穷大。事实上，不难看出，对于任何一个群，有且只有其单位元的阶为1。  
下面给出关于元素阶的两个重要性质：  
【定理12.6】有限群$\langle G,*\rangle$的每个元素都有有限阶，且其阶数不超过群的阶数|G|。  
【定理12.7】设$\langle G,*\rangle$为群，$G$中元素$a$的阶为$ k$，那么$a^{n}=e$当且仅当$k$整除$ n$  。",群结构满足结合律
有限群,是,群结构,,"如前所述，群代数结构是对幺半群结构在逆元方面的进一步扩充，其具体定义如下：  
【定义12.8】假设$\langle G,*\rangle$是任意给定的一个二元代数结构，如果$\langle G,*\rangle$满足如下性质：  
（1）结合律：对于$\forall x,y,z\in G$，成立：$(x\ \ *y)*z=x\ \ *(y*z)$；  
（2）含单位元：$\exists e\in G$，使得对于$\forall x\in G$，成立$\,\!e*x=x*e=x$；  
（3）运算$*$可逆：对于$\forall x\in G$，都存在$x^{-1}\in G$，使得$x^{-1}*x=x*x^{-1}=e$。  
则称$\langle G,*\rangle$是一个群代数结构，简称为群结构或群。  
从上述定义可知，对于任意给定的非空集合 $G$ 以及该集合上某个二元运算 $*$ ，$\langle G,*\rangle$ 能够 形成一个群结构的充分必要条件是$\langle G,*\rangle$必须满足封闭性、结合律、含幺性和可逆性这四个基本运算性质。例如，对于实数集合及其上的普通加法运算构成的代数结构$\langle R,+\rangle$，显然满足群的四条基本性质，其中0 是其单位元，对于$\forall x\in R$，$-x$是$x$的逆元。但是，对于实数集合及其上的普通乘法运算构成的代数结构$\langle R,\times\rangle$则不是一个群，因为在$\langle R,\times\rangle$中0 没有逆元素。不难发现，对于任意给定的集合$𝐴$，$\langle{ P}(A),\cup\rangle$和$\langle{ P}(A),\cap\rangle$都不能构成群结构，因为在$\langle{ P}(A),\cup\rangle$中$𝐴$没有逆元，在$\langle{P}(A),\cap\rangle$中$\varnothing$没有逆元。  
【定义12.9】设$\langle G,*\rangle$是任意给定的一个群，称$|G|$为$\langle G,*\rangle$的阶，如果$|G|$为有限数，则称  
$\langle G,*\rangle$为有限群，否则$\langle G,*\rangle$为无限群。如果运算$^*$满足交换律，即对于$\forall x,y\in G$，有$x*y=y*$$x$则称群$\langle G,*\rangle$是一个交换群或阿贝尔群。  
【定理12.3】设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$的单位元是$\langle G,*\rangle$中唯一的一个幂等元，若$|G|>1$，则$\langle G,*\rangle$中无零元且满足消去律。  
下面的定理12.2.2 给出了群中逆元素的基本性质：  
【定理12.4】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，有：  
$$
(a^{-1})^{-1}=a\,\exists(a*b)^{-1}=b^{-1}*a^{-1}
$$  
下面的定理12.5 给出了群与方程可解性之间的关系：  
【定理12.5】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，方程$a\circ x=b$和$y\circ a=$$b$在$\langle G,*\rangle$中有且仅有唯一解。  
由于群结构满足结合律，故可类似于半群和含幺半群定义元素的方幂：  
【定义12.10】设$\langle G,*\rangle$是任意给定的一个群，对于$\forall a\in G$和正整数$ n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$ a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个a}
$$  
定义$a^{0}=e$且$a^{-n}=(a^{-1})^{n}$  
从上述定义可以看出，对于一个群结构$\langle G,*\rangle$可以定义其任意整数的方幂运算，包括负指数方幂。因此，对于$G$中的任何一个元素$a$，均可以通过其正方幂、零方幂和负方幂构成一个向胜负两端无限延伸的序列，具体如下：  
$$
\cdots,a^{-n},\cdots,a^{-2},a^{-1},a^{0}\ \ ,a^{1},a^{2},\cdots,a^{n},\cdots
$$  
这些序列显然满足幂的运算法则，即对于任意整数$n$和$m$，有：  
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
如果$\langle G,*\rangle$是一个有限群$\langle G,*\rangle$，则根据运算的封闭性和鸽笼原理易知，在$G$中任意一个元素的无穷多个方幂中，必然至少有两个是相等的。具体地说，对于任意给定的$G$中某个元素$a$，必然存在两个不相等的整数$m$和$|n$，不妨设$m<n$，满足：  
$$
a^n=a^m\text{或}a^{n-m}=e
$$  
此时，可将正整数$n-m$看成是元素$a$方幂变化的一个周期。一般地，有如下定义：  
【定义12.11】设$\langle G,*\rangle$是任意给定的一个群，$e$是该群的单位元，对于$G$中任意给定的某个元素$a$，如果存在正整数$n$，满足$a^{n}=e$，则其中最小的正整数称为元素$a$的周期或阶，记为$|a|$，否则称元素$a$的周期为无限大或元素$a$的阶为无限大。  
例如，对于群$\langle\underline{{6}},+_{6}\rangle$，元素1 的阶为6，元素2 的阶为3，元素3 的阶为2，元素4 的阶为3，元素5 的阶为6，元素0 的阶为1。对于整数集合上的加法群$\langle Z,+\rangle$，显然，除了元素0 的周期为1 之外，其余任一非零元素的周期均为无穷大。事实上，不难看出，对于任何一个群，有且只有其单位元的阶为1。  
下面给出关于元素阶的两个重要性质：  
【定理12.6】有限群$\langle G,*\rangle$的每个元素都有有限阶，且其阶数不超过群的阶数|G|。  
【定理12.7】设$\langle G,*\rangle$为群，$G$中元素$a$的阶为$ k$，那么$a^{n}=e$当且仅当$k$整除$ n$  。",有限群是一种群结构
无限群,是,群结构,,"如前所述，群代数结构是对幺半群结构在逆元方面的进一步扩充，其具体定义如下：  
【定义12.8】假设$\langle G,*\rangle$是任意给定的一个二元代数结构，如果$\langle G,*\rangle$满足如下性质：  
（1）结合律：对于$\forall x,y,z\in G$，成立：$(x\ \ *y)*z=x\ \ *(y*z)$；  
（2）含单位元：$\exists e\in G$，使得对于$\forall x\in G$，成立$\,\!e*x=x*e=x$；  
（3）运算$*$可逆：对于$\forall x\in G$，都存在$x^{-1}\in G$，使得$x^{-1}*x=x*x^{-1}=e$。  
则称$\langle G,*\rangle$是一个群代数结构，简称为群结构或群。  
从上述定义可知，对于任意给定的非空集合 $G$ 以及该集合上某个二元运算 $*$ ，$\langle G,*\rangle$ 能够 形成一个群结构的充分必要条件是$\langle G,*\rangle$必须满足封闭性、结合律、含幺性和可逆性这四个基本运算性质。例如，对于实数集合及其上的普通加法运算构成的代数结构$\langle R,+\rangle$，显然满足群的四条基本性质，其中0 是其单位元，对于$\forall x\in R$，$-x$是$x$的逆元。但是，对于实数集合及其上的普通乘法运算构成的代数结构$\langle R,\times\rangle$则不是一个群，因为在$\langle R,\times\rangle$中0 没有逆元素。不难发现，对于任意给定的集合$𝐴$，$\langle{ P}(A),\cup\rangle$和$\langle{ P}(A),\cap\rangle$都不能构成群结构，因为在$\langle{ P}(A),\cup\rangle$中$𝐴$没有逆元，在$\langle{P}(A),\cap\rangle$中$\varnothing$没有逆元。  
【定义12.9】设$\langle G,*\rangle$是任意给定的一个群，称$|G|$为$\langle G,*\rangle$的阶，如果$|G|$为有限数，则称  
$\langle G,*\rangle$为有限群，否则$\langle G,*\rangle$为无限群。如果运算$^*$满足交换律，即对于$\forall x,y\in G$，有$x*y=y*$$x$则称群$\langle G,*\rangle$是一个交换群或阿贝尔群。  
【定理12.3】设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$的单位元是$\langle G,*\rangle$中唯一的一个幂等元，若$|G|>1$，则$\langle G,*\rangle$中无零元且满足消去律。  
下面的定理12.2.2 给出了群中逆元素的基本性质：  
【定理12.4】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，有：  
$$
(a^{-1})^{-1}=a\,\exists(a*b)^{-1}=b^{-1}*a^{-1}
$$  
下面的定理12.5 给出了群与方程可解性之间的关系：  
【定理12.5】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，方程$a\circ x=b$和$y\circ a=$$b$在$\langle G,*\rangle$中有且仅有唯一解。  
由于群结构满足结合律，故可类似于半群和含幺半群定义元素的方幂：  
【定义12.10】设$\langle G,*\rangle$是任意给定的一个群，对于$\forall a\in G$和正整数$ n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$ a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个a}
$$  
定义$a^{0}=e$且$a^{-n}=(a^{-1})^{n}$  
从上述定义可以看出，对于一个群结构$\langle G,*\rangle$可以定义其任意整数的方幂运算，包括负指数方幂。因此，对于$G$中的任何一个元素$a$，均可以通过其正方幂、零方幂和负方幂构成一个向胜负两端无限延伸的序列，具体如下：  
$$
\cdots,a^{-n},\cdots,a^{-2},a^{-1},a^{0}\ \ ,a^{1},a^{2},\cdots,a^{n},\cdots
$$  
这些序列显然满足幂的运算法则，即对于任意整数$n$和$m$，有：  
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
如果$\langle G,*\rangle$是一个有限群$\langle G,*\rangle$，则根据运算的封闭性和鸽笼原理易知，在$G$中任意一个元素的无穷多个方幂中，必然至少有两个是相等的。具体地说，对于任意给定的$G$中某个元素$a$，必然存在两个不相等的整数$m$和$|n$，不妨设$m<n$，满足：  
$$
a^n=a^m\text{或}a^{n-m}=e
$$  
此时，可将正整数$n-m$看成是元素$a$方幂变化的一个周期。一般地，有如下定义：  
【定义12.11】设$\langle G,*\rangle$是任意给定的一个群，$e$是该群的单位元，对于$G$中任意给定的某个元素$a$，如果存在正整数$n$，满足$a^{n}=e$，则其中最小的正整数称为元素$a$的周期或阶，记为$|a|$，否则称元素$a$的周期为无限大或元素$a$的阶为无限大。  
例如，对于群$\langle\underline{{6}},+_{6}\rangle$，元素1 的阶为6，元素2 的阶为3，元素3 的阶为2，元素4 的阶为3，元素5 的阶为6，元素0 的阶为1。对于整数集合上的加法群$\langle Z,+\rangle$，显然，除了元素0 的周期为1 之外，其余任一非零元素的周期均为无穷大。事实上，不难看出，对于任何一个群，有且只有其单位元的阶为1。  
下面给出关于元素阶的两个重要性质：  
【定理12.6】有限群$\langle G,*\rangle$的每个元素都有有限阶，且其阶数不超过群的阶数|G|。  
【定理12.7】设$\langle G,*\rangle$为群，$G$中元素$a$的阶为$ k$，那么$a^{n}=e$当且仅当$k$整除$ n$  。",无限群是一种群结构
交换群,是,群结构,,"如前所述，群代数结构是对幺半群结构在逆元方面的进一步扩充，其具体定义如下：  
【定义12.8】假设$\langle G,*\rangle$是任意给定的一个二元代数结构，如果$\langle G,*\rangle$满足如下性质：  
（1）结合律：对于$\forall x,y,z\in G$，成立：$(x\ \ *y)*z=x\ \ *(y*z)$；  
（2）含单位元：$\exists e\in G$，使得对于$\forall x\in G$，成立$\,\!e*x=x*e=x$；  
（3）运算$*$可逆：对于$\forall x\in G$，都存在$x^{-1}\in G$，使得$x^{-1}*x=x*x^{-1}=e$。  
则称$\langle G,*\rangle$是一个群代数结构，简称为群结构或群。  
从上述定义可知，对于任意给定的非空集合 $G$ 以及该集合上某个二元运算 $*$ ，$\langle G,*\rangle$ 能够 形成一个群结构的充分必要条件是$\langle G,*\rangle$必须满足封闭性、结合律、含幺性和可逆性这四个基本运算性质。例如，对于实数集合及其上的普通加法运算构成的代数结构$\langle R,+\rangle$，显然满足群的四条基本性质，其中0 是其单位元，对于$\forall x\in R$，$-x$是$x$的逆元。但是，对于实数集合及其上的普通乘法运算构成的代数结构$\langle R,\times\rangle$则不是一个群，因为在$\langle R,\times\rangle$中0 没有逆元素。不难发现，对于任意给定的集合$𝐴$，$\langle{ P}(A),\cup\rangle$和$\langle{ P}(A),\cap\rangle$都不能构成群结构，因为在$\langle{ P}(A),\cup\rangle$中$𝐴$没有逆元，在$\langle{P}(A),\cap\rangle$中$\varnothing$没有逆元。  
【定义12.9】设$\langle G,*\rangle$是任意给定的一个群，称$|G|$为$\langle G,*\rangle$的阶，如果$|G|$为有限数，则称  
$\langle G,*\rangle$为有限群，否则$\langle G,*\rangle$为无限群。如果运算$^*$满足交换律，即对于$\forall x,y\in G$，有$x*y=y*$$x$则称群$\langle G,*\rangle$是一个交换群或阿贝尔群。  
【定理12.3】设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$的单位元是$\langle G,*\rangle$中唯一的一个幂等元，若$|G|>1$，则$\langle G,*\rangle$中无零元且满足消去律。  
下面的定理12.2.2 给出了群中逆元素的基本性质：  
【定理12.4】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，有：  
$$
(a^{-1})^{-1}=a\,\exists(a*b)^{-1}=b^{-1}*a^{-1}
$$  
下面的定理12.5 给出了群与方程可解性之间的关系：  
【定理12.5】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，方程$a\circ x=b$和$y\circ a=$$b$在$\langle G,*\rangle$中有且仅有唯一解。  
由于群结构满足结合律，故可类似于半群和含幺半群定义元素的方幂：  
【定义12.10】设$\langle G,*\rangle$是任意给定的一个群，对于$\forall a\in G$和正整数$ n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$ a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个a}
$$  
定义$a^{0}=e$且$a^{-n}=(a^{-1})^{n}$  
从上述定义可以看出，对于一个群结构$\langle G,*\rangle$可以定义其任意整数的方幂运算，包括负指数方幂。因此，对于$G$中的任何一个元素$a$，均可以通过其正方幂、零方幂和负方幂构成一个向胜负两端无限延伸的序列，具体如下：  
$$
\cdots,a^{-n},\cdots,a^{-2},a^{-1},a^{0}\ \ ,a^{1},a^{2},\cdots,a^{n},\cdots
$$  
这些序列显然满足幂的运算法则，即对于任意整数$n$和$m$，有：  
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
如果$\langle G,*\rangle$是一个有限群$\langle G,*\rangle$，则根据运算的封闭性和鸽笼原理易知，在$G$中任意一个元素的无穷多个方幂中，必然至少有两个是相等的。具体地说，对于任意给定的$G$中某个元素$a$，必然存在两个不相等的整数$m$和$|n$，不妨设$m<n$，满足：  
$$
a^n=a^m\text{或}a^{n-m}=e
$$  
此时，可将正整数$n-m$看成是元素$a$方幂变化的一个周期。一般地，有如下定义：  
【定义12.11】设$\langle G,*\rangle$是任意给定的一个群，$e$是该群的单位元，对于$G$中任意给定的某个元素$a$，如果存在正整数$n$，满足$a^{n}=e$，则其中最小的正整数称为元素$a$的周期或阶，记为$|a|$，否则称元素$a$的周期为无限大或元素$a$的阶为无限大。  
例如，对于群$\langle\underline{{6}},+_{6}\rangle$，元素1 的阶为6，元素2 的阶为3，元素3 的阶为2，元素4 的阶为3，元素5 的阶为6，元素0 的阶为1。对于整数集合上的加法群$\langle Z,+\rangle$，显然，除了元素0 的周期为1 之外，其余任一非零元素的周期均为无穷大。事实上，不难看出，对于任何一个群，有且只有其单位元的阶为1。  
下面给出关于元素阶的两个重要性质：  
【定理12.6】有限群$\langle G,*\rangle$的每个元素都有有限阶，且其阶数不超过群的阶数|G|。  
【定理12.7】设$\langle G,*\rangle$为群，$G$中元素$a$的阶为$ k$，那么$a^{n}=e$当且仅当$k$整除$ n$  。",交换群是一种群结构
交换群,满足,交换律,,"如前所述，群代数结构是对幺半群结构在逆元方面的进一步扩充，其具体定义如下：  
【定义12.8】假设$\langle G,*\rangle$是任意给定的一个二元代数结构，如果$\langle G,*\rangle$满足如下性质：  
（1）结合律：对于$\forall x,y,z\in G$，成立：$(x\ \ *y)*z=x\ \ *(y*z)$；  
（2）含单位元：$\exists e\in G$，使得对于$\forall x\in G$，成立$\,\!e*x=x*e=x$；  
（3）运算$*$可逆：对于$\forall x\in G$，都存在$x^{-1}\in G$，使得$x^{-1}*x=x*x^{-1}=e$。  
则称$\langle G,*\rangle$是一个群代数结构，简称为群结构或群。  
从上述定义可知，对于任意给定的非空集合 $G$ 以及该集合上某个二元运算 $*$ ，$\langle G,*\rangle$ 能够 形成一个群结构的充分必要条件是$\langle G,*\rangle$必须满足封闭性、结合律、含幺性和可逆性这四个基本运算性质。例如，对于实数集合及其上的普通加法运算构成的代数结构$\langle R,+\rangle$，显然满足群的四条基本性质，其中0 是其单位元，对于$\forall x\in R$，$-x$是$x$的逆元。但是，对于实数集合及其上的普通乘法运算构成的代数结构$\langle R,\times\rangle$则不是一个群，因为在$\langle R,\times\rangle$中0 没有逆元素。不难发现，对于任意给定的集合$𝐴$，$\langle{ P}(A),\cup\rangle$和$\langle{ P}(A),\cap\rangle$都不能构成群结构，因为在$\langle{ P}(A),\cup\rangle$中$𝐴$没有逆元，在$\langle{P}(A),\cap\rangle$中$\varnothing$没有逆元。  
【定义12.9】设$\langle G,*\rangle$是任意给定的一个群，称$|G|$为$\langle G,*\rangle$的阶，如果$|G|$为有限数，则称  
$\langle G,*\rangle$为有限群，否则$\langle G,*\rangle$为无限群。如果运算$^*$满足交换律，即对于$\forall x,y\in G$，有$x*y=y*$$x$则称群$\langle G,*\rangle$是一个交换群或阿贝尔群。  
【定理12.3】设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$的单位元是$\langle G,*\rangle$中唯一的一个幂等元，若$|G|>1$，则$\langle G,*\rangle$中无零元且满足消去律。  
下面的定理12.2.2 给出了群中逆元素的基本性质：  
【定理12.4】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，有：  
$$
(a^{-1})^{-1}=a\,\exists(a*b)^{-1}=b^{-1}*a^{-1}
$$  
下面的定理12.5 给出了群与方程可解性之间的关系：  
【定理12.5】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，方程$a\circ x=b$和$y\circ a=$$b$在$\langle G,*\rangle$中有且仅有唯一解。  
由于群结构满足结合律，故可类似于半群和含幺半群定义元素的方幂：  
【定义12.10】设$\langle G,*\rangle$是任意给定的一个群，对于$\forall a\in G$和正整数$ n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$ a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个a}
$$  
定义$a^{0}=e$且$a^{-n}=(a^{-1})^{n}$  
从上述定义可以看出，对于一个群结构$\langle G,*\rangle$可以定义其任意整数的方幂运算，包括负指数方幂。因此，对于$G$中的任何一个元素$a$，均可以通过其正方幂、零方幂和负方幂构成一个向胜负两端无限延伸的序列，具体如下：  
$$
\cdots,a^{-n},\cdots,a^{-2},a^{-1},a^{0}\ \ ,a^{1},a^{2},\cdots,a^{n},\cdots
$$  
这些序列显然满足幂的运算法则，即对于任意整数$n$和$m$，有：  
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
如果$\langle G,*\rangle$是一个有限群$\langle G,*\rangle$，则根据运算的封闭性和鸽笼原理易知，在$G$中任意一个元素的无穷多个方幂中，必然至少有两个是相等的。具体地说，对于任意给定的$G$中某个元素$a$，必然存在两个不相等的整数$m$和$|n$，不妨设$m<n$，满足：  
$$
a^n=a^m\text{或}a^{n-m}=e
$$  
此时，可将正整数$n-m$看成是元素$a$方幂变化的一个周期。一般地，有如下定义：  
【定义12.11】设$\langle G,*\rangle$是任意给定的一个群，$e$是该群的单位元，对于$G$中任意给定的某个元素$a$，如果存在正整数$n$，满足$a^{n}=e$，则其中最小的正整数称为元素$a$的周期或阶，记为$|a|$，否则称元素$a$的周期为无限大或元素$a$的阶为无限大。  
例如，对于群$\langle\underline{{6}},+_{6}\rangle$，元素1 的阶为6，元素2 的阶为3，元素3 的阶为2，元素4 的阶为3，元素5 的阶为6，元素0 的阶为1。对于整数集合上的加法群$\langle Z,+\rangle$，显然，除了元素0 的周期为1 之外，其余任一非零元素的周期均为无穷大。事实上，不难看出，对于任何一个群，有且只有其单位元的阶为1。  
下面给出关于元素阶的两个重要性质：  
【定理12.6】有限群$\langle G,*\rangle$的每个元素都有有限阶，且其阶数不超过群的阶数|G|。  
【定理12.7】设$\langle G,*\rangle$为群，$G$中元素$a$的阶为$ k$，那么$a^{n}=e$当且仅当$k$整除$ n$  。",交换群满足交换律
单位元,是,幂等元,,"如前所述，群代数结构是对幺半群结构在逆元方面的进一步扩充，其具体定义如下：  
【定义12.8】假设$\langle G,*\rangle$是任意给定的一个二元代数结构，如果$\langle G,*\rangle$满足如下性质：  
（1）结合律：对于$\forall x,y,z\in G$，成立：$(x\ \ *y)*z=x\ \ *(y*z)$；  
（2）含单位元：$\exists e\in G$，使得对于$\forall x\in G$，成立$\,\!e*x=x*e=x$；  
（3）运算$*$可逆：对于$\forall x\in G$，都存在$x^{-1}\in G$，使得$x^{-1}*x=x*x^{-1}=e$。  
则称$\langle G,*\rangle$是一个群代数结构，简称为群结构或群。  
从上述定义可知，对于任意给定的非空集合 $G$ 以及该集合上某个二元运算 $*$ ，$\langle G,*\rangle$ 能够 形成一个群结构的充分必要条件是$\langle G,*\rangle$必须满足封闭性、结合律、含幺性和可逆性这四个基本运算性质。例如，对于实数集合及其上的普通加法运算构成的代数结构$\langle R,+\rangle$，显然满足群的四条基本性质，其中0 是其单位元，对于$\forall x\in R$，$-x$是$x$的逆元。但是，对于实数集合及其上的普通乘法运算构成的代数结构$\langle R,\times\rangle$则不是一个群，因为在$\langle R,\times\rangle$中0 没有逆元素。不难发现，对于任意给定的集合$𝐴$，$\langle{ P}(A),\cup\rangle$和$\langle{ P}(A),\cap\rangle$都不能构成群结构，因为在$\langle{ P}(A),\cup\rangle$中$𝐴$没有逆元，在$\langle{P}(A),\cap\rangle$中$\varnothing$没有逆元。  
【定义12.9】设$\langle G,*\rangle$是任意给定的一个群，称$|G|$为$\langle G,*\rangle$的阶，如果$|G|$为有限数，则称  
$\langle G,*\rangle$为有限群，否则$\langle G,*\rangle$为无限群。如果运算$^*$满足交换律，即对于$\forall x,y\in G$，有$x*y=y*$$x$则称群$\langle G,*\rangle$是一个交换群或阿贝尔群。  
【定理12.3】设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$的单位元是$\langle G,*\rangle$中唯一的一个幂等元，若$|G|>1$，则$\langle G,*\rangle$中无零元且满足消去律。  
下面的定理12.2.2 给出了群中逆元素的基本性质：  
【定理12.4】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，有：  
$$
(a^{-1})^{-1}=a\,\exists(a*b)^{-1}=b^{-1}*a^{-1}
$$  
下面的定理12.5 给出了群与方程可解性之间的关系：  
【定理12.5】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，方程$a\circ x=b$和$y\circ a=$$b$在$\langle G,*\rangle$中有且仅有唯一解。  
由于群结构满足结合律，故可类似于半群和含幺半群定义元素的方幂：  
【定义12.10】设$\langle G,*\rangle$是任意给定的一个群，对于$\forall a\in G$和正整数$ n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$ a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个a}
$$  
定义$a^{0}=e$且$a^{-n}=(a^{-1})^{n}$  
从上述定义可以看出，对于一个群结构$\langle G,*\rangle$可以定义其任意整数的方幂运算，包括负指数方幂。因此，对于$G$中的任何一个元素$a$，均可以通过其正方幂、零方幂和负方幂构成一个向胜负两端无限延伸的序列，具体如下：  
$$
\cdots,a^{-n},\cdots,a^{-2},a^{-1},a^{0}\ \ ,a^{1},a^{2},\cdots,a^{n},\cdots
$$  
这些序列显然满足幂的运算法则，即对于任意整数$n$和$m$，有：  
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
如果$\langle G,*\rangle$是一个有限群$\langle G,*\rangle$，则根据运算的封闭性和鸽笼原理易知，在$G$中任意一个元素的无穷多个方幂中，必然至少有两个是相等的。具体地说，对于任意给定的$G$中某个元素$a$，必然存在两个不相等的整数$m$和$|n$，不妨设$m<n$，满足：  
$$
a^n=a^m\text{或}a^{n-m}=e
$$  
此时，可将正整数$n-m$看成是元素$a$方幂变化的一个周期。一般地，有如下定义：  
【定义12.11】设$\langle G,*\rangle$是任意给定的一个群，$e$是该群的单位元，对于$G$中任意给定的某个元素$a$，如果存在正整数$n$，满足$a^{n}=e$，则其中最小的正整数称为元素$a$的周期或阶，记为$|a|$，否则称元素$a$的周期为无限大或元素$a$的阶为无限大。  
例如，对于群$\langle\underline{{6}},+_{6}\rangle$，元素1 的阶为6，元素2 的阶为3，元素3 的阶为2，元素4 的阶为3，元素5 的阶为6，元素0 的阶为1。对于整数集合上的加法群$\langle Z,+\rangle$，显然，除了元素0 的周期为1 之外，其余任一非零元素的周期均为无穷大。事实上，不难看出，对于任何一个群，有且只有其单位元的阶为1。  
下面给出关于元素阶的两个重要性质：  
【定理12.6】有限群$\langle G,*\rangle$的每个元素都有有限阶，且其阶数不超过群的阶数|G|。  
【定理12.7】设$\langle G,*\rangle$为群，$G$中元素$a$的阶为$ k$，那么$a^{n}=e$当且仅当$k$整除$ n$  。",单位元是唯一的幂等元
群结构,满足,消去律,,"如前所述，群代数结构是对幺半群结构在逆元方面的进一步扩充，其具体定义如下：  
【定义12.8】假设$\langle G,*\rangle$是任意给定的一个二元代数结构，如果$\langle G,*\rangle$满足如下性质：  
（1）结合律：对于$\forall x,y,z\in G$，成立：$(x\ \ *y)*z=x\ \ *(y*z)$；  
（2）含单位元：$\exists e\in G$，使得对于$\forall x\in G$，成立$\,\!e*x=x*e=x$；  
（3）运算$*$可逆：对于$\forall x\in G$，都存在$x^{-1}\in G$，使得$x^{-1}*x=x*x^{-1}=e$。  
则称$\langle G,*\rangle$是一个群代数结构，简称为群结构或群。  
从上述定义可知，对于任意给定的非空集合 $G$ 以及该集合上某个二元运算 $*$ ，$\langle G,*\rangle$ 能够 形成一个群结构的充分必要条件是$\langle G,*\rangle$必须满足封闭性、结合律、含幺性和可逆性这四个基本运算性质。例如，对于实数集合及其上的普通加法运算构成的代数结构$\langle R,+\rangle$，显然满足群的四条基本性质，其中0 是其单位元，对于$\forall x\in R$，$-x$是$x$的逆元。但是，对于实数集合及其上的普通乘法运算构成的代数结构$\langle R,\times\rangle$则不是一个群，因为在$\langle R,\times\rangle$中0 没有逆元素。不难发现，对于任意给定的集合$𝐴$，$\langle{ P}(A),\cup\rangle$和$\langle{ P}(A),\cap\rangle$都不能构成群结构，因为在$\langle{ P}(A),\cup\rangle$中$𝐴$没有逆元，在$\langle{P}(A),\cap\rangle$中$\varnothing$没有逆元。  
【定义12.9】设$\langle G,*\rangle$是任意给定的一个群，称$|G|$为$\langle G,*\rangle$的阶，如果$|G|$为有限数，则称  
$\langle G,*\rangle$为有限群，否则$\langle G,*\rangle$为无限群。如果运算$^*$满足交换律，即对于$\forall x,y\in G$，有$x*y=y*$$x$则称群$\langle G,*\rangle$是一个交换群或阿贝尔群。  
【定理12.3】设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$的单位元是$\langle G,*\rangle$中唯一的一个幂等元，若$|G|>1$，则$\langle G,*\rangle$中无零元且满足消去律。  
下面的定理12.2.2 给出了群中逆元素的基本性质：  
【定理12.4】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，有：  
$$
(a^{-1})^{-1}=a\,\exists(a*b)^{-1}=b^{-1}*a^{-1}
$$  
下面的定理12.5 给出了群与方程可解性之间的关系：  
【定理12.5】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，方程$a\circ x=b$和$y\circ a=$$b$在$\langle G,*\rangle$中有且仅有唯一解。  
由于群结构满足结合律，故可类似于半群和含幺半群定义元素的方幂：  
【定义12.10】设$\langle G,*\rangle$是任意给定的一个群，对于$\forall a\in G$和正整数$ n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$ a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个a}
$$  
定义$a^{0}=e$且$a^{-n}=(a^{-1})^{n}$  
从上述定义可以看出，对于一个群结构$\langle G,*\rangle$可以定义其任意整数的方幂运算，包括负指数方幂。因此，对于$G$中的任何一个元素$a$，均可以通过其正方幂、零方幂和负方幂构成一个向胜负两端无限延伸的序列，具体如下：  
$$
\cdots,a^{-n},\cdots,a^{-2},a^{-1},a^{0}\ \ ,a^{1},a^{2},\cdots,a^{n},\cdots
$$  
这些序列显然满足幂的运算法则，即对于任意整数$n$和$m$，有：  
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
如果$\langle G,*\rangle$是一个有限群$\langle G,*\rangle$，则根据运算的封闭性和鸽笼原理易知，在$G$中任意一个元素的无穷多个方幂中，必然至少有两个是相等的。具体地说，对于任意给定的$G$中某个元素$a$，必然存在两个不相等的整数$m$和$|n$，不妨设$m<n$，满足：  
$$
a^n=a^m\text{或}a^{n-m}=e
$$  
此时，可将正整数$n-m$看成是元素$a$方幂变化的一个周期。一般地，有如下定义：  
【定义12.11】设$\langle G,*\rangle$是任意给定的一个群，$e$是该群的单位元，对于$G$中任意给定的某个元素$a$，如果存在正整数$n$，满足$a^{n}=e$，则其中最小的正整数称为元素$a$的周期或阶，记为$|a|$，否则称元素$a$的周期为无限大或元素$a$的阶为无限大。  
例如，对于群$\langle\underline{{6}},+_{6}\rangle$，元素1 的阶为6，元素2 的阶为3，元素3 的阶为2，元素4 的阶为3，元素5 的阶为6，元素0 的阶为1。对于整数集合上的加法群$\langle Z,+\rangle$，显然，除了元素0 的周期为1 之外，其余任一非零元素的周期均为无穷大。事实上，不难看出，对于任何一个群，有且只有其单位元的阶为1。  
下面给出关于元素阶的两个重要性质：  
【定理12.6】有限群$\langle G,*\rangle$的每个元素都有有限阶，且其阶数不超过群的阶数|G|。  
【定理12.7】设$\langle G,*\rangle$为群，$G$中元素$a$的阶为$ k$，那么$a^{n}=e$当且仅当$k$整除$ n$  。",群结构满足消去律
方幂,定义于,群结构,,"如前所述，群代数结构是对幺半群结构在逆元方面的进一步扩充，其具体定义如下：  
【定义12.8】假设$\langle G,*\rangle$是任意给定的一个二元代数结构，如果$\langle G,*\rangle$满足如下性质：  
（1）结合律：对于$\forall x,y,z\in G$，成立：$(x\ \ *y)*z=x\ \ *(y*z)$；  
（2）含单位元：$\exists e\in G$，使得对于$\forall x\in G$，成立$\,\!e*x=x*e=x$；  
（3）运算$*$可逆：对于$\forall x\in G$，都存在$x^{-1}\in G$，使得$x^{-1}*x=x*x^{-1}=e$。  
则称$\langle G,*\rangle$是一个群代数结构，简称为群结构或群。  
从上述定义可知，对于任意给定的非空集合 $G$ 以及该集合上某个二元运算 $*$ ，$\langle G,*\rangle$ 能够 形成一个群结构的充分必要条件是$\langle G,*\rangle$必须满足封闭性、结合律、含幺性和可逆性这四个基本运算性质。例如，对于实数集合及其上的普通加法运算构成的代数结构$\langle R,+\rangle$，显然满足群的四条基本性质，其中0 是其单位元，对于$\forall x\in R$，$-x$是$x$的逆元。但是，对于实数集合及其上的普通乘法运算构成的代数结构$\langle R,\times\rangle$则不是一个群，因为在$\langle R,\times\rangle$中0 没有逆元素。不难发现，对于任意给定的集合$𝐴$，$\langle{ P}(A),\cup\rangle$和$\langle{ P}(A),\cap\rangle$都不能构成群结构，因为在$\langle{ P}(A),\cup\rangle$中$𝐴$没有逆元，在$\langle{P}(A),\cap\rangle$中$\varnothing$没有逆元。  
【定义12.9】设$\langle G,*\rangle$是任意给定的一个群，称$|G|$为$\langle G,*\rangle$的阶，如果$|G|$为有限数，则称  
$\langle G,*\rangle$为有限群，否则$\langle G,*\rangle$为无限群。如果运算$^*$满足交换律，即对于$\forall x,y\in G$，有$x*y=y*$$x$则称群$\langle G,*\rangle$是一个交换群或阿贝尔群。  
【定理12.3】设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$的单位元是$\langle G,*\rangle$中唯一的一个幂等元，若$|G|>1$，则$\langle G,*\rangle$中无零元且满足消去律。  
下面的定理12.2.2 给出了群中逆元素的基本性质：  
【定理12.4】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，有：  
$$
(a^{-1})^{-1}=a\,\exists(a*b)^{-1}=b^{-1}*a^{-1}
$$  
下面的定理12.5 给出了群与方程可解性之间的关系：  
【定理12.5】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，方程$a\circ x=b$和$y\circ a=$$b$在$\langle G,*\rangle$中有且仅有唯一解。  
由于群结构满足结合律，故可类似于半群和含幺半群定义元素的方幂：  
【定义12.10】设$\langle G,*\rangle$是任意给定的一个群，对于$\forall a\in G$和正整数$ n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$ a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个a}
$$  
定义$a^{0}=e$且$a^{-n}=(a^{-1})^{n}$  
从上述定义可以看出，对于一个群结构$\langle G,*\rangle$可以定义其任意整数的方幂运算，包括负指数方幂。因此，对于$G$中的任何一个元素$a$，均可以通过其正方幂、零方幂和负方幂构成一个向胜负两端无限延伸的序列，具体如下：  
$$
\cdots,a^{-n},\cdots,a^{-2},a^{-1},a^{0}\ \ ,a^{1},a^{2},\cdots,a^{n},\cdots
$$  
这些序列显然满足幂的运算法则，即对于任意整数$n$和$m$，有：  
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
如果$\langle G,*\rangle$是一个有限群$\langle G,*\rangle$，则根据运算的封闭性和鸽笼原理易知，在$G$中任意一个元素的无穷多个方幂中，必然至少有两个是相等的。具体地说，对于任意给定的$G$中某个元素$a$，必然存在两个不相等的整数$m$和$|n$，不妨设$m<n$，满足：  
$$
a^n=a^m\text{或}a^{n-m}=e
$$  
此时，可将正整数$n-m$看成是元素$a$方幂变化的一个周期。一般地，有如下定义：  
【定义12.11】设$\langle G,*\rangle$是任意给定的一个群，$e$是该群的单位元，对于$G$中任意给定的某个元素$a$，如果存在正整数$n$，满足$a^{n}=e$，则其中最小的正整数称为元素$a$的周期或阶，记为$|a|$，否则称元素$a$的周期为无限大或元素$a$的阶为无限大。  
例如，对于群$\langle\underline{{6}},+_{6}\rangle$，元素1 的阶为6，元素2 的阶为3，元素3 的阶为2，元素4 的阶为3，元素5 的阶为6，元素0 的阶为1。对于整数集合上的加法群$\langle Z,+\rangle$，显然，除了元素0 的周期为1 之外，其余任一非零元素的周期均为无穷大。事实上，不难看出，对于任何一个群，有且只有其单位元的阶为1。  
下面给出关于元素阶的两个重要性质：  
【定理12.6】有限群$\langle G,*\rangle$的每个元素都有有限阶，且其阶数不超过群的阶数|G|。  
【定理12.7】设$\langle G,*\rangle$为群，$G$中元素$a$的阶为$ k$，那么$a^{n}=e$当且仅当$k$整除$ n$  。",方幂在群结构中定义
周期,相关,方幂,,"如前所述，群代数结构是对幺半群结构在逆元方面的进一步扩充，其具体定义如下：  
【定义12.8】假设$\langle G,*\rangle$是任意给定的一个二元代数结构，如果$\langle G,*\rangle$满足如下性质：  
（1）结合律：对于$\forall x,y,z\in G$，成立：$(x\ \ *y)*z=x\ \ *(y*z)$；  
（2）含单位元：$\exists e\in G$，使得对于$\forall x\in G$，成立$\,\!e*x=x*e=x$；  
（3）运算$*$可逆：对于$\forall x\in G$，都存在$x^{-1}\in G$，使得$x^{-1}*x=x*x^{-1}=e$。  
则称$\langle G,*\rangle$是一个群代数结构，简称为群结构或群。  
从上述定义可知，对于任意给定的非空集合 $G$ 以及该集合上某个二元运算 $*$ ，$\langle G,*\rangle$ 能够 形成一个群结构的充分必要条件是$\langle G,*\rangle$必须满足封闭性、结合律、含幺性和可逆性这四个基本运算性质。例如，对于实数集合及其上的普通加法运算构成的代数结构$\langle R,+\rangle$，显然满足群的四条基本性质，其中0 是其单位元，对于$\forall x\in R$，$-x$是$x$的逆元。但是，对于实数集合及其上的普通乘法运算构成的代数结构$\langle R,\times\rangle$则不是一个群，因为在$\langle R,\times\rangle$中0 没有逆元素。不难发现，对于任意给定的集合$𝐴$，$\langle{ P}(A),\cup\rangle$和$\langle{ P}(A),\cap\rangle$都不能构成群结构，因为在$\langle{ P}(A),\cup\rangle$中$𝐴$没有逆元，在$\langle{P}(A),\cap\rangle$中$\varnothing$没有逆元。  
【定义12.9】设$\langle G,*\rangle$是任意给定的一个群，称$|G|$为$\langle G,*\rangle$的阶，如果$|G|$为有限数，则称  
$\langle G,*\rangle$为有限群，否则$\langle G,*\rangle$为无限群。如果运算$^*$满足交换律，即对于$\forall x,y\in G$，有$x*y=y*$$x$则称群$\langle G,*\rangle$是一个交换群或阿贝尔群。  
【定理12.3】设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$的单位元是$\langle G,*\rangle$中唯一的一个幂等元，若$|G|>1$，则$\langle G,*\rangle$中无零元且满足消去律。  
下面的定理12.2.2 给出了群中逆元素的基本性质：  
【定理12.4】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，有：  
$$
(a^{-1})^{-1}=a\,\exists(a*b)^{-1}=b^{-1}*a^{-1}
$$  
下面的定理12.5 给出了群与方程可解性之间的关系：  
【定理12.5】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，方程$a\circ x=b$和$y\circ a=$$b$在$\langle G,*\rangle$中有且仅有唯一解。  
由于群结构满足结合律，故可类似于半群和含幺半群定义元素的方幂：  
【定义12.10】设$\langle G,*\rangle$是任意给定的一个群，对于$\forall a\in G$和正整数$ n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$ a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个a}
$$  
定义$a^{0}=e$且$a^{-n}=(a^{-1})^{n}$  
从上述定义可以看出，对于一个群结构$\langle G,*\rangle$可以定义其任意整数的方幂运算，包括负指数方幂。因此，对于$G$中的任何一个元素$a$，均可以通过其正方幂、零方幂和负方幂构成一个向胜负两端无限延伸的序列，具体如下：  
$$
\cdots,a^{-n},\cdots,a^{-2},a^{-1},a^{0}\ \ ,a^{1},a^{2},\cdots,a^{n},\cdots
$$  
这些序列显然满足幂的运算法则，即对于任意整数$n$和$m$，有：  
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
如果$\langle G,*\rangle$是一个有限群$\langle G,*\rangle$，则根据运算的封闭性和鸽笼原理易知，在$G$中任意一个元素的无穷多个方幂中，必然至少有两个是相等的。具体地说，对于任意给定的$G$中某个元素$a$，必然存在两个不相等的整数$m$和$|n$，不妨设$m<n$，满足：  
$$
a^n=a^m\text{或}a^{n-m}=e
$$  
此时，可将正整数$n-m$看成是元素$a$方幂变化的一个周期。一般地，有如下定义：  
【定义12.11】设$\langle G,*\rangle$是任意给定的一个群，$e$是该群的单位元，对于$G$中任意给定的某个元素$a$，如果存在正整数$n$，满足$a^{n}=e$，则其中最小的正整数称为元素$a$的周期或阶，记为$|a|$，否则称元素$a$的周期为无限大或元素$a$的阶为无限大。  
例如，对于群$\langle\underline{{6}},+_{6}\rangle$，元素1 的阶为6，元素2 的阶为3，元素3 的阶为2，元素4 的阶为3，元素5 的阶为6，元素0 的阶为1。对于整数集合上的加法群$\langle Z,+\rangle$，显然，除了元素0 的周期为1 之外，其余任一非零元素的周期均为无穷大。事实上，不难看出，对于任何一个群，有且只有其单位元的阶为1。  
下面给出关于元素阶的两个重要性质：  
【定理12.6】有限群$\langle G,*\rangle$的每个元素都有有限阶，且其阶数不超过群的阶数|G|。  
【定理12.7】设$\langle G,*\rangle$为群，$G$中元素$a$的阶为$ k$，那么$a^{n}=e$当且仅当$k$整除$ n$  。",周期与方幂相关
定理12.3,描述,单位元,,"如前所述，群代数结构是对幺半群结构在逆元方面的进一步扩充，其具体定义如下：  
【定义12.8】假设$\langle G,*\rangle$是任意给定的一个二元代数结构，如果$\langle G,*\rangle$满足如下性质：  
（1）结合律：对于$\forall x,y,z\in G$，成立：$(x\ \ *y)*z=x\ \ *(y*z)$；  
（2）含单位元：$\exists e\in G$，使得对于$\forall x\in G$，成立$\,\!e*x=x*e=x$；  
（3）运算$*$可逆：对于$\forall x\in G$，都存在$x^{-1}\in G$，使得$x^{-1}*x=x*x^{-1}=e$。  
则称$\langle G,*\rangle$是一个群代数结构，简称为群结构或群。  
从上述定义可知，对于任意给定的非空集合 $G$ 以及该集合上某个二元运算 $*$ ，$\langle G,*\rangle$ 能够 形成一个群结构的充分必要条件是$\langle G,*\rangle$必须满足封闭性、结合律、含幺性和可逆性这四个基本运算性质。例如，对于实数集合及其上的普通加法运算构成的代数结构$\langle R,+\rangle$，显然满足群的四条基本性质，其中0 是其单位元，对于$\forall x\in R$，$-x$是$x$的逆元。但是，对于实数集合及其上的普通乘法运算构成的代数结构$\langle R,\times\rangle$则不是一个群，因为在$\langle R,\times\rangle$中0 没有逆元素。不难发现，对于任意给定的集合$𝐴$，$\langle{ P}(A),\cup\rangle$和$\langle{ P}(A),\cap\rangle$都不能构成群结构，因为在$\langle{ P}(A),\cup\rangle$中$𝐴$没有逆元，在$\langle{P}(A),\cap\rangle$中$\varnothing$没有逆元。  
【定义12.9】设$\langle G,*\rangle$是任意给定的一个群，称$|G|$为$\langle G,*\rangle$的阶，如果$|G|$为有限数，则称  
$\langle G,*\rangle$为有限群，否则$\langle G,*\rangle$为无限群。如果运算$^*$满足交换律，即对于$\forall x,y\in G$，有$x*y=y*$$x$则称群$\langle G,*\rangle$是一个交换群或阿贝尔群。  
【定理12.3】设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$的单位元是$\langle G,*\rangle$中唯一的一个幂等元，若$|G|>1$，则$\langle G,*\rangle$中无零元且满足消去律。  
下面的定理12.2.2 给出了群中逆元素的基本性质：  
【定理12.4】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，有：  
$$
(a^{-1})^{-1}=a\,\exists(a*b)^{-1}=b^{-1}*a^{-1}
$$  
下面的定理12.5 给出了群与方程可解性之间的关系：  
【定理12.5】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，方程$a\circ x=b$和$y\circ a=$$b$在$\langle G,*\rangle$中有且仅有唯一解。  
由于群结构满足结合律，故可类似于半群和含幺半群定义元素的方幂：  
【定义12.10】设$\langle G,*\rangle$是任意给定的一个群，对于$\forall a\in G$和正整数$ n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$ a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个a}
$$  
定义$a^{0}=e$且$a^{-n}=(a^{-1})^{n}$  
从上述定义可以看出，对于一个群结构$\langle G,*\rangle$可以定义其任意整数的方幂运算，包括负指数方幂。因此，对于$G$中的任何一个元素$a$，均可以通过其正方幂、零方幂和负方幂构成一个向胜负两端无限延伸的序列，具体如下：  
$$
\cdots,a^{-n},\cdots,a^{-2},a^{-1},a^{0}\ \ ,a^{1},a^{2},\cdots,a^{n},\cdots
$$  
这些序列显然满足幂的运算法则，即对于任意整数$n$和$m$，有：  
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
如果$\langle G,*\rangle$是一个有限群$\langle G,*\rangle$，则根据运算的封闭性和鸽笼原理易知，在$G$中任意一个元素的无穷多个方幂中，必然至少有两个是相等的。具体地说，对于任意给定的$G$中某个元素$a$，必然存在两个不相等的整数$m$和$|n$，不妨设$m<n$，满足：  
$$
a^n=a^m\text{或}a^{n-m}=e
$$  
此时，可将正整数$n-m$看成是元素$a$方幂变化的一个周期。一般地，有如下定义：  
【定义12.11】设$\langle G,*\rangle$是任意给定的一个群，$e$是该群的单位元，对于$G$中任意给定的某个元素$a$，如果存在正整数$n$，满足$a^{n}=e$，则其中最小的正整数称为元素$a$的周期或阶，记为$|a|$，否则称元素$a$的周期为无限大或元素$a$的阶为无限大。  
例如，对于群$\langle\underline{{6}},+_{6}\rangle$，元素1 的阶为6，元素2 的阶为3，元素3 的阶为2，元素4 的阶为3，元素5 的阶为6，元素0 的阶为1。对于整数集合上的加法群$\langle Z,+\rangle$，显然，除了元素0 的周期为1 之外，其余任一非零元素的周期均为无穷大。事实上，不难看出，对于任何一个群，有且只有其单位元的阶为1。  
下面给出关于元素阶的两个重要性质：  
【定理12.6】有限群$\langle G,*\rangle$的每个元素都有有限阶，且其阶数不超过群的阶数|G|。  
【定理12.7】设$\langle G,*\rangle$为群，$G$中元素$a$的阶为$ k$，那么$a^{n}=e$当且仅当$k$整除$ n$  。",定理12.3描述单位元的性质
定理12.3,描述,消去律,,"如前所述，群代数结构是对幺半群结构在逆元方面的进一步扩充，其具体定义如下：  
【定义12.8】假设$\langle G,*\rangle$是任意给定的一个二元代数结构，如果$\langle G,*\rangle$满足如下性质：  
（1）结合律：对于$\forall x,y,z\in G$，成立：$(x\ \ *y)*z=x\ \ *(y*z)$；  
（2）含单位元：$\exists e\in G$，使得对于$\forall x\in G$，成立$\,\!e*x=x*e=x$；  
（3）运算$*$可逆：对于$\forall x\in G$，都存在$x^{-1}\in G$，使得$x^{-1}*x=x*x^{-1}=e$。  
则称$\langle G,*\rangle$是一个群代数结构，简称为群结构或群。  
从上述定义可知，对于任意给定的非空集合 $G$ 以及该集合上某个二元运算 $*$ ，$\langle G,*\rangle$ 能够 形成一个群结构的充分必要条件是$\langle G,*\rangle$必须满足封闭性、结合律、含幺性和可逆性这四个基本运算性质。例如，对于实数集合及其上的普通加法运算构成的代数结构$\langle R,+\rangle$，显然满足群的四条基本性质，其中0 是其单位元，对于$\forall x\in R$，$-x$是$x$的逆元。但是，对于实数集合及其上的普通乘法运算构成的代数结构$\langle R,\times\rangle$则不是一个群，因为在$\langle R,\times\rangle$中0 没有逆元素。不难发现，对于任意给定的集合$𝐴$，$\langle{ P}(A),\cup\rangle$和$\langle{ P}(A),\cap\rangle$都不能构成群结构，因为在$\langle{ P}(A),\cup\rangle$中$𝐴$没有逆元，在$\langle{P}(A),\cap\rangle$中$\varnothing$没有逆元。  
【定义12.9】设$\langle G,*\rangle$是任意给定的一个群，称$|G|$为$\langle G,*\rangle$的阶，如果$|G|$为有限数，则称  
$\langle G,*\rangle$为有限群，否则$\langle G,*\rangle$为无限群。如果运算$^*$满足交换律，即对于$\forall x,y\in G$，有$x*y=y*$$x$则称群$\langle G,*\rangle$是一个交换群或阿贝尔群。  
【定理12.3】设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$的单位元是$\langle G,*\rangle$中唯一的一个幂等元，若$|G|>1$，则$\langle G,*\rangle$中无零元且满足消去律。  
下面的定理12.2.2 给出了群中逆元素的基本性质：  
【定理12.4】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，有：  
$$
(a^{-1})^{-1}=a\,\exists(a*b)^{-1}=b^{-1}*a^{-1}
$$  
下面的定理12.5 给出了群与方程可解性之间的关系：  
【定理12.5】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，方程$a\circ x=b$和$y\circ a=$$b$在$\langle G,*\rangle$中有且仅有唯一解。  
由于群结构满足结合律，故可类似于半群和含幺半群定义元素的方幂：  
【定义12.10】设$\langle G,*\rangle$是任意给定的一个群，对于$\forall a\in G$和正整数$ n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$ a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个a}
$$  
定义$a^{0}=e$且$a^{-n}=(a^{-1})^{n}$  
从上述定义可以看出，对于一个群结构$\langle G,*\rangle$可以定义其任意整数的方幂运算，包括负指数方幂。因此，对于$G$中的任何一个元素$a$，均可以通过其正方幂、零方幂和负方幂构成一个向胜负两端无限延伸的序列，具体如下：  
$$
\cdots,a^{-n},\cdots,a^{-2},a^{-1},a^{0}\ \ ,a^{1},a^{2},\cdots,a^{n},\cdots
$$  
这些序列显然满足幂的运算法则，即对于任意整数$n$和$m$，有：  
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
如果$\langle G,*\rangle$是一个有限群$\langle G,*\rangle$，则根据运算的封闭性和鸽笼原理易知，在$G$中任意一个元素的无穷多个方幂中，必然至少有两个是相等的。具体地说，对于任意给定的$G$中某个元素$a$，必然存在两个不相等的整数$m$和$|n$，不妨设$m<n$，满足：  
$$
a^n=a^m\text{或}a^{n-m}=e
$$  
此时，可将正整数$n-m$看成是元素$a$方幂变化的一个周期。一般地，有如下定义：  
【定义12.11】设$\langle G,*\rangle$是任意给定的一个群，$e$是该群的单位元，对于$G$中任意给定的某个元素$a$，如果存在正整数$n$，满足$a^{n}=e$，则其中最小的正整数称为元素$a$的周期或阶，记为$|a|$，否则称元素$a$的周期为无限大或元素$a$的阶为无限大。  
例如，对于群$\langle\underline{{6}},+_{6}\rangle$，元素1 的阶为6，元素2 的阶为3，元素3 的阶为2，元素4 的阶为3，元素5 的阶为6，元素0 的阶为1。对于整数集合上的加法群$\langle Z,+\rangle$，显然，除了元素0 的周期为1 之外，其余任一非零元素的周期均为无穷大。事实上，不难看出，对于任何一个群，有且只有其单位元的阶为1。  
下面给出关于元素阶的两个重要性质：  
【定理12.6】有限群$\langle G,*\rangle$的每个元素都有有限阶，且其阶数不超过群的阶数|G|。  
【定理12.7】设$\langle G,*\rangle$为群，$G$中元素$a$的阶为$ k$，那么$a^{n}=e$当且仅当$k$整除$ n$  。",定理12.3描述消去律
定理12.4,描述,逆元,,"如前所述，群代数结构是对幺半群结构在逆元方面的进一步扩充，其具体定义如下：  
【定义12.8】假设$\langle G,*\rangle$是任意给定的一个二元代数结构，如果$\langle G,*\rangle$满足如下性质：  
（1）结合律：对于$\forall x,y,z\in G$，成立：$(x\ \ *y)*z=x\ \ *(y*z)$；  
（2）含单位元：$\exists e\in G$，使得对于$\forall x\in G$，成立$\,\!e*x=x*e=x$；  
（3）运算$*$可逆：对于$\forall x\in G$，都存在$x^{-1}\in G$，使得$x^{-1}*x=x*x^{-1}=e$。  
则称$\langle G,*\rangle$是一个群代数结构，简称为群结构或群。  
从上述定义可知，对于任意给定的非空集合 $G$ 以及该集合上某个二元运算 $*$ ，$\langle G,*\rangle$ 能够 形成一个群结构的充分必要条件是$\langle G,*\rangle$必须满足封闭性、结合律、含幺性和可逆性这四个基本运算性质。例如，对于实数集合及其上的普通加法运算构成的代数结构$\langle R,+\rangle$，显然满足群的四条基本性质，其中0 是其单位元，对于$\forall x\in R$，$-x$是$x$的逆元。但是，对于实数集合及其上的普通乘法运算构成的代数结构$\langle R,\times\rangle$则不是一个群，因为在$\langle R,\times\rangle$中0 没有逆元素。不难发现，对于任意给定的集合$𝐴$，$\langle{ P}(A),\cup\rangle$和$\langle{ P}(A),\cap\rangle$都不能构成群结构，因为在$\langle{ P}(A),\cup\rangle$中$𝐴$没有逆元，在$\langle{P}(A),\cap\rangle$中$\varnothing$没有逆元。  
【定义12.9】设$\langle G,*\rangle$是任意给定的一个群，称$|G|$为$\langle G,*\rangle$的阶，如果$|G|$为有限数，则称  
$\langle G,*\rangle$为有限群，否则$\langle G,*\rangle$为无限群。如果运算$^*$满足交换律，即对于$\forall x,y\in G$，有$x*y=y*$$x$则称群$\langle G,*\rangle$是一个交换群或阿贝尔群。  
【定理12.3】设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$的单位元是$\langle G,*\rangle$中唯一的一个幂等元，若$|G|>1$，则$\langle G,*\rangle$中无零元且满足消去律。  
下面的定理12.2.2 给出了群中逆元素的基本性质：  
【定理12.4】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，有：  
$$
(a^{-1})^{-1}=a\,\exists(a*b)^{-1}=b^{-1}*a^{-1}
$$  
下面的定理12.5 给出了群与方程可解性之间的关系：  
【定理12.5】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，方程$a\circ x=b$和$y\circ a=$$b$在$\langle G,*\rangle$中有且仅有唯一解。  
由于群结构满足结合律，故可类似于半群和含幺半群定义元素的方幂：  
【定义12.10】设$\langle G,*\rangle$是任意给定的一个群，对于$\forall a\in G$和正整数$ n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$ a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个a}
$$  
定义$a^{0}=e$且$a^{-n}=(a^{-1})^{n}$  
从上述定义可以看出，对于一个群结构$\langle G,*\rangle$可以定义其任意整数的方幂运算，包括负指数方幂。因此，对于$G$中的任何一个元素$a$，均可以通过其正方幂、零方幂和负方幂构成一个向胜负两端无限延伸的序列，具体如下：  
$$
\cdots,a^{-n},\cdots,a^{-2},a^{-1},a^{0}\ \ ,a^{1},a^{2},\cdots,a^{n},\cdots
$$  
这些序列显然满足幂的运算法则，即对于任意整数$n$和$m$，有：  
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
如果$\langle G,*\rangle$是一个有限群$\langle G,*\rangle$，则根据运算的封闭性和鸽笼原理易知，在$G$中任意一个元素的无穷多个方幂中，必然至少有两个是相等的。具体地说，对于任意给定的$G$中某个元素$a$，必然存在两个不相等的整数$m$和$|n$，不妨设$m<n$，满足：  
$$
a^n=a^m\text{或}a^{n-m}=e
$$  
此时，可将正整数$n-m$看成是元素$a$方幂变化的一个周期。一般地，有如下定义：  
【定义12.11】设$\langle G,*\rangle$是任意给定的一个群，$e$是该群的单位元，对于$G$中任意给定的某个元素$a$，如果存在正整数$n$，满足$a^{n}=e$，则其中最小的正整数称为元素$a$的周期或阶，记为$|a|$，否则称元素$a$的周期为无限大或元素$a$的阶为无限大。  
例如，对于群$\langle\underline{{6}},+_{6}\rangle$，元素1 的阶为6，元素2 的阶为3，元素3 的阶为2，元素4 的阶为3，元素5 的阶为6，元素0 的阶为1。对于整数集合上的加法群$\langle Z,+\rangle$，显然，除了元素0 的周期为1 之外，其余任一非零元素的周期均为无穷大。事实上，不难看出，对于任何一个群，有且只有其单位元的阶为1。  
下面给出关于元素阶的两个重要性质：  
【定理12.6】有限群$\langle G,*\rangle$的每个元素都有有限阶，且其阶数不超过群的阶数|G|。  
【定理12.7】设$\langle G,*\rangle$为群，$G$中元素$a$的阶为$ k$，那么$a^{n}=e$当且仅当$k$整除$ n$  。",定理12.4描述逆元的性质
定理12.5,描述,方程可解性,,"如前所述，群代数结构是对幺半群结构在逆元方面的进一步扩充，其具体定义如下：  
【定义12.8】假设$\langle G,*\rangle$是任意给定的一个二元代数结构，如果$\langle G,*\rangle$满足如下性质：  
（1）结合律：对于$\forall x,y,z\in G$，成立：$(x\ \ *y)*z=x\ \ *(y*z)$；  
（2）含单位元：$\exists e\in G$，使得对于$\forall x\in G$，成立$\,\!e*x=x*e=x$；  
（3）运算$*$可逆：对于$\forall x\in G$，都存在$x^{-1}\in G$，使得$x^{-1}*x=x*x^{-1}=e$。  
则称$\langle G,*\rangle$是一个群代数结构，简称为群结构或群。  
从上述定义可知，对于任意给定的非空集合 $G$ 以及该集合上某个二元运算 $*$ ，$\langle G,*\rangle$ 能够 形成一个群结构的充分必要条件是$\langle G,*\rangle$必须满足封闭性、结合律、含幺性和可逆性这四个基本运算性质。例如，对于实数集合及其上的普通加法运算构成的代数结构$\langle R,+\rangle$，显然满足群的四条基本性质，其中0 是其单位元，对于$\forall x\in R$，$-x$是$x$的逆元。但是，对于实数集合及其上的普通乘法运算构成的代数结构$\langle R,\times\rangle$则不是一个群，因为在$\langle R,\times\rangle$中0 没有逆元素。不难发现，对于任意给定的集合$𝐴$，$\langle{ P}(A),\cup\rangle$和$\langle{ P}(A),\cap\rangle$都不能构成群结构，因为在$\langle{ P}(A),\cup\rangle$中$𝐴$没有逆元，在$\langle{P}(A),\cap\rangle$中$\varnothing$没有逆元。  
【定义12.9】设$\langle G,*\rangle$是任意给定的一个群，称$|G|$为$\langle G,*\rangle$的阶，如果$|G|$为有限数，则称  
$\langle G,*\rangle$为有限群，否则$\langle G,*\rangle$为无限群。如果运算$^*$满足交换律，即对于$\forall x,y\in G$，有$x*y=y*$$x$则称群$\langle G,*\rangle$是一个交换群或阿贝尔群。  
【定理12.3】设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$的单位元是$\langle G,*\rangle$中唯一的一个幂等元，若$|G|>1$，则$\langle G,*\rangle$中无零元且满足消去律。  
下面的定理12.2.2 给出了群中逆元素的基本性质：  
【定理12.4】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，有：  
$$
(a^{-1})^{-1}=a\,\exists(a*b)^{-1}=b^{-1}*a^{-1}
$$  
下面的定理12.5 给出了群与方程可解性之间的关系：  
【定理12.5】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，方程$a\circ x=b$和$y\circ a=$$b$在$\langle G,*\rangle$中有且仅有唯一解。  
由于群结构满足结合律，故可类似于半群和含幺半群定义元素的方幂：  
【定义12.10】设$\langle G,*\rangle$是任意给定的一个群，对于$\forall a\in G$和正整数$ n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$ a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个a}
$$  
定义$a^{0}=e$且$a^{-n}=(a^{-1})^{n}$  
从上述定义可以看出，对于一个群结构$\langle G,*\rangle$可以定义其任意整数的方幂运算，包括负指数方幂。因此，对于$G$中的任何一个元素$a$，均可以通过其正方幂、零方幂和负方幂构成一个向胜负两端无限延伸的序列，具体如下：  
$$
\cdots,a^{-n},\cdots,a^{-2},a^{-1},a^{0}\ \ ,a^{1},a^{2},\cdots,a^{n},\cdots
$$  
这些序列显然满足幂的运算法则，即对于任意整数$n$和$m$，有：  
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
如果$\langle G,*\rangle$是一个有限群$\langle G,*\rangle$，则根据运算的封闭性和鸽笼原理易知，在$G$中任意一个元素的无穷多个方幂中，必然至少有两个是相等的。具体地说，对于任意给定的$G$中某个元素$a$，必然存在两个不相等的整数$m$和$|n$，不妨设$m<n$，满足：  
$$
a^n=a^m\text{或}a^{n-m}=e
$$  
此时，可将正整数$n-m$看成是元素$a$方幂变化的一个周期。一般地，有如下定义：  
【定义12.11】设$\langle G,*\rangle$是任意给定的一个群，$e$是该群的单位元，对于$G$中任意给定的某个元素$a$，如果存在正整数$n$，满足$a^{n}=e$，则其中最小的正整数称为元素$a$的周期或阶，记为$|a|$，否则称元素$a$的周期为无限大或元素$a$的阶为无限大。  
例如，对于群$\langle\underline{{6}},+_{6}\rangle$，元素1 的阶为6，元素2 的阶为3，元素3 的阶为2，元素4 的阶为3，元素5 的阶为6，元素0 的阶为1。对于整数集合上的加法群$\langle Z,+\rangle$，显然，除了元素0 的周期为1 之外，其余任一非零元素的周期均为无穷大。事实上，不难看出，对于任何一个群，有且只有其单位元的阶为1。  
下面给出关于元素阶的两个重要性质：  
【定理12.6】有限群$\langle G,*\rangle$的每个元素都有有限阶，且其阶数不超过群的阶数|G|。  
【定理12.7】设$\langle G,*\rangle$为群，$G$中元素$a$的阶为$ k$，那么$a^{n}=e$当且仅当$k$整除$ n$  。",定理12.5描述群与方程可解性的关系
定理12.6,描述,有限群,,"如前所述，群代数结构是对幺半群结构在逆元方面的进一步扩充，其具体定义如下：  
【定义12.8】假设$\langle G,*\rangle$是任意给定的一个二元代数结构，如果$\langle G,*\rangle$满足如下性质：  
（1）结合律：对于$\forall x,y,z\in G$，成立：$(x\ \ *y)*z=x\ \ *(y*z)$；  
（2）含单位元：$\exists e\in G$，使得对于$\forall x\in G$，成立$\,\!e*x=x*e=x$；  
（3）运算$*$可逆：对于$\forall x\in G$，都存在$x^{-1}\in G$，使得$x^{-1}*x=x*x^{-1}=e$。  
则称$\langle G,*\rangle$是一个群代数结构，简称为群结构或群。  
从上述定义可知，对于任意给定的非空集合 $G$ 以及该集合上某个二元运算 $*$ ，$\langle G,*\rangle$ 能够 形成一个群结构的充分必要条件是$\langle G,*\rangle$必须满足封闭性、结合律、含幺性和可逆性这四个基本运算性质。例如，对于实数集合及其上的普通加法运算构成的代数结构$\langle R,+\rangle$，显然满足群的四条基本性质，其中0 是其单位元，对于$\forall x\in R$，$-x$是$x$的逆元。但是，对于实数集合及其上的普通乘法运算构成的代数结构$\langle R,\times\rangle$则不是一个群，因为在$\langle R,\times\rangle$中0 没有逆元素。不难发现，对于任意给定的集合$𝐴$，$\langle{ P}(A),\cup\rangle$和$\langle{ P}(A),\cap\rangle$都不能构成群结构，因为在$\langle{ P}(A),\cup\rangle$中$𝐴$没有逆元，在$\langle{P}(A),\cap\rangle$中$\varnothing$没有逆元。  
【定义12.9】设$\langle G,*\rangle$是任意给定的一个群，称$|G|$为$\langle G,*\rangle$的阶，如果$|G|$为有限数，则称  
$\langle G,*\rangle$为有限群，否则$\langle G,*\rangle$为无限群。如果运算$^*$满足交换律，即对于$\forall x,y\in G$，有$x*y=y*$$x$则称群$\langle G,*\rangle$是一个交换群或阿贝尔群。  
【定理12.3】设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$的单位元是$\langle G,*\rangle$中唯一的一个幂等元，若$|G|>1$，则$\langle G,*\rangle$中无零元且满足消去律。  
下面的定理12.2.2 给出了群中逆元素的基本性质：  
【定理12.4】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，有：  
$$
(a^{-1})^{-1}=a\,\exists(a*b)^{-1}=b^{-1}*a^{-1}
$$  
下面的定理12.5 给出了群与方程可解性之间的关系：  
【定理12.5】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，方程$a\circ x=b$和$y\circ a=$$b$在$\langle G,*\rangle$中有且仅有唯一解。  
由于群结构满足结合律，故可类似于半群和含幺半群定义元素的方幂：  
【定义12.10】设$\langle G,*\rangle$是任意给定的一个群，对于$\forall a\in G$和正整数$ n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$ a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个a}
$$  
定义$a^{0}=e$且$a^{-n}=(a^{-1})^{n}$  
从上述定义可以看出，对于一个群结构$\langle G,*\rangle$可以定义其任意整数的方幂运算，包括负指数方幂。因此，对于$G$中的任何一个元素$a$，均可以通过其正方幂、零方幂和负方幂构成一个向胜负两端无限延伸的序列，具体如下：  
$$
\cdots,a^{-n},\cdots,a^{-2},a^{-1},a^{0}\ \ ,a^{1},a^{2},\cdots,a^{n},\cdots
$$  
这些序列显然满足幂的运算法则，即对于任意整数$n$和$m$，有：  
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
如果$\langle G,*\rangle$是一个有限群$\langle G,*\rangle$，则根据运算的封闭性和鸽笼原理易知，在$G$中任意一个元素的无穷多个方幂中，必然至少有两个是相等的。具体地说，对于任意给定的$G$中某个元素$a$，必然存在两个不相等的整数$m$和$|n$，不妨设$m<n$，满足：  
$$
a^n=a^m\text{或}a^{n-m}=e
$$  
此时，可将正整数$n-m$看成是元素$a$方幂变化的一个周期。一般地，有如下定义：  
【定义12.11】设$\langle G,*\rangle$是任意给定的一个群，$e$是该群的单位元，对于$G$中任意给定的某个元素$a$，如果存在正整数$n$，满足$a^{n}=e$，则其中最小的正整数称为元素$a$的周期或阶，记为$|a|$，否则称元素$a$的周期为无限大或元素$a$的阶为无限大。  
例如，对于群$\langle\underline{{6}},+_{6}\rangle$，元素1 的阶为6，元素2 的阶为3，元素3 的阶为2，元素4 的阶为3，元素5 的阶为6，元素0 的阶为1。对于整数集合上的加法群$\langle Z,+\rangle$，显然，除了元素0 的周期为1 之外，其余任一非零元素的周期均为无穷大。事实上，不难看出，对于任何一个群，有且只有其单位元的阶为1。  
下面给出关于元素阶的两个重要性质：  
【定理12.6】有限群$\langle G,*\rangle$的每个元素都有有限阶，且其阶数不超过群的阶数|G|。  
【定理12.7】设$\langle G,*\rangle$为群，$G$中元素$a$的阶为$ k$，那么$a^{n}=e$当且仅当$k$整除$ n$  。",定理12.6描述有限群元素的阶
定理12.7,描述,方幂,,"如前所述，群代数结构是对幺半群结构在逆元方面的进一步扩充，其具体定义如下：  
【定义12.8】假设$\langle G,*\rangle$是任意给定的一个二元代数结构，如果$\langle G,*\rangle$满足如下性质：  
（1）结合律：对于$\forall x,y,z\in G$，成立：$(x\ \ *y)*z=x\ \ *(y*z)$；  
（2）含单位元：$\exists e\in G$，使得对于$\forall x\in G$，成立$\,\!e*x=x*e=x$；  
（3）运算$*$可逆：对于$\forall x\in G$，都存在$x^{-1}\in G$，使得$x^{-1}*x=x*x^{-1}=e$。  
则称$\langle G,*\rangle$是一个群代数结构，简称为群结构或群。  
从上述定义可知，对于任意给定的非空集合 $G$ 以及该集合上某个二元运算 $*$ ，$\langle G,*\rangle$ 能够 形成一个群结构的充分必要条件是$\langle G,*\rangle$必须满足封闭性、结合律、含幺性和可逆性这四个基本运算性质。例如，对于实数集合及其上的普通加法运算构成的代数结构$\langle R,+\rangle$，显然满足群的四条基本性质，其中0 是其单位元，对于$\forall x\in R$，$-x$是$x$的逆元。但是，对于实数集合及其上的普通乘法运算构成的代数结构$\langle R,\times\rangle$则不是一个群，因为在$\langle R,\times\rangle$中0 没有逆元素。不难发现，对于任意给定的集合$𝐴$，$\langle{ P}(A),\cup\rangle$和$\langle{ P}(A),\cap\rangle$都不能构成群结构，因为在$\langle{ P}(A),\cup\rangle$中$𝐴$没有逆元，在$\langle{P}(A),\cap\rangle$中$\varnothing$没有逆元。  
【定义12.9】设$\langle G,*\rangle$是任意给定的一个群，称$|G|$为$\langle G,*\rangle$的阶，如果$|G|$为有限数，则称  
$\langle G,*\rangle$为有限群，否则$\langle G,*\rangle$为无限群。如果运算$^*$满足交换律，即对于$\forall x,y\in G$，有$x*y=y*$$x$则称群$\langle G,*\rangle$是一个交换群或阿贝尔群。  
【定理12.3】设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$的单位元是$\langle G,*\rangle$中唯一的一个幂等元，若$|G|>1$，则$\langle G,*\rangle$中无零元且满足消去律。  
下面的定理12.2.2 给出了群中逆元素的基本性质：  
【定理12.4】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，有：  
$$
(a^{-1})^{-1}=a\,\exists(a*b)^{-1}=b^{-1}*a^{-1}
$$  
下面的定理12.5 给出了群与方程可解性之间的关系：  
【定理12.5】设$\langle G,*\rangle$是任意给定的一个群，则对于$\forall a,b\in G$，方程$a\circ x=b$和$y\circ a=$$b$在$\langle G,*\rangle$中有且仅有唯一解。  
由于群结构满足结合律，故可类似于半群和含幺半群定义元素的方幂：  
【定义12.10】设$\langle G,*\rangle$是任意给定的一个群，对于$\forall a\in G$和正整数$ n$，$a$的$n$次方幂定义为$n$个$a$的重复$n-1$ 次$*$运算，记为$ a^{n}$。即有：  
$$
a^n=a^{n-1}*a=\overbrace{a*a*\cdots*a}^{n个a}
$$  
定义$a^{0}=e$且$a^{-n}=(a^{-1})^{n}$  
从上述定义可以看出，对于一个群结构$\langle G,*\rangle$可以定义其任意整数的方幂运算，包括负指数方幂。因此，对于$G$中的任何一个元素$a$，均可以通过其正方幂、零方幂和负方幂构成一个向胜负两端无限延伸的序列，具体如下：  
$$
\cdots,a^{-n},\cdots,a^{-2},a^{-1},a^{0}\ \ ,a^{1},a^{2},\cdots,a^{n},\cdots
$$  
这些序列显然满足幂的运算法则，即对于任意整数$n$和$m$，有：  
$$
a^{n}*a^{m}=a^{n+m};\;\;(a^{n})^{m}=a^{n m}
$$  
如果$\langle G,*\rangle$是一个有限群$\langle G,*\rangle$，则根据运算的封闭性和鸽笼原理易知，在$G$中任意一个元素的无穷多个方幂中，必然至少有两个是相等的。具体地说，对于任意给定的$G$中某个元素$a$，必然存在两个不相等的整数$m$和$|n$，不妨设$m<n$，满足：  
$$
a^n=a^m\text{或}a^{n-m}=e
$$  
此时，可将正整数$n-m$看成是元素$a$方幂变化的一个周期。一般地，有如下定义：  
【定义12.11】设$\langle G,*\rangle$是任意给定的一个群，$e$是该群的单位元，对于$G$中任意给定的某个元素$a$，如果存在正整数$n$，满足$a^{n}=e$，则其中最小的正整数称为元素$a$的周期或阶，记为$|a|$，否则称元素$a$的周期为无限大或元素$a$的阶为无限大。  
例如，对于群$\langle\underline{{6}},+_{6}\rangle$，元素1 的阶为6，元素2 的阶为3，元素3 的阶为2，元素4 的阶为3，元素5 的阶为6，元素0 的阶为1。对于整数集合上的加法群$\langle Z,+\rangle$，显然，除了元素0 的周期为1 之外，其余任一非零元素的周期均为无穷大。事实上，不难看出，对于任何一个群，有且只有其单位元的阶为1。  
下面给出关于元素阶的两个重要性质：  
【定理12.6】有限群$\langle G,*\rangle$的每个元素都有有限阶，且其阶数不超过群的阶数|G|。  
【定理12.7】设$\langle G,*\rangle$为群，$G$中元素$a$的阶为$ k$，那么$a^{n}=e$当且仅当$k$整除$ n$  。",定理12.7描述方幂与元素阶的关系
循环群,同构,置换群,,"本节主要介绍两种重要的特殊群结构，即循环群和置换群。循环群是以某个元素的全部方幂载体集合的群，是目前研究最彻底的一种群。基于普通加法的整数加群$\langle Z,+\rangle$和基于模加运算的剩余类加群$\langle\underline{{n}},+_{n}\rangle$都是循环群。事实上，从同构角度看，循环群也只有$\langle Z,+\rangle$。和$\langle\underline{{n}},+_{n}\rangle$这两种不同的群。置换群则是有限集上置换函数集合与函数复合运算构成的群，是以置换函数及其运算为研究对象的群。置换群的重要性主要在于任何一个有限群都与一个置换群同构，换句话说，从同构的角度看，所有的有限群都是置换群。此外，循环群和置换群的实用性都非常强，是很多理论问题证明和求解的重要工具，在信息压缩与编码、形式语言自动机、几何变换与图形算法设计等多个领域具有重要的实用价值。  
一、循环群  
前面我们已经学过循环半群和循环含幺半群，现将其直接推广到群结构，由此得到循环群的概念，具体如下：  
【定义12.13】设$\langle G,*\rangle$是任意给定的群，若存在$a\in G$ 使得  
$$
G=\{a^{k}\big|k\in Z\}=\langle a\rangle
$$  
则称 $\langle G,*\rangle$ 为循环群，记作 $\langle\langle a\rangle_{*}\rangle$ ，并称 $a$ 是 $G$ 的生成元。此时，若 $|a|=n$ ，则称 $\langle\langle a\rangle{,*}\rangle$ 为 ${n}$ 阶 循环群，若$|a|$为无穷大，则称$\langle\langle a\rangle{,*}\rangle$为无限阶循环群。  
【定理12.15】假设$\langle G,*\rangle$是任意给定的一个循环群，则该群一定是交换群。  
【定理12.17】设$\langle G,*\rangle$是以$a$为生成元的循环群，即$G=\langle a\rangle$，则  
（1）若$G$是无限群，则$G$与整数加法群$\langle Z,+\rangle$同构；  
（2）若$G$是无限群是有限群且$|G|=n$，则$G$与$n$阶剩余类加群$\langle n,+_{n}\rangle$同构。  
二、 置换群  
在前面我们已经学习置换函数及其乘法的有关知识，现在从群的角度来考察置换函数及其乘法的运算性质。我们知道，置换函数其实就是有限集合上的的双射函数。为了能够更为一般的概念和性质，现从更为一般的角度考察双射函数，即一般集合上的双射函数及其乘法运算，由此得到如下变换及变换乘法的概念：  
【定义12.14】设$𝐴$是任意给定的一个非空集合，$A$集合上的映射$ f$：$A\rightarrow A$称为$𝐴$的一个变换。若该映射$f$是双射，则称$f$为$𝐴$上的一个一一变换。  
例如$f$：$Z\rightarrow Z$，$f(x)=x$和$g$：$Z\rightarrow Z$，$f(x)=-x$都是𝑍上的一一变换。  
【定义12.15】设$f,g$是𝐴上的变换，$f$和$g$的复合称为$f$与$g$的乘积，记作$f\circ g$  。  
不难证明，$f\circ g$也是$𝐴$上的一个变换。如果$f$和$g$都是$𝐴$上的一一变换，则乘积$f\circ g$也是$𝐴$上的一个一一变换。  
下面的定理12.18 表明：以给定集合上全体一一变换集合为载体、以变换乘法∘为运算构成的二元代数结构是一个群，由此可以从群的角度考察一一变换及其乘法运算性质。  
【定理12.18】假设$𝐴$是任意给定的一个非空集合，$E(A)$是$𝐴$上的全体一一变换构成的集合，则$E(A)$与其上一一变换的乘法运算∘构成的二元代数结构$\langle E(A),\circ\rangle$是一个群。  
【定义12.16】假设$𝐴$是任意给定的一个非空集合，$E(A)$是𝐴上的全体一一变换构成的集合，则$E(A)$与其上一一变换的乘法运算∘构成的群$\langle E(A),\circ\rangle$称为变换群，当$𝐴$是有限集合时，称变换群$\langle E(A),\circ\rangle$为对称群，对称群的任何一个子群称为置换群。  
从上述定义可以看出，变换群的载体集合$ E(A)$可以是有限集合也可以是无限集合，或者说变换群可以是有限群也可以是无限群。对称群则是一种特殊的变换群，要求变换群的载体集合必须是有限集合，因此，对称群一定是有限群。置换群则是变换群的子群，当然对称群作为其自身的平凡子群是一种特殊的置换群，但置换群不一定是对称群。因此，置换群比对称群具有更加广泛的含义，一般主要考察置换群。  
我们知道，对于任意给定的一个有限集合$𝐴$，该集合上的一一变换称为$𝐴$上的置换。当$|A|=n$时称$𝐴$上的置换为${n}$元置换。为了叙述上的方便，常将$A$记作$\{1,2,\cdots,n\}$，这样就可以将$𝐴$上的$n$元置换$p$记作：  
$$
\pi={\binom{a_{1},\ldots a_{n}}{b_{1},\ldots b_{n}}}\,,b_{i}=\sigma(a_{i}),\qquad\qquad\qquad i=1,2,\cdots,n
$$  
易见$.\pi(1)\,\,\,\pi(2)\,\,\,\,\,\cdots\pi(n)$恰恰为${1,\,,2,\cdots,n}$的一个排列。在$𝐴$上的所有置换和$𝐴$的所有排列之间存在着一一对应，$n$元集有$n!$个排列，故有${n}$!个$n$ 元置换。所有这些置换的集合记作$S_{n}$，则$\langle S_{n},\circ\rangle$就是一个对称群。  
具体地说，设$A=\{1,\!2\}$，那么$𝐴$上有两个置换：  
$$
p_1=\binom{1\quad2}{1\quad2},\quad p_2=\binom{1\quad2}{2\quad1}
$$  
当$A=\{1,\!2,\!3\}$时，$A$上有6 个置换：  
$$
\pi_1=\begin{pmatrix}1&2&3\\1&2&3\end{pmatrix},\pi_2=\begin{pmatrix}1&2&3\\2&1&3\end{pmatrix},\pi_3=\begin{pmatrix}1&2&3\\3&2&1\end{pmatrix}
$$  
$$
\pi_1=\begin{pmatrix}1&2&3\\1&3&2\end{pmatrix},\pi_2=\begin{pmatrix}1&2&3\\2&3&1\end{pmatrix},\pi_3=\begin{pmatrix}1&2&3\\3&1&2\end{pmatrix}
$$  
一般地，$A=\{a_{1},a_{2},\dots a_{n}\}$时，$A$上有$n!$个置换。如有$\pi(a_{i})=a_{j_{i}}$时，则$\pi$可表示为：  
$$
\pi={\binom{a_{1},\,\dots\,a_{n}}{a_{j_{1}},\,\dots\,a_{j_{n}}}}
$$  
置换乘法运算或者复合运算通常用∘表示，置换乘法可以像计算两个关系的合成那样进行。需要特别注意的是，置换乘法或复合运算与通常函数的复合运算次序相反。例如：  
$$
\pi_6\circ\pi_4=\begin{pmatrix}1&2&3\\3&1&2\end{pmatrix}\cdot\begin{pmatrix}1&2&3\\1&3&2\end{pmatrix}=\begin{pmatrix}1&2&3\\2&1&3\end{pmatrix}
$$  
即有：$(\pi_{6}\circ\pi_{4})(x)=\pi_{4}(\pi_{6}(x))$  。  
下面考察置换群的几何意义，首先考察三元对称群：  
设$A=\{1,\!2,\!3\}$，则$A$上的6 个置换$S_{3}=\{\pi_{1},\pi_{2},\pi_{3},\pi_{4},\pi_{5},\pi_{6}\}$关于其乘法运算∘构成一个群$\langle S_{3},\circ\rangle$，并称之为三次对称群。其中$\pi_{1}$是恒等置换为群中的单位元，且有：  
$$
{p_{2}}^{-1}=p_{2};~~{p_{3}}^{-1}=p_{3};~~{p_{4}}^{-1}=p_{5};~~{p_{5}}^{-1}=p_{4};~~{p_{6}}^{-1}=p_{6}
$$  
其实，还可以从另一个角度也可得到这个群：用数字1,2,3 标记正三角形的三个顶点，如图12-3 所示。现将三角形以其中心O 为中心轴分别旋转$\sigma_{0},\sigma_{1},\sigma_{2}$（旋转$\cdot0^{\circ},120^{\circ},240^{\circ})$），或分别按直线$l_{1}l_{2}l_{3}$位对称轴进行翻转$(\sigma_{3},\sigma_{4},\sigma_{5})$，则每次旋转或翻转显然都都对应于三角形顶点数字的的一个置换，具体对应关系如下：  
$\sigma_{0}$（旋转$0^{\circ}$）        $p_1=\begin{pmatrix}1&2&3\\1&2&3\end{pmatrix};\quad\sigma_1\bigl(\text{旋转}120^\circ\bigr)\quad p_2=\bigl(\begin{matrix}1&2&3\\2&1&3\end{matrix}\bigr)$  
$\sigma_2\bigl(\text{旋转 240°}\bigr)\quad p_3=\bigl(\begin{matrix}1&2&3\\3&2&1\end{matrix}\bigr);\quad\sigma_3\bigl(\text{绕}l_3\text{翻转}\bigr)$$\quad\quad\quad p_4=\begin{pmatrix}1&2&3\\1&3&2\end{pmatrix}$  
$\sigma_4\big(\text{绕}l_2\text{翻转}\big)\quad p_5=\big(\begin{matrix}1&2&3\\2&3&1\end{matrix}\big);\quad\sigma_5\big(\text{绕}l_1\text{翻转}\big)\quad p_6=(\begin{matrix}1&2&3\\3&1&2\end{matrix})$  
不难看出：$\langle\{\sigma_{0},\sigma_{1},\sigma_{2},\sigma_{3},\sigma_{4},\sigma_{5}\},\circledast\rangle$构成一个群，其中$\circledast$表示旋转或翻转的操作的复合操作，并且与群$\langle\{\pi_{1},\pi_{2},\pi_{3},\pi_{4},\pi_{5},\pi_{6}\},\circ\rangle$同构。  
![](images/e6cbfb18c66c7d99640531f391a63f4a34c10b210258fb0a56bb479a832c31f2.jpg)  
图12-3 三角形的对称轴和对称中心  
![](images/c11de4754b3535d3b87f562740b93b202d5ef5e49fd3a0cb5d9d33538b6831cb.jpg)  
图12-4正方形的对称轴和对称中心  
下面进一步考察四元对称群的几何意义：令$A=\{1,\!2,\!3,\!4\}$，$S_{4}=\{p|p$为A 上的置换}，因此，$\langle S_{4},\circ\rangle$为四元对称群。现用数字1,2,3,4 分别标记正方形的4 个顶点，如图12-4 所示，$\sigma_{0},\sigma_{1},\sigma_{2},\sigma_{3},\sigma_{4},\sigma_{5},\sigma_{6},\sigma_{7}$分别表示正方形以其中心为中心轴进行旋转或按对称轴进行翻转，则它们分别对应与A 上的一个置换，具体如下：  
$ \sigma_0\big(\text{旋转 }0^\circ\big)\quad p_1=\begin{pmatrix}1&2&3&4\\1&2&3&4\end{pmatrix};\quad\sigma_1\big(\text{旋转 }90^\circ\big)\quad p_2=\begin{pmatrix}1&2&3&4\\2&3&4&1\end{pmatrix}$  
$\sigma_2\big(\text{旋转 180°}\big)\quad p_3=\begin{pmatrix}1&2&3&4\\3&4&1&2\end{pmatrix};\quad\sigma_3\big(\text{旋转 270°}\big)\quad p_4=(\begin{matrix}1&2&3&4\\4&1&2&3\end{matrix})$  
$\sigma_4(\text{绕}l_1\text{翻转})\quad p_5=\begin{pmatrix}1&2&3&4\\4&3&2&1\end{pmatrix};\quad\sigma_5(\text{绕}l_2\text{翻转})\quad p_6=(\begin{matrix}1&2&3&4\\1&4&3&2\end{matrix})$  
$\sigma_6(\text{绕}l_3\text{翻转})\quad p_7=\begin{pmatrix}1&2&3&4\\1&4&3&2\end{pmatrix};\quad\sigma_7(\text{绕}l_4\text{翻转})\quad p_8=(\begin{matrix}1&2&3&4\\1&4&3&2\end{matrix})$  
不难看出：$\langle\{\sigma_{0},\sigma_{1},\sigma_{2},\sigma_{3},\sigma_{4},\sigma_{5},\sigma_{6},\sigma_{7}\},\circledast\rangle$构成一个群，其中$\circledast$表示旋转或翻转的操作的复合操作，具体定义如表12-1 所示。  
表12-1 $\circledast$的运算表
![](images/0d658bbe39ea00a7b3a2683e4707c30ed3115f5772998f1ac1c9608422308ecc.jpg)  
由于$\langle\{\sigma_{0},\sigma_{1},\cdots,\sigma_{7}\},\circledast\rangle$与$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$同构，故$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$也是群，它是$\langle S_{4},\circ\rangle$的一个真子群，因为四元对称群$\langle S_{4},\circ\rangle$有24 个置换，而$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$仅有8 个置换。也就是说，群$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$是一个8 阶4 元置换群，但不是4 元对称群。  
【定理12.19】假设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$与某个变换群同构，如果$\langle G,*\rangle$是一个有限群，则$\langle G,*\rangle$与某个置换群同构。  
上述定理12.19 表明，变换群和对称群的重要性在于其作为两种具体的特殊群与一般的抽象群有着非常密切的联系。具体地说，每个群均同构于一个变换群，特别地，每个有限群均同构于一个置换群。因此，从同构的角度看，所有的群都可以看成是变换群，所有的有限群都可以看成是置换群。",循环群和置换群都是重要的群结构，循环群是研究最彻底的一种群，而置换群是有限集上置换函数集合与函数复合运算构成的群。任何一个有限群都与一个置换群同构，从同构角度看，所有的有限群都是置换群。
变换群,包含,对称群,,"本节主要介绍两种重要的特殊群结构，即循环群和置换群。循环群是以某个元素的全部方幂载体集合的群，是目前研究最彻底的一种群。基于普通加法的整数加群$\langle Z,+\rangle$和基于模加运算的剩余类加群$\langle\underline{{n}},+_{n}\rangle$都是循环群。事实上，从同构角度看，循环群也只有$\langle Z,+\rangle$。和$\langle\underline{{n}},+_{n}\rangle$这两种不同的群。置换群则是有限集上置换函数集合与函数复合运算构成的群，是以置换函数及其运算为研究对象的群。置换群的重要性主要在于任何一个有限群都与一个置换群同构，换句话说，从同构的角度看，所有的有限群都是置换群。此外，循环群和置换群的实用性都非常强，是很多理论问题证明和求解的重要工具，在信息压缩与编码、形式语言自动机、几何变换与图形算法设计等多个领域具有重要的实用价值。  
一、循环群  
前面我们已经学过循环半群和循环含幺半群，现将其直接推广到群结构，由此得到循环群的概念，具体如下：  
【定义12.13】设$\langle G,*\rangle$是任意给定的群，若存在$a\in G$ 使得  
$$
G=\{a^{k}\big|k\in Z\}=\langle a\rangle
$$  
则称 $\langle G,*\rangle$ 为循环群，记作 $\langle\langle a\rangle_{*}\rangle$ ，并称 $a$ 是 $G$ 的生成元。此时，若 $|a|=n$ ，则称 $\langle\langle a\rangle{,*}\rangle$ 为 ${n}$ 阶 循环群，若$|a|$为无穷大，则称$\langle\langle a\rangle{,*}\rangle$为无限阶循环群。  
【定理12.15】假设$\langle G,*\rangle$是任意给定的一个循环群，则该群一定是交换群。  
【定理12.17】设$\langle G,*\rangle$是以$a$为生成元的循环群，即$G=\langle a\rangle$，则  
（1）若$G$是无限群，则$G$与整数加法群$\langle Z,+\rangle$同构；  
（2）若$G$是无限群是有限群且$|G|=n$，则$G$与$n$阶剩余类加群$\langle n,+_{n}\rangle$同构。  
二、 置换群  
在前面我们已经学习置换函数及其乘法的有关知识，现在从群的角度来考察置换函数及其乘法的运算性质。我们知道，置换函数其实就是有限集合上的的双射函数。为了能够更为一般的概念和性质，现从更为一般的角度考察双射函数，即一般集合上的双射函数及其乘法运算，由此得到如下变换及变换乘法的概念：  
【定义12.14】设$𝐴$是任意给定的一个非空集合，$A$集合上的映射$ f$：$A\rightarrow A$称为$𝐴$的一个变换。若该映射$f$是双射，则称$f$为$𝐴$上的一个一一变换。  
例如$f$：$Z\rightarrow Z$，$f(x)=x$和$g$：$Z\rightarrow Z$，$f(x)=-x$都是𝑍上的一一变换。  
【定义12.15】设$f,g$是𝐴上的变换，$f$和$g$的复合称为$f$与$g$的乘积，记作$f\circ g$  。  
不难证明，$f\circ g$也是$𝐴$上的一个变换。如果$f$和$g$都是$𝐴$上的一一变换，则乘积$f\circ g$也是$𝐴$上的一个一一变换。  
下面的定理12.18 表明：以给定集合上全体一一变换集合为载体、以变换乘法∘为运算构成的二元代数结构是一个群，由此可以从群的角度考察一一变换及其乘法运算性质。  
【定理12.18】假设$𝐴$是任意给定的一个非空集合，$E(A)$是$𝐴$上的全体一一变换构成的集合，则$E(A)$与其上一一变换的乘法运算∘构成的二元代数结构$\langle E(A),\circ\rangle$是一个群。  
【定义12.16】假设$𝐴$是任意给定的一个非空集合，$E(A)$是𝐴上的全体一一变换构成的集合，则$E(A)$与其上一一变换的乘法运算∘构成的群$\langle E(A),\circ\rangle$称为变换群，当$𝐴$是有限集合时，称变换群$\langle E(A),\circ\rangle$为对称群，对称群的任何一个子群称为置换群。  
从上述定义可以看出，变换群的载体集合$ E(A)$可以是有限集合也可以是无限集合，或者说变换群可以是有限群也可以是无限群。对称群则是一种特殊的变换群，要求变换群的载体集合必须是有限集合，因此，对称群一定是有限群。置换群则是变换群的子群，当然对称群作为其自身的平凡子群是一种特殊的置换群，但置换群不一定是对称群。因此，置换群比对称群具有更加广泛的含义，一般主要考察置换群。  
我们知道，对于任意给定的一个有限集合$𝐴$，该集合上的一一变换称为$𝐴$上的置换。当$|A|=n$时称$𝐴$上的置换为${n}$元置换。为了叙述上的方便，常将$A$记作$\{1,2,\cdots,n\}$，这样就可以将$𝐴$上的$n$元置换$p$记作：  
$$
\pi={\binom{a_{1},\ldots a_{n}}{b_{1},\ldots b_{n}}}\,,b_{i}=\sigma(a_{i}),\qquad\qquad\qquad i=1,2,\cdots,n
$$  
易见$.\pi(1)\,\,\,\pi(2)\,\,\,\,\,\cdots\pi(n)$恰恰为${1,\,,2,\cdots,n}$的一个排列。在$𝐴$上的所有置换和$𝐴$的所有排列之间存在着一一对应，$n$元集有$n!$个排列，故有${n}$!个$n$ 元置换。所有这些置换的集合记作$S_{n}$，则$\langle S_{n},\circ\rangle$就是一个对称群。  
具体地说，设$A=\{1,\!2\}$，那么$𝐴$上有两个置换：  
$$
p_1=\binom{1\quad2}{1\quad2},\quad p_2=\binom{1\quad2}{2\quad1}
$$  
当$A=\{1,\!2,\!3\}$时，$A$上有6 个置换：  
$$
\pi_1=\begin{pmatrix}1&2&3\\1&2&3\end{pmatrix},\pi_2=\begin{pmatrix}1&2&3\\2&1&3\end{pmatrix},\pi_3=\begin{pmatrix}1&2&3\\3&2&1\end{pmatrix}
$$  
$$
\pi_1=\begin{pmatrix}1&2&3\\1&3&2\end{pmatrix},\pi_2=\begin{pmatrix}1&2&3\\2&3&1\end{pmatrix},\pi_3=\begin{pmatrix}1&2&3\\3&1&2\end{pmatrix}
$$  
一般地，$A=\{a_{1},a_{2},\dots a_{n}\}$时，$A$上有$n!$个置换。如有$\pi(a_{i})=a_{j_{i}}$时，则$\pi$可表示为：  
$$
\pi={\binom{a_{1},\,\dots\,a_{n}}{a_{j_{1}},\,\dots\,a_{j_{n}}}}
$$  
置换乘法运算或者复合运算通常用∘表示，置换乘法可以像计算两个关系的合成那样进行。需要特别注意的是，置换乘法或复合运算与通常函数的复合运算次序相反。例如：  
$$
\pi_6\circ\pi_4=\begin{pmatrix}1&2&3\\3&1&2\end{pmatrix}\cdot\begin{pmatrix}1&2&3\\1&3&2\end{pmatrix}=\begin{pmatrix}1&2&3\\2&1&3\end{pmatrix}
$$  
即有：$(\pi_{6}\circ\pi_{4})(x)=\pi_{4}(\pi_{6}(x))$  。  
下面考察置换群的几何意义，首先考察三元对称群：  
设$A=\{1,\!2,\!3\}$，则$A$上的6 个置换$S_{3}=\{\pi_{1},\pi_{2},\pi_{3},\pi_{4},\pi_{5},\pi_{6}\}$关于其乘法运算∘构成一个群$\langle S_{3},\circ\rangle$，并称之为三次对称群。其中$\pi_{1}$是恒等置换为群中的单位元，且有：  
$$
{p_{2}}^{-1}=p_{2};~~{p_{3}}^{-1}=p_{3};~~{p_{4}}^{-1}=p_{5};~~{p_{5}}^{-1}=p_{4};~~{p_{6}}^{-1}=p_{6}
$$  
其实，还可以从另一个角度也可得到这个群：用数字1,2,3 标记正三角形的三个顶点，如图12-3 所示。现将三角形以其中心O 为中心轴分别旋转$\sigma_{0},\sigma_{1},\sigma_{2}$（旋转$\cdot0^{\circ},120^{\circ},240^{\circ})$），或分别按直线$l_{1}l_{2}l_{3}$位对称轴进行翻转$(\sigma_{3},\sigma_{4},\sigma_{5})$，则每次旋转或翻转显然都都对应于三角形顶点数字的的一个置换，具体对应关系如下：  
$\sigma_{0}$（旋转$0^{\circ}$）        $p_1=\begin{pmatrix}1&2&3\\1&2&3\end{pmatrix};\quad\sigma_1\bigl(\text{旋转}120^\circ\bigr)\quad p_2=\bigl(\begin{matrix}1&2&3\\2&1&3\end{matrix}\bigr)$  
$\sigma_2\bigl(\text{旋转 240°}\bigr)\quad p_3=\bigl(\begin{matrix}1&2&3\\3&2&1\end{matrix}\bigr);\quad\sigma_3\bigl(\text{绕}l_3\text{翻转}\bigr)$$\quad\quad\quad p_4=\begin{pmatrix}1&2&3\\1&3&2\end{pmatrix}$  
$\sigma_4\big(\text{绕}l_2\text{翻转}\big)\quad p_5=\big(\begin{matrix}1&2&3\\2&3&1\end{matrix}\big);\quad\sigma_5\big(\text{绕}l_1\text{翻转}\big)\quad p_6=(\begin{matrix}1&2&3\\3&1&2\end{matrix})$  
不难看出：$\langle\{\sigma_{0},\sigma_{1},\sigma_{2},\sigma_{3},\sigma_{4},\sigma_{5}\},\circledast\rangle$构成一个群，其中$\circledast$表示旋转或翻转的操作的复合操作，并且与群$\langle\{\pi_{1},\pi_{2},\pi_{3},\pi_{4},\pi_{5},\pi_{6}\},\circ\rangle$同构。  
![](images/e6cbfb18c66c7d99640531f391a63f4a34c10b210258fb0a56bb479a832c31f2.jpg)  
图12-3 三角形的对称轴和对称中心  
![](images/c11de4754b3535d3b87f562740b93b202d5ef5e49fd3a0cb5d9d33538b6831cb.jpg)  
图12-4正方形的对称轴和对称中心  
下面进一步考察四元对称群的几何意义：令$A=\{1,\!2,\!3,\!4\}$，$S_{4}=\{p|p$为A 上的置换}，因此，$\langle S_{4},\circ\rangle$为四元对称群。现用数字1,2,3,4 分别标记正方形的4 个顶点，如图12-4 所示，$\sigma_{0},\sigma_{1},\sigma_{2},\sigma_{3},\sigma_{4},\sigma_{5},\sigma_{6},\sigma_{7}$分别表示正方形以其中心为中心轴进行旋转或按对称轴进行翻转，则它们分别对应与A 上的一个置换，具体如下：  
$ \sigma_0\big(\text{旋转 }0^\circ\big)\quad p_1=\begin{pmatrix}1&2&3&4\\1&2&3&4\end{pmatrix};\quad\sigma_1\big(\text{旋转 }90^\circ\big)\quad p_2=\begin{pmatrix}1&2&3&4\\2&3&4&1\end{pmatrix}$  
$\sigma_2\big(\text{旋转 180°}\big)\quad p_3=\begin{pmatrix}1&2&3&4\\3&4&1&2\end{pmatrix};\quad\sigma_3\big(\text{旋转 270°}\big)\quad p_4=(\begin{matrix}1&2&3&4\\4&1&2&3\end{matrix})$  
$\sigma_4(\text{绕}l_1\text{翻转})\quad p_5=\begin{pmatrix}1&2&3&4\\4&3&2&1\end{pmatrix};\quad\sigma_5(\text{绕}l_2\text{翻转})\quad p_6=(\begin{matrix}1&2&3&4\\1&4&3&2\end{matrix})$  
$\sigma_6(\text{绕}l_3\text{翻转})\quad p_7=\begin{pmatrix}1&2&3&4\\1&4&3&2\end{pmatrix};\quad\sigma_7(\text{绕}l_4\text{翻转})\quad p_8=(\begin{matrix}1&2&3&4\\1&4&3&2\end{matrix})$  
不难看出：$\langle\{\sigma_{0},\sigma_{1},\sigma_{2},\sigma_{3},\sigma_{4},\sigma_{5},\sigma_{6},\sigma_{7}\},\circledast\rangle$构成一个群，其中$\circledast$表示旋转或翻转的操作的复合操作，具体定义如表12-1 所示。  
表12-1 $\circledast$的运算表
![](images/0d658bbe39ea00a7b3a2683e4707c30ed3115f5772998f1ac1c9608422308ecc.jpg)  
由于$\langle\{\sigma_{0},\sigma_{1},\cdots,\sigma_{7}\},\circledast\rangle$与$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$同构，故$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$也是群，它是$\langle S_{4},\circ\rangle$的一个真子群，因为四元对称群$\langle S_{4},\circ\rangle$有24 个置换，而$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$仅有8 个置换。也就是说，群$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$是一个8 阶4 元置换群，但不是4 元对称群。  
【定理12.19】假设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$与某个变换群同构，如果$\langle G,*\rangle$是一个有限群，则$\langle G,*\rangle$与某个置换群同构。  
上述定理12.19 表明，变换群和对称群的重要性在于其作为两种具体的特殊群与一般的抽象群有着非常密切的联系。具体地说，每个群均同构于一个变换群，特别地，每个有限群均同构于一个置换群。因此，从同构的角度看，所有的群都可以看成是变换群，所有的有限群都可以看成是置换群。",变换群是任意非空集合上全体一一变换构成的群，当集合是有限集合时，变换群称为对称群。对称群是变换群的特例，要求载体集合必须是有限集合。
对称群,包含,置换群,,"本节主要介绍两种重要的特殊群结构，即循环群和置换群。循环群是以某个元素的全部方幂载体集合的群，是目前研究最彻底的一种群。基于普通加法的整数加群$\langle Z,+\rangle$和基于模加运算的剩余类加群$\langle\underline{{n}},+_{n}\rangle$都是循环群。事实上，从同构角度看，循环群也只有$\langle Z,+\rangle$。和$\langle\underline{{n}},+_{n}\rangle$这两种不同的群。置换群则是有限集上置换函数集合与函数复合运算构成的群，是以置换函数及其运算为研究对象的群。置换群的重要性主要在于任何一个有限群都与一个置换群同构，换句话说，从同构的角度看，所有的有限群都是置换群。此外，循环群和置换群的实用性都非常强，是很多理论问题证明和求解的重要工具，在信息压缩与编码、形式语言自动机、几何变换与图形算法设计等多个领域具有重要的实用价值。  
一、循环群  
前面我们已经学过循环半群和循环含幺半群，现将其直接推广到群结构，由此得到循环群的概念，具体如下：  
【定义12.13】设$\langle G,*\rangle$是任意给定的群，若存在$a\in G$ 使得  
$$
G=\{a^{k}\big|k\in Z\}=\langle a\rangle
$$  
则称 $\langle G,*\rangle$ 为循环群，记作 $\langle\langle a\rangle_{*}\rangle$ ，并称 $a$ 是 $G$ 的生成元。此时，若 $|a|=n$ ，则称 $\langle\langle a\rangle{,*}\rangle$ 为 ${n}$ 阶 循环群，若$|a|$为无穷大，则称$\langle\langle a\rangle{,*}\rangle$为无限阶循环群。  
【定理12.15】假设$\langle G,*\rangle$是任意给定的一个循环群，则该群一定是交换群。  
【定理12.17】设$\langle G,*\rangle$是以$a$为生成元的循环群，即$G=\langle a\rangle$，则  
（1）若$G$是无限群，则$G$与整数加法群$\langle Z,+\rangle$同构；  
（2）若$G$是无限群是有限群且$|G|=n$，则$G$与$n$阶剩余类加群$\langle n,+_{n}\rangle$同构。  
二、 置换群  
在前面我们已经学习置换函数及其乘法的有关知识，现在从群的角度来考察置换函数及其乘法的运算性质。我们知道，置换函数其实就是有限集合上的的双射函数。为了能够更为一般的概念和性质，现从更为一般的角度考察双射函数，即一般集合上的双射函数及其乘法运算，由此得到如下变换及变换乘法的概念：  
【定义12.14】设$𝐴$是任意给定的一个非空集合，$A$集合上的映射$ f$：$A\rightarrow A$称为$𝐴$的一个变换。若该映射$f$是双射，则称$f$为$𝐴$上的一个一一变换。  
例如$f$：$Z\rightarrow Z$，$f(x)=x$和$g$：$Z\rightarrow Z$，$f(x)=-x$都是𝑍上的一一变换。  
【定义12.15】设$f,g$是𝐴上的变换，$f$和$g$的复合称为$f$与$g$的乘积，记作$f\circ g$  。  
不难证明，$f\circ g$也是$𝐴$上的一个变换。如果$f$和$g$都是$𝐴$上的一一变换，则乘积$f\circ g$也是$𝐴$上的一个一一变换。  
下面的定理12.18 表明：以给定集合上全体一一变换集合为载体、以变换乘法∘为运算构成的二元代数结构是一个群，由此可以从群的角度考察一一变换及其乘法运算性质。  
【定理12.18】假设$𝐴$是任意给定的一个非空集合，$E(A)$是$𝐴$上的全体一一变换构成的集合，则$E(A)$与其上一一变换的乘法运算∘构成的二元代数结构$\langle E(A),\circ\rangle$是一个群。  
【定义12.16】假设$𝐴$是任意给定的一个非空集合，$E(A)$是𝐴上的全体一一变换构成的集合，则$E(A)$与其上一一变换的乘法运算∘构成的群$\langle E(A),\circ\rangle$称为变换群，当$𝐴$是有限集合时，称变换群$\langle E(A),\circ\rangle$为对称群，对称群的任何一个子群称为置换群。  
从上述定义可以看出，变换群的载体集合$ E(A)$可以是有限集合也可以是无限集合，或者说变换群可以是有限群也可以是无限群。对称群则是一种特殊的变换群，要求变换群的载体集合必须是有限集合，因此，对称群一定是有限群。置换群则是变换群的子群，当然对称群作为其自身的平凡子群是一种特殊的置换群，但置换群不一定是对称群。因此，置换群比对称群具有更加广泛的含义，一般主要考察置换群。  
我们知道，对于任意给定的一个有限集合$𝐴$，该集合上的一一变换称为$𝐴$上的置换。当$|A|=n$时称$𝐴$上的置换为${n}$元置换。为了叙述上的方便，常将$A$记作$\{1,2,\cdots,n\}$，这样就可以将$𝐴$上的$n$元置换$p$记作：  
$$
\pi={\binom{a_{1},\ldots a_{n}}{b_{1},\ldots b_{n}}}\,,b_{i}=\sigma(a_{i}),\qquad\qquad\qquad i=1,2,\cdots,n
$$  
易见$.\pi(1)\,\,\,\pi(2)\,\,\,\,\,\cdots\pi(n)$恰恰为${1,\,,2,\cdots,n}$的一个排列。在$𝐴$上的所有置换和$𝐴$的所有排列之间存在着一一对应，$n$元集有$n!$个排列，故有${n}$!个$n$ 元置换。所有这些置换的集合记作$S_{n}$，则$\langle S_{n},\circ\rangle$就是一个对称群。  
具体地说，设$A=\{1,\!2\}$，那么$𝐴$上有两个置换：  
$$
p_1=\binom{1\quad2}{1\quad2},\quad p_2=\binom{1\quad2}{2\quad1}
$$  
当$A=\{1,\!2,\!3\}$时，$A$上有6 个置换：  
$$
\pi_1=\begin{pmatrix}1&2&3\\1&2&3\end{pmatrix},\pi_2=\begin{pmatrix}1&2&3\\2&1&3\end{pmatrix},\pi_3=\begin{pmatrix}1&2&3\\3&2&1\end{pmatrix}
$$  
$$
\pi_1=\begin{pmatrix}1&2&3\\1&3&2\end{pmatrix},\pi_2=\begin{pmatrix}1&2&3\\2&3&1\end{pmatrix},\pi_3=\begin{pmatrix}1&2&3\\3&1&2\end{pmatrix}
$$  
一般地，$A=\{a_{1},a_{2},\dots a_{n}\}$时，$A$上有$n!$个置换。如有$\pi(a_{i})=a_{j_{i}}$时，则$\pi$可表示为：  
$$
\pi={\binom{a_{1},\,\dots\,a_{n}}{a_{j_{1}},\,\dots\,a_{j_{n}}}}
$$  
置换乘法运算或者复合运算通常用∘表示，置换乘法可以像计算两个关系的合成那样进行。需要特别注意的是，置换乘法或复合运算与通常函数的复合运算次序相反。例如：  
$$
\pi_6\circ\pi_4=\begin{pmatrix}1&2&3\\3&1&2\end{pmatrix}\cdot\begin{pmatrix}1&2&3\\1&3&2\end{pmatrix}=\begin{pmatrix}1&2&3\\2&1&3\end{pmatrix}
$$  
即有：$(\pi_{6}\circ\pi_{4})(x)=\pi_{4}(\pi_{6}(x))$  。  
下面考察置换群的几何意义，首先考察三元对称群：  
设$A=\{1,\!2,\!3\}$，则$A$上的6 个置换$S_{3}=\{\pi_{1},\pi_{2},\pi_{3},\pi_{4},\pi_{5},\pi_{6}\}$关于其乘法运算∘构成一个群$\langle S_{3},\circ\rangle$，并称之为三次对称群。其中$\pi_{1}$是恒等置换为群中的单位元，且有：  
$$
{p_{2}}^{-1}=p_{2};~~{p_{3}}^{-1}=p_{3};~~{p_{4}}^{-1}=p_{5};~~{p_{5}}^{-1}=p_{4};~~{p_{6}}^{-1}=p_{6}
$$  
其实，还可以从另一个角度也可得到这个群：用数字1,2,3 标记正三角形的三个顶点，如图12-3 所示。现将三角形以其中心O 为中心轴分别旋转$\sigma_{0},\sigma_{1},\sigma_{2}$（旋转$\cdot0^{\circ},120^{\circ},240^{\circ})$），或分别按直线$l_{1}l_{2}l_{3}$位对称轴进行翻转$(\sigma_{3},\sigma_{4},\sigma_{5})$，则每次旋转或翻转显然都都对应于三角形顶点数字的的一个置换，具体对应关系如下：  
$\sigma_{0}$（旋转$0^{\circ}$）        $p_1=\begin{pmatrix}1&2&3\\1&2&3\end{pmatrix};\quad\sigma_1\bigl(\text{旋转}120^\circ\bigr)\quad p_2=\bigl(\begin{matrix}1&2&3\\2&1&3\end{matrix}\bigr)$  
$\sigma_2\bigl(\text{旋转 240°}\bigr)\quad p_3=\bigl(\begin{matrix}1&2&3\\3&2&1\end{matrix}\bigr);\quad\sigma_3\bigl(\text{绕}l_3\text{翻转}\bigr)$$\quad\quad\quad p_4=\begin{pmatrix}1&2&3\\1&3&2\end{pmatrix}$  
$\sigma_4\big(\text{绕}l_2\text{翻转}\big)\quad p_5=\big(\begin{matrix}1&2&3\\2&3&1\end{matrix}\big);\quad\sigma_5\big(\text{绕}l_1\text{翻转}\big)\quad p_6=(\begin{matrix}1&2&3\\3&1&2\end{matrix})$  
不难看出：$\langle\{\sigma_{0},\sigma_{1},\sigma_{2},\sigma_{3},\sigma_{4},\sigma_{5}\},\circledast\rangle$构成一个群，其中$\circledast$表示旋转或翻转的操作的复合操作，并且与群$\langle\{\pi_{1},\pi_{2},\pi_{3},\pi_{4},\pi_{5},\pi_{6}\},\circ\rangle$同构。  
![](images/e6cbfb18c66c7d99640531f391a63f4a34c10b210258fb0a56bb479a832c31f2.jpg)  
图12-3 三角形的对称轴和对称中心  
![](images/c11de4754b3535d3b87f562740b93b202d5ef5e49fd3a0cb5d9d33538b6831cb.jpg)  
图12-4正方形的对称轴和对称中心  
下面进一步考察四元对称群的几何意义：令$A=\{1,\!2,\!3,\!4\}$，$S_{4}=\{p|p$为A 上的置换}，因此，$\langle S_{4},\circ\rangle$为四元对称群。现用数字1,2,3,4 分别标记正方形的4 个顶点，如图12-4 所示，$\sigma_{0},\sigma_{1},\sigma_{2},\sigma_{3},\sigma_{4},\sigma_{5},\sigma_{6},\sigma_{7}$分别表示正方形以其中心为中心轴进行旋转或按对称轴进行翻转，则它们分别对应与A 上的一个置换，具体如下：  
$ \sigma_0\big(\text{旋转 }0^\circ\big)\quad p_1=\begin{pmatrix}1&2&3&4\\1&2&3&4\end{pmatrix};\quad\sigma_1\big(\text{旋转 }90^\circ\big)\quad p_2=\begin{pmatrix}1&2&3&4\\2&3&4&1\end{pmatrix}$  
$\sigma_2\big(\text{旋转 180°}\big)\quad p_3=\begin{pmatrix}1&2&3&4\\3&4&1&2\end{pmatrix};\quad\sigma_3\big(\text{旋转 270°}\big)\quad p_4=(\begin{matrix}1&2&3&4\\4&1&2&3\end{matrix})$  
$\sigma_4(\text{绕}l_1\text{翻转})\quad p_5=\begin{pmatrix}1&2&3&4\\4&3&2&1\end{pmatrix};\quad\sigma_5(\text{绕}l_2\text{翻转})\quad p_6=(\begin{matrix}1&2&3&4\\1&4&3&2\end{matrix})$  
$\sigma_6(\text{绕}l_3\text{翻转})\quad p_7=\begin{pmatrix}1&2&3&4\\1&4&3&2\end{pmatrix};\quad\sigma_7(\text{绕}l_4\text{翻转})\quad p_8=(\begin{matrix}1&2&3&4\\1&4&3&2\end{matrix})$  
不难看出：$\langle\{\sigma_{0},\sigma_{1},\sigma_{2},\sigma_{3},\sigma_{4},\sigma_{5},\sigma_{6},\sigma_{7}\},\circledast\rangle$构成一个群，其中$\circledast$表示旋转或翻转的操作的复合操作，具体定义如表12-1 所示。  
表12-1 $\circledast$的运算表
![](images/0d658bbe39ea00a7b3a2683e4707c30ed3115f5772998f1ac1c9608422308ecc.jpg)  
由于$\langle\{\sigma_{0},\sigma_{1},\cdots,\sigma_{7}\},\circledast\rangle$与$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$同构，故$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$也是群，它是$\langle S_{4},\circ\rangle$的一个真子群，因为四元对称群$\langle S_{4},\circ\rangle$有24 个置换，而$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$仅有8 个置换。也就是说，群$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$是一个8 阶4 元置换群，但不是4 元对称群。  
【定理12.19】假设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$与某个变换群同构，如果$\langle G,*\rangle$是一个有限群，则$\langle G,*\rangle$与某个置换群同构。  
上述定理12.19 表明，变换群和对称群的重要性在于其作为两种具体的特殊群与一般的抽象群有着非常密切的联系。具体地说，每个群均同构于一个变换群，特别地，每个有限群均同构于一个置换群。因此，从同构的角度看，所有的群都可以看成是变换群，所有的有限群都可以看成是置换群。",对称群的任何一个子群称为置换群，置换群是变换群的子群，但置换群不一定是对称群，置换群比对称群具有更广泛的含义。
循环群,同构,变换群,,"本节主要介绍两种重要的特殊群结构，即循环群和置换群。循环群是以某个元素的全部方幂载体集合的群，是目前研究最彻底的一种群。基于普通加法的整数加群$\langle Z,+\rangle$和基于模加运算的剩余类加群$\langle\underline{{n}},+_{n}\rangle$都是循环群。事实上，从同构角度看，循环群也只有$\langle Z,+\rangle$。和$\langle\underline{{n}},+_{n}\rangle$这两种不同的群。置换群则是有限集上置换函数集合与函数复合运算构成的群，是以置换函数及其运算为研究对象的群。置换群的重要性主要在于任何一个有限群都与一个置换群同构，换句话说，从同构的角度看，所有的有限群都是置换群。此外，循环群和置换群的实用性都非常强，是很多理论问题证明和求解的重要工具，在信息压缩与编码、形式语言自动机、几何变换与图形算法设计等多个领域具有重要的实用价值。  
一、循环群  
前面我们已经学过循环半群和循环含幺半群，现将其直接推广到群结构，由此得到循环群的概念，具体如下：  
【定义12.13】设$\langle G,*\rangle$是任意给定的群，若存在$a\in G$ 使得  
$$
G=\{a^{k}\big|k\in Z\}=\langle a\rangle
$$  
则称 $\langle G,*\rangle$ 为循环群，记作 $\langle\langle a\rangle_{*}\rangle$ ，并称 $a$ 是 $G$ 的生成元。此时，若 $|a|=n$ ，则称 $\langle\langle a\rangle{,*}\rangle$ 为 ${n}$ 阶 循环群，若$|a|$为无穷大，则称$\langle\langle a\rangle{,*}\rangle$为无限阶循环群。  
【定理12.15】假设$\langle G,*\rangle$是任意给定的一个循环群，则该群一定是交换群。  
【定理12.17】设$\langle G,*\rangle$是以$a$为生成元的循环群，即$G=\langle a\rangle$，则  
（1）若$G$是无限群，则$G$与整数加法群$\langle Z,+\rangle$同构；  
（2）若$G$是无限群是有限群且$|G|=n$，则$G$与$n$阶剩余类加群$\langle n,+_{n}\rangle$同构。  
二、 置换群  
在前面我们已经学习置换函数及其乘法的有关知识，现在从群的角度来考察置换函数及其乘法的运算性质。我们知道，置换函数其实就是有限集合上的的双射函数。为了能够更为一般的概念和性质，现从更为一般的角度考察双射函数，即一般集合上的双射函数及其乘法运算，由此得到如下变换及变换乘法的概念：  
【定义12.14】设$𝐴$是任意给定的一个非空集合，$A$集合上的映射$ f$：$A\rightarrow A$称为$𝐴$的一个变换。若该映射$f$是双射，则称$f$为$𝐴$上的一个一一变换。  
例如$f$：$Z\rightarrow Z$，$f(x)=x$和$g$：$Z\rightarrow Z$，$f(x)=-x$都是𝑍上的一一变换。  
【定义12.15】设$f,g$是𝐴上的变换，$f$和$g$的复合称为$f$与$g$的乘积，记作$f\circ g$  。  
不难证明，$f\circ g$也是$𝐴$上的一个变换。如果$f$和$g$都是$𝐴$上的一一变换，则乘积$f\circ g$也是$𝐴$上的一个一一变换。  
下面的定理12.18 表明：以给定集合上全体一一变换集合为载体、以变换乘法∘为运算构成的二元代数结构是一个群，由此可以从群的角度考察一一变换及其乘法运算性质。  
【定理12.18】假设$𝐴$是任意给定的一个非空集合，$E(A)$是$𝐴$上的全体一一变换构成的集合，则$E(A)$与其上一一变换的乘法运算∘构成的二元代数结构$\langle E(A),\circ\rangle$是一个群。  
【定义12.16】假设$𝐴$是任意给定的一个非空集合，$E(A)$是𝐴上的全体一一变换构成的集合，则$E(A)$与其上一一变换的乘法运算∘构成的群$\langle E(A),\circ\rangle$称为变换群，当$𝐴$是有限集合时，称变换群$\langle E(A),\circ\rangle$为对称群，对称群的任何一个子群称为置换群。  
从上述定义可以看出，变换群的载体集合$ E(A)$可以是有限集合也可以是无限集合，或者说变换群可以是有限群也可以是无限群。对称群则是一种特殊的变换群，要求变换群的载体集合必须是有限集合，因此，对称群一定是有限群。置换群则是变换群的子群，当然对称群作为其自身的平凡子群是一种特殊的置换群，但置换群不一定是对称群。因此，置换群比对称群具有更加广泛的含义，一般主要考察置换群。  
我们知道，对于任意给定的一个有限集合$𝐴$，该集合上的一一变换称为$𝐴$上的置换。当$|A|=n$时称$𝐴$上的置换为${n}$元置换。为了叙述上的方便，常将$A$记作$\{1,2,\cdots,n\}$，这样就可以将$𝐴$上的$n$元置换$p$记作：  
$$
\pi={\binom{a_{1},\ldots a_{n}}{b_{1},\ldots b_{n}}}\,,b_{i}=\sigma(a_{i}),\qquad\qquad\qquad i=1,2,\cdots,n
$$  
易见$.\pi(1)\,\,\,\pi(2)\,\,\,\,\,\cdots\pi(n)$恰恰为${1,\,,2,\cdots,n}$的一个排列。在$𝐴$上的所有置换和$𝐴$的所有排列之间存在着一一对应，$n$元集有$n!$个排列，故有${n}$!个$n$ 元置换。所有这些置换的集合记作$S_{n}$，则$\langle S_{n},\circ\rangle$就是一个对称群。  
具体地说，设$A=\{1,\!2\}$，那么$𝐴$上有两个置换：  
$$
p_1=\binom{1\quad2}{1\quad2},\quad p_2=\binom{1\quad2}{2\quad1}
$$  
当$A=\{1,\!2,\!3\}$时，$A$上有6 个置换：  
$$
\pi_1=\begin{pmatrix}1&2&3\\1&2&3\end{pmatrix},\pi_2=\begin{pmatrix}1&2&3\\2&1&3\end{pmatrix},\pi_3=\begin{pmatrix}1&2&3\\3&2&1\end{pmatrix}
$$  
$$
\pi_1=\begin{pmatrix}1&2&3\\1&3&2\end{pmatrix},\pi_2=\begin{pmatrix}1&2&3\\2&3&1\end{pmatrix},\pi_3=\begin{pmatrix}1&2&3\\3&1&2\end{pmatrix}
$$  
一般地，$A=\{a_{1},a_{2},\dots a_{n}\}$时，$A$上有$n!$个置换。如有$\pi(a_{i})=a_{j_{i}}$时，则$\pi$可表示为：  
$$
\pi={\binom{a_{1},\,\dots\,a_{n}}{a_{j_{1}},\,\dots\,a_{j_{n}}}}
$$  
置换乘法运算或者复合运算通常用∘表示，置换乘法可以像计算两个关系的合成那样进行。需要特别注意的是，置换乘法或复合运算与通常函数的复合运算次序相反。例如：  
$$
\pi_6\circ\pi_4=\begin{pmatrix}1&2&3\\3&1&2\end{pmatrix}\cdot\begin{pmatrix}1&2&3\\1&3&2\end{pmatrix}=\begin{pmatrix}1&2&3\\2&1&3\end{pmatrix}
$$  
即有：$(\pi_{6}\circ\pi_{4})(x)=\pi_{4}(\pi_{6}(x))$  。  
下面考察置换群的几何意义，首先考察三元对称群：  
设$A=\{1,\!2,\!3\}$，则$A$上的6 个置换$S_{3}=\{\pi_{1},\pi_{2},\pi_{3},\pi_{4},\pi_{5},\pi_{6}\}$关于其乘法运算∘构成一个群$\langle S_{3},\circ\rangle$，并称之为三次对称群。其中$\pi_{1}$是恒等置换为群中的单位元，且有：  
$$
{p_{2}}^{-1}=p_{2};~~{p_{3}}^{-1}=p_{3};~~{p_{4}}^{-1}=p_{5};~~{p_{5}}^{-1}=p_{4};~~{p_{6}}^{-1}=p_{6}
$$  
其实，还可以从另一个角度也可得到这个群：用数字1,2,3 标记正三角形的三个顶点，如图12-3 所示。现将三角形以其中心O 为中心轴分别旋转$\sigma_{0},\sigma_{1},\sigma_{2}$（旋转$\cdot0^{\circ},120^{\circ},240^{\circ})$），或分别按直线$l_{1}l_{2}l_{3}$位对称轴进行翻转$(\sigma_{3},\sigma_{4},\sigma_{5})$，则每次旋转或翻转显然都都对应于三角形顶点数字的的一个置换，具体对应关系如下：  
$\sigma_{0}$（旋转$0^{\circ}$）        $p_1=\begin{pmatrix}1&2&3\\1&2&3\end{pmatrix};\quad\sigma_1\bigl(\text{旋转}120^\circ\bigr)\quad p_2=\bigl(\begin{matrix}1&2&3\\2&1&3\end{matrix}\bigr)$  
$\sigma_2\bigl(\text{旋转 240°}\bigr)\quad p_3=\bigl(\begin{matrix}1&2&3\\3&2&1\end{matrix}\bigr);\quad\sigma_3\bigl(\text{绕}l_3\text{翻转}\bigr)$$\quad\quad\quad p_4=\begin{pmatrix}1&2&3\\1&3&2\end{pmatrix}$  
$\sigma_4\big(\text{绕}l_2\text{翻转}\big)\quad p_5=\big(\begin{matrix}1&2&3\\2&3&1\end{matrix}\big);\quad\sigma_5\big(\text{绕}l_1\text{翻转}\big)\quad p_6=(\begin{matrix}1&2&3\\3&1&2\end{matrix})$  
不难看出：$\langle\{\sigma_{0},\sigma_{1},\sigma_{2},\sigma_{3},\sigma_{4},\sigma_{5}\},\circledast\rangle$构成一个群，其中$\circledast$表示旋转或翻转的操作的复合操作，并且与群$\langle\{\pi_{1},\pi_{2},\pi_{3},\pi_{4},\pi_{5},\pi_{6}\},\circ\rangle$同构。  
![](images/e6cbfb18c66c7d99640531f391a63f4a34c10b210258fb0a56bb479a832c31f2.jpg)  
图12-3 三角形的对称轴和对称中心  
![](images/c11de4754b3535d3b87f562740b93b202d5ef5e49fd3a0cb5d9d33538b6831cb.jpg)  
图12-4正方形的对称轴和对称中心  
下面进一步考察四元对称群的几何意义：令$A=\{1,\!2,\!3,\!4\}$，$S_{4}=\{p|p$为A 上的置换}，因此，$\langle S_{4},\circ\rangle$为四元对称群。现用数字1,2,3,4 分别标记正方形的4 个顶点，如图12-4 所示，$\sigma_{0},\sigma_{1},\sigma_{2},\sigma_{3},\sigma_{4},\sigma_{5},\sigma_{6},\sigma_{7}$分别表示正方形以其中心为中心轴进行旋转或按对称轴进行翻转，则它们分别对应与A 上的一个置换，具体如下：  
$ \sigma_0\big(\text{旋转 }0^\circ\big)\quad p_1=\begin{pmatrix}1&2&3&4\\1&2&3&4\end{pmatrix};\quad\sigma_1\big(\text{旋转 }90^\circ\big)\quad p_2=\begin{pmatrix}1&2&3&4\\2&3&4&1\end{pmatrix}$  
$\sigma_2\big(\text{旋转 180°}\big)\quad p_3=\begin{pmatrix}1&2&3&4\\3&4&1&2\end{pmatrix};\quad\sigma_3\big(\text{旋转 270°}\big)\quad p_4=(\begin{matrix}1&2&3&4\\4&1&2&3\end{matrix})$  
$\sigma_4(\text{绕}l_1\text{翻转})\quad p_5=\begin{pmatrix}1&2&3&4\\4&3&2&1\end{pmatrix};\quad\sigma_5(\text{绕}l_2\text{翻转})\quad p_6=(\begin{matrix}1&2&3&4\\1&4&3&2\end{matrix})$  
$\sigma_6(\text{绕}l_3\text{翻转})\quad p_7=\begin{pmatrix}1&2&3&4\\1&4&3&2\end{pmatrix};\quad\sigma_7(\text{绕}l_4\text{翻转})\quad p_8=(\begin{matrix}1&2&3&4\\1&4&3&2\end{matrix})$  
不难看出：$\langle\{\sigma_{0},\sigma_{1},\sigma_{2},\sigma_{3},\sigma_{4},\sigma_{5},\sigma_{6},\sigma_{7}\},\circledast\rangle$构成一个群，其中$\circledast$表示旋转或翻转的操作的复合操作，具体定义如表12-1 所示。  
表12-1 $\circledast$的运算表
![](images/0d658bbe39ea00a7b3a2683e4707c30ed3115f5772998f1ac1c9608422308ecc.jpg)  
由于$\langle\{\sigma_{0},\sigma_{1},\cdots,\sigma_{7}\},\circledast\rangle$与$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$同构，故$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$也是群，它是$\langle S_{4},\circ\rangle$的一个真子群，因为四元对称群$\langle S_{4},\circ\rangle$有24 个置换，而$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$仅有8 个置换。也就是说，群$\langle\{p_{1}p_{2},\cdots,p_{8}\},\circ\rangle$是一个8 阶4 元置换群，但不是4 元对称群。  
【定理12.19】假设$\langle G,*\rangle$是任意给定的一个群，则$\langle G,*\rangle$与某个变换群同构，如果$\langle G,*\rangle$是一个有限群，则$\langle G,*\rangle$与某个置换群同构。  
上述定理12.19 表明，变换群和对称群的重要性在于其作为两种具体的特殊群与一般的抽象群有着非常密切的联系。具体地说，每个群均同构于一个变换群，特别地，每个有限群均同构于一个置换群。因此，从同构的角度看，所有的群都可以看成是变换群，所有的有限群都可以看成是置换群。",每个群均同构于一个变换群，特别地，每个有限群均同构于一个置换群。从同构的角度看，所有的群都可以看成是变换群，所有的有限群都可以看成是置换群。
同余关系,基础工具与结果,商群,,我们知道，集合上的任何一个等价关系都对应该集合上的一个划分，反之亦然。但是，如果对该集合进行某种运算或映射，等价关系则不能保证其所对应的划分在运算或映射下保持不变，这给使用等价关系考察代数结构的研究带来困难。同余关系则是同一性介于相等关系与等价关系之间的一种特殊等价关系，能够保证其作为等价关系所对应划分在运算下保持不变。也就是说，同余关系其实就是能够保运算的一类特殊等价关系。因此，在代数结构的研究中，通常使用同余关系而不是一般等价关系来考察载体集合的划分问题。本节以同余关系为基本工具考察群的子群结构划分问题并由此得到商群的概念与性质，主要包括同余关系与陪集、拉格朗日定理、正规子群与商群的基本知识。,同余关系作为基本工具用于考察群的子群结构划分问题，并由此得到商群的概念与性质
同余关系,特化,模H同余关系,,"现在我们在群结构的场合考察二元代数结构的同余关系。首先看下面具体实例：  
对于整数加群$\langle Z,+\rangle$，易知$\langle Z_{m},+\rangle$是$\langle Z,+\rangle$一个子群。其中$Z_{m}=\{k m|k\in Z\}$，$m$是任意给定的正整数。我们知道，任意两个整数$a$和$b$具有模$m$同余关系当且仅当$a-b\in Z_{m}$。  
对上述整数加群$\langle Z,+\rangle$上模$m$同余关系进行抽象，就得到如下群上的同余关系：  
【定义12.17】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，对于$\forall a,b\in G$,若有$a*b^{-1}\in H$，则称$a$与$b$具有模${H}$同余关系，记为$a\equiv b({mod{H}})$。  
下面的定理12.3.1 表明模$H$同余关系的确是一个同余关系，即要证明该关系不仅是一个等价关系，而且还对运算$*$具有保持性。  
【定理12.20】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则模${H}$同余关系是$G$上的一个等价关系且对运算${\ast}$具有保持性，即对于$\forall a,b,c\in G$，如果$a\equiv b({\bmod{\ H}})$，则有$a*c\equiv b*c({\bmod{\ H}})$。  
对于群$\langle G,*\rangle$的任意一个子群$\langle H,*\rangle$，既然模$H$同余关系是$G$上的一个等价关系，那么该关系必然确定一个对集合$G$的划分，每个划分块就是该等价关系的一个等价类。由于该等价关系显然由子群$\langle H,*\rangle$确定，因此，对集合的$G$划分也应由子群$\langle H,*\rangle$。为便于考察子群$\langle H,*\rangle$与集合划分的关系，现引入子群$\langle H,*\rangle$陪集的概念，并考察$\langle H,*\rangle$的左右陪集与模${H}$同余关系所确定等价类之间的联系。具体如下：  
【定义12.18】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则对于$\forall a\in G$，称集合$a$ $H=\{a*h|h\in H\}$为子群$\langle H,*\rangle$在群$\langle G,*\rangle$中的一个左陪集，集合$H a=\{h*a|h\in H\}$为子群$\langle H,*\rangle$在群$\langle G,*\rangle$中的一个右陪集，元素$a$为$𝑎$ $H$和$H a$的代表元。  
现在考察如何使用左右陪集实现对群的分解，为此首先引入如下定理：  
【定理12.21】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则对于$\forall a\in G$，其关于$\langle H,*\rangle$的左右陪集的基数相等且等于$ H$的基数，即有$\left|a H\right|=\left|H\right|=\left|H a\right|$。  
由此可见，对于群$\langle G,*\rangle$中的任意一个元素，其关于子群$\langle H,*\rangle$的左右陪集的基数相等且是一个仅与子集$H$有关的常数，即为$|H|$。由此可得如下关于群分解的拉格朗日定理：  
【定理12.22】（拉格朗日定理）设$\langle G,*\rangle$是任意给定的一个有限群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则群$\langle G,*\rangle$的阶一定是其子群$\langle H,*\rangle$阶的倍数，即有$k=|G|/|H|$，其中$k$为正整数且为子群$\langle H,*\rangle$的一切不同左（右）陪集个数。  
拉格朗日定理定理告诉我们：若$\langle G,*\rangle$是有限群，则其子群的阶是群$\langle G,*\rangle$阶的因子。因此，可以通过群与其子群阶的关系考察群的结构及其子群的个数。  
【推论12. 1】假设$\langle G,*\rangle$是一个$ n$阶有限群，则$G$中每个元素的阶均是${n}$的因子且对于$\forall a\in$$G$有$a^{n}=e$.  
【推论12.2】阶为素数的有限群是循环群.",模H同余关系是同余关系在群结构中的具体特化
模H同余关系,确定,陪集,,"现在我们在群结构的场合考察二元代数结构的同余关系。首先看下面具体实例：  
对于整数加群$\langle Z,+\rangle$，易知$\langle Z_{m},+\rangle$是$\langle Z,+\rangle$一个子群。其中$Z_{m}=\{k m|k\in Z\}$，$m$是任意给定的正整数。我们知道，任意两个整数$a$和$b$具有模$m$同余关系当且仅当$a-b\in Z_{m}$。  
对上述整数加群$\langle Z,+\rangle$上模$m$同余关系进行抽象，就得到如下群上的同余关系：  
【定义12.17】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，对于$\forall a,b\in G$,若有$a*b^{-1}\in H$，则称$a$与$b$具有模${H}$同余关系，记为$a\equiv b({mod{H}})$。  
下面的定理12.3.1 表明模$H$同余关系的确是一个同余关系，即要证明该关系不仅是一个等价关系，而且还对运算$*$具有保持性。  
【定理12.20】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则模${H}$同余关系是$G$上的一个等价关系且对运算${\ast}$具有保持性，即对于$\forall a,b,c\in G$，如果$a\equiv b({\bmod{\ H}})$，则有$a*c\equiv b*c({\bmod{\ H}})$。  
对于群$\langle G,*\rangle$的任意一个子群$\langle H,*\rangle$，既然模$H$同余关系是$G$上的一个等价关系，那么该关系必然确定一个对集合$G$的划分，每个划分块就是该等价关系的一个等价类。由于该等价关系显然由子群$\langle H,*\rangle$确定，因此，对集合的$G$划分也应由子群$\langle H,*\rangle$。为便于考察子群$\langle H,*\rangle$与集合划分的关系，现引入子群$\langle H,*\rangle$陪集的概念，并考察$\langle H,*\rangle$的左右陪集与模${H}$同余关系所确定等价类之间的联系。具体如下：  
【定义12.18】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则对于$\forall a\in G$，称集合$a$ $H=\{a*h|h\in H\}$为子群$\langle H,*\rangle$在群$\langle G,*\rangle$中的一个左陪集，集合$H a=\{h*a|h\in H\}$为子群$\langle H,*\rangle$在群$\langle G,*\rangle$中的一个右陪集，元素$a$为$𝑎$ $H$和$H a$的代表元。  
现在考察如何使用左右陪集实现对群的分解，为此首先引入如下定理：  
【定理12.21】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则对于$\forall a\in G$，其关于$\langle H,*\rangle$的左右陪集的基数相等且等于$ H$的基数，即有$\left|a H\right|=\left|H\right|=\left|H a\right|$。  
由此可见，对于群$\langle G,*\rangle$中的任意一个元素，其关于子群$\langle H,*\rangle$的左右陪集的基数相等且是一个仅与子集$H$有关的常数，即为$|H|$。由此可得如下关于群分解的拉格朗日定理：  
【定理12.22】（拉格朗日定理）设$\langle G,*\rangle$是任意给定的一个有限群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则群$\langle G,*\rangle$的阶一定是其子群$\langle H,*\rangle$阶的倍数，即有$k=|G|/|H|$，其中$k$为正整数且为子群$\langle H,*\rangle$的一切不同左（右）陪集个数。  
拉格朗日定理定理告诉我们：若$\langle G,*\rangle$是有限群，则其子群的阶是群$\langle G,*\rangle$阶的因子。因此，可以通过群与其子群阶的关系考察群的结构及其子群的个数。  
【推论12. 1】假设$\langle G,*\rangle$是一个$ n$阶有限群，则$G$中每个元素的阶均是${n}$的因子且对于$\forall a\in$$G$有$a^{n}=e$.  
【推论12.2】阶为素数的有限群是循环群.",模H同余关系确定了群中的陪集，每个陪集对应一个等价类
拉格朗日定理,应用,陪集,,"现在我们在群结构的场合考察二元代数结构的同余关系。首先看下面具体实例：  
对于整数加群$\langle Z,+\rangle$，易知$\langle Z_{m},+\rangle$是$\langle Z,+\rangle$一个子群。其中$Z_{m}=\{k m|k\in Z\}$，$m$是任意给定的正整数。我们知道，任意两个整数$a$和$b$具有模$m$同余关系当且仅当$a-b\in Z_{m}$。  
对上述整数加群$\langle Z,+\rangle$上模$m$同余关系进行抽象，就得到如下群上的同余关系：  
【定义12.17】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，对于$\forall a,b\in G$,若有$a*b^{-1}\in H$，则称$a$与$b$具有模${H}$同余关系，记为$a\equiv b({mod{H}})$。  
下面的定理12.3.1 表明模$H$同余关系的确是一个同余关系，即要证明该关系不仅是一个等价关系，而且还对运算$*$具有保持性。  
【定理12.20】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则模${H}$同余关系是$G$上的一个等价关系且对运算${\ast}$具有保持性，即对于$\forall a,b,c\in G$，如果$a\equiv b({\bmod{\ H}})$，则有$a*c\equiv b*c({\bmod{\ H}})$。  
对于群$\langle G,*\rangle$的任意一个子群$\langle H,*\rangle$，既然模$H$同余关系是$G$上的一个等价关系，那么该关系必然确定一个对集合$G$的划分，每个划分块就是该等价关系的一个等价类。由于该等价关系显然由子群$\langle H,*\rangle$确定，因此，对集合的$G$划分也应由子群$\langle H,*\rangle$。为便于考察子群$\langle H,*\rangle$与集合划分的关系，现引入子群$\langle H,*\rangle$陪集的概念，并考察$\langle H,*\rangle$的左右陪集与模${H}$同余关系所确定等价类之间的联系。具体如下：  
【定义12.18】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则对于$\forall a\in G$，称集合$a$ $H=\{a*h|h\in H\}$为子群$\langle H,*\rangle$在群$\langle G,*\rangle$中的一个左陪集，集合$H a=\{h*a|h\in H\}$为子群$\langle H,*\rangle$在群$\langle G,*\rangle$中的一个右陪集，元素$a$为$𝑎$ $H$和$H a$的代表元。  
现在考察如何使用左右陪集实现对群的分解，为此首先引入如下定理：  
【定理12.21】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则对于$\forall a\in G$，其关于$\langle H,*\rangle$的左右陪集的基数相等且等于$ H$的基数，即有$\left|a H\right|=\left|H\right|=\left|H a\right|$。  
由此可见，对于群$\langle G,*\rangle$中的任意一个元素，其关于子群$\langle H,*\rangle$的左右陪集的基数相等且是一个仅与子集$H$有关的常数，即为$|H|$。由此可得如下关于群分解的拉格朗日定理：  
【定理12.22】（拉格朗日定理）设$\langle G,*\rangle$是任意给定的一个有限群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则群$\langle G,*\rangle$的阶一定是其子群$\langle H,*\rangle$阶的倍数，即有$k=|G|/|H|$，其中$k$为正整数且为子群$\langle H,*\rangle$的一切不同左（右）陪集个数。  
拉格朗日定理定理告诉我们：若$\langle G,*\rangle$是有限群，则其子群的阶是群$\langle G,*\rangle$阶的因子。因此，可以通过群与其子群阶的关系考察群的结构及其子群的个数。  
【推论12. 1】假设$\langle G,*\rangle$是一个$ n$阶有限群，则$G$中每个元素的阶均是${n}$的因子且对于$\forall a\in$$G$有$a^{n}=e$.  
【推论12.2】阶为素数的有限群是循环群.",拉格朗日定理应用陪集的概念，说明有限群的阶是其子群阶的倍数
推论12.1,推导,拉格朗日定理,,"现在我们在群结构的场合考察二元代数结构的同余关系。首先看下面具体实例：  
对于整数加群$\langle Z,+\rangle$，易知$\langle Z_{m},+\rangle$是$\langle Z,+\rangle$一个子群。其中$Z_{m}=\{k m|k\in Z\}$，$m$是任意给定的正整数。我们知道，任意两个整数$a$和$b$具有模$m$同余关系当且仅当$a-b\in Z_{m}$。  
对上述整数加群$\langle Z,+\rangle$上模$m$同余关系进行抽象，就得到如下群上的同余关系：  
【定义12.17】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，对于$\forall a,b\in G$,若有$a*b^{-1}\in H$，则称$a$与$b$具有模${H}$同余关系，记为$a\equiv b({mod{H}})$。  
下面的定理12.3.1 表明模$H$同余关系的确是一个同余关系，即要证明该关系不仅是一个等价关系，而且还对运算$*$具有保持性。  
【定理12.20】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则模${H}$同余关系是$G$上的一个等价关系且对运算${\ast}$具有保持性，即对于$\forall a,b,c\in G$，如果$a\equiv b({\bmod{\ H}})$，则有$a*c\equiv b*c({\bmod{\ H}})$。  
对于群$\langle G,*\rangle$的任意一个子群$\langle H,*\rangle$，既然模$H$同余关系是$G$上的一个等价关系，那么该关系必然确定一个对集合$G$的划分，每个划分块就是该等价关系的一个等价类。由于该等价关系显然由子群$\langle H,*\rangle$确定，因此，对集合的$G$划分也应由子群$\langle H,*\rangle$。为便于考察子群$\langle H,*\rangle$与集合划分的关系，现引入子群$\langle H,*\rangle$陪集的概念，并考察$\langle H,*\rangle$的左右陪集与模${H}$同余关系所确定等价类之间的联系。具体如下：  
【定义12.18】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则对于$\forall a\in G$，称集合$a$ $H=\{a*h|h\in H\}$为子群$\langle H,*\rangle$在群$\langle G,*\rangle$中的一个左陪集，集合$H a=\{h*a|h\in H\}$为子群$\langle H,*\rangle$在群$\langle G,*\rangle$中的一个右陪集，元素$a$为$𝑎$ $H$和$H a$的代表元。  
现在考察如何使用左右陪集实现对群的分解，为此首先引入如下定理：  
【定理12.21】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则对于$\forall a\in G$，其关于$\langle H,*\rangle$的左右陪集的基数相等且等于$ H$的基数，即有$\left|a H\right|=\left|H\right|=\left|H a\right|$。  
由此可见，对于群$\langle G,*\rangle$中的任意一个元素，其关于子群$\langle H,*\rangle$的左右陪集的基数相等且是一个仅与子集$H$有关的常数，即为$|H|$。由此可得如下关于群分解的拉格朗日定理：  
【定理12.22】（拉格朗日定理）设$\langle G,*\rangle$是任意给定的一个有限群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则群$\langle G,*\rangle$的阶一定是其子群$\langle H,*\rangle$阶的倍数，即有$k=|G|/|H|$，其中$k$为正整数且为子群$\langle H,*\rangle$的一切不同左（右）陪集个数。  
拉格朗日定理定理告诉我们：若$\langle G,*\rangle$是有限群，则其子群的阶是群$\langle G,*\rangle$阶的因子。因此，可以通过群与其子群阶的关系考察群的结构及其子群的个数。  
【推论12. 1】假设$\langle G,*\rangle$是一个$ n$阶有限群，则$G$中每个元素的阶均是${n}$的因子且对于$\forall a\in$$G$有$a^{n}=e$.  
【推论12.2】阶为素数的有限群是循环群.",推论12.1由拉格朗日定理推导得出，说明有限群中每个元素的阶是群阶的因子
推论12.2,推导,拉格朗日定理,,"现在我们在群结构的场合考察二元代数结构的同余关系。首先看下面具体实例：  
对于整数加群$\langle Z,+\rangle$，易知$\langle Z_{m},+\rangle$是$\langle Z,+\rangle$一个子群。其中$Z_{m}=\{k m|k\in Z\}$，$m$是任意给定的正整数。我们知道，任意两个整数$a$和$b$具有模$m$同余关系当且仅当$a-b\in Z_{m}$。  
对上述整数加群$\langle Z,+\rangle$上模$m$同余关系进行抽象，就得到如下群上的同余关系：  
【定义12.17】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，对于$\forall a,b\in G$,若有$a*b^{-1}\in H$，则称$a$与$b$具有模${H}$同余关系，记为$a\equiv b({mod{H}})$。  
下面的定理12.3.1 表明模$H$同余关系的确是一个同余关系，即要证明该关系不仅是一个等价关系，而且还对运算$*$具有保持性。  
【定理12.20】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则模${H}$同余关系是$G$上的一个等价关系且对运算${\ast}$具有保持性，即对于$\forall a,b,c\in G$，如果$a\equiv b({\bmod{\ H}})$，则有$a*c\equiv b*c({\bmod{\ H}})$。  
对于群$\langle G,*\rangle$的任意一个子群$\langle H,*\rangle$，既然模$H$同余关系是$G$上的一个等价关系，那么该关系必然确定一个对集合$G$的划分，每个划分块就是该等价关系的一个等价类。由于该等价关系显然由子群$\langle H,*\rangle$确定，因此，对集合的$G$划分也应由子群$\langle H,*\rangle$。为便于考察子群$\langle H,*\rangle$与集合划分的关系，现引入子群$\langle H,*\rangle$陪集的概念，并考察$\langle H,*\rangle$的左右陪集与模${H}$同余关系所确定等价类之间的联系。具体如下：  
【定义12.18】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则对于$\forall a\in G$，称集合$a$ $H=\{a*h|h\in H\}$为子群$\langle H,*\rangle$在群$\langle G,*\rangle$中的一个左陪集，集合$H a=\{h*a|h\in H\}$为子群$\langle H,*\rangle$在群$\langle G,*\rangle$中的一个右陪集，元素$a$为$𝑎$ $H$和$H a$的代表元。  
现在考察如何使用左右陪集实现对群的分解，为此首先引入如下定理：  
【定理12.21】设$\langle G,*\rangle$是任意给定的一个群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则对于$\forall a\in G$，其关于$\langle H,*\rangle$的左右陪集的基数相等且等于$ H$的基数，即有$\left|a H\right|=\left|H\right|=\left|H a\right|$。  
由此可见，对于群$\langle G,*\rangle$中的任意一个元素，其关于子群$\langle H,*\rangle$的左右陪集的基数相等且是一个仅与子集$H$有关的常数，即为$|H|$。由此可得如下关于群分解的拉格朗日定理：  
【定理12.22】（拉格朗日定理）设$\langle G,*\rangle$是任意给定的一个有限群，$\langle H,*\rangle$是$\langle G,*\rangle$的任一子群，则群$\langle G,*\rangle$的阶一定是其子群$\langle H,*\rangle$阶的倍数，即有$k=|G|/|H|$，其中$k$为正整数且为子群$\langle H,*\rangle$的一切不同左（右）陪集个数。  
拉格朗日定理定理告诉我们：若$\langle G,*\rangle$是有限群，则其子群的阶是群$\langle G,*\rangle$阶的因子。因此，可以通过群与其子群阶的关系考察群的结构及其子群的个数。  
【推论12. 1】假设$\langle G,*\rangle$是一个$ n$阶有限群，则$G$中每个元素的阶均是${n}$的因子且对于$\forall a\in$$G$有$a^{n}=e$.  
【推论12.2】阶为素数的有限群是循环群.",推论12.2由拉格朗日定理推导得出，说明阶为素数的有限群是循环群
环,包含,域,,前面几节讲述了半群、含幺半群和群，它们都是具有一个运算的代数结构，这对于研究完整的整数系统和实数系统来说，还是不够的，因为这些系统同时具有加法和乘法两个运算。事实上，很多运算系统或代数系统都同时具有两个或两个以上的运算。为此，本节介绍具有两个二元运算的典型代数结构的基本知识，具体包括即环与域的基本概念和性质。,环和域都是具有两个二元运算的典型代数结构
环,包含,含幺环,,"我们知道，整数集合𝑍上具有加法$+$和乘法$\times$这两种运算，并且$\langle Z,+\rangle$是一个交换群、$\langle Z,\times\rangle$是一个半群，并且乘法对加法满足左、右分配律，即有：  
$$
a\times(b+c)=a\times b+a\times c;\ (b+c)\times a=b\times a+c a\times
$$  
由此可见，整数运算系统主要由两个运算子系统构成，即由一个基于加法运算的交换群和一个基于乘法运算的半群构成，并且乘法对加法满足分配律。  
将整数运算系统的上述性质进行抽象，就得到如果环代数结构的定义：  
【定义12.22】如果$\langle G,+,\times\rangle$是具有两个二元运算的代数系统，且满足：（1）$\langle G,+\rangle$是交换群；（2）$\langle G,\times\rangle$是半群；（3）$G$中的$\times$对$+$满足分配律。则称$\langle G,+,\times\rangle$是环代数结构或环代数系统，通常简称为环结构、环系统或环，并称$+$和$\times$分别为环中的加法和乘法。  
由上述定义可知，环结构由加法交换群和乘法半群这两个子结构组成，且满足乘法对加法的分配律。显然，代数系统$\langle Z,+,\times\rangle$就是一个环结构。  
此外，$\langle Q,+,\times\rangle,~\langle R,+,\times\rangle,~\langle C,+,\times\rangle$也都是环结构，其中$Q$是有理数集，$R$是实数集，$C$是复数集，分别称作整数环，有理数环，实数环和复数环。  
可根据构成环的群子结构或半群子结构的特点，对环结构做进一步的分类：  
【定义12.23】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果$\langle G,\times\rangle$是一个含幺半群，则称$\langle G,+,\times\rangle$是一个含幺环，如果$\langle G,\times\rangle$是一个交换半群，则称$\langle G,+,\times\rangle$是一个交换环，如果$\langle G,\times\rangle$是一个含幺交换半群，则称$\langle G,+,\times\rangle$是一个含幺交换环。  
为了叙述上的方便，通常将环中加法的单位元记作0，而将环中元素$x$关于加法的逆元称作$x$的负元，记作$-x$。如果环中乘法有单位元，就把这个单位元记作1，而将$ x$关于乘法的逆元（若存在的话）称为$x$的逆元，记作$:\!x^{-1}$。类似地，可用$x-y,$表示$ x+(-y)$，分别用$n x$和$x^{n}$表示$x$的加法和乘法$ n$次幂，即有：  
$$
n x=\underbrace{x+x+\cdots+x}_{n^{}个};\,\,\,x^{n}=\underbrace{x x\cdots x}_{n^{}个}
$$  
下面讨论环的基本性质。由环的定义可知，环中加法满足交换律、结合律，有单位元0  ，  
每个元素都有负元，环中乘法适合结合律，乘法对加法适合分配律。除此之外，我们进一步考察环的其它一些性质。首先考察环结构中加法逆元的性质：  
【定理12.28】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a,b\in G$，有：  
$$
-(a\times b)=a\times(-b)=(-a)\times b\quad\text{(12-20)}
$$  
下面考察环结构中加法单位元的性质：  
【定理12.29】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a\in G$，有：  
$$
a\times0=0\times a=0\quad\text{(12-21)}
$$  
上述定理12.29 表明，环结构中加法运算的单位元是乘法运算的零元，并且环中任二元素相乘，若其中至少有一个为零元，则乘积必为零元。但反之不然，因为在环中，两个非零元的乘积可能为零元，由此引出如下环结构中零因子的概念：  
【定义12.24】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果存在$G$中两个非零元素满足$a\cdot b=0$ ，称该环为含零因子环，元素 $a$ 和 $b$ 是其零因子，否则称该环为无零因子环。  
【定理12.30】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则$\langle G,+,\times\rangle$是无零因子环当且仅当于$\langle G,\times\rangle$满足消去律。  
由于环是由群和半群这两个子结构构成，故与群结构类似，环结构也存在子环、环同态的相关概念和理论。事实上，子环和环同态的概念和性质完全可以使用与群类似的思路进行讨论，这里不再赘述，读者可自行查阅环结构的相关资料深入学习。",含幺环是环的一种，其乘法半群是含幺半群
环,包含,交换环,,"我们知道，整数集合𝑍上具有加法$+$和乘法$\times$这两种运算，并且$\langle Z,+\rangle$是一个交换群、$\langle Z,\times\rangle$是一个半群，并且乘法对加法满足左、右分配律，即有：  
$$
a\times(b+c)=a\times b+a\times c;\ (b+c)\times a=b\times a+c a\times
$$  
由此可见，整数运算系统主要由两个运算子系统构成，即由一个基于加法运算的交换群和一个基于乘法运算的半群构成，并且乘法对加法满足分配律。  
将整数运算系统的上述性质进行抽象，就得到如果环代数结构的定义：  
【定义12.22】如果$\langle G,+,\times\rangle$是具有两个二元运算的代数系统，且满足：（1）$\langle G,+\rangle$是交换群；（2）$\langle G,\times\rangle$是半群；（3）$G$中的$\times$对$+$满足分配律。则称$\langle G,+,\times\rangle$是环代数结构或环代数系统，通常简称为环结构、环系统或环，并称$+$和$\times$分别为环中的加法和乘法。  
由上述定义可知，环结构由加法交换群和乘法半群这两个子结构组成，且满足乘法对加法的分配律。显然，代数系统$\langle Z,+,\times\rangle$就是一个环结构。  
此外，$\langle Q,+,\times\rangle,~\langle R,+,\times\rangle,~\langle C,+,\times\rangle$也都是环结构，其中$Q$是有理数集，$R$是实数集，$C$是复数集，分别称作整数环，有理数环，实数环和复数环。  
可根据构成环的群子结构或半群子结构的特点，对环结构做进一步的分类：  
【定义12.23】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果$\langle G,\times\rangle$是一个含幺半群，则称$\langle G,+,\times\rangle$是一个含幺环，如果$\langle G,\times\rangle$是一个交换半群，则称$\langle G,+,\times\rangle$是一个交换环，如果$\langle G,\times\rangle$是一个含幺交换半群，则称$\langle G,+,\times\rangle$是一个含幺交换环。  
为了叙述上的方便，通常将环中加法的单位元记作0，而将环中元素$x$关于加法的逆元称作$x$的负元，记作$-x$。如果环中乘法有单位元，就把这个单位元记作1，而将$ x$关于乘法的逆元（若存在的话）称为$x$的逆元，记作$:\!x^{-1}$。类似地，可用$x-y,$表示$ x+(-y)$，分别用$n x$和$x^{n}$表示$x$的加法和乘法$ n$次幂，即有：  
$$
n x=\underbrace{x+x+\cdots+x}_{n^{}个};\,\,\,x^{n}=\underbrace{x x\cdots x}_{n^{}个}
$$  
下面讨论环的基本性质。由环的定义可知，环中加法满足交换律、结合律，有单位元0  ，  
每个元素都有负元，环中乘法适合结合律，乘法对加法适合分配律。除此之外，我们进一步考察环的其它一些性质。首先考察环结构中加法逆元的性质：  
【定理12.28】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a,b\in G$，有：  
$$
-(a\times b)=a\times(-b)=(-a)\times b\quad\text{(12-20)}
$$  
下面考察环结构中加法单位元的性质：  
【定理12.29】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a\in G$，有：  
$$
a\times0=0\times a=0\quad\text{(12-21)}
$$  
上述定理12.29 表明，环结构中加法运算的单位元是乘法运算的零元，并且环中任二元素相乘，若其中至少有一个为零元，则乘积必为零元。但反之不然，因为在环中，两个非零元的乘积可能为零元，由此引出如下环结构中零因子的概念：  
【定义12.24】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果存在$G$中两个非零元素满足$a\cdot b=0$ ，称该环为含零因子环，元素 $a$ 和 $b$ 是其零因子，否则称该环为无零因子环。  
【定理12.30】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则$\langle G,+,\times\rangle$是无零因子环当且仅当于$\langle G,\times\rangle$满足消去律。  
由于环是由群和半群这两个子结构构成，故与群结构类似，环结构也存在子环、环同态的相关概念和理论。事实上，子环和环同态的概念和性质完全可以使用与群类似的思路进行讨论，这里不再赘述，读者可自行查阅环结构的相关资料深入学习。",交换环是环的一种，其乘法半群是交换半群
环,包含,含幺交换环,,"我们知道，整数集合𝑍上具有加法$+$和乘法$\times$这两种运算，并且$\langle Z,+\rangle$是一个交换群、$\langle Z,\times\rangle$是一个半群，并且乘法对加法满足左、右分配律，即有：  
$$
a\times(b+c)=a\times b+a\times c;\ (b+c)\times a=b\times a+c a\times
$$  
由此可见，整数运算系统主要由两个运算子系统构成，即由一个基于加法运算的交换群和一个基于乘法运算的半群构成，并且乘法对加法满足分配律。  
将整数运算系统的上述性质进行抽象，就得到如果环代数结构的定义：  
【定义12.22】如果$\langle G,+,\times\rangle$是具有两个二元运算的代数系统，且满足：（1）$\langle G,+\rangle$是交换群；（2）$\langle G,\times\rangle$是半群；（3）$G$中的$\times$对$+$满足分配律。则称$\langle G,+,\times\rangle$是环代数结构或环代数系统，通常简称为环结构、环系统或环，并称$+$和$\times$分别为环中的加法和乘法。  
由上述定义可知，环结构由加法交换群和乘法半群这两个子结构组成，且满足乘法对加法的分配律。显然，代数系统$\langle Z,+,\times\rangle$就是一个环结构。  
此外，$\langle Q,+,\times\rangle,~\langle R,+,\times\rangle,~\langle C,+,\times\rangle$也都是环结构，其中$Q$是有理数集，$R$是实数集，$C$是复数集，分别称作整数环，有理数环，实数环和复数环。  
可根据构成环的群子结构或半群子结构的特点，对环结构做进一步的分类：  
【定义12.23】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果$\langle G,\times\rangle$是一个含幺半群，则称$\langle G,+,\times\rangle$是一个含幺环，如果$\langle G,\times\rangle$是一个交换半群，则称$\langle G,+,\times\rangle$是一个交换环，如果$\langle G,\times\rangle$是一个含幺交换半群，则称$\langle G,+,\times\rangle$是一个含幺交换环。  
为了叙述上的方便，通常将环中加法的单位元记作0，而将环中元素$x$关于加法的逆元称作$x$的负元，记作$-x$。如果环中乘法有单位元，就把这个单位元记作1，而将$ x$关于乘法的逆元（若存在的话）称为$x$的逆元，记作$:\!x^{-1}$。类似地，可用$x-y,$表示$ x+(-y)$，分别用$n x$和$x^{n}$表示$x$的加法和乘法$ n$次幂，即有：  
$$
n x=\underbrace{x+x+\cdots+x}_{n^{}个};\,\,\,x^{n}=\underbrace{x x\cdots x}_{n^{}个}
$$  
下面讨论环的基本性质。由环的定义可知，环中加法满足交换律、结合律，有单位元0  ，  
每个元素都有负元，环中乘法适合结合律，乘法对加法适合分配律。除此之外，我们进一步考察环的其它一些性质。首先考察环结构中加法逆元的性质：  
【定理12.28】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a,b\in G$，有：  
$$
-(a\times b)=a\times(-b)=(-a)\times b\quad\text{(12-20)}
$$  
下面考察环结构中加法单位元的性质：  
【定理12.29】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a\in G$，有：  
$$
a\times0=0\times a=0\quad\text{(12-21)}
$$  
上述定理12.29 表明，环结构中加法运算的单位元是乘法运算的零元，并且环中任二元素相乘，若其中至少有一个为零元，则乘积必为零元。但反之不然，因为在环中，两个非零元的乘积可能为零元，由此引出如下环结构中零因子的概念：  
【定义12.24】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果存在$G$中两个非零元素满足$a\cdot b=0$ ，称该环为含零因子环，元素 $a$ 和 $b$ 是其零因子，否则称该环为无零因子环。  
【定理12.30】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则$\langle G,+,\times\rangle$是无零因子环当且仅当于$\langle G,\times\rangle$满足消去律。  
由于环是由群和半群这两个子结构构成，故与群结构类似，环结构也存在子环、环同态的相关概念和理论。事实上，子环和环同态的概念和性质完全可以使用与群类似的思路进行讨论，这里不再赘述，读者可自行查阅环结构的相关资料深入学习。",含幺交换环是环的一种，其乘法半群是含幺交换半群
环,包含,零因子环,,"我们知道，整数集合𝑍上具有加法$+$和乘法$\times$这两种运算，并且$\langle Z,+\rangle$是一个交换群、$\langle Z,\times\rangle$是一个半群，并且乘法对加法满足左、右分配律，即有：  
$$
a\times(b+c)=a\times b+a\times c;\ (b+c)\times a=b\times a+c a\times
$$  
由此可见，整数运算系统主要由两个运算子系统构成，即由一个基于加法运算的交换群和一个基于乘法运算的半群构成，并且乘法对加法满足分配律。  
将整数运算系统的上述性质进行抽象，就得到如果环代数结构的定义：  
【定义12.22】如果$\langle G,+,\times\rangle$是具有两个二元运算的代数系统，且满足：（1）$\langle G,+\rangle$是交换群；（2）$\langle G,\times\rangle$是半群；（3）$G$中的$\times$对$+$满足分配律。则称$\langle G,+,\times\rangle$是环代数结构或环代数系统，通常简称为环结构、环系统或环，并称$+$和$\times$分别为环中的加法和乘法。  
由上述定义可知，环结构由加法交换群和乘法半群这两个子结构组成，且满足乘法对加法的分配律。显然，代数系统$\langle Z,+,\times\rangle$就是一个环结构。  
此外，$\langle Q,+,\times\rangle,~\langle R,+,\times\rangle,~\langle C,+,\times\rangle$也都是环结构，其中$Q$是有理数集，$R$是实数集，$C$是复数集，分别称作整数环，有理数环，实数环和复数环。  
可根据构成环的群子结构或半群子结构的特点，对环结构做进一步的分类：  
【定义12.23】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果$\langle G,\times\rangle$是一个含幺半群，则称$\langle G,+,\times\rangle$是一个含幺环，如果$\langle G,\times\rangle$是一个交换半群，则称$\langle G,+,\times\rangle$是一个交换环，如果$\langle G,\times\rangle$是一个含幺交换半群，则称$\langle G,+,\times\rangle$是一个含幺交换环。  
为了叙述上的方便，通常将环中加法的单位元记作0，而将环中元素$x$关于加法的逆元称作$x$的负元，记作$-x$。如果环中乘法有单位元，就把这个单位元记作1，而将$ x$关于乘法的逆元（若存在的话）称为$x$的逆元，记作$:\!x^{-1}$。类似地，可用$x-y,$表示$ x+(-y)$，分别用$n x$和$x^{n}$表示$x$的加法和乘法$ n$次幂，即有：  
$$
n x=\underbrace{x+x+\cdots+x}_{n^{}个};\,\,\,x^{n}=\underbrace{x x\cdots x}_{n^{}个}
$$  
下面讨论环的基本性质。由环的定义可知，环中加法满足交换律、结合律，有单位元0  ，  
每个元素都有负元，环中乘法适合结合律，乘法对加法适合分配律。除此之外，我们进一步考察环的其它一些性质。首先考察环结构中加法逆元的性质：  
【定理12.28】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a,b\in G$，有：  
$$
-(a\times b)=a\times(-b)=(-a)\times b\quad\text{(12-20)}
$$  
下面考察环结构中加法单位元的性质：  
【定理12.29】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a\in G$，有：  
$$
a\times0=0\times a=0\quad\text{(12-21)}
$$  
上述定理12.29 表明，环结构中加法运算的单位元是乘法运算的零元，并且环中任二元素相乘，若其中至少有一个为零元，则乘积必为零元。但反之不然，因为在环中，两个非零元的乘积可能为零元，由此引出如下环结构中零因子的概念：  
【定义12.24】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果存在$G$中两个非零元素满足$a\cdot b=0$ ，称该环为含零因子环，元素 $a$ 和 $b$ 是其零因子，否则称该环为无零因子环。  
【定理12.30】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则$\langle G,+,\times\rangle$是无零因子环当且仅当于$\langle G,\times\rangle$满足消去律。  
由于环是由群和半群这两个子结构构成，故与群结构类似，环结构也存在子环、环同态的相关概念和理论。事实上，子环和环同态的概念和性质完全可以使用与群类似的思路进行讨论，这里不再赘述，读者可自行查阅环结构的相关资料深入学习。",零因子环是环的一种，存在两个非零元素乘积为零
环,包含,无零因子环,,"我们知道，整数集合𝑍上具有加法$+$和乘法$\times$这两种运算，并且$\langle Z,+\rangle$是一个交换群、$\langle Z,\times\rangle$是一个半群，并且乘法对加法满足左、右分配律，即有：  
$$
a\times(b+c)=a\times b+a\times c;\ (b+c)\times a=b\times a+c a\times
$$  
由此可见，整数运算系统主要由两个运算子系统构成，即由一个基于加法运算的交换群和一个基于乘法运算的半群构成，并且乘法对加法满足分配律。  
将整数运算系统的上述性质进行抽象，就得到如果环代数结构的定义：  
【定义12.22】如果$\langle G,+,\times\rangle$是具有两个二元运算的代数系统，且满足：（1）$\langle G,+\rangle$是交换群；（2）$\langle G,\times\rangle$是半群；（3）$G$中的$\times$对$+$满足分配律。则称$\langle G,+,\times\rangle$是环代数结构或环代数系统，通常简称为环结构、环系统或环，并称$+$和$\times$分别为环中的加法和乘法。  
由上述定义可知，环结构由加法交换群和乘法半群这两个子结构组成，且满足乘法对加法的分配律。显然，代数系统$\langle Z,+,\times\rangle$就是一个环结构。  
此外，$\langle Q,+,\times\rangle,~\langle R,+,\times\rangle,~\langle C,+,\times\rangle$也都是环结构，其中$Q$是有理数集，$R$是实数集，$C$是复数集，分别称作整数环，有理数环，实数环和复数环。  
可根据构成环的群子结构或半群子结构的特点，对环结构做进一步的分类：  
【定义12.23】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果$\langle G,\times\rangle$是一个含幺半群，则称$\langle G,+,\times\rangle$是一个含幺环，如果$\langle G,\times\rangle$是一个交换半群，则称$\langle G,+,\times\rangle$是一个交换环，如果$\langle G,\times\rangle$是一个含幺交换半群，则称$\langle G,+,\times\rangle$是一个含幺交换环。  
为了叙述上的方便，通常将环中加法的单位元记作0，而将环中元素$x$关于加法的逆元称作$x$的负元，记作$-x$。如果环中乘法有单位元，就把这个单位元记作1，而将$ x$关于乘法的逆元（若存在的话）称为$x$的逆元，记作$:\!x^{-1}$。类似地，可用$x-y,$表示$ x+(-y)$，分别用$n x$和$x^{n}$表示$x$的加法和乘法$ n$次幂，即有：  
$$
n x=\underbrace{x+x+\cdots+x}_{n^{}个};\,\,\,x^{n}=\underbrace{x x\cdots x}_{n^{}个}
$$  
下面讨论环的基本性质。由环的定义可知，环中加法满足交换律、结合律，有单位元0  ，  
每个元素都有负元，环中乘法适合结合律，乘法对加法适合分配律。除此之外，我们进一步考察环的其它一些性质。首先考察环结构中加法逆元的性质：  
【定理12.28】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a,b\in G$，有：  
$$
-(a\times b)=a\times(-b)=(-a)\times b\quad\text{(12-20)}
$$  
下面考察环结构中加法单位元的性质：  
【定理12.29】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a\in G$，有：  
$$
a\times0=0\times a=0\quad\text{(12-21)}
$$  
上述定理12.29 表明，环结构中加法运算的单位元是乘法运算的零元，并且环中任二元素相乘，若其中至少有一个为零元，则乘积必为零元。但反之不然，因为在环中，两个非零元的乘积可能为零元，由此引出如下环结构中零因子的概念：  
【定义12.24】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果存在$G$中两个非零元素满足$a\cdot b=0$ ，称该环为含零因子环，元素 $a$ 和 $b$ 是其零因子，否则称该环为无零因子环。  
【定理12.30】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则$\langle G,+,\times\rangle$是无零因子环当且仅当于$\langle G,\times\rangle$满足消去律。  
由于环是由群和半群这两个子结构构成，故与群结构类似，环结构也存在子环、环同态的相关概念和理论。事实上，子环和环同态的概念和性质完全可以使用与群类似的思路进行讨论，这里不再赘述，读者可自行查阅环结构的相关资料深入学习。",无零因子环是环的一种，不存在两个非零元素乘积为零
定理12.28,描述,环,,"我们知道，整数集合𝑍上具有加法$+$和乘法$\times$这两种运算，并且$\langle Z,+\rangle$是一个交换群、$\langle Z,\times\rangle$是一个半群，并且乘法对加法满足左、右分配律，即有：  
$$
a\times(b+c)=a\times b+a\times c;\ (b+c)\times a=b\times a+c a\times
$$  
由此可见，整数运算系统主要由两个运算子系统构成，即由一个基于加法运算的交换群和一个基于乘法运算的半群构成，并且乘法对加法满足分配律。  
将整数运算系统的上述性质进行抽象，就得到如果环代数结构的定义：  
【定义12.22】如果$\langle G,+,\times\rangle$是具有两个二元运算的代数系统，且满足：（1）$\langle G,+\rangle$是交换群；（2）$\langle G,\times\rangle$是半群；（3）$G$中的$\times$对$+$满足分配律。则称$\langle G,+,\times\rangle$是环代数结构或环代数系统，通常简称为环结构、环系统或环，并称$+$和$\times$分别为环中的加法和乘法。  
由上述定义可知，环结构由加法交换群和乘法半群这两个子结构组成，且满足乘法对加法的分配律。显然，代数系统$\langle Z,+,\times\rangle$就是一个环结构。  
此外，$\langle Q,+,\times\rangle,~\langle R,+,\times\rangle,~\langle C,+,\times\rangle$也都是环结构，其中$Q$是有理数集，$R$是实数集，$C$是复数集，分别称作整数环，有理数环，实数环和复数环。  
可根据构成环的群子结构或半群子结构的特点，对环结构做进一步的分类：  
【定义12.23】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果$\langle G,\times\rangle$是一个含幺半群，则称$\langle G,+,\times\rangle$是一个含幺环，如果$\langle G,\times\rangle$是一个交换半群，则称$\langle G,+,\times\rangle$是一个交换环，如果$\langle G,\times\rangle$是一个含幺交换半群，则称$\langle G,+,\times\rangle$是一个含幺交换环。  
为了叙述上的方便，通常将环中加法的单位元记作0，而将环中元素$x$关于加法的逆元称作$x$的负元，记作$-x$。如果环中乘法有单位元，就把这个单位元记作1，而将$ x$关于乘法的逆元（若存在的话）称为$x$的逆元，记作$:\!x^{-1}$。类似地，可用$x-y,$表示$ x+(-y)$，分别用$n x$和$x^{n}$表示$x$的加法和乘法$ n$次幂，即有：  
$$
n x=\underbrace{x+x+\cdots+x}_{n^{}个};\,\,\,x^{n}=\underbrace{x x\cdots x}_{n^{}个}
$$  
下面讨论环的基本性质。由环的定义可知，环中加法满足交换律、结合律，有单位元0  ，  
每个元素都有负元，环中乘法适合结合律，乘法对加法适合分配律。除此之外，我们进一步考察环的其它一些性质。首先考察环结构中加法逆元的性质：  
【定理12.28】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a,b\in G$，有：  
$$
-(a\times b)=a\times(-b)=(-a)\times b\quad\text{(12-20)}
$$  
下面考察环结构中加法单位元的性质：  
【定理12.29】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a\in G$，有：  
$$
a\times0=0\times a=0\quad\text{(12-21)}
$$  
上述定理12.29 表明，环结构中加法运算的单位元是乘法运算的零元，并且环中任二元素相乘，若其中至少有一个为零元，则乘积必为零元。但反之不然，因为在环中，两个非零元的乘积可能为零元，由此引出如下环结构中零因子的概念：  
【定义12.24】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果存在$G$中两个非零元素满足$a\cdot b=0$ ，称该环为含零因子环，元素 $a$ 和 $b$ 是其零因子，否则称该环为无零因子环。  
【定理12.30】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则$\langle G,+,\times\rangle$是无零因子环当且仅当于$\langle G,\times\rangle$满足消去律。  
由于环是由群和半群这两个子结构构成，故与群结构类似，环结构也存在子环、环同态的相关概念和理论。事实上，子环和环同态的概念和性质完全可以使用与群类似的思路进行讨论，这里不再赘述，读者可自行查阅环结构的相关资料深入学习。",定理12.28描述了环中加法逆元的性质
定理12.29,描述,环,,"我们知道，整数集合𝑍上具有加法$+$和乘法$\times$这两种运算，并且$\langle Z,+\rangle$是一个交换群、$\langle Z,\times\rangle$是一个半群，并且乘法对加法满足左、右分配律，即有：  
$$
a\times(b+c)=a\times b+a\times c;\ (b+c)\times a=b\times a+c a\times
$$  
由此可见，整数运算系统主要由两个运算子系统构成，即由一个基于加法运算的交换群和一个基于乘法运算的半群构成，并且乘法对加法满足分配律。  
将整数运算系统的上述性质进行抽象，就得到如果环代数结构的定义：  
【定义12.22】如果$\langle G,+,\times\rangle$是具有两个二元运算的代数系统，且满足：（1）$\langle G,+\rangle$是交换群；（2）$\langle G,\times\rangle$是半群；（3）$G$中的$\times$对$+$满足分配律。则称$\langle G,+,\times\rangle$是环代数结构或环代数系统，通常简称为环结构、环系统或环，并称$+$和$\times$分别为环中的加法和乘法。  
由上述定义可知，环结构由加法交换群和乘法半群这两个子结构组成，且满足乘法对加法的分配律。显然，代数系统$\langle Z,+,\times\rangle$就是一个环结构。  
此外，$\langle Q,+,\times\rangle,~\langle R,+,\times\rangle,~\langle C,+,\times\rangle$也都是环结构，其中$Q$是有理数集，$R$是实数集，$C$是复数集，分别称作整数环，有理数环，实数环和复数环。  
可根据构成环的群子结构或半群子结构的特点，对环结构做进一步的分类：  
【定义12.23】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果$\langle G,\times\rangle$是一个含幺半群，则称$\langle G,+,\times\rangle$是一个含幺环，如果$\langle G,\times\rangle$是一个交换半群，则称$\langle G,+,\times\rangle$是一个交换环，如果$\langle G,\times\rangle$是一个含幺交换半群，则称$\langle G,+,\times\rangle$是一个含幺交换环。  
为了叙述上的方便，通常将环中加法的单位元记作0，而将环中元素$x$关于加法的逆元称作$x$的负元，记作$-x$。如果环中乘法有单位元，就把这个单位元记作1，而将$ x$关于乘法的逆元（若存在的话）称为$x$的逆元，记作$:\!x^{-1}$。类似地，可用$x-y,$表示$ x+(-y)$，分别用$n x$和$x^{n}$表示$x$的加法和乘法$ n$次幂，即有：  
$$
n x=\underbrace{x+x+\cdots+x}_{n^{}个};\,\,\,x^{n}=\underbrace{x x\cdots x}_{n^{}个}
$$  
下面讨论环的基本性质。由环的定义可知，环中加法满足交换律、结合律，有单位元0  ，  
每个元素都有负元，环中乘法适合结合律，乘法对加法适合分配律。除此之外，我们进一步考察环的其它一些性质。首先考察环结构中加法逆元的性质：  
【定理12.28】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a,b\in G$，有：  
$$
-(a\times b)=a\times(-b)=(-a)\times b\quad\text{(12-20)}
$$  
下面考察环结构中加法单位元的性质：  
【定理12.29】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a\in G$，有：  
$$
a\times0=0\times a=0\quad\text{(12-21)}
$$  
上述定理12.29 表明，环结构中加法运算的单位元是乘法运算的零元，并且环中任二元素相乘，若其中至少有一个为零元，则乘积必为零元。但反之不然，因为在环中，两个非零元的乘积可能为零元，由此引出如下环结构中零因子的概念：  
【定义12.24】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果存在$G$中两个非零元素满足$a\cdot b=0$ ，称该环为含零因子环，元素 $a$ 和 $b$ 是其零因子，否则称该环为无零因子环。  
【定理12.30】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则$\langle G,+,\times\rangle$是无零因子环当且仅当于$\langle G,\times\rangle$满足消去律。  
由于环是由群和半群这两个子结构构成，故与群结构类似，环结构也存在子环、环同态的相关概念和理论。事实上，子环和环同态的概念和性质完全可以使用与群类似的思路进行讨论，这里不再赘述，读者可自行查阅环结构的相关资料深入学习。",定理12.29描述了环中加法单位元的性质
定理12.30,等价,无零因子环,,"我们知道，整数集合𝑍上具有加法$+$和乘法$\times$这两种运算，并且$\langle Z,+\rangle$是一个交换群、$\langle Z,\times\rangle$是一个半群，并且乘法对加法满足左、右分配律，即有：  
$$
a\times(b+c)=a\times b+a\times c;\ (b+c)\times a=b\times a+c a\times
$$  
由此可见，整数运算系统主要由两个运算子系统构成，即由一个基于加法运算的交换群和一个基于乘法运算的半群构成，并且乘法对加法满足分配律。  
将整数运算系统的上述性质进行抽象，就得到如果环代数结构的定义：  
【定义12.22】如果$\langle G,+,\times\rangle$是具有两个二元运算的代数系统，且满足：（1）$\langle G,+\rangle$是交换群；（2）$\langle G,\times\rangle$是半群；（3）$G$中的$\times$对$+$满足分配律。则称$\langle G,+,\times\rangle$是环代数结构或环代数系统，通常简称为环结构、环系统或环，并称$+$和$\times$分别为环中的加法和乘法。  
由上述定义可知，环结构由加法交换群和乘法半群这两个子结构组成，且满足乘法对加法的分配律。显然，代数系统$\langle Z,+,\times\rangle$就是一个环结构。  
此外，$\langle Q,+,\times\rangle,~\langle R,+,\times\rangle,~\langle C,+,\times\rangle$也都是环结构，其中$Q$是有理数集，$R$是实数集，$C$是复数集，分别称作整数环，有理数环，实数环和复数环。  
可根据构成环的群子结构或半群子结构的特点，对环结构做进一步的分类：  
【定义12.23】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果$\langle G,\times\rangle$是一个含幺半群，则称$\langle G,+,\times\rangle$是一个含幺环，如果$\langle G,\times\rangle$是一个交换半群，则称$\langle G,+,\times\rangle$是一个交换环，如果$\langle G,\times\rangle$是一个含幺交换半群，则称$\langle G,+,\times\rangle$是一个含幺交换环。  
为了叙述上的方便，通常将环中加法的单位元记作0，而将环中元素$x$关于加法的逆元称作$x$的负元，记作$-x$。如果环中乘法有单位元，就把这个单位元记作1，而将$ x$关于乘法的逆元（若存在的话）称为$x$的逆元，记作$:\!x^{-1}$。类似地，可用$x-y,$表示$ x+(-y)$，分别用$n x$和$x^{n}$表示$x$的加法和乘法$ n$次幂，即有：  
$$
n x=\underbrace{x+x+\cdots+x}_{n^{}个};\,\,\,x^{n}=\underbrace{x x\cdots x}_{n^{}个}
$$  
下面讨论环的基本性质。由环的定义可知，环中加法满足交换律、结合律，有单位元0  ，  
每个元素都有负元，环中乘法适合结合律，乘法对加法适合分配律。除此之外，我们进一步考察环的其它一些性质。首先考察环结构中加法逆元的性质：  
【定理12.28】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a,b\in G$，有：  
$$
-(a\times b)=a\times(-b)=(-a)\times b\quad\text{(12-20)}
$$  
下面考察环结构中加法单位元的性质：  
【定理12.29】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则对于$\forall a\in G$，有：  
$$
a\times0=0\times a=0\quad\text{(12-21)}
$$  
上述定理12.29 表明，环结构中加法运算的单位元是乘法运算的零元，并且环中任二元素相乘，若其中至少有一个为零元，则乘积必为零元。但反之不然，因为在环中，两个非零元的乘积可能为零元，由此引出如下环结构中零因子的概念：  
【定义12.24】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，如果存在$G$中两个非零元素满足$a\cdot b=0$ ，称该环为含零因子环，元素 $a$ 和 $b$ 是其零因子，否则称该环为无零因子环。  
【定理12.30】假设$\langle G,+,\times\rangle$是任意给定的一个环结构，则$\langle G,+,\times\rangle$是无零因子环当且仅当于$\langle G,\times\rangle$满足消去律。  
由于环是由群和半群这两个子结构构成，故与群结构类似，环结构也存在子环、环同态的相关概念和理论。事实上，子环和环同态的概念和性质完全可以使用与群类似的思路进行讨论，这里不再赘述，读者可自行查阅环结构的相关资料深入学习。",定理12.30表明环是无零因子环当且仅当其乘法满足消去律
格,属于,代数结构,,格是一种非常特殊的代数结构。如前所述，数学主要有偏序、代数、拓扑和测度这四大基本结构，格结构同时具备偏序结构和代数结构，并与拓扑结构具有非常紧密的联系。不过从本质上看，格仍属于代数结构。格结构在密码学、计算机语义学、开关理论、逻辑设计等多个领域都具有非常重要的应用。本节主要介绍格的基本概念与性质，包括偏序格与代数格的概念、格结构的基本性质、格同态与同构以及若干常用的特殊格。,格本质上属于代数结构
格结构,具备,偏序结构,,格是一种非常特殊的代数结构。如前所述，数学主要有偏序、代数、拓扑和测度这四大基本结构，格结构同时具备偏序结构和代数结构，并与拓扑结构具有非常紧密的联系。不过从本质上看，格仍属于代数结构。格结构在密码学、计算机语义学、开关理论、逻辑设计等多个领域都具有非常重要的应用。本节主要介绍格的基本概念与性质，包括偏序格与代数格的概念、格结构的基本性质、格同态与同构以及若干常用的特殊格。,格结构具备偏序结构
格结构,具备,代数结构,,格是一种非常特殊的代数结构。如前所述，数学主要有偏序、代数、拓扑和测度这四大基本结构，格结构同时具备偏序结构和代数结构，并与拓扑结构具有非常紧密的联系。不过从本质上看，格仍属于代数结构。格结构在密码学、计算机语义学、开关理论、逻辑设计等多个领域都具有非常重要的应用。本节主要介绍格的基本概念与性质，包括偏序格与代数格的概念、格结构的基本性质、格同态与同构以及若干常用的特殊格。,格结构具备代数结构
偏序格,概念并列,代数格,,格是一种非常特殊的代数结构。如前所述，数学主要有偏序、代数、拓扑和测度这四大基本结构，格结构同时具备偏序结构和代数结构，并与拓扑结构具有非常紧密的联系。不过从本质上看，格仍属于代数结构。格结构在密码学、计算机语义学、开关理论、逻辑设计等多个领域都具有非常重要的应用。本节主要介绍格的基本概念与性质，包括偏序格与代数格的概念、格结构的基本性质、格同态与同构以及若干常用的特殊格。,偏序格与代数格是并列的概念
格同态,并列,格同构,,格是一种非常特殊的代数结构。如前所述，数学主要有偏序、代数、拓扑和测度这四大基本结构，格结构同时具备偏序结构和代数结构，并与拓扑结构具有非常紧密的联系。不过从本质上看，格仍属于代数结构。格结构在密码学、计算机语义学、开关理论、逻辑设计等多个领域都具有非常重要的应用。本节主要介绍格的基本概念与性质，包括偏序格与代数格的概念、格结构的基本性质、格同态与同构以及若干常用的特殊格。,格同态与格同构是并列的概念
格,包含,特殊格,,格是一种非常特殊的代数结构。如前所述，数学主要有偏序、代数、拓扑和测度这四大基本结构，格结构同时具备偏序结构和代数结构，并与拓扑结构具有非常紧密的联系。不过从本质上看，格仍属于代数结构。格结构在密码学、计算机语义学、开关理论、逻辑设计等多个领域都具有非常重要的应用。本节主要介绍格的基本概念与性质，包括偏序格与代数格的概念、格结构的基本性质、格同态与同构以及若干常用的特殊格。,格包含若干常用的特殊格
格,包含,偏序格,,"格的特殊性主要是在代数结构中引入偏序关系，一个格结构，既可从偏序角度借助哈斯图直观地表示格结构，也可从代数角度通过子代数、同态和同构策略等分析讨论格结构。我们首先分别定义偏序格和代数格的概念，然后在证明这两个概念是等价的。首先给出偏序格的定义，具体如下：  
【定义12.26】对偏序集$\langle L,\leq\rangle$中的任意两个元素$a,b$，如果集合$\left\{a,b\right\}$恒存在上确界$(G L B)$和下确界$（𝐿𝑈𝐵）$，则称偏序集$\langle L,\leq\rangle$是一个格，或称为偏序格。  
我们知道，对于任意给定的一个偏序集$\langle L,\leq\rangle$，其中的任意两个元素所构成的子集不一定存在上确界或下确界，否则该偏序集就是偏序格。  
既然格是一种特殊的代数系统，那么这种偏序格一定存在运算。利用格的定义和偏序关系的反对称性不难证明：对于偏序格$\langle L,\leq\rangle$中任意两个元素$a,b$构成的集合$\{a,b\}$，其上确界和下确界唯一存在且均属于$ L$。因此，可用$a*b$表示集合$\{a,b\}$的下确界，称为$a$和$b$的保交，用$a\oplus b$表示集合$\left\{a,b\right\}$的上确界，称为a 和$b$ 的保联。$*$和⊕即为偏序格的两个二元运算，即：  
$$
a*b=G L B\{a,b\},\;\;a\oplus b=L U B\{a,b\}
$$  
有时也用∩和∪、$*$和$+、\wedge$和$\vee$分别表示保交和保联。  
例如，设$ Z^{+}$是正整数集合，在$Z^{+}$上定义一个二元运算“|”，对于$a,b\in Z^{+}$，$a|b$当且仅当$a$整除$b$。容易验证运算“|”是$Z^{+}$上一个偏序关系，故$\langle Z^{+},|\rangle$是偏序集。由于该偏序集中任意两个元素的最小公倍数和最大公约数就是这两个元素的最小上界和最大下界，因此，$\langle Z^{+},|\rangle$是格。再如，设$\varphi(S)$是给定集合$𝑆$的幂集，$\langle\varphi(S),\subseteq\rangle$是一个偏序集，则对于于$\varphi(S)$中的任意两 个元素$ S_{1}$，$S_{2}$，其最大下界为$S_{1}\cap S_{2}$，最小上界为$S_{1}\cup S_{2}$，所以$\langle\varphi(S),\subseteq\rangle$是格。  
从代数的角度出发，有如下关于格的定义：  
【定义12.27】设$\langle L,\land,\lor\rangle$是具有两个二元运算的代数系统，若对于$\forall a,b,c\in L$，满足：  
交换律：$a\vee b=b\vee a$， $a\wedge b=b\wedge a$；  
结合律：$a\lor(b\lor c)=(a\lor b)\lor c,\;\;a\land(b\land c)=(a\land b)\land c;$  
吸收律：$a\vee(a\wedge b)=a$，$a\wedge(a\vee b)=a$；  
则称$\langle L,\land,\lor\rangle$是一个格，或称为代数格。  
可以证明代数格还满足幂等律。事实上，对于$\forall a\in L_{\prime}$,有：  
$$
a\wedge a=a\wedge(a\vee(a\wedge a))=a;\enspace a\vee a=a\vee(a\wedge(a\vee a))=a
$$  
即有$a\wedge a=a$和$a\vee a=a$成立。  
下面的定理表明偏序格和代数格是等价的。  
【定理12.32】偏序格和代数格的定义是等价的。换言之，任何一个偏序格都存在一个与之对应的代数格，并且任意一个代数格也存在一个与之对应的偏序格。",偏序格是格的一种特殊形式，通过偏序关系定义
格,包含,代数格,,"格的特殊性主要是在代数结构中引入偏序关系，一个格结构，既可从偏序角度借助哈斯图直观地表示格结构，也可从代数角度通过子代数、同态和同构策略等分析讨论格结构。我们首先分别定义偏序格和代数格的概念，然后在证明这两个概念是等价的。首先给出偏序格的定义，具体如下：  
【定义12.26】对偏序集$\langle L,\leq\rangle$中的任意两个元素$a,b$，如果集合$\left\{a,b\right\}$恒存在上确界$(G L B)$和下确界$（𝐿𝑈𝐵）$，则称偏序集$\langle L,\leq\rangle$是一个格，或称为偏序格。  
我们知道，对于任意给定的一个偏序集$\langle L,\leq\rangle$，其中的任意两个元素所构成的子集不一定存在上确界或下确界，否则该偏序集就是偏序格。  
既然格是一种特殊的代数系统，那么这种偏序格一定存在运算。利用格的定义和偏序关系的反对称性不难证明：对于偏序格$\langle L,\leq\rangle$中任意两个元素$a,b$构成的集合$\{a,b\}$，其上确界和下确界唯一存在且均属于$ L$。因此，可用$a*b$表示集合$\{a,b\}$的下确界，称为$a$和$b$的保交，用$a\oplus b$表示集合$\left\{a,b\right\}$的上确界，称为a 和$b$ 的保联。$*$和⊕即为偏序格的两个二元运算，即：  
$$
a*b=G L B\{a,b\},\;\;a\oplus b=L U B\{a,b\}
$$  
有时也用∩和∪、$*$和$+、\wedge$和$\vee$分别表示保交和保联。  
例如，设$ Z^{+}$是正整数集合，在$Z^{+}$上定义一个二元运算“|”，对于$a,b\in Z^{+}$，$a|b$当且仅当$a$整除$b$。容易验证运算“|”是$Z^{+}$上一个偏序关系，故$\langle Z^{+},|\rangle$是偏序集。由于该偏序集中任意两个元素的最小公倍数和最大公约数就是这两个元素的最小上界和最大下界，因此，$\langle Z^{+},|\rangle$是格。再如，设$\varphi(S)$是给定集合$𝑆$的幂集，$\langle\varphi(S),\subseteq\rangle$是一个偏序集，则对于于$\varphi(S)$中的任意两 个元素$ S_{1}$，$S_{2}$，其最大下界为$S_{1}\cap S_{2}$，最小上界为$S_{1}\cup S_{2}$，所以$\langle\varphi(S),\subseteq\rangle$是格。  
从代数的角度出发，有如下关于格的定义：  
【定义12.27】设$\langle L,\land,\lor\rangle$是具有两个二元运算的代数系统，若对于$\forall a,b,c\in L$，满足：  
交换律：$a\vee b=b\vee a$， $a\wedge b=b\wedge a$；  
结合律：$a\lor(b\lor c)=(a\lor b)\lor c,\;\;a\land(b\land c)=(a\land b)\land c;$  
吸收律：$a\vee(a\wedge b)=a$，$a\wedge(a\vee b)=a$；  
则称$\langle L,\land,\lor\rangle$是一个格，或称为代数格。  
可以证明代数格还满足幂等律。事实上，对于$\forall a\in L_{\prime}$,有：  
$$
a\wedge a=a\wedge(a\vee(a\wedge a))=a;\enspace a\vee a=a\vee(a\wedge(a\vee a))=a
$$  
即有$a\wedge a=a$和$a\vee a=a$成立。  
下面的定理表明偏序格和代数格是等价的。  
【定理12.32】偏序格和代数格的定义是等价的。换言之，任何一个偏序格都存在一个与之对应的代数格，并且任意一个代数格也存在一个与之对应的偏序格。",代数格是格的一种特殊形式，通过代数运算定义
偏序格,等价,代数格,,"格的特殊性主要是在代数结构中引入偏序关系，一个格结构，既可从偏序角度借助哈斯图直观地表示格结构，也可从代数角度通过子代数、同态和同构策略等分析讨论格结构。我们首先分别定义偏序格和代数格的概念，然后在证明这两个概念是等价的。首先给出偏序格的定义，具体如下：  
【定义12.26】对偏序集$\langle L,\leq\rangle$中的任意两个元素$a,b$，如果集合$\left\{a,b\right\}$恒存在上确界$(G L B)$和下确界$（𝐿𝑈𝐵）$，则称偏序集$\langle L,\leq\rangle$是一个格，或称为偏序格。  
我们知道，对于任意给定的一个偏序集$\langle L,\leq\rangle$，其中的任意两个元素所构成的子集不一定存在上确界或下确界，否则该偏序集就是偏序格。  
既然格是一种特殊的代数系统，那么这种偏序格一定存在运算。利用格的定义和偏序关系的反对称性不难证明：对于偏序格$\langle L,\leq\rangle$中任意两个元素$a,b$构成的集合$\{a,b\}$，其上确界和下确界唯一存在且均属于$ L$。因此，可用$a*b$表示集合$\{a,b\}$的下确界，称为$a$和$b$的保交，用$a\oplus b$表示集合$\left\{a,b\right\}$的上确界，称为a 和$b$ 的保联。$*$和⊕即为偏序格的两个二元运算，即：  
$$
a*b=G L B\{a,b\},\;\;a\oplus b=L U B\{a,b\}
$$  
有时也用∩和∪、$*$和$+、\wedge$和$\vee$分别表示保交和保联。  
例如，设$ Z^{+}$是正整数集合，在$Z^{+}$上定义一个二元运算“|”，对于$a,b\in Z^{+}$，$a|b$当且仅当$a$整除$b$。容易验证运算“|”是$Z^{+}$上一个偏序关系，故$\langle Z^{+},|\rangle$是偏序集。由于该偏序集中任意两个元素的最小公倍数和最大公约数就是这两个元素的最小上界和最大下界，因此，$\langle Z^{+},|\rangle$是格。再如，设$\varphi(S)$是给定集合$𝑆$的幂集，$\langle\varphi(S),\subseteq\rangle$是一个偏序集，则对于于$\varphi(S)$中的任意两 个元素$ S_{1}$，$S_{2}$，其最大下界为$S_{1}\cap S_{2}$，最小上界为$S_{1}\cup S_{2}$，所以$\langle\varphi(S),\subseteq\rangle$是格。  
从代数的角度出发，有如下关于格的定义：  
【定义12.27】设$\langle L,\land,\lor\rangle$是具有两个二元运算的代数系统，若对于$\forall a,b,c\in L$，满足：  
交换律：$a\vee b=b\vee a$， $a\wedge b=b\wedge a$；  
结合律：$a\lor(b\lor c)=(a\lor b)\lor c,\;\;a\land(b\land c)=(a\land b)\land c;$  
吸收律：$a\vee(a\wedge b)=a$，$a\wedge(a\vee b)=a$；  
则称$\langle L,\land,\lor\rangle$是一个格，或称为代数格。  
可以证明代数格还满足幂等律。事实上，对于$\forall a\in L_{\prime}$,有：  
$$
a\wedge a=a\wedge(a\vee(a\wedge a))=a;\enspace a\vee a=a\vee(a\wedge(a\vee a))=a
$$  
即有$a\wedge a=a$和$a\vee a=a$成立。  
下面的定理表明偏序格和代数格是等价的。  
【定理12.32】偏序格和代数格的定义是等价的。换言之，任何一个偏序格都存在一个与之对应的代数格，并且任意一个代数格也存在一个与之对应的偏序格。",偏序格和代数格的定义是等价的，任何一个偏序格都存在一个与之对应的代数格，反之亦然
偏序格与代数格的等价性,描述,偏序格,,"格的特殊性主要是在代数结构中引入偏序关系，一个格结构，既可从偏序角度借助哈斯图直观地表示格结构，也可从代数角度通过子代数、同态和同构策略等分析讨论格结构。我们首先分别定义偏序格和代数格的概念，然后在证明这两个概念是等价的。首先给出偏序格的定义，具体如下：  
【定义12.26】对偏序集$\langle L,\leq\rangle$中的任意两个元素$a,b$，如果集合$\left\{a,b\right\}$恒存在上确界$(G L B)$和下确界$（𝐿𝑈𝐵）$，则称偏序集$\langle L,\leq\rangle$是一个格，或称为偏序格。  
我们知道，对于任意给定的一个偏序集$\langle L,\leq\rangle$，其中的任意两个元素所构成的子集不一定存在上确界或下确界，否则该偏序集就是偏序格。  
既然格是一种特殊的代数系统，那么这种偏序格一定存在运算。利用格的定义和偏序关系的反对称性不难证明：对于偏序格$\langle L,\leq\rangle$中任意两个元素$a,b$构成的集合$\{a,b\}$，其上确界和下确界唯一存在且均属于$ L$。因此，可用$a*b$表示集合$\{a,b\}$的下确界，称为$a$和$b$的保交，用$a\oplus b$表示集合$\left\{a,b\right\}$的上确界，称为a 和$b$ 的保联。$*$和⊕即为偏序格的两个二元运算，即：  
$$
a*b=G L B\{a,b\},\;\;a\oplus b=L U B\{a,b\}
$$  
有时也用∩和∪、$*$和$+、\wedge$和$\vee$分别表示保交和保联。  
例如，设$ Z^{+}$是正整数集合，在$Z^{+}$上定义一个二元运算“|”，对于$a,b\in Z^{+}$，$a|b$当且仅当$a$整除$b$。容易验证运算“|”是$Z^{+}$上一个偏序关系，故$\langle Z^{+},|\rangle$是偏序集。由于该偏序集中任意两个元素的最小公倍数和最大公约数就是这两个元素的最小上界和最大下界，因此，$\langle Z^{+},|\rangle$是格。再如，设$\varphi(S)$是给定集合$𝑆$的幂集，$\langle\varphi(S),\subseteq\rangle$是一个偏序集，则对于于$\varphi(S)$中的任意两 个元素$ S_{1}$，$S_{2}$，其最大下界为$S_{1}\cap S_{2}$，最小上界为$S_{1}\cup S_{2}$，所以$\langle\varphi(S),\subseteq\rangle$是格。  
从代数的角度出发，有如下关于格的定义：  
【定义12.27】设$\langle L,\land,\lor\rangle$是具有两个二元运算的代数系统，若对于$\forall a,b,c\in L$，满足：  
交换律：$a\vee b=b\vee a$， $a\wedge b=b\wedge a$；  
结合律：$a\lor(b\lor c)=(a\lor b)\lor c,\;\;a\land(b\land c)=(a\land b)\land c;$  
吸收律：$a\vee(a\wedge b)=a$，$a\wedge(a\vee b)=a$；  
则称$\langle L,\land,\lor\rangle$是一个格，或称为代数格。  
可以证明代数格还满足幂等律。事实上，对于$\forall a\in L_{\prime}$,有：  
$$
a\wedge a=a\wedge(a\vee(a\wedge a))=a;\enspace a\vee a=a\vee(a\wedge(a\vee a))=a
$$  
即有$a\wedge a=a$和$a\vee a=a$成立。  
下面的定理表明偏序格和代数格是等价的。  
【定理12.32】偏序格和代数格的定义是等价的。换言之，任何一个偏序格都存在一个与之对应的代数格，并且任意一个代数格也存在一个与之对应的偏序格。",偏序格与代数格的等价性描述了偏序格和代数格之间的等价关系
偏序格与代数格的等价性,描述,代数格,,"格的特殊性主要是在代数结构中引入偏序关系，一个格结构，既可从偏序角度借助哈斯图直观地表示格结构，也可从代数角度通过子代数、同态和同构策略等分析讨论格结构。我们首先分别定义偏序格和代数格的概念，然后在证明这两个概念是等价的。首先给出偏序格的定义，具体如下：  
【定义12.26】对偏序集$\langle L,\leq\rangle$中的任意两个元素$a,b$，如果集合$\left\{a,b\right\}$恒存在上确界$(G L B)$和下确界$（𝐿𝑈𝐵）$，则称偏序集$\langle L,\leq\rangle$是一个格，或称为偏序格。  
我们知道，对于任意给定的一个偏序集$\langle L,\leq\rangle$，其中的任意两个元素所构成的子集不一定存在上确界或下确界，否则该偏序集就是偏序格。  
既然格是一种特殊的代数系统，那么这种偏序格一定存在运算。利用格的定义和偏序关系的反对称性不难证明：对于偏序格$\langle L,\leq\rangle$中任意两个元素$a,b$构成的集合$\{a,b\}$，其上确界和下确界唯一存在且均属于$ L$。因此，可用$a*b$表示集合$\{a,b\}$的下确界，称为$a$和$b$的保交，用$a\oplus b$表示集合$\left\{a,b\right\}$的上确界，称为a 和$b$ 的保联。$*$和⊕即为偏序格的两个二元运算，即：  
$$
a*b=G L B\{a,b\},\;\;a\oplus b=L U B\{a,b\}
$$  
有时也用∩和∪、$*$和$+、\wedge$和$\vee$分别表示保交和保联。  
例如，设$ Z^{+}$是正整数集合，在$Z^{+}$上定义一个二元运算“|”，对于$a,b\in Z^{+}$，$a|b$当且仅当$a$整除$b$。容易验证运算“|”是$Z^{+}$上一个偏序关系，故$\langle Z^{+},|\rangle$是偏序集。由于该偏序集中任意两个元素的最小公倍数和最大公约数就是这两个元素的最小上界和最大下界，因此，$\langle Z^{+},|\rangle$是格。再如，设$\varphi(S)$是给定集合$𝑆$的幂集，$\langle\varphi(S),\subseteq\rangle$是一个偏序集，则对于于$\varphi(S)$中的任意两 个元素$ S_{1}$，$S_{2}$，其最大下界为$S_{1}\cap S_{2}$，最小上界为$S_{1}\cup S_{2}$，所以$\langle\varphi(S),\subseteq\rangle$是格。  
从代数的角度出发，有如下关于格的定义：  
【定义12.27】设$\langle L,\land,\lor\rangle$是具有两个二元运算的代数系统，若对于$\forall a,b,c\in L$，满足：  
交换律：$a\vee b=b\vee a$， $a\wedge b=b\wedge a$；  
结合律：$a\lor(b\lor c)=(a\lor b)\lor c,\;\;a\land(b\land c)=(a\land b)\land c;$  
吸收律：$a\vee(a\wedge b)=a$，$a\wedge(a\vee b)=a$；  
则称$\langle L,\land,\lor\rangle$是一个格，或称为代数格。  
可以证明代数格还满足幂等律。事实上，对于$\forall a\in L_{\prime}$,有：  
$$
a\wedge a=a\wedge(a\vee(a\wedge a))=a;\enspace a\vee a=a\vee(a\wedge(a\vee a))=a
$$  
即有$a\wedge a=a$和$a\vee a=a$成立。  
下面的定理表明偏序格和代数格是等价的。  
【定理12.32】偏序格和代数格的定义是等价的。换言之，任何一个偏序格都存在一个与之对应的代数格，并且任意一个代数格也存在一个与之对应的偏序格。",偏序格与代数格的等价性描述了偏序格和代数格之间的等价关系
格,包含,子格,,"对偶性是格结构最基本的特征。考察格的基本性质一般从格结构的对偶特征入手。从偏序关系的角度看，格$\langle L,\leq\rangle$结构在集合 $L$上定义的偏序关系$\leq$显然是可逆的。具体地说，对于集合$ L$上的偏序关系≤，其逆关系$\geq$也是集合$ L$上的偏序关系。由于将偏序集$\langle L,\leq\rangle$的哈斯图做一个上下翻转就得到偏序集$\langle L,\geq\rangle$的哈斯图，故对集合$L$的任意子集$𝐴$，$A$在偏序$\langle L,\leq\rangle$中的上确界是$𝐴$在偏序$\langle L,\geq\rangle$中的下确界，$A$在$\langle L,\leq\rangle$中的下确界是$𝐴$在$\langle L,\geq\rangle$的上确界。因为二元关系的逆关系保持原关系的自反性、反对称性和传递性不变，所以$\langle L,\geq\rangle$也是格。  
通常将格$\langle L,\leq\rangle$和格$\langle L,\geq\rangle$称为互为对偶的格。对偶格之间具有紧密联系，例如格$\langle L,\leq\rangle$的保交运算对应格$\langle L,\geq\rangle$的保联运算，反之亦然。假如在格$\langle L,\leq\rangle$和格$\langle L,\geq\rangle$中，$*$和$\oplus$分别代表格的下确界和上确界运算，如果在关于$\langle L,\leq\rangle$的命题中，分别用$*$、⊕、$≤$代替关于$\langle L,\geq\rangle$命题中的⊕、$∗$、$≥$，那么两个命题的真伪必定保持一致性。这就是对偶原理。  
【定理12.33】设$\langle L,\leq\rangle$是任意给定的一个格，关系“$≤$”是“$\geq\!\!$的逆关系，则对$\forall$ $a,b,c,d\in$$L$，有如下14 条基本性质：  
（1）自反性：  $a\leq a;\ \ a\geq a.$  
（2）反对称性：$a\leq b$且$b\leq a\Rightarrow a=b$；$a\geq b$且$b\geq a\Rightarrow a=b$.  
（3）传递性  $a\leq b$且$b\leq c\Rightarrow a\leq c$；$a\geq b$且$b\geq c\Rightarrow a\geq c$.  $(4)a*b\leq a;\;\;a\oplus b\geq a;\;\;a*b\leq b;\;\;a\oplus b\geq b.$  
（5）$c\leq a$且$c\leq b\Rightarrow c\leq a*b$；$c\geq a$且$c\geq b\Rightarrow c\geq a\oplus b$.  
（6）交换律：  $a*b=b*a;\ a\oplus b=b\oplus a$  
（7）结合律：  $a*(b*c)=(a*b)*c;\;\;a\oplus(b\oplus c)=(a\oplus b)\oplus c$  
（8）吸收律：  $a*(a\oplus b)=a;\ a\oplus(a*b)=a.$  
（9）幂等律：  $a*a=a;\;\;a\oplus a=a.$  
(10)  $a\leq b\Longleftrightarrow a*b=a\Longleftrightarrow a\oplus b=b\,.$  
（11）$a\leq b$且$c\leq d\Rightarrow a*c\leq b*d$；$a\leq b$且${\mathfrak{c}}\leq d\Rightarrow a\oplus c\leq b\oplus d$.  
（12）偏序对运算的保序性：  $a\leq b\Rightarrow a*c\leq b*c;\;\;a\leq b\Rightarrow a\oplus c\leq b\oplus c$  
（13）确界运算对偏序的分配不等式：
$$
a\oplus(b*c)\leq(a\oplus b)*(a\oplus c);\,\,\,a*(b\oplus c)\geq(a*b)\oplus(a*(c)
$$  
（14） 确界运算对偏序的模不等式：$a\leq c\Longleftrightarrow a\oplus(b*c)\leq(a\oplus b)*c$  
格是一个特殊的代数系统，那么是否存在子格和格同态呢，答案是肯定的。设集合$𝑆$是集合$ L$的子集，从格的定义角度出发，格要求运算必须满足交换律、结合律和吸收律，如果这些运算律在集合$L$上满足，那么在$𝑆$上也一定满足，因此只要集合$𝐴$是非空的，且运算在$𝑆$上满足封闭性，那么$𝑆$就为$L$的子格。一般地，有如下的定义：  
【定义12.28】设代数系统$\langle L,*,\oplus\rangle$是一个格，对于$L$的任意一个非空子集$𝑆$，若运算$*$和$\oplus$在$𝑆$上的满足封闭性，则称$\langle S,*,\oplus\rangle$是$\langle L,*,\oplus\rangle$的一个子格，简称$𝑆$是$L$的子格。  
上面给出了代数格的子格定义，那么对于偏序格的子格又改如何定义呢。事实上若非空集合$\textstyle S\subseteq L$，且$\langle L,\leq\rangle$是偏序格，由第六章的偏序关系知道$\langle S,\leq\rangle$一定是偏序集，甚至也可能是格，但不一定是子格，因为子格要对运算封闭。由此得到如下偏序子格的定义：  
【定义12.29】设$\langle L,\leq\rangle$是一个格，$S\subseteq L$，若𝑆满足：  
（1）$S\neq\emptyset$；（2）对$\forall\;\;a,b\in S,\;\;<L,\leq\;>$的保交和保联运算都有： $a*b=G L B\{a,b\}\in S;\;\;a\oplus b=L U B\{a,b\}\in S$  
则称$\langle S,\leq\rangle$是$\langle L,\leq\rangle$的一个子格，简称$𝑆$是$L$的子格。  
利用代数系统中的同态和同构概念，分别可以得到格的同态和同构的定义：  
【定义12.30】设$\langle L,\land,\lor\rangle$和$\langle S,*,\oplus\rangle$是两个格， $f$是从$L$到$𝑆$的映射，若对$\forall\;\;x,y\in L$，有：  
$$
f(x\wedge y)=f(x)*f(y);\ f(x\vee y)=f(x)\oplus(y)
$$  
则称 $f$ 为从格 $\langle L,\land,\lor\rangle$ 到格 $\langle S,*,\oplus\rangle$ 的格同态映射，简称格同态。如果 $f$ 分别是单射、满射和双 射，$f$分别称为单格同态、满格同态和格同构，将格$ L$到$L$的同态称为$ L $的自同态。",子格是格的非空子集，且在子集上运算封闭
格,特殊化,偏序子格,,"对偶性是格结构最基本的特征。考察格的基本性质一般从格结构的对偶特征入手。从偏序关系的角度看，格$\langle L,\leq\rangle$结构在集合 $L$上定义的偏序关系$\leq$显然是可逆的。具体地说，对于集合$ L$上的偏序关系≤，其逆关系$\geq$也是集合$ L$上的偏序关系。由于将偏序集$\langle L,\leq\rangle$的哈斯图做一个上下翻转就得到偏序集$\langle L,\geq\rangle$的哈斯图，故对集合$L$的任意子集$𝐴$，$A$在偏序$\langle L,\leq\rangle$中的上确界是$𝐴$在偏序$\langle L,\geq\rangle$中的下确界，$A$在$\langle L,\leq\rangle$中的下确界是$𝐴$在$\langle L,\geq\rangle$的上确界。因为二元关系的逆关系保持原关系的自反性、反对称性和传递性不变，所以$\langle L,\geq\rangle$也是格。  
通常将格$\langle L,\leq\rangle$和格$\langle L,\geq\rangle$称为互为对偶的格。对偶格之间具有紧密联系，例如格$\langle L,\leq\rangle$的保交运算对应格$\langle L,\geq\rangle$的保联运算，反之亦然。假如在格$\langle L,\leq\rangle$和格$\langle L,\geq\rangle$中，$*$和$\oplus$分别代表格的下确界和上确界运算，如果在关于$\langle L,\leq\rangle$的命题中，分别用$*$、⊕、$≤$代替关于$\langle L,\geq\rangle$命题中的⊕、$∗$、$≥$，那么两个命题的真伪必定保持一致性。这就是对偶原理。  
【定理12.33】设$\langle L,\leq\rangle$是任意给定的一个格，关系“$≤$”是“$\geq\!\!$的逆关系，则对$\forall$ $a,b,c,d\in$$L$，有如下14 条基本性质：  
（1）自反性：  $a\leq a;\ \ a\geq a.$  
（2）反对称性：$a\leq b$且$b\leq a\Rightarrow a=b$；$a\geq b$且$b\geq a\Rightarrow a=b$.  
（3）传递性  $a\leq b$且$b\leq c\Rightarrow a\leq c$；$a\geq b$且$b\geq c\Rightarrow a\geq c$.  $(4)a*b\leq a;\;\;a\oplus b\geq a;\;\;a*b\leq b;\;\;a\oplus b\geq b.$  
（5）$c\leq a$且$c\leq b\Rightarrow c\leq a*b$；$c\geq a$且$c\geq b\Rightarrow c\geq a\oplus b$.  
（6）交换律：  $a*b=b*a;\ a\oplus b=b\oplus a$  
（7）结合律：  $a*(b*c)=(a*b)*c;\;\;a\oplus(b\oplus c)=(a\oplus b)\oplus c$  
（8）吸收律：  $a*(a\oplus b)=a;\ a\oplus(a*b)=a.$  
（9）幂等律：  $a*a=a;\;\;a\oplus a=a.$  
(10)  $a\leq b\Longleftrightarrow a*b=a\Longleftrightarrow a\oplus b=b\,.$  
（11）$a\leq b$且$c\leq d\Rightarrow a*c\leq b*d$；$a\leq b$且${\mathfrak{c}}\leq d\Rightarrow a\oplus c\leq b\oplus d$.  
（12）偏序对运算的保序性：  $a\leq b\Rightarrow a*c\leq b*c;\;\;a\leq b\Rightarrow a\oplus c\leq b\oplus c$  
（13）确界运算对偏序的分配不等式：
$$
a\oplus(b*c)\leq(a\oplus b)*(a\oplus c);\,\,\,a*(b\oplus c)\geq(a*b)\oplus(a*(c)
$$  
（14） 确界运算对偏序的模不等式：$a\leq c\Longleftrightarrow a\oplus(b*c)\leq(a\oplus b)*c$  
格是一个特殊的代数系统，那么是否存在子格和格同态呢，答案是肯定的。设集合$𝑆$是集合$ L$的子集，从格的定义角度出发，格要求运算必须满足交换律、结合律和吸收律，如果这些运算律在集合$L$上满足，那么在$𝑆$上也一定满足，因此只要集合$𝐴$是非空的，且运算在$𝑆$上满足封闭性，那么$𝑆$就为$L$的子格。一般地，有如下的定义：  
【定义12.28】设代数系统$\langle L,*,\oplus\rangle$是一个格，对于$L$的任意一个非空子集$𝑆$，若运算$*$和$\oplus$在$𝑆$上的满足封闭性，则称$\langle S,*,\oplus\rangle$是$\langle L,*,\oplus\rangle$的一个子格，简称$𝑆$是$L$的子格。  
上面给出了代数格的子格定义，那么对于偏序格的子格又改如何定义呢。事实上若非空集合$\textstyle S\subseteq L$，且$\langle L,\leq\rangle$是偏序格，由第六章的偏序关系知道$\langle S,\leq\rangle$一定是偏序集，甚至也可能是格，但不一定是子格，因为子格要对运算封闭。由此得到如下偏序子格的定义：  
【定义12.29】设$\langle L,\leq\rangle$是一个格，$S\subseteq L$，若𝑆满足：  
（1）$S\neq\emptyset$；（2）对$\forall\;\;a,b\in S,\;\;<L,\leq\;>$的保交和保联运算都有： $a*b=G L B\{a,b\}\in S;\;\;a\oplus b=L U B\{a,b\}\in S$  
则称$\langle S,\leq\rangle$是$\langle L,\leq\rangle$的一个子格，简称$𝑆$是$L$的子格。  
利用代数系统中的同态和同构概念，分别可以得到格的同态和同构的定义：  
【定义12.30】设$\langle L,\land,\lor\rangle$和$\langle S,*,\oplus\rangle$是两个格， $f$是从$L$到$𝑆$的映射，若对$\forall\;\;x,y\in L$，有：  
$$
f(x\wedge y)=f(x)*f(y);\ f(x\vee y)=f(x)\oplus(y)
$$  
则称 $f$ 为从格 $\langle L,\land,\lor\rangle$ 到格 $\langle S,*,\oplus\rangle$ 的格同态映射，简称格同态。如果 $f$ 分别是单射、满射和双 射，$f$分别称为单格同态、满格同态和格同构，将格$ L$到$L$的同态称为$ L $的自同态。",偏序子格是格的子集，满足偏序关系和运算封闭性
格,映射,格同态,,"对偶性是格结构最基本的特征。考察格的基本性质一般从格结构的对偶特征入手。从偏序关系的角度看，格$\langle L,\leq\rangle$结构在集合 $L$上定义的偏序关系$\leq$显然是可逆的。具体地说，对于集合$ L$上的偏序关系≤，其逆关系$\geq$也是集合$ L$上的偏序关系。由于将偏序集$\langle L,\leq\rangle$的哈斯图做一个上下翻转就得到偏序集$\langle L,\geq\rangle$的哈斯图，故对集合$L$的任意子集$𝐴$，$A$在偏序$\langle L,\leq\rangle$中的上确界是$𝐴$在偏序$\langle L,\geq\rangle$中的下确界，$A$在$\langle L,\leq\rangle$中的下确界是$𝐴$在$\langle L,\geq\rangle$的上确界。因为二元关系的逆关系保持原关系的自反性、反对称性和传递性不变，所以$\langle L,\geq\rangle$也是格。  
通常将格$\langle L,\leq\rangle$和格$\langle L,\geq\rangle$称为互为对偶的格。对偶格之间具有紧密联系，例如格$\langle L,\leq\rangle$的保交运算对应格$\langle L,\geq\rangle$的保联运算，反之亦然。假如在格$\langle L,\leq\rangle$和格$\langle L,\geq\rangle$中，$*$和$\oplus$分别代表格的下确界和上确界运算，如果在关于$\langle L,\leq\rangle$的命题中，分别用$*$、⊕、$≤$代替关于$\langle L,\geq\rangle$命题中的⊕、$∗$、$≥$，那么两个命题的真伪必定保持一致性。这就是对偶原理。  
【定理12.33】设$\langle L,\leq\rangle$是任意给定的一个格，关系“$≤$”是“$\geq\!\!$的逆关系，则对$\forall$ $a,b,c,d\in$$L$，有如下14 条基本性质：  
（1）自反性：  $a\leq a;\ \ a\geq a.$  
（2）反对称性：$a\leq b$且$b\leq a\Rightarrow a=b$；$a\geq b$且$b\geq a\Rightarrow a=b$.  
（3）传递性  $a\leq b$且$b\leq c\Rightarrow a\leq c$；$a\geq b$且$b\geq c\Rightarrow a\geq c$.  $(4)a*b\leq a;\;\;a\oplus b\geq a;\;\;a*b\leq b;\;\;a\oplus b\geq b.$  
（5）$c\leq a$且$c\leq b\Rightarrow c\leq a*b$；$c\geq a$且$c\geq b\Rightarrow c\geq a\oplus b$.  
（6）交换律：  $a*b=b*a;\ a\oplus b=b\oplus a$  
（7）结合律：  $a*(b*c)=(a*b)*c;\;\;a\oplus(b\oplus c)=(a\oplus b)\oplus c$  
（8）吸收律：  $a*(a\oplus b)=a;\ a\oplus(a*b)=a.$  
（9）幂等律：  $a*a=a;\;\;a\oplus a=a.$  
(10)  $a\leq b\Longleftrightarrow a*b=a\Longleftrightarrow a\oplus b=b\,.$  
（11）$a\leq b$且$c\leq d\Rightarrow a*c\leq b*d$；$a\leq b$且${\mathfrak{c}}\leq d\Rightarrow a\oplus c\leq b\oplus d$.  
（12）偏序对运算的保序性：  $a\leq b\Rightarrow a*c\leq b*c;\;\;a\leq b\Rightarrow a\oplus c\leq b\oplus c$  
（13）确界运算对偏序的分配不等式：
$$
a\oplus(b*c)\leq(a\oplus b)*(a\oplus c);\,\,\,a*(b\oplus c)\geq(a*b)\oplus(a*(c)
$$  
（14） 确界运算对偏序的模不等式：$a\leq c\Longleftrightarrow a\oplus(b*c)\leq(a\oplus b)*c$  
格是一个特殊的代数系统，那么是否存在子格和格同态呢，答案是肯定的。设集合$𝑆$是集合$ L$的子集，从格的定义角度出发，格要求运算必须满足交换律、结合律和吸收律，如果这些运算律在集合$L$上满足，那么在$𝑆$上也一定满足，因此只要集合$𝐴$是非空的，且运算在$𝑆$上满足封闭性，那么$𝑆$就为$L$的子格。一般地，有如下的定义：  
【定义12.28】设代数系统$\langle L,*,\oplus\rangle$是一个格，对于$L$的任意一个非空子集$𝑆$，若运算$*$和$\oplus$在$𝑆$上的满足封闭性，则称$\langle S,*,\oplus\rangle$是$\langle L,*,\oplus\rangle$的一个子格，简称$𝑆$是$L$的子格。  
上面给出了代数格的子格定义，那么对于偏序格的子格又改如何定义呢。事实上若非空集合$\textstyle S\subseteq L$，且$\langle L,\leq\rangle$是偏序格，由第六章的偏序关系知道$\langle S,\leq\rangle$一定是偏序集，甚至也可能是格，但不一定是子格，因为子格要对运算封闭。由此得到如下偏序子格的定义：  
【定义12.29】设$\langle L,\leq\rangle$是一个格，$S\subseteq L$，若𝑆满足：  
（1）$S\neq\emptyset$；（2）对$\forall\;\;a,b\in S,\;\;<L,\leq\;>$的保交和保联运算都有： $a*b=G L B\{a,b\}\in S;\;\;a\oplus b=L U B\{a,b\}\in S$  
则称$\langle S,\leq\rangle$是$\langle L,\leq\rangle$的一个子格，简称$𝑆$是$L$的子格。  
利用代数系统中的同态和同构概念，分别可以得到格的同态和同构的定义：  
【定义12.30】设$\langle L,\land,\lor\rangle$和$\langle S,*,\oplus\rangle$是两个格， $f$是从$L$到$𝑆$的映射，若对$\forall\;\;x,y\in L$，有：  
$$
f(x\wedge y)=f(x)*f(y);\ f(x\vee y)=f(x)\oplus(y)
$$  
则称 $f$ 为从格 $\langle L,\land,\lor\rangle$ 到格 $\langle S,*,\oplus\rangle$ 的格同态映射，简称格同态。如果 $f$ 分别是单射、满射和双 射，$f$分别称为单格同态、满格同态和格同构，将格$ L$到$L$的同态称为$ L $的自同态。",格同态是格之间的映射，保持运算结构不变
格,应用,对偶原理,,"对偶性是格结构最基本的特征。考察格的基本性质一般从格结构的对偶特征入手。从偏序关系的角度看，格$\langle L,\leq\rangle$结构在集合 $L$上定义的偏序关系$\leq$显然是可逆的。具体地说，对于集合$ L$上的偏序关系≤，其逆关系$\geq$也是集合$ L$上的偏序关系。由于将偏序集$\langle L,\leq\rangle$的哈斯图做一个上下翻转就得到偏序集$\langle L,\geq\rangle$的哈斯图，故对集合$L$的任意子集$𝐴$，$A$在偏序$\langle L,\leq\rangle$中的上确界是$𝐴$在偏序$\langle L,\geq\rangle$中的下确界，$A$在$\langle L,\leq\rangle$中的下确界是$𝐴$在$\langle L,\geq\rangle$的上确界。因为二元关系的逆关系保持原关系的自反性、反对称性和传递性不变，所以$\langle L,\geq\rangle$也是格。  
通常将格$\langle L,\leq\rangle$和格$\langle L,\geq\rangle$称为互为对偶的格。对偶格之间具有紧密联系，例如格$\langle L,\leq\rangle$的保交运算对应格$\langle L,\geq\rangle$的保联运算，反之亦然。假如在格$\langle L,\leq\rangle$和格$\langle L,\geq\rangle$中，$*$和$\oplus$分别代表格的下确界和上确界运算，如果在关于$\langle L,\leq\rangle$的命题中，分别用$*$、⊕、$≤$代替关于$\langle L,\geq\rangle$命题中的⊕、$∗$、$≥$，那么两个命题的真伪必定保持一致性。这就是对偶原理。  
【定理12.33】设$\langle L,\leq\rangle$是任意给定的一个格，关系“$≤$”是“$\geq\!\!$的逆关系，则对$\forall$ $a,b,c,d\in$$L$，有如下14 条基本性质：  
（1）自反性：  $a\leq a;\ \ a\geq a.$  
（2）反对称性：$a\leq b$且$b\leq a\Rightarrow a=b$；$a\geq b$且$b\geq a\Rightarrow a=b$.  
（3）传递性  $a\leq b$且$b\leq c\Rightarrow a\leq c$；$a\geq b$且$b\geq c\Rightarrow a\geq c$.  $(4)a*b\leq a;\;\;a\oplus b\geq a;\;\;a*b\leq b;\;\;a\oplus b\geq b.$  
（5）$c\leq a$且$c\leq b\Rightarrow c\leq a*b$；$c\geq a$且$c\geq b\Rightarrow c\geq a\oplus b$.  
（6）交换律：  $a*b=b*a;\ a\oplus b=b\oplus a$  
（7）结合律：  $a*(b*c)=(a*b)*c;\;\;a\oplus(b\oplus c)=(a\oplus b)\oplus c$  
（8）吸收律：  $a*(a\oplus b)=a;\ a\oplus(a*b)=a.$  
（9）幂等律：  $a*a=a;\;\;a\oplus a=a.$  
(10)  $a\leq b\Longleftrightarrow a*b=a\Longleftrightarrow a\oplus b=b\,.$  
（11）$a\leq b$且$c\leq d\Rightarrow a*c\leq b*d$；$a\leq b$且${\mathfrak{c}}\leq d\Rightarrow a\oplus c\leq b\oplus d$.  
（12）偏序对运算的保序性：  $a\leq b\Rightarrow a*c\leq b*c;\;\;a\leq b\Rightarrow a\oplus c\leq b\oplus c$  
（13）确界运算对偏序的分配不等式：
$$
a\oplus(b*c)\leq(a\oplus b)*(a\oplus c);\,\,\,a*(b\oplus c)\geq(a*b)\oplus(a*(c)
$$  
（14） 确界运算对偏序的模不等式：$a\leq c\Longleftrightarrow a\oplus(b*c)\leq(a\oplus b)*c$  
格是一个特殊的代数系统，那么是否存在子格和格同态呢，答案是肯定的。设集合$𝑆$是集合$ L$的子集，从格的定义角度出发，格要求运算必须满足交换律、结合律和吸收律，如果这些运算律在集合$L$上满足，那么在$𝑆$上也一定满足，因此只要集合$𝐴$是非空的，且运算在$𝑆$上满足封闭性，那么$𝑆$就为$L$的子格。一般地，有如下的定义：  
【定义12.28】设代数系统$\langle L,*,\oplus\rangle$是一个格，对于$L$的任意一个非空子集$𝑆$，若运算$*$和$\oplus$在$𝑆$上的满足封闭性，则称$\langle S,*,\oplus\rangle$是$\langle L,*,\oplus\rangle$的一个子格，简称$𝑆$是$L$的子格。  
上面给出了代数格的子格定义，那么对于偏序格的子格又改如何定义呢。事实上若非空集合$\textstyle S\subseteq L$，且$\langle L,\leq\rangle$是偏序格，由第六章的偏序关系知道$\langle S,\leq\rangle$一定是偏序集，甚至也可能是格，但不一定是子格，因为子格要对运算封闭。由此得到如下偏序子格的定义：  
【定义12.29】设$\langle L,\leq\rangle$是一个格，$S\subseteq L$，若𝑆满足：  
（1）$S\neq\emptyset$；（2）对$\forall\;\;a,b\in S,\;\;<L,\leq\;>$的保交和保联运算都有： $a*b=G L B\{a,b\}\in S;\;\;a\oplus b=L U B\{a,b\}\in S$  
则称$\langle S,\leq\rangle$是$\langle L,\leq\rangle$的一个子格，简称$𝑆$是$L$的子格。  
利用代数系统中的同态和同构概念，分别可以得到格的同态和同构的定义：  
【定义12.30】设$\langle L,\land,\lor\rangle$和$\langle S,*,\oplus\rangle$是两个格， $f$是从$L$到$𝑆$的映射，若对$\forall\;\;x,y\in L$，有：  
$$
f(x\wedge y)=f(x)*f(y);\ f(x\vee y)=f(x)\oplus(y)
$$  
则称 $f$ 为从格 $\langle L,\land,\lor\rangle$ 到格 $\langle S,*,\oplus\rangle$ 的格同态映射，简称格同态。如果 $f$ 分别是单射、满射和双 射，$f$分别称为单格同态、满格同态和格同构，将格$ L$到$L$的同态称为$ L $的自同态。",对偶原理应用于格，表明对偶格的命题真伪一致性
子格,关联,偏序子格,,"对偶性是格结构最基本的特征。考察格的基本性质一般从格结构的对偶特征入手。从偏序关系的角度看，格$\langle L,\leq\rangle$结构在集合 $L$上定义的偏序关系$\leq$显然是可逆的。具体地说，对于集合$ L$上的偏序关系≤，其逆关系$\geq$也是集合$ L$上的偏序关系。由于将偏序集$\langle L,\leq\rangle$的哈斯图做一个上下翻转就得到偏序集$\langle L,\geq\rangle$的哈斯图，故对集合$L$的任意子集$𝐴$，$A$在偏序$\langle L,\leq\rangle$中的上确界是$𝐴$在偏序$\langle L,\geq\rangle$中的下确界，$A$在$\langle L,\leq\rangle$中的下确界是$𝐴$在$\langle L,\geq\rangle$的上确界。因为二元关系的逆关系保持原关系的自反性、反对称性和传递性不变，所以$\langle L,\geq\rangle$也是格。  
通常将格$\langle L,\leq\rangle$和格$\langle L,\geq\rangle$称为互为对偶的格。对偶格之间具有紧密联系，例如格$\langle L,\leq\rangle$的保交运算对应格$\langle L,\geq\rangle$的保联运算，反之亦然。假如在格$\langle L,\leq\rangle$和格$\langle L,\geq\rangle$中，$*$和$\oplus$分别代表格的下确界和上确界运算，如果在关于$\langle L,\leq\rangle$的命题中，分别用$*$、⊕、$≤$代替关于$\langle L,\geq\rangle$命题中的⊕、$∗$、$≥$，那么两个命题的真伪必定保持一致性。这就是对偶原理。  
【定理12.33】设$\langle L,\leq\rangle$是任意给定的一个格，关系“$≤$”是“$\geq\!\!$的逆关系，则对$\forall$ $a,b,c,d\in$$L$，有如下14 条基本性质：  
（1）自反性：  $a\leq a;\ \ a\geq a.$  
（2）反对称性：$a\leq b$且$b\leq a\Rightarrow a=b$；$a\geq b$且$b\geq a\Rightarrow a=b$.  
（3）传递性  $a\leq b$且$b\leq c\Rightarrow a\leq c$；$a\geq b$且$b\geq c\Rightarrow a\geq c$.  $(4)a*b\leq a;\;\;a\oplus b\geq a;\;\;a*b\leq b;\;\;a\oplus b\geq b.$  
（5）$c\leq a$且$c\leq b\Rightarrow c\leq a*b$；$c\geq a$且$c\geq b\Rightarrow c\geq a\oplus b$.  
（6）交换律：  $a*b=b*a;\ a\oplus b=b\oplus a$  
（7）结合律：  $a*(b*c)=(a*b)*c;\;\;a\oplus(b\oplus c)=(a\oplus b)\oplus c$  
（8）吸收律：  $a*(a\oplus b)=a;\ a\oplus(a*b)=a.$  
（9）幂等律：  $a*a=a;\;\;a\oplus a=a.$  
(10)  $a\leq b\Longleftrightarrow a*b=a\Longleftrightarrow a\oplus b=b\,.$  
（11）$a\leq b$且$c\leq d\Rightarrow a*c\leq b*d$；$a\leq b$且${\mathfrak{c}}\leq d\Rightarrow a\oplus c\leq b\oplus d$.  
（12）偏序对运算的保序性：  $a\leq b\Rightarrow a*c\leq b*c;\;\;a\leq b\Rightarrow a\oplus c\leq b\oplus c$  
（13）确界运算对偏序的分配不等式：
$$
a\oplus(b*c)\leq(a\oplus b)*(a\oplus c);\,\,\,a*(b\oplus c)\geq(a*b)\oplus(a*(c)
$$  
（14） 确界运算对偏序的模不等式：$a\leq c\Longleftrightarrow a\oplus(b*c)\leq(a\oplus b)*c$  
格是一个特殊的代数系统，那么是否存在子格和格同态呢，答案是肯定的。设集合$𝑆$是集合$ L$的子集，从格的定义角度出发，格要求运算必须满足交换律、结合律和吸收律，如果这些运算律在集合$L$上满足，那么在$𝑆$上也一定满足，因此只要集合$𝐴$是非空的，且运算在$𝑆$上满足封闭性，那么$𝑆$就为$L$的子格。一般地，有如下的定义：  
【定义12.28】设代数系统$\langle L,*,\oplus\rangle$是一个格，对于$L$的任意一个非空子集$𝑆$，若运算$*$和$\oplus$在$𝑆$上的满足封闭性，则称$\langle S,*,\oplus\rangle$是$\langle L,*,\oplus\rangle$的一个子格，简称$𝑆$是$L$的子格。  
上面给出了代数格的子格定义，那么对于偏序格的子格又改如何定义呢。事实上若非空集合$\textstyle S\subseteq L$，且$\langle L,\leq\rangle$是偏序格，由第六章的偏序关系知道$\langle S,\leq\rangle$一定是偏序集，甚至也可能是格，但不一定是子格，因为子格要对运算封闭。由此得到如下偏序子格的定义：  
【定义12.29】设$\langle L,\leq\rangle$是一个格，$S\subseteq L$，若𝑆满足：  
（1）$S\neq\emptyset$；（2）对$\forall\;\;a,b\in S,\;\;<L,\leq\;>$的保交和保联运算都有： $a*b=G L B\{a,b\}\in S;\;\;a\oplus b=L U B\{a,b\}\in S$  
则称$\langle S,\leq\rangle$是$\langle L,\leq\rangle$的一个子格，简称$𝑆$是$L$的子格。  
利用代数系统中的同态和同构概念，分别可以得到格的同态和同构的定义：  
【定义12.30】设$\langle L,\land,\lor\rangle$和$\langle S,*,\oplus\rangle$是两个格， $f$是从$L$到$𝑆$的映射，若对$\forall\;\;x,y\in L$，有：  
$$
f(x\wedge y)=f(x)*f(y);\ f(x\vee y)=f(x)\oplus(y)
$$  
则称 $f$ 为从格 $\langle L,\land,\lor\rangle$ 到格 $\langle S,*,\oplus\rangle$ 的格同态映射，简称格同态。如果 $f$ 分别是单射、满射和双 射，$f$分别称为单格同态、满格同态和格同构，将格$ L$到$L$的同态称为$ L $的自同态。",偏序子格是子格在偏序关系下的特例
格同态,相关,对偶原理,,"对偶性是格结构最基本的特征。考察格的基本性质一般从格结构的对偶特征入手。从偏序关系的角度看，格$\langle L,\leq\rangle$结构在集合 $L$上定义的偏序关系$\leq$显然是可逆的。具体地说，对于集合$ L$上的偏序关系≤，其逆关系$\geq$也是集合$ L$上的偏序关系。由于将偏序集$\langle L,\leq\rangle$的哈斯图做一个上下翻转就得到偏序集$\langle L,\geq\rangle$的哈斯图，故对集合$L$的任意子集$𝐴$，$A$在偏序$\langle L,\leq\rangle$中的上确界是$𝐴$在偏序$\langle L,\geq\rangle$中的下确界，$A$在$\langle L,\leq\rangle$中的下确界是$𝐴$在$\langle L,\geq\rangle$的上确界。因为二元关系的逆关系保持原关系的自反性、反对称性和传递性不变，所以$\langle L,\geq\rangle$也是格。  
通常将格$\langle L,\leq\rangle$和格$\langle L,\geq\rangle$称为互为对偶的格。对偶格之间具有紧密联系，例如格$\langle L,\leq\rangle$的保交运算对应格$\langle L,\geq\rangle$的保联运算，反之亦然。假如在格$\langle L,\leq\rangle$和格$\langle L,\geq\rangle$中，$*$和$\oplus$分别代表格的下确界和上确界运算，如果在关于$\langle L,\leq\rangle$的命题中，分别用$*$、⊕、$≤$代替关于$\langle L,\geq\rangle$命题中的⊕、$∗$、$≥$，那么两个命题的真伪必定保持一致性。这就是对偶原理。  
【定理12.33】设$\langle L,\leq\rangle$是任意给定的一个格，关系“$≤$”是“$\geq\!\!$的逆关系，则对$\forall$ $a,b,c,d\in$$L$，有如下14 条基本性质：  
（1）自反性：  $a\leq a;\ \ a\geq a.$  
（2）反对称性：$a\leq b$且$b\leq a\Rightarrow a=b$；$a\geq b$且$b\geq a\Rightarrow a=b$.  
（3）传递性  $a\leq b$且$b\leq c\Rightarrow a\leq c$；$a\geq b$且$b\geq c\Rightarrow a\geq c$.  $(4)a*b\leq a;\;\;a\oplus b\geq a;\;\;a*b\leq b;\;\;a\oplus b\geq b.$  
（5）$c\leq a$且$c\leq b\Rightarrow c\leq a*b$；$c\geq a$且$c\geq b\Rightarrow c\geq a\oplus b$.  
（6）交换律：  $a*b=b*a;\ a\oplus b=b\oplus a$  
（7）结合律：  $a*(b*c)=(a*b)*c;\;\;a\oplus(b\oplus c)=(a\oplus b)\oplus c$  
（8）吸收律：  $a*(a\oplus b)=a;\ a\oplus(a*b)=a.$  
（9）幂等律：  $a*a=a;\;\;a\oplus a=a.$  
(10)  $a\leq b\Longleftrightarrow a*b=a\Longleftrightarrow a\oplus b=b\,.$  
（11）$a\leq b$且$c\leq d\Rightarrow a*c\leq b*d$；$a\leq b$且${\mathfrak{c}}\leq d\Rightarrow a\oplus c\leq b\oplus d$.  
（12）偏序对运算的保序性：  $a\leq b\Rightarrow a*c\leq b*c;\;\;a\leq b\Rightarrow a\oplus c\leq b\oplus c$  
（13）确界运算对偏序的分配不等式：
$$
a\oplus(b*c)\leq(a\oplus b)*(a\oplus c);\,\,\,a*(b\oplus c)\geq(a*b)\oplus(a*(c)
$$  
（14） 确界运算对偏序的模不等式：$a\leq c\Longleftrightarrow a\oplus(b*c)\leq(a\oplus b)*c$  
格是一个特殊的代数系统，那么是否存在子格和格同态呢，答案是肯定的。设集合$𝑆$是集合$ L$的子集，从格的定义角度出发，格要求运算必须满足交换律、结合律和吸收律，如果这些运算律在集合$L$上满足，那么在$𝑆$上也一定满足，因此只要集合$𝐴$是非空的，且运算在$𝑆$上满足封闭性，那么$𝑆$就为$L$的子格。一般地，有如下的定义：  
【定义12.28】设代数系统$\langle L,*,\oplus\rangle$是一个格，对于$L$的任意一个非空子集$𝑆$，若运算$*$和$\oplus$在$𝑆$上的满足封闭性，则称$\langle S,*,\oplus\rangle$是$\langle L,*,\oplus\rangle$的一个子格，简称$𝑆$是$L$的子格。  
上面给出了代数格的子格定义，那么对于偏序格的子格又改如何定义呢。事实上若非空集合$\textstyle S\subseteq L$，且$\langle L,\leq\rangle$是偏序格，由第六章的偏序关系知道$\langle S,\leq\rangle$一定是偏序集，甚至也可能是格，但不一定是子格，因为子格要对运算封闭。由此得到如下偏序子格的定义：  
【定义12.29】设$\langle L,\leq\rangle$是一个格，$S\subseteq L$，若𝑆满足：  
（1）$S\neq\emptyset$；（2）对$\forall\;\;a,b\in S,\;\;<L,\leq\;>$的保交和保联运算都有： $a*b=G L B\{a,b\}\in S;\;\;a\oplus b=L U B\{a,b\}\in S$  
则称$\langle S,\leq\rangle$是$\langle L,\leq\rangle$的一个子格，简称$𝑆$是$L$的子格。  
利用代数系统中的同态和同构概念，分别可以得到格的同态和同构的定义：  
【定义12.30】设$\langle L,\land,\lor\rangle$和$\langle S,*,\oplus\rangle$是两个格， $f$是从$L$到$𝑆$的映射，若对$\forall\;\;x,y\in L$，有：  
$$
f(x\wedge y)=f(x)*f(y);\ f(x\vee y)=f(x)\oplus(y)
$$  
则称 $f$ 为从格 $\langle L,\land,\lor\rangle$ 到格 $\langle S,*,\oplus\rangle$ 的格同态映射，简称格同态。如果 $f$ 分别是单射、满射和双 射，$f$分别称为单格同态、满格同态和格同构，将格$ L$到$L$的同态称为$ L $的自同态。",格同态和对偶原理共同描述格的结构和性质
格,特殊化,分配格,,"以上从偏序和代数这两个角度考察了格结构的基本概念和基本性质。如果对一般格结构赋予一些新的特征或约束条件，则可进一步得到相应的特殊格。本小节主要讨论若干重要的特殊格，主要包括分配格、有界格和有补格。  
一、分配格  
我们知道格结构的代数运算满足交换律、结合律和吸收律，但并没有要求其满足分配律。事实上，对于一般的格结构只能满足确界运算对偏序的分配不等式，这是一个以不等式形式出现分配形式，这只是一个弱分配律运算性质，如果将该性质加强为以等式形式构成真正意义上的分配律，由此便可得到一种名为分配格的特殊格结构，其具体定义如下：  
【定义12.31】设$\langle L,*,\oplus\rangle$是一个格，如果对于$\forall\ \ a,b,c\in L$，都有： $a*(b\oplus c)=(a*b)\oplus(a*c);\,\,\,a\oplus(b*c)=(a\oplus b)*(a\oplus c)$  
即运算满足分配律，则称$\langle L,*,\oplus\rangle$是一个分配格。  
值得注意的是，以上定义中两个式子其实是对偶式。因此，如要证明一个格是分配格只需证明上式中的任意一个等式即可。  
【定理12.34】设$\langle L,\leq\rangle$是任意给定的一个格结构，则$\langle L,\leq\rangle$是分配格当且仅当$\langle L,\leq\rangle$中即不存在与钻石格同构的子格，也不存在与五角格同构的子格  
【定理12.35】任意一条链都是一个分配格。  
消去律在格中一般不成立，但在分配格中具有如下一种特殊的消去律：  
【定理12.36】设$\langle L,*,\oplus\rangle$是任意给定的一个分配格，则对$\forall$$a,b,c\in L$$，如果a*b=a*c且$$a\oplus b=a\oplus c$，那么有$b=c$。  
二、有界格  
我们知道，格结构是一个偏序结构，如果在该结构的载体集合中引入存在最大值和最小值的约束条件，则可得到有界格的概念，具体如下：  
【定义12.32】设$\langle L,\leq\rangle$是任一给定的格，若$L$中存在最小元和最大元，即$\exists a,b\in L$，对∀ $x\in L$，有$a\leq x$且$x\leq b$，则称$\langle L,\leq\rangle$为有界格，通常将其最大元记为1，最小值记为0。 例如，设$𝑆$是一个非空集合，则格$\langle S,{\subseteq}\rangle$是一个有界格，其最大元是$𝑆$，最小元是$\varnothing$。并不是所有的格都是有界格，例如是实数集上的是小于或等于关系构成的格$<R,\leq\;>$，显然不是有界格。根据最小元和最大元以及幺元和零元的定义，易知成立下列等式：  
$1*x=x*1=x;1\oplus x=x\oplus1=1;0*x=x*0=0;0\oplus x=x\oplus0=x$  
也就是说1 是$*$和⊕的幺元与零元，0 是⊕和$*$的幺元和零元。  
【定理12.37】对于任意一个有界格$\langle L,\leq\rangle$，其最大值和最小值是唯一的。  
三、有补格  
对于格$\langle P(A),\subseteq\rangle$或$\langle{ P}(A),\cap,\cup\rangle$来说，集合$𝐴$和空集$\varnothing$显然是$P(A)$的最大元和最小元。我们知道，可在$\langle{ P}(A),\cap,\cup\rangle$上定义集合的补运算，即对于$\forall B\in P(A)$，存在${\bar{B}}\in P(A)$，满足：  
$$
B\cup\bar{B}=\ A;\ B\cap\bar{B}=\ \varnothing\quad\text{(12.5.9)}
$$  
通常称集合$\bar{B}$是集合$ B$的补集，或者称集合$\bar{B}$与$B$具有互补关系。现将格结构$\langle{ P}(A),\cap,\cup\rangle$或$\langle P(A),\subseteq\rangle$上的补运算推广到一般的有界格中，得到如下有补格的概念：  
【定义12.33】设$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$是任意给定的一个有界格，则对$\forall a\in L$，如果存在$b\in$$L$，满足$a*b=0$ 且$a\oplus b=1$，则称$ b$是$a$的补元素，通常简称为补元，记作$\bar{a}$。如果有界格$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$中每个元素都存在其补元素，则称$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$为有补格。  
由格结构的交换律可知，如果$b$是$a$的补元，那么$a$也是$b$的补元，即$a$与$b$互为补元。易知，在有界格中， 0 的唯一补元是1，1 的唯一补元是0。但是，对于有界格中一般的元素，其补元不一定存在。因此，虽然有补格一定是有界格，但有界格不一定是有补格。  
另一方面，对于任个有补格，并不能保证其中每个元素的补元素是唯一确定的。例如，对于如图12-8 所示的有界格，易知$a$补元是$b$和$c$，$b$的补元是$a$和$c$，$c$的补元是$a$和$b$。  
![](images/15c8cb1c91d0343f4329e4fe28808131c9c2a9b35b96281ded4f82ad6ec628e1.jpg)  
有补格中元素补元的这种不唯一性容易造成对问题分析和求解的混淆。因此，必须对一般的有补格结构附加适当的约束条件，使其能够满足格中任意元素补元的唯一性。事实上，如果对有补格附加满足分配律的约束，这可保证其补元的唯一性，即有如下定理：  
【定理12.38】设$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$是一个有补格并且也是一个分配格，即是一个有补分配格，则$L$中任意元素的补元存在且唯一。  
从以上分析讨论可知：有补格仅保证了补元的普遍性，即格中任意一个元素都至少存在一个补元，但不能保证补元的唯一性；分配格则可以保证补元的唯一性但不能保证补元的普遍性；有补分配格同时吸收了有补格和分配格这两种特殊格的优点，能够同时保证补元的普遍性和唯一性。因此，有补分配格是一个具有优良性质的特殊格结构。事实上，有补分配格就是在计算机、电子信息、自动化等科学与工程中大量用到的布尔格或布尔代数。",分配格是满足分配律的特殊格结构
格,特殊化,有界格,,"以上从偏序和代数这两个角度考察了格结构的基本概念和基本性质。如果对一般格结构赋予一些新的特征或约束条件，则可进一步得到相应的特殊格。本小节主要讨论若干重要的特殊格，主要包括分配格、有界格和有补格。  
一、分配格  
我们知道格结构的代数运算满足交换律、结合律和吸收律，但并没有要求其满足分配律。事实上，对于一般的格结构只能满足确界运算对偏序的分配不等式，这是一个以不等式形式出现分配形式，这只是一个弱分配律运算性质，如果将该性质加强为以等式形式构成真正意义上的分配律，由此便可得到一种名为分配格的特殊格结构，其具体定义如下：  
【定义12.31】设$\langle L,*,\oplus\rangle$是一个格，如果对于$\forall\ \ a,b,c\in L$，都有： $a*(b\oplus c)=(a*b)\oplus(a*c);\,\,\,a\oplus(b*c)=(a\oplus b)*(a\oplus c)$  
即运算满足分配律，则称$\langle L,*,\oplus\rangle$是一个分配格。  
值得注意的是，以上定义中两个式子其实是对偶式。因此，如要证明一个格是分配格只需证明上式中的任意一个等式即可。  
【定理12.34】设$\langle L,\leq\rangle$是任意给定的一个格结构，则$\langle L,\leq\rangle$是分配格当且仅当$\langle L,\leq\rangle$中即不存在与钻石格同构的子格，也不存在与五角格同构的子格  
【定理12.35】任意一条链都是一个分配格。  
消去律在格中一般不成立，但在分配格中具有如下一种特殊的消去律：  
【定理12.36】设$\langle L,*,\oplus\rangle$是任意给定的一个分配格，则对$\forall$$a,b,c\in L$$，如果a*b=a*c且$$a\oplus b=a\oplus c$，那么有$b=c$。  
二、有界格  
我们知道，格结构是一个偏序结构，如果在该结构的载体集合中引入存在最大值和最小值的约束条件，则可得到有界格的概念，具体如下：  
【定义12.32】设$\langle L,\leq\rangle$是任一给定的格，若$L$中存在最小元和最大元，即$\exists a,b\in L$，对∀ $x\in L$，有$a\leq x$且$x\leq b$，则称$\langle L,\leq\rangle$为有界格，通常将其最大元记为1，最小值记为0。 例如，设$𝑆$是一个非空集合，则格$\langle S,{\subseteq}\rangle$是一个有界格，其最大元是$𝑆$，最小元是$\varnothing$。并不是所有的格都是有界格，例如是实数集上的是小于或等于关系构成的格$<R,\leq\;>$，显然不是有界格。根据最小元和最大元以及幺元和零元的定义，易知成立下列等式：  
$1*x=x*1=x;1\oplus x=x\oplus1=1;0*x=x*0=0;0\oplus x=x\oplus0=x$  
也就是说1 是$*$和⊕的幺元与零元，0 是⊕和$*$的幺元和零元。  
【定理12.37】对于任意一个有界格$\langle L,\leq\rangle$，其最大值和最小值是唯一的。  
三、有补格  
对于格$\langle P(A),\subseteq\rangle$或$\langle{ P}(A),\cap,\cup\rangle$来说，集合$𝐴$和空集$\varnothing$显然是$P(A)$的最大元和最小元。我们知道，可在$\langle{ P}(A),\cap,\cup\rangle$上定义集合的补运算，即对于$\forall B\in P(A)$，存在${\bar{B}}\in P(A)$，满足：  
$$
B\cup\bar{B}=\ A;\ B\cap\bar{B}=\ \varnothing\quad\text{(12.5.9)}
$$  
通常称集合$\bar{B}$是集合$ B$的补集，或者称集合$\bar{B}$与$B$具有互补关系。现将格结构$\langle{ P}(A),\cap,\cup\rangle$或$\langle P(A),\subseteq\rangle$上的补运算推广到一般的有界格中，得到如下有补格的概念：  
【定义12.33】设$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$是任意给定的一个有界格，则对$\forall a\in L$，如果存在$b\in$$L$，满足$a*b=0$ 且$a\oplus b=1$，则称$ b$是$a$的补元素，通常简称为补元，记作$\bar{a}$。如果有界格$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$中每个元素都存在其补元素，则称$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$为有补格。  
由格结构的交换律可知，如果$b$是$a$的补元，那么$a$也是$b$的补元，即$a$与$b$互为补元。易知，在有界格中， 0 的唯一补元是1，1 的唯一补元是0。但是，对于有界格中一般的元素，其补元不一定存在。因此，虽然有补格一定是有界格，但有界格不一定是有补格。  
另一方面，对于任个有补格，并不能保证其中每个元素的补元素是唯一确定的。例如，对于如图12-8 所示的有界格，易知$a$补元是$b$和$c$，$b$的补元是$a$和$c$，$c$的补元是$a$和$b$。  
![](images/15c8cb1c91d0343f4329e4fe28808131c9c2a9b35b96281ded4f82ad6ec628e1.jpg)  
有补格中元素补元的这种不唯一性容易造成对问题分析和求解的混淆。因此，必须对一般的有补格结构附加适当的约束条件，使其能够满足格中任意元素补元的唯一性。事实上，如果对有补格附加满足分配律的约束，这可保证其补元的唯一性，即有如下定理：  
【定理12.38】设$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$是一个有补格并且也是一个分配格，即是一个有补分配格，则$L$中任意元素的补元存在且唯一。  
从以上分析讨论可知：有补格仅保证了补元的普遍性，即格中任意一个元素都至少存在一个补元，但不能保证补元的唯一性；分配格则可以保证补元的唯一性但不能保证补元的普遍性；有补分配格同时吸收了有补格和分配格这两种特殊格的优点，能够同时保证补元的普遍性和唯一性。因此，有补分配格是一个具有优良性质的特殊格结构。事实上，有补分配格就是在计算机、电子信息、自动化等科学与工程中大量用到的布尔格或布尔代数。",有界格是存在最大值和最小值的特殊格结构
格,特殊化,有补格,,"以上从偏序和代数这两个角度考察了格结构的基本概念和基本性质。如果对一般格结构赋予一些新的特征或约束条件，则可进一步得到相应的特殊格。本小节主要讨论若干重要的特殊格，主要包括分配格、有界格和有补格。  
一、分配格  
我们知道格结构的代数运算满足交换律、结合律和吸收律，但并没有要求其满足分配律。事实上，对于一般的格结构只能满足确界运算对偏序的分配不等式，这是一个以不等式形式出现分配形式，这只是一个弱分配律运算性质，如果将该性质加强为以等式形式构成真正意义上的分配律，由此便可得到一种名为分配格的特殊格结构，其具体定义如下：  
【定义12.31】设$\langle L,*,\oplus\rangle$是一个格，如果对于$\forall\ \ a,b,c\in L$，都有： $a*(b\oplus c)=(a*b)\oplus(a*c);\,\,\,a\oplus(b*c)=(a\oplus b)*(a\oplus c)$  
即运算满足分配律，则称$\langle L,*,\oplus\rangle$是一个分配格。  
值得注意的是，以上定义中两个式子其实是对偶式。因此，如要证明一个格是分配格只需证明上式中的任意一个等式即可。  
【定理12.34】设$\langle L,\leq\rangle$是任意给定的一个格结构，则$\langle L,\leq\rangle$是分配格当且仅当$\langle L,\leq\rangle$中即不存在与钻石格同构的子格，也不存在与五角格同构的子格  
【定理12.35】任意一条链都是一个分配格。  
消去律在格中一般不成立，但在分配格中具有如下一种特殊的消去律：  
【定理12.36】设$\langle L,*,\oplus\rangle$是任意给定的一个分配格，则对$\forall$$a,b,c\in L$$，如果a*b=a*c且$$a\oplus b=a\oplus c$，那么有$b=c$。  
二、有界格  
我们知道，格结构是一个偏序结构，如果在该结构的载体集合中引入存在最大值和最小值的约束条件，则可得到有界格的概念，具体如下：  
【定义12.32】设$\langle L,\leq\rangle$是任一给定的格，若$L$中存在最小元和最大元，即$\exists a,b\in L$，对∀ $x\in L$，有$a\leq x$且$x\leq b$，则称$\langle L,\leq\rangle$为有界格，通常将其最大元记为1，最小值记为0。 例如，设$𝑆$是一个非空集合，则格$\langle S,{\subseteq}\rangle$是一个有界格，其最大元是$𝑆$，最小元是$\varnothing$。并不是所有的格都是有界格，例如是实数集上的是小于或等于关系构成的格$<R,\leq\;>$，显然不是有界格。根据最小元和最大元以及幺元和零元的定义，易知成立下列等式：  
$1*x=x*1=x;1\oplus x=x\oplus1=1;0*x=x*0=0;0\oplus x=x\oplus0=x$  
也就是说1 是$*$和⊕的幺元与零元，0 是⊕和$*$的幺元和零元。  
【定理12.37】对于任意一个有界格$\langle L,\leq\rangle$，其最大值和最小值是唯一的。  
三、有补格  
对于格$\langle P(A),\subseteq\rangle$或$\langle{ P}(A),\cap,\cup\rangle$来说，集合$𝐴$和空集$\varnothing$显然是$P(A)$的最大元和最小元。我们知道，可在$\langle{ P}(A),\cap,\cup\rangle$上定义集合的补运算，即对于$\forall B\in P(A)$，存在${\bar{B}}\in P(A)$，满足：  
$$
B\cup\bar{B}=\ A;\ B\cap\bar{B}=\ \varnothing\quad\text{(12.5.9)}
$$  
通常称集合$\bar{B}$是集合$ B$的补集，或者称集合$\bar{B}$与$B$具有互补关系。现将格结构$\langle{ P}(A),\cap,\cup\rangle$或$\langle P(A),\subseteq\rangle$上的补运算推广到一般的有界格中，得到如下有补格的概念：  
【定义12.33】设$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$是任意给定的一个有界格，则对$\forall a\in L$，如果存在$b\in$$L$，满足$a*b=0$ 且$a\oplus b=1$，则称$ b$是$a$的补元素，通常简称为补元，记作$\bar{a}$。如果有界格$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$中每个元素都存在其补元素，则称$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$为有补格。  
由格结构的交换律可知，如果$b$是$a$的补元，那么$a$也是$b$的补元，即$a$与$b$互为补元。易知，在有界格中， 0 的唯一补元是1，1 的唯一补元是0。但是，对于有界格中一般的元素，其补元不一定存在。因此，虽然有补格一定是有界格，但有界格不一定是有补格。  
另一方面，对于任个有补格，并不能保证其中每个元素的补元素是唯一确定的。例如，对于如图12-8 所示的有界格，易知$a$补元是$b$和$c$，$b$的补元是$a$和$c$，$c$的补元是$a$和$b$。  
![](images/15c8cb1c91d0343f4329e4fe28808131c9c2a9b35b96281ded4f82ad6ec628e1.jpg)  
有补格中元素补元的这种不唯一性容易造成对问题分析和求解的混淆。因此，必须对一般的有补格结构附加适当的约束条件，使其能够满足格中任意元素补元的唯一性。事实上，如果对有补格附加满足分配律的约束，这可保证其补元的唯一性，即有如下定理：  
【定理12.38】设$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$是一个有补格并且也是一个分配格，即是一个有补分配格，则$L$中任意元素的补元存在且唯一。  
从以上分析讨论可知：有补格仅保证了补元的普遍性，即格中任意一个元素都至少存在一个补元，但不能保证补元的唯一性；分配格则可以保证补元的唯一性但不能保证补元的普遍性；有补分配格同时吸收了有补格和分配格这两种特殊格的优点，能够同时保证补元的普遍性和唯一性。因此，有补分配格是一个具有优良性质的特殊格结构。事实上，有补分配格就是在计算机、电子信息、自动化等科学与工程中大量用到的布尔格或布尔代数。",有补格是每个元素都存在补元素的特殊格结构
分配格,组合,有补分配格,,"以上从偏序和代数这两个角度考察了格结构的基本概念和基本性质。如果对一般格结构赋予一些新的特征或约束条件，则可进一步得到相应的特殊格。本小节主要讨论若干重要的特殊格，主要包括分配格、有界格和有补格。  
一、分配格  
我们知道格结构的代数运算满足交换律、结合律和吸收律，但并没有要求其满足分配律。事实上，对于一般的格结构只能满足确界运算对偏序的分配不等式，这是一个以不等式形式出现分配形式，这只是一个弱分配律运算性质，如果将该性质加强为以等式形式构成真正意义上的分配律，由此便可得到一种名为分配格的特殊格结构，其具体定义如下：  
【定义12.31】设$\langle L,*,\oplus\rangle$是一个格，如果对于$\forall\ \ a,b,c\in L$，都有： $a*(b\oplus c)=(a*b)\oplus(a*c);\,\,\,a\oplus(b*c)=(a\oplus b)*(a\oplus c)$  
即运算满足分配律，则称$\langle L,*,\oplus\rangle$是一个分配格。  
值得注意的是，以上定义中两个式子其实是对偶式。因此，如要证明一个格是分配格只需证明上式中的任意一个等式即可。  
【定理12.34】设$\langle L,\leq\rangle$是任意给定的一个格结构，则$\langle L,\leq\rangle$是分配格当且仅当$\langle L,\leq\rangle$中即不存在与钻石格同构的子格，也不存在与五角格同构的子格  
【定理12.35】任意一条链都是一个分配格。  
消去律在格中一般不成立，但在分配格中具有如下一种特殊的消去律：  
【定理12.36】设$\langle L,*,\oplus\rangle$是任意给定的一个分配格，则对$\forall$$a,b,c\in L$$，如果a*b=a*c且$$a\oplus b=a\oplus c$，那么有$b=c$。  
二、有界格  
我们知道，格结构是一个偏序结构，如果在该结构的载体集合中引入存在最大值和最小值的约束条件，则可得到有界格的概念，具体如下：  
【定义12.32】设$\langle L,\leq\rangle$是任一给定的格，若$L$中存在最小元和最大元，即$\exists a,b\in L$，对∀ $x\in L$，有$a\leq x$且$x\leq b$，则称$\langle L,\leq\rangle$为有界格，通常将其最大元记为1，最小值记为0。 例如，设$𝑆$是一个非空集合，则格$\langle S,{\subseteq}\rangle$是一个有界格，其最大元是$𝑆$，最小元是$\varnothing$。并不是所有的格都是有界格，例如是实数集上的是小于或等于关系构成的格$<R,\leq\;>$，显然不是有界格。根据最小元和最大元以及幺元和零元的定义，易知成立下列等式：  
$1*x=x*1=x;1\oplus x=x\oplus1=1;0*x=x*0=0;0\oplus x=x\oplus0=x$  
也就是说1 是$*$和⊕的幺元与零元，0 是⊕和$*$的幺元和零元。  
【定理12.37】对于任意一个有界格$\langle L,\leq\rangle$，其最大值和最小值是唯一的。  
三、有补格  
对于格$\langle P(A),\subseteq\rangle$或$\langle{ P}(A),\cap,\cup\rangle$来说，集合$𝐴$和空集$\varnothing$显然是$P(A)$的最大元和最小元。我们知道，可在$\langle{ P}(A),\cap,\cup\rangle$上定义集合的补运算，即对于$\forall B\in P(A)$，存在${\bar{B}}\in P(A)$，满足：  
$$
B\cup\bar{B}=\ A;\ B\cap\bar{B}=\ \varnothing\quad\text{(12.5.9)}
$$  
通常称集合$\bar{B}$是集合$ B$的补集，或者称集合$\bar{B}$与$B$具有互补关系。现将格结构$\langle{ P}(A),\cap,\cup\rangle$或$\langle P(A),\subseteq\rangle$上的补运算推广到一般的有界格中，得到如下有补格的概念：  
【定义12.33】设$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$是任意给定的一个有界格，则对$\forall a\in L$，如果存在$b\in$$L$，满足$a*b=0$ 且$a\oplus b=1$，则称$ b$是$a$的补元素，通常简称为补元，记作$\bar{a}$。如果有界格$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$中每个元素都存在其补元素，则称$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$为有补格。  
由格结构的交换律可知，如果$b$是$a$的补元，那么$a$也是$b$的补元，即$a$与$b$互为补元。易知，在有界格中， 0 的唯一补元是1，1 的唯一补元是0。但是，对于有界格中一般的元素，其补元不一定存在。因此，虽然有补格一定是有界格，但有界格不一定是有补格。  
另一方面，对于任个有补格，并不能保证其中每个元素的补元素是唯一确定的。例如，对于如图12-8 所示的有界格，易知$a$补元是$b$和$c$，$b$的补元是$a$和$c$，$c$的补元是$a$和$b$。  
![](images/15c8cb1c91d0343f4329e4fe28808131c9c2a9b35b96281ded4f82ad6ec628e1.jpg)  
有补格中元素补元的这种不唯一性容易造成对问题分析和求解的混淆。因此，必须对一般的有补格结构附加适当的约束条件，使其能够满足格中任意元素补元的唯一性。事实上，如果对有补格附加满足分配律的约束，这可保证其补元的唯一性，即有如下定理：  
【定理12.38】设$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$是一个有补格并且也是一个分配格，即是一个有补分配格，则$L$中任意元素的补元存在且唯一。  
从以上分析讨论可知：有补格仅保证了补元的普遍性，即格中任意一个元素都至少存在一个补元，但不能保证补元的唯一性；分配格则可以保证补元的唯一性但不能保证补元的普遍性；有补分配格同时吸收了有补格和分配格这两种特殊格的优点，能够同时保证补元的普遍性和唯一性。因此，有补分配格是一个具有优良性质的特殊格结构。事实上，有补分配格就是在计算机、电子信息、自动化等科学与工程中大量用到的布尔格或布尔代数。",有补分配格同时满足分配律和补元存在的特殊格结构
有界格,包含,有补格,,"以上从偏序和代数这两个角度考察了格结构的基本概念和基本性质。如果对一般格结构赋予一些新的特征或约束条件，则可进一步得到相应的特殊格。本小节主要讨论若干重要的特殊格，主要包括分配格、有界格和有补格。  
一、分配格  
我们知道格结构的代数运算满足交换律、结合律和吸收律，但并没有要求其满足分配律。事实上，对于一般的格结构只能满足确界运算对偏序的分配不等式，这是一个以不等式形式出现分配形式，这只是一个弱分配律运算性质，如果将该性质加强为以等式形式构成真正意义上的分配律，由此便可得到一种名为分配格的特殊格结构，其具体定义如下：  
【定义12.31】设$\langle L,*,\oplus\rangle$是一个格，如果对于$\forall\ \ a,b,c\in L$，都有： $a*(b\oplus c)=(a*b)\oplus(a*c);\,\,\,a\oplus(b*c)=(a\oplus b)*(a\oplus c)$  
即运算满足分配律，则称$\langle L,*,\oplus\rangle$是一个分配格。  
值得注意的是，以上定义中两个式子其实是对偶式。因此，如要证明一个格是分配格只需证明上式中的任意一个等式即可。  
【定理12.34】设$\langle L,\leq\rangle$是任意给定的一个格结构，则$\langle L,\leq\rangle$是分配格当且仅当$\langle L,\leq\rangle$中即不存在与钻石格同构的子格，也不存在与五角格同构的子格  
【定理12.35】任意一条链都是一个分配格。  
消去律在格中一般不成立，但在分配格中具有如下一种特殊的消去律：  
【定理12.36】设$\langle L,*,\oplus\rangle$是任意给定的一个分配格，则对$\forall$$a,b,c\in L$$，如果a*b=a*c且$$a\oplus b=a\oplus c$，那么有$b=c$。  
二、有界格  
我们知道，格结构是一个偏序结构，如果在该结构的载体集合中引入存在最大值和最小值的约束条件，则可得到有界格的概念，具体如下：  
【定义12.32】设$\langle L,\leq\rangle$是任一给定的格，若$L$中存在最小元和最大元，即$\exists a,b\in L$，对∀ $x\in L$，有$a\leq x$且$x\leq b$，则称$\langle L,\leq\rangle$为有界格，通常将其最大元记为1，最小值记为0。 例如，设$𝑆$是一个非空集合，则格$\langle S,{\subseteq}\rangle$是一个有界格，其最大元是$𝑆$，最小元是$\varnothing$。并不是所有的格都是有界格，例如是实数集上的是小于或等于关系构成的格$<R,\leq\;>$，显然不是有界格。根据最小元和最大元以及幺元和零元的定义，易知成立下列等式：  
$1*x=x*1=x;1\oplus x=x\oplus1=1;0*x=x*0=0;0\oplus x=x\oplus0=x$  
也就是说1 是$*$和⊕的幺元与零元，0 是⊕和$*$的幺元和零元。  
【定理12.37】对于任意一个有界格$\langle L,\leq\rangle$，其最大值和最小值是唯一的。  
三、有补格  
对于格$\langle P(A),\subseteq\rangle$或$\langle{ P}(A),\cap,\cup\rangle$来说，集合$𝐴$和空集$\varnothing$显然是$P(A)$的最大元和最小元。我们知道，可在$\langle{ P}(A),\cap,\cup\rangle$上定义集合的补运算，即对于$\forall B\in P(A)$，存在${\bar{B}}\in P(A)$，满足：  
$$
B\cup\bar{B}=\ A;\ B\cap\bar{B}=\ \varnothing\quad\text{(12.5.9)}
$$  
通常称集合$\bar{B}$是集合$ B$的补集，或者称集合$\bar{B}$与$B$具有互补关系。现将格结构$\langle{ P}(A),\cap,\cup\rangle$或$\langle P(A),\subseteq\rangle$上的补运算推广到一般的有界格中，得到如下有补格的概念：  
【定义12.33】设$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$是任意给定的一个有界格，则对$\forall a\in L$，如果存在$b\in$$L$，满足$a*b=0$ 且$a\oplus b=1$，则称$ b$是$a$的补元素，通常简称为补元，记作$\bar{a}$。如果有界格$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$中每个元素都存在其补元素，则称$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$为有补格。  
由格结构的交换律可知，如果$b$是$a$的补元，那么$a$也是$b$的补元，即$a$与$b$互为补元。易知，在有界格中， 0 的唯一补元是1，1 的唯一补元是0。但是，对于有界格中一般的元素，其补元不一定存在。因此，虽然有补格一定是有界格，但有界格不一定是有补格。  
另一方面，对于任个有补格，并不能保证其中每个元素的补元素是唯一确定的。例如，对于如图12-8 所示的有界格，易知$a$补元是$b$和$c$，$b$的补元是$a$和$c$，$c$的补元是$a$和$b$。  
![](images/15c8cb1c91d0343f4329e4fe28808131c9c2a9b35b96281ded4f82ad6ec628e1.jpg)  
有补格中元素补元的这种不唯一性容易造成对问题分析和求解的混淆。因此，必须对一般的有补格结构附加适当的约束条件，使其能够满足格中任意元素补元的唯一性。事实上，如果对有补格附加满足分配律的约束，这可保证其补元的唯一性，即有如下定理：  
【定理12.38】设$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$是一个有补格并且也是一个分配格，即是一个有补分配格，则$L$中任意元素的补元存在且唯一。  
从以上分析讨论可知：有补格仅保证了补元的普遍性，即格中任意一个元素都至少存在一个补元，但不能保证补元的唯一性；分配格则可以保证补元的唯一性但不能保证补元的普遍性；有补分配格同时吸收了有补格和分配格这两种特殊格的优点，能够同时保证补元的普遍性和唯一性。因此，有补分配格是一个具有优良性质的特殊格结构。事实上，有补分配格就是在计算机、电子信息、自动化等科学与工程中大量用到的布尔格或布尔代数。",有补格一定是有界格，但有界格不一定是有补格
有补格,组合,有补分配格,,"以上从偏序和代数这两个角度考察了格结构的基本概念和基本性质。如果对一般格结构赋予一些新的特征或约束条件，则可进一步得到相应的特殊格。本小节主要讨论若干重要的特殊格，主要包括分配格、有界格和有补格。  
一、分配格  
我们知道格结构的代数运算满足交换律、结合律和吸收律，但并没有要求其满足分配律。事实上，对于一般的格结构只能满足确界运算对偏序的分配不等式，这是一个以不等式形式出现分配形式，这只是一个弱分配律运算性质，如果将该性质加强为以等式形式构成真正意义上的分配律，由此便可得到一种名为分配格的特殊格结构，其具体定义如下：  
【定义12.31】设$\langle L,*,\oplus\rangle$是一个格，如果对于$\forall\ \ a,b,c\in L$，都有： $a*(b\oplus c)=(a*b)\oplus(a*c);\,\,\,a\oplus(b*c)=(a\oplus b)*(a\oplus c)$  
即运算满足分配律，则称$\langle L,*,\oplus\rangle$是一个分配格。  
值得注意的是，以上定义中两个式子其实是对偶式。因此，如要证明一个格是分配格只需证明上式中的任意一个等式即可。  
【定理12.34】设$\langle L,\leq\rangle$是任意给定的一个格结构，则$\langle L,\leq\rangle$是分配格当且仅当$\langle L,\leq\rangle$中即不存在与钻石格同构的子格，也不存在与五角格同构的子格  
【定理12.35】任意一条链都是一个分配格。  
消去律在格中一般不成立，但在分配格中具有如下一种特殊的消去律：  
【定理12.36】设$\langle L,*,\oplus\rangle$是任意给定的一个分配格，则对$\forall$$a,b,c\in L$$，如果a*b=a*c且$$a\oplus b=a\oplus c$，那么有$b=c$。  
二、有界格  
我们知道，格结构是一个偏序结构，如果在该结构的载体集合中引入存在最大值和最小值的约束条件，则可得到有界格的概念，具体如下：  
【定义12.32】设$\langle L,\leq\rangle$是任一给定的格，若$L$中存在最小元和最大元，即$\exists a,b\in L$，对∀ $x\in L$，有$a\leq x$且$x\leq b$，则称$\langle L,\leq\rangle$为有界格，通常将其最大元记为1，最小值记为0。 例如，设$𝑆$是一个非空集合，则格$\langle S,{\subseteq}\rangle$是一个有界格，其最大元是$𝑆$，最小元是$\varnothing$。并不是所有的格都是有界格，例如是实数集上的是小于或等于关系构成的格$<R,\leq\;>$，显然不是有界格。根据最小元和最大元以及幺元和零元的定义，易知成立下列等式：  
$1*x=x*1=x;1\oplus x=x\oplus1=1;0*x=x*0=0;0\oplus x=x\oplus0=x$  
也就是说1 是$*$和⊕的幺元与零元，0 是⊕和$*$的幺元和零元。  
【定理12.37】对于任意一个有界格$\langle L,\leq\rangle$，其最大值和最小值是唯一的。  
三、有补格  
对于格$\langle P(A),\subseteq\rangle$或$\langle{ P}(A),\cap,\cup\rangle$来说，集合$𝐴$和空集$\varnothing$显然是$P(A)$的最大元和最小元。我们知道，可在$\langle{ P}(A),\cap,\cup\rangle$上定义集合的补运算，即对于$\forall B\in P(A)$，存在${\bar{B}}\in P(A)$，满足：  
$$
B\cup\bar{B}=\ A;\ B\cap\bar{B}=\ \varnothing\quad\text{(12.5.9)}
$$  
通常称集合$\bar{B}$是集合$ B$的补集，或者称集合$\bar{B}$与$B$具有互补关系。现将格结构$\langle{ P}(A),\cap,\cup\rangle$或$\langle P(A),\subseteq\rangle$上的补运算推广到一般的有界格中，得到如下有补格的概念：  
【定义12.33】设$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$是任意给定的一个有界格，则对$\forall a\in L$，如果存在$b\in$$L$，满足$a*b=0$ 且$a\oplus b=1$，则称$ b$是$a$的补元素，通常简称为补元，记作$\bar{a}$。如果有界格$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$中每个元素都存在其补元素，则称$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$为有补格。  
由格结构的交换律可知，如果$b$是$a$的补元，那么$a$也是$b$的补元，即$a$与$b$互为补元。易知，在有界格中， 0 的唯一补元是1，1 的唯一补元是0。但是，对于有界格中一般的元素，其补元不一定存在。因此，虽然有补格一定是有界格，但有界格不一定是有补格。  
另一方面，对于任个有补格，并不能保证其中每个元素的补元素是唯一确定的。例如，对于如图12-8 所示的有界格，易知$a$补元是$b$和$c$，$b$的补元是$a$和$c$，$c$的补元是$a$和$b$。  
![](images/15c8cb1c91d0343f4329e4fe28808131c9c2a9b35b96281ded4f82ad6ec628e1.jpg)  
有补格中元素补元的这种不唯一性容易造成对问题分析和求解的混淆。因此，必须对一般的有补格结构附加适当的约束条件，使其能够满足格中任意元素补元的唯一性。事实上，如果对有补格附加满足分配律的约束，这可保证其补元的唯一性，即有如下定理：  
【定理12.38】设$\langle L,\leq\rangle$或$\langle L,*,\oplus\rangle$是一个有补格并且也是一个分配格，即是一个有补分配格，则$L$中任意元素的补元存在且唯一。  
从以上分析讨论可知：有补格仅保证了补元的普遍性，即格中任意一个元素都至少存在一个补元，但不能保证补元的唯一性；分配格则可以保证补元的唯一性但不能保证补元的普遍性；有补分配格同时吸收了有补格和分配格这两种特殊格的优点，能够同时保证补元的普遍性和唯一性。因此，有补分配格是一个具有优良性质的特殊格结构。事实上，有补分配格就是在计算机、电子信息、自动化等科学与工程中大量用到的布尔格或布尔代数。",有补分配格是有补格和分配格的组合，具有补元普遍性和唯一性
布尔代数,定义,定理12.39,,"如前所述，有补分配格既保证了格中每个元素都存在其补元素，又保证了每个元素补元素的唯一性。显然，这其实是定义了格结构载体集合上的一元求补映射或运算。因此，有补分配格结构具有保交、保联和保补这三种运算。具体地说，有补分配格是一个包含两个二元运算$*$和⊕以及一个一元运$^{-}$所构成的特殊代数系统。这种特殊的代数系统其实就是布尔代数系统，具体定义如下，通常将用字母$B$表示布尔代数的载体集：  
【定义12.34】假设$\langle B,*,\oplus\rangle$是一个任意给定的有补分配格，则称其为布尔格或布尔代数，记为 $\langle B,*,\oplus,^{-},0,1\rangle$ 。 如果 $L$ 是有限集， 则称 $\langle B,*,\oplus,^{-},0,1\rangle$ 为有限布尔格或有限布尔代数； 如 果$L$是无限集，则称$\langle B,*,\oplus,^{-},0,1\rangle$为无限布尔格或无限布尔代数。  
显然，布尔代数的两个二元运算满足交换律、结合律、吸收律和幂等律等，然而这些定  
律并非独立的，例如幂等律可由吸收律得到。那么哪些运算律能够从本质上判定一个代数系统是否为布尔代数呢？下面的定理12.39 给出了具体答案，该定理结论也可看成是从运算性质的角度给出布尔代数系统的一个公理化定义：  
【定理12.39】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个至少含有两个元素的代数系统，$*$和⊕是定义在$𝐿$上的二元运算,$^{-}$ 是定义在$B$上的一元运算，对$\forall\ \ a,b,c\in B$，如果满足：  
（1）交换律：$a*b=b*a$，$a\oplus b=b\oplus a$  
（2）分配律：$a*(b\oplus c)=(a*b)\oplus(a*c);\,\,\,a\oplus(b*c)=(a\oplus b)*(a\oplus c)$  
（3）同一律：$a*1=a$，$a\oplus0={\mathsf{a}}$  
（4）互补律：${\bar{a}}*a=0$，${\bar{a}}\oplus a=1$  
则$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数。  
将代数系统中子代数的概念应用于布尔代数，可定义如下布尔子代数概念：  
【定义12.35】设$\langle B,*,\oplus,-,0,1\rangle $是任意给定的一个布尔代数，$S$是$B$的非空子集，若$𝑆$对运算${\ast,\oplus,^{-}}$ 都封闭且$0{,}1\in S$，则称$\langle S,*,\oplus,\stackrel{-}{\quad},0,1\rangle,$是$\langle B,*,\oplus,-,0,1\rangle $的子布尔代数。",定理12.39给出了布尔代数系统的公理化定义，通过运算性质判定一个代数系统是否为布尔代数
布尔代数,包含,布尔子代数,,"如前所述，有补分配格既保证了格中每个元素都存在其补元素，又保证了每个元素补元素的唯一性。显然，这其实是定义了格结构载体集合上的一元求补映射或运算。因此，有补分配格结构具有保交、保联和保补这三种运算。具体地说，有补分配格是一个包含两个二元运算$*$和⊕以及一个一元运$^{-}$所构成的特殊代数系统。这种特殊的代数系统其实就是布尔代数系统，具体定义如下，通常将用字母$B$表示布尔代数的载体集：  
【定义12.34】假设$\langle B,*,\oplus\rangle$是一个任意给定的有补分配格，则称其为布尔格或布尔代数，记为 $\langle B,*,\oplus,^{-},0,1\rangle$ 。 如果 $L$ 是有限集， 则称 $\langle B,*,\oplus,^{-},0,1\rangle$ 为有限布尔格或有限布尔代数； 如 果$L$是无限集，则称$\langle B,*,\oplus,^{-},0,1\rangle$为无限布尔格或无限布尔代数。  
显然，布尔代数的两个二元运算满足交换律、结合律、吸收律和幂等律等，然而这些定  
律并非独立的，例如幂等律可由吸收律得到。那么哪些运算律能够从本质上判定一个代数系统是否为布尔代数呢？下面的定理12.39 给出了具体答案，该定理结论也可看成是从运算性质的角度给出布尔代数系统的一个公理化定义：  
【定理12.39】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个至少含有两个元素的代数系统，$*$和⊕是定义在$𝐿$上的二元运算,$^{-}$ 是定义在$B$上的一元运算，对$\forall\ \ a,b,c\in B$，如果满足：  
（1）交换律：$a*b=b*a$，$a\oplus b=b\oplus a$  
（2）分配律：$a*(b\oplus c)=(a*b)\oplus(a*c);\,\,\,a\oplus(b*c)=(a\oplus b)*(a\oplus c)$  
（3）同一律：$a*1=a$，$a\oplus0={\mathsf{a}}$  
（4）互补律：${\bar{a}}*a=0$，${\bar{a}}\oplus a=1$  
则$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数。  
将代数系统中子代数的概念应用于布尔代数，可定义如下布尔子代数概念：  
【定义12.35】设$\langle B,*,\oplus,-,0,1\rangle $是任意给定的一个布尔代数，$S$是$B$的非空子集，若$𝑆$对运算${\ast,\oplus,^{-}}$ 都封闭且$0{,}1\in S$，则称$\langle S,*,\oplus,\stackrel{-}{\quad},0,1\rangle,$是$\langle B,*,\oplus,-,0,1\rangle $的子布尔代数。",布尔子代数是布尔代数的非空子集，对布尔代数的运算封闭且包含0和1
布尔同态,包含,布尔同构,,"将代数系统中同态和同构的概念应用于布尔代数，可定义如下布尔同态与同构：  
【定义12.36】设$\langle B_{1},*,\oplus,^{-},0,1\rangle$和$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$是任意给定的两个布尔代数，如果存在一个从$B_{1}$到$B_{2}$的映射$\psi$: $B_{1}\rightarrow B_{2}$，对$\forall a,b\in L,$，$\psi$满足：  
$\begin{aligned}\psi(a*b)&=\psi(a)\circ\psi(b); \psi(a\oplus b)=\psi(a)\circledast\psi(b);\\\psi(\bar{a})&=\triangle \psi(a); \psi(0)=\alpha; \psi(1)=\beta\end{aligned}$  
则称映射$\psi$是从$\langle B_{1},*,\oplus, ^{-},0,1\rangle$到$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$的一个同态映射，并称$\langle B_{1},*,\oplus, ^{-},0,1\rangle$与$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$为布尔同态。若$\psi$是双射，则称$\psi$是从$\langle B_{1},*,\oplus, ^{-},0,1\rangle$到$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$的一个同构映射，并称$\langle B_{1},*,\oplus, ^{-},0,1\rangle$与$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$为布尔同构。  
有时难以直接讨论或研究某个比较复杂或抽象的布尔代数系统，若能找到一个与之同构的具体布尔代数系统进行研究，就会带来很多方便，例如，如果某个布尔代数和集合代数同构，则可将集合代数作为具体研究对象，从而大大简化对该布尔代数的研究。  
为了给出一个比较重要的关于布尔同构的定理，下面定义一个所谓原子的概念：  
【定义12.37】设$\langle B,*,\oplus, ^{-},0,1\rangle$是任意给定的一个布尔代数，对于$\forall a\in B$且$a\neq0$，如果对于$\forall x\in B$，满足$x*a=a$或$x*a=0$，则称$^{}a$是$\langle B,*,\oplus, ^{-},0,1\rangle$的一个原子或极小元。  
在定义中$a\neq0$表示$a$不是$B$中的最小元，而且对$B$中任一元素${x}$，要么$x$比$a$大，要么$x$和$a$不可比。简言之，除去最小元0 外，不会有任何一个元素$x$比$a$小。下面的例题12.6.7 表明，对于任意给定的一个布尔代数，可能会有多个原子。  
例如，在图12-12（a）中，$b$是最小元，唯一的原子是$a$，同时也是最大元。在图12-12（b）中，$a_{4}$是最小元，$a_{2}$和$a_{3}$都是原子，$a_{1}$是最大元但不是原子。在图12-12（c）中，$b_{8}$是最小元，$b_{5}$，$b_{6}$，$b_{7}$是原子，而$b_{1}$，$b_{2}$，$b_{3}$，$b_{4}$都不是原子。  
![](images/543436e369e6162cc7d12db06777b18d401f37573a58bcd4b6f824c830035b69.jpg)  
图12-12  布尔代数的原子  
基于原子的概念，可以得到如下关于布尔同构的斯通定理：  
【定理12.41】（斯通定理）设$\langle B,*,\oplus,^{-},0,1\rangle$是有限布尔代数，集合$𝑆$是$B$中所有原子构成的集合，那么$\langle B,*,\oplus,^{-},0,1\rangle$和$\langle P(S),\subseteq,\cap,\cup,^{-},\emptyset,S\rangle$同构。",布尔同构是布尔同态的特殊情况，即当映射是双射时，布尔同态成为布尔同构
原子,基础,布尔同构,,"将代数系统中同态和同构的概念应用于布尔代数，可定义如下布尔同态与同构：  
【定义12.36】设$\langle B_{1},*,\oplus,^{-},0,1\rangle$和$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$是任意给定的两个布尔代数，如果存在一个从$B_{1}$到$B_{2}$的映射$\psi$: $B_{1}\rightarrow B_{2}$，对$\forall a,b\in L,$，$\psi$满足：  
$\begin{aligned}\psi(a*b)&=\psi(a)\circ\psi(b); \psi(a\oplus b)=\psi(a)\circledast\psi(b);\\\psi(\bar{a})&=\triangle \psi(a); \psi(0)=\alpha; \psi(1)=\beta\end{aligned}$  
则称映射$\psi$是从$\langle B_{1},*,\oplus, ^{-},0,1\rangle$到$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$的一个同态映射，并称$\langle B_{1},*,\oplus, ^{-},0,1\rangle$与$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$为布尔同态。若$\psi$是双射，则称$\psi$是从$\langle B_{1},*,\oplus, ^{-},0,1\rangle$到$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$的一个同构映射，并称$\langle B_{1},*,\oplus, ^{-},0,1\rangle$与$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$为布尔同构。  
有时难以直接讨论或研究某个比较复杂或抽象的布尔代数系统，若能找到一个与之同构的具体布尔代数系统进行研究，就会带来很多方便，例如，如果某个布尔代数和集合代数同构，则可将集合代数作为具体研究对象，从而大大简化对该布尔代数的研究。  
为了给出一个比较重要的关于布尔同构的定理，下面定义一个所谓原子的概念：  
【定义12.37】设$\langle B,*,\oplus, ^{-},0,1\rangle$是任意给定的一个布尔代数，对于$\forall a\in B$且$a\neq0$，如果对于$\forall x\in B$，满足$x*a=a$或$x*a=0$，则称$^{}a$是$\langle B,*,\oplus, ^{-},0,1\rangle$的一个原子或极小元。  
在定义中$a\neq0$表示$a$不是$B$中的最小元，而且对$B$中任一元素${x}$，要么$x$比$a$大，要么$x$和$a$不可比。简言之，除去最小元0 外，不会有任何一个元素$x$比$a$小。下面的例题12.6.7 表明，对于任意给定的一个布尔代数，可能会有多个原子。  
例如，在图12-12（a）中，$b$是最小元，唯一的原子是$a$，同时也是最大元。在图12-12（b）中，$a_{4}$是最小元，$a_{2}$和$a_{3}$都是原子，$a_{1}$是最大元但不是原子。在图12-12（c）中，$b_{8}$是最小元，$b_{5}$，$b_{6}$，$b_{7}$是原子，而$b_{1}$，$b_{2}$，$b_{3}$，$b_{4}$都不是原子。  
![](images/543436e369e6162cc7d12db06777b18d401f37573a58bcd4b6f824c830035b69.jpg)  
图12-12  布尔代数的原子  
基于原子的概念，可以得到如下关于布尔同构的斯通定理：  
【定理12.41】（斯通定理）设$\langle B,*,\oplus,^{-},0,1\rangle$是有限布尔代数，集合$𝑆$是$B$中所有原子构成的集合，那么$\langle B,*,\oplus,^{-},0,1\rangle$和$\langle P(S),\subseteq,\cap,\cup,^{-},\emptyset,S\rangle$同构。",原子的概念是定义布尔同构的基础，斯通定理通过原子集合来描述布尔代数的同构性质
斯通定理,描述,布尔同构,,"将代数系统中同态和同构的概念应用于布尔代数，可定义如下布尔同态与同构：  
【定义12.36】设$\langle B_{1},*,\oplus,^{-},0,1\rangle$和$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$是任意给定的两个布尔代数，如果存在一个从$B_{1}$到$B_{2}$的映射$\psi$: $B_{1}\rightarrow B_{2}$，对$\forall a,b\in L,$，$\psi$满足：  
$\begin{aligned}\psi(a*b)&=\psi(a)\circ\psi(b); \psi(a\oplus b)=\psi(a)\circledast\psi(b);\\\psi(\bar{a})&=\triangle \psi(a); \psi(0)=\alpha; \psi(1)=\beta\end{aligned}$  
则称映射$\psi$是从$\langle B_{1},*,\oplus, ^{-},0,1\rangle$到$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$的一个同态映射，并称$\langle B_{1},*,\oplus, ^{-},0,1\rangle$与$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$为布尔同态。若$\psi$是双射，则称$\psi$是从$\langle B_{1},*,\oplus, ^{-},0,1\rangle$到$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$的一个同构映射，并称$\langle B_{1},*,\oplus, ^{-},0,1\rangle$与$\langle B_{2},\circ,\circledast,\triangle,\alpha,\beta\rangle$为布尔同构。  
有时难以直接讨论或研究某个比较复杂或抽象的布尔代数系统，若能找到一个与之同构的具体布尔代数系统进行研究，就会带来很多方便，例如，如果某个布尔代数和集合代数同构，则可将集合代数作为具体研究对象，从而大大简化对该布尔代数的研究。  
为了给出一个比较重要的关于布尔同构的定理，下面定义一个所谓原子的概念：  
【定义12.37】设$\langle B,*,\oplus, ^{-},0,1\rangle$是任意给定的一个布尔代数，对于$\forall a\in B$且$a\neq0$，如果对于$\forall x\in B$，满足$x*a=a$或$x*a=0$，则称$^{}a$是$\langle B,*,\oplus, ^{-},0,1\rangle$的一个原子或极小元。  
在定义中$a\neq0$表示$a$不是$B$中的最小元，而且对$B$中任一元素${x}$，要么$x$比$a$大，要么$x$和$a$不可比。简言之，除去最小元0 外，不会有任何一个元素$x$比$a$小。下面的例题12.6.7 表明，对于任意给定的一个布尔代数，可能会有多个原子。  
例如，在图12-12（a）中，$b$是最小元，唯一的原子是$a$，同时也是最大元。在图12-12（b）中，$a_{4}$是最小元，$a_{2}$和$a_{3}$都是原子，$a_{1}$是最大元但不是原子。在图12-12（c）中，$b_{8}$是最小元，$b_{5}$，$b_{6}$，$b_{7}$是原子，而$b_{1}$，$b_{2}$，$b_{3}$，$b_{4}$都不是原子。  
![](images/543436e369e6162cc7d12db06777b18d401f37573a58bcd4b6f824c830035b69.jpg)  
图12-12  布尔代数的原子  
基于原子的概念，可以得到如下关于布尔同构的斯通定理：  
【定理12.41】（斯通定理）设$\langle B,*,\oplus,^{-},0,1\rangle$是有限布尔代数，集合$𝑆$是$B$中所有原子构成的集合，那么$\langle B,*,\oplus,^{-},0,1\rangle$和$\langle P(S),\subseteq,\cap,\cup,^{-},\emptyset,S\rangle$同构。",斯通定理描述了有限布尔代数与其原子集合的幂集代数之间的同构关系
布尔代数,定义基础,布尔表达式,,"我们知道，无论是命题代数还是集合代数都可以通过相应的表达式进行计算，集合代数有集合运算表示式，命题代数有命题表达式或命题公式，事实上，可以从更加抽象的布尔代数的角度考察这些运算表达式，或者说可以将这些具体的运算表达式抽象成一般的布尔表达式研究其共同运算性质。由此得到布尔表达式的概念，具体定义如下：  
【定义12.38】设$\langle B,*,\oplus,^{-},0,1\rangle$是任意给定的一个布尔代数，则集合$ B$中的元素称为布尔常元，取值于$ B$中元素的变元称为布尔变元。  
与命题代数类似，使用归纳的方法定义布尔表达式：  
【定义12.39】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数，则 $B$上布尔表达式定义如下：  
（1）$B$中的任何一个布尔常元是布尔表达式；  
（2）$B$中的任何一个布尔变元是布尔表达式；  
（3）如果$e_{1}$和$e_{2}$是布尔表达式，则$\overline{{e_{1}}}$ ，$e_{1}*e_{2}$，$e_{1}\oplus e_{2}$也是布尔表达式；  
（4）只有有限次使用（1）、（2）和（3）所构造的符号串才是布尔表达式。  
【定义12.40】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数，$B$中含有${n}$个相异布尔变元的布尔表达式称为$\mathbf{n}$元布尔表达式，记为$f(x_{1},x_{2},\cdots,x_{n})$，其中$x_{1},x_{2},\cdots,x_{n}$是布尔变元。布尔表达式的值是指将$B$中的布尔常元作为布尔变元$x_{i}(i=1,2,\cdots,n)$的值来代替布尔表达式中相应的布尔变元，而计算出的布尔表达式的值。  
例如，表达式$f(x,y)=(a*x)\oplus({\bar{b}}\oplus y)\oplus(x\oplus{\bar{y}})$是布尔代数$\langle\lbrace0,a,b,1\rbrace,*,\oplus,^{-},0,1\rangle$上的二元布尔表达式。如果对该表达式中布尔变元$x,y$赋初值为$x=a,y=b$，则可得到：  
$$
f(a,b)=(a*a)\oplus\left({\bar{b}}\oplus b\right)\oplus\left(a\oplus{\bar{b}}\right)=a\oplus1\oplus\left(a\oplus{\bar{b}}\right)=1
$$  
【定义12.41】设$f_{1}(x_{1},x_{2},\cdots,x_{n})$和$f_{2}(x_{1},x_{2},\cdots,x_{n})$是$\langle B,*,\oplus,^{-},0,1\rangle$上的两个布尔表达式，如果对${x_{i}}$任意的赋值即$x_{i}=b_{i},b_{i}\in B,(i=1,2,\cdots,n)$均有：  
$$
f_{1}(b_{1},b_{2},\cdots,b_{n})=f_{2}(b_{1},b_{2},\cdots,b_{n})\quad\text{(12-26)}
$$  
则称这两个布尔表达式为等价或等值，记为$f_{1}(x_{1},x_{2},\cdots,x_{n})=f_{2}(x_{1},x_{2},\cdots,x_{n})\,。$  
如果要验证两个布尔表达式是等价的，一般情况下可以采取如下两种方法：一种是直接验证，另外一种是利用布尔代数的运算律进行有限次的推导。例如，对于$\langle B,*,\oplus,^{-},0,1\rangle$上两个布尔表达式：  
$$
f_{1}(x_{1},x_{2},x_{3})=x_{1}*(x_{2}\oplus x_{3}),\;\;f_{2}(x_{1},x_{2},x_{3})=(x_{1}*x_{2})\oplus(x_{1}*x_{3})
$$  
对于$\forall x_{i}=b_{i},b_{i}\in B,(i=1,2,3)$，可以直接验证$f_{1}(x_{1},x_{2},x_{3})=f_{2}(x_{1},x_{2},x_{3})$。也可以利用分配律验证其等价性。这与命题逻辑中的真值表法和演算法非常类似。  
对于布尔代数$\langle B,*,\oplus,^{-},0,1\rangle$上任意一个布尔表达式$f(x_{1},x_{2},\cdots,x_{n})$，由于运算${*,\bigoplus,^{-}}$在$B$上封闭，故对于$\langle x_{1},x_{2},\cdots,x_{n}\rangle$的任何赋值$\langle b_{1},b_{2},\cdots,b_{n}\rangle,b_{i}\in B$，有$f(b_{1},b_{2},\cdots,b_{n})\in B$。这表明$f(x_{1},x_{2},\cdots,x_{n})$确定了一个从$B^{n}$到$B$的函数。据此引入如下布尔函数的概念：  
【定义12.42】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数，$f$为一个从$B^{n}$到$B$的函数，如果它能够用$\langle B,*,\oplus,^{-},0,1\rangle$上的$n$元布尔表达式表示，则称该函数为布尔函数。  
对于任意一个给定的布尔函数，如何确定其所对应的布尔表达式呢？现在就来讨论这个问题，首先给出如下布尔表达式极小项的定义  
【定义12.43】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数，给定$n$个布尔变元$x_{1},x_{2},\cdots,x_{n}$，表达式$\widetilde{x}_{1}*\widetilde{x}_{2}*\widetilde{x}_{3}*\cdots*\widetilde{x}_{n}$称为极小项，其中$\tilde{x}_{i}$表示$ x_{i}$或$\overline{{x_{\iota}}}$。  
例如，对于两个布尔变元$x_{1},x_{2}$，其极小项为$x_{1}*x_{2}\,,\ \bar{x}_{1}*x_{2}\,,\ x_{1}*\bar{x}_{2}$和${x}_{1}*{x}_{2}$  。  
容易验证$n$个布尔变元可以构成$\ 2^{n}$个不同的极小项，分别记为$m_{0},m_{1},m_{2},\cdots,m_{2^{n}-1}$，其中下标是二进制数$a_{1}a_{2}\cdots a_{n}$对应的十进制数，其中：  
$$
a_i=\begin{cases}1,&\text{当}\widetilde{x_i}=x_i\text{时}\\0,&\text{当}\widetilde{x_i}=\bar{x_i}\text{时}\end{cases}(i=1, 2, \cdots, n)
$$  
具体可表述为：  
$m_{0}={\bar{x}}_{1}*{\bar{x}}_{2}*\cdots*{\bar{x}}_{n},\quad m_{1}={\bar{x}}_{1}*{\bar{x}}_{2}*\cdots*{\bar{x}}_{n-1}*x_{n},\ \cdots,\quad m_{n}=x_{1}*x_{2}*\cdots*x_{n}$ 不难验证极小项具有如下两个基本性质：  
（1）$m_{i}*m_{j}=0$，当$i\neq j$时；（2）$m_{0}\oplus m_{1}\oplus m_{2}\oplus\cdots\oplus m_{2^{n}-1}=1\,$。  
【定义12.44】设$<\mathrm{B},*,\oplus,\stackrel{\_}{\ },0,1>$布尔代数，称形如：
$$
(\,\alpha_{0}*m_{0}\,)\,\oplus(\alpha_{1}*m_{1})\oplus(\alpha_{2}*m_{2})\oplus\cdots\oplus(\alpha_{2^{n}-1}\oplus m_{2^{n}-1})
$$  
的布尔表达式成为主析取范式，这里$\alpha_{i}$是布尔常元，$m_{i}$是极小项$(i=1,\!2,\!\cdots,2^{n}-1)$.  
因为每个$\alpha_{i}$有$|B|$种取法，故具有$n$个布尔变元的不同主析取范式共有$|\mathrm{B}|^{2^{n}}$个，当$B=${0,1}时有$2^{2^{n}}$个。而$2^{n}$个极小项最多只能构造出$|\mathbf{B}|^{2^{n}}$个不同的主析取范式，所以一个$\mathsf{n}$ 元布尔表达式必等价于这$|\mathbf{B}|^{2^{n}}$个主析取范式之一。又由于任何两个不同的主析取范式显然是不等价的，所以一个n 元布尔表达式都唯一等价于一个主析取范式。可将${ n}$元布尔表达式化成等价的主析取范式，方法与将命题公式换成主析取范式的方法完全一致。  
对于任意给定的一个$ n$元布尔表达式，其${n}$个布尔变元的每一指派，都可确定该表达式在集合B中的一个取值，故每个布尔表达式都代表一个布尔函数。由于$n$个布尔变元的主析取范式最多只有$|\mathrm{B}|^{2^{n}}$个，故布尔表达式最多只能表示$|\mathrm{B}|^{2^{n}}$个不同函数。$B=\{0,1\}$时，从$B^{n}$到$B$的函数共有$2^{2^{n}}$个，主析取范式也有$2^{2^{n}}$个，恰好每一个主析取范式代表一个布尔函数，此时每个函数均可用布尔表达式表示。  
可用同样方法讨论极大项和主合取范式，不再赘述。
![](images/d9aea4daa121e3eccc7b12420a8fb81447c40edfd8e103d7c7a3a0401f26dc77.jpg)  
图 12-14 离散数学的知识体系  
从上述分析讨论不难看出，布尔表达式和布尔函数的运算性质与命题代数的演算基本上相同。因此，可将布尔代数看成是命题代数的一个抽象，将命题代数看成是布尔代数的一个具体实例。事实上，集合代数也是布尔代数的一个具体实例。如图12-14 所示，集合代数和命题（逻辑）代数作为一种理论基础共同支撑了离散数学结构的整个知识体系，同时两者又在抽象布尔代数的层次上实现了完美的统一。",布尔表达式是基于布尔代数定义的，布尔代数为布尔表达式提供了运算和常元的定义基础。
布尔表达式,表示关系,布尔函数,,"我们知道，无论是命题代数还是集合代数都可以通过相应的表达式进行计算，集合代数有集合运算表示式，命题代数有命题表达式或命题公式，事实上，可以从更加抽象的布尔代数的角度考察这些运算表达式，或者说可以将这些具体的运算表达式抽象成一般的布尔表达式研究其共同运算性质。由此得到布尔表达式的概念，具体定义如下：  
【定义12.38】设$\langle B,*,\oplus,^{-},0,1\rangle$是任意给定的一个布尔代数，则集合$ B$中的元素称为布尔常元，取值于$ B$中元素的变元称为布尔变元。  
与命题代数类似，使用归纳的方法定义布尔表达式：  
【定义12.39】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数，则 $B$上布尔表达式定义如下：  
（1）$B$中的任何一个布尔常元是布尔表达式；  
（2）$B$中的任何一个布尔变元是布尔表达式；  
（3）如果$e_{1}$和$e_{2}$是布尔表达式，则$\overline{{e_{1}}}$ ，$e_{1}*e_{2}$，$e_{1}\oplus e_{2}$也是布尔表达式；  
（4）只有有限次使用（1）、（2）和（3）所构造的符号串才是布尔表达式。  
【定义12.40】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数，$B$中含有${n}$个相异布尔变元的布尔表达式称为$\mathbf{n}$元布尔表达式，记为$f(x_{1},x_{2},\cdots,x_{n})$，其中$x_{1},x_{2},\cdots,x_{n}$是布尔变元。布尔表达式的值是指将$B$中的布尔常元作为布尔变元$x_{i}(i=1,2,\cdots,n)$的值来代替布尔表达式中相应的布尔变元，而计算出的布尔表达式的值。  
例如，表达式$f(x,y)=(a*x)\oplus({\bar{b}}\oplus y)\oplus(x\oplus{\bar{y}})$是布尔代数$\langle\lbrace0,a,b,1\rbrace,*,\oplus,^{-},0,1\rangle$上的二元布尔表达式。如果对该表达式中布尔变元$x,y$赋初值为$x=a,y=b$，则可得到：  
$$
f(a,b)=(a*a)\oplus\left({\bar{b}}\oplus b\right)\oplus\left(a\oplus{\bar{b}}\right)=a\oplus1\oplus\left(a\oplus{\bar{b}}\right)=1
$$  
【定义12.41】设$f_{1}(x_{1},x_{2},\cdots,x_{n})$和$f_{2}(x_{1},x_{2},\cdots,x_{n})$是$\langle B,*,\oplus,^{-},0,1\rangle$上的两个布尔表达式，如果对${x_{i}}$任意的赋值即$x_{i}=b_{i},b_{i}\in B,(i=1,2,\cdots,n)$均有：  
$$
f_{1}(b_{1},b_{2},\cdots,b_{n})=f_{2}(b_{1},b_{2},\cdots,b_{n})\quad\text{(12-26)}
$$  
则称这两个布尔表达式为等价或等值，记为$f_{1}(x_{1},x_{2},\cdots,x_{n})=f_{2}(x_{1},x_{2},\cdots,x_{n})\,。$  
如果要验证两个布尔表达式是等价的，一般情况下可以采取如下两种方法：一种是直接验证，另外一种是利用布尔代数的运算律进行有限次的推导。例如，对于$\langle B,*,\oplus,^{-},0,1\rangle$上两个布尔表达式：  
$$
f_{1}(x_{1},x_{2},x_{3})=x_{1}*(x_{2}\oplus x_{3}),\;\;f_{2}(x_{1},x_{2},x_{3})=(x_{1}*x_{2})\oplus(x_{1}*x_{3})
$$  
对于$\forall x_{i}=b_{i},b_{i}\in B,(i=1,2,3)$，可以直接验证$f_{1}(x_{1},x_{2},x_{3})=f_{2}(x_{1},x_{2},x_{3})$。也可以利用分配律验证其等价性。这与命题逻辑中的真值表法和演算法非常类似。  
对于布尔代数$\langle B,*,\oplus,^{-},0,1\rangle$上任意一个布尔表达式$f(x_{1},x_{2},\cdots,x_{n})$，由于运算${*,\bigoplus,^{-}}$在$B$上封闭，故对于$\langle x_{1},x_{2},\cdots,x_{n}\rangle$的任何赋值$\langle b_{1},b_{2},\cdots,b_{n}\rangle,b_{i}\in B$，有$f(b_{1},b_{2},\cdots,b_{n})\in B$。这表明$f(x_{1},x_{2},\cdots,x_{n})$确定了一个从$B^{n}$到$B$的函数。据此引入如下布尔函数的概念：  
【定义12.42】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数，$f$为一个从$B^{n}$到$B$的函数，如果它能够用$\langle B,*,\oplus,^{-},0,1\rangle$上的$n$元布尔表达式表示，则称该函数为布尔函数。  
对于任意一个给定的布尔函数，如何确定其所对应的布尔表达式呢？现在就来讨论这个问题，首先给出如下布尔表达式极小项的定义  
【定义12.43】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数，给定$n$个布尔变元$x_{1},x_{2},\cdots,x_{n}$，表达式$\widetilde{x}_{1}*\widetilde{x}_{2}*\widetilde{x}_{3}*\cdots*\widetilde{x}_{n}$称为极小项，其中$\tilde{x}_{i}$表示$ x_{i}$或$\overline{{x_{\iota}}}$。  
例如，对于两个布尔变元$x_{1},x_{2}$，其极小项为$x_{1}*x_{2}\,,\ \bar{x}_{1}*x_{2}\,,\ x_{1}*\bar{x}_{2}$和${x}_{1}*{x}_{2}$  。  
容易验证$n$个布尔变元可以构成$\ 2^{n}$个不同的极小项，分别记为$m_{0},m_{1},m_{2},\cdots,m_{2^{n}-1}$，其中下标是二进制数$a_{1}a_{2}\cdots a_{n}$对应的十进制数，其中：  
$$
a_i=\begin{cases}1,&\text{当}\widetilde{x_i}=x_i\text{时}\\0,&\text{当}\widetilde{x_i}=\bar{x_i}\text{时}\end{cases}(i=1, 2, \cdots, n)
$$  
具体可表述为：  
$m_{0}={\bar{x}}_{1}*{\bar{x}}_{2}*\cdots*{\bar{x}}_{n},\quad m_{1}={\bar{x}}_{1}*{\bar{x}}_{2}*\cdots*{\bar{x}}_{n-1}*x_{n},\ \cdots,\quad m_{n}=x_{1}*x_{2}*\cdots*x_{n}$ 不难验证极小项具有如下两个基本性质：  
（1）$m_{i}*m_{j}=0$，当$i\neq j$时；（2）$m_{0}\oplus m_{1}\oplus m_{2}\oplus\cdots\oplus m_{2^{n}-1}=1\,$。  
【定义12.44】设$<\mathrm{B},*,\oplus,\stackrel{\_}{\ },0,1>$布尔代数，称形如：
$$
(\,\alpha_{0}*m_{0}\,)\,\oplus(\alpha_{1}*m_{1})\oplus(\alpha_{2}*m_{2})\oplus\cdots\oplus(\alpha_{2^{n}-1}\oplus m_{2^{n}-1})
$$  
的布尔表达式成为主析取范式，这里$\alpha_{i}$是布尔常元，$m_{i}$是极小项$(i=1,\!2,\!\cdots,2^{n}-1)$.  
因为每个$\alpha_{i}$有$|B|$种取法，故具有$n$个布尔变元的不同主析取范式共有$|\mathrm{B}|^{2^{n}}$个，当$B=${0,1}时有$2^{2^{n}}$个。而$2^{n}$个极小项最多只能构造出$|\mathbf{B}|^{2^{n}}$个不同的主析取范式，所以一个$\mathsf{n}$ 元布尔表达式必等价于这$|\mathbf{B}|^{2^{n}}$个主析取范式之一。又由于任何两个不同的主析取范式显然是不等价的，所以一个n 元布尔表达式都唯一等价于一个主析取范式。可将${ n}$元布尔表达式化成等价的主析取范式，方法与将命题公式换成主析取范式的方法完全一致。  
对于任意给定的一个$ n$元布尔表达式，其${n}$个布尔变元的每一指派，都可确定该表达式在集合B中的一个取值，故每个布尔表达式都代表一个布尔函数。由于$n$个布尔变元的主析取范式最多只有$|\mathrm{B}|^{2^{n}}$个，故布尔表达式最多只能表示$|\mathrm{B}|^{2^{n}}$个不同函数。$B=\{0,1\}$时，从$B^{n}$到$B$的函数共有$2^{2^{n}}$个，主析取范式也有$2^{2^{n}}$个，恰好每一个主析取范式代表一个布尔函数，此时每个函数均可用布尔表达式表示。  
可用同样方法讨论极大项和主合取范式，不再赘述。
![](images/d9aea4daa121e3eccc7b12420a8fb81447c40edfd8e103d7c7a3a0401f26dc77.jpg)  
图 12-14 离散数学的知识体系  
从上述分析讨论不难看出，布尔表达式和布尔函数的运算性质与命题代数的演算基本上相同。因此，可将布尔代数看成是命题代数的一个抽象，将命题代数看成是布尔代数的一个具体实例。事实上，集合代数也是布尔代数的一个具体实例。如图12-14 所示，集合代数和命题（逻辑）代数作为一种理论基础共同支撑了离散数学结构的整个知识体系，同时两者又在抽象布尔代数的层次上实现了完美的统一。",布尔表达式可以表示布尔函数，布尔函数是通过布尔表达式来定义的，布尔表达式的值确定了布尔函数的行为。
布尔表达式,构成关系,极小项,,"我们知道，无论是命题代数还是集合代数都可以通过相应的表达式进行计算，集合代数有集合运算表示式，命题代数有命题表达式或命题公式，事实上，可以从更加抽象的布尔代数的角度考察这些运算表达式，或者说可以将这些具体的运算表达式抽象成一般的布尔表达式研究其共同运算性质。由此得到布尔表达式的概念，具体定义如下：  
【定义12.38】设$\langle B,*,\oplus,^{-},0,1\rangle$是任意给定的一个布尔代数，则集合$ B$中的元素称为布尔常元，取值于$ B$中元素的变元称为布尔变元。  
与命题代数类似，使用归纳的方法定义布尔表达式：  
【定义12.39】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数，则 $B$上布尔表达式定义如下：  
（1）$B$中的任何一个布尔常元是布尔表达式；  
（2）$B$中的任何一个布尔变元是布尔表达式；  
（3）如果$e_{1}$和$e_{2}$是布尔表达式，则$\overline{{e_{1}}}$ ，$e_{1}*e_{2}$，$e_{1}\oplus e_{2}$也是布尔表达式；  
（4）只有有限次使用（1）、（2）和（3）所构造的符号串才是布尔表达式。  
【定义12.40】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数，$B$中含有${n}$个相异布尔变元的布尔表达式称为$\mathbf{n}$元布尔表达式，记为$f(x_{1},x_{2},\cdots,x_{n})$，其中$x_{1},x_{2},\cdots,x_{n}$是布尔变元。布尔表达式的值是指将$B$中的布尔常元作为布尔变元$x_{i}(i=1,2,\cdots,n)$的值来代替布尔表达式中相应的布尔变元，而计算出的布尔表达式的值。  
例如，表达式$f(x,y)=(a*x)\oplus({\bar{b}}\oplus y)\oplus(x\oplus{\bar{y}})$是布尔代数$\langle\lbrace0,a,b,1\rbrace,*,\oplus,^{-},0,1\rangle$上的二元布尔表达式。如果对该表达式中布尔变元$x,y$赋初值为$x=a,y=b$，则可得到：  
$$
f(a,b)=(a*a)\oplus\left({\bar{b}}\oplus b\right)\oplus\left(a\oplus{\bar{b}}\right)=a\oplus1\oplus\left(a\oplus{\bar{b}}\right)=1
$$  
【定义12.41】设$f_{1}(x_{1},x_{2},\cdots,x_{n})$和$f_{2}(x_{1},x_{2},\cdots,x_{n})$是$\langle B,*,\oplus,^{-},0,1\rangle$上的两个布尔表达式，如果对${x_{i}}$任意的赋值即$x_{i}=b_{i},b_{i}\in B,(i=1,2,\cdots,n)$均有：  
$$
f_{1}(b_{1},b_{2},\cdots,b_{n})=f_{2}(b_{1},b_{2},\cdots,b_{n})\quad\text{(12-26)}
$$  
则称这两个布尔表达式为等价或等值，记为$f_{1}(x_{1},x_{2},\cdots,x_{n})=f_{2}(x_{1},x_{2},\cdots,x_{n})\,。$  
如果要验证两个布尔表达式是等价的，一般情况下可以采取如下两种方法：一种是直接验证，另外一种是利用布尔代数的运算律进行有限次的推导。例如，对于$\langle B,*,\oplus,^{-},0,1\rangle$上两个布尔表达式：  
$$
f_{1}(x_{1},x_{2},x_{3})=x_{1}*(x_{2}\oplus x_{3}),\;\;f_{2}(x_{1},x_{2},x_{3})=(x_{1}*x_{2})\oplus(x_{1}*x_{3})
$$  
对于$\forall x_{i}=b_{i},b_{i}\in B,(i=1,2,3)$，可以直接验证$f_{1}(x_{1},x_{2},x_{3})=f_{2}(x_{1},x_{2},x_{3})$。也可以利用分配律验证其等价性。这与命题逻辑中的真值表法和演算法非常类似。  
对于布尔代数$\langle B,*,\oplus,^{-},0,1\rangle$上任意一个布尔表达式$f(x_{1},x_{2},\cdots,x_{n})$，由于运算${*,\bigoplus,^{-}}$在$B$上封闭，故对于$\langle x_{1},x_{2},\cdots,x_{n}\rangle$的任何赋值$\langle b_{1},b_{2},\cdots,b_{n}\rangle,b_{i}\in B$，有$f(b_{1},b_{2},\cdots,b_{n})\in B$。这表明$f(x_{1},x_{2},\cdots,x_{n})$确定了一个从$B^{n}$到$B$的函数。据此引入如下布尔函数的概念：  
【定义12.42】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数，$f$为一个从$B^{n}$到$B$的函数，如果它能够用$\langle B,*,\oplus,^{-},0,1\rangle$上的$n$元布尔表达式表示，则称该函数为布尔函数。  
对于任意一个给定的布尔函数，如何确定其所对应的布尔表达式呢？现在就来讨论这个问题，首先给出如下布尔表达式极小项的定义  
【定义12.43】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数，给定$n$个布尔变元$x_{1},x_{2},\cdots,x_{n}$，表达式$\widetilde{x}_{1}*\widetilde{x}_{2}*\widetilde{x}_{3}*\cdots*\widetilde{x}_{n}$称为极小项，其中$\tilde{x}_{i}$表示$ x_{i}$或$\overline{{x_{\iota}}}$。  
例如，对于两个布尔变元$x_{1},x_{2}$，其极小项为$x_{1}*x_{2}\,,\ \bar{x}_{1}*x_{2}\,,\ x_{1}*\bar{x}_{2}$和${x}_{1}*{x}_{2}$  。  
容易验证$n$个布尔变元可以构成$\ 2^{n}$个不同的极小项，分别记为$m_{0},m_{1},m_{2},\cdots,m_{2^{n}-1}$，其中下标是二进制数$a_{1}a_{2}\cdots a_{n}$对应的十进制数，其中：  
$$
a_i=\begin{cases}1,&\text{当}\widetilde{x_i}=x_i\text{时}\\0,&\text{当}\widetilde{x_i}=\bar{x_i}\text{时}\end{cases}(i=1, 2, \cdots, n)
$$  
具体可表述为：  
$m_{0}={\bar{x}}_{1}*{\bar{x}}_{2}*\cdots*{\bar{x}}_{n},\quad m_{1}={\bar{x}}_{1}*{\bar{x}}_{2}*\cdots*{\bar{x}}_{n-1}*x_{n},\ \cdots,\quad m_{n}=x_{1}*x_{2}*\cdots*x_{n}$ 不难验证极小项具有如下两个基本性质：  
（1）$m_{i}*m_{j}=0$，当$i\neq j$时；（2）$m_{0}\oplus m_{1}\oplus m_{2}\oplus\cdots\oplus m_{2^{n}-1}=1\,$。  
【定义12.44】设$<\mathrm{B},*,\oplus,\stackrel{\_}{\ },0,1>$布尔代数，称形如：
$$
(\,\alpha_{0}*m_{0}\,)\,\oplus(\alpha_{1}*m_{1})\oplus(\alpha_{2}*m_{2})\oplus\cdots\oplus(\alpha_{2^{n}-1}\oplus m_{2^{n}-1})
$$  
的布尔表达式成为主析取范式，这里$\alpha_{i}$是布尔常元，$m_{i}$是极小项$(i=1,\!2,\!\cdots,2^{n}-1)$.  
因为每个$\alpha_{i}$有$|B|$种取法，故具有$n$个布尔变元的不同主析取范式共有$|\mathrm{B}|^{2^{n}}$个，当$B=${0,1}时有$2^{2^{n}}$个。而$2^{n}$个极小项最多只能构造出$|\mathbf{B}|^{2^{n}}$个不同的主析取范式，所以一个$\mathsf{n}$ 元布尔表达式必等价于这$|\mathbf{B}|^{2^{n}}$个主析取范式之一。又由于任何两个不同的主析取范式显然是不等价的，所以一个n 元布尔表达式都唯一等价于一个主析取范式。可将${ n}$元布尔表达式化成等价的主析取范式，方法与将命题公式换成主析取范式的方法完全一致。  
对于任意给定的一个$ n$元布尔表达式，其${n}$个布尔变元的每一指派，都可确定该表达式在集合B中的一个取值，故每个布尔表达式都代表一个布尔函数。由于$n$个布尔变元的主析取范式最多只有$|\mathrm{B}|^{2^{n}}$个，故布尔表达式最多只能表示$|\mathrm{B}|^{2^{n}}$个不同函数。$B=\{0,1\}$时，从$B^{n}$到$B$的函数共有$2^{2^{n}}$个，主析取范式也有$2^{2^{n}}$个，恰好每一个主析取范式代表一个布尔函数，此时每个函数均可用布尔表达式表示。  
可用同样方法讨论极大项和主合取范式，不再赘述。
![](images/d9aea4daa121e3eccc7b12420a8fb81447c40edfd8e103d7c7a3a0401f26dc77.jpg)  
图 12-14 离散数学的知识体系  
从上述分析讨论不难看出，布尔表达式和布尔函数的运算性质与命题代数的演算基本上相同。因此，可将布尔代数看成是命题代数的一个抽象，将命题代数看成是布尔代数的一个具体实例。事实上，集合代数也是布尔代数的一个具体实例。如图12-14 所示，集合代数和命题（逻辑）代数作为一种理论基础共同支撑了离散数学结构的整个知识体系，同时两者又在抽象布尔代数的层次上实现了完美的统一。",极小项是布尔表达式的一种特殊形式，由布尔变元和布尔常元通过特定运算构成。
布尔表达式,等价关系,主析取范式,,"我们知道，无论是命题代数还是集合代数都可以通过相应的表达式进行计算，集合代数有集合运算表示式，命题代数有命题表达式或命题公式，事实上，可以从更加抽象的布尔代数的角度考察这些运算表达式，或者说可以将这些具体的运算表达式抽象成一般的布尔表达式研究其共同运算性质。由此得到布尔表达式的概念，具体定义如下：  
【定义12.38】设$\langle B,*,\oplus,^{-},0,1\rangle$是任意给定的一个布尔代数，则集合$ B$中的元素称为布尔常元，取值于$ B$中元素的变元称为布尔变元。  
与命题代数类似，使用归纳的方法定义布尔表达式：  
【定义12.39】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数，则 $B$上布尔表达式定义如下：  
（1）$B$中的任何一个布尔常元是布尔表达式；  
（2）$B$中的任何一个布尔变元是布尔表达式；  
（3）如果$e_{1}$和$e_{2}$是布尔表达式，则$\overline{{e_{1}}}$ ，$e_{1}*e_{2}$，$e_{1}\oplus e_{2}$也是布尔表达式；  
（4）只有有限次使用（1）、（2）和（3）所构造的符号串才是布尔表达式。  
【定义12.40】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数，$B$中含有${n}$个相异布尔变元的布尔表达式称为$\mathbf{n}$元布尔表达式，记为$f(x_{1},x_{2},\cdots,x_{n})$，其中$x_{1},x_{2},\cdots,x_{n}$是布尔变元。布尔表达式的值是指将$B$中的布尔常元作为布尔变元$x_{i}(i=1,2,\cdots,n)$的值来代替布尔表达式中相应的布尔变元，而计算出的布尔表达式的值。  
例如，表达式$f(x,y)=(a*x)\oplus({\bar{b}}\oplus y)\oplus(x\oplus{\bar{y}})$是布尔代数$\langle\lbrace0,a,b,1\rbrace,*,\oplus,^{-},0,1\rangle$上的二元布尔表达式。如果对该表达式中布尔变元$x,y$赋初值为$x=a,y=b$，则可得到：  
$$
f(a,b)=(a*a)\oplus\left({\bar{b}}\oplus b\right)\oplus\left(a\oplus{\bar{b}}\right)=a\oplus1\oplus\left(a\oplus{\bar{b}}\right)=1
$$  
【定义12.41】设$f_{1}(x_{1},x_{2},\cdots,x_{n})$和$f_{2}(x_{1},x_{2},\cdots,x_{n})$是$\langle B,*,\oplus,^{-},0,1\rangle$上的两个布尔表达式，如果对${x_{i}}$任意的赋值即$x_{i}=b_{i},b_{i}\in B,(i=1,2,\cdots,n)$均有：  
$$
f_{1}(b_{1},b_{2},\cdots,b_{n})=f_{2}(b_{1},b_{2},\cdots,b_{n})\quad\text{(12-26)}
$$  
则称这两个布尔表达式为等价或等值，记为$f_{1}(x_{1},x_{2},\cdots,x_{n})=f_{2}(x_{1},x_{2},\cdots,x_{n})\,。$  
如果要验证两个布尔表达式是等价的，一般情况下可以采取如下两种方法：一种是直接验证，另外一种是利用布尔代数的运算律进行有限次的推导。例如，对于$\langle B,*,\oplus,^{-},0,1\rangle$上两个布尔表达式：  
$$
f_{1}(x_{1},x_{2},x_{3})=x_{1}*(x_{2}\oplus x_{3}),\;\;f_{2}(x_{1},x_{2},x_{3})=(x_{1}*x_{2})\oplus(x_{1}*x_{3})
$$  
对于$\forall x_{i}=b_{i},b_{i}\in B,(i=1,2,3)$，可以直接验证$f_{1}(x_{1},x_{2},x_{3})=f_{2}(x_{1},x_{2},x_{3})$。也可以利用分配律验证其等价性。这与命题逻辑中的真值表法和演算法非常类似。  
对于布尔代数$\langle B,*,\oplus,^{-},0,1\rangle$上任意一个布尔表达式$f(x_{1},x_{2},\cdots,x_{n})$，由于运算${*,\bigoplus,^{-}}$在$B$上封闭，故对于$\langle x_{1},x_{2},\cdots,x_{n}\rangle$的任何赋值$\langle b_{1},b_{2},\cdots,b_{n}\rangle,b_{i}\in B$，有$f(b_{1},b_{2},\cdots,b_{n})\in B$。这表明$f(x_{1},x_{2},\cdots,x_{n})$确定了一个从$B^{n}$到$B$的函数。据此引入如下布尔函数的概念：  
【定义12.42】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数，$f$为一个从$B^{n}$到$B$的函数，如果它能够用$\langle B,*,\oplus,^{-},0,1\rangle$上的$n$元布尔表达式表示，则称该函数为布尔函数。  
对于任意一个给定的布尔函数，如何确定其所对应的布尔表达式呢？现在就来讨论这个问题，首先给出如下布尔表达式极小项的定义  
【定义12.43】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数，给定$n$个布尔变元$x_{1},x_{2},\cdots,x_{n}$，表达式$\widetilde{x}_{1}*\widetilde{x}_{2}*\widetilde{x}_{3}*\cdots*\widetilde{x}_{n}$称为极小项，其中$\tilde{x}_{i}$表示$ x_{i}$或$\overline{{x_{\iota}}}$。  
例如，对于两个布尔变元$x_{1},x_{2}$，其极小项为$x_{1}*x_{2}\,,\ \bar{x}_{1}*x_{2}\,,\ x_{1}*\bar{x}_{2}$和${x}_{1}*{x}_{2}$  。  
容易验证$n$个布尔变元可以构成$\ 2^{n}$个不同的极小项，分别记为$m_{0},m_{1},m_{2},\cdots,m_{2^{n}-1}$，其中下标是二进制数$a_{1}a_{2}\cdots a_{n}$对应的十进制数，其中：  
$$
a_i=\begin{cases}1,&\text{当}\widetilde{x_i}=x_i\text{时}\\0,&\text{当}\widetilde{x_i}=\bar{x_i}\text{时}\end{cases}(i=1, 2, \cdots, n)
$$  
具体可表述为：  
$m_{0}={\bar{x}}_{1}*{\bar{x}}_{2}*\cdots*{\bar{x}}_{n},\quad m_{1}={\bar{x}}_{1}*{\bar{x}}_{2}*\cdots*{\bar{x}}_{n-1}*x_{n},\ \cdots,\quad m_{n}=x_{1}*x_{2}*\cdots*x_{n}$ 不难验证极小项具有如下两个基本性质：  
（1）$m_{i}*m_{j}=0$，当$i\neq j$时；（2）$m_{0}\oplus m_{1}\oplus m_{2}\oplus\cdots\oplus m_{2^{n}-1}=1\,$。  
【定义12.44】设$<\mathrm{B},*,\oplus,\stackrel{\_}{\ },0,1>$布尔代数，称形如：
$$
(\,\alpha_{0}*m_{0}\,)\,\oplus(\alpha_{1}*m_{1})\oplus(\alpha_{2}*m_{2})\oplus\cdots\oplus(\alpha_{2^{n}-1}\oplus m_{2^{n}-1})
$$  
的布尔表达式成为主析取范式，这里$\alpha_{i}$是布尔常元，$m_{i}$是极小项$(i=1,\!2,\!\cdots,2^{n}-1)$.  
因为每个$\alpha_{i}$有$|B|$种取法，故具有$n$个布尔变元的不同主析取范式共有$|\mathrm{B}|^{2^{n}}$个，当$B=${0,1}时有$2^{2^{n}}$个。而$2^{n}$个极小项最多只能构造出$|\mathbf{B}|^{2^{n}}$个不同的主析取范式，所以一个$\mathsf{n}$ 元布尔表达式必等价于这$|\mathbf{B}|^{2^{n}}$个主析取范式之一。又由于任何两个不同的主析取范式显然是不等价的，所以一个n 元布尔表达式都唯一等价于一个主析取范式。可将${ n}$元布尔表达式化成等价的主析取范式，方法与将命题公式换成主析取范式的方法完全一致。  
对于任意给定的一个$ n$元布尔表达式，其${n}$个布尔变元的每一指派，都可确定该表达式在集合B中的一个取值，故每个布尔表达式都代表一个布尔函数。由于$n$个布尔变元的主析取范式最多只有$|\mathrm{B}|^{2^{n}}$个，故布尔表达式最多只能表示$|\mathrm{B}|^{2^{n}}$个不同函数。$B=\{0,1\}$时，从$B^{n}$到$B$的函数共有$2^{2^{n}}$个，主析取范式也有$2^{2^{n}}$个，恰好每一个主析取范式代表一个布尔函数，此时每个函数均可用布尔表达式表示。  
可用同样方法讨论极大项和主合取范式，不再赘述。
![](images/d9aea4daa121e3eccc7b12420a8fb81447c40edfd8e103d7c7a3a0401f26dc77.jpg)  
图 12-14 离散数学的知识体系  
从上述分析讨论不难看出，布尔表达式和布尔函数的运算性质与命题代数的演算基本上相同。因此，可将布尔代数看成是命题代数的一个抽象，将命题代数看成是布尔代数的一个具体实例。事实上，集合代数也是布尔代数的一个具体实例。如图12-14 所示，集合代数和命题（逻辑）代数作为一种理论基础共同支撑了离散数学结构的整个知识体系，同时两者又在抽象布尔代数的层次上实现了完美的统一。",每个布尔表达式都唯一等价于一个主析取范式，主析取范式是布尔表达式的一种标准形式。
布尔函数,表示关系,主析取范式,,"我们知道，无论是命题代数还是集合代数都可以通过相应的表达式进行计算，集合代数有集合运算表示式，命题代数有命题表达式或命题公式，事实上，可以从更加抽象的布尔代数的角度考察这些运算表达式，或者说可以将这些具体的运算表达式抽象成一般的布尔表达式研究其共同运算性质。由此得到布尔表达式的概念，具体定义如下：  
【定义12.38】设$\langle B,*,\oplus,^{-},0,1\rangle$是任意给定的一个布尔代数，则集合$ B$中的元素称为布尔常元，取值于$ B$中元素的变元称为布尔变元。  
与命题代数类似，使用归纳的方法定义布尔表达式：  
【定义12.39】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数，则 $B$上布尔表达式定义如下：  
（1）$B$中的任何一个布尔常元是布尔表达式；  
（2）$B$中的任何一个布尔变元是布尔表达式；  
（3）如果$e_{1}$和$e_{2}$是布尔表达式，则$\overline{{e_{1}}}$ ，$e_{1}*e_{2}$，$e_{1}\oplus e_{2}$也是布尔表达式；  
（4）只有有限次使用（1）、（2）和（3）所构造的符号串才是布尔表达式。  
【定义12.40】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数，$B$中含有${n}$个相异布尔变元的布尔表达式称为$\mathbf{n}$元布尔表达式，记为$f(x_{1},x_{2},\cdots,x_{n})$，其中$x_{1},x_{2},\cdots,x_{n}$是布尔变元。布尔表达式的值是指将$B$中的布尔常元作为布尔变元$x_{i}(i=1,2,\cdots,n)$的值来代替布尔表达式中相应的布尔变元，而计算出的布尔表达式的值。  
例如，表达式$f(x,y)=(a*x)\oplus({\bar{b}}\oplus y)\oplus(x\oplus{\bar{y}})$是布尔代数$\langle\lbrace0,a,b,1\rbrace,*,\oplus,^{-},0,1\rangle$上的二元布尔表达式。如果对该表达式中布尔变元$x,y$赋初值为$x=a,y=b$，则可得到：  
$$
f(a,b)=(a*a)\oplus\left({\bar{b}}\oplus b\right)\oplus\left(a\oplus{\bar{b}}\right)=a\oplus1\oplus\left(a\oplus{\bar{b}}\right)=1
$$  
【定义12.41】设$f_{1}(x_{1},x_{2},\cdots,x_{n})$和$f_{2}(x_{1},x_{2},\cdots,x_{n})$是$\langle B,*,\oplus,^{-},0,1\rangle$上的两个布尔表达式，如果对${x_{i}}$任意的赋值即$x_{i}=b_{i},b_{i}\in B,(i=1,2,\cdots,n)$均有：  
$$
f_{1}(b_{1},b_{2},\cdots,b_{n})=f_{2}(b_{1},b_{2},\cdots,b_{n})\quad\text{(12-26)}
$$  
则称这两个布尔表达式为等价或等值，记为$f_{1}(x_{1},x_{2},\cdots,x_{n})=f_{2}(x_{1},x_{2},\cdots,x_{n})\,。$  
如果要验证两个布尔表达式是等价的，一般情况下可以采取如下两种方法：一种是直接验证，另外一种是利用布尔代数的运算律进行有限次的推导。例如，对于$\langle B,*,\oplus,^{-},0,1\rangle$上两个布尔表达式：  
$$
f_{1}(x_{1},x_{2},x_{3})=x_{1}*(x_{2}\oplus x_{3}),\;\;f_{2}(x_{1},x_{2},x_{3})=(x_{1}*x_{2})\oplus(x_{1}*x_{3})
$$  
对于$\forall x_{i}=b_{i},b_{i}\in B,(i=1,2,3)$，可以直接验证$f_{1}(x_{1},x_{2},x_{3})=f_{2}(x_{1},x_{2},x_{3})$。也可以利用分配律验证其等价性。这与命题逻辑中的真值表法和演算法非常类似。  
对于布尔代数$\langle B,*,\oplus,^{-},0,1\rangle$上任意一个布尔表达式$f(x_{1},x_{2},\cdots,x_{n})$，由于运算${*,\bigoplus,^{-}}$在$B$上封闭，故对于$\langle x_{1},x_{2},\cdots,x_{n}\rangle$的任何赋值$\langle b_{1},b_{2},\cdots,b_{n}\rangle,b_{i}\in B$，有$f(b_{1},b_{2},\cdots,b_{n})\in B$。这表明$f(x_{1},x_{2},\cdots,x_{n})$确定了一个从$B^{n}$到$B$的函数。据此引入如下布尔函数的概念：  
【定义12.42】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数，$f$为一个从$B^{n}$到$B$的函数，如果它能够用$\langle B,*,\oplus,^{-},0,1\rangle$上的$n$元布尔表达式表示，则称该函数为布尔函数。  
对于任意一个给定的布尔函数，如何确定其所对应的布尔表达式呢？现在就来讨论这个问题，首先给出如下布尔表达式极小项的定义  
【定义12.43】设$\langle B,*,\oplus,^{-},0,1\rangle$是一个布尔代数，给定$n$个布尔变元$x_{1},x_{2},\cdots,x_{n}$，表达式$\widetilde{x}_{1}*\widetilde{x}_{2}*\widetilde{x}_{3}*\cdots*\widetilde{x}_{n}$称为极小项，其中$\tilde{x}_{i}$表示$ x_{i}$或$\overline{{x_{\iota}}}$。  
例如，对于两个布尔变元$x_{1},x_{2}$，其极小项为$x_{1}*x_{2}\,,\ \bar{x}_{1}*x_{2}\,,\ x_{1}*\bar{x}_{2}$和${x}_{1}*{x}_{2}$  。  
容易验证$n$个布尔变元可以构成$\ 2^{n}$个不同的极小项，分别记为$m_{0},m_{1},m_{2},\cdots,m_{2^{n}-1}$，其中下标是二进制数$a_{1}a_{2}\cdots a_{n}$对应的十进制数，其中：  
$$
a_i=\begin{cases}1,&\text{当}\widetilde{x_i}=x_i\text{时}\\0,&\text{当}\widetilde{x_i}=\bar{x_i}\text{时}\end{cases}(i=1, 2, \cdots, n)
$$  
具体可表述为：  
$m_{0}={\bar{x}}_{1}*{\bar{x}}_{2}*\cdots*{\bar{x}}_{n},\quad m_{1}={\bar{x}}_{1}*{\bar{x}}_{2}*\cdots*{\bar{x}}_{n-1}*x_{n},\ \cdots,\quad m_{n}=x_{1}*x_{2}*\cdots*x_{n}$ 不难验证极小项具有如下两个基本性质：  
（1）$m_{i}*m_{j}=0$，当$i\neq j$时；（2）$m_{0}\oplus m_{1}\oplus m_{2}\oplus\cdots\oplus m_{2^{n}-1}=1\,$。  
【定义12.44】设$<\mathrm{B},*,\oplus,\stackrel{\_}{\ },0,1>$布尔代数，称形如：
$$
(\,\alpha_{0}*m_{0}\,)\,\oplus(\alpha_{1}*m_{1})\oplus(\alpha_{2}*m_{2})\oplus\cdots\oplus(\alpha_{2^{n}-1}\oplus m_{2^{n}-1})
$$  
的布尔表达式成为主析取范式，这里$\alpha_{i}$是布尔常元，$m_{i}$是极小项$(i=1,\!2,\!\cdots,2^{n}-1)$.  
因为每个$\alpha_{i}$有$|B|$种取法，故具有$n$个布尔变元的不同主析取范式共有$|\mathrm{B}|^{2^{n}}$个，当$B=${0,1}时有$2^{2^{n}}$个。而$2^{n}$个极小项最多只能构造出$|\mathbf{B}|^{2^{n}}$个不同的主析取范式，所以一个$\mathsf{n}$ 元布尔表达式必等价于这$|\mathbf{B}|^{2^{n}}$个主析取范式之一。又由于任何两个不同的主析取范式显然是不等价的，所以一个n 元布尔表达式都唯一等价于一个主析取范式。可将${ n}$元布尔表达式化成等价的主析取范式，方法与将命题公式换成主析取范式的方法完全一致。  
对于任意给定的一个$ n$元布尔表达式，其${n}$个布尔变元的每一指派，都可确定该表达式在集合B中的一个取值，故每个布尔表达式都代表一个布尔函数。由于$n$个布尔变元的主析取范式最多只有$|\mathrm{B}|^{2^{n}}$个，故布尔表达式最多只能表示$|\mathrm{B}|^{2^{n}}$个不同函数。$B=\{0,1\}$时，从$B^{n}$到$B$的函数共有$2^{2^{n}}$个，主析取范式也有$2^{2^{n}}$个，恰好每一个主析取范式代表一个布尔函数，此时每个函数均可用布尔表达式表示。  
可用同样方法讨论极大项和主合取范式，不再赘述。
![](images/d9aea4daa121e3eccc7b12420a8fb81447c40edfd8e103d7c7a3a0401f26dc77.jpg)  
图 12-14 离散数学的知识体系  
从上述分析讨论不难看出，布尔表达式和布尔函数的运算性质与命题代数的演算基本上相同。因此，可将布尔代数看成是命题代数的一个抽象，将命题代数看成是布尔代数的一个具体实例。事实上，集合代数也是布尔代数的一个具体实例。如图12-14 所示，集合代数和命题（逻辑）代数作为一种理论基础共同支撑了离散数学结构的整个知识体系，同时两者又在抽象布尔代数的层次上实现了完美的统一。",每个布尔函数都可以用主析取范式表示，主析取范式是布尔函数的一种标准表示形式。
整数,研究对象,整数理论,,"整数作为一种最基本的离散量和离散结构不仅是离散数学的研究对象，而且其自身也是研究其它离散结构的一项基本工具，在离散量的度量、计数和算法设计等方面发挥重要的基础性作用。整数是人类最早认识和使用的数，专门研究整数及其性质的整数理论是一个具有几千年历史的非常古老的数学分支。在很长一段时期内，整数理论被认为仅仅是思想的体操、数学思维能力的训练工具，其实用性并没有得到充分重视。著名数学家数学王子高斯就曾给出这样的评价：如果说数学是科学的皇后，那么整数理论则是皇后头上美丽的皇冠。意指其仅仅是漂亮而不够实用。直到20 世纪70 年代基于整数模余运算理论的非对称加密算法被设计出来并取得成功应用，整数理论的实用性才得到广泛重视。事实上，算法概念正是诞生于整数的算术运算，这使得整数理论与计算机算法有着一种天然的紧密联系。计算机学科的诞生与兴起让整数理论这门古老的学科重新焕发出新的生命并得到蓬勃发展。目前，整数理论已经成为算法设计与算法度量的一项基本工具，在散列函数构造、伪随机数生成、信息编码与加密等多个领域得到广泛应用。其实除整数之外，离散数学中很多其它离散结构模型，例如图模型、关系模型、群代数结构模型等，也都是通过相关算法在计算机领域发挥重要作用。因此，算法设计技术是学习与应用离散数学所必备的基本知识。  
综上所述，作为学习离散数学的另一入门基础，本章比较系统地介绍整数理论与算法设计的基本知识，具体包括整除的基本概念与运算性质、模余运算的基础知识、同余方程及其解法、非对称加密算法、算法设计的基本知识、算法设计的基本策略与应用等。",整数是整数理论的研究对象
整数,基础工具,算法设计,,"整数作为一种最基本的离散量和离散结构不仅是离散数学的研究对象，而且其自身也是研究其它离散结构的一项基本工具，在离散量的度量、计数和算法设计等方面发挥重要的基础性作用。整数是人类最早认识和使用的数，专门研究整数及其性质的整数理论是一个具有几千年历史的非常古老的数学分支。在很长一段时期内，整数理论被认为仅仅是思想的体操、数学思维能力的训练工具，其实用性并没有得到充分重视。著名数学家数学王子高斯就曾给出这样的评价：如果说数学是科学的皇后，那么整数理论则是皇后头上美丽的皇冠。意指其仅仅是漂亮而不够实用。直到20 世纪70 年代基于整数模余运算理论的非对称加密算法被设计出来并取得成功应用，整数理论的实用性才得到广泛重视。事实上，算法概念正是诞生于整数的算术运算，这使得整数理论与计算机算法有着一种天然的紧密联系。计算机学科的诞生与兴起让整数理论这门古老的学科重新焕发出新的生命并得到蓬勃发展。目前，整数理论已经成为算法设计与算法度量的一项基本工具，在散列函数构造、伪随机数生成、信息编码与加密等多个领域得到广泛应用。其实除整数之外，离散数学中很多其它离散结构模型，例如图模型、关系模型、群代数结构模型等，也都是通过相关算法在计算机领域发挥重要作用。因此，算法设计技术是学习与应用离散数学所必备的基本知识。  
综上所述，作为学习离散数学的另一入门基础，本章比较系统地介绍整数理论与算法设计的基本知识，具体包括整除的基本概念与运算性质、模余运算的基础知识、同余方程及其解法、非对称加密算法、算法设计的基本知识、算法设计的基本策略与应用等。",整数在算法设计中发挥重要的基础性作用
整数理论,理论基础,非对称加密算法,,"整数作为一种最基本的离散量和离散结构不仅是离散数学的研究对象，而且其自身也是研究其它离散结构的一项基本工具，在离散量的度量、计数和算法设计等方面发挥重要的基础性作用。整数是人类最早认识和使用的数，专门研究整数及其性质的整数理论是一个具有几千年历史的非常古老的数学分支。在很长一段时期内，整数理论被认为仅仅是思想的体操、数学思维能力的训练工具，其实用性并没有得到充分重视。著名数学家数学王子高斯就曾给出这样的评价：如果说数学是科学的皇后，那么整数理论则是皇后头上美丽的皇冠。意指其仅仅是漂亮而不够实用。直到20 世纪70 年代基于整数模余运算理论的非对称加密算法被设计出来并取得成功应用，整数理论的实用性才得到广泛重视。事实上，算法概念正是诞生于整数的算术运算，这使得整数理论与计算机算法有着一种天然的紧密联系。计算机学科的诞生与兴起让整数理论这门古老的学科重新焕发出新的生命并得到蓬勃发展。目前，整数理论已经成为算法设计与算法度量的一项基本工具，在散列函数构造、伪随机数生成、信息编码与加密等多个领域得到广泛应用。其实除整数之外，离散数学中很多其它离散结构模型，例如图模型、关系模型、群代数结构模型等，也都是通过相关算法在计算机领域发挥重要作用。因此，算法设计技术是学习与应用离散数学所必备的基本知识。  
综上所述，作为学习离散数学的另一入门基础，本章比较系统地介绍整数理论与算法设计的基本知识，具体包括整除的基本概念与运算性质、模余运算的基础知识、同余方程及其解法、非对称加密算法、算法设计的基本知识、算法设计的基本策略与应用等。",非对称加密算法基于整数模余运算理论
整数理论,基本工具,算法设计,,"整数作为一种最基本的离散量和离散结构不仅是离散数学的研究对象，而且其自身也是研究其它离散结构的一项基本工具，在离散量的度量、计数和算法设计等方面发挥重要的基础性作用。整数是人类最早认识和使用的数，专门研究整数及其性质的整数理论是一个具有几千年历史的非常古老的数学分支。在很长一段时期内，整数理论被认为仅仅是思想的体操、数学思维能力的训练工具，其实用性并没有得到充分重视。著名数学家数学王子高斯就曾给出这样的评价：如果说数学是科学的皇后，那么整数理论则是皇后头上美丽的皇冠。意指其仅仅是漂亮而不够实用。直到20 世纪70 年代基于整数模余运算理论的非对称加密算法被设计出来并取得成功应用，整数理论的实用性才得到广泛重视。事实上，算法概念正是诞生于整数的算术运算，这使得整数理论与计算机算法有着一种天然的紧密联系。计算机学科的诞生与兴起让整数理论这门古老的学科重新焕发出新的生命并得到蓬勃发展。目前，整数理论已经成为算法设计与算法度量的一项基本工具，在散列函数构造、伪随机数生成、信息编码与加密等多个领域得到广泛应用。其实除整数之外，离散数学中很多其它离散结构模型，例如图模型、关系模型、群代数结构模型等，也都是通过相关算法在计算机领域发挥重要作用。因此，算法设计技术是学习与应用离散数学所必备的基本知识。  
综上所述，作为学习离散数学的另一入门基础，本章比较系统地介绍整数理论与算法设计的基本知识，具体包括整除的基本概念与运算性质、模余运算的基础知识、同余方程及其解法、非对称加密算法、算法设计的基本知识、算法设计的基本策略与应用等。",整数理论是算法设计与算法度量的一项基本工具
模余运算,理论基础,非对称加密算法,,"整数作为一种最基本的离散量和离散结构不仅是离散数学的研究对象，而且其自身也是研究其它离散结构的一项基本工具，在离散量的度量、计数和算法设计等方面发挥重要的基础性作用。整数是人类最早认识和使用的数，专门研究整数及其性质的整数理论是一个具有几千年历史的非常古老的数学分支。在很长一段时期内，整数理论被认为仅仅是思想的体操、数学思维能力的训练工具，其实用性并没有得到充分重视。著名数学家数学王子高斯就曾给出这样的评价：如果说数学是科学的皇后，那么整数理论则是皇后头上美丽的皇冠。意指其仅仅是漂亮而不够实用。直到20 世纪70 年代基于整数模余运算理论的非对称加密算法被设计出来并取得成功应用，整数理论的实用性才得到广泛重视。事实上，算法概念正是诞生于整数的算术运算，这使得整数理论与计算机算法有着一种天然的紧密联系。计算机学科的诞生与兴起让整数理论这门古老的学科重新焕发出新的生命并得到蓬勃发展。目前，整数理论已经成为算法设计与算法度量的一项基本工具，在散列函数构造、伪随机数生成、信息编码与加密等多个领域得到广泛应用。其实除整数之外，离散数学中很多其它离散结构模型，例如图模型、关系模型、群代数结构模型等，也都是通过相关算法在计算机领域发挥重要作用。因此，算法设计技术是学习与应用离散数学所必备的基本知识。  
综上所述，作为学习离散数学的另一入门基础，本章比较系统地介绍整数理论与算法设计的基本知识，具体包括整除的基本概念与运算性质、模余运算的基础知识、同余方程及其解法、非对称加密算法、算法设计的基本知识、算法设计的基本策略与应用等。",非对称加密算法基于模余运算理论
同余方程,组成部分,整数理论,,"整数作为一种最基本的离散量和离散结构不仅是离散数学的研究对象，而且其自身也是研究其它离散结构的一项基本工具，在离散量的度量、计数和算法设计等方面发挥重要的基础性作用。整数是人类最早认识和使用的数，专门研究整数及其性质的整数理论是一个具有几千年历史的非常古老的数学分支。在很长一段时期内，整数理论被认为仅仅是思想的体操、数学思维能力的训练工具，其实用性并没有得到充分重视。著名数学家数学王子高斯就曾给出这样的评价：如果说数学是科学的皇后，那么整数理论则是皇后头上美丽的皇冠。意指其仅仅是漂亮而不够实用。直到20 世纪70 年代基于整数模余运算理论的非对称加密算法被设计出来并取得成功应用，整数理论的实用性才得到广泛重视。事实上，算法概念正是诞生于整数的算术运算，这使得整数理论与计算机算法有着一种天然的紧密联系。计算机学科的诞生与兴起让整数理论这门古老的学科重新焕发出新的生命并得到蓬勃发展。目前，整数理论已经成为算法设计与算法度量的一项基本工具，在散列函数构造、伪随机数生成、信息编码与加密等多个领域得到广泛应用。其实除整数之外，离散数学中很多其它离散结构模型，例如图模型、关系模型、群代数结构模型等，也都是通过相关算法在计算机领域发挥重要作用。因此，算法设计技术是学习与应用离散数学所必备的基本知识。  
综上所述，作为学习离散数学的另一入门基础，本章比较系统地介绍整数理论与算法设计的基本知识，具体包括整除的基本概念与运算性质、模余运算的基础知识、同余方程及其解法、非对称加密算法、算法设计的基本知识、算法设计的基本策略与应用等。",同余方程是整数理论的一部分
整数,包含,整数除法,,本节主要介绍整数理论中若干最基本的知识。我们知道，整数相加、相减、相乘的结果都是整数，而除法结果却不一定是整数。因此，整数理论研究的重点自然是运算结果相对比较复杂的除法。通过整数的除法运算可以得到整数的素因数分解，由此我们便可以素数为基本构件来考察或窥探整数的离散结构特征与变化规律。在这个过程中，素数作为构造整数的基本构件，其性质与分布规律自然是整数理论的重要内容。因此，本节内容主要包括整数与整数除法的概念、公因数与公倍数、整数的素因数分解、素数的性质及相关算法等。,整数理论包括整数除法的概念
整数除法,推导,素因数分解,,本节主要介绍整数理论中若干最基本的知识。我们知道，整数相加、相减、相乘的结果都是整数，而除法结果却不一定是整数。因此，整数理论研究的重点自然是运算结果相对比较复杂的除法。通过整数的除法运算可以得到整数的素因数分解，由此我们便可以素数为基本构件来考察或窥探整数的离散结构特征与变化规律。在这个过程中，素数作为构造整数的基本构件，其性质与分布规律自然是整数理论的重要内容。因此，本节内容主要包括整数与整数除法的概念、公因数与公倍数、整数的素因数分解、素数的性质及相关算法等。,通过整数除法运算可以得到整数的素因数分解
素因数分解,基于,素数,,本节主要介绍整数理论中若干最基本的知识。我们知道，整数相加、相减、相乘的结果都是整数，而除法结果却不一定是整数。因此，整数理论研究的重点自然是运算结果相对比较复杂的除法。通过整数的除法运算可以得到整数的素因数分解，由此我们便可以素数为基本构件来考察或窥探整数的离散结构特征与变化规律。在这个过程中，素数作为构造整数的基本构件，其性质与分布规律自然是整数理论的重要内容。因此，本节内容主要包括整数与整数除法的概念、公因数与公倍数、整数的素因数分解、素数的性质及相关算法等。,素因数分解基于素数作为基本构件
整数,包含,公因数与公倍数,,本节主要介绍整数理论中若干最基本的知识。我们知道，整数相加、相减、相乘的结果都是整数，而除法结果却不一定是整数。因此，整数理论研究的重点自然是运算结果相对比较复杂的除法。通过整数的除法运算可以得到整数的素因数分解，由此我们便可以素数为基本构件来考察或窥探整数的离散结构特征与变化规律。在这个过程中，素数作为构造整数的基本构件，其性质与分布规律自然是整数理论的重要内容。因此，本节内容主要包括整数与整数除法的概念、公因数与公倍数、整数的素因数分解、素数的性质及相关算法等。,整数理论包括公因数与公倍数的概念
素数,涉及,相关算法,,本节主要介绍整数理论中若干最基本的知识。我们知道，整数相加、相减、相乘的结果都是整数，而除法结果却不一定是整数。因此，整数理论研究的重点自然是运算结果相对比较复杂的除法。通过整数的除法运算可以得到整数的素因数分解，由此我们便可以素数为基本构件来考察或窥探整数的离散结构特征与变化规律。在这个过程中，素数作为构造整数的基本构件，其性质与分布规律自然是整数理论的重要内容。因此，本节内容主要包括整数与整数除法的概念、公因数与公倍数、整数的素因数分解、素数的性质及相关算法等。,素数的性质及相关算法是整数理论的重要内容
整数,包含,整除,,"在第一章，我们得到自然数和自然数集的定义。在自然数集中加入每个非零元素的相反数就得到整数集合，整数集中每个元素称为整数。也就是说，对于整数集合$z$，有：  
$$
Z\!=\!\{\cdots\!,\,\!-4,\,\!-3,\,\!-2,\,\!-1,\,0,\,1,\,2,\,3,\,4,\,\cdots\}
$$  
对于整数，我们主要考察其除法运算，包括整除和带余除法，由此可以得到倍数与因子、素数与合数、商与余数的相关概念和性质。  
首先在整数及其乘法运算基础上，考察整除的概念与性质。  
【定义2.1】假设$a$ 和$b$ 是任意给定的两个整数且$a\neq0$，若存在整数$q$，满足$b=a\cdot q($其中“∙”表示普通数乘运算，通常将其省略)，则称$\pmb{a}$ 能整除$\pmb{b}$，或$\pmb{b}$ 能被$\pmb{a}$ 整除，记为a|b。此时，又称$a$ 是$b$ 的因子或$b$ 是$a$ 的倍数。若不存在任何整数$q$，满足$b=a q$，则称$\pmb{a}$ 不能整除$\pmb{b}$，或$\pmb{b}$ 不能被$\pmb{a}$ 整除，记为$a\nmid b$。  
例如：5|25，13 ∤120，7|49，13|0，$^{-3}\vert$-12，9 ∤−56；8 的因子有$\pm1$，$\pm2$，$\pm4$和$\pm8$，7的因子有$\pm1$和$\pm7$。显然，对于任意一个给定的整数$a$，它至少能够被$\pm1$或$\pm n$整除。因此，这四个是$a$ 的因子，称其为$a$ 的平凡因子。$a$ 的其它因子称为非平凡因子。  
【定义2.2】对于任意一个给定的非零整数$a$，若$a\ne\pm1$且没有非平凡因子，则称$a$ 为素数或质数；否则称$a$ 为合数。  
从一定意义上讲，素数是构成整数的基本要素，在整数理论中具有极其重要的地位。若非特别说明，我们所说的素数都是指正素数。2 是第一个正素数，其后还有3, 5, 7, 11,…, 等等。我们还会后续相关内容中详细讨论素数的性质与应用。  
例如，整数2, 3, 5, 7, 11, 13 都是素数，而4, 10, 16, 21 都不是素数。  
对于一个不是很大的整数，显然可用一个比较简单的方法来判定一个大于2 的正整数$b$是否为素数：用从2 到$b-1$的每一个整数去除$b$，如果这些整数都不是$b$ 的因子，那么$b$是素数。注意到：若$a k=b$，则$a$ 或$k$ 小于或等于$\sqrt{b}$。由此可知，如果$b$ 不是素数，那么它必有一个因子$k$ 满足不等式$1<k\leq{\sqrt{b}}$ 。因此，为得到更高的效率，只需在这个范围里检验因子。同样，如果$b$ 有一偶数因子，那么2 一定是该因子的一个因子。因此，在通过2 的整除性检验后，可以跳过所有偶数。要判断一个很大的整数是否为素数则不是一件容易的事情，我们将在本章后续的相关部分具体介绍整数集合中大素数的分布和查找知识。  
整数的整除运算具有如下基本性质：  
【定理2.1】假设$a,b,c$ 是3 个任意给定的整数，则有：  
（1）$a|b$ 当且仅当$\pm a|\pm b$；  
（2）若$a|b,\ b|c$，则 $a|c$；  
（3）若$;b|a_{i},\;\;i=1,\;\;2,\;\;\cdots,\;\;k$，则 $b|a_{1}x_{1}+a_{2}x_{2}+\cdots+a_{k}x_{k}$，此处 $x_{i}(i=1,\ \ 2$，$\cdots,\;\;k)$也是任意的整数；  
（4）若$b|a$，则 $b p|a p$，此处$p$ 是任意非零整数；  
（5）若$b|a$，$a\neq0$，则 $|b|\leq|a|$； 下面仅证明（3）和（5），其余性质的证明与此类似，读者可自行给出。  
根据整除的定义，我们知道任意两个整数之间并不一定满足整除关系。为使整数能够正常进行除法运算，必须对整除概念进行推广。事实上，对于任意两个整数，虽然它们之间不一定具有整除关系，但总存在如下关系：  
【定理2.2】假设$a$ 和$b$ 是任意给定的两个整数且$a\neq0$，则必然存在唯一确定的一对整数$q$ 和$r$，满足下列等式：  
$$
b=a q+r,\;\;0\leq r<|a|\tag{2-1}
$$  
此时称整数$a$ 为除数、$b$ 为被除数、$q$为$b$ 除以$a$的商、$r$为$b$ 除以$a$ 的余数。",整除是整数除法运算的一种情况
整数,包含,带余除法,,"在第一章，我们得到自然数和自然数集的定义。在自然数集中加入每个非零元素的相反数就得到整数集合，整数集中每个元素称为整数。也就是说，对于整数集合$z$，有：  
$$
Z\!=\!\{\cdots\!,\,\!-4,\,\!-3,\,\!-2,\,\!-1,\,0,\,1,\,2,\,3,\,4,\,\cdots\}
$$  
对于整数，我们主要考察其除法运算，包括整除和带余除法，由此可以得到倍数与因子、素数与合数、商与余数的相关概念和性质。  
首先在整数及其乘法运算基础上，考察整除的概念与性质。  
【定义2.1】假设$a$ 和$b$ 是任意给定的两个整数且$a\neq0$，若存在整数$q$，满足$b=a\cdot q($其中“∙”表示普通数乘运算，通常将其省略)，则称$\pmb{a}$ 能整除$\pmb{b}$，或$\pmb{b}$ 能被$\pmb{a}$ 整除，记为a|b。此时，又称$a$ 是$b$ 的因子或$b$ 是$a$ 的倍数。若不存在任何整数$q$，满足$b=a q$，则称$\pmb{a}$ 不能整除$\pmb{b}$，或$\pmb{b}$ 不能被$\pmb{a}$ 整除，记为$a\nmid b$。  
例如：5|25，13 ∤120，7|49，13|0，$^{-3}\vert$-12，9 ∤−56；8 的因子有$\pm1$，$\pm2$，$\pm4$和$\pm8$，7的因子有$\pm1$和$\pm7$。显然，对于任意一个给定的整数$a$，它至少能够被$\pm1$或$\pm n$整除。因此，这四个是$a$ 的因子，称其为$a$ 的平凡因子。$a$ 的其它因子称为非平凡因子。  
【定义2.2】对于任意一个给定的非零整数$a$，若$a\ne\pm1$且没有非平凡因子，则称$a$ 为素数或质数；否则称$a$ 为合数。  
从一定意义上讲，素数是构成整数的基本要素，在整数理论中具有极其重要的地位。若非特别说明，我们所说的素数都是指正素数。2 是第一个正素数，其后还有3, 5, 7, 11,…, 等等。我们还会后续相关内容中详细讨论素数的性质与应用。  
例如，整数2, 3, 5, 7, 11, 13 都是素数，而4, 10, 16, 21 都不是素数。  
对于一个不是很大的整数，显然可用一个比较简单的方法来判定一个大于2 的正整数$b$是否为素数：用从2 到$b-1$的每一个整数去除$b$，如果这些整数都不是$b$ 的因子，那么$b$是素数。注意到：若$a k=b$，则$a$ 或$k$ 小于或等于$\sqrt{b}$。由此可知，如果$b$ 不是素数，那么它必有一个因子$k$ 满足不等式$1<k\leq{\sqrt{b}}$ 。因此，为得到更高的效率，只需在这个范围里检验因子。同样，如果$b$ 有一偶数因子，那么2 一定是该因子的一个因子。因此，在通过2 的整除性检验后，可以跳过所有偶数。要判断一个很大的整数是否为素数则不是一件容易的事情，我们将在本章后续的相关部分具体介绍整数集合中大素数的分布和查找知识。  
整数的整除运算具有如下基本性质：  
【定理2.1】假设$a,b,c$ 是3 个任意给定的整数，则有：  
（1）$a|b$ 当且仅当$\pm a|\pm b$；  
（2）若$a|b,\ b|c$，则 $a|c$；  
（3）若$;b|a_{i},\;\;i=1,\;\;2,\;\;\cdots,\;\;k$，则 $b|a_{1}x_{1}+a_{2}x_{2}+\cdots+a_{k}x_{k}$，此处 $x_{i}(i=1,\ \ 2$，$\cdots,\;\;k)$也是任意的整数；  
（4）若$b|a$，则 $b p|a p$，此处$p$ 是任意非零整数；  
（5）若$b|a$，$a\neq0$，则 $|b|\leq|a|$； 下面仅证明（3）和（5），其余性质的证明与此类似，读者可自行给出。  
根据整除的定义，我们知道任意两个整数之间并不一定满足整除关系。为使整数能够正常进行除法运算，必须对整除概念进行推广。事实上，对于任意两个整数，虽然它们之间不一定具有整除关系，但总存在如下关系：  
【定理2.2】假设$a$ 和$b$ 是任意给定的两个整数且$a\neq0$，则必然存在唯一确定的一对整数$q$ 和$r$，满足下列等式：  
$$
b=a q+r,\;\;0\leq r<|a|\tag{2-1}
$$  
此时称整数$a$ 为除数、$b$ 为被除数、$q$为$b$ 除以$a$的商、$r$为$b$ 除以$a$ 的余数。",带余除法是整数除法运算的一种情况
整除,相关,素数,,"在第一章，我们得到自然数和自然数集的定义。在自然数集中加入每个非零元素的相反数就得到整数集合，整数集中每个元素称为整数。也就是说，对于整数集合$z$，有：  
$$
Z\!=\!\{\cdots\!,\,\!-4,\,\!-3,\,\!-2,\,\!-1,\,0,\,1,\,2,\,3,\,4,\,\cdots\}
$$  
对于整数，我们主要考察其除法运算，包括整除和带余除法，由此可以得到倍数与因子、素数与合数、商与余数的相关概念和性质。  
首先在整数及其乘法运算基础上，考察整除的概念与性质。  
【定义2.1】假设$a$ 和$b$ 是任意给定的两个整数且$a\neq0$，若存在整数$q$，满足$b=a\cdot q($其中“∙”表示普通数乘运算，通常将其省略)，则称$\pmb{a}$ 能整除$\pmb{b}$，或$\pmb{b}$ 能被$\pmb{a}$ 整除，记为a|b。此时，又称$a$ 是$b$ 的因子或$b$ 是$a$ 的倍数。若不存在任何整数$q$，满足$b=a q$，则称$\pmb{a}$ 不能整除$\pmb{b}$，或$\pmb{b}$ 不能被$\pmb{a}$ 整除，记为$a\nmid b$。  
例如：5|25，13 ∤120，7|49，13|0，$^{-3}\vert$-12，9 ∤−56；8 的因子有$\pm1$，$\pm2$，$\pm4$和$\pm8$，7的因子有$\pm1$和$\pm7$。显然，对于任意一个给定的整数$a$，它至少能够被$\pm1$或$\pm n$整除。因此，这四个是$a$ 的因子，称其为$a$ 的平凡因子。$a$ 的其它因子称为非平凡因子。  
【定义2.2】对于任意一个给定的非零整数$a$，若$a\ne\pm1$且没有非平凡因子，则称$a$ 为素数或质数；否则称$a$ 为合数。  
从一定意义上讲，素数是构成整数的基本要素，在整数理论中具有极其重要的地位。若非特别说明，我们所说的素数都是指正素数。2 是第一个正素数，其后还有3, 5, 7, 11,…, 等等。我们还会后续相关内容中详细讨论素数的性质与应用。  
例如，整数2, 3, 5, 7, 11, 13 都是素数，而4, 10, 16, 21 都不是素数。  
对于一个不是很大的整数，显然可用一个比较简单的方法来判定一个大于2 的正整数$b$是否为素数：用从2 到$b-1$的每一个整数去除$b$，如果这些整数都不是$b$ 的因子，那么$b$是素数。注意到：若$a k=b$，则$a$ 或$k$ 小于或等于$\sqrt{b}$。由此可知，如果$b$ 不是素数，那么它必有一个因子$k$ 满足不等式$1<k\leq{\sqrt{b}}$ 。因此，为得到更高的效率，只需在这个范围里检验因子。同样，如果$b$ 有一偶数因子，那么2 一定是该因子的一个因子。因此，在通过2 的整除性检验后，可以跳过所有偶数。要判断一个很大的整数是否为素数则不是一件容易的事情，我们将在本章后续的相关部分具体介绍整数集合中大素数的分布和查找知识。  
整数的整除运算具有如下基本性质：  
【定理2.1】假设$a,b,c$ 是3 个任意给定的整数，则有：  
（1）$a|b$ 当且仅当$\pm a|\pm b$；  
（2）若$a|b,\ b|c$，则 $a|c$；  
（3）若$;b|a_{i},\;\;i=1,\;\;2,\;\;\cdots,\;\;k$，则 $b|a_{1}x_{1}+a_{2}x_{2}+\cdots+a_{k}x_{k}$，此处 $x_{i}(i=1,\ \ 2$，$\cdots,\;\;k)$也是任意的整数；  
（4）若$b|a$，则 $b p|a p$，此处$p$ 是任意非零整数；  
（5）若$b|a$，$a\neq0$，则 $|b|\leq|a|$； 下面仅证明（3）和（5），其余性质的证明与此类似，读者可自行给出。  
根据整除的定义，我们知道任意两个整数之间并不一定满足整除关系。为使整数能够正常进行除法运算，必须对整除概念进行推广。事实上，对于任意两个整数，虽然它们之间不一定具有整除关系，但总存在如下关系：  
【定理2.2】假设$a$ 和$b$ 是任意给定的两个整数且$a\neq0$，则必然存在唯一确定的一对整数$q$ 和$r$，满足下列等式：  
$$
b=a q+r,\;\;0\leq r<|a|\tag{2-1}
$$  
此时称整数$a$ 为除数、$b$ 为被除数、$q$为$b$ 除以$a$的商、$r$为$b$ 除以$a$ 的余数。",素数的定义基于整除概念，素数没有非平凡因子
带余除法,推广,整除,,"在第一章，我们得到自然数和自然数集的定义。在自然数集中加入每个非零元素的相反数就得到整数集合，整数集中每个元素称为整数。也就是说，对于整数集合$z$，有：  
$$
Z\!=\!\{\cdots\!,\,\!-4,\,\!-3,\,\!-2,\,\!-1,\,0,\,1,\,2,\,3,\,4,\,\cdots\}
$$  
对于整数，我们主要考察其除法运算，包括整除和带余除法，由此可以得到倍数与因子、素数与合数、商与余数的相关概念和性质。  
首先在整数及其乘法运算基础上，考察整除的概念与性质。  
【定义2.1】假设$a$ 和$b$ 是任意给定的两个整数且$a\neq0$，若存在整数$q$，满足$b=a\cdot q($其中“∙”表示普通数乘运算，通常将其省略)，则称$\pmb{a}$ 能整除$\pmb{b}$，或$\pmb{b}$ 能被$\pmb{a}$ 整除，记为a|b。此时，又称$a$ 是$b$ 的因子或$b$ 是$a$ 的倍数。若不存在任何整数$q$，满足$b=a q$，则称$\pmb{a}$ 不能整除$\pmb{b}$，或$\pmb{b}$ 不能被$\pmb{a}$ 整除，记为$a\nmid b$。  
例如：5|25，13 ∤120，7|49，13|0，$^{-3}\vert$-12，9 ∤−56；8 的因子有$\pm1$，$\pm2$，$\pm4$和$\pm8$，7的因子有$\pm1$和$\pm7$。显然，对于任意一个给定的整数$a$，它至少能够被$\pm1$或$\pm n$整除。因此，这四个是$a$ 的因子，称其为$a$ 的平凡因子。$a$ 的其它因子称为非平凡因子。  
【定义2.2】对于任意一个给定的非零整数$a$，若$a\ne\pm1$且没有非平凡因子，则称$a$ 为素数或质数；否则称$a$ 为合数。  
从一定意义上讲，素数是构成整数的基本要素，在整数理论中具有极其重要的地位。若非特别说明，我们所说的素数都是指正素数。2 是第一个正素数，其后还有3, 5, 7, 11,…, 等等。我们还会后续相关内容中详细讨论素数的性质与应用。  
例如，整数2, 3, 5, 7, 11, 13 都是素数，而4, 10, 16, 21 都不是素数。  
对于一个不是很大的整数，显然可用一个比较简单的方法来判定一个大于2 的正整数$b$是否为素数：用从2 到$b-1$的每一个整数去除$b$，如果这些整数都不是$b$ 的因子，那么$b$是素数。注意到：若$a k=b$，则$a$ 或$k$ 小于或等于$\sqrt{b}$。由此可知，如果$b$ 不是素数，那么它必有一个因子$k$ 满足不等式$1<k\leq{\sqrt{b}}$ 。因此，为得到更高的效率，只需在这个范围里检验因子。同样，如果$b$ 有一偶数因子，那么2 一定是该因子的一个因子。因此，在通过2 的整除性检验后，可以跳过所有偶数。要判断一个很大的整数是否为素数则不是一件容易的事情，我们将在本章后续的相关部分具体介绍整数集合中大素数的分布和查找知识。  
整数的整除运算具有如下基本性质：  
【定理2.1】假设$a,b,c$ 是3 个任意给定的整数，则有：  
（1）$a|b$ 当且仅当$\pm a|\pm b$；  
（2）若$a|b,\ b|c$，则 $a|c$；  
（3）若$;b|a_{i},\;\;i=1,\;\;2,\;\;\cdots,\;\;k$，则 $b|a_{1}x_{1}+a_{2}x_{2}+\cdots+a_{k}x_{k}$，此处 $x_{i}(i=1,\ \ 2$，$\cdots,\;\;k)$也是任意的整数；  
（4）若$b|a$，则 $b p|a p$，此处$p$ 是任意非零整数；  
（5）若$b|a$，$a\neq0$，则 $|b|\leq|a|$； 下面仅证明（3）和（5），其余性质的证明与此类似，读者可自行给出。  
根据整除的定义，我们知道任意两个整数之间并不一定满足整除关系。为使整数能够正常进行除法运算，必须对整除概念进行推广。事实上，对于任意两个整数，虽然它们之间不一定具有整除关系，但总存在如下关系：  
【定理2.2】假设$a$ 和$b$ 是任意给定的两个整数且$a\neq0$，则必然存在唯一确定的一对整数$q$ 和$r$，满足下列等式：  
$$
b=a q+r,\;\;0\leq r<|a|\tag{2-1}
$$  
此时称整数$a$ 为除数、$b$ 为被除数、$q$为$b$ 除以$a$的商、$r$为$b$ 除以$a$ 的余数。",带余除法是整除概念的推广，适用于任意两个整数
公因数,相关概念,公倍数,,对于任意两个整数，它们之间可以进行加法运算、减法运算和乘法运算，却不一定能够进行整除运算。因此，我们可以将整除运算作为一个基本工具来考察单个整数的离散结构特征以及整数与整数之间的各种联系。本节首先介绍公因数和公倍数的相关概念与性质，然后给出最大公因数的经典构造算法，最后讨论整数基于整除性质的分解。由于非零整数的正负号不影响其整除性质，因此，不失一般性，以下关于整数的讨论，在默认状态下是针对非负整数范围，所得结论可直接推广到所有整数的范围。,公因数和公倍数是描述整数之间关系的两个基本概念
最大公因数,特化,公因数,,对于任意两个整数，它们之间可以进行加法运算、减法运算和乘法运算，却不一定能够进行整除运算。因此，我们可以将整除运算作为一个基本工具来考察单个整数的离散结构特征以及整数与整数之间的各种联系。本节首先介绍公因数和公倍数的相关概念与性质，然后给出最大公因数的经典构造算法，最后讨论整数基于整除性质的分解。由于非零整数的正负号不影响其整除性质，因此，不失一般性，以下关于整数的讨论，在默认状态下是针对非负整数范围，所得结论可直接推广到所有整数的范围。,最大公因数是公因数中的一个特殊值，表示最大的公因数
整数分解,基于,整除性质,,对于任意两个整数，它们之间可以进行加法运算、减法运算和乘法运算，却不一定能够进行整除运算。因此，我们可以将整除运算作为一个基本工具来考察单个整数的离散结构特征以及整数与整数之间的各种联系。本节首先介绍公因数和公倍数的相关概念与性质，然后给出最大公因数的经典构造算法，最后讨论整数基于整除性质的分解。由于非零整数的正负号不影响其整除性质，因此，不失一般性，以下关于整数的讨论，在默认状态下是针对非负整数范围，所得结论可直接推广到所有整数的范围。,整数分解是基于整除性质进行的
互素,包含,两两互素,,"从整除的角度看，两个整数的公因数表达的是这两个整数共性成分。如果两个整数的最大公因数为1，则表明这两个整数除1 之外没有任何额外的共性成分。因此，从结构上看，这两个整数之间具有很强的独立性。这种很强的独立性我们称之为互素。互素是整数理论中一个非常重要的基本概念，整数的很多性质都与互素的概念有关，其具体定义如下：  
【定义2.7】假设$a_{1},a_{2},\cdots,a_{k}$是$k$个不全为零的整数，如果有$\operatorname*{gcd}(a_{1},a_{2},\cdots,a_{k})=1$，则称这$k$ 个整数$a_{1},a_{2},\cdots,a_{k}$为互素；如果$a_{1},a_{2},\cdots,a_{k}$中任意两个整数的最大公因数均为1，则称这$k$ 个整数$a_{1},a_{2},\cdots,a_{k}$为两两互素。  
$a_{1},a_{2},\cdots,a_{k}$互素与$a_{1},a_{2},\cdots,a_{k}$两两互素是两个不同的概念，在实际使用过程中应注意加以区分，避免混淆。显然，由$a_{1},a_{2},\cdots,a_{k}$两两互素可以推出$a_{1},a_{2},\cdots,a_{k}$互素，反之不然。例如，$\operatorname*{gcd}(3,6,9,10)=1$，此时这4 个整数仅仅为互素的关系，因为其中的3, 6, 9的最大公因数并不为1，所以不符合两两互素。  
【定理2.8】设$a$，$b$ 是任意两个整数，若$\operatorname*{gcd}(a,b)=a s+b t$，则$s$ 与$t$是互素的。  
【定理2.9】如果整数$a$ 与整数$b_{1},b_{2},\cdots,b_{n}$中的每一个都互质，那么$a$ 与乘积$b_{1}b_{2}\cdots b_{n}$也互质。  
【定理2.10】对于任意的整数$a$，$b$，$c$，下面结论成立：  
（1）若$b|a c$且$\operatorname*{gcd}(a,b)=1$，则有$b|c$；  
（2）若$b|c$且$a|c$，则有$a b|c$。  
【定理 2.11 】若 $\operatorname*{gcd}(a,b)=1$ ，则 $\operatorname*{gcd}(a,b k)=\operatorname*{gcd}(a,k)\,.$",两两互素可以推出互素，但互素不一定能推出两两互素
定理2.8,定义,互素,,"从整除的角度看，两个整数的公因数表达的是这两个整数共性成分。如果两个整数的最大公因数为1，则表明这两个整数除1 之外没有任何额外的共性成分。因此，从结构上看，这两个整数之间具有很强的独立性。这种很强的独立性我们称之为互素。互素是整数理论中一个非常重要的基本概念，整数的很多性质都与互素的概念有关，其具体定义如下：  
【定义2.7】假设$a_{1},a_{2},\cdots,a_{k}$是$k$个不全为零的整数，如果有$\operatorname*{gcd}(a_{1},a_{2},\cdots,a_{k})=1$，则称这$k$ 个整数$a_{1},a_{2},\cdots,a_{k}$为互素；如果$a_{1},a_{2},\cdots,a_{k}$中任意两个整数的最大公因数均为1，则称这$k$ 个整数$a_{1},a_{2},\cdots,a_{k}$为两两互素。  
$a_{1},a_{2},\cdots,a_{k}$互素与$a_{1},a_{2},\cdots,a_{k}$两两互素是两个不同的概念，在实际使用过程中应注意加以区分，避免混淆。显然，由$a_{1},a_{2},\cdots,a_{k}$两两互素可以推出$a_{1},a_{2},\cdots,a_{k}$互素，反之不然。例如，$\operatorname*{gcd}(3,6,9,10)=1$，此时这4 个整数仅仅为互素的关系，因为其中的3, 6, 9的最大公因数并不为1，所以不符合两两互素。  
【定理2.8】设$a$，$b$ 是任意两个整数，若$\operatorname*{gcd}(a,b)=a s+b t$，则$s$ 与$t$是互素的。  
【定理2.9】如果整数$a$ 与整数$b_{1},b_{2},\cdots,b_{n}$中的每一个都互质，那么$a$ 与乘积$b_{1}b_{2}\cdots b_{n}$也互质。  
【定理2.10】对于任意的整数$a$，$b$，$c$，下面结论成立：  
（1）若$b|a c$且$\operatorname*{gcd}(a,b)=1$，则有$b|c$；  
（2）若$b|c$且$a|c$，则有$a b|c$。  
【定理 2.11 】若 $\operatorname*{gcd}(a,b)=1$ ，则 $\operatorname*{gcd}(a,b k)=\operatorname*{gcd}(a,k)\,.$","定理2.8定义了若gcd(a,b)=as+bt，则s与t是互素的"
定理2.9,条件,互素,,"从整除的角度看，两个整数的公因数表达的是这两个整数共性成分。如果两个整数的最大公因数为1，则表明这两个整数除1 之外没有任何额外的共性成分。因此，从结构上看，这两个整数之间具有很强的独立性。这种很强的独立性我们称之为互素。互素是整数理论中一个非常重要的基本概念，整数的很多性质都与互素的概念有关，其具体定义如下：  
【定义2.7】假设$a_{1},a_{2},\cdots,a_{k}$是$k$个不全为零的整数，如果有$\operatorname*{gcd}(a_{1},a_{2},\cdots,a_{k})=1$，则称这$k$ 个整数$a_{1},a_{2},\cdots,a_{k}$为互素；如果$a_{1},a_{2},\cdots,a_{k}$中任意两个整数的最大公因数均为1，则称这$k$ 个整数$a_{1},a_{2},\cdots,a_{k}$为两两互素。  
$a_{1},a_{2},\cdots,a_{k}$互素与$a_{1},a_{2},\cdots,a_{k}$两两互素是两个不同的概念，在实际使用过程中应注意加以区分，避免混淆。显然，由$a_{1},a_{2},\cdots,a_{k}$两两互素可以推出$a_{1},a_{2},\cdots,a_{k}$互素，反之不然。例如，$\operatorname*{gcd}(3,6,9,10)=1$，此时这4 个整数仅仅为互素的关系，因为其中的3, 6, 9的最大公因数并不为1，所以不符合两两互素。  
【定理2.8】设$a$，$b$ 是任意两个整数，若$\operatorname*{gcd}(a,b)=a s+b t$，则$s$ 与$t$是互素的。  
【定理2.9】如果整数$a$ 与整数$b_{1},b_{2},\cdots,b_{n}$中的每一个都互质，那么$a$ 与乘积$b_{1}b_{2}\cdots b_{n}$也互质。  
【定理2.10】对于任意的整数$a$，$b$，$c$，下面结论成立：  
（1）若$b|a c$且$\operatorname*{gcd}(a,b)=1$，则有$b|c$；  
（2）若$b|c$且$a|c$，则有$a b|c$。  
【定理 2.11 】若 $\operatorname*{gcd}(a,b)=1$ ，则 $\operatorname*{gcd}(a,b k)=\operatorname*{gcd}(a,k)\,.$","定理2.9表明若a与b1,b2,...,bn中的每一个都互素，则a与乘积b1b2...bn也互素"
定理2.10,条件,互素,,"从整除的角度看，两个整数的公因数表达的是这两个整数共性成分。如果两个整数的最大公因数为1，则表明这两个整数除1 之外没有任何额外的共性成分。因此，从结构上看，这两个整数之间具有很强的独立性。这种很强的独立性我们称之为互素。互素是整数理论中一个非常重要的基本概念，整数的很多性质都与互素的概念有关，其具体定义如下：  
【定义2.7】假设$a_{1},a_{2},\cdots,a_{k}$是$k$个不全为零的整数，如果有$\operatorname*{gcd}(a_{1},a_{2},\cdots,a_{k})=1$，则称这$k$ 个整数$a_{1},a_{2},\cdots,a_{k}$为互素；如果$a_{1},a_{2},\cdots,a_{k}$中任意两个整数的最大公因数均为1，则称这$k$ 个整数$a_{1},a_{2},\cdots,a_{k}$为两两互素。  
$a_{1},a_{2},\cdots,a_{k}$互素与$a_{1},a_{2},\cdots,a_{k}$两两互素是两个不同的概念，在实际使用过程中应注意加以区分，避免混淆。显然，由$a_{1},a_{2},\cdots,a_{k}$两两互素可以推出$a_{1},a_{2},\cdots,a_{k}$互素，反之不然。例如，$\operatorname*{gcd}(3,6,9,10)=1$，此时这4 个整数仅仅为互素的关系，因为其中的3, 6, 9的最大公因数并不为1，所以不符合两两互素。  
【定理2.8】设$a$，$b$ 是任意两个整数，若$\operatorname*{gcd}(a,b)=a s+b t$，则$s$ 与$t$是互素的。  
【定理2.9】如果整数$a$ 与整数$b_{1},b_{2},\cdots,b_{n}$中的每一个都互质，那么$a$ 与乘积$b_{1}b_{2}\cdots b_{n}$也互质。  
【定理2.10】对于任意的整数$a$，$b$，$c$，下面结论成立：  
（1）若$b|a c$且$\operatorname*{gcd}(a,b)=1$，则有$b|c$；  
（2）若$b|c$且$a|c$，则有$a b|c$。  
【定理 2.11 】若 $\operatorname*{gcd}(a,b)=1$ ，则 $\operatorname*{gcd}(a,b k)=\operatorname*{gcd}(a,k)\,.$","定理2.10提供了关于互素整数的两个结论：(1)若b|ac且gcd(a,b)=1，则b|c；(2)若b|c且a|c，则ab|c"
定理2.11,条件,互素,,"从整除的角度看，两个整数的公因数表达的是这两个整数共性成分。如果两个整数的最大公因数为1，则表明这两个整数除1 之外没有任何额外的共性成分。因此，从结构上看，这两个整数之间具有很强的独立性。这种很强的独立性我们称之为互素。互素是整数理论中一个非常重要的基本概念，整数的很多性质都与互素的概念有关，其具体定义如下：  
【定义2.7】假设$a_{1},a_{2},\cdots,a_{k}$是$k$个不全为零的整数，如果有$\operatorname*{gcd}(a_{1},a_{2},\cdots,a_{k})=1$，则称这$k$ 个整数$a_{1},a_{2},\cdots,a_{k}$为互素；如果$a_{1},a_{2},\cdots,a_{k}$中任意两个整数的最大公因数均为1，则称这$k$ 个整数$a_{1},a_{2},\cdots,a_{k}$为两两互素。  
$a_{1},a_{2},\cdots,a_{k}$互素与$a_{1},a_{2},\cdots,a_{k}$两两互素是两个不同的概念，在实际使用过程中应注意加以区分，避免混淆。显然，由$a_{1},a_{2},\cdots,a_{k}$两两互素可以推出$a_{1},a_{2},\cdots,a_{k}$互素，反之不然。例如，$\operatorname*{gcd}(3,6,9,10)=1$，此时这4 个整数仅仅为互素的关系，因为其中的3, 6, 9的最大公因数并不为1，所以不符合两两互素。  
【定理2.8】设$a$，$b$ 是任意两个整数，若$\operatorname*{gcd}(a,b)=a s+b t$，则$s$ 与$t$是互素的。  
【定理2.9】如果整数$a$ 与整数$b_{1},b_{2},\cdots,b_{n}$中的每一个都互质，那么$a$ 与乘积$b_{1}b_{2}\cdots b_{n}$也互质。  
【定理2.10】对于任意的整数$a$，$b$，$c$，下面结论成立：  
（1）若$b|a c$且$\operatorname*{gcd}(a,b)=1$，则有$b|c$；  
（2）若$b|c$且$a|c$，则有$a b|c$。  
【定理 2.11 】若 $\operatorname*{gcd}(a,b)=1$ ，则 $\operatorname*{gcd}(a,b k)=\operatorname*{gcd}(a,k)\,.$","定理2.11表明若gcd(a,b)=1，则gcd(a,bk)=gcd(a,k)"
整数的基本知识,包含,整数的因数分解,,"对于是任意给定的两个整数$a$ 和$b$，如果$a$ 能够整除$b$，则通过整数$a$ 实现了对整数$b$的一个分解，即将$b$ 分解成$a$ 和另外一个整数的乘积。现在我们从整除的角度讨论整数的分解问题，亦即整数的因数分解问题。  
我们知道，素数是整个整数中不能够再分解的数，因为素数除了±1和其自身之外，没有其它的非平凡因子。因此，在对整数进行因数分解的过程中可以将素数看出是构成整数的最基本的要素或构件。通过对整数进行到素数层次的因数分解，就可以从整除的角度比较完整地考察整数的基本结构，并由此探究整数的基本性质和基本规律。  
【定理2.12】任何大于1 的正整数$a$，或为一素数，或可以写成若干素数的积，即$a=$$p_{1}p_{2}\cdots p_{b}$，其中$p_{i}(1\leq i\leq b)$是素数。  
[定理2.13] (算术基本定理) 任何大于1 的整数$a$可以唯一表示成
$$
a=p_{1}^{a_{1}}p_{2}^{a_{2}}\cdots p_{k}^{a_{k}}\tag{2-4}
$$  
其中$p_{1},p_{2},\cdots,p_{k}$是素数，$p_{1}<p_{2}<\dots<p_{k}$，$a_{1},a_{2},\cdots,a_{k}$是正整数。  
上述定理给出了整数素数分解的存在性与唯一性，称之为算术基本定理。由此可以看出，整数的素数分解在整数理论以及在整数初等数学中的重要性。  
【定义2.8】若$p_{1},p_{2},\cdots,p_{k}$是素数，$p_{1}<p_{2}<\cdots<p_{k},$，$a_{1},a_{2},\cdots,a_{k}$是正整数，那么称  
$$
a=p_{1}^{a_{1}}p_{2}^{a_{2}}\cdots p_{k}^{a_{k}}\tag{2-6}
$$  
是整数$a$ 的素幂分解式，其中$p_{i}$是素数，$p_{1}<p_{2}<\dots<p_{k}$，$a_{i}$是正整数。【例题2.12】写出51480 的素幂分解式。  
整数的素幂分解式给出了整数一种基于素数的结构表达，在数论研究中具有非常重要的作用。例如，下面两个定理表明，可以使用其素幂分解式计算两个整数的最大公约数和最小公倍数，还可以证明最大公约数和最小公倍数之间的关系。  
【定理2.14】设整数$a,~b$ 的素因子分解式分别为：  
$$
a=p_{1}^{a_{1}}\cdots p_{k}^{a_{k}};\,\,\,b=p_{1}^{b_{1}}\cdots p_{k}^{b_{k}}
$$  
其中$p_{1},\cdots,p_{k}$是互不相同的素数，$a_{1},\cdots,a_{k},\;\;b_{1},\cdots,b_{k}$是非负整数。则有：  
$$
{\operatorname*{gcd}(a,b)=p_{1}^{m i n(a_{1},b_{1})}\cdots p_{k}^{m i n(a_{k},b_{k})\tag{2-7}}}
$$  
$$
{\operatorname{lcm}(a,b)=p_{1}^{m a x(a_{1},b_{1})}\cdots p_{k}^{m a x(a_{k},b_{k})}}\tag{2-8}
$$",整数的基本知识包含整数的因数分解问题
整数的因数分解,基础,素数,,"对于是任意给定的两个整数$a$ 和$b$，如果$a$ 能够整除$b$，则通过整数$a$ 实现了对整数$b$的一个分解，即将$b$ 分解成$a$ 和另外一个整数的乘积。现在我们从整除的角度讨论整数的分解问题，亦即整数的因数分解问题。  
我们知道，素数是整个整数中不能够再分解的数，因为素数除了±1和其自身之外，没有其它的非平凡因子。因此，在对整数进行因数分解的过程中可以将素数看出是构成整数的最基本的要素或构件。通过对整数进行到素数层次的因数分解，就可以从整除的角度比较完整地考察整数的基本结构，并由此探究整数的基本性质和基本规律。  
【定理2.12】任何大于1 的正整数$a$，或为一素数，或可以写成若干素数的积，即$a=$$p_{1}p_{2}\cdots p_{b}$，其中$p_{i}(1\leq i\leq b)$是素数。  
[定理2.13] (算术基本定理) 任何大于1 的整数$a$可以唯一表示成
$$
a=p_{1}^{a_{1}}p_{2}^{a_{2}}\cdots p_{k}^{a_{k}}\tag{2-4}
$$  
其中$p_{1},p_{2},\cdots,p_{k}$是素数，$p_{1}<p_{2}<\dots<p_{k}$，$a_{1},a_{2},\cdots,a_{k}$是正整数。  
上述定理给出了整数素数分解的存在性与唯一性，称之为算术基本定理。由此可以看出，整数的素数分解在整数理论以及在整数初等数学中的重要性。  
【定义2.8】若$p_{1},p_{2},\cdots,p_{k}$是素数，$p_{1}<p_{2}<\cdots<p_{k},$，$a_{1},a_{2},\cdots,a_{k}$是正整数，那么称  
$$
a=p_{1}^{a_{1}}p_{2}^{a_{2}}\cdots p_{k}^{a_{k}}\tag{2-6}
$$  
是整数$a$ 的素幂分解式，其中$p_{i}$是素数，$p_{1}<p_{2}<\dots<p_{k}$，$a_{i}$是正整数。【例题2.12】写出51480 的素幂分解式。  
整数的素幂分解式给出了整数一种基于素数的结构表达，在数论研究中具有非常重要的作用。例如，下面两个定理表明，可以使用其素幂分解式计算两个整数的最大公约数和最小公倍数，还可以证明最大公约数和最小公倍数之间的关系。  
【定理2.14】设整数$a,~b$ 的素因子分解式分别为：  
$$
a=p_{1}^{a_{1}}\cdots p_{k}^{a_{k}};\,\,\,b=p_{1}^{b_{1}}\cdots p_{k}^{b_{k}}
$$  
其中$p_{1},\cdots,p_{k}$是互不相同的素数，$a_{1},\cdots,a_{k},\;\;b_{1},\cdots,b_{k}$是非负整数。则有：  
$$
{\operatorname*{gcd}(a,b)=p_{1}^{m i n(a_{1},b_{1})}\cdots p_{k}^{m i n(a_{k},b_{k})\tag{2-7}}}
$$  
$$
{\operatorname{lcm}(a,b)=p_{1}^{m a x(a_{1},b_{1})}\cdots p_{k}^{m a x(a_{k},b_{k})}}\tag{2-8}
$$",整数的因数分解以素数作为基本要素
算术基本定理,定义,素幂分解式,,"对于是任意给定的两个整数$a$ 和$b$，如果$a$ 能够整除$b$，则通过整数$a$ 实现了对整数$b$的一个分解，即将$b$ 分解成$a$ 和另外一个整数的乘积。现在我们从整除的角度讨论整数的分解问题，亦即整数的因数分解问题。  
我们知道，素数是整个整数中不能够再分解的数，因为素数除了±1和其自身之外，没有其它的非平凡因子。因此，在对整数进行因数分解的过程中可以将素数看出是构成整数的最基本的要素或构件。通过对整数进行到素数层次的因数分解，就可以从整除的角度比较完整地考察整数的基本结构，并由此探究整数的基本性质和基本规律。  
【定理2.12】任何大于1 的正整数$a$，或为一素数，或可以写成若干素数的积，即$a=$$p_{1}p_{2}\cdots p_{b}$，其中$p_{i}(1\leq i\leq b)$是素数。  
[定理2.13] (算术基本定理) 任何大于1 的整数$a$可以唯一表示成
$$
a=p_{1}^{a_{1}}p_{2}^{a_{2}}\cdots p_{k}^{a_{k}}\tag{2-4}
$$  
其中$p_{1},p_{2},\cdots,p_{k}$是素数，$p_{1}<p_{2}<\dots<p_{k}$，$a_{1},a_{2},\cdots,a_{k}$是正整数。  
上述定理给出了整数素数分解的存在性与唯一性，称之为算术基本定理。由此可以看出，整数的素数分解在整数理论以及在整数初等数学中的重要性。  
【定义2.8】若$p_{1},p_{2},\cdots,p_{k}$是素数，$p_{1}<p_{2}<\cdots<p_{k},$，$a_{1},a_{2},\cdots,a_{k}$是正整数，那么称  
$$
a=p_{1}^{a_{1}}p_{2}^{a_{2}}\cdots p_{k}^{a_{k}}\tag{2-6}
$$  
是整数$a$ 的素幂分解式，其中$p_{i}$是素数，$p_{1}<p_{2}<\dots<p_{k}$，$a_{i}$是正整数。【例题2.12】写出51480 的素幂分解式。  
整数的素幂分解式给出了整数一种基于素数的结构表达，在数论研究中具有非常重要的作用。例如，下面两个定理表明，可以使用其素幂分解式计算两个整数的最大公约数和最小公倍数，还可以证明最大公约数和最小公倍数之间的关系。  
【定理2.14】设整数$a,~b$ 的素因子分解式分别为：  
$$
a=p_{1}^{a_{1}}\cdots p_{k}^{a_{k}};\,\,\,b=p_{1}^{b_{1}}\cdots p_{k}^{b_{k}}
$$  
其中$p_{1},\cdots,p_{k}$是互不相同的素数，$a_{1},\cdots,a_{k},\;\;b_{1},\cdots,b_{k}$是非负整数。则有：  
$$
{\operatorname*{gcd}(a,b)=p_{1}^{m i n(a_{1},b_{1})}\cdots p_{k}^{m i n(a_{k},b_{k})\tag{2-7}}}
$$  
$$
{\operatorname{lcm}(a,b)=p_{1}^{m a x(a_{1},b_{1})}\cdots p_{k}^{m a x(a_{k},b_{k})}}\tag{2-8}
$$",算术基本定理定义了整数的素幂分解式的存在性与唯一性
素幂分解式,计算基础,最大公约数,,"对于是任意给定的两个整数$a$ 和$b$，如果$a$ 能够整除$b$，则通过整数$a$ 实现了对整数$b$的一个分解，即将$b$ 分解成$a$ 和另外一个整数的乘积。现在我们从整除的角度讨论整数的分解问题，亦即整数的因数分解问题。  
我们知道，素数是整个整数中不能够再分解的数，因为素数除了±1和其自身之外，没有其它的非平凡因子。因此，在对整数进行因数分解的过程中可以将素数看出是构成整数的最基本的要素或构件。通过对整数进行到素数层次的因数分解，就可以从整除的角度比较完整地考察整数的基本结构，并由此探究整数的基本性质和基本规律。  
【定理2.12】任何大于1 的正整数$a$，或为一素数，或可以写成若干素数的积，即$a=$$p_{1}p_{2}\cdots p_{b}$，其中$p_{i}(1\leq i\leq b)$是素数。  
[定理2.13] (算术基本定理) 任何大于1 的整数$a$可以唯一表示成
$$
a=p_{1}^{a_{1}}p_{2}^{a_{2}}\cdots p_{k}^{a_{k}}\tag{2-4}
$$  
其中$p_{1},p_{2},\cdots,p_{k}$是素数，$p_{1}<p_{2}<\dots<p_{k}$，$a_{1},a_{2},\cdots,a_{k}$是正整数。  
上述定理给出了整数素数分解的存在性与唯一性，称之为算术基本定理。由此可以看出，整数的素数分解在整数理论以及在整数初等数学中的重要性。  
【定义2.8】若$p_{1},p_{2},\cdots,p_{k}$是素数，$p_{1}<p_{2}<\cdots<p_{k},$，$a_{1},a_{2},\cdots,a_{k}$是正整数，那么称  
$$
a=p_{1}^{a_{1}}p_{2}^{a_{2}}\cdots p_{k}^{a_{k}}\tag{2-6}
$$  
是整数$a$ 的素幂分解式，其中$p_{i}$是素数，$p_{1}<p_{2}<\dots<p_{k}$，$a_{i}$是正整数。【例题2.12】写出51480 的素幂分解式。  
整数的素幂分解式给出了整数一种基于素数的结构表达，在数论研究中具有非常重要的作用。例如，下面两个定理表明，可以使用其素幂分解式计算两个整数的最大公约数和最小公倍数，还可以证明最大公约数和最小公倍数之间的关系。  
【定理2.14】设整数$a,~b$ 的素因子分解式分别为：  
$$
a=p_{1}^{a_{1}}\cdots p_{k}^{a_{k}};\,\,\,b=p_{1}^{b_{1}}\cdots p_{k}^{b_{k}}
$$  
其中$p_{1},\cdots,p_{k}$是互不相同的素数，$a_{1},\cdots,a_{k},\;\;b_{1},\cdots,b_{k}$是非负整数。则有：  
$$
{\operatorname*{gcd}(a,b)=p_{1}^{m i n(a_{1},b_{1})}\cdots p_{k}^{m i n(a_{k},b_{k})\tag{2-7}}}
$$  
$$
{\operatorname{lcm}(a,b)=p_{1}^{m a x(a_{1},b_{1})}\cdots p_{k}^{m a x(a_{k},b_{k})}}\tag{2-8}
$$",素幂分解式用于计算两个整数的最大公约数
素幂分解式,计算基础,最小公倍数,,"对于是任意给定的两个整数$a$ 和$b$，如果$a$ 能够整除$b$，则通过整数$a$ 实现了对整数$b$的一个分解，即将$b$ 分解成$a$ 和另外一个整数的乘积。现在我们从整除的角度讨论整数的分解问题，亦即整数的因数分解问题。  
我们知道，素数是整个整数中不能够再分解的数，因为素数除了±1和其自身之外，没有其它的非平凡因子。因此，在对整数进行因数分解的过程中可以将素数看出是构成整数的最基本的要素或构件。通过对整数进行到素数层次的因数分解，就可以从整除的角度比较完整地考察整数的基本结构，并由此探究整数的基本性质和基本规律。  
【定理2.12】任何大于1 的正整数$a$，或为一素数，或可以写成若干素数的积，即$a=$$p_{1}p_{2}\cdots p_{b}$，其中$p_{i}(1\leq i\leq b)$是素数。  
[定理2.13] (算术基本定理) 任何大于1 的整数$a$可以唯一表示成
$$
a=p_{1}^{a_{1}}p_{2}^{a_{2}}\cdots p_{k}^{a_{k}}\tag{2-4}
$$  
其中$p_{1},p_{2},\cdots,p_{k}$是素数，$p_{1}<p_{2}<\dots<p_{k}$，$a_{1},a_{2},\cdots,a_{k}$是正整数。  
上述定理给出了整数素数分解的存在性与唯一性，称之为算术基本定理。由此可以看出，整数的素数分解在整数理论以及在整数初等数学中的重要性。  
【定义2.8】若$p_{1},p_{2},\cdots,p_{k}$是素数，$p_{1}<p_{2}<\cdots<p_{k},$，$a_{1},a_{2},\cdots,a_{k}$是正整数，那么称  
$$
a=p_{1}^{a_{1}}p_{2}^{a_{2}}\cdots p_{k}^{a_{k}}\tag{2-6}
$$  
是整数$a$ 的素幂分解式，其中$p_{i}$是素数，$p_{1}<p_{2}<\dots<p_{k}$，$a_{i}$是正整数。【例题2.12】写出51480 的素幂分解式。  
整数的素幂分解式给出了整数一种基于素数的结构表达，在数论研究中具有非常重要的作用。例如，下面两个定理表明，可以使用其素幂分解式计算两个整数的最大公约数和最小公倍数，还可以证明最大公约数和最小公倍数之间的关系。  
【定理2.14】设整数$a,~b$ 的素因子分解式分别为：  
$$
a=p_{1}^{a_{1}}\cdots p_{k}^{a_{k}};\,\,\,b=p_{1}^{b_{1}}\cdots p_{k}^{b_{k}}
$$  
其中$p_{1},\cdots,p_{k}$是互不相同的素数，$a_{1},\cdots,a_{k},\;\;b_{1},\cdots,b_{k}$是非负整数。则有：  
$$
{\operatorname*{gcd}(a,b)=p_{1}^{m i n(a_{1},b_{1})}\cdots p_{k}^{m i n(a_{k},b_{k})\tag{2-7}}}
$$  
$$
{\operatorname{lcm}(a,b)=p_{1}^{m a x(a_{1},b_{1})}\cdots p_{k}^{m a x(a_{k},b_{k})}}\tag{2-8}
$$",素幂分解式用于计算两个整数的最小公倍数
最大公约数,关系,最小公倍数,,"对于是任意给定的两个整数$a$ 和$b$，如果$a$ 能够整除$b$，则通过整数$a$ 实现了对整数$b$的一个分解，即将$b$ 分解成$a$ 和另外一个整数的乘积。现在我们从整除的角度讨论整数的分解问题，亦即整数的因数分解问题。  
我们知道，素数是整个整数中不能够再分解的数，因为素数除了±1和其自身之外，没有其它的非平凡因子。因此，在对整数进行因数分解的过程中可以将素数看出是构成整数的最基本的要素或构件。通过对整数进行到素数层次的因数分解，就可以从整除的角度比较完整地考察整数的基本结构，并由此探究整数的基本性质和基本规律。  
【定理2.12】任何大于1 的正整数$a$，或为一素数，或可以写成若干素数的积，即$a=$$p_{1}p_{2}\cdots p_{b}$，其中$p_{i}(1\leq i\leq b)$是素数。  
[定理2.13] (算术基本定理) 任何大于1 的整数$a$可以唯一表示成
$$
a=p_{1}^{a_{1}}p_{2}^{a_{2}}\cdots p_{k}^{a_{k}}\tag{2-4}
$$  
其中$p_{1},p_{2},\cdots,p_{k}$是素数，$p_{1}<p_{2}<\dots<p_{k}$，$a_{1},a_{2},\cdots,a_{k}$是正整数。  
上述定理给出了整数素数分解的存在性与唯一性，称之为算术基本定理。由此可以看出，整数的素数分解在整数理论以及在整数初等数学中的重要性。  
【定义2.8】若$p_{1},p_{2},\cdots,p_{k}$是素数，$p_{1}<p_{2}<\cdots<p_{k},$，$a_{1},a_{2},\cdots,a_{k}$是正整数，那么称  
$$
a=p_{1}^{a_{1}}p_{2}^{a_{2}}\cdots p_{k}^{a_{k}}\tag{2-6}
$$  
是整数$a$ 的素幂分解式，其中$p_{i}$是素数，$p_{1}<p_{2}<\dots<p_{k}$，$a_{i}$是正整数。【例题2.12】写出51480 的素幂分解式。  
整数的素幂分解式给出了整数一种基于素数的结构表达，在数论研究中具有非常重要的作用。例如，下面两个定理表明，可以使用其素幂分解式计算两个整数的最大公约数和最小公倍数，还可以证明最大公约数和最小公倍数之间的关系。  
【定理2.14】设整数$a,~b$ 的素因子分解式分别为：  
$$
a=p_{1}^{a_{1}}\cdots p_{k}^{a_{k}};\,\,\,b=p_{1}^{b_{1}}\cdots p_{k}^{b_{k}}
$$  
其中$p_{1},\cdots,p_{k}$是互不相同的素数，$a_{1},\cdots,a_{k},\;\;b_{1},\cdots,b_{k}$是非负整数。则有：  
$$
{\operatorname*{gcd}(a,b)=p_{1}^{m i n(a_{1},b_{1})}\cdots p_{k}^{m i n(a_{k},b_{k})\tag{2-7}}}
$$  
$$
{\operatorname{lcm}(a,b)=p_{1}^{m a x(a_{1},b_{1})}\cdots p_{k}^{m a x(a_{k},b_{k})}}\tag{2-8}
$$",最大公约数和最小公倍数之间存在特定关系，可通过素幂分解式证明
素数,讨论,素数的性质,,"通过算术基本定理可以看出，素数是构成所有整数的基本要素，在整个整数理论中占据非常重要的基础性地位。现在我们就来学习有关素数的基本知识，讨论素数的若干基本性质、素数的分布以及相关的查找方法。  
素数的一个非常独特性质是它与其它整数之间具有如下非常简单而直接的关系，这种简单直接的关系是使用素数考察整数性质的基础。  
【定理2.15】假设$p$ 是任意一个给定的素数，则它与其它任意整数$a$ 之间的关系是：要么$p$ 与$a$ 互素，要么$p$ 能够整除$a$。  
可以通过上述定理证明下面结论：  
【定理2.16】假设$p$ 是任意一个给定的素数，$a$ 和$b$ 是任意两个整数，如果$p$ 能整除$a$与$b$ 的乘积，则$p$ 至少能整除$a$ 与$b$ 中的一个。更一般地，假设$a_{1},a_{2},\cdots,a_{k}$是任意给出的$k$个整数，如果素数$p$ 能够整除$a_{1},a_{2},\cdots,a_{k}$，则$p$ 至少能够整除$a_{1},a_{2},\cdots,a_{k}$中的一个。  
下面讨论素数的计数问题。首先考虑在整个正整数集合中，到底有多少个素数？下面的定理给出了答案：  
【定理2.17】正整数集合中的素数有无穷多个。  
下面进一步讨论有限正整数集合中素数的计数与分布情况：  
【定理2.18】设$a$是任意大于1 的整数，则$a$除1 外的最小正因数$q$一定是素数，并且，当$a$是合数时，$q\leq{\sqrt{a}}$，亦即：若$a$ 是合数，则$a$ 必有一个小于等于$\sqrt{a}$的素因子。  
使用上述定理，可以获得一种名为爱氏筛法的素数查找方法。对于任意给定的一个正整数$N$，可以使用该方法找到所有不超过$N$的素数，具体做法如下：  
首先把所有不超过$N$的正整数按从小到大的次序排成一个队列，然后在队列中划去1以及划去一切不超过$\sqrt{N}$的素数的所有倍数，剩下的数即为所求的素数。  
由于有无穷多个素数，因此人们总是希望能够找到尽可能大的素数。300 年来人们找到的最大素数都是$2^{p}-1$这种形式的整数，其中$p$ 也是素数。我们将具有这种形式的素数称为梅森素数，目前有一个名为互联网梅森素数大搜索组织专门搜索大素数，有兴趣的读者可以查阅有关资料了解大素数查找的进展情况。",文本讨论了素数的基本性质
素数,证明,定理2.15,,"通过算术基本定理可以看出，素数是构成所有整数的基本要素，在整个整数理论中占据非常重要的基础性地位。现在我们就来学习有关素数的基本知识，讨论素数的若干基本性质、素数的分布以及相关的查找方法。  
素数的一个非常独特性质是它与其它整数之间具有如下非常简单而直接的关系，这种简单直接的关系是使用素数考察整数性质的基础。  
【定理2.15】假设$p$ 是任意一个给定的素数，则它与其它任意整数$a$ 之间的关系是：要么$p$ 与$a$ 互素，要么$p$ 能够整除$a$。  
可以通过上述定理证明下面结论：  
【定理2.16】假设$p$ 是任意一个给定的素数，$a$ 和$b$ 是任意两个整数，如果$p$ 能整除$a$与$b$ 的乘积，则$p$ 至少能整除$a$ 与$b$ 中的一个。更一般地，假设$a_{1},a_{2},\cdots,a_{k}$是任意给出的$k$个整数，如果素数$p$ 能够整除$a_{1},a_{2},\cdots,a_{k}$，则$p$ 至少能够整除$a_{1},a_{2},\cdots,a_{k}$中的一个。  
下面讨论素数的计数问题。首先考虑在整个正整数集合中，到底有多少个素数？下面的定理给出了答案：  
【定理2.17】正整数集合中的素数有无穷多个。  
下面进一步讨论有限正整数集合中素数的计数与分布情况：  
【定理2.18】设$a$是任意大于1 的整数，则$a$除1 外的最小正因数$q$一定是素数，并且，当$a$是合数时，$q\leq{\sqrt{a}}$，亦即：若$a$ 是合数，则$a$ 必有一个小于等于$\sqrt{a}$的素因子。  
使用上述定理，可以获得一种名为爱氏筛法的素数查找方法。对于任意给定的一个正整数$N$，可以使用该方法找到所有不超过$N$的素数，具体做法如下：  
首先把所有不超过$N$的正整数按从小到大的次序排成一个队列，然后在队列中划去1以及划去一切不超过$\sqrt{N}$的素数的所有倍数，剩下的数即为所求的素数。  
由于有无穷多个素数，因此人们总是希望能够找到尽可能大的素数。300 年来人们找到的最大素数都是$2^{p}-1$这种形式的整数，其中$p$ 也是素数。我们将具有这种形式的素数称为梅森素数，目前有一个名为互联网梅森素数大搜索组织专门搜索大素数，有兴趣的读者可以查阅有关资料了解大素数查找的进展情况。",定理2.15证明了素数与其他整数之间的关系
素数,证明,定理2.16,,"通过算术基本定理可以看出，素数是构成所有整数的基本要素，在整个整数理论中占据非常重要的基础性地位。现在我们就来学习有关素数的基本知识，讨论素数的若干基本性质、素数的分布以及相关的查找方法。  
素数的一个非常独特性质是它与其它整数之间具有如下非常简单而直接的关系，这种简单直接的关系是使用素数考察整数性质的基础。  
【定理2.15】假设$p$ 是任意一个给定的素数，则它与其它任意整数$a$ 之间的关系是：要么$p$ 与$a$ 互素，要么$p$ 能够整除$a$。  
可以通过上述定理证明下面结论：  
【定理2.16】假设$p$ 是任意一个给定的素数，$a$ 和$b$ 是任意两个整数，如果$p$ 能整除$a$与$b$ 的乘积，则$p$ 至少能整除$a$ 与$b$ 中的一个。更一般地，假设$a_{1},a_{2},\cdots,a_{k}$是任意给出的$k$个整数，如果素数$p$ 能够整除$a_{1},a_{2},\cdots,a_{k}$，则$p$ 至少能够整除$a_{1},a_{2},\cdots,a_{k}$中的一个。  
下面讨论素数的计数问题。首先考虑在整个正整数集合中，到底有多少个素数？下面的定理给出了答案：  
【定理2.17】正整数集合中的素数有无穷多个。  
下面进一步讨论有限正整数集合中素数的计数与分布情况：  
【定理2.18】设$a$是任意大于1 的整数，则$a$除1 外的最小正因数$q$一定是素数，并且，当$a$是合数时，$q\leq{\sqrt{a}}$，亦即：若$a$ 是合数，则$a$ 必有一个小于等于$\sqrt{a}$的素因子。  
使用上述定理，可以获得一种名为爱氏筛法的素数查找方法。对于任意给定的一个正整数$N$，可以使用该方法找到所有不超过$N$的素数，具体做法如下：  
首先把所有不超过$N$的正整数按从小到大的次序排成一个队列，然后在队列中划去1以及划去一切不超过$\sqrt{N}$的素数的所有倍数，剩下的数即为所求的素数。  
由于有无穷多个素数，因此人们总是希望能够找到尽可能大的素数。300 年来人们找到的最大素数都是$2^{p}-1$这种形式的整数，其中$p$ 也是素数。我们将具有这种形式的素数称为梅森素数，目前有一个名为互联网梅森素数大搜索组织专门搜索大素数，有兴趣的读者可以查阅有关资料了解大素数查找的进展情况。",定理2.16证明了素数能整除整数乘积的性质
素数的计数问题,解答,定理2.17,,"通过算术基本定理可以看出，素数是构成所有整数的基本要素，在整个整数理论中占据非常重要的基础性地位。现在我们就来学习有关素数的基本知识，讨论素数的若干基本性质、素数的分布以及相关的查找方法。  
素数的一个非常独特性质是它与其它整数之间具有如下非常简单而直接的关系，这种简单直接的关系是使用素数考察整数性质的基础。  
【定理2.15】假设$p$ 是任意一个给定的素数，则它与其它任意整数$a$ 之间的关系是：要么$p$ 与$a$ 互素，要么$p$ 能够整除$a$。  
可以通过上述定理证明下面结论：  
【定理2.16】假设$p$ 是任意一个给定的素数，$a$ 和$b$ 是任意两个整数，如果$p$ 能整除$a$与$b$ 的乘积，则$p$ 至少能整除$a$ 与$b$ 中的一个。更一般地，假设$a_{1},a_{2},\cdots,a_{k}$是任意给出的$k$个整数，如果素数$p$ 能够整除$a_{1},a_{2},\cdots,a_{k}$，则$p$ 至少能够整除$a_{1},a_{2},\cdots,a_{k}$中的一个。  
下面讨论素数的计数问题。首先考虑在整个正整数集合中，到底有多少个素数？下面的定理给出了答案：  
【定理2.17】正整数集合中的素数有无穷多个。  
下面进一步讨论有限正整数集合中素数的计数与分布情况：  
【定理2.18】设$a$是任意大于1 的整数，则$a$除1 外的最小正因数$q$一定是素数，并且，当$a$是合数时，$q\leq{\sqrt{a}}$，亦即：若$a$ 是合数，则$a$ 必有一个小于等于$\sqrt{a}$的素因子。  
使用上述定理，可以获得一种名为爱氏筛法的素数查找方法。对于任意给定的一个正整数$N$，可以使用该方法找到所有不超过$N$的素数，具体做法如下：  
首先把所有不超过$N$的正整数按从小到大的次序排成一个队列，然后在队列中划去1以及划去一切不超过$\sqrt{N}$的素数的所有倍数，剩下的数即为所求的素数。  
由于有无穷多个素数，因此人们总是希望能够找到尽可能大的素数。300 年来人们找到的最大素数都是$2^{p}-1$这种形式的整数，其中$p$ 也是素数。我们将具有这种形式的素数称为梅森素数，目前有一个名为互联网梅森素数大搜索组织专门搜索大素数，有兴趣的读者可以查阅有关资料了解大素数查找的进展情况。",定理2.17解答了素数有无穷多个的问题
素数的计数问题,讨论,定理2.18,,"通过算术基本定理可以看出，素数是构成所有整数的基本要素，在整个整数理论中占据非常重要的基础性地位。现在我们就来学习有关素数的基本知识，讨论素数的若干基本性质、素数的分布以及相关的查找方法。  
素数的一个非常独特性质是它与其它整数之间具有如下非常简单而直接的关系，这种简单直接的关系是使用素数考察整数性质的基础。  
【定理2.15】假设$p$ 是任意一个给定的素数，则它与其它任意整数$a$ 之间的关系是：要么$p$ 与$a$ 互素，要么$p$ 能够整除$a$。  
可以通过上述定理证明下面结论：  
【定理2.16】假设$p$ 是任意一个给定的素数，$a$ 和$b$ 是任意两个整数，如果$p$ 能整除$a$与$b$ 的乘积，则$p$ 至少能整除$a$ 与$b$ 中的一个。更一般地，假设$a_{1},a_{2},\cdots,a_{k}$是任意给出的$k$个整数，如果素数$p$ 能够整除$a_{1},a_{2},\cdots,a_{k}$，则$p$ 至少能够整除$a_{1},a_{2},\cdots,a_{k}$中的一个。  
下面讨论素数的计数问题。首先考虑在整个正整数集合中，到底有多少个素数？下面的定理给出了答案：  
【定理2.17】正整数集合中的素数有无穷多个。  
下面进一步讨论有限正整数集合中素数的计数与分布情况：  
【定理2.18】设$a$是任意大于1 的整数，则$a$除1 外的最小正因数$q$一定是素数，并且，当$a$是合数时，$q\leq{\sqrt{a}}$，亦即：若$a$ 是合数，则$a$ 必有一个小于等于$\sqrt{a}$的素因子。  
使用上述定理，可以获得一种名为爱氏筛法的素数查找方法。对于任意给定的一个正整数$N$，可以使用该方法找到所有不超过$N$的素数，具体做法如下：  
首先把所有不超过$N$的正整数按从小到大的次序排成一个队列，然后在队列中划去1以及划去一切不超过$\sqrt{N}$的素数的所有倍数，剩下的数即为所求的素数。  
由于有无穷多个素数，因此人们总是希望能够找到尽可能大的素数。300 年来人们找到的最大素数都是$2^{p}-1$这种形式的整数，其中$p$ 也是素数。我们将具有这种形式的素数称为梅森素数，目前有一个名为互联网梅森素数大搜索组织专门搜索大素数，有兴趣的读者可以查阅有关资料了解大素数查找的进展情况。",定理2.18讨论了有限正整数集合中素数的计数与分布
素数,应用,爱氏筛法,,"通过算术基本定理可以看出，素数是构成所有整数的基本要素，在整个整数理论中占据非常重要的基础性地位。现在我们就来学习有关素数的基本知识，讨论素数的若干基本性质、素数的分布以及相关的查找方法。  
素数的一个非常独特性质是它与其它整数之间具有如下非常简单而直接的关系，这种简单直接的关系是使用素数考察整数性质的基础。  
【定理2.15】假设$p$ 是任意一个给定的素数，则它与其它任意整数$a$ 之间的关系是：要么$p$ 与$a$ 互素，要么$p$ 能够整除$a$。  
可以通过上述定理证明下面结论：  
【定理2.16】假设$p$ 是任意一个给定的素数，$a$ 和$b$ 是任意两个整数，如果$p$ 能整除$a$与$b$ 的乘积，则$p$ 至少能整除$a$ 与$b$ 中的一个。更一般地，假设$a_{1},a_{2},\cdots,a_{k}$是任意给出的$k$个整数，如果素数$p$ 能够整除$a_{1},a_{2},\cdots,a_{k}$，则$p$ 至少能够整除$a_{1},a_{2},\cdots,a_{k}$中的一个。  
下面讨论素数的计数问题。首先考虑在整个正整数集合中，到底有多少个素数？下面的定理给出了答案：  
【定理2.17】正整数集合中的素数有无穷多个。  
下面进一步讨论有限正整数集合中素数的计数与分布情况：  
【定理2.18】设$a$是任意大于1 的整数，则$a$除1 外的最小正因数$q$一定是素数，并且，当$a$是合数时，$q\leq{\sqrt{a}}$，亦即：若$a$ 是合数，则$a$ 必有一个小于等于$\sqrt{a}$的素因子。  
使用上述定理，可以获得一种名为爱氏筛法的素数查找方法。对于任意给定的一个正整数$N$，可以使用该方法找到所有不超过$N$的素数，具体做法如下：  
首先把所有不超过$N$的正整数按从小到大的次序排成一个队列，然后在队列中划去1以及划去一切不超过$\sqrt{N}$的素数的所有倍数，剩下的数即为所求的素数。  
由于有无穷多个素数，因此人们总是希望能够找到尽可能大的素数。300 年来人们找到的最大素数都是$2^{p}-1$这种形式的整数，其中$p$ 也是素数。我们将具有这种形式的素数称为梅森素数，目前有一个名为互联网梅森素数大搜索组织专门搜索大素数，有兴趣的读者可以查阅有关资料了解大素数查找的进展情况。",爱氏筛法用于查找不超过给定正整数的所有素数
素数,特例,梅森素数,,"通过算术基本定理可以看出，素数是构成所有整数的基本要素，在整个整数理论中占据非常重要的基础性地位。现在我们就来学习有关素数的基本知识，讨论素数的若干基本性质、素数的分布以及相关的查找方法。  
素数的一个非常独特性质是它与其它整数之间具有如下非常简单而直接的关系，这种简单直接的关系是使用素数考察整数性质的基础。  
【定理2.15】假设$p$ 是任意一个给定的素数，则它与其它任意整数$a$ 之间的关系是：要么$p$ 与$a$ 互素，要么$p$ 能够整除$a$。  
可以通过上述定理证明下面结论：  
【定理2.16】假设$p$ 是任意一个给定的素数，$a$ 和$b$ 是任意两个整数，如果$p$ 能整除$a$与$b$ 的乘积，则$p$ 至少能整除$a$ 与$b$ 中的一个。更一般地，假设$a_{1},a_{2},\cdots,a_{k}$是任意给出的$k$个整数，如果素数$p$ 能够整除$a_{1},a_{2},\cdots,a_{k}$，则$p$ 至少能够整除$a_{1},a_{2},\cdots,a_{k}$中的一个。  
下面讨论素数的计数问题。首先考虑在整个正整数集合中，到底有多少个素数？下面的定理给出了答案：  
【定理2.17】正整数集合中的素数有无穷多个。  
下面进一步讨论有限正整数集合中素数的计数与分布情况：  
【定理2.18】设$a$是任意大于1 的整数，则$a$除1 外的最小正因数$q$一定是素数，并且，当$a$是合数时，$q\leq{\sqrt{a}}$，亦即：若$a$ 是合数，则$a$ 必有一个小于等于$\sqrt{a}$的素因子。  
使用上述定理，可以获得一种名为爱氏筛法的素数查找方法。对于任意给定的一个正整数$N$，可以使用该方法找到所有不超过$N$的素数，具体做法如下：  
首先把所有不超过$N$的正整数按从小到大的次序排成一个队列，然后在队列中划去1以及划去一切不超过$\sqrt{N}$的素数的所有倍数，剩下的数即为所求的素数。  
由于有无穷多个素数，因此人们总是希望能够找到尽可能大的素数。300 年来人们找到的最大素数都是$2^{p}-1$这种形式的整数，其中$p$ 也是素数。我们将具有这种形式的素数称为梅森素数，目前有一个名为互联网梅森素数大搜索组织专门搜索大素数，有兴趣的读者可以查阅有关资料了解大素数查找的进展情况。",梅森素数是具有特定形式的素数
同余算术,包含,同余关系,,前面关于整数理论的讨论主要基于整数整除的概念与性质。由于整除是一个是整数之间一个比较强的约束关系，很多整数都不能满足，因此引入一种具有普适性的带余除法概念，将整数的整除归结为一种余数为0 的特殊带余除法。德国数学家高斯则是从带余除法的角度对整除的概念进行推广，引入同余的概念及相关算术。从带余除法的角度看，同余并非像整除那样要求余数一定为0，而只要求两个整数被某个除数做带余除法后得到的余数相等，这个约束显然比整除的约束宽松很多。同余算术是整理理论一个重要发展并构成初等数论的理论核心，它从在一种比整除约束更为宽松的条件下考察整数的运算及性质并得到很多非常精彩的数论成果，这些成果在整数加密算法设计等多个领域得到广泛应用。本节主要介绍同余算术的概念、性质与应用，具体包括同余关系及其运算、剩余系的概念与性质、同余方程与方程组的求解、若干经典的整数加密算法。,同余算术包含同余关系及其运算
同余算术,包含,剩余系,,前面关于整数理论的讨论主要基于整数整除的概念与性质。由于整除是一个是整数之间一个比较强的约束关系，很多整数都不能满足，因此引入一种具有普适性的带余除法概念，将整数的整除归结为一种余数为0 的特殊带余除法。德国数学家高斯则是从带余除法的角度对整除的概念进行推广，引入同余的概念及相关算术。从带余除法的角度看，同余并非像整除那样要求余数一定为0，而只要求两个整数被某个除数做带余除法后得到的余数相等，这个约束显然比整除的约束宽松很多。同余算术是整理理论一个重要发展并构成初等数论的理论核心，它从在一种比整除约束更为宽松的条件下考察整数的运算及性质并得到很多非常精彩的数论成果，这些成果在整数加密算法设计等多个领域得到广泛应用。本节主要介绍同余算术的概念、性质与应用，具体包括同余关系及其运算、剩余系的概念与性质、同余方程与方程组的求解、若干经典的整数加密算法。,同余算术包含剩余系的概念与性质
同余算术,包含,同余方程,,前面关于整数理论的讨论主要基于整数整除的概念与性质。由于整除是一个是整数之间一个比较强的约束关系，很多整数都不能满足，因此引入一种具有普适性的带余除法概念，将整数的整除归结为一种余数为0 的特殊带余除法。德国数学家高斯则是从带余除法的角度对整除的概念进行推广，引入同余的概念及相关算术。从带余除法的角度看，同余并非像整除那样要求余数一定为0，而只要求两个整数被某个除数做带余除法后得到的余数相等，这个约束显然比整除的约束宽松很多。同余算术是整理理论一个重要发展并构成初等数论的理论核心，它从在一种比整除约束更为宽松的条件下考察整数的运算及性质并得到很多非常精彩的数论成果，这些成果在整数加密算法设计等多个领域得到广泛应用。本节主要介绍同余算术的概念、性质与应用，具体包括同余关系及其运算、剩余系的概念与性质、同余方程与方程组的求解、若干经典的整数加密算法。,同余算术包含同余方程与方程组的求解
同余算术,应用,整数加密算法,,前面关于整数理论的讨论主要基于整数整除的概念与性质。由于整除是一个是整数之间一个比较强的约束关系，很多整数都不能满足，因此引入一种具有普适性的带余除法概念，将整数的整除归结为一种余数为0 的特殊带余除法。德国数学家高斯则是从带余除法的角度对整除的概念进行推广，引入同余的概念及相关算术。从带余除法的角度看，同余并非像整除那样要求余数一定为0，而只要求两个整数被某个除数做带余除法后得到的余数相等，这个约束显然比整除的约束宽松很多。同余算术是整理理论一个重要发展并构成初等数论的理论核心，它从在一种比整除约束更为宽松的条件下考察整数的运算及性质并得到很多非常精彩的数论成果，这些成果在整数加密算法设计等多个领域得到广泛应用。本节主要介绍同余算术的概念、性质与应用，具体包括同余关系及其运算、剩余系的概念与性质、同余方程与方程组的求解、若干经典的整数加密算法。,同余算术的成果在整数加密算法设计等领域得到广泛应用
同余关系,定义,模m同余的判定定理,,"在很多场合，我们往往只关心用某一特定正整数除以整数得到的余数。例如，星期日期就是从某个星期日开始经历的天数除以7 得到的余数，通过对天数取以7 为除数的余数，就可以用短短的7 个数字借助以7 为周期的循环机制表示无穷无尽的天数。事实上，取余数是一种以有限驾驭无限的重要智慧，对于任一给定的正整数$m$，通过考察所有整数除以$m$ 所得余数的差异，把所有具有相同余数的整数归为一类，则可将所有整数分为$m$ 个基本类型。若分别从每个类中取一个整数作为代表构成一个$m$ 元有限集，则可将这个有限集看成是对整数集的一个抽象，由此完成了整数集从无限向有限的转化。在这个分类过程中，整数之间是否具有相同余数的关系起着非常关键的作用，由此得到如下同余的概念：  
【定义2.9】假设$m$ 是任一给定的正整数，对于任意两个整数$a$和$b$，它们除以$m$ 后得到的余数分别记为$a({\bmod{\ m}})$和$b({\bmod{\ m}})$，如果这两个余数相等，即有：  
$$
a({\bmod{\ m}})=b({\bmod{\ m}})\tag{2-9}
$$  
则称$a$与$b$具有模$\pmb{m}$同余关系，简称为$a$与$b$模$\pmb{m}$同余或同余，记为$a\equiv b({\bmod{m}})$或$b\equiv$$a({\bmod{\ m}})$；否则称$a$与$b$对于模$\mathbfit{m}$不同余，记为$a\not\equiv b({\bmod{{m}}})$或$b\not\equiv a({\bmod{\ m}})$。  
根据上述定义，不难证明下面关于模$_m$同余的判定定理：  
【定理2.19】假设$m$是任一给定的正整数，任意两个整数$a$和$b$具有模$_m$同余关系，当且仅当$m$能够整除$a-b$。  
【定理2.20】假设$m$ 是任一给定的正整数，任意两个整数$a$ 和$b$ 具有模$m$同余关系，  
当且仅当存在整数$k$，使得整除$a=b+k m$  
下面定理表明了同余关系的保加性和保乘性：  
【定理2.21】设$m$ 是任一正整数，若整数$a$ 与$b$ 模$m$ 同余，整数$c$与$d$ 同余模$m$，则它们的和与积也分别模$m$ 同余。即：若$a\equiv b({\bmod{\ }}m)$，$c\equiv d({\bmod{\pmod{m}}})$，则有：  
$$
a+c\equiv(b+d)(\bmod{\ m}),\ \ a c\equiv b d(\bmod{\ m})
$$  
【定理2.22】假设$m$ 是任一给定的正整数，则对任意两个整数$a$ 和$b$，成立下面两个关于余数的计算公式：  
$$
(a+b){\bmod{\ m}}=((a{\bmod{\ m}})+(b{\bmod{\ m}})){\bmod{\ m}}\tag{2-10}
$$  
$$
ab\ {\bmod{\ m}}=((a{\bmod{\ m}})(b{\bmod{\ m}}))\ {\bmod{\ m}}\tag{2-11}
$$  
例如，对于$7\equiv2{\bmod{\mathrm{~5~}}}$和$11\equiv1{\bmod{\mathrm{~5~}}}$，由定理2.21 知：  
$$
18=7+11\equiv2+1=3({\bmod{\mathrm{~}}}5)
$$  
$$
77=7\cdot11\equiv2\cdot1=2{\pmod{5}}
$$  
再如，对于任意三个数，比如说1, 2 和5，由定理2.22 知存在如下等式：  
$$
(1+2)({\bmod{\ }}5)=((1\ \,({\bmod{\ }}5)+(2\ \,({\bmod{\ }}5))({\bmod{\ }}5)
$$  
$$
2\,\bmod\,5=\left((1\,\bmod\,5)(2\,\bmod\,5)\right)\,(\bmod\,5)
$$  
值得注意的是，同余关系在一般情况下不满足消去律，例如 $8\equiv12({\bmod{\mathrm{~}}}4)$，两边同除以4 后，$2\equiv3({\bmod{\mathrm{~}}}4)$显然是不成立的，但是存在下列性质：  
【定理2.23】若$a c\equiv b c({\bmod{\pmod{m}}})$，且$c$ 与$m$ 互素，则有：$a\equiv b({\bmod{\ }}m)$  
如前所述，使用同余可以实现对整数集合的划分或分类，现在就来讨论这个问题。由同余的定义可知，对于任意给定的正整数$m$，可依照除以$m$ 后的余数值以及模$m$ 同余关系，将所有整数划分为$m$ 个互不相交的子集合。据此，我们引入如下同余类的概念：  
【定义2.10】设$m$ 是任一给定正整数，对于每个整数$i$，$0\leq i<m$，定义如下集合：  
$$
R_{i}(m)=\{n|n\equiv i({\bmod{\pmod{\ m}}},n\in Z\}\tag{2-12}
$$  
则称每个$^{}R_{i}(m)$分别是模$m$ 的一个同余类或剩余类，在不引起混淆的情况下，通常也将$R_{i}(m)$简记为$[i]$，并记为：$Z_{m}=\{[0],[1],\cdots[m-1]\}.$。  
【定理2.24】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m),$所有模$m$ 同余类，则有下述结论成立：  
（1）每个整数$a$ 都恰好属于某个同余类，通常将这个同余类记为$[a]_{m}$或$[a]$  
（2）对于任意的两个整数$a$ 和$b$，它们属于同一个同余类的充分必要条件是：
$$
a\equiv b({\bmod{m}})
$$  
上述定理表明，每个整数必定属于且仅属于其中一个剩余类，属于同一个剩余类的任意两个整数都是模$m$ 同余的，属于不同剩余类的任意两个整数不可能是模$m$ 同余的。  
根据定理，可以在$.Z_{m}=\{[0],[1],\cdots[m-1]\}$上定义关于同余类的加法和乘法运算：  
【定义2.11】假设$m$ 是任一给定的正整数对于任意给定的两个整数$a$和$b$，定义：
$$
[a]_{m}+[b]_{m}=[a+b]_{m}
$$  
$$
[a]_{m}\cdot[b]_{m}=[a\cdot b]_{m}
$$  
【定义2.12】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m)$是所有模$m$ 同余类，如果从每个同余类$R_{i}(m)$中分别取一个整数$x_{i}$构成一个$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$，则称该有限集合为模$m$ 的一个完全剩余系，简称为完全系；称$m$ 元有限集合$\{0,\ 1,\ 2,\ \cdots\ ,$为最小非负完全剩余系。  
对于正整数$m$，假设$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$是模$m$ 的一个完全剩余系，对于其中的任意一个整数$\cdot x_{i}$，如果${\bf\nabla}_{}^{}$与$m$ 互素，则$x_{i}$所在同余类${\mathbf{}}R_{i}(m)$中每个整数$k$ 都与$m$ 互素。这是因为根据$k\equiv x_{i}({\bmod{\pmod{m}}})$，即有$\cdot_{x_{i}}=k+q m$。由此可知，如果$k$ 与$m$有大于1 的公因子，那么$x_{i}$必然与$m$ 有大于1 的公因子。类似地，如果$x_{i}$与$m$ 互素，则$x_{i}$所在同余类$R_{i}(m)$中每个整数$k$ 都与$m$ 不互素。由此得到如下简化同余类和简化剩余系的概念：  
【定义2.13】对于正整数$m$，假设$R_{i}(m)$是任意一个模$m$ 同余类，若$R_{i}(m)$中存在一个整数与 $m$  互素，则称 $\ R_{i}(m)$ 是一个模 $\pmb{m}$  简化同余类或模 $\pmb{m}$  简化剩余类。如果分别从每个模 $m$ 简化同余类中取出一个整数作为代表$x_{i}$构成一个有限集合$\{x_{0},\ x_{1},\ \cdots,x_{\varphi(m-1)}\}$，则称该集合为模$m$ 的一个简化剩余系，简称为简化系。其中$\varphi(m)$称为欧拉函数，表示模$m$ 简化剩余类的数目，亦即不超过$m$ 且与$m$ 互素的正整数个数。  
因为所有模$m$ 同余类构成整数集合的一个划分，所以每个与$m$ 互质的整数仅存在于它  所在的简化同余类中。由此可以看出，简化同余类以及欧拉函数$\varphi(m)$在整数互质性质的研究中具有非常重要的作用，后面将使用这些概念证明欧拉定理和费马小定理。这两个定理不仅是整数理论中非常著名而重要的定理，而且还是现代非对称数论加密算法的基础。",模m同余的判定定理定义了同余关系的判定条件，即两个整数a和b模m同余当且仅当m能整除a-b。
同余关系,性质,同余关系的保加性和保乘性,,"在很多场合，我们往往只关心用某一特定正整数除以整数得到的余数。例如，星期日期就是从某个星期日开始经历的天数除以7 得到的余数，通过对天数取以7 为除数的余数，就可以用短短的7 个数字借助以7 为周期的循环机制表示无穷无尽的天数。事实上，取余数是一种以有限驾驭无限的重要智慧，对于任一给定的正整数$m$，通过考察所有整数除以$m$ 所得余数的差异，把所有具有相同余数的整数归为一类，则可将所有整数分为$m$ 个基本类型。若分别从每个类中取一个整数作为代表构成一个$m$ 元有限集，则可将这个有限集看成是对整数集的一个抽象，由此完成了整数集从无限向有限的转化。在这个分类过程中，整数之间是否具有相同余数的关系起着非常关键的作用，由此得到如下同余的概念：  
【定义2.9】假设$m$ 是任一给定的正整数，对于任意两个整数$a$和$b$，它们除以$m$ 后得到的余数分别记为$a({\bmod{\ m}})$和$b({\bmod{\ m}})$，如果这两个余数相等，即有：  
$$
a({\bmod{\ m}})=b({\bmod{\ m}})\tag{2-9}
$$  
则称$a$与$b$具有模$\pmb{m}$同余关系，简称为$a$与$b$模$\pmb{m}$同余或同余，记为$a\equiv b({\bmod{m}})$或$b\equiv$$a({\bmod{\ m}})$；否则称$a$与$b$对于模$\mathbfit{m}$不同余，记为$a\not\equiv b({\bmod{{m}}})$或$b\not\equiv a({\bmod{\ m}})$。  
根据上述定义，不难证明下面关于模$_m$同余的判定定理：  
【定理2.19】假设$m$是任一给定的正整数，任意两个整数$a$和$b$具有模$_m$同余关系，当且仅当$m$能够整除$a-b$。  
【定理2.20】假设$m$ 是任一给定的正整数，任意两个整数$a$ 和$b$ 具有模$m$同余关系，  
当且仅当存在整数$k$，使得整除$a=b+k m$  
下面定理表明了同余关系的保加性和保乘性：  
【定理2.21】设$m$ 是任一正整数，若整数$a$ 与$b$ 模$m$ 同余，整数$c$与$d$ 同余模$m$，则它们的和与积也分别模$m$ 同余。即：若$a\equiv b({\bmod{\ }}m)$，$c\equiv d({\bmod{\pmod{m}}})$，则有：  
$$
a+c\equiv(b+d)(\bmod{\ m}),\ \ a c\equiv b d(\bmod{\ m})
$$  
【定理2.22】假设$m$ 是任一给定的正整数，则对任意两个整数$a$ 和$b$，成立下面两个关于余数的计算公式：  
$$
(a+b){\bmod{\ m}}=((a{\bmod{\ m}})+(b{\bmod{\ m}})){\bmod{\ m}}\tag{2-10}
$$  
$$
ab\ {\bmod{\ m}}=((a{\bmod{\ m}})(b{\bmod{\ m}}))\ {\bmod{\ m}}\tag{2-11}
$$  
例如，对于$7\equiv2{\bmod{\mathrm{~5~}}}$和$11\equiv1{\bmod{\mathrm{~5~}}}$，由定理2.21 知：  
$$
18=7+11\equiv2+1=3({\bmod{\mathrm{~}}}5)
$$  
$$
77=7\cdot11\equiv2\cdot1=2{\pmod{5}}
$$  
再如，对于任意三个数，比如说1, 2 和5，由定理2.22 知存在如下等式：  
$$
(1+2)({\bmod{\ }}5)=((1\ \,({\bmod{\ }}5)+(2\ \,({\bmod{\ }}5))({\bmod{\ }}5)
$$  
$$
2\,\bmod\,5=\left((1\,\bmod\,5)(2\,\bmod\,5)\right)\,(\bmod\,5)
$$  
值得注意的是，同余关系在一般情况下不满足消去律，例如 $8\equiv12({\bmod{\mathrm{~}}}4)$，两边同除以4 后，$2\equiv3({\bmod{\mathrm{~}}}4)$显然是不成立的，但是存在下列性质：  
【定理2.23】若$a c\equiv b c({\bmod{\pmod{m}}})$，且$c$ 与$m$ 互素，则有：$a\equiv b({\bmod{\ }}m)$  
如前所述，使用同余可以实现对整数集合的划分或分类，现在就来讨论这个问题。由同余的定义可知，对于任意给定的正整数$m$，可依照除以$m$ 后的余数值以及模$m$ 同余关系，将所有整数划分为$m$ 个互不相交的子集合。据此，我们引入如下同余类的概念：  
【定义2.10】设$m$ 是任一给定正整数，对于每个整数$i$，$0\leq i<m$，定义如下集合：  
$$
R_{i}(m)=\{n|n\equiv i({\bmod{\pmod{\ m}}},n\in Z\}\tag{2-12}
$$  
则称每个$^{}R_{i}(m)$分别是模$m$ 的一个同余类或剩余类，在不引起混淆的情况下，通常也将$R_{i}(m)$简记为$[i]$，并记为：$Z_{m}=\{[0],[1],\cdots[m-1]\}.$。  
【定理2.24】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m),$所有模$m$ 同余类，则有下述结论成立：  
（1）每个整数$a$ 都恰好属于某个同余类，通常将这个同余类记为$[a]_{m}$或$[a]$  
（2）对于任意的两个整数$a$ 和$b$，它们属于同一个同余类的充分必要条件是：
$$
a\equiv b({\bmod{m}})
$$  
上述定理表明，每个整数必定属于且仅属于其中一个剩余类，属于同一个剩余类的任意两个整数都是模$m$ 同余的，属于不同剩余类的任意两个整数不可能是模$m$ 同余的。  
根据定理，可以在$.Z_{m}=\{[0],[1],\cdots[m-1]\}$上定义关于同余类的加法和乘法运算：  
【定义2.11】假设$m$ 是任一给定的正整数对于任意给定的两个整数$a$和$b$，定义：
$$
[a]_{m}+[b]_{m}=[a+b]_{m}
$$  
$$
[a]_{m}\cdot[b]_{m}=[a\cdot b]_{m}
$$  
【定义2.12】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m)$是所有模$m$ 同余类，如果从每个同余类$R_{i}(m)$中分别取一个整数$x_{i}$构成一个$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$，则称该有限集合为模$m$ 的一个完全剩余系，简称为完全系；称$m$ 元有限集合$\{0,\ 1,\ 2,\ \cdots\ ,$为最小非负完全剩余系。  
对于正整数$m$，假设$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$是模$m$ 的一个完全剩余系，对于其中的任意一个整数$\cdot x_{i}$，如果${\bf\nabla}_{}^{}$与$m$ 互素，则$x_{i}$所在同余类${\mathbf{}}R_{i}(m)$中每个整数$k$ 都与$m$ 互素。这是因为根据$k\equiv x_{i}({\bmod{\pmod{m}}})$，即有$\cdot_{x_{i}}=k+q m$。由此可知，如果$k$ 与$m$有大于1 的公因子，那么$x_{i}$必然与$m$ 有大于1 的公因子。类似地，如果$x_{i}$与$m$ 互素，则$x_{i}$所在同余类$R_{i}(m)$中每个整数$k$ 都与$m$ 不互素。由此得到如下简化同余类和简化剩余系的概念：  
【定义2.13】对于正整数$m$，假设$R_{i}(m)$是任意一个模$m$ 同余类，若$R_{i}(m)$中存在一个整数与 $m$  互素，则称 $\ R_{i}(m)$ 是一个模 $\pmb{m}$  简化同余类或模 $\pmb{m}$  简化剩余类。如果分别从每个模 $m$ 简化同余类中取出一个整数作为代表$x_{i}$构成一个有限集合$\{x_{0},\ x_{1},\ \cdots,x_{\varphi(m-1)}\}$，则称该集合为模$m$ 的一个简化剩余系，简称为简化系。其中$\varphi(m)$称为欧拉函数，表示模$m$ 简化剩余类的数目，亦即不超过$m$ 且与$m$ 互素的正整数个数。  
因为所有模$m$ 同余类构成整数集合的一个划分，所以每个与$m$ 互质的整数仅存在于它  所在的简化同余类中。由此可以看出，简化同余类以及欧拉函数$\varphi(m)$在整数互质性质的研究中具有非常重要的作用，后面将使用这些概念证明欧拉定理和费马小定理。这两个定理不仅是整数理论中非常著名而重要的定理，而且还是现代非对称数论加密算法的基础。",同余关系的保加性和保乘性表明，若两个整数对分别模m同余，则它们的和与积也分别模m同余。
同余类的概念,描述,同余类的性质,,"在很多场合，我们往往只关心用某一特定正整数除以整数得到的余数。例如，星期日期就是从某个星期日开始经历的天数除以7 得到的余数，通过对天数取以7 为除数的余数，就可以用短短的7 个数字借助以7 为周期的循环机制表示无穷无尽的天数。事实上，取余数是一种以有限驾驭无限的重要智慧，对于任一给定的正整数$m$，通过考察所有整数除以$m$ 所得余数的差异，把所有具有相同余数的整数归为一类，则可将所有整数分为$m$ 个基本类型。若分别从每个类中取一个整数作为代表构成一个$m$ 元有限集，则可将这个有限集看成是对整数集的一个抽象，由此完成了整数集从无限向有限的转化。在这个分类过程中，整数之间是否具有相同余数的关系起着非常关键的作用，由此得到如下同余的概念：  
【定义2.9】假设$m$ 是任一给定的正整数，对于任意两个整数$a$和$b$，它们除以$m$ 后得到的余数分别记为$a({\bmod{\ m}})$和$b({\bmod{\ m}})$，如果这两个余数相等，即有：  
$$
a({\bmod{\ m}})=b({\bmod{\ m}})\tag{2-9}
$$  
则称$a$与$b$具有模$\pmb{m}$同余关系，简称为$a$与$b$模$\pmb{m}$同余或同余，记为$a\equiv b({\bmod{m}})$或$b\equiv$$a({\bmod{\ m}})$；否则称$a$与$b$对于模$\mathbfit{m}$不同余，记为$a\not\equiv b({\bmod{{m}}})$或$b\not\equiv a({\bmod{\ m}})$。  
根据上述定义，不难证明下面关于模$_m$同余的判定定理：  
【定理2.19】假设$m$是任一给定的正整数，任意两个整数$a$和$b$具有模$_m$同余关系，当且仅当$m$能够整除$a-b$。  
【定理2.20】假设$m$ 是任一给定的正整数，任意两个整数$a$ 和$b$ 具有模$m$同余关系，  
当且仅当存在整数$k$，使得整除$a=b+k m$  
下面定理表明了同余关系的保加性和保乘性：  
【定理2.21】设$m$ 是任一正整数，若整数$a$ 与$b$ 模$m$ 同余，整数$c$与$d$ 同余模$m$，则它们的和与积也分别模$m$ 同余。即：若$a\equiv b({\bmod{\ }}m)$，$c\equiv d({\bmod{\pmod{m}}})$，则有：  
$$
a+c\equiv(b+d)(\bmod{\ m}),\ \ a c\equiv b d(\bmod{\ m})
$$  
【定理2.22】假设$m$ 是任一给定的正整数，则对任意两个整数$a$ 和$b$，成立下面两个关于余数的计算公式：  
$$
(a+b){\bmod{\ m}}=((a{\bmod{\ m}})+(b{\bmod{\ m}})){\bmod{\ m}}\tag{2-10}
$$  
$$
ab\ {\bmod{\ m}}=((a{\bmod{\ m}})(b{\bmod{\ m}}))\ {\bmod{\ m}}\tag{2-11}
$$  
例如，对于$7\equiv2{\bmod{\mathrm{~5~}}}$和$11\equiv1{\bmod{\mathrm{~5~}}}$，由定理2.21 知：  
$$
18=7+11\equiv2+1=3({\bmod{\mathrm{~}}}5)
$$  
$$
77=7\cdot11\equiv2\cdot1=2{\pmod{5}}
$$  
再如，对于任意三个数，比如说1, 2 和5，由定理2.22 知存在如下等式：  
$$
(1+2)({\bmod{\ }}5)=((1\ \,({\bmod{\ }}5)+(2\ \,({\bmod{\ }}5))({\bmod{\ }}5)
$$  
$$
2\,\bmod\,5=\left((1\,\bmod\,5)(2\,\bmod\,5)\right)\,(\bmod\,5)
$$  
值得注意的是，同余关系在一般情况下不满足消去律，例如 $8\equiv12({\bmod{\mathrm{~}}}4)$，两边同除以4 后，$2\equiv3({\bmod{\mathrm{~}}}4)$显然是不成立的，但是存在下列性质：  
【定理2.23】若$a c\equiv b c({\bmod{\pmod{m}}})$，且$c$ 与$m$ 互素，则有：$a\equiv b({\bmod{\ }}m)$  
如前所述，使用同余可以实现对整数集合的划分或分类，现在就来讨论这个问题。由同余的定义可知，对于任意给定的正整数$m$，可依照除以$m$ 后的余数值以及模$m$ 同余关系，将所有整数划分为$m$ 个互不相交的子集合。据此，我们引入如下同余类的概念：  
【定义2.10】设$m$ 是任一给定正整数，对于每个整数$i$，$0\leq i<m$，定义如下集合：  
$$
R_{i}(m)=\{n|n\equiv i({\bmod{\pmod{\ m}}},n\in Z\}\tag{2-12}
$$  
则称每个$^{}R_{i}(m)$分别是模$m$ 的一个同余类或剩余类，在不引起混淆的情况下，通常也将$R_{i}(m)$简记为$[i]$，并记为：$Z_{m}=\{[0],[1],\cdots[m-1]\}.$。  
【定理2.24】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m),$所有模$m$ 同余类，则有下述结论成立：  
（1）每个整数$a$ 都恰好属于某个同余类，通常将这个同余类记为$[a]_{m}$或$[a]$  
（2）对于任意的两个整数$a$ 和$b$，它们属于同一个同余类的充分必要条件是：
$$
a\equiv b({\bmod{m}})
$$  
上述定理表明，每个整数必定属于且仅属于其中一个剩余类，属于同一个剩余类的任意两个整数都是模$m$ 同余的，属于不同剩余类的任意两个整数不可能是模$m$ 同余的。  
根据定理，可以在$.Z_{m}=\{[0],[1],\cdots[m-1]\}$上定义关于同余类的加法和乘法运算：  
【定义2.11】假设$m$ 是任一给定的正整数对于任意给定的两个整数$a$和$b$，定义：
$$
[a]_{m}+[b]_{m}=[a+b]_{m}
$$  
$$
[a]_{m}\cdot[b]_{m}=[a\cdot b]_{m}
$$  
【定义2.12】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m)$是所有模$m$ 同余类，如果从每个同余类$R_{i}(m)$中分别取一个整数$x_{i}$构成一个$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$，则称该有限集合为模$m$ 的一个完全剩余系，简称为完全系；称$m$ 元有限集合$\{0,\ 1,\ 2,\ \cdots\ ,$为最小非负完全剩余系。  
对于正整数$m$，假设$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$是模$m$ 的一个完全剩余系，对于其中的任意一个整数$\cdot x_{i}$，如果${\bf\nabla}_{}^{}$与$m$ 互素，则$x_{i}$所在同余类${\mathbf{}}R_{i}(m)$中每个整数$k$ 都与$m$ 互素。这是因为根据$k\equiv x_{i}({\bmod{\pmod{m}}})$，即有$\cdot_{x_{i}}=k+q m$。由此可知，如果$k$ 与$m$有大于1 的公因子，那么$x_{i}$必然与$m$ 有大于1 的公因子。类似地，如果$x_{i}$与$m$ 互素，则$x_{i}$所在同余类$R_{i}(m)$中每个整数$k$ 都与$m$ 不互素。由此得到如下简化同余类和简化剩余系的概念：  
【定义2.13】对于正整数$m$，假设$R_{i}(m)$是任意一个模$m$ 同余类，若$R_{i}(m)$中存在一个整数与 $m$  互素，则称 $\ R_{i}(m)$ 是一个模 $\pmb{m}$  简化同余类或模 $\pmb{m}$  简化剩余类。如果分别从每个模 $m$ 简化同余类中取出一个整数作为代表$x_{i}$构成一个有限集合$\{x_{0},\ x_{1},\ \cdots,x_{\varphi(m-1)}\}$，则称该集合为模$m$ 的一个简化剩余系，简称为简化系。其中$\varphi(m)$称为欧拉函数，表示模$m$ 简化剩余类的数目，亦即不超过$m$ 且与$m$ 互素的正整数个数。  
因为所有模$m$ 同余类构成整数集合的一个划分，所以每个与$m$ 互质的整数仅存在于它  所在的简化同余类中。由此可以看出，简化同余类以及欧拉函数$\varphi(m)$在整数互质性质的研究中具有非常重要的作用，后面将使用这些概念证明欧拉定理和费马小定理。这两个定理不仅是整数理论中非常著名而重要的定理，而且还是现代非对称数论加密算法的基础。",同余类的概念定义了模m同余类的集合，而同余类的性质描述了这些同余类的特性，如每个整数恰好属于一个同余类。
同余类的概念,运算定义,同余类的加法和乘法运算,,"在很多场合，我们往往只关心用某一特定正整数除以整数得到的余数。例如，星期日期就是从某个星期日开始经历的天数除以7 得到的余数，通过对天数取以7 为除数的余数，就可以用短短的7 个数字借助以7 为周期的循环机制表示无穷无尽的天数。事实上，取余数是一种以有限驾驭无限的重要智慧，对于任一给定的正整数$m$，通过考察所有整数除以$m$ 所得余数的差异，把所有具有相同余数的整数归为一类，则可将所有整数分为$m$ 个基本类型。若分别从每个类中取一个整数作为代表构成一个$m$ 元有限集，则可将这个有限集看成是对整数集的一个抽象，由此完成了整数集从无限向有限的转化。在这个分类过程中，整数之间是否具有相同余数的关系起着非常关键的作用，由此得到如下同余的概念：  
【定义2.9】假设$m$ 是任一给定的正整数，对于任意两个整数$a$和$b$，它们除以$m$ 后得到的余数分别记为$a({\bmod{\ m}})$和$b({\bmod{\ m}})$，如果这两个余数相等，即有：  
$$
a({\bmod{\ m}})=b({\bmod{\ m}})\tag{2-9}
$$  
则称$a$与$b$具有模$\pmb{m}$同余关系，简称为$a$与$b$模$\pmb{m}$同余或同余，记为$a\equiv b({\bmod{m}})$或$b\equiv$$a({\bmod{\ m}})$；否则称$a$与$b$对于模$\mathbfit{m}$不同余，记为$a\not\equiv b({\bmod{{m}}})$或$b\not\equiv a({\bmod{\ m}})$。  
根据上述定义，不难证明下面关于模$_m$同余的判定定理：  
【定理2.19】假设$m$是任一给定的正整数，任意两个整数$a$和$b$具有模$_m$同余关系，当且仅当$m$能够整除$a-b$。  
【定理2.20】假设$m$ 是任一给定的正整数，任意两个整数$a$ 和$b$ 具有模$m$同余关系，  
当且仅当存在整数$k$，使得整除$a=b+k m$  
下面定理表明了同余关系的保加性和保乘性：  
【定理2.21】设$m$ 是任一正整数，若整数$a$ 与$b$ 模$m$ 同余，整数$c$与$d$ 同余模$m$，则它们的和与积也分别模$m$ 同余。即：若$a\equiv b({\bmod{\ }}m)$，$c\equiv d({\bmod{\pmod{m}}})$，则有：  
$$
a+c\equiv(b+d)(\bmod{\ m}),\ \ a c\equiv b d(\bmod{\ m})
$$  
【定理2.22】假设$m$ 是任一给定的正整数，则对任意两个整数$a$ 和$b$，成立下面两个关于余数的计算公式：  
$$
(a+b){\bmod{\ m}}=((a{\bmod{\ m}})+(b{\bmod{\ m}})){\bmod{\ m}}\tag{2-10}
$$  
$$
ab\ {\bmod{\ m}}=((a{\bmod{\ m}})(b{\bmod{\ m}}))\ {\bmod{\ m}}\tag{2-11}
$$  
例如，对于$7\equiv2{\bmod{\mathrm{~5~}}}$和$11\equiv1{\bmod{\mathrm{~5~}}}$，由定理2.21 知：  
$$
18=7+11\equiv2+1=3({\bmod{\mathrm{~}}}5)
$$  
$$
77=7\cdot11\equiv2\cdot1=2{\pmod{5}}
$$  
再如，对于任意三个数，比如说1, 2 和5，由定理2.22 知存在如下等式：  
$$
(1+2)({\bmod{\ }}5)=((1\ \,({\bmod{\ }}5)+(2\ \,({\bmod{\ }}5))({\bmod{\ }}5)
$$  
$$
2\,\bmod\,5=\left((1\,\bmod\,5)(2\,\bmod\,5)\right)\,(\bmod\,5)
$$  
值得注意的是，同余关系在一般情况下不满足消去律，例如 $8\equiv12({\bmod{\mathrm{~}}}4)$，两边同除以4 后，$2\equiv3({\bmod{\mathrm{~}}}4)$显然是不成立的，但是存在下列性质：  
【定理2.23】若$a c\equiv b c({\bmod{\pmod{m}}})$，且$c$ 与$m$ 互素，则有：$a\equiv b({\bmod{\ }}m)$  
如前所述，使用同余可以实现对整数集合的划分或分类，现在就来讨论这个问题。由同余的定义可知，对于任意给定的正整数$m$，可依照除以$m$ 后的余数值以及模$m$ 同余关系，将所有整数划分为$m$ 个互不相交的子集合。据此，我们引入如下同余类的概念：  
【定义2.10】设$m$ 是任一给定正整数，对于每个整数$i$，$0\leq i<m$，定义如下集合：  
$$
R_{i}(m)=\{n|n\equiv i({\bmod{\pmod{\ m}}},n\in Z\}\tag{2-12}
$$  
则称每个$^{}R_{i}(m)$分别是模$m$ 的一个同余类或剩余类，在不引起混淆的情况下，通常也将$R_{i}(m)$简记为$[i]$，并记为：$Z_{m}=\{[0],[1],\cdots[m-1]\}.$。  
【定理2.24】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m),$所有模$m$ 同余类，则有下述结论成立：  
（1）每个整数$a$ 都恰好属于某个同余类，通常将这个同余类记为$[a]_{m}$或$[a]$  
（2）对于任意的两个整数$a$ 和$b$，它们属于同一个同余类的充分必要条件是：
$$
a\equiv b({\bmod{m}})
$$  
上述定理表明，每个整数必定属于且仅属于其中一个剩余类，属于同一个剩余类的任意两个整数都是模$m$ 同余的，属于不同剩余类的任意两个整数不可能是模$m$ 同余的。  
根据定理，可以在$.Z_{m}=\{[0],[1],\cdots[m-1]\}$上定义关于同余类的加法和乘法运算：  
【定义2.11】假设$m$ 是任一给定的正整数对于任意给定的两个整数$a$和$b$，定义：
$$
[a]_{m}+[b]_{m}=[a+b]_{m}
$$  
$$
[a]_{m}\cdot[b]_{m}=[a\cdot b]_{m}
$$  
【定义2.12】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m)$是所有模$m$ 同余类，如果从每个同余类$R_{i}(m)$中分别取一个整数$x_{i}$构成一个$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$，则称该有限集合为模$m$ 的一个完全剩余系，简称为完全系；称$m$ 元有限集合$\{0,\ 1,\ 2,\ \cdots\ ,$为最小非负完全剩余系。  
对于正整数$m$，假设$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$是模$m$ 的一个完全剩余系，对于其中的任意一个整数$\cdot x_{i}$，如果${\bf\nabla}_{}^{}$与$m$ 互素，则$x_{i}$所在同余类${\mathbf{}}R_{i}(m)$中每个整数$k$ 都与$m$ 互素。这是因为根据$k\equiv x_{i}({\bmod{\pmod{m}}})$，即有$\cdot_{x_{i}}=k+q m$。由此可知，如果$k$ 与$m$有大于1 的公因子，那么$x_{i}$必然与$m$ 有大于1 的公因子。类似地，如果$x_{i}$与$m$ 互素，则$x_{i}$所在同余类$R_{i}(m)$中每个整数$k$ 都与$m$ 不互素。由此得到如下简化同余类和简化剩余系的概念：  
【定义2.13】对于正整数$m$，假设$R_{i}(m)$是任意一个模$m$ 同余类，若$R_{i}(m)$中存在一个整数与 $m$  互素，则称 $\ R_{i}(m)$ 是一个模 $\pmb{m}$  简化同余类或模 $\pmb{m}$  简化剩余类。如果分别从每个模 $m$ 简化同余类中取出一个整数作为代表$x_{i}$构成一个有限集合$\{x_{0},\ x_{1},\ \cdots,x_{\varphi(m-1)}\}$，则称该集合为模$m$ 的一个简化剩余系，简称为简化系。其中$\varphi(m)$称为欧拉函数，表示模$m$ 简化剩余类的数目，亦即不超过$m$ 且与$m$ 互素的正整数个数。  
因为所有模$m$ 同余类构成整数集合的一个划分，所以每个与$m$ 互质的整数仅存在于它  所在的简化同余类中。由此可以看出，简化同余类以及欧拉函数$\varphi(m)$在整数互质性质的研究中具有非常重要的作用，后面将使用这些概念证明欧拉定理和费马小定理。这两个定理不仅是整数理论中非常著名而重要的定理，而且还是现代非对称数论加密算法的基础。",同余类的加法和乘法运算定义了同余类之间的加法和乘法操作，基于同余类的概念进行定义。
完全剩余系,构成,同余类的概念,,"在很多场合，我们往往只关心用某一特定正整数除以整数得到的余数。例如，星期日期就是从某个星期日开始经历的天数除以7 得到的余数，通过对天数取以7 为除数的余数，就可以用短短的7 个数字借助以7 为周期的循环机制表示无穷无尽的天数。事实上，取余数是一种以有限驾驭无限的重要智慧，对于任一给定的正整数$m$，通过考察所有整数除以$m$ 所得余数的差异，把所有具有相同余数的整数归为一类，则可将所有整数分为$m$ 个基本类型。若分别从每个类中取一个整数作为代表构成一个$m$ 元有限集，则可将这个有限集看成是对整数集的一个抽象，由此完成了整数集从无限向有限的转化。在这个分类过程中，整数之间是否具有相同余数的关系起着非常关键的作用，由此得到如下同余的概念：  
【定义2.9】假设$m$ 是任一给定的正整数，对于任意两个整数$a$和$b$，它们除以$m$ 后得到的余数分别记为$a({\bmod{\ m}})$和$b({\bmod{\ m}})$，如果这两个余数相等，即有：  
$$
a({\bmod{\ m}})=b({\bmod{\ m}})\tag{2-9}
$$  
则称$a$与$b$具有模$\pmb{m}$同余关系，简称为$a$与$b$模$\pmb{m}$同余或同余，记为$a\equiv b({\bmod{m}})$或$b\equiv$$a({\bmod{\ m}})$；否则称$a$与$b$对于模$\mathbfit{m}$不同余，记为$a\not\equiv b({\bmod{{m}}})$或$b\not\equiv a({\bmod{\ m}})$。  
根据上述定义，不难证明下面关于模$_m$同余的判定定理：  
【定理2.19】假设$m$是任一给定的正整数，任意两个整数$a$和$b$具有模$_m$同余关系，当且仅当$m$能够整除$a-b$。  
【定理2.20】假设$m$ 是任一给定的正整数，任意两个整数$a$ 和$b$ 具有模$m$同余关系，  
当且仅当存在整数$k$，使得整除$a=b+k m$  
下面定理表明了同余关系的保加性和保乘性：  
【定理2.21】设$m$ 是任一正整数，若整数$a$ 与$b$ 模$m$ 同余，整数$c$与$d$ 同余模$m$，则它们的和与积也分别模$m$ 同余。即：若$a\equiv b({\bmod{\ }}m)$，$c\equiv d({\bmod{\pmod{m}}})$，则有：  
$$
a+c\equiv(b+d)(\bmod{\ m}),\ \ a c\equiv b d(\bmod{\ m})
$$  
【定理2.22】假设$m$ 是任一给定的正整数，则对任意两个整数$a$ 和$b$，成立下面两个关于余数的计算公式：  
$$
(a+b){\bmod{\ m}}=((a{\bmod{\ m}})+(b{\bmod{\ m}})){\bmod{\ m}}\tag{2-10}
$$  
$$
ab\ {\bmod{\ m}}=((a{\bmod{\ m}})(b{\bmod{\ m}}))\ {\bmod{\ m}}\tag{2-11}
$$  
例如，对于$7\equiv2{\bmod{\mathrm{~5~}}}$和$11\equiv1{\bmod{\mathrm{~5~}}}$，由定理2.21 知：  
$$
18=7+11\equiv2+1=3({\bmod{\mathrm{~}}}5)
$$  
$$
77=7\cdot11\equiv2\cdot1=2{\pmod{5}}
$$  
再如，对于任意三个数，比如说1, 2 和5，由定理2.22 知存在如下等式：  
$$
(1+2)({\bmod{\ }}5)=((1\ \,({\bmod{\ }}5)+(2\ \,({\bmod{\ }}5))({\bmod{\ }}5)
$$  
$$
2\,\bmod\,5=\left((1\,\bmod\,5)(2\,\bmod\,5)\right)\,(\bmod\,5)
$$  
值得注意的是，同余关系在一般情况下不满足消去律，例如 $8\equiv12({\bmod{\mathrm{~}}}4)$，两边同除以4 后，$2\equiv3({\bmod{\mathrm{~}}}4)$显然是不成立的，但是存在下列性质：  
【定理2.23】若$a c\equiv b c({\bmod{\pmod{m}}})$，且$c$ 与$m$ 互素，则有：$a\equiv b({\bmod{\ }}m)$  
如前所述，使用同余可以实现对整数集合的划分或分类，现在就来讨论这个问题。由同余的定义可知，对于任意给定的正整数$m$，可依照除以$m$ 后的余数值以及模$m$ 同余关系，将所有整数划分为$m$ 个互不相交的子集合。据此，我们引入如下同余类的概念：  
【定义2.10】设$m$ 是任一给定正整数，对于每个整数$i$，$0\leq i<m$，定义如下集合：  
$$
R_{i}(m)=\{n|n\equiv i({\bmod{\pmod{\ m}}},n\in Z\}\tag{2-12}
$$  
则称每个$^{}R_{i}(m)$分别是模$m$ 的一个同余类或剩余类，在不引起混淆的情况下，通常也将$R_{i}(m)$简记为$[i]$，并记为：$Z_{m}=\{[0],[1],\cdots[m-1]\}.$。  
【定理2.24】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m),$所有模$m$ 同余类，则有下述结论成立：  
（1）每个整数$a$ 都恰好属于某个同余类，通常将这个同余类记为$[a]_{m}$或$[a]$  
（2）对于任意的两个整数$a$ 和$b$，它们属于同一个同余类的充分必要条件是：
$$
a\equiv b({\bmod{m}})
$$  
上述定理表明，每个整数必定属于且仅属于其中一个剩余类，属于同一个剩余类的任意两个整数都是模$m$ 同余的，属于不同剩余类的任意两个整数不可能是模$m$ 同余的。  
根据定理，可以在$.Z_{m}=\{[0],[1],\cdots[m-1]\}$上定义关于同余类的加法和乘法运算：  
【定义2.11】假设$m$ 是任一给定的正整数对于任意给定的两个整数$a$和$b$，定义：
$$
[a]_{m}+[b]_{m}=[a+b]_{m}
$$  
$$
[a]_{m}\cdot[b]_{m}=[a\cdot b]_{m}
$$  
【定义2.12】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m)$是所有模$m$ 同余类，如果从每个同余类$R_{i}(m)$中分别取一个整数$x_{i}$构成一个$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$，则称该有限集合为模$m$ 的一个完全剩余系，简称为完全系；称$m$ 元有限集合$\{0,\ 1,\ 2,\ \cdots\ ,$为最小非负完全剩余系。  
对于正整数$m$，假设$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$是模$m$ 的一个完全剩余系，对于其中的任意一个整数$\cdot x_{i}$，如果${\bf\nabla}_{}^{}$与$m$ 互素，则$x_{i}$所在同余类${\mathbf{}}R_{i}(m)$中每个整数$k$ 都与$m$ 互素。这是因为根据$k\equiv x_{i}({\bmod{\pmod{m}}})$，即有$\cdot_{x_{i}}=k+q m$。由此可知，如果$k$ 与$m$有大于1 的公因子，那么$x_{i}$必然与$m$ 有大于1 的公因子。类似地，如果$x_{i}$与$m$ 互素，则$x_{i}$所在同余类$R_{i}(m)$中每个整数$k$ 都与$m$ 不互素。由此得到如下简化同余类和简化剩余系的概念：  
【定义2.13】对于正整数$m$，假设$R_{i}(m)$是任意一个模$m$ 同余类，若$R_{i}(m)$中存在一个整数与 $m$  互素，则称 $\ R_{i}(m)$ 是一个模 $\pmb{m}$  简化同余类或模 $\pmb{m}$  简化剩余类。如果分别从每个模 $m$ 简化同余类中取出一个整数作为代表$x_{i}$构成一个有限集合$\{x_{0},\ x_{1},\ \cdots,x_{\varphi(m-1)}\}$，则称该集合为模$m$ 的一个简化剩余系，简称为简化系。其中$\varphi(m)$称为欧拉函数，表示模$m$ 简化剩余类的数目，亦即不超过$m$ 且与$m$ 互素的正整数个数。  
因为所有模$m$ 同余类构成整数集合的一个划分，所以每个与$m$ 互质的整数仅存在于它  所在的简化同余类中。由此可以看出，简化同余类以及欧拉函数$\varphi(m)$在整数互质性质的研究中具有非常重要的作用，后面将使用这些概念证明欧拉定理和费马小定理。这两个定理不仅是整数理论中非常著名而重要的定理，而且还是现代非对称数论加密算法的基础。",完全剩余系是由每个同余类中取一个整数构成的有限集合，基于同余类的概念进行定义。
简化同余类和简化剩余系,特化,同余类的概念,,"在很多场合，我们往往只关心用某一特定正整数除以整数得到的余数。例如，星期日期就是从某个星期日开始经历的天数除以7 得到的余数，通过对天数取以7 为除数的余数，就可以用短短的7 个数字借助以7 为周期的循环机制表示无穷无尽的天数。事实上，取余数是一种以有限驾驭无限的重要智慧，对于任一给定的正整数$m$，通过考察所有整数除以$m$ 所得余数的差异，把所有具有相同余数的整数归为一类，则可将所有整数分为$m$ 个基本类型。若分别从每个类中取一个整数作为代表构成一个$m$ 元有限集，则可将这个有限集看成是对整数集的一个抽象，由此完成了整数集从无限向有限的转化。在这个分类过程中，整数之间是否具有相同余数的关系起着非常关键的作用，由此得到如下同余的概念：  
【定义2.9】假设$m$ 是任一给定的正整数，对于任意两个整数$a$和$b$，它们除以$m$ 后得到的余数分别记为$a({\bmod{\ m}})$和$b({\bmod{\ m}})$，如果这两个余数相等，即有：  
$$
a({\bmod{\ m}})=b({\bmod{\ m}})\tag{2-9}
$$  
则称$a$与$b$具有模$\pmb{m}$同余关系，简称为$a$与$b$模$\pmb{m}$同余或同余，记为$a\equiv b({\bmod{m}})$或$b\equiv$$a({\bmod{\ m}})$；否则称$a$与$b$对于模$\mathbfit{m}$不同余，记为$a\not\equiv b({\bmod{{m}}})$或$b\not\equiv a({\bmod{\ m}})$。  
根据上述定义，不难证明下面关于模$_m$同余的判定定理：  
【定理2.19】假设$m$是任一给定的正整数，任意两个整数$a$和$b$具有模$_m$同余关系，当且仅当$m$能够整除$a-b$。  
【定理2.20】假设$m$ 是任一给定的正整数，任意两个整数$a$ 和$b$ 具有模$m$同余关系，  
当且仅当存在整数$k$，使得整除$a=b+k m$  
下面定理表明了同余关系的保加性和保乘性：  
【定理2.21】设$m$ 是任一正整数，若整数$a$ 与$b$ 模$m$ 同余，整数$c$与$d$ 同余模$m$，则它们的和与积也分别模$m$ 同余。即：若$a\equiv b({\bmod{\ }}m)$，$c\equiv d({\bmod{\pmod{m}}})$，则有：  
$$
a+c\equiv(b+d)(\bmod{\ m}),\ \ a c\equiv b d(\bmod{\ m})
$$  
【定理2.22】假设$m$ 是任一给定的正整数，则对任意两个整数$a$ 和$b$，成立下面两个关于余数的计算公式：  
$$
(a+b){\bmod{\ m}}=((a{\bmod{\ m}})+(b{\bmod{\ m}})){\bmod{\ m}}\tag{2-10}
$$  
$$
ab\ {\bmod{\ m}}=((a{\bmod{\ m}})(b{\bmod{\ m}}))\ {\bmod{\ m}}\tag{2-11}
$$  
例如，对于$7\equiv2{\bmod{\mathrm{~5~}}}$和$11\equiv1{\bmod{\mathrm{~5~}}}$，由定理2.21 知：  
$$
18=7+11\equiv2+1=3({\bmod{\mathrm{~}}}5)
$$  
$$
77=7\cdot11\equiv2\cdot1=2{\pmod{5}}
$$  
再如，对于任意三个数，比如说1, 2 和5，由定理2.22 知存在如下等式：  
$$
(1+2)({\bmod{\ }}5)=((1\ \,({\bmod{\ }}5)+(2\ \,({\bmod{\ }}5))({\bmod{\ }}5)
$$  
$$
2\,\bmod\,5=\left((1\,\bmod\,5)(2\,\bmod\,5)\right)\,(\bmod\,5)
$$  
值得注意的是，同余关系在一般情况下不满足消去律，例如 $8\equiv12({\bmod{\mathrm{~}}}4)$，两边同除以4 后，$2\equiv3({\bmod{\mathrm{~}}}4)$显然是不成立的，但是存在下列性质：  
【定理2.23】若$a c\equiv b c({\bmod{\pmod{m}}})$，且$c$ 与$m$ 互素，则有：$a\equiv b({\bmod{\ }}m)$  
如前所述，使用同余可以实现对整数集合的划分或分类，现在就来讨论这个问题。由同余的定义可知，对于任意给定的正整数$m$，可依照除以$m$ 后的余数值以及模$m$ 同余关系，将所有整数划分为$m$ 个互不相交的子集合。据此，我们引入如下同余类的概念：  
【定义2.10】设$m$ 是任一给定正整数，对于每个整数$i$，$0\leq i<m$，定义如下集合：  
$$
R_{i}(m)=\{n|n\equiv i({\bmod{\pmod{\ m}}},n\in Z\}\tag{2-12}
$$  
则称每个$^{}R_{i}(m)$分别是模$m$ 的一个同余类或剩余类，在不引起混淆的情况下，通常也将$R_{i}(m)$简记为$[i]$，并记为：$Z_{m}=\{[0],[1],\cdots[m-1]\}.$。  
【定理2.24】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m),$所有模$m$ 同余类，则有下述结论成立：  
（1）每个整数$a$ 都恰好属于某个同余类，通常将这个同余类记为$[a]_{m}$或$[a]$  
（2）对于任意的两个整数$a$ 和$b$，它们属于同一个同余类的充分必要条件是：
$$
a\equiv b({\bmod{m}})
$$  
上述定理表明，每个整数必定属于且仅属于其中一个剩余类，属于同一个剩余类的任意两个整数都是模$m$ 同余的，属于不同剩余类的任意两个整数不可能是模$m$ 同余的。  
根据定理，可以在$.Z_{m}=\{[0],[1],\cdots[m-1]\}$上定义关于同余类的加法和乘法运算：  
【定义2.11】假设$m$ 是任一给定的正整数对于任意给定的两个整数$a$和$b$，定义：
$$
[a]_{m}+[b]_{m}=[a+b]_{m}
$$  
$$
[a]_{m}\cdot[b]_{m}=[a\cdot b]_{m}
$$  
【定义2.12】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m)$是所有模$m$ 同余类，如果从每个同余类$R_{i}(m)$中分别取一个整数$x_{i}$构成一个$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$，则称该有限集合为模$m$ 的一个完全剩余系，简称为完全系；称$m$ 元有限集合$\{0,\ 1,\ 2,\ \cdots\ ,$为最小非负完全剩余系。  
对于正整数$m$，假设$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$是模$m$ 的一个完全剩余系，对于其中的任意一个整数$\cdot x_{i}$，如果${\bf\nabla}_{}^{}$与$m$ 互素，则$x_{i}$所在同余类${\mathbf{}}R_{i}(m)$中每个整数$k$ 都与$m$ 互素。这是因为根据$k\equiv x_{i}({\bmod{\pmod{m}}})$，即有$\cdot_{x_{i}}=k+q m$。由此可知，如果$k$ 与$m$有大于1 的公因子，那么$x_{i}$必然与$m$ 有大于1 的公因子。类似地，如果$x_{i}$与$m$ 互素，则$x_{i}$所在同余类$R_{i}(m)$中每个整数$k$ 都与$m$ 不互素。由此得到如下简化同余类和简化剩余系的概念：  
【定义2.13】对于正整数$m$，假设$R_{i}(m)$是任意一个模$m$ 同余类，若$R_{i}(m)$中存在一个整数与 $m$  互素，则称 $\ R_{i}(m)$ 是一个模 $\pmb{m}$  简化同余类或模 $\pmb{m}$  简化剩余类。如果分别从每个模 $m$ 简化同余类中取出一个整数作为代表$x_{i}$构成一个有限集合$\{x_{0},\ x_{1},\ \cdots,x_{\varphi(m-1)}\}$，则称该集合为模$m$ 的一个简化剩余系，简称为简化系。其中$\varphi(m)$称为欧拉函数，表示模$m$ 简化剩余类的数目，亦即不超过$m$ 且与$m$ 互素的正整数个数。  
因为所有模$m$ 同余类构成整数集合的一个划分，所以每个与$m$ 互质的整数仅存在于它  所在的简化同余类中。由此可以看出，简化同余类以及欧拉函数$\varphi(m)$在整数互质性质的研究中具有非常重要的作用，后面将使用这些概念证明欧拉定理和费马小定理。这两个定理不仅是整数理论中非常著名而重要的定理，而且还是现代非对称数论加密算法的基础。",简化同余类和简化剩余系是同余类中与m互素的特殊类和集合，基于同余类的概念进行特化定义。
同余算术,包含,同余关系,,"相等的两个整数除以某一正整数$m$ 后得到的余数自然是相等的。因此，两个整数之间的同余关系不仅可以看成是对整除关系的一种推广，而且还可以看成是对两个整数相等关系的一种推广。下面定理表明整数相等关系与同余关系自己具有共同本质属性。  
【定理2.25】假设$m$ 是任一给定的正整数，则模$m$ 同余关系满足下列性质：  
(1) 自反性：$a\equiv a({\bmod{\ m}})$，对一切整数$a$ 成立；  
(2) 对称性：若$a\equiv b({\bmod{\ }}m)$，则$b\equiv a({\bmod{\ m}}).$；  
(3) 传递性：若$a\equiv b({\bmod{\ }}m)$，$b\equiv c({{\pmod{m}}})$，则$a\equiv c({{\pmod{m}}}).$。  
我们知道，根据整数之间相等关系的制约可以列出相应的整数方程和方程组。那么，根据整数同余关系的制约是否也可以列出相应的方程和方程组呢？如果可以，那么这些方程和方程组如何求解？本节我们就来讨论这些问题。  
【定义2.14】假设$m$ 是任一给定的正整数，$a$ 和$b$ 是任意给定的两个整数，下式：  
$$
a x\equiv b({\bmod{m}})\tag{2-13}
$$  
称为关于未知数$x$ 的一次线性同余方程，简称为同余方程，其中$x$ 为未知整数。若存在一个整数$\cdot x_{0}$，当$x=x_{0}$时，成立$.a x\equiv b({\bmod{\pmod{m}}})$，则称$\cdot x_{0}$是该同余方程的一个解。  
显然，如果$x_{0}$是某个同余方程的一个解，则与$x_{0}$同余的所有整数都是该同余方程的解，这是一种平凡情形，通常将与$x_{0}$同余的所有整数与$x_{0}$一起看成是同一个解。因此，同余方程解的计数标准为：凡是相互之间模$m$ 同余的解都视为同一个解，同余方程解的个数是指它的关于模$m$ 互不同余所有解的个数，亦即在模$m$ 的一个完全剩余系中解的个数。  
下面考察一次线性同余方程解的存在性：  
【定理2.26】假设$m$ 是任一给定的正整数，$a,b$ 是任意给定的两个整数，如果$a$ 与$m$之间没有整除关系，即有$a\not\equiv0({\bmod{m}})$ ，则下列同余方程  
$$
a x\equiv b({\bmod{m}})
$$  
有解的充要条件是$a$ 与$m$ 的最大公因数能够整除$b$。若有解，则解的个数为$\operatorname*{gcd}(a,m)$。  
对于同余方程$a\cdot x \equiv 1(\mod m)$，其有解的充要条件是$a$ 与$m$ 的最大公因数能够整除1，即互素$a$ 与$m$。且有解的情况下只有唯一解。由此给出如下关于$\bar{a}$的定义：  
【定义2.15】设$m$ 是任一给定的正整数，$a$ 是任一与$m$ 互素的整数，满足$a\cdot x\equiv$1 (mod $m^{\prime}$)的最小正整数解称为整数$a$的模$\pmb{m}$ 逆，记为$\cdot\bar{a}$。  
下面定理的证明过程给出了整数$a$ 模$m$ 逆$\bar{a}$的一个具体求法：  
【定理2.27】设$m$ 和$a$ 是两个互素的整数，且$m>1$，则存在唯一一个小于$m$ 的正整数$\bar{a}$，它是$a$ 的模$m$ 逆，即有：${\bar{a}}\cdot a\equiv1({\bmod{{m}}})$。  
【定义2.16】假设$m_{1},m_{2},\cdots,m_{k}$为$k$个正整数，$a_{1},a_{2},\cdots,a_{k}$为$k$ 个整数，由下列$k$ 个以$x$ 为未知整数的同余方程联立而成的方程组，称为同余方程组：  
$$
\left\{\begin{array}{l l}{x\equiv a_{1}(\bmod~m_{1})}\\ {x\equiv a_{2}(\bmod m_{2})}\\ {\qquad\dots}\\ {x\equiv a_{k}(\bmod~m_{k})}\end{array}\right.\tag{2-14}
$$  
若存在一个整数$\cdot x_{0}$满足上述所有同余方程，则称$\cdot x_{0}$是该同余方程组的一个解。  
当以上定义的同余方程组中所有模两两互素时，方程组一定有唯一的一组解。下面的中国余数定理是整数理论中一个非常著名的定理，又称为孙子定理。该定理不仅确认了上述结论，而且其证明过程其实给出了一个具体的求解方法。  
【定理2.28】（中国余数定理）设$m_{1}$$\cdot\ \ m_{2},\ \ \cdots m_{k}$是两两互素的正整数，那么同余式组（2-14）有唯一的以$M=m_{1}m_{2}\cdots m_{k}$为模的解。",同余算术包含同余关系，同余关系是同余算术的基本概念之一
同余关系,基础,同余方程,,"相等的两个整数除以某一正整数$m$ 后得到的余数自然是相等的。因此，两个整数之间的同余关系不仅可以看成是对整除关系的一种推广，而且还可以看成是对两个整数相等关系的一种推广。下面定理表明整数相等关系与同余关系自己具有共同本质属性。  
【定理2.25】假设$m$ 是任一给定的正整数，则模$m$ 同余关系满足下列性质：  
(1) 自反性：$a\equiv a({\bmod{\ m}})$，对一切整数$a$ 成立；  
(2) 对称性：若$a\equiv b({\bmod{\ }}m)$，则$b\equiv a({\bmod{\ m}}).$；  
(3) 传递性：若$a\equiv b({\bmod{\ }}m)$，$b\equiv c({{\pmod{m}}})$，则$a\equiv c({{\pmod{m}}}).$。  
我们知道，根据整数之间相等关系的制约可以列出相应的整数方程和方程组。那么，根据整数同余关系的制约是否也可以列出相应的方程和方程组呢？如果可以，那么这些方程和方程组如何求解？本节我们就来讨论这些问题。  
【定义2.14】假设$m$ 是任一给定的正整数，$a$ 和$b$ 是任意给定的两个整数，下式：  
$$
a x\equiv b({\bmod{m}})\tag{2-13}
$$  
称为关于未知数$x$ 的一次线性同余方程，简称为同余方程，其中$x$ 为未知整数。若存在一个整数$\cdot x_{0}$，当$x=x_{0}$时，成立$.a x\equiv b({\bmod{\pmod{m}}})$，则称$\cdot x_{0}$是该同余方程的一个解。  
显然，如果$x_{0}$是某个同余方程的一个解，则与$x_{0}$同余的所有整数都是该同余方程的解，这是一种平凡情形，通常将与$x_{0}$同余的所有整数与$x_{0}$一起看成是同一个解。因此，同余方程解的计数标准为：凡是相互之间模$m$ 同余的解都视为同一个解，同余方程解的个数是指它的关于模$m$ 互不同余所有解的个数，亦即在模$m$ 的一个完全剩余系中解的个数。  
下面考察一次线性同余方程解的存在性：  
【定理2.26】假设$m$ 是任一给定的正整数，$a,b$ 是任意给定的两个整数，如果$a$ 与$m$之间没有整除关系，即有$a\not\equiv0({\bmod{m}})$ ，则下列同余方程  
$$
a x\equiv b({\bmod{m}})
$$  
有解的充要条件是$a$ 与$m$ 的最大公因数能够整除$b$。若有解，则解的个数为$\operatorname*{gcd}(a,m)$。  
对于同余方程$a\cdot x \equiv 1(\mod m)$，其有解的充要条件是$a$ 与$m$ 的最大公因数能够整除1，即互素$a$ 与$m$。且有解的情况下只有唯一解。由此给出如下关于$\bar{a}$的定义：  
【定义2.15】设$m$ 是任一给定的正整数，$a$ 是任一与$m$ 互素的整数，满足$a\cdot x\equiv$1 (mod $m^{\prime}$)的最小正整数解称为整数$a$的模$\pmb{m}$ 逆，记为$\cdot\bar{a}$。  
下面定理的证明过程给出了整数$a$ 模$m$ 逆$\bar{a}$的一个具体求法：  
【定理2.27】设$m$ 和$a$ 是两个互素的整数，且$m>1$，则存在唯一一个小于$m$ 的正整数$\bar{a}$，它是$a$ 的模$m$ 逆，即有：${\bar{a}}\cdot a\equiv1({\bmod{{m}}})$。  
【定义2.16】假设$m_{1},m_{2},\cdots,m_{k}$为$k$个正整数，$a_{1},a_{2},\cdots,a_{k}$为$k$ 个整数，由下列$k$ 个以$x$ 为未知整数的同余方程联立而成的方程组，称为同余方程组：  
$$
\left\{\begin{array}{l l}{x\equiv a_{1}(\bmod~m_{1})}\\ {x\equiv a_{2}(\bmod m_{2})}\\ {\qquad\dots}\\ {x\equiv a_{k}(\bmod~m_{k})}\end{array}\right.\tag{2-14}
$$  
若存在一个整数$\cdot x_{0}$满足上述所有同余方程，则称$\cdot x_{0}$是该同余方程组的一个解。  
当以上定义的同余方程组中所有模两两互素时，方程组一定有唯一的一组解。下面的中国余数定理是整数理论中一个非常著名的定理，又称为孙子定理。该定理不仅确认了上述结论，而且其证明过程其实给出了一个具体的求解方法。  
【定理2.28】（中国余数定理）设$m_{1}$$\cdot\ \ m_{2},\ \ \cdots m_{k}$是两两互素的正整数，那么同余式组（2-14）有唯一的以$M=m_{1}m_{2}\cdots m_{k}$为模的解。",同余关系是定义同余方程的基础，同余方程是基于同余关系建立的
同余方程,讨论对象,同余方程解的存在性,,"相等的两个整数除以某一正整数$m$ 后得到的余数自然是相等的。因此，两个整数之间的同余关系不仅可以看成是对整除关系的一种推广，而且还可以看成是对两个整数相等关系的一种推广。下面定理表明整数相等关系与同余关系自己具有共同本质属性。  
【定理2.25】假设$m$ 是任一给定的正整数，则模$m$ 同余关系满足下列性质：  
(1) 自反性：$a\equiv a({\bmod{\ m}})$，对一切整数$a$ 成立；  
(2) 对称性：若$a\equiv b({\bmod{\ }}m)$，则$b\equiv a({\bmod{\ m}}).$；  
(3) 传递性：若$a\equiv b({\bmod{\ }}m)$，$b\equiv c({{\pmod{m}}})$，则$a\equiv c({{\pmod{m}}}).$。  
我们知道，根据整数之间相等关系的制约可以列出相应的整数方程和方程组。那么，根据整数同余关系的制约是否也可以列出相应的方程和方程组呢？如果可以，那么这些方程和方程组如何求解？本节我们就来讨论这些问题。  
【定义2.14】假设$m$ 是任一给定的正整数，$a$ 和$b$ 是任意给定的两个整数，下式：  
$$
a x\equiv b({\bmod{m}})\tag{2-13}
$$  
称为关于未知数$x$ 的一次线性同余方程，简称为同余方程，其中$x$ 为未知整数。若存在一个整数$\cdot x_{0}$，当$x=x_{0}$时，成立$.a x\equiv b({\bmod{\pmod{m}}})$，则称$\cdot x_{0}$是该同余方程的一个解。  
显然，如果$x_{0}$是某个同余方程的一个解，则与$x_{0}$同余的所有整数都是该同余方程的解，这是一种平凡情形，通常将与$x_{0}$同余的所有整数与$x_{0}$一起看成是同一个解。因此，同余方程解的计数标准为：凡是相互之间模$m$ 同余的解都视为同一个解，同余方程解的个数是指它的关于模$m$ 互不同余所有解的个数，亦即在模$m$ 的一个完全剩余系中解的个数。  
下面考察一次线性同余方程解的存在性：  
【定理2.26】假设$m$ 是任一给定的正整数，$a,b$ 是任意给定的两个整数，如果$a$ 与$m$之间没有整除关系，即有$a\not\equiv0({\bmod{m}})$ ，则下列同余方程  
$$
a x\equiv b({\bmod{m}})
$$  
有解的充要条件是$a$ 与$m$ 的最大公因数能够整除$b$。若有解，则解的个数为$\operatorname*{gcd}(a,m)$。  
对于同余方程$a\cdot x \equiv 1(\mod m)$，其有解的充要条件是$a$ 与$m$ 的最大公因数能够整除1，即互素$a$ 与$m$。且有解的情况下只有唯一解。由此给出如下关于$\bar{a}$的定义：  
【定义2.15】设$m$ 是任一给定的正整数，$a$ 是任一与$m$ 互素的整数，满足$a\cdot x\equiv$1 (mod $m^{\prime}$)的最小正整数解称为整数$a$的模$\pmb{m}$ 逆，记为$\cdot\bar{a}$。  
下面定理的证明过程给出了整数$a$ 模$m$ 逆$\bar{a}$的一个具体求法：  
【定理2.27】设$m$ 和$a$ 是两个互素的整数，且$m>1$，则存在唯一一个小于$m$ 的正整数$\bar{a}$，它是$a$ 的模$m$ 逆，即有：${\bar{a}}\cdot a\equiv1({\bmod{{m}}})$。  
【定义2.16】假设$m_{1},m_{2},\cdots,m_{k}$为$k$个正整数，$a_{1},a_{2},\cdots,a_{k}$为$k$ 个整数，由下列$k$ 个以$x$ 为未知整数的同余方程联立而成的方程组，称为同余方程组：  
$$
\left\{\begin{array}{l l}{x\equiv a_{1}(\bmod~m_{1})}\\ {x\equiv a_{2}(\bmod m_{2})}\\ {\qquad\dots}\\ {x\equiv a_{k}(\bmod~m_{k})}\end{array}\right.\tag{2-14}
$$  
若存在一个整数$\cdot x_{0}$满足上述所有同余方程，则称$\cdot x_{0}$是该同余方程组的一个解。  
当以上定义的同余方程组中所有模两两互素时，方程组一定有唯一的一组解。下面的中国余数定理是整数理论中一个非常著名的定理，又称为孙子定理。该定理不仅确认了上述结论，而且其证明过程其实给出了一个具体的求解方法。  
【定理2.28】（中国余数定理）设$m_{1}$$\cdot\ \ m_{2},\ \ \cdots m_{k}$是两两互素的正整数，那么同余式组（2-14）有唯一的以$M=m_{1}m_{2}\cdots m_{k}$为模的解。",同余方程解的存在性是同余方程的重要讨论对象，研究同余方程是否有解
同余方程,相关概念,模逆,,"相等的两个整数除以某一正整数$m$ 后得到的余数自然是相等的。因此，两个整数之间的同余关系不仅可以看成是对整除关系的一种推广，而且还可以看成是对两个整数相等关系的一种推广。下面定理表明整数相等关系与同余关系自己具有共同本质属性。  
【定理2.25】假设$m$ 是任一给定的正整数，则模$m$ 同余关系满足下列性质：  
(1) 自反性：$a\equiv a({\bmod{\ m}})$，对一切整数$a$ 成立；  
(2) 对称性：若$a\equiv b({\bmod{\ }}m)$，则$b\equiv a({\bmod{\ m}}).$；  
(3) 传递性：若$a\equiv b({\bmod{\ }}m)$，$b\equiv c({{\pmod{m}}})$，则$a\equiv c({{\pmod{m}}}).$。  
我们知道，根据整数之间相等关系的制约可以列出相应的整数方程和方程组。那么，根据整数同余关系的制约是否也可以列出相应的方程和方程组呢？如果可以，那么这些方程和方程组如何求解？本节我们就来讨论这些问题。  
【定义2.14】假设$m$ 是任一给定的正整数，$a$ 和$b$ 是任意给定的两个整数，下式：  
$$
a x\equiv b({\bmod{m}})\tag{2-13}
$$  
称为关于未知数$x$ 的一次线性同余方程，简称为同余方程，其中$x$ 为未知整数。若存在一个整数$\cdot x_{0}$，当$x=x_{0}$时，成立$.a x\equiv b({\bmod{\pmod{m}}})$，则称$\cdot x_{0}$是该同余方程的一个解。  
显然，如果$x_{0}$是某个同余方程的一个解，则与$x_{0}$同余的所有整数都是该同余方程的解，这是一种平凡情形，通常将与$x_{0}$同余的所有整数与$x_{0}$一起看成是同一个解。因此，同余方程解的计数标准为：凡是相互之间模$m$ 同余的解都视为同一个解，同余方程解的个数是指它的关于模$m$ 互不同余所有解的个数，亦即在模$m$ 的一个完全剩余系中解的个数。  
下面考察一次线性同余方程解的存在性：  
【定理2.26】假设$m$ 是任一给定的正整数，$a,b$ 是任意给定的两个整数，如果$a$ 与$m$之间没有整除关系，即有$a\not\equiv0({\bmod{m}})$ ，则下列同余方程  
$$
a x\equiv b({\bmod{m}})
$$  
有解的充要条件是$a$ 与$m$ 的最大公因数能够整除$b$。若有解，则解的个数为$\operatorname*{gcd}(a,m)$。  
对于同余方程$a\cdot x \equiv 1(\mod m)$，其有解的充要条件是$a$ 与$m$ 的最大公因数能够整除1，即互素$a$ 与$m$。且有解的情况下只有唯一解。由此给出如下关于$\bar{a}$的定义：  
【定义2.15】设$m$ 是任一给定的正整数，$a$ 是任一与$m$ 互素的整数，满足$a\cdot x\equiv$1 (mod $m^{\prime}$)的最小正整数解称为整数$a$的模$\pmb{m}$ 逆，记为$\cdot\bar{a}$。  
下面定理的证明过程给出了整数$a$ 模$m$ 逆$\bar{a}$的一个具体求法：  
【定理2.27】设$m$ 和$a$ 是两个互素的整数，且$m>1$，则存在唯一一个小于$m$ 的正整数$\bar{a}$，它是$a$ 的模$m$ 逆，即有：${\bar{a}}\cdot a\equiv1({\bmod{{m}}})$。  
【定义2.16】假设$m_{1},m_{2},\cdots,m_{k}$为$k$个正整数，$a_{1},a_{2},\cdots,a_{k}$为$k$ 个整数，由下列$k$ 个以$x$ 为未知整数的同余方程联立而成的方程组，称为同余方程组：  
$$
\left\{\begin{array}{l l}{x\equiv a_{1}(\bmod~m_{1})}\\ {x\equiv a_{2}(\bmod m_{2})}\\ {\qquad\dots}\\ {x\equiv a_{k}(\bmod~m_{k})}\end{array}\right.\tag{2-14}
$$  
若存在一个整数$\cdot x_{0}$满足上述所有同余方程，则称$\cdot x_{0}$是该同余方程组的一个解。  
当以上定义的同余方程组中所有模两两互素时，方程组一定有唯一的一组解。下面的中国余数定理是整数理论中一个非常著名的定理，又称为孙子定理。该定理不仅确认了上述结论，而且其证明过程其实给出了一个具体的求解方法。  
【定理2.28】（中国余数定理）设$m_{1}$$\cdot\ \ m_{2},\ \ \cdots m_{k}$是两两互素的正整数，那么同余式组（2-14）有唯一的以$M=m_{1}m_{2}\cdots m_{k}$为模的解。",模逆是解决特定同余方程（如ax ≡ 1 (mod m)）的关键概念
同余方程组,组成,同余方程,,"相等的两个整数除以某一正整数$m$ 后得到的余数自然是相等的。因此，两个整数之间的同余关系不仅可以看成是对整除关系的一种推广，而且还可以看成是对两个整数相等关系的一种推广。下面定理表明整数相等关系与同余关系自己具有共同本质属性。  
【定理2.25】假设$m$ 是任一给定的正整数，则模$m$ 同余关系满足下列性质：  
(1) 自反性：$a\equiv a({\bmod{\ m}})$，对一切整数$a$ 成立；  
(2) 对称性：若$a\equiv b({\bmod{\ }}m)$，则$b\equiv a({\bmod{\ m}}).$；  
(3) 传递性：若$a\equiv b({\bmod{\ }}m)$，$b\equiv c({{\pmod{m}}})$，则$a\equiv c({{\pmod{m}}}).$。  
我们知道，根据整数之间相等关系的制约可以列出相应的整数方程和方程组。那么，根据整数同余关系的制约是否也可以列出相应的方程和方程组呢？如果可以，那么这些方程和方程组如何求解？本节我们就来讨论这些问题。  
【定义2.14】假设$m$ 是任一给定的正整数，$a$ 和$b$ 是任意给定的两个整数，下式：  
$$
a x\equiv b({\bmod{m}})\tag{2-13}
$$  
称为关于未知数$x$ 的一次线性同余方程，简称为同余方程，其中$x$ 为未知整数。若存在一个整数$\cdot x_{0}$，当$x=x_{0}$时，成立$.a x\equiv b({\bmod{\pmod{m}}})$，则称$\cdot x_{0}$是该同余方程的一个解。  
显然，如果$x_{0}$是某个同余方程的一个解，则与$x_{0}$同余的所有整数都是该同余方程的解，这是一种平凡情形，通常将与$x_{0}$同余的所有整数与$x_{0}$一起看成是同一个解。因此，同余方程解的计数标准为：凡是相互之间模$m$ 同余的解都视为同一个解，同余方程解的个数是指它的关于模$m$ 互不同余所有解的个数，亦即在模$m$ 的一个完全剩余系中解的个数。  
下面考察一次线性同余方程解的存在性：  
【定理2.26】假设$m$ 是任一给定的正整数，$a,b$ 是任意给定的两个整数，如果$a$ 与$m$之间没有整除关系，即有$a\not\equiv0({\bmod{m}})$ ，则下列同余方程  
$$
a x\equiv b({\bmod{m}})
$$  
有解的充要条件是$a$ 与$m$ 的最大公因数能够整除$b$。若有解，则解的个数为$\operatorname*{gcd}(a,m)$。  
对于同余方程$a\cdot x \equiv 1(\mod m)$，其有解的充要条件是$a$ 与$m$ 的最大公因数能够整除1，即互素$a$ 与$m$。且有解的情况下只有唯一解。由此给出如下关于$\bar{a}$的定义：  
【定义2.15】设$m$ 是任一给定的正整数，$a$ 是任一与$m$ 互素的整数，满足$a\cdot x\equiv$1 (mod $m^{\prime}$)的最小正整数解称为整数$a$的模$\pmb{m}$ 逆，记为$\cdot\bar{a}$。  
下面定理的证明过程给出了整数$a$ 模$m$ 逆$\bar{a}$的一个具体求法：  
【定理2.27】设$m$ 和$a$ 是两个互素的整数，且$m>1$，则存在唯一一个小于$m$ 的正整数$\bar{a}$，它是$a$ 的模$m$ 逆，即有：${\bar{a}}\cdot a\equiv1({\bmod{{m}}})$。  
【定义2.16】假设$m_{1},m_{2},\cdots,m_{k}$为$k$个正整数，$a_{1},a_{2},\cdots,a_{k}$为$k$ 个整数，由下列$k$ 个以$x$ 为未知整数的同余方程联立而成的方程组，称为同余方程组：  
$$
\left\{\begin{array}{l l}{x\equiv a_{1}(\bmod~m_{1})}\\ {x\equiv a_{2}(\bmod m_{2})}\\ {\qquad\dots}\\ {x\equiv a_{k}(\bmod~m_{k})}\end{array}\right.\tag{2-14}
$$  
若存在一个整数$\cdot x_{0}$满足上述所有同余方程，则称$\cdot x_{0}$是该同余方程组的一个解。  
当以上定义的同余方程组中所有模两两互素时，方程组一定有唯一的一组解。下面的中国余数定理是整数理论中一个非常著名的定理，又称为孙子定理。该定理不仅确认了上述结论，而且其证明过程其实给出了一个具体的求解方法。  
【定理2.28】（中国余数定理）设$m_{1}$$\cdot\ \ m_{2},\ \ \cdots m_{k}$是两两互素的正整数，那么同余式组（2-14）有唯一的以$M=m_{1}m_{2}\cdots m_{k}$为模的解。",同余方程组由多个同余方程组成
同余方程组,应用,中国余数定理,,"相等的两个整数除以某一正整数$m$ 后得到的余数自然是相等的。因此，两个整数之间的同余关系不仅可以看成是对整除关系的一种推广，而且还可以看成是对两个整数相等关系的一种推广。下面定理表明整数相等关系与同余关系自己具有共同本质属性。  
【定理2.25】假设$m$ 是任一给定的正整数，则模$m$ 同余关系满足下列性质：  
(1) 自反性：$a\equiv a({\bmod{\ m}})$，对一切整数$a$ 成立；  
(2) 对称性：若$a\equiv b({\bmod{\ }}m)$，则$b\equiv a({\bmod{\ m}}).$；  
(3) 传递性：若$a\equiv b({\bmod{\ }}m)$，$b\equiv c({{\pmod{m}}})$，则$a\equiv c({{\pmod{m}}}).$。  
我们知道，根据整数之间相等关系的制约可以列出相应的整数方程和方程组。那么，根据整数同余关系的制约是否也可以列出相应的方程和方程组呢？如果可以，那么这些方程和方程组如何求解？本节我们就来讨论这些问题。  
【定义2.14】假设$m$ 是任一给定的正整数，$a$ 和$b$ 是任意给定的两个整数，下式：  
$$
a x\equiv b({\bmod{m}})\tag{2-13}
$$  
称为关于未知数$x$ 的一次线性同余方程，简称为同余方程，其中$x$ 为未知整数。若存在一个整数$\cdot x_{0}$，当$x=x_{0}$时，成立$.a x\equiv b({\bmod{\pmod{m}}})$，则称$\cdot x_{0}$是该同余方程的一个解。  
显然，如果$x_{0}$是某个同余方程的一个解，则与$x_{0}$同余的所有整数都是该同余方程的解，这是一种平凡情形，通常将与$x_{0}$同余的所有整数与$x_{0}$一起看成是同一个解。因此，同余方程解的计数标准为：凡是相互之间模$m$ 同余的解都视为同一个解，同余方程解的个数是指它的关于模$m$ 互不同余所有解的个数，亦即在模$m$ 的一个完全剩余系中解的个数。  
下面考察一次线性同余方程解的存在性：  
【定理2.26】假设$m$ 是任一给定的正整数，$a,b$ 是任意给定的两个整数，如果$a$ 与$m$之间没有整除关系，即有$a\not\equiv0({\bmod{m}})$ ，则下列同余方程  
$$
a x\equiv b({\bmod{m}})
$$  
有解的充要条件是$a$ 与$m$ 的最大公因数能够整除$b$。若有解，则解的个数为$\operatorname*{gcd}(a,m)$。  
对于同余方程$a\cdot x \equiv 1(\mod m)$，其有解的充要条件是$a$ 与$m$ 的最大公因数能够整除1，即互素$a$ 与$m$。且有解的情况下只有唯一解。由此给出如下关于$\bar{a}$的定义：  
【定义2.15】设$m$ 是任一给定的正整数，$a$ 是任一与$m$ 互素的整数，满足$a\cdot x\equiv$1 (mod $m^{\prime}$)的最小正整数解称为整数$a$的模$\pmb{m}$ 逆，记为$\cdot\bar{a}$。  
下面定理的证明过程给出了整数$a$ 模$m$ 逆$\bar{a}$的一个具体求法：  
【定理2.27】设$m$ 和$a$ 是两个互素的整数，且$m>1$，则存在唯一一个小于$m$ 的正整数$\bar{a}$，它是$a$ 的模$m$ 逆，即有：${\bar{a}}\cdot a\equiv1({\bmod{{m}}})$。  
【定义2.16】假设$m_{1},m_{2},\cdots,m_{k}$为$k$个正整数，$a_{1},a_{2},\cdots,a_{k}$为$k$ 个整数，由下列$k$ 个以$x$ 为未知整数的同余方程联立而成的方程组，称为同余方程组：  
$$
\left\{\begin{array}{l l}{x\equiv a_{1}(\bmod~m_{1})}\\ {x\equiv a_{2}(\bmod m_{2})}\\ {\qquad\dots}\\ {x\equiv a_{k}(\bmod~m_{k})}\end{array}\right.\tag{2-14}
$$  
若存在一个整数$\cdot x_{0}$满足上述所有同余方程，则称$\cdot x_{0}$是该同余方程组的一个解。  
当以上定义的同余方程组中所有模两两互素时，方程组一定有唯一的一组解。下面的中国余数定理是整数理论中一个非常著名的定理，又称为孙子定理。该定理不仅确认了上述结论，而且其证明过程其实给出了一个具体的求解方法。  
【定理2.28】（中国余数定理）设$m_{1}$$\cdot\ \ m_{2},\ \ \cdots m_{k}$是两两互素的正整数，那么同余式组（2-14）有唯一的以$M=m_{1}m_{2}\cdots m_{k}$为模的解。",中国余数定理用于解决模两两互素的同余方程组，保证其有唯一解
中国余数定理,解决,同余方程组,,"相等的两个整数除以某一正整数$m$ 后得到的余数自然是相等的。因此，两个整数之间的同余关系不仅可以看成是对整除关系的一种推广，而且还可以看成是对两个整数相等关系的一种推广。下面定理表明整数相等关系与同余关系自己具有共同本质属性。  
【定理2.25】假设$m$ 是任一给定的正整数，则模$m$ 同余关系满足下列性质：  
(1) 自反性：$a\equiv a({\bmod{\ m}})$，对一切整数$a$ 成立；  
(2) 对称性：若$a\equiv b({\bmod{\ }}m)$，则$b\equiv a({\bmod{\ m}}).$；  
(3) 传递性：若$a\equiv b({\bmod{\ }}m)$，$b\equiv c({{\pmod{m}}})$，则$a\equiv c({{\pmod{m}}}).$。  
我们知道，根据整数之间相等关系的制约可以列出相应的整数方程和方程组。那么，根据整数同余关系的制约是否也可以列出相应的方程和方程组呢？如果可以，那么这些方程和方程组如何求解？本节我们就来讨论这些问题。  
【定义2.14】假设$m$ 是任一给定的正整数，$a$ 和$b$ 是任意给定的两个整数，下式：  
$$
a x\equiv b({\bmod{m}})\tag{2-13}
$$  
称为关于未知数$x$ 的一次线性同余方程，简称为同余方程，其中$x$ 为未知整数。若存在一个整数$\cdot x_{0}$，当$x=x_{0}$时，成立$.a x\equiv b({\bmod{\pmod{m}}})$，则称$\cdot x_{0}$是该同余方程的一个解。  
显然，如果$x_{0}$是某个同余方程的一个解，则与$x_{0}$同余的所有整数都是该同余方程的解，这是一种平凡情形，通常将与$x_{0}$同余的所有整数与$x_{0}$一起看成是同一个解。因此，同余方程解的计数标准为：凡是相互之间模$m$ 同余的解都视为同一个解，同余方程解的个数是指它的关于模$m$ 互不同余所有解的个数，亦即在模$m$ 的一个完全剩余系中解的个数。  
下面考察一次线性同余方程解的存在性：  
【定理2.26】假设$m$ 是任一给定的正整数，$a,b$ 是任意给定的两个整数，如果$a$ 与$m$之间没有整除关系，即有$a\not\equiv0({\bmod{m}})$ ，则下列同余方程  
$$
a x\equiv b({\bmod{m}})
$$  
有解的充要条件是$a$ 与$m$ 的最大公因数能够整除$b$。若有解，则解的个数为$\operatorname*{gcd}(a,m)$。  
对于同余方程$a\cdot x \equiv 1(\mod m)$，其有解的充要条件是$a$ 与$m$ 的最大公因数能够整除1，即互素$a$ 与$m$。且有解的情况下只有唯一解。由此给出如下关于$\bar{a}$的定义：  
【定义2.15】设$m$ 是任一给定的正整数，$a$ 是任一与$m$ 互素的整数，满足$a\cdot x\equiv$1 (mod $m^{\prime}$)的最小正整数解称为整数$a$的模$\pmb{m}$ 逆，记为$\cdot\bar{a}$。  
下面定理的证明过程给出了整数$a$ 模$m$ 逆$\bar{a}$的一个具体求法：  
【定理2.27】设$m$ 和$a$ 是两个互素的整数，且$m>1$，则存在唯一一个小于$m$ 的正整数$\bar{a}$，它是$a$ 的模$m$ 逆，即有：${\bar{a}}\cdot a\equiv1({\bmod{{m}}})$。  
【定义2.16】假设$m_{1},m_{2},\cdots,m_{k}$为$k$个正整数，$a_{1},a_{2},\cdots,a_{k}$为$k$ 个整数，由下列$k$ 个以$x$ 为未知整数的同余方程联立而成的方程组，称为同余方程组：  
$$
\left\{\begin{array}{l l}{x\equiv a_{1}(\bmod~m_{1})}\\ {x\equiv a_{2}(\bmod m_{2})}\\ {\qquad\dots}\\ {x\equiv a_{k}(\bmod~m_{k})}\end{array}\right.\tag{2-14}
$$  
若存在一个整数$\cdot x_{0}$满足上述所有同余方程，则称$\cdot x_{0}$是该同余方程组的一个解。  
当以上定义的同余方程组中所有模两两互素时，方程组一定有唯一的一组解。下面的中国余数定理是整数理论中一个非常著名的定理，又称为孙子定理。该定理不仅确认了上述结论，而且其证明过程其实给出了一个具体的求解方法。  
【定理2.28】（中国余数定理）设$m_{1}$$\cdot\ \ m_{2},\ \ \cdots m_{k}$是两两互素的正整数，那么同余式组（2-14）有唯一的以$M=m_{1}m_{2}\cdots m_{k}$为模的解。",中国余数定理提供了一种解决特定同余方程组的方法
仿射加密算法,基于,同余算术,,"为防止机密信息被泄露或破坏，需采用数据加密技术对其进行保护。数据加密的基本思想是对原始数据加以伪装，使非法接入者无法理解信息的真正含义，基本过程就是对原来为明文信息或数据按某种算法进行处理，使其成为不可读的一段代码，称为密文，使其只能在输入相应密钥之后才能显示出本来内容。数据加密通常分为对称式加密和非对称式加密两大类。本节介绍两种基于整数理论的经典加密算法，一种是名为仿射加密算法的对称加密算法，另一种是名为RSA 的非对称加密算法。  
仿射加密算法又称为凯撒加密算法，是一种简单且广为人知的加密技术。它是一种替换加密技术，基本思想如下：首先使用0 到25 之间的数字表示A 到Z 这26 个字母。然后，对于每个不大于25 的非负整数$\cdot p$，定义其加密函数值$f(p)$为$\{0,1,2,\ \cdots,25\}$中某个数字。加密函数$f(p)$的有多种定义方法，例如可采用如下加密函数：  
$$
f(p)=(p+3)\;{\bmod{\,}}26
$$  
对于上述加密函数，此时用整数$(p+3)\,\mathrm{mod}\,26$代表的字母替代由整数$p$表示的字母实现加密。例如，对“WELCOME TO HEFEI”进行加密，首先用数字代替字母，然后使用加密函数$f(p)=(p+3)\mod 26$ 代替$p$，翻译成字母后，得到获得到的加密信息为：“ZHOFRPH VR KHIHL”具体过程如下：  
表2-3 凯撒密码的加密过程
![](images/168580ee1913d8c32220b048da1875515ce367981f5bce7472f95af1471231b8.jpg)  
解密则需要使用加密函数的$f(p)$反函数 $f^{-1}(p)$  
$$
f^{-1}(p)=(p-3){\bmod{\,}}26
$$  
解密时需将加密信息转换成数字，然后使用$f^{-1}(p)$把$\{0,1,2,\ \cdots,25\}$中整数$\cdot p$恢复成信息原文对应的整数，之后再将数字装换成字母获得原文。  
RSA 算法由三位数学家Rivest、Shamir 和Adleman 于1977 年共同提出，是至今最为广泛使用的非对称加密算法，特别适合于对通过互联网传送的数据进行加密，通常于数字签名等场合。RSA 算法使用整数模余运算性质生成公钥和私钥，并进行加密和解密。RSA 算法原理基于欧拉定理和费马小定理，为此首先介绍这两个定理。  
【定理2.29】（欧拉定理）设$m$ 是任一正整数，$a$ 是任一与$m$ 互素的整数，则有：  
$$
a^{\varphi(m)}\equiv1({\bmod{\ m}})\tag{2-15}
$$  
其中$\varphi(m)$是欧拉函数。  
如果上述猜想能够成立，则提供了一个非常有效的素数判定方法。但是遗憾的是，上述猜想并不成立。事实上，$p$ 为只要是素数，则其必满足上式，但反之不然。法国数学家给出了如下称之为费马小定理更一般结论：  
【定理2.30】（费马小定理）假设$p$ 是一个任意给定的素数，则对于任意整数$a$，有：  
$$
a^{p}\equiv a({\bmod{\ p}})\tag{2-16}
$$  
特别地，当$a$与$p$ 互素时，有：$a^{p-1}\equiv1({\bmod{\ p}})$。  
下面介绍RSA 算法的基本原理和具体计算过程。RSA 算法理论基础是同余算术以及欧拉定理和费马小定理，其安全性依赖于大整数素因子分解的困难性，即已知整数$n$ 是两个大素数$p$ 和$q$ 的乘积，则难以在可接受的时间范围内通过$n$ 的素因子分解方法获得$p$ 和$q$ 的取值。RSA 算法的密钥生成、加密、解密的具体过程如下：  
1） 密钥的生成  
首先生成两个互不相同的大素数$p$ 和$q$，并令$n=p\cdot q$。其中$p$ 和$q$ 是属于解密信息，不可对外公开，整数$n$ 属于加密信息，需要对外公开。  
然后，令$\varphi(n)=(p-1)(q-1)$，并任意选择一个与$\varphi(n)$互素的正整数$e$，满足：  
$2\leq e\leq\varphi(n)$  
其中$\varphi(n)$不可对外公开，$e$ 为加密密钥，需要对外公开。  
由于$p$ 和$q$ 都是素数，故小于$p$ 且与$p$ 互素的非负整数的个数为$(p-1)$个，小于$q$ 且与$q$ 互素的非负整数的个数为$(q-1)$个。注意到$n=p\cdot q$，由计数的乘法原理及素数的性质可知，小于$\cdot n$且与$n$互素的非负整数的个数为$(p-1)$ $(q-1)$个，因此，$\varphi(n)=(p-1)(q-$1)其实就是欧拉函数。  
由于$e$ 的模$\varphi(n)$互素，因此$e$ 的模$\varphi(n)$同余逆$d$存在且唯一。算出$e$ 的模$\varphi(n)$同余逆$d$，使其满足：  
$$
e d\equiv1({\bmod{\ }}\varphi(n))\tag{2-17}
$$  
整数$d$ 属于解密密钥，不可对外公开。  
由此得到RSA 加密算法中作为公钥的加密密钥$e$，作为私钥的解密密钥$d$。  
2） 加密过程  
在RSA 加密算法中，要将明文信息转化成若干组整数序列。为此，首先将每个字母翻译成相应的整数，例如可以使用前述的凯撒加密算法完成这项工作。然后，将这些由明文字母对应的整数合并成若干组，每个组分别形成一个大整数，代表一个字母段。  
RSA 加密过程其实就是每个表示明文字母段的大整数$M$逐个转化为表示密文字母段的大整数$C$，具体转化公式如下：  
$$
C=M^{e}{\pmod{n}}\tag{2-18}
$$  
在转化过程中总是假定$M<n$。如果$M\geq n$，则需要对表示明文的所有整数重新进行分组以确保每个字母段对应的大整数小于$n$。  
3） 解密过程  
由于$d$ 是$e$ 的模$\varphi(n)$逆，即是$e$ 的模$(p-1)(q-1)$逆，故有：  
$$
e d\equiv1(\bmod(p-1)(q-1))\tag{2-19}
$$  
也就是说，$_{e d}$除以$(p-1)(q-1)$的余数为1，故存在整数$k$，使得：  
$$
e d={\begin{array}{l}{(p-1)(q-1)k+1}\end{array}}
$$  
故有：  
$$
C^{d}\equiv(M^{e})^{d}\equiv M^{e d}\equiv M^{(p-1)(q-1)k+1}\,({\mathrm{mod}}\,\,n)
$$  
假定$M$与$p$ 和$q$ 均为互素，则根据费马小定理有：  
$$
M^{p-1}\equiv1(\mathrm{\;mod}\;\left(p\right))\mathcal{X}M^{p-1}\equiv1(\mathrm{\;mod}\;\,q)
$$  
从而有：  
$$
\begin{array}{r}{C^{d}\equiv M^{(p-1)(q-1)k+1}\equiv\!\!M\!\cdot\!(M^{p-1})^{k(q-1)}\!\!\equiv\!\!M\!\cdot\!1\!\equiv\!\!M\,(\mathrm{mod}\,p)}\\ {C^{d}\equiv M^{(p-1)(q-1)k+1}\equiv\!\!M\!\cdot\!(M^{q-1})^{k(p-1)}\!\!\equiv\!\!M\!\cdot\!1\!\equiv\!\!M\,(\mathrm{mod}\,q)}\end{array}
$$  
由于$p$ 与$q$ 互素，则根据中国余数定理，有：  
$$
C^{d}\equiv M\,({\sf m o d}\,\,\,p\cdot q)\mathbb{\bar{X}}C^{d}\equiv M\,({\sf m o d}\,\,\,n)
$$  
由于$M<n$，故必有：$M=C^{d}\;({\mathsf{m o d}}\;\,n)$  
因此，若已知解密密钥$d$，就可使用公式$M=C^{d}\,({\sf m o d}\,n),$对密文$C$ 进行解密。  
在RSA 加密和解密算法中，如果$p,\ q$ 被信息窃取者获得，则可算出$(p-1)(q-1).$。由于$e$ 是公开密钥，且$d$是$e$ 关于关于模$(p-1)(q-1)$的逆，则不难求出$d$，如此RSA 系统便被完全攻破，信息窃取者就会很容易获得加密的信息。  
RSA 算法中的素数都是十进制整数，怎样才能选择好的$p$ 和$q$，这是$R S A$ 加密算法最关键的问题。针对素数$p$ 和$q$ 的选择，1978 年Rivest 等人在关于RSA 公开密钥的论文中，建议对素数$p$ 和$q$ 的选择应当满足：  
1）$p$ 和$q$ 要足够长，在长度上应相差几位，且二者之差与$p$ 和$q$ 位数相近；  
2）$p{-}1$ 和$q{-}1$ 的最大公约数$\operatorname*{gcd}(p -1\,,\,\,\,q-\!\!1)$要尽量小；  
3）$p{-}1$ 和$q{-}1$ 均应至少含有一个大的素数因子。  
并把满足这些条件的素数称为安全素数。  
从实用的观点看，如果加密后的信息能够保证在足够长的时间内不能被破解，则认为这个加密方法是安全的。相对于RSA 加密算法而言，如果整数$n$ 不是足够大，例如只有10 位，那么按照计算机目前的计算能力，几乎可以立刻求出其所有素因子实现对RSA 加密算法的破解。如果计算机的计算能力得到进一步的提高，则或许能够破解200 位的整数$n$。但是，如果使用200 素数$p$ 和200 位素数$q$ 构成400 位整数$n$，则计算机无法破解由此设计的RSA加密算法。因此，就目前以及今后一段时间而言，RSA 加密算法具有较好的安全性。",仿射加密算法是基于同余算术的加密技术
RSA算法,基于,欧拉定理,,"为防止机密信息被泄露或破坏，需采用数据加密技术对其进行保护。数据加密的基本思想是对原始数据加以伪装，使非法接入者无法理解信息的真正含义，基本过程就是对原来为明文信息或数据按某种算法进行处理，使其成为不可读的一段代码，称为密文，使其只能在输入相应密钥之后才能显示出本来内容。数据加密通常分为对称式加密和非对称式加密两大类。本节介绍两种基于整数理论的经典加密算法，一种是名为仿射加密算法的对称加密算法，另一种是名为RSA 的非对称加密算法。  
仿射加密算法又称为凯撒加密算法，是一种简单且广为人知的加密技术。它是一种替换加密技术，基本思想如下：首先使用0 到25 之间的数字表示A 到Z 这26 个字母。然后，对于每个不大于25 的非负整数$\cdot p$，定义其加密函数值$f(p)$为$\{0,1,2,\ \cdots,25\}$中某个数字。加密函数$f(p)$的有多种定义方法，例如可采用如下加密函数：  
$$
f(p)=(p+3)\;{\bmod{\,}}26
$$  
对于上述加密函数，此时用整数$(p+3)\,\mathrm{mod}\,26$代表的字母替代由整数$p$表示的字母实现加密。例如，对“WELCOME TO HEFEI”进行加密，首先用数字代替字母，然后使用加密函数$f(p)=(p+3)\mod 26$ 代替$p$，翻译成字母后，得到获得到的加密信息为：“ZHOFRPH VR KHIHL”具体过程如下：  
表2-3 凯撒密码的加密过程
![](images/168580ee1913d8c32220b048da1875515ce367981f5bce7472f95af1471231b8.jpg)  
解密则需要使用加密函数的$f(p)$反函数 $f^{-1}(p)$  
$$
f^{-1}(p)=(p-3){\bmod{\,}}26
$$  
解密时需将加密信息转换成数字，然后使用$f^{-1}(p)$把$\{0,1,2,\ \cdots,25\}$中整数$\cdot p$恢复成信息原文对应的整数，之后再将数字装换成字母获得原文。  
RSA 算法由三位数学家Rivest、Shamir 和Adleman 于1977 年共同提出，是至今最为广泛使用的非对称加密算法，特别适合于对通过互联网传送的数据进行加密，通常于数字签名等场合。RSA 算法使用整数模余运算性质生成公钥和私钥，并进行加密和解密。RSA 算法原理基于欧拉定理和费马小定理，为此首先介绍这两个定理。  
【定理2.29】（欧拉定理）设$m$ 是任一正整数，$a$ 是任一与$m$ 互素的整数，则有：  
$$
a^{\varphi(m)}\equiv1({\bmod{\ m}})\tag{2-15}
$$  
其中$\varphi(m)$是欧拉函数。  
如果上述猜想能够成立，则提供了一个非常有效的素数判定方法。但是遗憾的是，上述猜想并不成立。事实上，$p$ 为只要是素数，则其必满足上式，但反之不然。法国数学家给出了如下称之为费马小定理更一般结论：  
【定理2.30】（费马小定理）假设$p$ 是一个任意给定的素数，则对于任意整数$a$，有：  
$$
a^{p}\equiv a({\bmod{\ p}})\tag{2-16}
$$  
特别地，当$a$与$p$ 互素时，有：$a^{p-1}\equiv1({\bmod{\ p}})$。  
下面介绍RSA 算法的基本原理和具体计算过程。RSA 算法理论基础是同余算术以及欧拉定理和费马小定理，其安全性依赖于大整数素因子分解的困难性，即已知整数$n$ 是两个大素数$p$ 和$q$ 的乘积，则难以在可接受的时间范围内通过$n$ 的素因子分解方法获得$p$ 和$q$ 的取值。RSA 算法的密钥生成、加密、解密的具体过程如下：  
1） 密钥的生成  
首先生成两个互不相同的大素数$p$ 和$q$，并令$n=p\cdot q$。其中$p$ 和$q$ 是属于解密信息，不可对外公开，整数$n$ 属于加密信息，需要对外公开。  
然后，令$\varphi(n)=(p-1)(q-1)$，并任意选择一个与$\varphi(n)$互素的正整数$e$，满足：  
$2\leq e\leq\varphi(n)$  
其中$\varphi(n)$不可对外公开，$e$ 为加密密钥，需要对外公开。  
由于$p$ 和$q$ 都是素数，故小于$p$ 且与$p$ 互素的非负整数的个数为$(p-1)$个，小于$q$ 且与$q$ 互素的非负整数的个数为$(q-1)$个。注意到$n=p\cdot q$，由计数的乘法原理及素数的性质可知，小于$\cdot n$且与$n$互素的非负整数的个数为$(p-1)$ $(q-1)$个，因此，$\varphi(n)=(p-1)(q-$1)其实就是欧拉函数。  
由于$e$ 的模$\varphi(n)$互素，因此$e$ 的模$\varphi(n)$同余逆$d$存在且唯一。算出$e$ 的模$\varphi(n)$同余逆$d$，使其满足：  
$$
e d\equiv1({\bmod{\ }}\varphi(n))\tag{2-17}
$$  
整数$d$ 属于解密密钥，不可对外公开。  
由此得到RSA 加密算法中作为公钥的加密密钥$e$，作为私钥的解密密钥$d$。  
2） 加密过程  
在RSA 加密算法中，要将明文信息转化成若干组整数序列。为此，首先将每个字母翻译成相应的整数，例如可以使用前述的凯撒加密算法完成这项工作。然后，将这些由明文字母对应的整数合并成若干组，每个组分别形成一个大整数，代表一个字母段。  
RSA 加密过程其实就是每个表示明文字母段的大整数$M$逐个转化为表示密文字母段的大整数$C$，具体转化公式如下：  
$$
C=M^{e}{\pmod{n}}\tag{2-18}
$$  
在转化过程中总是假定$M<n$。如果$M\geq n$，则需要对表示明文的所有整数重新进行分组以确保每个字母段对应的大整数小于$n$。  
3） 解密过程  
由于$d$ 是$e$ 的模$\varphi(n)$逆，即是$e$ 的模$(p-1)(q-1)$逆，故有：  
$$
e d\equiv1(\bmod(p-1)(q-1))\tag{2-19}
$$  
也就是说，$_{e d}$除以$(p-1)(q-1)$的余数为1，故存在整数$k$，使得：  
$$
e d={\begin{array}{l}{(p-1)(q-1)k+1}\end{array}}
$$  
故有：  
$$
C^{d}\equiv(M^{e})^{d}\equiv M^{e d}\equiv M^{(p-1)(q-1)k+1}\,({\mathrm{mod}}\,\,n)
$$  
假定$M$与$p$ 和$q$ 均为互素，则根据费马小定理有：  
$$
M^{p-1}\equiv1(\mathrm{\;mod}\;\left(p\right))\mathcal{X}M^{p-1}\equiv1(\mathrm{\;mod}\;\,q)
$$  
从而有：  
$$
\begin{array}{r}{C^{d}\equiv M^{(p-1)(q-1)k+1}\equiv\!\!M\!\cdot\!(M^{p-1})^{k(q-1)}\!\!\equiv\!\!M\!\cdot\!1\!\equiv\!\!M\,(\mathrm{mod}\,p)}\\ {C^{d}\equiv M^{(p-1)(q-1)k+1}\equiv\!\!M\!\cdot\!(M^{q-1})^{k(p-1)}\!\!\equiv\!\!M\!\cdot\!1\!\equiv\!\!M\,(\mathrm{mod}\,q)}\end{array}
$$  
由于$p$ 与$q$ 互素，则根据中国余数定理，有：  
$$
C^{d}\equiv M\,({\sf m o d}\,\,\,p\cdot q)\mathbb{\bar{X}}C^{d}\equiv M\,({\sf m o d}\,\,\,n)
$$  
由于$M<n$，故必有：$M=C^{d}\;({\mathsf{m o d}}\;\,n)$  
因此，若已知解密密钥$d$，就可使用公式$M=C^{d}\,({\sf m o d}\,n),$对密文$C$ 进行解密。  
在RSA 加密和解密算法中，如果$p,\ q$ 被信息窃取者获得，则可算出$(p-1)(q-1).$。由于$e$ 是公开密钥，且$d$是$e$ 关于关于模$(p-1)(q-1)$的逆，则不难求出$d$，如此RSA 系统便被完全攻破，信息窃取者就会很容易获得加密的信息。  
RSA 算法中的素数都是十进制整数，怎样才能选择好的$p$ 和$q$，这是$R S A$ 加密算法最关键的问题。针对素数$p$ 和$q$ 的选择，1978 年Rivest 等人在关于RSA 公开密钥的论文中，建议对素数$p$ 和$q$ 的选择应当满足：  
1）$p$ 和$q$ 要足够长，在长度上应相差几位，且二者之差与$p$ 和$q$ 位数相近；  
2）$p{-}1$ 和$q{-}1$ 的最大公约数$\operatorname*{gcd}(p -1\,,\,\,\,q-\!\!1)$要尽量小；  
3）$p{-}1$ 和$q{-}1$ 均应至少含有一个大的素数因子。  
并把满足这些条件的素数称为安全素数。  
从实用的观点看，如果加密后的信息能够保证在足够长的时间内不能被破解，则认为这个加密方法是安全的。相对于RSA 加密算法而言，如果整数$n$ 不是足够大，例如只有10 位，那么按照计算机目前的计算能力，几乎可以立刻求出其所有素因子实现对RSA 加密算法的破解。如果计算机的计算能力得到进一步的提高，则或许能够破解200 位的整数$n$。但是，如果使用200 素数$p$ 和200 位素数$q$ 构成400 位整数$n$，则计算机无法破解由此设计的RSA加密算法。因此，就目前以及今后一段时间而言，RSA 加密算法具有较好的安全性。",RSA算法的原理基于欧拉定理
RSA算法,基于,费马小定理,,"为防止机密信息被泄露或破坏，需采用数据加密技术对其进行保护。数据加密的基本思想是对原始数据加以伪装，使非法接入者无法理解信息的真正含义，基本过程就是对原来为明文信息或数据按某种算法进行处理，使其成为不可读的一段代码，称为密文，使其只能在输入相应密钥之后才能显示出本来内容。数据加密通常分为对称式加密和非对称式加密两大类。本节介绍两种基于整数理论的经典加密算法，一种是名为仿射加密算法的对称加密算法，另一种是名为RSA 的非对称加密算法。  
仿射加密算法又称为凯撒加密算法，是一种简单且广为人知的加密技术。它是一种替换加密技术，基本思想如下：首先使用0 到25 之间的数字表示A 到Z 这26 个字母。然后，对于每个不大于25 的非负整数$\cdot p$，定义其加密函数值$f(p)$为$\{0,1,2,\ \cdots,25\}$中某个数字。加密函数$f(p)$的有多种定义方法，例如可采用如下加密函数：  
$$
f(p)=(p+3)\;{\bmod{\,}}26
$$  
对于上述加密函数，此时用整数$(p+3)\,\mathrm{mod}\,26$代表的字母替代由整数$p$表示的字母实现加密。例如，对“WELCOME TO HEFEI”进行加密，首先用数字代替字母，然后使用加密函数$f(p)=(p+3)\mod 26$ 代替$p$，翻译成字母后，得到获得到的加密信息为：“ZHOFRPH VR KHIHL”具体过程如下：  
表2-3 凯撒密码的加密过程
![](images/168580ee1913d8c32220b048da1875515ce367981f5bce7472f95af1471231b8.jpg)  
解密则需要使用加密函数的$f(p)$反函数 $f^{-1}(p)$  
$$
f^{-1}(p)=(p-3){\bmod{\,}}26
$$  
解密时需将加密信息转换成数字，然后使用$f^{-1}(p)$把$\{0,1,2,\ \cdots,25\}$中整数$\cdot p$恢复成信息原文对应的整数，之后再将数字装换成字母获得原文。  
RSA 算法由三位数学家Rivest、Shamir 和Adleman 于1977 年共同提出，是至今最为广泛使用的非对称加密算法，特别适合于对通过互联网传送的数据进行加密，通常于数字签名等场合。RSA 算法使用整数模余运算性质生成公钥和私钥，并进行加密和解密。RSA 算法原理基于欧拉定理和费马小定理，为此首先介绍这两个定理。  
【定理2.29】（欧拉定理）设$m$ 是任一正整数，$a$ 是任一与$m$ 互素的整数，则有：  
$$
a^{\varphi(m)}\equiv1({\bmod{\ m}})\tag{2-15}
$$  
其中$\varphi(m)$是欧拉函数。  
如果上述猜想能够成立，则提供了一个非常有效的素数判定方法。但是遗憾的是，上述猜想并不成立。事实上，$p$ 为只要是素数，则其必满足上式，但反之不然。法国数学家给出了如下称之为费马小定理更一般结论：  
【定理2.30】（费马小定理）假设$p$ 是一个任意给定的素数，则对于任意整数$a$，有：  
$$
a^{p}\equiv a({\bmod{\ p}})\tag{2-16}
$$  
特别地，当$a$与$p$ 互素时，有：$a^{p-1}\equiv1({\bmod{\ p}})$。  
下面介绍RSA 算法的基本原理和具体计算过程。RSA 算法理论基础是同余算术以及欧拉定理和费马小定理，其安全性依赖于大整数素因子分解的困难性，即已知整数$n$ 是两个大素数$p$ 和$q$ 的乘积，则难以在可接受的时间范围内通过$n$ 的素因子分解方法获得$p$ 和$q$ 的取值。RSA 算法的密钥生成、加密、解密的具体过程如下：  
1） 密钥的生成  
首先生成两个互不相同的大素数$p$ 和$q$，并令$n=p\cdot q$。其中$p$ 和$q$ 是属于解密信息，不可对外公开，整数$n$ 属于加密信息，需要对外公开。  
然后，令$\varphi(n)=(p-1)(q-1)$，并任意选择一个与$\varphi(n)$互素的正整数$e$，满足：  
$2\leq e\leq\varphi(n)$  
其中$\varphi(n)$不可对外公开，$e$ 为加密密钥，需要对外公开。  
由于$p$ 和$q$ 都是素数，故小于$p$ 且与$p$ 互素的非负整数的个数为$(p-1)$个，小于$q$ 且与$q$ 互素的非负整数的个数为$(q-1)$个。注意到$n=p\cdot q$，由计数的乘法原理及素数的性质可知，小于$\cdot n$且与$n$互素的非负整数的个数为$(p-1)$ $(q-1)$个，因此，$\varphi(n)=(p-1)(q-$1)其实就是欧拉函数。  
由于$e$ 的模$\varphi(n)$互素，因此$e$ 的模$\varphi(n)$同余逆$d$存在且唯一。算出$e$ 的模$\varphi(n)$同余逆$d$，使其满足：  
$$
e d\equiv1({\bmod{\ }}\varphi(n))\tag{2-17}
$$  
整数$d$ 属于解密密钥，不可对外公开。  
由此得到RSA 加密算法中作为公钥的加密密钥$e$，作为私钥的解密密钥$d$。  
2） 加密过程  
在RSA 加密算法中，要将明文信息转化成若干组整数序列。为此，首先将每个字母翻译成相应的整数，例如可以使用前述的凯撒加密算法完成这项工作。然后，将这些由明文字母对应的整数合并成若干组，每个组分别形成一个大整数，代表一个字母段。  
RSA 加密过程其实就是每个表示明文字母段的大整数$M$逐个转化为表示密文字母段的大整数$C$，具体转化公式如下：  
$$
C=M^{e}{\pmod{n}}\tag{2-18}
$$  
在转化过程中总是假定$M<n$。如果$M\geq n$，则需要对表示明文的所有整数重新进行分组以确保每个字母段对应的大整数小于$n$。  
3） 解密过程  
由于$d$ 是$e$ 的模$\varphi(n)$逆，即是$e$ 的模$(p-1)(q-1)$逆，故有：  
$$
e d\equiv1(\bmod(p-1)(q-1))\tag{2-19}
$$  
也就是说，$_{e d}$除以$(p-1)(q-1)$的余数为1，故存在整数$k$，使得：  
$$
e d={\begin{array}{l}{(p-1)(q-1)k+1}\end{array}}
$$  
故有：  
$$
C^{d}\equiv(M^{e})^{d}\equiv M^{e d}\equiv M^{(p-1)(q-1)k+1}\,({\mathrm{mod}}\,\,n)
$$  
假定$M$与$p$ 和$q$ 均为互素，则根据费马小定理有：  
$$
M^{p-1}\equiv1(\mathrm{\;mod}\;\left(p\right))\mathcal{X}M^{p-1}\equiv1(\mathrm{\;mod}\;\,q)
$$  
从而有：  
$$
\begin{array}{r}{C^{d}\equiv M^{(p-1)(q-1)k+1}\equiv\!\!M\!\cdot\!(M^{p-1})^{k(q-1)}\!\!\equiv\!\!M\!\cdot\!1\!\equiv\!\!M\,(\mathrm{mod}\,p)}\\ {C^{d}\equiv M^{(p-1)(q-1)k+1}\equiv\!\!M\!\cdot\!(M^{q-1})^{k(p-1)}\!\!\equiv\!\!M\!\cdot\!1\!\equiv\!\!M\,(\mathrm{mod}\,q)}\end{array}
$$  
由于$p$ 与$q$ 互素，则根据中国余数定理，有：  
$$
C^{d}\equiv M\,({\sf m o d}\,\,\,p\cdot q)\mathbb{\bar{X}}C^{d}\equiv M\,({\sf m o d}\,\,\,n)
$$  
由于$M<n$，故必有：$M=C^{d}\;({\mathsf{m o d}}\;\,n)$  
因此，若已知解密密钥$d$，就可使用公式$M=C^{d}\,({\sf m o d}\,n),$对密文$C$ 进行解密。  
在RSA 加密和解密算法中，如果$p,\ q$ 被信息窃取者获得，则可算出$(p-1)(q-1).$。由于$e$ 是公开密钥，且$d$是$e$ 关于关于模$(p-1)(q-1)$的逆，则不难求出$d$，如此RSA 系统便被完全攻破，信息窃取者就会很容易获得加密的信息。  
RSA 算法中的素数都是十进制整数，怎样才能选择好的$p$ 和$q$，这是$R S A$ 加密算法最关键的问题。针对素数$p$ 和$q$ 的选择，1978 年Rivest 等人在关于RSA 公开密钥的论文中，建议对素数$p$ 和$q$ 的选择应当满足：  
1）$p$ 和$q$ 要足够长，在长度上应相差几位，且二者之差与$p$ 和$q$ 位数相近；  
2）$p{-}1$ 和$q{-}1$ 的最大公约数$\operatorname*{gcd}(p -1\,,\,\,\,q-\!\!1)$要尽量小；  
3）$p{-}1$ 和$q{-}1$ 均应至少含有一个大的素数因子。  
并把满足这些条件的素数称为安全素数。  
从实用的观点看，如果加密后的信息能够保证在足够长的时间内不能被破解，则认为这个加密方法是安全的。相对于RSA 加密算法而言，如果整数$n$ 不是足够大，例如只有10 位，那么按照计算机目前的计算能力，几乎可以立刻求出其所有素因子实现对RSA 加密算法的破解。如果计算机的计算能力得到进一步的提高，则或许能够破解200 位的整数$n$。但是，如果使用200 素数$p$ 和200 位素数$q$ 构成400 位整数$n$，则计算机无法破解由此设计的RSA加密算法。因此，就目前以及今后一段时间而言，RSA 加密算法具有较好的安全性。",RSA算法的原理基于费马小定理
RSA算法,依赖,安全素数,,"为防止机密信息被泄露或破坏，需采用数据加密技术对其进行保护。数据加密的基本思想是对原始数据加以伪装，使非法接入者无法理解信息的真正含义，基本过程就是对原来为明文信息或数据按某种算法进行处理，使其成为不可读的一段代码，称为密文，使其只能在输入相应密钥之后才能显示出本来内容。数据加密通常分为对称式加密和非对称式加密两大类。本节介绍两种基于整数理论的经典加密算法，一种是名为仿射加密算法的对称加密算法，另一种是名为RSA 的非对称加密算法。  
仿射加密算法又称为凯撒加密算法，是一种简单且广为人知的加密技术。它是一种替换加密技术，基本思想如下：首先使用0 到25 之间的数字表示A 到Z 这26 个字母。然后，对于每个不大于25 的非负整数$\cdot p$，定义其加密函数值$f(p)$为$\{0,1,2,\ \cdots,25\}$中某个数字。加密函数$f(p)$的有多种定义方法，例如可采用如下加密函数：  
$$
f(p)=(p+3)\;{\bmod{\,}}26
$$  
对于上述加密函数，此时用整数$(p+3)\,\mathrm{mod}\,26$代表的字母替代由整数$p$表示的字母实现加密。例如，对“WELCOME TO HEFEI”进行加密，首先用数字代替字母，然后使用加密函数$f(p)=(p+3)\mod 26$ 代替$p$，翻译成字母后，得到获得到的加密信息为：“ZHOFRPH VR KHIHL”具体过程如下：  
表2-3 凯撒密码的加密过程
![](images/168580ee1913d8c32220b048da1875515ce367981f5bce7472f95af1471231b8.jpg)  
解密则需要使用加密函数的$f(p)$反函数 $f^{-1}(p)$  
$$
f^{-1}(p)=(p-3){\bmod{\,}}26
$$  
解密时需将加密信息转换成数字，然后使用$f^{-1}(p)$把$\{0,1,2,\ \cdots,25\}$中整数$\cdot p$恢复成信息原文对应的整数，之后再将数字装换成字母获得原文。  
RSA 算法由三位数学家Rivest、Shamir 和Adleman 于1977 年共同提出，是至今最为广泛使用的非对称加密算法，特别适合于对通过互联网传送的数据进行加密，通常于数字签名等场合。RSA 算法使用整数模余运算性质生成公钥和私钥，并进行加密和解密。RSA 算法原理基于欧拉定理和费马小定理，为此首先介绍这两个定理。  
【定理2.29】（欧拉定理）设$m$ 是任一正整数，$a$ 是任一与$m$ 互素的整数，则有：  
$$
a^{\varphi(m)}\equiv1({\bmod{\ m}})\tag{2-15}
$$  
其中$\varphi(m)$是欧拉函数。  
如果上述猜想能够成立，则提供了一个非常有效的素数判定方法。但是遗憾的是，上述猜想并不成立。事实上，$p$ 为只要是素数，则其必满足上式，但反之不然。法国数学家给出了如下称之为费马小定理更一般结论：  
【定理2.30】（费马小定理）假设$p$ 是一个任意给定的素数，则对于任意整数$a$，有：  
$$
a^{p}\equiv a({\bmod{\ p}})\tag{2-16}
$$  
特别地，当$a$与$p$ 互素时，有：$a^{p-1}\equiv1({\bmod{\ p}})$。  
下面介绍RSA 算法的基本原理和具体计算过程。RSA 算法理论基础是同余算术以及欧拉定理和费马小定理，其安全性依赖于大整数素因子分解的困难性，即已知整数$n$ 是两个大素数$p$ 和$q$ 的乘积，则难以在可接受的时间范围内通过$n$ 的素因子分解方法获得$p$ 和$q$ 的取值。RSA 算法的密钥生成、加密、解密的具体过程如下：  
1） 密钥的生成  
首先生成两个互不相同的大素数$p$ 和$q$，并令$n=p\cdot q$。其中$p$ 和$q$ 是属于解密信息，不可对外公开，整数$n$ 属于加密信息，需要对外公开。  
然后，令$\varphi(n)=(p-1)(q-1)$，并任意选择一个与$\varphi(n)$互素的正整数$e$，满足：  
$2\leq e\leq\varphi(n)$  
其中$\varphi(n)$不可对外公开，$e$ 为加密密钥，需要对外公开。  
由于$p$ 和$q$ 都是素数，故小于$p$ 且与$p$ 互素的非负整数的个数为$(p-1)$个，小于$q$ 且与$q$ 互素的非负整数的个数为$(q-1)$个。注意到$n=p\cdot q$，由计数的乘法原理及素数的性质可知，小于$\cdot n$且与$n$互素的非负整数的个数为$(p-1)$ $(q-1)$个，因此，$\varphi(n)=(p-1)(q-$1)其实就是欧拉函数。  
由于$e$ 的模$\varphi(n)$互素，因此$e$ 的模$\varphi(n)$同余逆$d$存在且唯一。算出$e$ 的模$\varphi(n)$同余逆$d$，使其满足：  
$$
e d\equiv1({\bmod{\ }}\varphi(n))\tag{2-17}
$$  
整数$d$ 属于解密密钥，不可对外公开。  
由此得到RSA 加密算法中作为公钥的加密密钥$e$，作为私钥的解密密钥$d$。  
2） 加密过程  
在RSA 加密算法中，要将明文信息转化成若干组整数序列。为此，首先将每个字母翻译成相应的整数，例如可以使用前述的凯撒加密算法完成这项工作。然后，将这些由明文字母对应的整数合并成若干组，每个组分别形成一个大整数，代表一个字母段。  
RSA 加密过程其实就是每个表示明文字母段的大整数$M$逐个转化为表示密文字母段的大整数$C$，具体转化公式如下：  
$$
C=M^{e}{\pmod{n}}\tag{2-18}
$$  
在转化过程中总是假定$M<n$。如果$M\geq n$，则需要对表示明文的所有整数重新进行分组以确保每个字母段对应的大整数小于$n$。  
3） 解密过程  
由于$d$ 是$e$ 的模$\varphi(n)$逆，即是$e$ 的模$(p-1)(q-1)$逆，故有：  
$$
e d\equiv1(\bmod(p-1)(q-1))\tag{2-19}
$$  
也就是说，$_{e d}$除以$(p-1)(q-1)$的余数为1，故存在整数$k$，使得：  
$$
e d={\begin{array}{l}{(p-1)(q-1)k+1}\end{array}}
$$  
故有：  
$$
C^{d}\equiv(M^{e})^{d}\equiv M^{e d}\equiv M^{(p-1)(q-1)k+1}\,({\mathrm{mod}}\,\,n)
$$  
假定$M$与$p$ 和$q$ 均为互素，则根据费马小定理有：  
$$
M^{p-1}\equiv1(\mathrm{\;mod}\;\left(p\right))\mathcal{X}M^{p-1}\equiv1(\mathrm{\;mod}\;\,q)
$$  
从而有：  
$$
\begin{array}{r}{C^{d}\equiv M^{(p-1)(q-1)k+1}\equiv\!\!M\!\cdot\!(M^{p-1})^{k(q-1)}\!\!\equiv\!\!M\!\cdot\!1\!\equiv\!\!M\,(\mathrm{mod}\,p)}\\ {C^{d}\equiv M^{(p-1)(q-1)k+1}\equiv\!\!M\!\cdot\!(M^{q-1})^{k(p-1)}\!\!\equiv\!\!M\!\cdot\!1\!\equiv\!\!M\,(\mathrm{mod}\,q)}\end{array}
$$  
由于$p$ 与$q$ 互素，则根据中国余数定理，有：  
$$
C^{d}\equiv M\,({\sf m o d}\,\,\,p\cdot q)\mathbb{\bar{X}}C^{d}\equiv M\,({\sf m o d}\,\,\,n)
$$  
由于$M<n$，故必有：$M=C^{d}\;({\mathsf{m o d}}\;\,n)$  
因此，若已知解密密钥$d$，就可使用公式$M=C^{d}\,({\sf m o d}\,n),$对密文$C$ 进行解密。  
在RSA 加密和解密算法中，如果$p,\ q$ 被信息窃取者获得，则可算出$(p-1)(q-1).$。由于$e$ 是公开密钥，且$d$是$e$ 关于关于模$(p-1)(q-1)$的逆，则不难求出$d$，如此RSA 系统便被完全攻破，信息窃取者就会很容易获得加密的信息。  
RSA 算法中的素数都是十进制整数，怎样才能选择好的$p$ 和$q$，这是$R S A$ 加密算法最关键的问题。针对素数$p$ 和$q$ 的选择，1978 年Rivest 等人在关于RSA 公开密钥的论文中，建议对素数$p$ 和$q$ 的选择应当满足：  
1）$p$ 和$q$ 要足够长，在长度上应相差几位，且二者之差与$p$ 和$q$ 位数相近；  
2）$p{-}1$ 和$q{-}1$ 的最大公约数$\operatorname*{gcd}(p -1\,,\,\,\,q-\!\!1)$要尽量小；  
3）$p{-}1$ 和$q{-}1$ 均应至少含有一个大的素数因子。  
并把满足这些条件的素数称为安全素数。  
从实用的观点看，如果加密后的信息能够保证在足够长的时间内不能被破解，则认为这个加密方法是安全的。相对于RSA 加密算法而言，如果整数$n$ 不是足够大，例如只有10 位，那么按照计算机目前的计算能力，几乎可以立刻求出其所有素因子实现对RSA 加密算法的破解。如果计算机的计算能力得到进一步的提高，则或许能够破解200 位的整数$n$。但是，如果使用200 素数$p$ 和200 位素数$q$ 构成400 位整数$n$，则计算机无法破解由此设计的RSA加密算法。因此，就目前以及今后一段时间而言，RSA 加密算法具有较好的安全性。",RSA算法的安全性依赖于安全素数的选择
RSA算法,基于,同余算术,,"为防止机密信息被泄露或破坏，需采用数据加密技术对其进行保护。数据加密的基本思想是对原始数据加以伪装，使非法接入者无法理解信息的真正含义，基本过程就是对原来为明文信息或数据按某种算法进行处理，使其成为不可读的一段代码，称为密文，使其只能在输入相应密钥之后才能显示出本来内容。数据加密通常分为对称式加密和非对称式加密两大类。本节介绍两种基于整数理论的经典加密算法，一种是名为仿射加密算法的对称加密算法，另一种是名为RSA 的非对称加密算法。  
仿射加密算法又称为凯撒加密算法，是一种简单且广为人知的加密技术。它是一种替换加密技术，基本思想如下：首先使用0 到25 之间的数字表示A 到Z 这26 个字母。然后，对于每个不大于25 的非负整数$\cdot p$，定义其加密函数值$f(p)$为$\{0,1,2,\ \cdots,25\}$中某个数字。加密函数$f(p)$的有多种定义方法，例如可采用如下加密函数：  
$$
f(p)=(p+3)\;{\bmod{\,}}26
$$  
对于上述加密函数，此时用整数$(p+3)\,\mathrm{mod}\,26$代表的字母替代由整数$p$表示的字母实现加密。例如，对“WELCOME TO HEFEI”进行加密，首先用数字代替字母，然后使用加密函数$f(p)=(p+3)\mod 26$ 代替$p$，翻译成字母后，得到获得到的加密信息为：“ZHOFRPH VR KHIHL”具体过程如下：  
表2-3 凯撒密码的加密过程
![](images/168580ee1913d8c32220b048da1875515ce367981f5bce7472f95af1471231b8.jpg)  
解密则需要使用加密函数的$f(p)$反函数 $f^{-1}(p)$  
$$
f^{-1}(p)=(p-3){\bmod{\,}}26
$$  
解密时需将加密信息转换成数字，然后使用$f^{-1}(p)$把$\{0,1,2,\ \cdots,25\}$中整数$\cdot p$恢复成信息原文对应的整数，之后再将数字装换成字母获得原文。  
RSA 算法由三位数学家Rivest、Shamir 和Adleman 于1977 年共同提出，是至今最为广泛使用的非对称加密算法，特别适合于对通过互联网传送的数据进行加密，通常于数字签名等场合。RSA 算法使用整数模余运算性质生成公钥和私钥，并进行加密和解密。RSA 算法原理基于欧拉定理和费马小定理，为此首先介绍这两个定理。  
【定理2.29】（欧拉定理）设$m$ 是任一正整数，$a$ 是任一与$m$ 互素的整数，则有：  
$$
a^{\varphi(m)}\equiv1({\bmod{\ m}})\tag{2-15}
$$  
其中$\varphi(m)$是欧拉函数。  
如果上述猜想能够成立，则提供了一个非常有效的素数判定方法。但是遗憾的是，上述猜想并不成立。事实上，$p$ 为只要是素数，则其必满足上式，但反之不然。法国数学家给出了如下称之为费马小定理更一般结论：  
【定理2.30】（费马小定理）假设$p$ 是一个任意给定的素数，则对于任意整数$a$，有：  
$$
a^{p}\equiv a({\bmod{\ p}})\tag{2-16}
$$  
特别地，当$a$与$p$ 互素时，有：$a^{p-1}\equiv1({\bmod{\ p}})$。  
下面介绍RSA 算法的基本原理和具体计算过程。RSA 算法理论基础是同余算术以及欧拉定理和费马小定理，其安全性依赖于大整数素因子分解的困难性，即已知整数$n$ 是两个大素数$p$ 和$q$ 的乘积，则难以在可接受的时间范围内通过$n$ 的素因子分解方法获得$p$ 和$q$ 的取值。RSA 算法的密钥生成、加密、解密的具体过程如下：  
1） 密钥的生成  
首先生成两个互不相同的大素数$p$ 和$q$，并令$n=p\cdot q$。其中$p$ 和$q$ 是属于解密信息，不可对外公开，整数$n$ 属于加密信息，需要对外公开。  
然后，令$\varphi(n)=(p-1)(q-1)$，并任意选择一个与$\varphi(n)$互素的正整数$e$，满足：  
$2\leq e\leq\varphi(n)$  
其中$\varphi(n)$不可对外公开，$e$ 为加密密钥，需要对外公开。  
由于$p$ 和$q$ 都是素数，故小于$p$ 且与$p$ 互素的非负整数的个数为$(p-1)$个，小于$q$ 且与$q$ 互素的非负整数的个数为$(q-1)$个。注意到$n=p\cdot q$，由计数的乘法原理及素数的性质可知，小于$\cdot n$且与$n$互素的非负整数的个数为$(p-1)$ $(q-1)$个，因此，$\varphi(n)=(p-1)(q-$1)其实就是欧拉函数。  
由于$e$ 的模$\varphi(n)$互素，因此$e$ 的模$\varphi(n)$同余逆$d$存在且唯一。算出$e$ 的模$\varphi(n)$同余逆$d$，使其满足：  
$$
e d\equiv1({\bmod{\ }}\varphi(n))\tag{2-17}
$$  
整数$d$ 属于解密密钥，不可对外公开。  
由此得到RSA 加密算法中作为公钥的加密密钥$e$，作为私钥的解密密钥$d$。  
2） 加密过程  
在RSA 加密算法中，要将明文信息转化成若干组整数序列。为此，首先将每个字母翻译成相应的整数，例如可以使用前述的凯撒加密算法完成这项工作。然后，将这些由明文字母对应的整数合并成若干组，每个组分别形成一个大整数，代表一个字母段。  
RSA 加密过程其实就是每个表示明文字母段的大整数$M$逐个转化为表示密文字母段的大整数$C$，具体转化公式如下：  
$$
C=M^{e}{\pmod{n}}\tag{2-18}
$$  
在转化过程中总是假定$M<n$。如果$M\geq n$，则需要对表示明文的所有整数重新进行分组以确保每个字母段对应的大整数小于$n$。  
3） 解密过程  
由于$d$ 是$e$ 的模$\varphi(n)$逆，即是$e$ 的模$(p-1)(q-1)$逆，故有：  
$$
e d\equiv1(\bmod(p-1)(q-1))\tag{2-19}
$$  
也就是说，$_{e d}$除以$(p-1)(q-1)$的余数为1，故存在整数$k$，使得：  
$$
e d={\begin{array}{l}{(p-1)(q-1)k+1}\end{array}}
$$  
故有：  
$$
C^{d}\equiv(M^{e})^{d}\equiv M^{e d}\equiv M^{(p-1)(q-1)k+1}\,({\mathrm{mod}}\,\,n)
$$  
假定$M$与$p$ 和$q$ 均为互素，则根据费马小定理有：  
$$
M^{p-1}\equiv1(\mathrm{\;mod}\;\left(p\right))\mathcal{X}M^{p-1}\equiv1(\mathrm{\;mod}\;\,q)
$$  
从而有：  
$$
\begin{array}{r}{C^{d}\equiv M^{(p-1)(q-1)k+1}\equiv\!\!M\!\cdot\!(M^{p-1})^{k(q-1)}\!\!\equiv\!\!M\!\cdot\!1\!\equiv\!\!M\,(\mathrm{mod}\,p)}\\ {C^{d}\equiv M^{(p-1)(q-1)k+1}\equiv\!\!M\!\cdot\!(M^{q-1})^{k(p-1)}\!\!\equiv\!\!M\!\cdot\!1\!\equiv\!\!M\,(\mathrm{mod}\,q)}\end{array}
$$  
由于$p$ 与$q$ 互素，则根据中国余数定理，有：  
$$
C^{d}\equiv M\,({\sf m o d}\,\,\,p\cdot q)\mathbb{\bar{X}}C^{d}\equiv M\,({\sf m o d}\,\,\,n)
$$  
由于$M<n$，故必有：$M=C^{d}\;({\mathsf{m o d}}\;\,n)$  
因此，若已知解密密钥$d$，就可使用公式$M=C^{d}\,({\sf m o d}\,n),$对密文$C$ 进行解密。  
在RSA 加密和解密算法中，如果$p,\ q$ 被信息窃取者获得，则可算出$(p-1)(q-1).$。由于$e$ 是公开密钥，且$d$是$e$ 关于关于模$(p-1)(q-1)$的逆，则不难求出$d$，如此RSA 系统便被完全攻破，信息窃取者就会很容易获得加密的信息。  
RSA 算法中的素数都是十进制整数，怎样才能选择好的$p$ 和$q$，这是$R S A$ 加密算法最关键的问题。针对素数$p$ 和$q$ 的选择，1978 年Rivest 等人在关于RSA 公开密钥的论文中，建议对素数$p$ 和$q$ 的选择应当满足：  
1）$p$ 和$q$ 要足够长，在长度上应相差几位，且二者之差与$p$ 和$q$ 位数相近；  
2）$p{-}1$ 和$q{-}1$ 的最大公约数$\operatorname*{gcd}(p -1\,,\,\,\,q-\!\!1)$要尽量小；  
3）$p{-}1$ 和$q{-}1$ 均应至少含有一个大的素数因子。  
并把满足这些条件的素数称为安全素数。  
从实用的观点看，如果加密后的信息能够保证在足够长的时间内不能被破解，则认为这个加密方法是安全的。相对于RSA 加密算法而言，如果整数$n$ 不是足够大，例如只有10 位，那么按照计算机目前的计算能力，几乎可以立刻求出其所有素因子实现对RSA 加密算法的破解。如果计算机的计算能力得到进一步的提高，则或许能够破解200 位的整数$n$。但是，如果使用200 素数$p$ 和200 位素数$q$ 构成400 位整数$n$，则计算机无法破解由此设计的RSA加密算法。因此，就目前以及今后一段时间而言，RSA 加密算法具有较好的安全性。",RSA算法的理论基础是同余算术
算法,基础与延伸,算法设计,,在前面整数理论中有不少关于整数的算法，例如求最大公因数的辗转相除算法、素数查找算法、 凯撒整数加密算法、 RSA  整数加密算法等等。 所谓算法， 简单地说就是算术之法， 也就是说通过运算的方式按照机械的步骤逐步实现对问题的求解。算法的这种基于构造性和机械性的运算体系非常契合计算机的运算特点和需求。因此，随着计算机的诞生和兴起，算法设计理论与技术迅速得到广泛重视和深入研究。目前，除了整数理论之外，在离散数学的其它内容中很多也都是通过一些非常精彩算法形式为计算机提供服务。为更好地学习离散数学及其应用知识，本节简要介绍算法设计的基本知识。,算法是算法设计的基础，算法设计是对算法的理论和技术进行深入研究与应用的延伸
算法,表示方法,伪代码,,"计算机是处理数据并将数据转化为有用信息的电子设备。任何计算机都由程序指令控制，程序指令规定计算机的用途，并告诉计算机需要完成的工作。因此，要使计算机工作就需要编写计算机程序，告诉计算机如何按照步骤执行程序，以实现最终目标。值得注意的是：根据计算机的特点，在告诉计算机需要它完成什么任务的同时，还需要进一步确定或选择让它怎样去完成，这正是计算机算法的由来。  
算法一词出自《周髀算经》，即算术之法。目前，关于算法的概念有很多种不同的定义，至今没有一种得到大家的公认，但可从这些不同定义中找到一些基本的共识。为求同存异，现从广义和狭义这两个不同的角度来诠释与理解算法的概念。  
【定义2.17】从广义上讲，算法是指通过运算的方式按照某种机械的步骤逐步实现对问题的求解，从这个角度看，现实生活中的很多工作流程都可以看成是算法，例如烧菜的菜谱、理发的流程等，都可以叫算法。从狭义上讲，算法是一个由已知推求未知的过程，对于符合一定规范的输入，它能够在有限的时间内获得所需的输出。在计算机专业领域，主要是从狭义的角度来理解算法。  
本书的算法设计，主要是从计算机专业角度来理解算法。在计算机专业领域，对算法的理解不仅是狭义的，而且对算法概念诠释更加明确具体，即：算法是指用于计算机解决问题的清晰有穷指令序列，且满足以下五条基本性质：  
1) 有穷性：算法中每条指令的执行次数和时间均有限。执行次数或执行时间无穷的算法，对实际生产生活几乎没有意义，而且还会造成资源浪费。  
2) 确定性：对算法的描述必须无歧义，以保证算法执行结果是确定的，且符合要求和期望。如果算法对于同样的输入，在相同环境下产生不确定的结果，则是不能接受的。  
3) 输入：一个算法有0 个或多个输入，以确定运算对象的初始情况。所谓0 个输入是  
指算法本身给定了初始条件。  
4) 输出：一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的。  
5) 可行性：算法中有待实现的运算都是基本运算，算法原则上要能够精确地运行，且人们用笔和纸做有限次运算后就可以完成。  
从计算机专业角度来看，一个完整的算法应该具备如下三个基本要素：  
1) 基本运算和操作  
算法的实现形式有多种，但是这些实现形式都具有相同的基本运算和操作。这些基本运算和操作有以下四类：  
算术运算：加减乘除等运算；关系运算：大于、小于、等于、不等于等运算；逻辑运算：或、与、非等运算；数据操作：输入、输出、赋值等运算。  
2) 控制结构  
一个算法的功能结构不仅取决于所选用的操作，而且还与各操作之间的执行顺序紧密相关。算法的控制结构确定了算法的基本框架，决定着各个操作的执行顺序。算法控制结构有三种，即顺序结构、选择结构和循环结构。  
3) 数据结构  
在计算机领域，算法的操作对象是数据。为了方便快速的存取，数据一般以一些特定的结构进行存储，另一方面，具体实际问题及其数学模型的结构特点决定了数据之间总是存在着一些特定的逻辑关系或逻辑结构。这些存储结构和逻辑结构统称为数据结构。  
一个算法可以采用多种不同的形式进行表示，常用的表示方法有：自然语言、流程图、伪代码等。本书后面各章节的算法将主要采用伪代码进行描述，以利于读者将理论与实际相结合，通过自己亲自动手描述和实现算法，加深对算法的理解。  
伪代码不是真正编程语言，而是一种算法描述语言，使用介于自然语言和程序设计语言之间的文字符号来描述算法。使用伪代码描述算法，能够使被描述的算法可以容易地以任何一种编程语言实现。伪代码可以综合使用多种编程语言中的语法、保留字，甚至会用到自然语言。 因此，伪代码结构清晰，简单且易于修改，可读性较好，并且类似自然语言。",伪代码是算法的一种表示方法，用于描述算法的结构和步骤，便于理解和实现。
算法效率,描述,函数增长的阶,,"从实际应用考虑，如果一个算法的运行时间过久，比如需要长达数年的时间，那么该算法就不适合用来解决问题。同样，一个算法如果需要占用很大的内存开销，导致系统无法为其它程序提供必须的内存资源，那么这也是不能够接受的。因此，对于设计出来的算法，需要对其利用时间和内存空间的效率进行分析，这就是算法的效率分析。无论是时间效率还是空间效率上看，算法的效率都是问题规模的某个函数，并且函数值随着问题规模的增长而增长。如果函数值随问题规模的增长而增长得很快，则说明算法效率很低，反之，如果函数值随问题规模的增长而增长得很慢，则说明算法效率很高。  
因此，为了更好地分析算法的效率，需要一些合适的方法来描述或度量函数值随自变量增长而增长的速度，如果不能精确地算出函数增长的速度，那么至少也要针对函数增长的不同速度划分出若干性质不同的等级，这就是函数增长的阶。当输入规模足够大时，精确表示的运行时间函数中的常系数和低阶项会被输入规模所掩盖。此时，只需要考虑高阶项即可。比如若复杂度为多项式$x^{2+}\!x$，$x$的复杂度会被$x^{2}$的复杂所吸收，因此只需考虑最高阶。  
事实上，在分析和度量算法效率的时候，重点考虑的是当问题规模充分大时的函数值增长的情况。因此，分析和度量算法效率时，一般都使用渐近效率的概念，即从极限的角度考虑运行时间如何随输入规模的增长而增长。为了更加准确地阐释和度量算法复杂度随问题规模增长而增长的速度，计算机科学家在算法领域引入了一些函数增长符号，其中时间复杂度常用大𝑂符号表述，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。使用这种方式时，时间复杂度可被称为是渐近的，它主要考察当输入值充分大时的情况。  
对于绝大多数算法来说，其复杂度的增长速度还可以使用基本或常用函数增长类型通过示例性的方法来描述或表示，如常数级、对数级、多项式级、指数级、阶乘级增长速度，等等。这些常用函数的增长速度非常直观，以它们增长速度为标准对算法的计算复杂度进行度量，会使得算法复杂度分析变得易于理解。因此，掌握这些常用函数的基本增长类型对算法设计具有非常重要的指导意义，下面对其做简要介绍：  
（1）$\mathrm{O}(1)$：复杂度为常数级，例如从一个数据集中取出第一个元素；  
（2）$\mathrm{O}(\lg n)$：该类型常见于将一个数据集分成两半，然后将其中每一半再分成两半，以此类推。例如对有序数组进行二分查找，其时间复杂度就是$\mathrm{O}(\lg n)$；  
（3）$\mathrm{O}(n)$：该类型常见于数据集中的遍历，例如在线性结构中顺序查找某个元素的算法，其时间复杂度就是$\mathrm{O}(n)$；  
（4）$\mathrm{O}(n\lg n)$：该类型与前面所述的$\mathbf O(1g\ n)$有点类似，常见于将一个数据集分成两半，然后将每一半再分成两半，并且对每一半数据进行遍历，以此类推，例如归并排序时间复杂度就是$\mathrm{O}(n\,1\mathrm{g}\,n)$；  
（5）${\mathrm{O}}(n^{2})$：常见于两重嵌套循环的算法之中，也就是说在遍历一个数据集中的每一个元素的时候同时遍历另一个数量级相同的数据集，基本排序算法（如冒泡排序、直接插入排序、直接选择排序等）的时间复杂度是${\mathrm{O}}(n^{2})$；  
（6）${\mathrm{O}}(n^{3})$：该类型常见于三重嵌套循环的算法之中，在线性代数中，两个$n$阶方阵相乘的时间复杂度就是${\mathrm{O}}(n^{3})$，著名求解最短路径Floyd 算法的时间复杂度也是${\mathrm{O}}(n^{3})$；  
（7）$\mathrm{O}(2^{n})$：为一个数据集生成所有的子集，这种数量级的算法可以说是很低效的，在规模较大的时候是不可行的；  
（8）$\mathrm{O}(n!)$：对具有$n$ 个元素的集合进行全排列时就是该类型的典型例子，这种数量级的算法基本上是不可行的。",函数增长的阶用于描述算法效率随问题规模增长的速度
算法效率,度量,渐近效率,,"从实际应用考虑，如果一个算法的运行时间过久，比如需要长达数年的时间，那么该算法就不适合用来解决问题。同样，一个算法如果需要占用很大的内存开销，导致系统无法为其它程序提供必须的内存资源，那么这也是不能够接受的。因此，对于设计出来的算法，需要对其利用时间和内存空间的效率进行分析，这就是算法的效率分析。无论是时间效率还是空间效率上看，算法的效率都是问题规模的某个函数，并且函数值随着问题规模的增长而增长。如果函数值随问题规模的增长而增长得很快，则说明算法效率很低，反之，如果函数值随问题规模的增长而增长得很慢，则说明算法效率很高。  
因此，为了更好地分析算法的效率，需要一些合适的方法来描述或度量函数值随自变量增长而增长的速度，如果不能精确地算出函数增长的速度，那么至少也要针对函数增长的不同速度划分出若干性质不同的等级，这就是函数增长的阶。当输入规模足够大时，精确表示的运行时间函数中的常系数和低阶项会被输入规模所掩盖。此时，只需要考虑高阶项即可。比如若复杂度为多项式$x^{2+}\!x$，$x$的复杂度会被$x^{2}$的复杂所吸收，因此只需考虑最高阶。  
事实上，在分析和度量算法效率的时候，重点考虑的是当问题规模充分大时的函数值增长的情况。因此，分析和度量算法效率时，一般都使用渐近效率的概念，即从极限的角度考虑运行时间如何随输入规模的增长而增长。为了更加准确地阐释和度量算法复杂度随问题规模增长而增长的速度，计算机科学家在算法领域引入了一些函数增长符号，其中时间复杂度常用大𝑂符号表述，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。使用这种方式时，时间复杂度可被称为是渐近的，它主要考察当输入值充分大时的情况。  
对于绝大多数算法来说，其复杂度的增长速度还可以使用基本或常用函数增长类型通过示例性的方法来描述或表示，如常数级、对数级、多项式级、指数级、阶乘级增长速度，等等。这些常用函数的增长速度非常直观，以它们增长速度为标准对算法的计算复杂度进行度量，会使得算法复杂度分析变得易于理解。因此，掌握这些常用函数的基本增长类型对算法设计具有非常重要的指导意义，下面对其做简要介绍：  
（1）$\mathrm{O}(1)$：复杂度为常数级，例如从一个数据集中取出第一个元素；  
（2）$\mathrm{O}(\lg n)$：该类型常见于将一个数据集分成两半，然后将其中每一半再分成两半，以此类推。例如对有序数组进行二分查找，其时间复杂度就是$\mathrm{O}(\lg n)$；  
（3）$\mathrm{O}(n)$：该类型常见于数据集中的遍历，例如在线性结构中顺序查找某个元素的算法，其时间复杂度就是$\mathrm{O}(n)$；  
（4）$\mathrm{O}(n\lg n)$：该类型与前面所述的$\mathbf O(1g\ n)$有点类似，常见于将一个数据集分成两半，然后将每一半再分成两半，并且对每一半数据进行遍历，以此类推，例如归并排序时间复杂度就是$\mathrm{O}(n\,1\mathrm{g}\,n)$；  
（5）${\mathrm{O}}(n^{2})$：常见于两重嵌套循环的算法之中，也就是说在遍历一个数据集中的每一个元素的时候同时遍历另一个数量级相同的数据集，基本排序算法（如冒泡排序、直接插入排序、直接选择排序等）的时间复杂度是${\mathrm{O}}(n^{2})$；  
（6）${\mathrm{O}}(n^{3})$：该类型常见于三重嵌套循环的算法之中，在线性代数中，两个$n$阶方阵相乘的时间复杂度就是${\mathrm{O}}(n^{3})$，著名求解最短路径Floyd 算法的时间复杂度也是${\mathrm{O}}(n^{3})$；  
（7）$\mathrm{O}(2^{n})$：为一个数据集生成所有的子集，这种数量级的算法可以说是很低效的，在规模较大的时候是不可行的；  
（8）$\mathrm{O}(n!)$：对具有$n$ 个元素的集合进行全排列时就是该类型的典型例子，这种数量级的算法基本上是不可行的。",渐近效率用于从极限角度度量算法效率
算法效率,定量描述,时间复杂度,,"从实际应用考虑，如果一个算法的运行时间过久，比如需要长达数年的时间，那么该算法就不适合用来解决问题。同样，一个算法如果需要占用很大的内存开销，导致系统无法为其它程序提供必须的内存资源，那么这也是不能够接受的。因此，对于设计出来的算法，需要对其利用时间和内存空间的效率进行分析，这就是算法的效率分析。无论是时间效率还是空间效率上看，算法的效率都是问题规模的某个函数，并且函数值随着问题规模的增长而增长。如果函数值随问题规模的增长而增长得很快，则说明算法效率很低，反之，如果函数值随问题规模的增长而增长得很慢，则说明算法效率很高。  
因此，为了更好地分析算法的效率，需要一些合适的方法来描述或度量函数值随自变量增长而增长的速度，如果不能精确地算出函数增长的速度，那么至少也要针对函数增长的不同速度划分出若干性质不同的等级，这就是函数增长的阶。当输入规模足够大时，精确表示的运行时间函数中的常系数和低阶项会被输入规模所掩盖。此时，只需要考虑高阶项即可。比如若复杂度为多项式$x^{2+}\!x$，$x$的复杂度会被$x^{2}$的复杂所吸收，因此只需考虑最高阶。  
事实上，在分析和度量算法效率的时候，重点考虑的是当问题规模充分大时的函数值增长的情况。因此，分析和度量算法效率时，一般都使用渐近效率的概念，即从极限的角度考虑运行时间如何随输入规模的增长而增长。为了更加准确地阐释和度量算法复杂度随问题规模增长而增长的速度，计算机科学家在算法领域引入了一些函数增长符号，其中时间复杂度常用大𝑂符号表述，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。使用这种方式时，时间复杂度可被称为是渐近的，它主要考察当输入值充分大时的情况。  
对于绝大多数算法来说，其复杂度的增长速度还可以使用基本或常用函数增长类型通过示例性的方法来描述或表示，如常数级、对数级、多项式级、指数级、阶乘级增长速度，等等。这些常用函数的增长速度非常直观，以它们增长速度为标准对算法的计算复杂度进行度量，会使得算法复杂度分析变得易于理解。因此，掌握这些常用函数的基本增长类型对算法设计具有非常重要的指导意义，下面对其做简要介绍：  
（1）$\mathrm{O}(1)$：复杂度为常数级，例如从一个数据集中取出第一个元素；  
（2）$\mathrm{O}(\lg n)$：该类型常见于将一个数据集分成两半，然后将其中每一半再分成两半，以此类推。例如对有序数组进行二分查找，其时间复杂度就是$\mathrm{O}(\lg n)$；  
（3）$\mathrm{O}(n)$：该类型常见于数据集中的遍历，例如在线性结构中顺序查找某个元素的算法，其时间复杂度就是$\mathrm{O}(n)$；  
（4）$\mathrm{O}(n\lg n)$：该类型与前面所述的$\mathbf O(1g\ n)$有点类似，常见于将一个数据集分成两半，然后将每一半再分成两半，并且对每一半数据进行遍历，以此类推，例如归并排序时间复杂度就是$\mathrm{O}(n\,1\mathrm{g}\,n)$；  
（5）${\mathrm{O}}(n^{2})$：常见于两重嵌套循环的算法之中，也就是说在遍历一个数据集中的每一个元素的时候同时遍历另一个数量级相同的数据集，基本排序算法（如冒泡排序、直接插入排序、直接选择排序等）的时间复杂度是${\mathrm{O}}(n^{2})$；  
（6）${\mathrm{O}}(n^{3})$：该类型常见于三重嵌套循环的算法之中，在线性代数中，两个$n$阶方阵相乘的时间复杂度就是${\mathrm{O}}(n^{3})$，著名求解最短路径Floyd 算法的时间复杂度也是${\mathrm{O}}(n^{3})$；  
（7）$\mathrm{O}(2^{n})$：为一个数据集生成所有的子集，这种数量级的算法可以说是很低效的，在规模较大的时候是不可行的；  
（8）$\mathrm{O}(n!)$：对具有$n$ 个元素的集合进行全排列时就是该类型的典型例子，这种数量级的算法基本上是不可行的。",时间复杂度定量描述算法的运行时间，反映算法效率
时间复杂度,分类,基本增长类型,,"从实际应用考虑，如果一个算法的运行时间过久，比如需要长达数年的时间，那么该算法就不适合用来解决问题。同样，一个算法如果需要占用很大的内存开销，导致系统无法为其它程序提供必须的内存资源，那么这也是不能够接受的。因此，对于设计出来的算法，需要对其利用时间和内存空间的效率进行分析，这就是算法的效率分析。无论是时间效率还是空间效率上看，算法的效率都是问题规模的某个函数，并且函数值随着问题规模的增长而增长。如果函数值随问题规模的增长而增长得很快，则说明算法效率很低，反之，如果函数值随问题规模的增长而增长得很慢，则说明算法效率很高。  
因此，为了更好地分析算法的效率，需要一些合适的方法来描述或度量函数值随自变量增长而增长的速度，如果不能精确地算出函数增长的速度，那么至少也要针对函数增长的不同速度划分出若干性质不同的等级，这就是函数增长的阶。当输入规模足够大时，精确表示的运行时间函数中的常系数和低阶项会被输入规模所掩盖。此时，只需要考虑高阶项即可。比如若复杂度为多项式$x^{2+}\!x$，$x$的复杂度会被$x^{2}$的复杂所吸收，因此只需考虑最高阶。  
事实上，在分析和度量算法效率的时候，重点考虑的是当问题规模充分大时的函数值增长的情况。因此，分析和度量算法效率时，一般都使用渐近效率的概念，即从极限的角度考虑运行时间如何随输入规模的增长而增长。为了更加准确地阐释和度量算法复杂度随问题规模增长而增长的速度，计算机科学家在算法领域引入了一些函数增长符号，其中时间复杂度常用大𝑂符号表述，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。使用这种方式时，时间复杂度可被称为是渐近的，它主要考察当输入值充分大时的情况。  
对于绝大多数算法来说，其复杂度的增长速度还可以使用基本或常用函数增长类型通过示例性的方法来描述或表示，如常数级、对数级、多项式级、指数级、阶乘级增长速度，等等。这些常用函数的增长速度非常直观，以它们增长速度为标准对算法的计算复杂度进行度量，会使得算法复杂度分析变得易于理解。因此，掌握这些常用函数的基本增长类型对算法设计具有非常重要的指导意义，下面对其做简要介绍：  
（1）$\mathrm{O}(1)$：复杂度为常数级，例如从一个数据集中取出第一个元素；  
（2）$\mathrm{O}(\lg n)$：该类型常见于将一个数据集分成两半，然后将其中每一半再分成两半，以此类推。例如对有序数组进行二分查找，其时间复杂度就是$\mathrm{O}(\lg n)$；  
（3）$\mathrm{O}(n)$：该类型常见于数据集中的遍历，例如在线性结构中顺序查找某个元素的算法，其时间复杂度就是$\mathrm{O}(n)$；  
（4）$\mathrm{O}(n\lg n)$：该类型与前面所述的$\mathbf O(1g\ n)$有点类似，常见于将一个数据集分成两半，然后将每一半再分成两半，并且对每一半数据进行遍历，以此类推，例如归并排序时间复杂度就是$\mathrm{O}(n\,1\mathrm{g}\,n)$；  
（5）${\mathrm{O}}(n^{2})$：常见于两重嵌套循环的算法之中，也就是说在遍历一个数据集中的每一个元素的时候同时遍历另一个数量级相同的数据集，基本排序算法（如冒泡排序、直接插入排序、直接选择排序等）的时间复杂度是${\mathrm{O}}(n^{2})$；  
（6）${\mathrm{O}}(n^{3})$：该类型常见于三重嵌套循环的算法之中，在线性代数中，两个$n$阶方阵相乘的时间复杂度就是${\mathrm{O}}(n^{3})$，著名求解最短路径Floyd 算法的时间复杂度也是${\mathrm{O}}(n^{3})$；  
（7）$\mathrm{O}(2^{n})$：为一个数据集生成所有的子集，这种数量级的算法可以说是很低效的，在规模较大的时候是不可行的；  
（8）$\mathrm{O}(n!)$：对具有$n$ 个元素的集合进行全排列时就是该类型的典型例子，这种数量级的算法基本上是不可行的。",时间复杂度通过基本增长类型（如常数级、对数级等）进行分类描述
渐近效率,关联,时间复杂度,,"从实际应用考虑，如果一个算法的运行时间过久，比如需要长达数年的时间，那么该算法就不适合用来解决问题。同样，一个算法如果需要占用很大的内存开销，导致系统无法为其它程序提供必须的内存资源，那么这也是不能够接受的。因此，对于设计出来的算法，需要对其利用时间和内存空间的效率进行分析，这就是算法的效率分析。无论是时间效率还是空间效率上看，算法的效率都是问题规模的某个函数，并且函数值随着问题规模的增长而增长。如果函数值随问题规模的增长而增长得很快，则说明算法效率很低，反之，如果函数值随问题规模的增长而增长得很慢，则说明算法效率很高。  
因此，为了更好地分析算法的效率，需要一些合适的方法来描述或度量函数值随自变量增长而增长的速度，如果不能精确地算出函数增长的速度，那么至少也要针对函数增长的不同速度划分出若干性质不同的等级，这就是函数增长的阶。当输入规模足够大时，精确表示的运行时间函数中的常系数和低阶项会被输入规模所掩盖。此时，只需要考虑高阶项即可。比如若复杂度为多项式$x^{2+}\!x$，$x$的复杂度会被$x^{2}$的复杂所吸收，因此只需考虑最高阶。  
事实上，在分析和度量算法效率的时候，重点考虑的是当问题规模充分大时的函数值增长的情况。因此，分析和度量算法效率时，一般都使用渐近效率的概念，即从极限的角度考虑运行时间如何随输入规模的增长而增长。为了更加准确地阐释和度量算法复杂度随问题规模增长而增长的速度，计算机科学家在算法领域引入了一些函数增长符号，其中时间复杂度常用大𝑂符号表述，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。使用这种方式时，时间复杂度可被称为是渐近的，它主要考察当输入值充分大时的情况。  
对于绝大多数算法来说，其复杂度的增长速度还可以使用基本或常用函数增长类型通过示例性的方法来描述或表示，如常数级、对数级、多项式级、指数级、阶乘级增长速度，等等。这些常用函数的增长速度非常直观，以它们增长速度为标准对算法的计算复杂度进行度量，会使得算法复杂度分析变得易于理解。因此，掌握这些常用函数的基本增长类型对算法设计具有非常重要的指导意义，下面对其做简要介绍：  
（1）$\mathrm{O}(1)$：复杂度为常数级，例如从一个数据集中取出第一个元素；  
（2）$\mathrm{O}(\lg n)$：该类型常见于将一个数据集分成两半，然后将其中每一半再分成两半，以此类推。例如对有序数组进行二分查找，其时间复杂度就是$\mathrm{O}(\lg n)$；  
（3）$\mathrm{O}(n)$：该类型常见于数据集中的遍历，例如在线性结构中顺序查找某个元素的算法，其时间复杂度就是$\mathrm{O}(n)$；  
（4）$\mathrm{O}(n\lg n)$：该类型与前面所述的$\mathbf O(1g\ n)$有点类似，常见于将一个数据集分成两半，然后将每一半再分成两半，并且对每一半数据进行遍历，以此类推，例如归并排序时间复杂度就是$\mathrm{O}(n\,1\mathrm{g}\,n)$；  
（5）${\mathrm{O}}(n^{2})$：常见于两重嵌套循环的算法之中，也就是说在遍历一个数据集中的每一个元素的时候同时遍历另一个数量级相同的数据集，基本排序算法（如冒泡排序、直接插入排序、直接选择排序等）的时间复杂度是${\mathrm{O}}(n^{2})$；  
（6）${\mathrm{O}}(n^{3})$：该类型常见于三重嵌套循环的算法之中，在线性代数中，两个$n$阶方阵相乘的时间复杂度就是${\mathrm{O}}(n^{3})$，著名求解最短路径Floyd 算法的时间复杂度也是${\mathrm{O}}(n^{3})$；  
（7）$\mathrm{O}(2^{n})$：为一个数据集生成所有的子集，这种数量级的算法可以说是很低效的，在规模较大的时候是不可行的；  
（8）$\mathrm{O}(n!)$：对具有$n$ 个元素的集合进行全排列时就是该类型的典型例子，这种数量级的算法基本上是不可行的。",渐近效率与时间复杂度关联，共同描述算法在输入规模充分大时的效率
函数增长的阶,体现,基本增长类型,,"从实际应用考虑，如果一个算法的运行时间过久，比如需要长达数年的时间，那么该算法就不适合用来解决问题。同样，一个算法如果需要占用很大的内存开销，导致系统无法为其它程序提供必须的内存资源，那么这也是不能够接受的。因此，对于设计出来的算法，需要对其利用时间和内存空间的效率进行分析，这就是算法的效率分析。无论是时间效率还是空间效率上看，算法的效率都是问题规模的某个函数，并且函数值随着问题规模的增长而增长。如果函数值随问题规模的增长而增长得很快，则说明算法效率很低，反之，如果函数值随问题规模的增长而增长得很慢，则说明算法效率很高。  
因此，为了更好地分析算法的效率，需要一些合适的方法来描述或度量函数值随自变量增长而增长的速度，如果不能精确地算出函数增长的速度，那么至少也要针对函数增长的不同速度划分出若干性质不同的等级，这就是函数增长的阶。当输入规模足够大时，精确表示的运行时间函数中的常系数和低阶项会被输入规模所掩盖。此时，只需要考虑高阶项即可。比如若复杂度为多项式$x^{2+}\!x$，$x$的复杂度会被$x^{2}$的复杂所吸收，因此只需考虑最高阶。  
事实上，在分析和度量算法效率的时候，重点考虑的是当问题规模充分大时的函数值增长的情况。因此，分析和度量算法效率时，一般都使用渐近效率的概念，即从极限的角度考虑运行时间如何随输入规模的增长而增长。为了更加准确地阐释和度量算法复杂度随问题规模增长而增长的速度，计算机科学家在算法领域引入了一些函数增长符号，其中时间复杂度常用大𝑂符号表述，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。使用这种方式时，时间复杂度可被称为是渐近的，它主要考察当输入值充分大时的情况。  
对于绝大多数算法来说，其复杂度的增长速度还可以使用基本或常用函数增长类型通过示例性的方法来描述或表示，如常数级、对数级、多项式级、指数级、阶乘级增长速度，等等。这些常用函数的增长速度非常直观，以它们增长速度为标准对算法的计算复杂度进行度量，会使得算法复杂度分析变得易于理解。因此，掌握这些常用函数的基本增长类型对算法设计具有非常重要的指导意义，下面对其做简要介绍：  
（1）$\mathrm{O}(1)$：复杂度为常数级，例如从一个数据集中取出第一个元素；  
（2）$\mathrm{O}(\lg n)$：该类型常见于将一个数据集分成两半，然后将其中每一半再分成两半，以此类推。例如对有序数组进行二分查找，其时间复杂度就是$\mathrm{O}(\lg n)$；  
（3）$\mathrm{O}(n)$：该类型常见于数据集中的遍历，例如在线性结构中顺序查找某个元素的算法，其时间复杂度就是$\mathrm{O}(n)$；  
（4）$\mathrm{O}(n\lg n)$：该类型与前面所述的$\mathbf O(1g\ n)$有点类似，常见于将一个数据集分成两半，然后将每一半再分成两半，并且对每一半数据进行遍历，以此类推，例如归并排序时间复杂度就是$\mathrm{O}(n\,1\mathrm{g}\,n)$；  
（5）${\mathrm{O}}(n^{2})$：常见于两重嵌套循环的算法之中，也就是说在遍历一个数据集中的每一个元素的时候同时遍历另一个数量级相同的数据集，基本排序算法（如冒泡排序、直接插入排序、直接选择排序等）的时间复杂度是${\mathrm{O}}(n^{2})$；  
（6）${\mathrm{O}}(n^{3})$：该类型常见于三重嵌套循环的算法之中，在线性代数中，两个$n$阶方阵相乘的时间复杂度就是${\mathrm{O}}(n^{3})$，著名求解最短路径Floyd 算法的时间复杂度也是${\mathrm{O}}(n^{3})$；  
（7）$\mathrm{O}(2^{n})$：为一个数据集生成所有的子集，这种数量级的算法可以说是很低效的，在规模较大的时候是不可行的；  
（8）$\mathrm{O}(n!)$：对具有$n$ 个元素的集合进行全排列时就是该类型的典型例子，这种数量级的算法基本上是不可行的。",函数增长的阶通过基本增长类型体现其增长速度
算法设计策略,包含,分治策略,,计算机问题求解算法虽然千差万别，但都遵循一些基本的设计策略。这些策略蕴含着很多非常深刻而又普适的求解智慧。例如，分治策略把一个问题分解为若干规模较小的子问题，然后以递归的方式求解它们并通过合并它们的解来实现对原问题的求解，而回溯策略则认为对未知世界的探索是一个试错的过程，并给出具体的试错方案，这恰恰是对人类生活经验的一种抽象和总结。不断学习、领会和掌握这些智慧，就可逐步形成良好的算法思维，从而能够更加透彻地从本质上理解算法设计的精髓，为设计出高水平算法打下坚实的基础。本章主要结合具体应用实例介绍和分析算法设计的若干基本策略，包括蛮力与贪心策略、递归与分治策略、回溯与动态规划策略。,分治策略是算法设计策略的一种，通过分解问题并递归求解子问题来实现原问题的求解
算法设计策略,包含,回溯策略,,计算机问题求解算法虽然千差万别，但都遵循一些基本的设计策略。这些策略蕴含着很多非常深刻而又普适的求解智慧。例如，分治策略把一个问题分解为若干规模较小的子问题，然后以递归的方式求解它们并通过合并它们的解来实现对原问题的求解，而回溯策略则认为对未知世界的探索是一个试错的过程，并给出具体的试错方案，这恰恰是对人类生活经验的一种抽象和总结。不断学习、领会和掌握这些智慧，就可逐步形成良好的算法思维，从而能够更加透彻地从本质上理解算法设计的精髓，为设计出高水平算法打下坚实的基础。本章主要结合具体应用实例介绍和分析算法设计的若干基本策略，包括蛮力与贪心策略、递归与分治策略、回溯与动态规划策略。,回溯策略是算法设计策略的一种，通过试错过程探索未知世界并给出具体试错方案
算法设计策略,包含,蛮力与贪心策略,,计算机问题求解算法虽然千差万别，但都遵循一些基本的设计策略。这些策略蕴含着很多非常深刻而又普适的求解智慧。例如，分治策略把一个问题分解为若干规模较小的子问题，然后以递归的方式求解它们并通过合并它们的解来实现对原问题的求解，而回溯策略则认为对未知世界的探索是一个试错的过程，并给出具体的试错方案，这恰恰是对人类生活经验的一种抽象和总结。不断学习、领会和掌握这些智慧，就可逐步形成良好的算法思维，从而能够更加透彻地从本质上理解算法设计的精髓，为设计出高水平算法打下坚实的基础。本章主要结合具体应用实例介绍和分析算法设计的若干基本策略，包括蛮力与贪心策略、递归与分治策略、回溯与动态规划策略。,蛮力与贪心策略是算法设计策略的一种，用于介绍和分析算法设计的基本策略
算法设计策略,包含,递归与分治策略,,计算机问题求解算法虽然千差万别，但都遵循一些基本的设计策略。这些策略蕴含着很多非常深刻而又普适的求解智慧。例如，分治策略把一个问题分解为若干规模较小的子问题，然后以递归的方式求解它们并通过合并它们的解来实现对原问题的求解，而回溯策略则认为对未知世界的探索是一个试错的过程，并给出具体的试错方案，这恰恰是对人类生活经验的一种抽象和总结。不断学习、领会和掌握这些智慧，就可逐步形成良好的算法思维，从而能够更加透彻地从本质上理解算法设计的精髓，为设计出高水平算法打下坚实的基础。本章主要结合具体应用实例介绍和分析算法设计的若干基本策略，包括蛮力与贪心策略、递归与分治策略、回溯与动态规划策略。,递归与分治策略是算法设计策略的一种，结合具体应用实例介绍和分析算法设计的基本策略
算法设计策略,包含,回溯与动态规划策略,,计算机问题求解算法虽然千差万别，但都遵循一些基本的设计策略。这些策略蕴含着很多非常深刻而又普适的求解智慧。例如，分治策略把一个问题分解为若干规模较小的子问题，然后以递归的方式求解它们并通过合并它们的解来实现对原问题的求解，而回溯策略则认为对未知世界的探索是一个试错的过程，并给出具体的试错方案，这恰恰是对人类生活经验的一种抽象和总结。不断学习、领会和掌握这些智慧，就可逐步形成良好的算法思维，从而能够更加透彻地从本质上理解算法设计的精髓，为设计出高水平算法打下坚实的基础。本章主要结合具体应用实例介绍和分析算法设计的若干基本策略，包括蛮力与贪心策略、递归与分治策略、回溯与动态规划策略。,回溯与动态规划策略是算法设计策略的一种，结合具体应用实例介绍和分析算法设计的基本策略
蛮力法,共同特点,贪心法,,计算机处理的对象及其结构都是离散的，对这种离散对象与结构的求解，显然有一种最直观、最基本的方法，就是枚举出所有可能状态，然后在这些状态中找到所需的解。这就是蛮力法。该方法最大优点就是普适性高，几乎可以解决任何问题，最大的缺点就是计算量太大，很多情况下不可行。此外，还有一种非常直观的、非常基本的方法，那就是贪心法。该方法在每一步都获得当前状态下最好的结果，通过使用局部最优解步步逼近的方式获得问题全局最优解。贪心法的优点是思想直观，易于理解，缺点是算法没有总体控制机制，缺少远见和大局观，有时难以保证算法的正确性。蛮力法和贪心法的共同特点是算法思想简单，易于理解，但都存在比较明显的局限性，在很多情况下难以直接使用。,算法思想简单，易于理解，但存在明显的局限性
蛮力策略,同义,穷举法,,"【定义2.18】蛮力策略或蛮力法，亦称为穷举法或暴力法，就是用最原始、最暴力的方式解决问题，基本思路是以扫描的模式依次处理问题域所有元素，并将所有可能的结果枚举出来，进而实现对问题的求解。  
从算法思想的角度来看，蛮力法直接基于问题的描述和所涉及概念的定义来解决问题，即用最直接的方式解决问题。例如：求$.1+{\begin{array}{l}{2+3+\cdots+n}\end{array}}$的结果。蛮力法就是逐次将$n$个元素一个一个累加起来得到结果。  
蛮力法的设计一般没有技巧性，因此巧妙和高效的算法很少来自蛮力法。但是，蛮力法在算法设计策略中仍然占据着不可替代的重要地位，原因在于：  
（1）在可枚举的离散结构中，蛮力法是一种几乎可以解决任何问题的一般性方法。  
（2）若要解决的问题规模不大，且使用蛮力法的效率可以接受，就可直接使用蛮力法。此时，设计一个更高效算法所花费的代价很可能是不值得的。  
（3）可将蛮力法作为一个基准，来衡量同样问题更高效的算法，为研究提供服务。蛮力法的求解一般由如下两个基本步骤组成：  
1）找到枚举范围：分析问题，找到所涉及的每一种情况。  
2）找到约束条件：解析约束条件，并用逻辑表达式表示。",蛮力策略亦称为穷举法
蛮力策略,同义,暴力法,,"【定义2.18】蛮力策略或蛮力法，亦称为穷举法或暴力法，就是用最原始、最暴力的方式解决问题，基本思路是以扫描的模式依次处理问题域所有元素，并将所有可能的结果枚举出来，进而实现对问题的求解。  
从算法思想的角度来看，蛮力法直接基于问题的描述和所涉及概念的定义来解决问题，即用最直接的方式解决问题。例如：求$.1+{\begin{array}{l}{2+3+\cdots+n}\end{array}}$的结果。蛮力法就是逐次将$n$个元素一个一个累加起来得到结果。  
蛮力法的设计一般没有技巧性，因此巧妙和高效的算法很少来自蛮力法。但是，蛮力法在算法设计策略中仍然占据着不可替代的重要地位，原因在于：  
（1）在可枚举的离散结构中，蛮力法是一种几乎可以解决任何问题的一般性方法。  
（2）若要解决的问题规模不大，且使用蛮力法的效率可以接受，就可直接使用蛮力法。此时，设计一个更高效算法所花费的代价很可能是不值得的。  
（3）可将蛮力法作为一个基准，来衡量同样问题更高效的算法，为研究提供服务。蛮力法的求解一般由如下两个基本步骤组成：  
1）找到枚举范围：分析问题，找到所涉及的每一种情况。  
2）找到约束条件：解析约束条件，并用逻辑表达式表示。",蛮力策略亦称为暴力法
蛮力策略,属于,算法设计策略,,"【定义2.18】蛮力策略或蛮力法，亦称为穷举法或暴力法，就是用最原始、最暴力的方式解决问题，基本思路是以扫描的模式依次处理问题域所有元素，并将所有可能的结果枚举出来，进而实现对问题的求解。  
从算法思想的角度来看，蛮力法直接基于问题的描述和所涉及概念的定义来解决问题，即用最直接的方式解决问题。例如：求$.1+{\begin{array}{l}{2+3+\cdots+n}\end{array}}$的结果。蛮力法就是逐次将$n$个元素一个一个累加起来得到结果。  
蛮力法的设计一般没有技巧性，因此巧妙和高效的算法很少来自蛮力法。但是，蛮力法在算法设计策略中仍然占据着不可替代的重要地位，原因在于：  
（1）在可枚举的离散结构中，蛮力法是一种几乎可以解决任何问题的一般性方法。  
（2）若要解决的问题规模不大，且使用蛮力法的效率可以接受，就可直接使用蛮力法。此时，设计一个更高效算法所花费的代价很可能是不值得的。  
（3）可将蛮力法作为一个基准，来衡量同样问题更高效的算法，为研究提供服务。蛮力法的求解一般由如下两个基本步骤组成：  
1）找到枚举范围：分析问题，找到所涉及的每一种情况。  
2）找到约束条件：解析约束条件，并用逻辑表达式表示。",蛮力策略在算法设计策略中占据重要地位
蛮力策略,适用,可枚举的离散结构,,"【定义2.18】蛮力策略或蛮力法，亦称为穷举法或暴力法，就是用最原始、最暴力的方式解决问题，基本思路是以扫描的模式依次处理问题域所有元素，并将所有可能的结果枚举出来，进而实现对问题的求解。  
从算法思想的角度来看，蛮力法直接基于问题的描述和所涉及概念的定义来解决问题，即用最直接的方式解决问题。例如：求$.1+{\begin{array}{l}{2+3+\cdots+n}\end{array}}$的结果。蛮力法就是逐次将$n$个元素一个一个累加起来得到结果。  
蛮力法的设计一般没有技巧性，因此巧妙和高效的算法很少来自蛮力法。但是，蛮力法在算法设计策略中仍然占据着不可替代的重要地位，原因在于：  
（1）在可枚举的离散结构中，蛮力法是一种几乎可以解决任何问题的一般性方法。  
（2）若要解决的问题规模不大，且使用蛮力法的效率可以接受，就可直接使用蛮力法。此时，设计一个更高效算法所花费的代价很可能是不值得的。  
（3）可将蛮力法作为一个基准，来衡量同样问题更高效的算法，为研究提供服务。蛮力法的求解一般由如下两个基本步骤组成：  
1）找到枚举范围：分析问题，找到所涉及的每一种情况。  
2）找到约束条件：解析约束条件，并用逻辑表达式表示。",蛮力策略适用于可枚举的离散结构
蛮力策略,适用,问题规模不大,,"【定义2.18】蛮力策略或蛮力法，亦称为穷举法或暴力法，就是用最原始、最暴力的方式解决问题，基本思路是以扫描的模式依次处理问题域所有元素，并将所有可能的结果枚举出来，进而实现对问题的求解。  
从算法思想的角度来看，蛮力法直接基于问题的描述和所涉及概念的定义来解决问题，即用最直接的方式解决问题。例如：求$.1+{\begin{array}{l}{2+3+\cdots+n}\end{array}}$的结果。蛮力法就是逐次将$n$个元素一个一个累加起来得到结果。  
蛮力法的设计一般没有技巧性，因此巧妙和高效的算法很少来自蛮力法。但是，蛮力法在算法设计策略中仍然占据着不可替代的重要地位，原因在于：  
（1）在可枚举的离散结构中，蛮力法是一种几乎可以解决任何问题的一般性方法。  
（2）若要解决的问题规模不大，且使用蛮力法的效率可以接受，就可直接使用蛮力法。此时，设计一个更高效算法所花费的代价很可能是不值得的。  
（3）可将蛮力法作为一个基准，来衡量同样问题更高效的算法，为研究提供服务。蛮力法的求解一般由如下两个基本步骤组成：  
1）找到枚举范围：分析问题，找到所涉及的每一种情况。  
2）找到约束条件：解析约束条件，并用逻辑表达式表示。",蛮力策略适用于问题规模不大且效率可接受的情况
蛮力策略,基准,高效算法,,"【定义2.18】蛮力策略或蛮力法，亦称为穷举法或暴力法，就是用最原始、最暴力的方式解决问题，基本思路是以扫描的模式依次处理问题域所有元素，并将所有可能的结果枚举出来，进而实现对问题的求解。  
从算法思想的角度来看，蛮力法直接基于问题的描述和所涉及概念的定义来解决问题，即用最直接的方式解决问题。例如：求$.1+{\begin{array}{l}{2+3+\cdots+n}\end{array}}$的结果。蛮力法就是逐次将$n$个元素一个一个累加起来得到结果。  
蛮力法的设计一般没有技巧性，因此巧妙和高效的算法很少来自蛮力法。但是，蛮力法在算法设计策略中仍然占据着不可替代的重要地位，原因在于：  
（1）在可枚举的离散结构中，蛮力法是一种几乎可以解决任何问题的一般性方法。  
（2）若要解决的问题规模不大，且使用蛮力法的效率可以接受，就可直接使用蛮力法。此时，设计一个更高效算法所花费的代价很可能是不值得的。  
（3）可将蛮力法作为一个基准，来衡量同样问题更高效的算法，为研究提供服务。蛮力法的求解一般由如下两个基本步骤组成：  
1）找到枚举范围：分析问题，找到所涉及的每一种情况。  
2）找到约束条件：解析约束条件，并用逻辑表达式表示。",蛮力策略可作为衡量高效算法的基准
蛮力策略,步骤,枚举范围,,"【定义2.18】蛮力策略或蛮力法，亦称为穷举法或暴力法，就是用最原始、最暴力的方式解决问题，基本思路是以扫描的模式依次处理问题域所有元素，并将所有可能的结果枚举出来，进而实现对问题的求解。  
从算法思想的角度来看，蛮力法直接基于问题的描述和所涉及概念的定义来解决问题，即用最直接的方式解决问题。例如：求$.1+{\begin{array}{l}{2+3+\cdots+n}\end{array}}$的结果。蛮力法就是逐次将$n$个元素一个一个累加起来得到结果。  
蛮力法的设计一般没有技巧性，因此巧妙和高效的算法很少来自蛮力法。但是，蛮力法在算法设计策略中仍然占据着不可替代的重要地位，原因在于：  
（1）在可枚举的离散结构中，蛮力法是一种几乎可以解决任何问题的一般性方法。  
（2）若要解决的问题规模不大，且使用蛮力法的效率可以接受，就可直接使用蛮力法。此时，设计一个更高效算法所花费的代价很可能是不值得的。  
（3）可将蛮力法作为一个基准，来衡量同样问题更高效的算法，为研究提供服务。蛮力法的求解一般由如下两个基本步骤组成：  
1）找到枚举范围：分析问题，找到所涉及的每一种情况。  
2）找到约束条件：解析约束条件，并用逻辑表达式表示。",蛮力策略的求解步骤包括找到枚举范围
蛮力策略,步骤,约束条件,,"【定义2.18】蛮力策略或蛮力法，亦称为穷举法或暴力法，就是用最原始、最暴力的方式解决问题，基本思路是以扫描的模式依次处理问题域所有元素，并将所有可能的结果枚举出来，进而实现对问题的求解。  
从算法思想的角度来看，蛮力法直接基于问题的描述和所涉及概念的定义来解决问题，即用最直接的方式解决问题。例如：求$.1+{\begin{array}{l}{2+3+\cdots+n}\end{array}}$的结果。蛮力法就是逐次将$n$个元素一个一个累加起来得到结果。  
蛮力法的设计一般没有技巧性，因此巧妙和高效的算法很少来自蛮力法。但是，蛮力法在算法设计策略中仍然占据着不可替代的重要地位，原因在于：  
（1）在可枚举的离散结构中，蛮力法是一种几乎可以解决任何问题的一般性方法。  
（2）若要解决的问题规模不大，且使用蛮力法的效率可以接受，就可直接使用蛮力法。此时，设计一个更高效算法所花费的代价很可能是不值得的。  
（3）可将蛮力法作为一个基准，来衡量同样问题更高效的算法，为研究提供服务。蛮力法的求解一般由如下两个基本步骤组成：  
1）找到枚举范围：分析问题，找到所涉及的每一种情况。  
2）找到约束条件：解析约束条件，并用逻辑表达式表示。",蛮力策略的求解步骤包括找到约束条件
贪心算法,构造,局部最优解,,"【定义2.19】贪心算法，就是从问题的某个初始解出发，通过在每一步构造当前状态下局部最优解的方式（即在每个局部阶段都贪心地做出当前状态下一个最优决策），一步一步地向全局最优解逼近，最终获取全局最优解。  
从算法设计的角度看，贪心算法具有思维复杂度低、代码量小、运行效率高、空间复杂度低等优点。但是，其局限性也是很明显的：贪心算法合理性的前提是每一步的局部最优解一定能够逼近到全局最优解，有时很难保证能够做到这一点，这称为贪心算法的非完美性。贪心算法从本质上缺少大局观思想，会给我们直接使用贪心算法带来很大的困难，因为有时很难找到一个简单可行并具有完美性的贪心思路，即使找到一个看上去很完美的贪心思路，也需要严格地证明其正确性。不过值得庆幸的是，虽然并不是所有问题都可通过贪心算法获得整体最优解，但是由此至少可以得到一个近似最优解。",贪心算法通过每一步构造当前状态下的局部最优解来逼近全局最优解
贪心算法,逼近,全局最优解,,"【定义2.19】贪心算法，就是从问题的某个初始解出发，通过在每一步构造当前状态下局部最优解的方式（即在每个局部阶段都贪心地做出当前状态下一个最优决策），一步一步地向全局最优解逼近，最终获取全局最优解。  
从算法设计的角度看，贪心算法具有思维复杂度低、代码量小、运行效率高、空间复杂度低等优点。但是，其局限性也是很明显的：贪心算法合理性的前提是每一步的局部最优解一定能够逼近到全局最优解，有时很难保证能够做到这一点，这称为贪心算法的非完美性。贪心算法从本质上缺少大局观思想，会给我们直接使用贪心算法带来很大的困难，因为有时很难找到一个简单可行并具有完美性的贪心思路，即使找到一个看上去很完美的贪心思路，也需要严格地证明其正确性。不过值得庆幸的是，虽然并不是所有问题都可通过贪心算法获得整体最优解，但是由此至少可以得到一个近似最优解。",贪心算法通过局部最优解一步一步逼近全局最优解
贪心算法,具有,非完美性,,"【定义2.19】贪心算法，就是从问题的某个初始解出发，通过在每一步构造当前状态下局部最优解的方式（即在每个局部阶段都贪心地做出当前状态下一个最优决策），一步一步地向全局最优解逼近，最终获取全局最优解。  
从算法设计的角度看，贪心算法具有思维复杂度低、代码量小、运行效率高、空间复杂度低等优点。但是，其局限性也是很明显的：贪心算法合理性的前提是每一步的局部最优解一定能够逼近到全局最优解，有时很难保证能够做到这一点，这称为贪心算法的非完美性。贪心算法从本质上缺少大局观思想，会给我们直接使用贪心算法带来很大的困难，因为有时很难找到一个简单可行并具有完美性的贪心思路，即使找到一个看上去很完美的贪心思路，也需要严格地证明其正确性。不过值得庆幸的是，虽然并不是所有问题都可通过贪心算法获得整体最优解，但是由此至少可以得到一个近似最优解。",贪心算法具有非完美性，即局部最优解不一定能保证逼近到全局最优解
贪心算法,获得,近似最优解,,"【定义2.19】贪心算法，就是从问题的某个初始解出发，通过在每一步构造当前状态下局部最优解的方式（即在每个局部阶段都贪心地做出当前状态下一个最优决策），一步一步地向全局最优解逼近，最终获取全局最优解。  
从算法设计的角度看，贪心算法具有思维复杂度低、代码量小、运行效率高、空间复杂度低等优点。但是，其局限性也是很明显的：贪心算法合理性的前提是每一步的局部最优解一定能够逼近到全局最优解，有时很难保证能够做到这一点，这称为贪心算法的非完美性。贪心算法从本质上缺少大局观思想，会给我们直接使用贪心算法带来很大的困难，因为有时很难找到一个简单可行并具有完美性的贪心思路，即使找到一个看上去很完美的贪心思路，也需要严格地证明其正确性。不过值得庆幸的是，虽然并不是所有问题都可通过贪心算法获得整体最优解，但是由此至少可以得到一个近似最优解。",贪心算法虽不一定能获得全局最优解，但至少可以得到一个近似最优解
递归,协同应用,分治,,递归是算法设计中一项非常重要的策略，其基本思想是把一个问题归结为一个或多个规模更小的子问题，然后用同样的方法解规模更小的子问题，要求子问题与原问题保持同一类型以保证可用同样方法求解，如此下去，直到子问题的规模小到可以直接求解为止。分治策略的思想则是将一个难以解决的大问题，分割成一些与原问题相同的、规模较小的子问题，以便分而治之，然后递归地解决子问题，最后把子问题的解组合成原问题的解。递归和分治就像一对孪生兄弟，经常同时应用在算法设计之中，并由此形成很多高效的算法。,递归和分治在算法设计中经常同时应用，形成高效的算法
递归,相互依赖,分治,,递归是算法设计中一项非常重要的策略，其基本思想是把一个问题归结为一个或多个规模更小的子问题，然后用同样的方法解规模更小的子问题，要求子问题与原问题保持同一类型以保证可用同样方法求解，如此下去，直到子问题的规模小到可以直接求解为止。分治策略的思想则是将一个难以解决的大问题，分割成一些与原问题相同的、规模较小的子问题，以便分而治之，然后递归地解决子问题，最后把子问题的解组合成原问题的解。递归和分治就像一对孪生兄弟，经常同时应用在算法设计之中，并由此形成很多高效的算法。,分治策略通过递归地解决子问题，最终组合成原问题的解
递归,自相似性,递归,,"【定义2.20】若一个算法通过把问题转化到带更小输入的相同问题的实例，来求解原来的问题，则这个算法称为递归的。  
其算法思想就是把求解的问题转化成规模较小的子问题，然后，再把该子问题继续转化为更小的子问题，通过多次转化，使得问题的规模小到可以直接求解，并得到最小解，然后将最小解逐层向上返回调用，最终得到整个问题的解。通俗地说，递归法就是大事化小、小事化了。例如，求两个正整数$a$ 和$b$ 的最大公因子的问题，其中$b{>}a$，就可以转化到求一对更小的整数（即$b$ 𝑚𝑜𝑑 $a$ 和$a$）的最大公因子问题，因为gcd($\cdot b$𝑚𝑜𝑑 $a,\ a)=\operatorname*{gcd}(a,\ b)$。  
递归算法有三个基本要求：  
（1）递归中每次循环都必须使问题规模变小；  
（2）递归操作中每相邻两步都是紧密关联的，在递归返回到上一层的操作中，前一次的输出便是后一次的输入；  
（3）当子问题的规模足够小时，必须能够直接求出该子问题的解，也就是说必须具备结束递归的初始条件（即得到递归出口：当问题规模 $n$小到某个值时，能够直接求解）。",递归算法通过将问题转化为规模更小的相同问题实例来求解原问题，体现了自相似性。
递归,转化,子问题,,"【定义2.20】若一个算法通过把问题转化到带更小输入的相同问题的实例，来求解原来的问题，则这个算法称为递归的。  
其算法思想就是把求解的问题转化成规模较小的子问题，然后，再把该子问题继续转化为更小的子问题，通过多次转化，使得问题的规模小到可以直接求解，并得到最小解，然后将最小解逐层向上返回调用，最终得到整个问题的解。通俗地说，递归法就是大事化小、小事化了。例如，求两个正整数$a$ 和$b$ 的最大公因子的问题，其中$b{>}a$，就可以转化到求一对更小的整数（即$b$ 𝑚𝑜𝑑 $a$ 和$a$）的最大公因子问题，因为gcd($\cdot b$𝑚𝑜𝑑 $a,\ a)=\operatorname*{gcd}(a,\ b)$。  
递归算法有三个基本要求：  
（1）递归中每次循环都必须使问题规模变小；  
（2）递归操作中每相邻两步都是紧密关联的，在递归返回到上一层的操作中，前一次的输出便是后一次的输入；  
（3）当子问题的规模足够小时，必须能够直接求出该子问题的解，也就是说必须具备结束递归的初始条件（即得到递归出口：当问题规模 $n$小到某个值时，能够直接求解）。",递归算法将原问题转化为规模较小的子问题，逐层缩小问题规模直至可解。
递归,依赖,递归出口,,"【定义2.20】若一个算法通过把问题转化到带更小输入的相同问题的实例，来求解原来的问题，则这个算法称为递归的。  
其算法思想就是把求解的问题转化成规模较小的子问题，然后，再把该子问题继续转化为更小的子问题，通过多次转化，使得问题的规模小到可以直接求解，并得到最小解，然后将最小解逐层向上返回调用，最终得到整个问题的解。通俗地说，递归法就是大事化小、小事化了。例如，求两个正整数$a$ 和$b$ 的最大公因子的问题，其中$b{>}a$，就可以转化到求一对更小的整数（即$b$ 𝑚𝑜𝑑 $a$ 和$a$）的最大公因子问题，因为gcd($\cdot b$𝑚𝑜𝑑 $a,\ a)=\operatorname*{gcd}(a,\ b)$。  
递归算法有三个基本要求：  
（1）递归中每次循环都必须使问题规模变小；  
（2）递归操作中每相邻两步都是紧密关联的，在递归返回到上一层的操作中，前一次的输出便是后一次的输入；  
（3）当子问题的规模足够小时，必须能够直接求出该子问题的解，也就是说必须具备结束递归的初始条件（即得到递归出口：当问题规模 $n$小到某个值时，能够直接求解）。",递归算法必须具备结束递归的初始条件，即递归出口，以确保问题规模小到可以直接求解。
递归,关联,递归操作,,"【定义2.20】若一个算法通过把问题转化到带更小输入的相同问题的实例，来求解原来的问题，则这个算法称为递归的。  
其算法思想就是把求解的问题转化成规模较小的子问题，然后，再把该子问题继续转化为更小的子问题，通过多次转化，使得问题的规模小到可以直接求解，并得到最小解，然后将最小解逐层向上返回调用，最终得到整个问题的解。通俗地说，递归法就是大事化小、小事化了。例如，求两个正整数$a$ 和$b$ 的最大公因子的问题，其中$b{>}a$，就可以转化到求一对更小的整数（即$b$ 𝑚𝑜𝑑 $a$ 和$a$）的最大公因子问题，因为gcd($\cdot b$𝑚𝑜𝑑 $a,\ a)=\operatorname*{gcd}(a,\ b)$。  
递归算法有三个基本要求：  
（1）递归中每次循环都必须使问题规模变小；  
（2）递归操作中每相邻两步都是紧密关联的，在递归返回到上一层的操作中，前一次的输出便是后一次的输入；  
（3）当子问题的规模足够小时，必须能够直接求出该子问题的解，也就是说必须具备结束递归的初始条件（即得到递归出口：当问题规模 $n$小到某个值时，能够直接求解）。",递归操作中每相邻两步紧密关联，前一次的输出作为后一次的输入。
分治策略,应用,分治递推关系,,"【定义2.21】对于一个规模为$n$ 的问题，若该问题可以容易地解决（比如说规模$n$ 较小）则直接解决，否则将其分解为$k$个规模较小的子问题，这些子问题互相独立且与原问题形式相同，求解这些子问题，然后将各子问题的解合并得到原问题的解。  
如定义所述，由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术解  决并实现分治策略提供了方便。分治法也可以看成是一种递归，因为必要时可把分解求得的子问题的解合并起来获得原问题的解。  
分治算法一般分为如下三个基本步骤：（1）将原问题分解为若干相同的子问题；（2）若子问题的规模容易解决则直接求解，否则继续分解；3）将子问题的解合并得到原问题的解，当遇到如折半查找等某些不必求出所有子问题的解的情况时，则省略合并操作。  
分治算法的计算复杂性可以通过构造递推表达式进行分析：假设一个递归算法把一个规模为$n$ 的问题分成$a$ 个子问题，其中每个子问题的规模是$n/b$（为简单起见，假设$n$是$b$的倍数），并设在把子问题解组合成原问题解的处理中需要总量为$g(n)$的额外运算。  
【定义2.22】若$f\!\!\left(n\right)$表示求解规模为$n$ 的问题所需的运算数，则$f$满足如下递推关系：  
$$
f~(n)=a f(n/b)+g(n)\tag{2-23}
$$  
上式称为分治递推关系。  
可通过上述递推关系来分析算法的复杂度。  
【定理2.31】假设$f$是满足递推关系：  
$$
f(n)=a f(n/b)+c
$$  
的增函数，其中$n$ 被$b$ 整除，$a{\geq}1$，$b$ 是大于1 的整数，$c$ 是一个正实数。则有：  
$$
f(n)={\left\{\begin{array}{l l}{O(n^{l o g_{b}\,a})}&{{如果a>1}}\\ {O(l o g\,n)}&{{如果a=1}}\end{array}\right.}\tag{2-24}
$$  
进一步，当$n=b^{k}$时（$k$ 是正整数），则有：  
$$
f(n)=C_{1}n^{l o g_{b}\,a}+C_{2}\tag{2-25}
$$  
其中$C_{1}{=}f\!\!(1){+}c/(a{\cdot}1)$且$C_{2}=-c/(a-1)$",分治策略通过分治递推关系来分析算法的复杂度
分治递推关系,满足,定理2.31,,"【定义2.21】对于一个规模为$n$ 的问题，若该问题可以容易地解决（比如说规模$n$ 较小）则直接解决，否则将其分解为$k$个规模较小的子问题，这些子问题互相独立且与原问题形式相同，求解这些子问题，然后将各子问题的解合并得到原问题的解。  
如定义所述，由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术解  决并实现分治策略提供了方便。分治法也可以看成是一种递归，因为必要时可把分解求得的子问题的解合并起来获得原问题的解。  
分治算法一般分为如下三个基本步骤：（1）将原问题分解为若干相同的子问题；（2）若子问题的规模容易解决则直接求解，否则继续分解；3）将子问题的解合并得到原问题的解，当遇到如折半查找等某些不必求出所有子问题的解的情况时，则省略合并操作。  
分治算法的计算复杂性可以通过构造递推表达式进行分析：假设一个递归算法把一个规模为$n$ 的问题分成$a$ 个子问题，其中每个子问题的规模是$n/b$（为简单起见，假设$n$是$b$的倍数），并设在把子问题解组合成原问题解的处理中需要总量为$g(n)$的额外运算。  
【定义2.22】若$f\!\!\left(n\right)$表示求解规模为$n$ 的问题所需的运算数，则$f$满足如下递推关系：  
$$
f~(n)=a f(n/b)+g(n)\tag{2-23}
$$  
上式称为分治递推关系。  
可通过上述递推关系来分析算法的复杂度。  
【定理2.31】假设$f$是满足递推关系：  
$$
f(n)=a f(n/b)+c
$$  
的增函数，其中$n$ 被$b$ 整除，$a{\geq}1$，$b$ 是大于1 的整数，$c$ 是一个正实数。则有：  
$$
f(n)={\left\{\begin{array}{l l}{O(n^{l o g_{b}\,a})}&{{如果a>1}}\\ {O(l o g\,n)}&{{如果a=1}}\end{array}\right.}\tag{2-24}
$$  
进一步，当$n=b^{k}$时（$k$ 是正整数），则有：  
$$
f(n)=C_{1}n^{l o g_{b}\,a}+C_{2}\tag{2-25}
$$  
其中$C_{1}{=}f\!\!(1){+}c/(a{\cdot}1)$且$C_{2}=-c/(a-1)$",分治递推关系满足定理2.31的条件
回溯,应用领域,动态规划,,回溯是一种基于解空间搜索的方法。基本思路类似于蛮力法，首先对所有的解状态进行枚举，生成解空间或状态空间，然后通过在解空间中搜索获得所需要的解。与蛮力法不同的是，这里的解空间是有结构的，换句话说，解空间以空间树的结构方式存在，由此可以根据这种特殊结构设计出很多高效的搜索方法。动态规划策略则是把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，通过对单阶段问题的逐个求解，实现对整个问题的求解，多年来，回溯和动态规划策略在最短路线、库存管理、资源分配、设备更新、排序、装载等问题求解算法中得到广泛应用。,回溯和动态规划策略在最短路线、库存管理、资源分配、设备更新、排序、装载等问题求解算法中得到广泛应用
回溯法,优化,剪枝,,"【定义2.23】回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。  
回溯法是一个既有系统性又有跳跃性的搜索算法，基本思路是在包含问题所有解的空间树中，按照深度优先的策略，从根节点出发搜索解的空间树。当算法搜索至某一节点时，先判断该节点是否包含问题的解，如果肯定不包含，则跳过以该节点为根的子树，逐层向其先前的节点回溯；否则，就进入该子树，继续按深度优先的策略进行搜索。回溯法的解空间为树结构，比较适合解决一些规模较大的问题。  
在用回溯法求解问题时，需要确定问题的解空间。所谓解空间，就是满足问题所有可能的解组成的集合，并且至少包含问题的一个（最优）解。  
由回溯法得到的解可以表示成$_{,n}$元向量$(X_{1},X_{2},\cdots,X_{n})$的形式。解向量一般具有显性或隐性的约束条件，在算法设计时，应该仔细分析，不能忽略。例如，当$n=3$ 时，0-1 背包问题可用一棵完全二叉树表示其解空间，如图2-14 所示。  
![](images/b415fb2b375de62d1f97720c41a6931e01b566d3978cde4ab5b4f6710e0bbacd.jpg)
图2-14  $n{=}3$ 时背包问题的解空间  
在作为解空间的树结构中，从第𝑖层到第$i{+}1$ 层边上的标号给出了变量$X_{i}$ 的值。从树根到叶的任一路径表示解的空间中的一个元素，即一个具体的解向量。例如，从根节点$A$ 到叶子节点$H$ 的路径相应于解空间中的元素（1,1,1）。  
回溯算法需要搜索整棵解空间树，当问题规模很大时，计算量比较大。此时可用剪枝的方法对搜索策略进行优化。  
【定义2.24】剪枝就是通过某种判断避免一些不必要的遍历过程，剪去解空间树中的一些不必要的枝条，从而缩小搜索规模。  
剪枝函数通常有两种策略，一是用约束函数在扩展节点处剪去不满足约束条件的子树，二是用限界函数剪去不能得到最优解的子树。对于限界函数，一般是添加一个全局变量记录当前最优解，在到达节点时计算该节点预期值并与当前最优解比较，若不好，则回溯。  
综上所述，回溯法解题一般包括三个基本步骤：(1)定义问题的解空间；(2)确定解空间结构；(3)以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。  
![](images/94c98789a7564cef4defce6c521572031ed59be149b82dc63805c35507db88a6.jpg)
图$2{\mathrm{-}}15\ 8{\times}8$ 棋盘",回溯法在搜索解空间树时，可以通过剪枝方法优化搜索策略，避免不必要的遍历过程，缩小搜索规模。
动态规划,依赖,最优子结构性质,,"【定义2.25】动态规划是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。  
当问题的数学模型是递推式时，按理应该使用递归算法求解。但是，递归算法有时存在大量重复计算，使得算法时间复杂度过高。实际上，不同子问题的个数往往只有多项式数量级，若将已经计算过的子问题中间数据和计算结果记录下来，需要某个子问题的解时就直接调用，则可避免大量的重复计算，甚至可以获得多项式时间的算法计算量。动态规划算法正是遵循这种思想，将求解过程中所有子问题的解全部记录下来，不管该子问题以后是否会被其它子问题用到。可以看出，动态规划采用的是以空间换取时间的策略。  
动态规划法的有效性依赖于求解问题的两个重要性质，即：最优子结构性质和子问题重叠性质。  
$\bullet$ 最优子结构性质  如果问题最优解所包含子问题的解也是最优的，则称该问题具有最优子结构性质。最优子结构性质是动态规划求解问题的必要条件。  
$\bullet$ 子问题重叠性质  子问题重叠性质是指在用递归算法由自顶向下的方式对问题求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。当再次需要计算已经计算过的子问题时，无需再次计算，只需查表即可。 当确定待解决的问题可以使用动态规划算法求解时，通常按照以下几个步骤进行：  
（1）把所有最优化问题分成若干个阶段，找出最优解的性质，并刻画其结构特性。  
（2）将问题发展到各个阶段时所处的不同状态表示出来，确定各个阶段状态之间的递推（或递归）关系，并确定初始（边界）条件。  
（3）应用递推（或递归）关系求解最优值。  
（4）根据计算最优值时得到的信息，构造最优解。  
以上（1）~（3）步是动态规划算法解决问题的基本步骤，在只需要计算最优值的问题中，完成这三个基本步骤即可。  
如果问题需要构造最优解，仍需执行第（4）步；此时，在第（3）步通常需要记录更多的信息，以便在步骤（4）中有足够信息快速地构造出最优解。",动态规划的有效性依赖于最优子结构性质，即问题最优解所包含子问题的解也是最优的，这是动态规划求解问题的必要条件。
动态规划,依赖,子问题重叠性质,,"【定义2.25】动态规划是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。  
当问题的数学模型是递推式时，按理应该使用递归算法求解。但是，递归算法有时存在大量重复计算，使得算法时间复杂度过高。实际上，不同子问题的个数往往只有多项式数量级，若将已经计算过的子问题中间数据和计算结果记录下来，需要某个子问题的解时就直接调用，则可避免大量的重复计算，甚至可以获得多项式时间的算法计算量。动态规划算法正是遵循这种思想，将求解过程中所有子问题的解全部记录下来，不管该子问题以后是否会被其它子问题用到。可以看出，动态规划采用的是以空间换取时间的策略。  
动态规划法的有效性依赖于求解问题的两个重要性质，即：最优子结构性质和子问题重叠性质。  
$\bullet$ 最优子结构性质  如果问题最优解所包含子问题的解也是最优的，则称该问题具有最优子结构性质。最优子结构性质是动态规划求解问题的必要条件。  
$\bullet$ 子问题重叠性质  子问题重叠性质是指在用递归算法由自顶向下的方式对问题求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。当再次需要计算已经计算过的子问题时，无需再次计算，只需查表即可。 当确定待解决的问题可以使用动态规划算法求解时，通常按照以下几个步骤进行：  
（1）把所有最优化问题分成若干个阶段，找出最优解的性质，并刻画其结构特性。  
（2）将问题发展到各个阶段时所处的不同状态表示出来，确定各个阶段状态之间的递推（或递归）关系，并确定初始（边界）条件。  
（3）应用递推（或递归）关系求解最优值。  
（4）根据计算最优值时得到的信息，构造最优解。  
以上（1）~（3）步是动态规划算法解决问题的基本步骤，在只需要计算最优值的问题中，完成这三个基本步骤即可。  
如果问题需要构造最优解，仍需执行第（4）步；此时，在第（3）步通常需要记录更多的信息，以便在步骤（4）中有足够信息快速地构造出最优解。",动态规划的有效性依赖于子问题重叠性质，即递归算法中子问题会被重复计算多次，通过记录已计算子问题的解来避免重复计算。
最优子结构性质,共存,子问题重叠性质,,"【定义2.25】动态规划是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。  
当问题的数学模型是递推式时，按理应该使用递归算法求解。但是，递归算法有时存在大量重复计算，使得算法时间复杂度过高。实际上，不同子问题的个数往往只有多项式数量级，若将已经计算过的子问题中间数据和计算结果记录下来，需要某个子问题的解时就直接调用，则可避免大量的重复计算，甚至可以获得多项式时间的算法计算量。动态规划算法正是遵循这种思想，将求解过程中所有子问题的解全部记录下来，不管该子问题以后是否会被其它子问题用到。可以看出，动态规划采用的是以空间换取时间的策略。  
动态规划法的有效性依赖于求解问题的两个重要性质，即：最优子结构性质和子问题重叠性质。  
$\bullet$ 最优子结构性质  如果问题最优解所包含子问题的解也是最优的，则称该问题具有最优子结构性质。最优子结构性质是动态规划求解问题的必要条件。  
$\bullet$ 子问题重叠性质  子问题重叠性质是指在用递归算法由自顶向下的方式对问题求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。当再次需要计算已经计算过的子问题时，无需再次计算，只需查表即可。 当确定待解决的问题可以使用动态规划算法求解时，通常按照以下几个步骤进行：  
（1）把所有最优化问题分成若干个阶段，找出最优解的性质，并刻画其结构特性。  
（2）将问题发展到各个阶段时所处的不同状态表示出来，确定各个阶段状态之间的递推（或递归）关系，并确定初始（边界）条件。  
（3）应用递推（或递归）关系求解最优值。  
（4）根据计算最优值时得到的信息，构造最优解。  
以上（1）~（3）步是动态规划算法解决问题的基本步骤，在只需要计算最优值的问题中，完成这三个基本步骤即可。  
如果问题需要构造最优解，仍需执行第（4）步；此时，在第（3）步通常需要记录更多的信息，以便在步骤（4）中有足够信息快速地构造出最优解。",最优子结构性质和子问题重叠性质是动态规划求解问题的两个重要性质，共同决定了动态规划法的有效性。
数理逻辑,构成,命题逻辑,,"计算机是处理数据并将其转化为有用信息的电子设备，其中央处理器主要由算术逻辑计算单元构成，通过数值与逻辑运算实现对信息的表示和处理。因此，逻辑运算作为计算机信息处理的两大基本方式之一，在计算机软件与硬件设计中具有非常重要的作用。在现实社会中，人们通常使用自然语言表达和处理逻辑问题。然而，计算机还远未实现对自然语言的正确理解，不能有效解决自然语言与生俱来的概念歧义问题，因此需要通过引入一套抽象数学符号来实现逻辑的表达和运算。这种基于数学符号表达和运算的形式化逻辑，称之为数理逻辑。数理逻辑最初主要由命题逻辑构成，后来由命题逻辑逐步发展到谓词逻辑，并进一步衍生出证明论、模型论、递归论等多个分支。数理逻辑严密无歧义的符号化表达和处理方式非常契合计算机信息处理的特点和机器思维的需求。计算机通过将数理逻辑中的数学符号转化成物理量实现其非凡的逻辑处理能力，学习和研发计算机系统必须借助数理逻辑中数学符号的演算规律去思考、表达和解决问题，善于通过数学符号的逻辑演算来驱动计算机实现信息的表示和处理。因此，数理逻辑在计算机与人工智能的各个领域都发挥着基础性的支撑作用，是计算机相关专业人员必须牢固掌握的基础知识。  
通过学习数理逻辑，读者不仅可以较好地掌握形式化表达和处理信息的基本方法，满足后续专业课在数理逻辑方面的知识需求，更为重要的是能够养成抽象严谨的逻辑思维，充分提高分析问题和解决问题的能力。命题逻辑是整个数理逻辑知识体系中最经典、最基础的部分，要掌握数理逻辑基本理论和应用技术，首先必须学好命题逻辑。本章比较系统地介绍命题逻辑的基本理论与应用，包括命题的基本概念与运算性质、命题公式与等值演算、真值函数与联结词的完备集、命题公式的范式、命题逻辑的推理系统与方法等。",数理逻辑最初主要由命题逻辑构成
数理逻辑,发展,命题逻辑,,"计算机是处理数据并将其转化为有用信息的电子设备，其中央处理器主要由算术逻辑计算单元构成，通过数值与逻辑运算实现对信息的表示和处理。因此，逻辑运算作为计算机信息处理的两大基本方式之一，在计算机软件与硬件设计中具有非常重要的作用。在现实社会中，人们通常使用自然语言表达和处理逻辑问题。然而，计算机还远未实现对自然语言的正确理解，不能有效解决自然语言与生俱来的概念歧义问题，因此需要通过引入一套抽象数学符号来实现逻辑的表达和运算。这种基于数学符号表达和运算的形式化逻辑，称之为数理逻辑。数理逻辑最初主要由命题逻辑构成，后来由命题逻辑逐步发展到谓词逻辑，并进一步衍生出证明论、模型论、递归论等多个分支。数理逻辑严密无歧义的符号化表达和处理方式非常契合计算机信息处理的特点和机器思维的需求。计算机通过将数理逻辑中的数学符号转化成物理量实现其非凡的逻辑处理能力，学习和研发计算机系统必须借助数理逻辑中数学符号的演算规律去思考、表达和解决问题，善于通过数学符号的逻辑演算来驱动计算机实现信息的表示和处理。因此，数理逻辑在计算机与人工智能的各个领域都发挥着基础性的支撑作用，是计算机相关专业人员必须牢固掌握的基础知识。  
通过学习数理逻辑，读者不仅可以较好地掌握形式化表达和处理信息的基本方法，满足后续专业课在数理逻辑方面的知识需求，更为重要的是能够养成抽象严谨的逻辑思维，充分提高分析问题和解决问题的能力。命题逻辑是整个数理逻辑知识体系中最经典、最基础的部分，要掌握数理逻辑基本理论和应用技术，首先必须学好命题逻辑。本章比较系统地介绍命题逻辑的基本理论与应用，包括命题的基本概念与运算性质、命题公式与等值演算、真值函数与联结词的完备集、命题公式的范式、命题逻辑的推理系统与方法等。",数理逻辑由命题逻辑逐步发展到谓词逻辑
数理逻辑,基础,命题逻辑,,"计算机是处理数据并将其转化为有用信息的电子设备，其中央处理器主要由算术逻辑计算单元构成，通过数值与逻辑运算实现对信息的表示和处理。因此，逻辑运算作为计算机信息处理的两大基本方式之一，在计算机软件与硬件设计中具有非常重要的作用。在现实社会中，人们通常使用自然语言表达和处理逻辑问题。然而，计算机还远未实现对自然语言的正确理解，不能有效解决自然语言与生俱来的概念歧义问题，因此需要通过引入一套抽象数学符号来实现逻辑的表达和运算。这种基于数学符号表达和运算的形式化逻辑，称之为数理逻辑。数理逻辑最初主要由命题逻辑构成，后来由命题逻辑逐步发展到谓词逻辑，并进一步衍生出证明论、模型论、递归论等多个分支。数理逻辑严密无歧义的符号化表达和处理方式非常契合计算机信息处理的特点和机器思维的需求。计算机通过将数理逻辑中的数学符号转化成物理量实现其非凡的逻辑处理能力，学习和研发计算机系统必须借助数理逻辑中数学符号的演算规律去思考、表达和解决问题，善于通过数学符号的逻辑演算来驱动计算机实现信息的表示和处理。因此，数理逻辑在计算机与人工智能的各个领域都发挥着基础性的支撑作用，是计算机相关专业人员必须牢固掌握的基础知识。  
通过学习数理逻辑，读者不仅可以较好地掌握形式化表达和处理信息的基本方法，满足后续专业课在数理逻辑方面的知识需求，更为重要的是能够养成抽象严谨的逻辑思维，充分提高分析问题和解决问题的能力。命题逻辑是整个数理逻辑知识体系中最经典、最基础的部分，要掌握数理逻辑基本理论和应用技术，首先必须学好命题逻辑。本章比较系统地介绍命题逻辑的基本理论与应用，包括命题的基本概念与运算性质、命题公式与等值演算、真值函数与联结词的完备集、命题公式的范式、命题逻辑的推理系统与方法等。",命题逻辑是数理逻辑知识体系中最经典、最基础的部分
数理逻辑,学习顺序,命题逻辑,,"计算机是处理数据并将其转化为有用信息的电子设备，其中央处理器主要由算术逻辑计算单元构成，通过数值与逻辑运算实现对信息的表示和处理。因此，逻辑运算作为计算机信息处理的两大基本方式之一，在计算机软件与硬件设计中具有非常重要的作用。在现实社会中，人们通常使用自然语言表达和处理逻辑问题。然而，计算机还远未实现对自然语言的正确理解，不能有效解决自然语言与生俱来的概念歧义问题，因此需要通过引入一套抽象数学符号来实现逻辑的表达和运算。这种基于数学符号表达和运算的形式化逻辑，称之为数理逻辑。数理逻辑最初主要由命题逻辑构成，后来由命题逻辑逐步发展到谓词逻辑，并进一步衍生出证明论、模型论、递归论等多个分支。数理逻辑严密无歧义的符号化表达和处理方式非常契合计算机信息处理的特点和机器思维的需求。计算机通过将数理逻辑中的数学符号转化成物理量实现其非凡的逻辑处理能力，学习和研发计算机系统必须借助数理逻辑中数学符号的演算规律去思考、表达和解决问题，善于通过数学符号的逻辑演算来驱动计算机实现信息的表示和处理。因此，数理逻辑在计算机与人工智能的各个领域都发挥着基础性的支撑作用，是计算机相关专业人员必须牢固掌握的基础知识。  
通过学习数理逻辑，读者不仅可以较好地掌握形式化表达和处理信息的基本方法，满足后续专业课在数理逻辑方面的知识需求，更为重要的是能够养成抽象严谨的逻辑思维，充分提高分析问题和解决问题的能力。命题逻辑是整个数理逻辑知识体系中最经典、最基础的部分，要掌握数理逻辑基本理论和应用技术，首先必须学好命题逻辑。本章比较系统地介绍命题逻辑的基本理论与应用，包括命题的基本概念与运算性质、命题公式与等值演算、真值函数与联结词的完备集、命题公式的范式、命题逻辑的推理系统与方法等。",要掌握数理逻辑基本理论和应用技术，首先必须学好命题逻辑
命题逻辑,基础,命题,,逻辑主要分为辩证逻辑与形式逻辑这两大类。辩证逻辑主要研究人类思维中的辩证法，属于哲学范畴。离散数学领域的逻辑通常是指形式逻辑，主要研究人类思维的基本形式、基本规则和基本规律，由概念、判断、推理这三个逐步递进的基本构件组成，通过概念形成判断，再通过判断形成推理。其中判断在整个形式逻辑系统中起着承上启下的枢纽作用，它以命题为载体实现其逻辑演算与推理的功能。因此，命题逻辑不仅是数理逻辑学中最为基础的内容，而且在整个逻辑学的学科体系占有十分重要的地位。学习命题逻辑一般需要从命题的概念和运算开始，本节主要介绍命题的基本概念和基本运算，包括命题逻辑的由来、命题的基本概念、命题的基本运算和常用联结词、命题的符号化与应用等。,命题逻辑是数理逻辑学中最为基础的内容，以命题为载体实现逻辑演算与推理功能
命题逻辑,起点,命题的概念与运算,,逻辑主要分为辩证逻辑与形式逻辑这两大类。辩证逻辑主要研究人类思维中的辩证法，属于哲学范畴。离散数学领域的逻辑通常是指形式逻辑，主要研究人类思维的基本形式、基本规则和基本规律，由概念、判断、推理这三个逐步递进的基本构件组成，通过概念形成判断，再通过判断形成推理。其中判断在整个形式逻辑系统中起着承上启下的枢纽作用，它以命题为载体实现其逻辑演算与推理的功能。因此，命题逻辑不仅是数理逻辑学中最为基础的内容，而且在整个逻辑学的学科体系占有十分重要的地位。学习命题逻辑一般需要从命题的概念和运算开始，本节主要介绍命题的基本概念和基本运算，包括命题逻辑的由来、命题的基本概念、命题的基本运算和常用联结词、命题的符号化与应用等。,学习命题逻辑一般需要从命题的概念和运算开始
命题,包含,命题的概念与运算,,逻辑主要分为辩证逻辑与形式逻辑这两大类。辩证逻辑主要研究人类思维中的辩证法，属于哲学范畴。离散数学领域的逻辑通常是指形式逻辑，主要研究人类思维的基本形式、基本规则和基本规律，由概念、判断、推理这三个逐步递进的基本构件组成，通过概念形成判断，再通过判断形成推理。其中判断在整个形式逻辑系统中起着承上启下的枢纽作用，它以命题为载体实现其逻辑演算与推理的功能。因此，命题逻辑不仅是数理逻辑学中最为基础的内容，而且在整个逻辑学的学科体系占有十分重要的地位。学习命题逻辑一般需要从命题的概念和运算开始，本节主要介绍命题的基本概念和基本运算，包括命题逻辑的由来、命题的基本概念、命题的基本运算和常用联结词、命题的符号化与应用等。,命题的概念与运算包括命题的基本概念和基本运算
逻辑,包含,数理逻辑,,"正确的思维是人们在日常学习、工作和生活中避免犯错的基础。所谓正确的思维，其实就是概念清晰、判断正确、推理合乎逻辑。这里的逻辑主要是指形式逻辑，意思是说推理要符合思维的基本形式、基本规则和基本规律。英国哲学家弗朗西斯·培根曾经说过：“逻辑是不可战胜的，因为反对逻辑的时候必须要使用逻辑”。这句话尽管有些极端，却很好地说明了逻辑的重要性。形式逻辑最初由古希腊哲学家亚里士多德创立，旨在通过研究人类思维的基本形式、基本规则和基本规律为政治家、哲学家、社会活动价的辩论提供理论指导。因此，历史上著名的政治家、哲学家和社会活动家在逻辑学方面一般都具有很深的造诣。  
用自然语言表达和处理逻辑问题虽然易于理解，但是自然语言与生俱来的歧义性使其难以满足逻辑表达在严密性方面的需求，制约了逻辑学的进一步发展。因此，德国著名数学家莱布尼茨提出一个关于数理逻辑的构想，意思是通过引入一套形式化符号系统来表示和处理逻辑问题，使得逻辑能够像代数一样进行演算、像几何一样可以画图，在发生意见分歧的时无需争论，只需说：让我们坐下来算一算吧，看谁正确。这就是著名的莱布尼茨梦想。1847年，英国数学家乔治∙布尔出版了第一部数理逻辑著作《逻辑学的数学分析》，创立一套以命题符号演算与推理为处理对象的布尔代数系统，初步实现了莱布尼茨梦想，使数理逻辑由一个初步的设想变成一套相对完整的数学理论体系。布尔代数以命题作为基本处理单元，故亦称为命题代数或命题逻辑。其实，与布尔同时代的数学家德摩根也几乎独立地在命题逻辑方面做了大量研究工作，并取得了丰硕的成果。可以这样说，数学家德摩根正式启动了将经典逻辑学大部分研究内容纳入数学范畴的任务，数学家布尔则是完成了这项任务。命题逻辑的现有知识体系基本上涵盖了这两位数学家的相关成果。",数理逻辑是逻辑的一个分支，通过形式化符号系统来表示和处理逻辑问题
数理逻辑,实现,布尔代数,,"正确的思维是人们在日常学习、工作和生活中避免犯错的基础。所谓正确的思维，其实就是概念清晰、判断正确、推理合乎逻辑。这里的逻辑主要是指形式逻辑，意思是说推理要符合思维的基本形式、基本规则和基本规律。英国哲学家弗朗西斯·培根曾经说过：“逻辑是不可战胜的，因为反对逻辑的时候必须要使用逻辑”。这句话尽管有些极端，却很好地说明了逻辑的重要性。形式逻辑最初由古希腊哲学家亚里士多德创立，旨在通过研究人类思维的基本形式、基本规则和基本规律为政治家、哲学家、社会活动价的辩论提供理论指导。因此，历史上著名的政治家、哲学家和社会活动家在逻辑学方面一般都具有很深的造诣。  
用自然语言表达和处理逻辑问题虽然易于理解，但是自然语言与生俱来的歧义性使其难以满足逻辑表达在严密性方面的需求，制约了逻辑学的进一步发展。因此，德国著名数学家莱布尼茨提出一个关于数理逻辑的构想，意思是通过引入一套形式化符号系统来表示和处理逻辑问题，使得逻辑能够像代数一样进行演算、像几何一样可以画图，在发生意见分歧的时无需争论，只需说：让我们坐下来算一算吧，看谁正确。这就是著名的莱布尼茨梦想。1847年，英国数学家乔治∙布尔出版了第一部数理逻辑著作《逻辑学的数学分析》，创立一套以命题符号演算与推理为处理对象的布尔代数系统，初步实现了莱布尼茨梦想，使数理逻辑由一个初步的设想变成一套相对完整的数学理论体系。布尔代数以命题作为基本处理单元，故亦称为命题代数或命题逻辑。其实，与布尔同时代的数学家德摩根也几乎独立地在命题逻辑方面做了大量研究工作，并取得了丰硕的成果。可以这样说，数学家德摩根正式启动了将经典逻辑学大部分研究内容纳入数学范畴的任务，数学家布尔则是完成了这项任务。命题逻辑的现有知识体系基本上涵盖了这两位数学家的相关成果。",布尔代数是数理逻辑的一个具体实现，以命题符号演算与推理为处理对象
布尔代数,同义,命题逻辑,,"正确的思维是人们在日常学习、工作和生活中避免犯错的基础。所谓正确的思维，其实就是概念清晰、判断正确、推理合乎逻辑。这里的逻辑主要是指形式逻辑，意思是说推理要符合思维的基本形式、基本规则和基本规律。英国哲学家弗朗西斯·培根曾经说过：“逻辑是不可战胜的，因为反对逻辑的时候必须要使用逻辑”。这句话尽管有些极端，却很好地说明了逻辑的重要性。形式逻辑最初由古希腊哲学家亚里士多德创立，旨在通过研究人类思维的基本形式、基本规则和基本规律为政治家、哲学家、社会活动价的辩论提供理论指导。因此，历史上著名的政治家、哲学家和社会活动家在逻辑学方面一般都具有很深的造诣。  
用自然语言表达和处理逻辑问题虽然易于理解，但是自然语言与生俱来的歧义性使其难以满足逻辑表达在严密性方面的需求，制约了逻辑学的进一步发展。因此，德国著名数学家莱布尼茨提出一个关于数理逻辑的构想，意思是通过引入一套形式化符号系统来表示和处理逻辑问题，使得逻辑能够像代数一样进行演算、像几何一样可以画图，在发生意见分歧的时无需争论，只需说：让我们坐下来算一算吧，看谁正确。这就是著名的莱布尼茨梦想。1847年，英国数学家乔治∙布尔出版了第一部数理逻辑著作《逻辑学的数学分析》，创立一套以命题符号演算与推理为处理对象的布尔代数系统，初步实现了莱布尼茨梦想，使数理逻辑由一个初步的设想变成一套相对完整的数学理论体系。布尔代数以命题作为基本处理单元，故亦称为命题代数或命题逻辑。其实，与布尔同时代的数学家德摩根也几乎独立地在命题逻辑方面做了大量研究工作，并取得了丰硕的成果。可以这样说，数学家德摩根正式启动了将经典逻辑学大部分研究内容纳入数学范畴的任务，数学家布尔则是完成了这项任务。命题逻辑的现有知识体系基本上涵盖了这两位数学家的相关成果。",布尔代数以命题作为基本处理单元，故亦称为命题代数或命题逻辑
命题逻辑,属于,数理逻辑,,"正确的思维是人们在日常学习、工作和生活中避免犯错的基础。所谓正确的思维，其实就是概念清晰、判断正确、推理合乎逻辑。这里的逻辑主要是指形式逻辑，意思是说推理要符合思维的基本形式、基本规则和基本规律。英国哲学家弗朗西斯·培根曾经说过：“逻辑是不可战胜的，因为反对逻辑的时候必须要使用逻辑”。这句话尽管有些极端，却很好地说明了逻辑的重要性。形式逻辑最初由古希腊哲学家亚里士多德创立，旨在通过研究人类思维的基本形式、基本规则和基本规律为政治家、哲学家、社会活动价的辩论提供理论指导。因此，历史上著名的政治家、哲学家和社会活动家在逻辑学方面一般都具有很深的造诣。  
用自然语言表达和处理逻辑问题虽然易于理解，但是自然语言与生俱来的歧义性使其难以满足逻辑表达在严密性方面的需求，制约了逻辑学的进一步发展。因此，德国著名数学家莱布尼茨提出一个关于数理逻辑的构想，意思是通过引入一套形式化符号系统来表示和处理逻辑问题，使得逻辑能够像代数一样进行演算、像几何一样可以画图，在发生意见分歧的时无需争论，只需说：让我们坐下来算一算吧，看谁正确。这就是著名的莱布尼茨梦想。1847年，英国数学家乔治∙布尔出版了第一部数理逻辑著作《逻辑学的数学分析》，创立一套以命题符号演算与推理为处理对象的布尔代数系统，初步实现了莱布尼茨梦想，使数理逻辑由一个初步的设想变成一套相对完整的数学理论体系。布尔代数以命题作为基本处理单元，故亦称为命题代数或命题逻辑。其实，与布尔同时代的数学家德摩根也几乎独立地在命题逻辑方面做了大量研究工作，并取得了丰硕的成果。可以这样说，数学家德摩根正式启动了将经典逻辑学大部分研究内容纳入数学范畴的任务，数学家布尔则是完成了这项任务。命题逻辑的现有知识体系基本上涵盖了这两位数学家的相关成果。",命题逻辑是数理逻辑的一部分，涵盖了布尔和德摩根的研究成果
命题,包含,原子命题,,"命题逻辑以命题作为最基本的处理对象。因此，学习命题逻辑首先必须掌握命题的基本概念。事实上，命题的概念与集合的概念一样，是一个没有严格定义的原始概念，其内涵是不言自明的。我们只能对命题的概念进行描述或解释：  
所谓命题，就是具有确切真假含义且能做出判断的陈述句。当判断正确或者符合客观实际时，命题表达的内容为真或者说命题的取值为真，并称该命题为真命题；否则命题表达的内容为假或者说命题的取值为假，并称该命题为假命题。命题或真或假的取值，称为命题的真值。通常用 $T$或1 表示取值为真的真值，用 $F$ 或0 表示取值为假的真值。  
根据上述关于命题概念的解释，可以看出：  
（1）命题主要用于逻辑思维中的是非判断，因此必须是陈述语句。其它类型的语句，例如感叹句、祈使句、疑问句等，都不能用于是非判断，故不能作为命题。  
（2）对于任何一个给定的命题，必有唯一确定的真值，要么取真、要么取假，不能既真又假，也不能既不真也不假。因此，具有二义性的陈述句不能作为命题。  
【定义3.1】对于任意一个给定的命题，当它不能再分解为更加简单的陈述句时，则称该命题为原子命题；否则，称之为复合命题。  
由上述定义可知，所有命题分为原子命题和复合命题这两种基本类型。例如，命题“合肥是安徽的省会”就是一个不能再分解的原子命题，而命题“安徽不是一个国家”则是一个复合命题，由“安徽是一个国家”这个原子命题生成。  
通常用带下标或不带下标的大写英文字母 $A,B,C,\ldots,P,Q,R,\ldots$… 表示命题，并称之为命题标识符。在命题逻辑系统中，对命题标识符的解释不允许有二义性。也就是说，对于任一确定的具体场合，各个标识符所表达的含义是唯一确定的。",命题分为原子命题和复合命题两种基本类型，原子命题是不能再分解的命题
命题,包含,复合命题,,"命题逻辑以命题作为最基本的处理对象。因此，学习命题逻辑首先必须掌握命题的基本概念。事实上，命题的概念与集合的概念一样，是一个没有严格定义的原始概念，其内涵是不言自明的。我们只能对命题的概念进行描述或解释：  
所谓命题，就是具有确切真假含义且能做出判断的陈述句。当判断正确或者符合客观实际时，命题表达的内容为真或者说命题的取值为真，并称该命题为真命题；否则命题表达的内容为假或者说命题的取值为假，并称该命题为假命题。命题或真或假的取值，称为命题的真值。通常用 $T$或1 表示取值为真的真值，用 $F$ 或0 表示取值为假的真值。  
根据上述关于命题概念的解释，可以看出：  
（1）命题主要用于逻辑思维中的是非判断，因此必须是陈述语句。其它类型的语句，例如感叹句、祈使句、疑问句等，都不能用于是非判断，故不能作为命题。  
（2）对于任何一个给定的命题，必有唯一确定的真值，要么取真、要么取假，不能既真又假，也不能既不真也不假。因此，具有二义性的陈述句不能作为命题。  
【定义3.1】对于任意一个给定的命题，当它不能再分解为更加简单的陈述句时，则称该命题为原子命题；否则，称之为复合命题。  
由上述定义可知，所有命题分为原子命题和复合命题这两种基本类型。例如，命题“合肥是安徽的省会”就是一个不能再分解的原子命题，而命题“安徽不是一个国家”则是一个复合命题，由“安徽是一个国家”这个原子命题生成。  
通常用带下标或不带下标的大写英文字母 $A,B,C,\ldots,P,Q,R,\ldots$… 表示命题，并称之为命题标识符。在命题逻辑系统中，对命题标识符的解释不允许有二义性。也就是说，对于任一确定的具体场合，各个标识符所表达的含义是唯一确定的。",命题分为原子命题和复合命题两种基本类型，复合命题是可以再分解的命题
命题,表示,命题标识符,,"命题逻辑以命题作为最基本的处理对象。因此，学习命题逻辑首先必须掌握命题的基本概念。事实上，命题的概念与集合的概念一样，是一个没有严格定义的原始概念，其内涵是不言自明的。我们只能对命题的概念进行描述或解释：  
所谓命题，就是具有确切真假含义且能做出判断的陈述句。当判断正确或者符合客观实际时，命题表达的内容为真或者说命题的取值为真，并称该命题为真命题；否则命题表达的内容为假或者说命题的取值为假，并称该命题为假命题。命题或真或假的取值，称为命题的真值。通常用 $T$或1 表示取值为真的真值，用 $F$ 或0 表示取值为假的真值。  
根据上述关于命题概念的解释，可以看出：  
（1）命题主要用于逻辑思维中的是非判断，因此必须是陈述语句。其它类型的语句，例如感叹句、祈使句、疑问句等，都不能用于是非判断，故不能作为命题。  
（2）对于任何一个给定的命题，必有唯一确定的真值，要么取真、要么取假，不能既真又假，也不能既不真也不假。因此，具有二义性的陈述句不能作为命题。  
【定义3.1】对于任意一个给定的命题，当它不能再分解为更加简单的陈述句时，则称该命题为原子命题；否则，称之为复合命题。  
由上述定义可知，所有命题分为原子命题和复合命题这两种基本类型。例如，命题“合肥是安徽的省会”就是一个不能再分解的原子命题，而命题“安徽不是一个国家”则是一个复合命题，由“安徽是一个国家”这个原子命题生成。  
通常用带下标或不带下标的大写英文字母 $A,B,C,\ldots,P,Q,R,\ldots$… 表示命题，并称之为命题标识符。在命题逻辑系统中，对命题标识符的解释不允许有二义性。也就是说，对于任一确定的具体场合，各个标识符所表达的含义是唯一确定的。",命题通常用带下标或不带下标的大写英文字母表示，这些字母称为命题标识符
原子命题,对立,复合命题,,"命题逻辑以命题作为最基本的处理对象。因此，学习命题逻辑首先必须掌握命题的基本概念。事实上，命题的概念与集合的概念一样，是一个没有严格定义的原始概念，其内涵是不言自明的。我们只能对命题的概念进行描述或解释：  
所谓命题，就是具有确切真假含义且能做出判断的陈述句。当判断正确或者符合客观实际时，命题表达的内容为真或者说命题的取值为真，并称该命题为真命题；否则命题表达的内容为假或者说命题的取值为假，并称该命题为假命题。命题或真或假的取值，称为命题的真值。通常用 $T$或1 表示取值为真的真值，用 $F$ 或0 表示取值为假的真值。  
根据上述关于命题概念的解释，可以看出：  
（1）命题主要用于逻辑思维中的是非判断，因此必须是陈述语句。其它类型的语句，例如感叹句、祈使句、疑问句等，都不能用于是非判断，故不能作为命题。  
（2）对于任何一个给定的命题，必有唯一确定的真值，要么取真、要么取假，不能既真又假，也不能既不真也不假。因此，具有二义性的陈述句不能作为命题。  
【定义3.1】对于任意一个给定的命题，当它不能再分解为更加简单的陈述句时，则称该命题为原子命题；否则，称之为复合命题。  
由上述定义可知，所有命题分为原子命题和复合命题这两种基本类型。例如，命题“合肥是安徽的省会”就是一个不能再分解的原子命题，而命题“安徽不是一个国家”则是一个复合命题，由“安徽是一个国家”这个原子命题生成。  
通常用带下标或不带下标的大写英文字母 $A,B,C,\ldots,P,Q,R,\ldots$… 表示命题，并称之为命题标识符。在命题逻辑系统中，对命题标识符的解释不允许有二义性。也就是说，对于任一确定的具体场合，各个标识符所表达的含义是唯一确定的。",所有命题分为原子命题和复合命题这两种基本类型，原子命题不能再分解，而复合命题可以再分解
命题标识符,指代,命题,,"命题逻辑以命题作为最基本的处理对象。因此，学习命题逻辑首先必须掌握命题的基本概念。事实上，命题的概念与集合的概念一样，是一个没有严格定义的原始概念，其内涵是不言自明的。我们只能对命题的概念进行描述或解释：  
所谓命题，就是具有确切真假含义且能做出判断的陈述句。当判断正确或者符合客观实际时，命题表达的内容为真或者说命题的取值为真，并称该命题为真命题；否则命题表达的内容为假或者说命题的取值为假，并称该命题为假命题。命题或真或假的取值，称为命题的真值。通常用 $T$或1 表示取值为真的真值，用 $F$ 或0 表示取值为假的真值。  
根据上述关于命题概念的解释，可以看出：  
（1）命题主要用于逻辑思维中的是非判断，因此必须是陈述语句。其它类型的语句，例如感叹句、祈使句、疑问句等，都不能用于是非判断，故不能作为命题。  
（2）对于任何一个给定的命题，必有唯一确定的真值，要么取真、要么取假，不能既真又假，也不能既不真也不假。因此，具有二义性的陈述句不能作为命题。  
【定义3.1】对于任意一个给定的命题，当它不能再分解为更加简单的陈述句时，则称该命题为原子命题；否则，称之为复合命题。  
由上述定义可知，所有命题分为原子命题和复合命题这两种基本类型。例如，命题“合肥是安徽的省会”就是一个不能再分解的原子命题，而命题“安徽不是一个国家”则是一个复合命题，由“安徽是一个国家”这个原子命题生成。  
通常用带下标或不带下标的大写英文字母 $A,B,C,\ldots,P,Q,R,\ldots$… 表示命题，并称之为命题标识符。在命题逻辑系统中，对命题标识符的解释不允许有二义性。也就是说，对于任一确定的具体场合，各个标识符所表达的含义是唯一确定的。",命题标识符用于指代具体的命题，在命题逻辑系统中，其含义是唯一确定的
命题演算与推理,依赖,命题的常用联结词,,"可以通过一些联结词和标点符号将若干原子命题联结起来构成复合命题，由此形成命题的运算机制。为了能够使用数学方法表示、分析和处理这种命题运算机制，精确研究命题之间的逻辑关系，需要引入一套抽象数学符号来表示这些联结词。最常用的逻辑联结词主要有如下五种：“或者”、 “并且”、“不是”、“如果…, 那么…”、“当且仅当”。下面分别介绍这些逻辑联结词的具体逻辑含义及其数学符号。",命题演算与推理依赖于命题的常用联结词来表示、分析和处理命题之间的逻辑关系
命题的否定,定义,否定联结词,,"对于任意一个给定的命题，可以通过对其含义取反或者进行否定来得到一个新的命题。新命题的含义与真值与原命题完全相反，由此得到的逻辑运算称为命题的“非”运算或“否定”运算。该运算及其逻辑联结词具体定义如下：  
【定义3.2】设 $P$ 是任一命题，复合命题“非 $P$ ”称为 $P$ 的否定式或非运算，记作 $\lnot\ P$ ，其中符号$\neg$称为否定联结词(简称为否定词)。$\lnot\ P$ 的真值为真，当且仅当 $P$ 的真值为假，或者说：$\lnot\ P$ 的真值为假，当且仅当 $P$ 的真值为真。  
$\lnot\ P$ 是一个由命题$P$衍生而来的复合命题，其真值取值状况与 $P$ 完全相反。例如，若令 $P$ 表示命题“我喜欢唱歌”，则 $\lnot\ P$ 就表示命题“我不喜欢唱歌”。  
对于任意一个命题 $P$，它其否定命题¬ $P$ 之间的真值关系如表3-1 第3 列所示：  
表$^{3\cdot1}\ \neg,\ \wedge,$ ∨的运算表
![](images/b0b4f79b14e0e83d1cdd7d9bbd1f3b9956a6520b82a62886b519b2594f4eadae.jpg)",命题的否定是通过使用否定联结词对原命题进行取反操作得到的复合命题，其真值与原命题完全相反
命题,构成,合取,,"对于任意两个命题，有时需要构造一个新的复合命题表示这两个命题同时为真的含义，相当于自然语言中“与”或“并且”的意思，由此得到的逻辑运算称为命题的“合取”运算或者“与”运算。该运算及其逻辑联结词的具体定义如下：  
【定义3.3】设 $P$ 、$Q$ 是任意两个命题，复合命题$^{\prime\prime}P$并且 $Q$ ”称为 $P$ 与 $Q$ 的合取式或与运算，记作 $P\land Q$，其中符号$\wedge$称为合取联结词(简称为合取词)。 $P\land Q$的取值为真，当且仅当 $P$ 和$Q$ 同时为真；或者说$P$ ∧𝑄 的取值为假，当且仅当 $P$ 和 $Q$ 至少有一个为假。  
例如，若令$\cdot P$表示“我喜欢唱歌”， $Q$ 表示“我喜欢跳舞”，则合取式 $P\land Q$ 就表示复合命题“我喜欢唱歌并且喜欢跳舞”。  
对于任意两个命题 $P$ 和 $Q$ ，其合取运算 $P\land Q$的真值取值规定如表3-1 第5 列所示。  
有时需要构造一个复合命题表示两个命题中至少有一个为真的含义，相当于自然语言中“可兼或”的意思，由此得到的逻辑运算称为命题的“析取”运算或者“可兼或”运算。所谓可兼或，就是可两者兼得的或。该运算及其逻辑联结词的具体定义如下：  
【定义 3.4 】设   $P、 Q$   是任意给定的两个命题，复合命题 $^{\prime\prime}P$   或 $\textit{Q}\,^{\prime\prime}$ 称为   $P$ 与   $Q$   的析取 式或者可兼或运算，有时简称为或运算，记作 $P\lor Q$ ，其中符号$\vee$称为析取联结词(简称为析取词 ) 。 $P\lor Q$   的取值为真，当且仅当   $P$   和   $Q$   中至少有一个为真；或者说 $P\lor Q$   的取值 为假，当且仅当 $P$ 和 $Q$ 都为假。  
例如，若令 $P$ 表示“我喜欢唱歌”，$Q$ 表示“我喜欢跳舞”，则析取式 $P\lor Q$ 就表示复合命题“我喜欢唱歌或者喜欢跳舞”。  
对于任意两个命题 $P$ 和 $Q$，析取运算 $P\lor Q$ 的真值取值规定如表3-1 第6 列所示。  
在实际的逻辑电路中，通常用高电位表示1 或$T$，用低电位表示0 或$F$，通过逻辑与、或、非等运算，可构造相应的与门、或门、非门，如图所示。后面将具体介绍如何使用这些门电路来构造出一些复杂的逻辑电路。  
图3-2 逻辑电路  
需要注意的是：自然语言中或的含义是有歧义的，对或的理解除了上述可兼或外，有时还可理解成不可兼或，即两者不可兼得的或，有时称之为异或。在逻辑运算中，可兼或与异或之间具有完全不同的含义，我们将在后续相关内容中具体讨论异或逻辑联结词及其逻辑运算。除非特别说明，逻辑演算中或运算含义都默认为可兼或运算，即析取运算。  
在实际应用中，应根据语句的具体内容和上下文相关信息仔细甄别其中“或”表达的是可兼或还是不可兼或。例如，语句“今天晚上我看书或者听音乐”中“或”的含义应理解为可兼或；语句”这节课是数学课或者体育课“中“或”的含义应理解为不可兼或。",任意两个命题可以通过合取运算构成一个新的复合命题，表示这两个命题同时为真
合取,使用,合取联结词,,"对于任意两个命题，有时需要构造一个新的复合命题表示这两个命题同时为真的含义，相当于自然语言中“与”或“并且”的意思，由此得到的逻辑运算称为命题的“合取”运算或者“与”运算。该运算及其逻辑联结词的具体定义如下：  
【定义3.3】设 $P$ 、$Q$ 是任意两个命题，复合命题$^{\prime\prime}P$并且 $Q$ ”称为 $P$ 与 $Q$ 的合取式或与运算，记作 $P\land Q$，其中符号$\wedge$称为合取联结词(简称为合取词)。 $P\land Q$的取值为真，当且仅当 $P$ 和$Q$ 同时为真；或者说$P$ ∧𝑄 的取值为假，当且仅当 $P$ 和 $Q$ 至少有一个为假。  
例如，若令$\cdot P$表示“我喜欢唱歌”， $Q$ 表示“我喜欢跳舞”，则合取式 $P\land Q$ 就表示复合命题“我喜欢唱歌并且喜欢跳舞”。  
对于任意两个命题 $P$ 和 $Q$ ，其合取运算 $P\land Q$的真值取值规定如表3-1 第5 列所示。  
有时需要构造一个复合命题表示两个命题中至少有一个为真的含义，相当于自然语言中“可兼或”的意思，由此得到的逻辑运算称为命题的“析取”运算或者“可兼或”运算。所谓可兼或，就是可两者兼得的或。该运算及其逻辑联结词的具体定义如下：  
【定义 3.4 】设   $P、 Q$   是任意给定的两个命题，复合命题 $^{\prime\prime}P$   或 $\textit{Q}\,^{\prime\prime}$ 称为   $P$ 与   $Q$   的析取 式或者可兼或运算，有时简称为或运算，记作 $P\lor Q$ ，其中符号$\vee$称为析取联结词(简称为析取词 ) 。 $P\lor Q$   的取值为真，当且仅当   $P$   和   $Q$   中至少有一个为真；或者说 $P\lor Q$   的取值 为假，当且仅当 $P$ 和 $Q$ 都为假。  
例如，若令 $P$ 表示“我喜欢唱歌”，$Q$ 表示“我喜欢跳舞”，则析取式 $P\lor Q$ 就表示复合命题“我喜欢唱歌或者喜欢跳舞”。  
对于任意两个命题 $P$ 和 $Q$，析取运算 $P\lor Q$ 的真值取值规定如表3-1 第6 列所示。  
在实际的逻辑电路中，通常用高电位表示1 或$T$，用低电位表示0 或$F$，通过逻辑与、或、非等运算，可构造相应的与门、或门、非门，如图所示。后面将具体介绍如何使用这些门电路来构造出一些复杂的逻辑电路。  
图3-2 逻辑电路  
需要注意的是：自然语言中或的含义是有歧义的，对或的理解除了上述可兼或外，有时还可理解成不可兼或，即两者不可兼得的或，有时称之为异或。在逻辑运算中，可兼或与异或之间具有完全不同的含义，我们将在后续相关内容中具体讨论异或逻辑联结词及其逻辑运算。除非特别说明，逻辑演算中或运算含义都默认为可兼或运算，即析取运算。  
在实际应用中，应根据语句的具体内容和上下文相关信息仔细甄别其中“或”表达的是可兼或还是不可兼或。例如，语句“今天晚上我看书或者听音乐”中“或”的含义应理解为可兼或；语句”这节课是数学课或者体育课“中“或”的含义应理解为不可兼或。",合取运算使用合取联结词来表示两个命题的同时为真
命题,构成,析取,,"对于任意两个命题，有时需要构造一个新的复合命题表示这两个命题同时为真的含义，相当于自然语言中“与”或“并且”的意思，由此得到的逻辑运算称为命题的“合取”运算或者“与”运算。该运算及其逻辑联结词的具体定义如下：  
【定义3.3】设 $P$ 、$Q$ 是任意两个命题，复合命题$^{\prime\prime}P$并且 $Q$ ”称为 $P$ 与 $Q$ 的合取式或与运算，记作 $P\land Q$，其中符号$\wedge$称为合取联结词(简称为合取词)。 $P\land Q$的取值为真，当且仅当 $P$ 和$Q$ 同时为真；或者说$P$ ∧𝑄 的取值为假，当且仅当 $P$ 和 $Q$ 至少有一个为假。  
例如，若令$\cdot P$表示“我喜欢唱歌”， $Q$ 表示“我喜欢跳舞”，则合取式 $P\land Q$ 就表示复合命题“我喜欢唱歌并且喜欢跳舞”。  
对于任意两个命题 $P$ 和 $Q$ ，其合取运算 $P\land Q$的真值取值规定如表3-1 第5 列所示。  
有时需要构造一个复合命题表示两个命题中至少有一个为真的含义，相当于自然语言中“可兼或”的意思，由此得到的逻辑运算称为命题的“析取”运算或者“可兼或”运算。所谓可兼或，就是可两者兼得的或。该运算及其逻辑联结词的具体定义如下：  
【定义 3.4 】设   $P、 Q$   是任意给定的两个命题，复合命题 $^{\prime\prime}P$   或 $\textit{Q}\,^{\prime\prime}$ 称为   $P$ 与   $Q$   的析取 式或者可兼或运算，有时简称为或运算，记作 $P\lor Q$ ，其中符号$\vee$称为析取联结词(简称为析取词 ) 。 $P\lor Q$   的取值为真，当且仅当   $P$   和   $Q$   中至少有一个为真；或者说 $P\lor Q$   的取值 为假，当且仅当 $P$ 和 $Q$ 都为假。  
例如，若令 $P$ 表示“我喜欢唱歌”，$Q$ 表示“我喜欢跳舞”，则析取式 $P\lor Q$ 就表示复合命题“我喜欢唱歌或者喜欢跳舞”。  
对于任意两个命题 $P$ 和 $Q$，析取运算 $P\lor Q$ 的真值取值规定如表3-1 第6 列所示。  
在实际的逻辑电路中，通常用高电位表示1 或$T$，用低电位表示0 或$F$，通过逻辑与、或、非等运算，可构造相应的与门、或门、非门，如图所示。后面将具体介绍如何使用这些门电路来构造出一些复杂的逻辑电路。  
图3-2 逻辑电路  
需要注意的是：自然语言中或的含义是有歧义的，对或的理解除了上述可兼或外，有时还可理解成不可兼或，即两者不可兼得的或，有时称之为异或。在逻辑运算中，可兼或与异或之间具有完全不同的含义，我们将在后续相关内容中具体讨论异或逻辑联结词及其逻辑运算。除非特别说明，逻辑演算中或运算含义都默认为可兼或运算，即析取运算。  
在实际应用中，应根据语句的具体内容和上下文相关信息仔细甄别其中“或”表达的是可兼或还是不可兼或。例如，语句“今天晚上我看书或者听音乐”中“或”的含义应理解为可兼或；语句”这节课是数学课或者体育课“中“或”的含义应理解为不可兼或。",任意两个命题可以通过析取运算构成一个新的复合命题，表示这两个命题中至少有一个为真
析取,使用,析取联结词,,"对于任意两个命题，有时需要构造一个新的复合命题表示这两个命题同时为真的含义，相当于自然语言中“与”或“并且”的意思，由此得到的逻辑运算称为命题的“合取”运算或者“与”运算。该运算及其逻辑联结词的具体定义如下：  
【定义3.3】设 $P$ 、$Q$ 是任意两个命题，复合命题$^{\prime\prime}P$并且 $Q$ ”称为 $P$ 与 $Q$ 的合取式或与运算，记作 $P\land Q$，其中符号$\wedge$称为合取联结词(简称为合取词)。 $P\land Q$的取值为真，当且仅当 $P$ 和$Q$ 同时为真；或者说$P$ ∧𝑄 的取值为假，当且仅当 $P$ 和 $Q$ 至少有一个为假。  
例如，若令$\cdot P$表示“我喜欢唱歌”， $Q$ 表示“我喜欢跳舞”，则合取式 $P\land Q$ 就表示复合命题“我喜欢唱歌并且喜欢跳舞”。  
对于任意两个命题 $P$ 和 $Q$ ，其合取运算 $P\land Q$的真值取值规定如表3-1 第5 列所示。  
有时需要构造一个复合命题表示两个命题中至少有一个为真的含义，相当于自然语言中“可兼或”的意思，由此得到的逻辑运算称为命题的“析取”运算或者“可兼或”运算。所谓可兼或，就是可两者兼得的或。该运算及其逻辑联结词的具体定义如下：  
【定义 3.4 】设   $P、 Q$   是任意给定的两个命题，复合命题 $^{\prime\prime}P$   或 $\textit{Q}\,^{\prime\prime}$ 称为   $P$ 与   $Q$   的析取 式或者可兼或运算，有时简称为或运算，记作 $P\lor Q$ ，其中符号$\vee$称为析取联结词(简称为析取词 ) 。 $P\lor Q$   的取值为真，当且仅当   $P$   和   $Q$   中至少有一个为真；或者说 $P\lor Q$   的取值 为假，当且仅当 $P$ 和 $Q$ 都为假。  
例如，若令 $P$ 表示“我喜欢唱歌”，$Q$ 表示“我喜欢跳舞”，则析取式 $P\lor Q$ 就表示复合命题“我喜欢唱歌或者喜欢跳舞”。  
对于任意两个命题 $P$ 和 $Q$，析取运算 $P\lor Q$ 的真值取值规定如表3-1 第6 列所示。  
在实际的逻辑电路中，通常用高电位表示1 或$T$，用低电位表示0 或$F$，通过逻辑与、或、非等运算，可构造相应的与门、或门、非门，如图所示。后面将具体介绍如何使用这些门电路来构造出一些复杂的逻辑电路。  
图3-2 逻辑电路  
需要注意的是：自然语言中或的含义是有歧义的，对或的理解除了上述可兼或外，有时还可理解成不可兼或，即两者不可兼得的或，有时称之为异或。在逻辑运算中，可兼或与异或之间具有完全不同的含义，我们将在后续相关内容中具体讨论异或逻辑联结词及其逻辑运算。除非特别说明，逻辑演算中或运算含义都默认为可兼或运算，即析取运算。  
在实际应用中，应根据语句的具体内容和上下文相关信息仔细甄别其中“或”表达的是可兼或还是不可兼或。例如，语句“今天晚上我看书或者听音乐”中“或”的含义应理解为可兼或；语句”这节课是数学课或者体育课“中“或”的含义应理解为不可兼或。",析取运算使用析取联结词来表示两个命题中至少有一个为真
可兼或,等价,析取,,"对于任意两个命题，有时需要构造一个新的复合命题表示这两个命题同时为真的含义，相当于自然语言中“与”或“并且”的意思，由此得到的逻辑运算称为命题的“合取”运算或者“与”运算。该运算及其逻辑联结词的具体定义如下：  
【定义3.3】设 $P$ 、$Q$ 是任意两个命题，复合命题$^{\prime\prime}P$并且 $Q$ ”称为 $P$ 与 $Q$ 的合取式或与运算，记作 $P\land Q$，其中符号$\wedge$称为合取联结词(简称为合取词)。 $P\land Q$的取值为真，当且仅当 $P$ 和$Q$ 同时为真；或者说$P$ ∧𝑄 的取值为假，当且仅当 $P$ 和 $Q$ 至少有一个为假。  
例如，若令$\cdot P$表示“我喜欢唱歌”， $Q$ 表示“我喜欢跳舞”，则合取式 $P\land Q$ 就表示复合命题“我喜欢唱歌并且喜欢跳舞”。  
对于任意两个命题 $P$ 和 $Q$ ，其合取运算 $P\land Q$的真值取值规定如表3-1 第5 列所示。  
有时需要构造一个复合命题表示两个命题中至少有一个为真的含义，相当于自然语言中“可兼或”的意思，由此得到的逻辑运算称为命题的“析取”运算或者“可兼或”运算。所谓可兼或，就是可两者兼得的或。该运算及其逻辑联结词的具体定义如下：  
【定义 3.4 】设   $P、 Q$   是任意给定的两个命题，复合命题 $^{\prime\prime}P$   或 $\textit{Q}\,^{\prime\prime}$ 称为   $P$ 与   $Q$   的析取 式或者可兼或运算，有时简称为或运算，记作 $P\lor Q$ ，其中符号$\vee$称为析取联结词(简称为析取词 ) 。 $P\lor Q$   的取值为真，当且仅当   $P$   和   $Q$   中至少有一个为真；或者说 $P\lor Q$   的取值 为假，当且仅当 $P$ 和 $Q$ 都为假。  
例如，若令 $P$ 表示“我喜欢唱歌”，$Q$ 表示“我喜欢跳舞”，则析取式 $P\lor Q$ 就表示复合命题“我喜欢唱歌或者喜欢跳舞”。  
对于任意两个命题 $P$ 和 $Q$，析取运算 $P\lor Q$ 的真值取值规定如表3-1 第6 列所示。  
在实际的逻辑电路中，通常用高电位表示1 或$T$，用低电位表示0 或$F$，通过逻辑与、或、非等运算，可构造相应的与门、或门、非门，如图所示。后面将具体介绍如何使用这些门电路来构造出一些复杂的逻辑电路。  
图3-2 逻辑电路  
需要注意的是：自然语言中或的含义是有歧义的，对或的理解除了上述可兼或外，有时还可理解成不可兼或，即两者不可兼得的或，有时称之为异或。在逻辑运算中，可兼或与异或之间具有完全不同的含义，我们将在后续相关内容中具体讨论异或逻辑联结词及其逻辑运算。除非特别说明，逻辑演算中或运算含义都默认为可兼或运算，即析取运算。  
在实际应用中，应根据语句的具体内容和上下文相关信息仔细甄别其中“或”表达的是可兼或还是不可兼或。例如，语句“今天晚上我看书或者听音乐”中“或”的含义应理解为可兼或；语句”这节课是数学课或者体育课“中“或”的含义应理解为不可兼或。",可兼或运算与析取运算具有相同的逻辑含义，表示两个命题中至少有一个为真
可兼或,区别,异或,,"对于任意两个命题，有时需要构造一个新的复合命题表示这两个命题同时为真的含义，相当于自然语言中“与”或“并且”的意思，由此得到的逻辑运算称为命题的“合取”运算或者“与”运算。该运算及其逻辑联结词的具体定义如下：  
【定义3.3】设 $P$ 、$Q$ 是任意两个命题，复合命题$^{\prime\prime}P$并且 $Q$ ”称为 $P$ 与 $Q$ 的合取式或与运算，记作 $P\land Q$，其中符号$\wedge$称为合取联结词(简称为合取词)。 $P\land Q$的取值为真，当且仅当 $P$ 和$Q$ 同时为真；或者说$P$ ∧𝑄 的取值为假，当且仅当 $P$ 和 $Q$ 至少有一个为假。  
例如，若令$\cdot P$表示“我喜欢唱歌”， $Q$ 表示“我喜欢跳舞”，则合取式 $P\land Q$ 就表示复合命题“我喜欢唱歌并且喜欢跳舞”。  
对于任意两个命题 $P$ 和 $Q$ ，其合取运算 $P\land Q$的真值取值规定如表3-1 第5 列所示。  
有时需要构造一个复合命题表示两个命题中至少有一个为真的含义，相当于自然语言中“可兼或”的意思，由此得到的逻辑运算称为命题的“析取”运算或者“可兼或”运算。所谓可兼或，就是可两者兼得的或。该运算及其逻辑联结词的具体定义如下：  
【定义 3.4 】设   $P、 Q$   是任意给定的两个命题，复合命题 $^{\prime\prime}P$   或 $\textit{Q}\,^{\prime\prime}$ 称为   $P$ 与   $Q$   的析取 式或者可兼或运算，有时简称为或运算，记作 $P\lor Q$ ，其中符号$\vee$称为析取联结词(简称为析取词 ) 。 $P\lor Q$   的取值为真，当且仅当   $P$   和   $Q$   中至少有一个为真；或者说 $P\lor Q$   的取值 为假，当且仅当 $P$ 和 $Q$ 都为假。  
例如，若令 $P$ 表示“我喜欢唱歌”，$Q$ 表示“我喜欢跳舞”，则析取式 $P\lor Q$ 就表示复合命题“我喜欢唱歌或者喜欢跳舞”。  
对于任意两个命题 $P$ 和 $Q$，析取运算 $P\lor Q$ 的真值取值规定如表3-1 第6 列所示。  
在实际的逻辑电路中，通常用高电位表示1 或$T$，用低电位表示0 或$F$，通过逻辑与、或、非等运算，可构造相应的与门、或门、非门，如图所示。后面将具体介绍如何使用这些门电路来构造出一些复杂的逻辑电路。  
图3-2 逻辑电路  
需要注意的是：自然语言中或的含义是有歧义的，对或的理解除了上述可兼或外，有时还可理解成不可兼或，即两者不可兼得的或，有时称之为异或。在逻辑运算中，可兼或与异或之间具有完全不同的含义，我们将在后续相关内容中具体讨论异或逻辑联结词及其逻辑运算。除非特别说明，逻辑演算中或运算含义都默认为可兼或运算，即析取运算。  
在实际应用中，应根据语句的具体内容和上下文相关信息仔细甄别其中“或”表达的是可兼或还是不可兼或。例如，语句“今天晚上我看书或者听音乐”中“或”的含义应理解为可兼或；语句”这节课是数学课或者体育课“中“或”的含义应理解为不可兼或。",可兼或与异或具有不同的逻辑含义，前者表示两者可兼得，后者表示两者不可兼得
命题演算与推理,包含,命题,,"有时候需要构造一个复合命题表示如果某个命题为真，那么另外一个命题必为真的含义，相当于自然语言中“如果…，那么…”的意思，由此得到的逻辑运算称为命题的“蕴涵”运算或者“条件”运算。该运算及其逻辑联结词的具体定义如下：  
【定义3.5】设 $P、 Q$ 是任意两个命题，复合命题$^{\prime\prime}P$ 蕴涵 $Q$ ”称为 $P$ 与 $Q$ 的蕴含式或蕴含运算，记作 $P\rightarrow Q$ ，其中符号$""~\rightarrow~""$称为蕴含联结词（简称为蕴含词），$P$ 称为蕴含式的前提或前件，   $Q$   称为蕴含式的结论或后件。 $P\rightarrow Q$   的真值为假，当且仅当   $P$ 为真且  $Q$ 为假。  
例如，若令 $P$ 表示“我喜欢唱歌”， $Q$表示“我喜欢跳舞”，则蕴涵式 $P\rightarrow Q$ 就表示复合命题“如果我喜欢唱歌，那么必然喜欢跳舞”。其中命题“我喜欢唱歌”是蕴含式的前提或前件，命题“我喜欢跳舞”是蕴含式的结论或后件。  
对于任意两个命题 $P$ 和 $Q$ ，蕴涵运算 $P\rightarrow Q$ 的真值取值规定如表3-2 第3 列所示。  
表${3 -2}\rightarrow,\ \leftrightarrow$的运算表
![](images/920c1058d83ec209cf5c8390304a73d783359e57457ba1d5a111c26950f592f9.jpg)  
由表3-2 可以看出，对于蕴涵运算 $P\rightarrow Q$ 的真值取值，只有当 $P$ 为真， $Q$ 为假时，$P\rightarrow Q$ 的真值才为假，在其余三种情况下 $P\rightarrow Q$ 的真值均为真。也就是说，当 $P$ 为为假时，无论 $Q$ 为真或者为假，$P\rightarrow Q$ 的真值均为真。  
其实，蕴含运算符$""{\rightarrow}""$既可表示充分条件，也可表示必要条件，关键是看哪个作为运算的前件，哪个作为运算的后件。具体地说，对于蕴涵式 $P\rightarrow Q$ ，具有如下结论：  
命题 $P$ 是命题 $Q$ 的充分条件，因为根据蕴涵式的含义有：若 $P$ 为真，则 $Q$ 必为真；  
命题 $Q$ 是命题 $P$ 的必要条件，因为根据蕴涵式的含义有：若 $Q$为假，则 $P$ 必为假。  
自然语言表达充分条件和必要条件的方式有很多种，实际使用的时候应注意区分。例如，若令 $P$ 表示命题“天气好”， $Q$ 表示命题“我去公园”，则对于如下4 个命题：  
（1）如果天气好，我就去公园；（2）只要天气好，我就去公园；  
（3）只有天气好，我才去公园；（4）仅当天气好，我才去公园。  
对于命题（1）2），$P$ 是 $Q$ 的充分条件，$Q$ 是 $P$ 的必要条件，可表示为 $P\rightarrow Q$；  
对于命题（3）4），$P$ 是 $Q$ 的必要条件，$Q$ 是 $P$ 的充分条件，可表示为 $Q\rightarrow P$ 。  
有时需要构造一个复合命题表示两个命题同时为真且同时为假的含义，相当于自然语言中“等价”、“当且仅当”的意思，由此得到的逻辑运算称为命题的“等价”运算或者“双蕴含”运算。该运算及其逻辑联结词的具体定义如下：  
【定义 3.6 】设   $P$ 、 $Q$   是任意两个命题，复合命题 “   $P$   等价   $Q$   ” 称为   $P$   与   $Q$   的等价 式或等价运算，有时也称为双蕴含运算，记作 $P\leftrightarrow Q$ ，其中符号$\leftrightarrow$称为等价联结词(简称为等价词)。$P\leftrightarrow Q$ 的取值为真，当且仅当 $P$ 与 $Q$具有相同的真值。  
例如，若令 $P$ 表示“我喜欢唱歌”，$Q$ 表示“我喜欢跳舞”，则等价式 $P\leftrightarrow Q$ 就表示复合命题“我喜欢唱歌当且仅当我喜欢跳舞”，或者“如果我喜欢唱歌，那么必然喜欢跳舞，并且如果我喜欢跳舞，那么必然喜欢唱歌”。  
对于任意两个命题 $P$ 和 $Q$ ，其等价运算$P\leftrightarrow Q$的真值取值情况如表3-2 第4 列所示。",命题演算与推理涉及对命题的分析和处理
命题,使用,命题的常用联结词,,"有时候需要构造一个复合命题表示如果某个命题为真，那么另外一个命题必为真的含义，相当于自然语言中“如果…，那么…”的意思，由此得到的逻辑运算称为命题的“蕴涵”运算或者“条件”运算。该运算及其逻辑联结词的具体定义如下：  
【定义3.5】设 $P、 Q$ 是任意两个命题，复合命题$^{\prime\prime}P$ 蕴涵 $Q$ ”称为 $P$ 与 $Q$ 的蕴含式或蕴含运算，记作 $P\rightarrow Q$ ，其中符号$""~\rightarrow~""$称为蕴含联结词（简称为蕴含词），$P$ 称为蕴含式的前提或前件，   $Q$   称为蕴含式的结论或后件。 $P\rightarrow Q$   的真值为假，当且仅当   $P$ 为真且  $Q$ 为假。  
例如，若令 $P$ 表示“我喜欢唱歌”， $Q$表示“我喜欢跳舞”，则蕴涵式 $P\rightarrow Q$ 就表示复合命题“如果我喜欢唱歌，那么必然喜欢跳舞”。其中命题“我喜欢唱歌”是蕴含式的前提或前件，命题“我喜欢跳舞”是蕴含式的结论或后件。  
对于任意两个命题 $P$ 和 $Q$ ，蕴涵运算 $P\rightarrow Q$ 的真值取值规定如表3-2 第3 列所示。  
表${3 -2}\rightarrow,\ \leftrightarrow$的运算表
![](images/920c1058d83ec209cf5c8390304a73d783359e57457ba1d5a111c26950f592f9.jpg)  
由表3-2 可以看出，对于蕴涵运算 $P\rightarrow Q$ 的真值取值，只有当 $P$ 为真， $Q$ 为假时，$P\rightarrow Q$ 的真值才为假，在其余三种情况下 $P\rightarrow Q$ 的真值均为真。也就是说，当 $P$ 为为假时，无论 $Q$ 为真或者为假，$P\rightarrow Q$ 的真值均为真。  
其实，蕴含运算符$""{\rightarrow}""$既可表示充分条件，也可表示必要条件，关键是看哪个作为运算的前件，哪个作为运算的后件。具体地说，对于蕴涵式 $P\rightarrow Q$ ，具有如下结论：  
命题 $P$ 是命题 $Q$ 的充分条件，因为根据蕴涵式的含义有：若 $P$ 为真，则 $Q$ 必为真；  
命题 $Q$ 是命题 $P$ 的必要条件，因为根据蕴涵式的含义有：若 $Q$为假，则 $P$ 必为假。  
自然语言表达充分条件和必要条件的方式有很多种，实际使用的时候应注意区分。例如，若令 $P$ 表示命题“天气好”， $Q$ 表示命题“我去公园”，则对于如下4 个命题：  
（1）如果天气好，我就去公园；（2）只要天气好，我就去公园；  
（3）只有天气好，我才去公园；（4）仅当天气好，我才去公园。  
对于命题（1）2），$P$ 是 $Q$ 的充分条件，$Q$ 是 $P$ 的必要条件，可表示为 $P\rightarrow Q$；  
对于命题（3）4），$P$ 是 $Q$ 的必要条件，$Q$ 是 $P$ 的充分条件，可表示为 $Q\rightarrow P$ 。  
有时需要构造一个复合命题表示两个命题同时为真且同时为假的含义，相当于自然语言中“等价”、“当且仅当”的意思，由此得到的逻辑运算称为命题的“等价”运算或者“双蕴含”运算。该运算及其逻辑联结词的具体定义如下：  
【定义 3.6 】设   $P$ 、 $Q$   是任意两个命题，复合命题 “   $P$   等价   $Q$   ” 称为   $P$   与   $Q$   的等价 式或等价运算，有时也称为双蕴含运算，记作 $P\leftrightarrow Q$ ，其中符号$\leftrightarrow$称为等价联结词(简称为等价词)。$P\leftrightarrow Q$ 的取值为真，当且仅当 $P$ 与 $Q$具有相同的真值。  
例如，若令 $P$ 表示“我喜欢唱歌”，$Q$ 表示“我喜欢跳舞”，则等价式 $P\leftrightarrow Q$ 就表示复合命题“我喜欢唱歌当且仅当我喜欢跳舞”，或者“如果我喜欢唱歌，那么必然喜欢跳舞，并且如果我喜欢跳舞，那么必然喜欢唱歌”。  
对于任意两个命题 $P$ 和 $Q$ ，其等价运算$P\leftrightarrow Q$的真值取值情况如表3-2 第4 列所示。",命题通过常用联结词构成复合命题
命题的常用联结词,包含,蕴含联结词,,"有时候需要构造一个复合命题表示如果某个命题为真，那么另外一个命题必为真的含义，相当于自然语言中“如果…，那么…”的意思，由此得到的逻辑运算称为命题的“蕴涵”运算或者“条件”运算。该运算及其逻辑联结词的具体定义如下：  
【定义3.5】设 $P、 Q$ 是任意两个命题，复合命题$^{\prime\prime}P$ 蕴涵 $Q$ ”称为 $P$ 与 $Q$ 的蕴含式或蕴含运算，记作 $P\rightarrow Q$ ，其中符号$""~\rightarrow~""$称为蕴含联结词（简称为蕴含词），$P$ 称为蕴含式的前提或前件，   $Q$   称为蕴含式的结论或后件。 $P\rightarrow Q$   的真值为假，当且仅当   $P$ 为真且  $Q$ 为假。  
例如，若令 $P$ 表示“我喜欢唱歌”， $Q$表示“我喜欢跳舞”，则蕴涵式 $P\rightarrow Q$ 就表示复合命题“如果我喜欢唱歌，那么必然喜欢跳舞”。其中命题“我喜欢唱歌”是蕴含式的前提或前件，命题“我喜欢跳舞”是蕴含式的结论或后件。  
对于任意两个命题 $P$ 和 $Q$ ，蕴涵运算 $P\rightarrow Q$ 的真值取值规定如表3-2 第3 列所示。  
表${3 -2}\rightarrow,\ \leftrightarrow$的运算表
![](images/920c1058d83ec209cf5c8390304a73d783359e57457ba1d5a111c26950f592f9.jpg)  
由表3-2 可以看出，对于蕴涵运算 $P\rightarrow Q$ 的真值取值，只有当 $P$ 为真， $Q$ 为假时，$P\rightarrow Q$ 的真值才为假，在其余三种情况下 $P\rightarrow Q$ 的真值均为真。也就是说，当 $P$ 为为假时，无论 $Q$ 为真或者为假，$P\rightarrow Q$ 的真值均为真。  
其实，蕴含运算符$""{\rightarrow}""$既可表示充分条件，也可表示必要条件，关键是看哪个作为运算的前件，哪个作为运算的后件。具体地说，对于蕴涵式 $P\rightarrow Q$ ，具有如下结论：  
命题 $P$ 是命题 $Q$ 的充分条件，因为根据蕴涵式的含义有：若 $P$ 为真，则 $Q$ 必为真；  
命题 $Q$ 是命题 $P$ 的必要条件，因为根据蕴涵式的含义有：若 $Q$为假，则 $P$ 必为假。  
自然语言表达充分条件和必要条件的方式有很多种，实际使用的时候应注意区分。例如，若令 $P$ 表示命题“天气好”， $Q$ 表示命题“我去公园”，则对于如下4 个命题：  
（1）如果天气好，我就去公园；（2）只要天气好，我就去公园；  
（3）只有天气好，我才去公园；（4）仅当天气好，我才去公园。  
对于命题（1）2），$P$ 是 $Q$ 的充分条件，$Q$ 是 $P$ 的必要条件，可表示为 $P\rightarrow Q$；  
对于命题（3）4），$P$ 是 $Q$ 的必要条件，$Q$ 是 $P$ 的充分条件，可表示为 $Q\rightarrow P$ 。  
有时需要构造一个复合命题表示两个命题同时为真且同时为假的含义，相当于自然语言中“等价”、“当且仅当”的意思，由此得到的逻辑运算称为命题的“等价”运算或者“双蕴含”运算。该运算及其逻辑联结词的具体定义如下：  
【定义 3.6 】设   $P$ 、 $Q$   是任意两个命题，复合命题 “   $P$   等价   $Q$   ” 称为   $P$   与   $Q$   的等价 式或等价运算，有时也称为双蕴含运算，记作 $P\leftrightarrow Q$ ，其中符号$\leftrightarrow$称为等价联结词(简称为等价词)。$P\leftrightarrow Q$ 的取值为真，当且仅当 $P$ 与 $Q$具有相同的真值。  
例如，若令 $P$ 表示“我喜欢唱歌”，$Q$ 表示“我喜欢跳舞”，则等价式 $P\leftrightarrow Q$ 就表示复合命题“我喜欢唱歌当且仅当我喜欢跳舞”，或者“如果我喜欢唱歌，那么必然喜欢跳舞，并且如果我喜欢跳舞，那么必然喜欢唱歌”。  
对于任意两个命题 $P$ 和 $Q$ ，其等价运算$P\leftrightarrow Q$的真值取值情况如表3-2 第4 列所示。",蕴含联结词是命题的常用联结词之一
命题的常用联结词,包含,等价联结词,,"有时候需要构造一个复合命题表示如果某个命题为真，那么另外一个命题必为真的含义，相当于自然语言中“如果…，那么…”的意思，由此得到的逻辑运算称为命题的“蕴涵”运算或者“条件”运算。该运算及其逻辑联结词的具体定义如下：  
【定义3.5】设 $P、 Q$ 是任意两个命题，复合命题$^{\prime\prime}P$ 蕴涵 $Q$ ”称为 $P$ 与 $Q$ 的蕴含式或蕴含运算，记作 $P\rightarrow Q$ ，其中符号$""~\rightarrow~""$称为蕴含联结词（简称为蕴含词），$P$ 称为蕴含式的前提或前件，   $Q$   称为蕴含式的结论或后件。 $P\rightarrow Q$   的真值为假，当且仅当   $P$ 为真且  $Q$ 为假。  
例如，若令 $P$ 表示“我喜欢唱歌”， $Q$表示“我喜欢跳舞”，则蕴涵式 $P\rightarrow Q$ 就表示复合命题“如果我喜欢唱歌，那么必然喜欢跳舞”。其中命题“我喜欢唱歌”是蕴含式的前提或前件，命题“我喜欢跳舞”是蕴含式的结论或后件。  
对于任意两个命题 $P$ 和 $Q$ ，蕴涵运算 $P\rightarrow Q$ 的真值取值规定如表3-2 第3 列所示。  
表${3 -2}\rightarrow,\ \leftrightarrow$的运算表
![](images/920c1058d83ec209cf5c8390304a73d783359e57457ba1d5a111c26950f592f9.jpg)  
由表3-2 可以看出，对于蕴涵运算 $P\rightarrow Q$ 的真值取值，只有当 $P$ 为真， $Q$ 为假时，$P\rightarrow Q$ 的真值才为假，在其余三种情况下 $P\rightarrow Q$ 的真值均为真。也就是说，当 $P$ 为为假时，无论 $Q$ 为真或者为假，$P\rightarrow Q$ 的真值均为真。  
其实，蕴含运算符$""{\rightarrow}""$既可表示充分条件，也可表示必要条件，关键是看哪个作为运算的前件，哪个作为运算的后件。具体地说，对于蕴涵式 $P\rightarrow Q$ ，具有如下结论：  
命题 $P$ 是命题 $Q$ 的充分条件，因为根据蕴涵式的含义有：若 $P$ 为真，则 $Q$ 必为真；  
命题 $Q$ 是命题 $P$ 的必要条件，因为根据蕴涵式的含义有：若 $Q$为假，则 $P$ 必为假。  
自然语言表达充分条件和必要条件的方式有很多种，实际使用的时候应注意区分。例如，若令 $P$ 表示命题“天气好”， $Q$ 表示命题“我去公园”，则对于如下4 个命题：  
（1）如果天气好，我就去公园；（2）只要天气好，我就去公园；  
（3）只有天气好，我才去公园；（4）仅当天气好，我才去公园。  
对于命题（1）2），$P$ 是 $Q$ 的充分条件，$Q$ 是 $P$ 的必要条件，可表示为 $P\rightarrow Q$；  
对于命题（3）4），$P$ 是 $Q$ 的必要条件，$Q$ 是 $P$ 的充分条件，可表示为 $Q\rightarrow P$ 。  
有时需要构造一个复合命题表示两个命题同时为真且同时为假的含义，相当于自然语言中“等价”、“当且仅当”的意思，由此得到的逻辑运算称为命题的“等价”运算或者“双蕴含”运算。该运算及其逻辑联结词的具体定义如下：  
【定义 3.6 】设   $P$ 、 $Q$   是任意两个命题，复合命题 “   $P$   等价   $Q$   ” 称为   $P$   与   $Q$   的等价 式或等价运算，有时也称为双蕴含运算，记作 $P\leftrightarrow Q$ ，其中符号$\leftrightarrow$称为等价联结词(简称为等价词)。$P\leftrightarrow Q$ 的取值为真，当且仅当 $P$ 与 $Q$具有相同的真值。  
例如，若令 $P$ 表示“我喜欢唱歌”，$Q$ 表示“我喜欢跳舞”，则等价式 $P\leftrightarrow Q$ 就表示复合命题“我喜欢唱歌当且仅当我喜欢跳舞”，或者“如果我喜欢唱歌，那么必然喜欢跳舞，并且如果我喜欢跳舞，那么必然喜欢唱歌”。  
对于任意两个命题 $P$ 和 $Q$ ，其等价运算$P\leftrightarrow Q$的真值取值情况如表3-2 第4 列所示。",等价联结词是命题的常用联结词之一
蕴含联结词,表示,蕴涵运算,,"有时候需要构造一个复合命题表示如果某个命题为真，那么另外一个命题必为真的含义，相当于自然语言中“如果…，那么…”的意思，由此得到的逻辑运算称为命题的“蕴涵”运算或者“条件”运算。该运算及其逻辑联结词的具体定义如下：  
【定义3.5】设 $P、 Q$ 是任意两个命题，复合命题$^{\prime\prime}P$ 蕴涵 $Q$ ”称为 $P$ 与 $Q$ 的蕴含式或蕴含运算，记作 $P\rightarrow Q$ ，其中符号$""~\rightarrow~""$称为蕴含联结词（简称为蕴含词），$P$ 称为蕴含式的前提或前件，   $Q$   称为蕴含式的结论或后件。 $P\rightarrow Q$   的真值为假，当且仅当   $P$ 为真且  $Q$ 为假。  
例如，若令 $P$ 表示“我喜欢唱歌”， $Q$表示“我喜欢跳舞”，则蕴涵式 $P\rightarrow Q$ 就表示复合命题“如果我喜欢唱歌，那么必然喜欢跳舞”。其中命题“我喜欢唱歌”是蕴含式的前提或前件，命题“我喜欢跳舞”是蕴含式的结论或后件。  
对于任意两个命题 $P$ 和 $Q$ ，蕴涵运算 $P\rightarrow Q$ 的真值取值规定如表3-2 第3 列所示。  
表${3 -2}\rightarrow,\ \leftrightarrow$的运算表
![](images/920c1058d83ec209cf5c8390304a73d783359e57457ba1d5a111c26950f592f9.jpg)  
由表3-2 可以看出，对于蕴涵运算 $P\rightarrow Q$ 的真值取值，只有当 $P$ 为真， $Q$ 为假时，$P\rightarrow Q$ 的真值才为假，在其余三种情况下 $P\rightarrow Q$ 的真值均为真。也就是说，当 $P$ 为为假时，无论 $Q$ 为真或者为假，$P\rightarrow Q$ 的真值均为真。  
其实，蕴含运算符$""{\rightarrow}""$既可表示充分条件，也可表示必要条件，关键是看哪个作为运算的前件，哪个作为运算的后件。具体地说，对于蕴涵式 $P\rightarrow Q$ ，具有如下结论：  
命题 $P$ 是命题 $Q$ 的充分条件，因为根据蕴涵式的含义有：若 $P$ 为真，则 $Q$ 必为真；  
命题 $Q$ 是命题 $P$ 的必要条件，因为根据蕴涵式的含义有：若 $Q$为假，则 $P$ 必为假。  
自然语言表达充分条件和必要条件的方式有很多种，实际使用的时候应注意区分。例如，若令 $P$ 表示命题“天气好”， $Q$ 表示命题“我去公园”，则对于如下4 个命题：  
（1）如果天气好，我就去公园；（2）只要天气好，我就去公园；  
（3）只有天气好，我才去公园；（4）仅当天气好，我才去公园。  
对于命题（1）2），$P$ 是 $Q$ 的充分条件，$Q$ 是 $P$ 的必要条件，可表示为 $P\rightarrow Q$；  
对于命题（3）4），$P$ 是 $Q$ 的必要条件，$Q$ 是 $P$ 的充分条件，可表示为 $Q\rightarrow P$ 。  
有时需要构造一个复合命题表示两个命题同时为真且同时为假的含义，相当于自然语言中“等价”、“当且仅当”的意思，由此得到的逻辑运算称为命题的“等价”运算或者“双蕴含”运算。该运算及其逻辑联结词的具体定义如下：  
【定义 3.6 】设   $P$ 、 $Q$   是任意两个命题，复合命题 “   $P$   等价   $Q$   ” 称为   $P$   与   $Q$   的等价 式或等价运算，有时也称为双蕴含运算，记作 $P\leftrightarrow Q$ ，其中符号$\leftrightarrow$称为等价联结词(简称为等价词)。$P\leftrightarrow Q$ 的取值为真，当且仅当 $P$ 与 $Q$具有相同的真值。  
例如，若令 $P$ 表示“我喜欢唱歌”，$Q$ 表示“我喜欢跳舞”，则等价式 $P\leftrightarrow Q$ 就表示复合命题“我喜欢唱歌当且仅当我喜欢跳舞”，或者“如果我喜欢唱歌，那么必然喜欢跳舞，并且如果我喜欢跳舞，那么必然喜欢唱歌”。  
对于任意两个命题 $P$ 和 $Q$ ，其等价运算$P\leftrightarrow Q$的真值取值情况如表3-2 第4 列所示。",蕴含联结词用于表示蕴涵运算
等价联结词,表示,等价运算,,"有时候需要构造一个复合命题表示如果某个命题为真，那么另外一个命题必为真的含义，相当于自然语言中“如果…，那么…”的意思，由此得到的逻辑运算称为命题的“蕴涵”运算或者“条件”运算。该运算及其逻辑联结词的具体定义如下：  
【定义3.5】设 $P、 Q$ 是任意两个命题，复合命题$^{\prime\prime}P$ 蕴涵 $Q$ ”称为 $P$ 与 $Q$ 的蕴含式或蕴含运算，记作 $P\rightarrow Q$ ，其中符号$""~\rightarrow~""$称为蕴含联结词（简称为蕴含词），$P$ 称为蕴含式的前提或前件，   $Q$   称为蕴含式的结论或后件。 $P\rightarrow Q$   的真值为假，当且仅当   $P$ 为真且  $Q$ 为假。  
例如，若令 $P$ 表示“我喜欢唱歌”， $Q$表示“我喜欢跳舞”，则蕴涵式 $P\rightarrow Q$ 就表示复合命题“如果我喜欢唱歌，那么必然喜欢跳舞”。其中命题“我喜欢唱歌”是蕴含式的前提或前件，命题“我喜欢跳舞”是蕴含式的结论或后件。  
对于任意两个命题 $P$ 和 $Q$ ，蕴涵运算 $P\rightarrow Q$ 的真值取值规定如表3-2 第3 列所示。  
表${3 -2}\rightarrow,\ \leftrightarrow$的运算表
![](images/920c1058d83ec209cf5c8390304a73d783359e57457ba1d5a111c26950f592f9.jpg)  
由表3-2 可以看出，对于蕴涵运算 $P\rightarrow Q$ 的真值取值，只有当 $P$ 为真， $Q$ 为假时，$P\rightarrow Q$ 的真值才为假，在其余三种情况下 $P\rightarrow Q$ 的真值均为真。也就是说，当 $P$ 为为假时，无论 $Q$ 为真或者为假，$P\rightarrow Q$ 的真值均为真。  
其实，蕴含运算符$""{\rightarrow}""$既可表示充分条件，也可表示必要条件，关键是看哪个作为运算的前件，哪个作为运算的后件。具体地说，对于蕴涵式 $P\rightarrow Q$ ，具有如下结论：  
命题 $P$ 是命题 $Q$ 的充分条件，因为根据蕴涵式的含义有：若 $P$ 为真，则 $Q$ 必为真；  
命题 $Q$ 是命题 $P$ 的必要条件，因为根据蕴涵式的含义有：若 $Q$为假，则 $P$ 必为假。  
自然语言表达充分条件和必要条件的方式有很多种，实际使用的时候应注意区分。例如，若令 $P$ 表示命题“天气好”， $Q$ 表示命题“我去公园”，则对于如下4 个命题：  
（1）如果天气好，我就去公园；（2）只要天气好，我就去公园；  
（3）只有天气好，我才去公园；（4）仅当天气好，我才去公园。  
对于命题（1）2），$P$ 是 $Q$ 的充分条件，$Q$ 是 $P$ 的必要条件，可表示为 $P\rightarrow Q$；  
对于命题（3）4），$P$ 是 $Q$ 的必要条件，$Q$ 是 $P$ 的充分条件，可表示为 $Q\rightarrow P$ 。  
有时需要构造一个复合命题表示两个命题同时为真且同时为假的含义，相当于自然语言中“等价”、“当且仅当”的意思，由此得到的逻辑运算称为命题的“等价”运算或者“双蕴含”运算。该运算及其逻辑联结词的具体定义如下：  
【定义 3.6 】设   $P$ 、 $Q$   是任意两个命题，复合命题 “   $P$   等价   $Q$   ” 称为   $P$   与   $Q$   的等价 式或等价运算，有时也称为双蕴含运算，记作 $P\leftrightarrow Q$ ，其中符号$\leftrightarrow$称为等价联结词(简称为等价词)。$P\leftrightarrow Q$ 的取值为真，当且仅当 $P$ 与 $Q$具有相同的真值。  
例如，若令 $P$ 表示“我喜欢唱歌”，$Q$ 表示“我喜欢跳舞”，则等价式 $P\leftrightarrow Q$ 就表示复合命题“我喜欢唱歌当且仅当我喜欢跳舞”，或者“如果我喜欢唱歌，那么必然喜欢跳舞，并且如果我喜欢跳舞，那么必然喜欢唱歌”。  
对于任意两个命题 $P$ 和 $Q$ ，其等价运算$P\leftrightarrow Q$的真值取值情况如表3-2 第4 列所示。",等价联结词用于表示等价运算
蕴涵运算,涉及,命题,,"有时候需要构造一个复合命题表示如果某个命题为真，那么另外一个命题必为真的含义，相当于自然语言中“如果…，那么…”的意思，由此得到的逻辑运算称为命题的“蕴涵”运算或者“条件”运算。该运算及其逻辑联结词的具体定义如下：  
【定义3.5】设 $P、 Q$ 是任意两个命题，复合命题$^{\prime\prime}P$ 蕴涵 $Q$ ”称为 $P$ 与 $Q$ 的蕴含式或蕴含运算，记作 $P\rightarrow Q$ ，其中符号$""~\rightarrow~""$称为蕴含联结词（简称为蕴含词），$P$ 称为蕴含式的前提或前件，   $Q$   称为蕴含式的结论或后件。 $P\rightarrow Q$   的真值为假，当且仅当   $P$ 为真且  $Q$ 为假。  
例如，若令 $P$ 表示“我喜欢唱歌”， $Q$表示“我喜欢跳舞”，则蕴涵式 $P\rightarrow Q$ 就表示复合命题“如果我喜欢唱歌，那么必然喜欢跳舞”。其中命题“我喜欢唱歌”是蕴含式的前提或前件，命题“我喜欢跳舞”是蕴含式的结论或后件。  
对于任意两个命题 $P$ 和 $Q$ ，蕴涵运算 $P\rightarrow Q$ 的真值取值规定如表3-2 第3 列所示。  
表${3 -2}\rightarrow,\ \leftrightarrow$的运算表
![](images/920c1058d83ec209cf5c8390304a73d783359e57457ba1d5a111c26950f592f9.jpg)  
由表3-2 可以看出，对于蕴涵运算 $P\rightarrow Q$ 的真值取值，只有当 $P$ 为真， $Q$ 为假时，$P\rightarrow Q$ 的真值才为假，在其余三种情况下 $P\rightarrow Q$ 的真值均为真。也就是说，当 $P$ 为为假时，无论 $Q$ 为真或者为假，$P\rightarrow Q$ 的真值均为真。  
其实，蕴含运算符$""{\rightarrow}""$既可表示充分条件，也可表示必要条件，关键是看哪个作为运算的前件，哪个作为运算的后件。具体地说，对于蕴涵式 $P\rightarrow Q$ ，具有如下结论：  
命题 $P$ 是命题 $Q$ 的充分条件，因为根据蕴涵式的含义有：若 $P$ 为真，则 $Q$ 必为真；  
命题 $Q$ 是命题 $P$ 的必要条件，因为根据蕴涵式的含义有：若 $Q$为假，则 $P$ 必为假。  
自然语言表达充分条件和必要条件的方式有很多种，实际使用的时候应注意区分。例如，若令 $P$ 表示命题“天气好”， $Q$ 表示命题“我去公园”，则对于如下4 个命题：  
（1）如果天气好，我就去公园；（2）只要天气好，我就去公园；  
（3）只有天气好，我才去公园；（4）仅当天气好，我才去公园。  
对于命题（1）2），$P$ 是 $Q$ 的充分条件，$Q$ 是 $P$ 的必要条件，可表示为 $P\rightarrow Q$；  
对于命题（3）4），$P$ 是 $Q$ 的必要条件，$Q$ 是 $P$ 的充分条件，可表示为 $Q\rightarrow P$ 。  
有时需要构造一个复合命题表示两个命题同时为真且同时为假的含义，相当于自然语言中“等价”、“当且仅当”的意思，由此得到的逻辑运算称为命题的“等价”运算或者“双蕴含”运算。该运算及其逻辑联结词的具体定义如下：  
【定义 3.6 】设   $P$ 、 $Q$   是任意两个命题，复合命题 “   $P$   等价   $Q$   ” 称为   $P$   与   $Q$   的等价 式或等价运算，有时也称为双蕴含运算，记作 $P\leftrightarrow Q$ ，其中符号$\leftrightarrow$称为等价联结词(简称为等价词)。$P\leftrightarrow Q$ 的取值为真，当且仅当 $P$ 与 $Q$具有相同的真值。  
例如，若令 $P$ 表示“我喜欢唱歌”，$Q$ 表示“我喜欢跳舞”，则等价式 $P\leftrightarrow Q$ 就表示复合命题“我喜欢唱歌当且仅当我喜欢跳舞”，或者“如果我喜欢唱歌，那么必然喜欢跳舞，并且如果我喜欢跳舞，那么必然喜欢唱歌”。  
对于任意两个命题 $P$ 和 $Q$ ，其等价运算$P\leftrightarrow Q$的真值取值情况如表3-2 第4 列所示。",蕴涵运算涉及两个命题之间的关系
等价运算,涉及,命题,,"有时候需要构造一个复合命题表示如果某个命题为真，那么另外一个命题必为真的含义，相当于自然语言中“如果…，那么…”的意思，由此得到的逻辑运算称为命题的“蕴涵”运算或者“条件”运算。该运算及其逻辑联结词的具体定义如下：  
【定义3.5】设 $P、 Q$ 是任意两个命题，复合命题$^{\prime\prime}P$ 蕴涵 $Q$ ”称为 $P$ 与 $Q$ 的蕴含式或蕴含运算，记作 $P\rightarrow Q$ ，其中符号$""~\rightarrow~""$称为蕴含联结词（简称为蕴含词），$P$ 称为蕴含式的前提或前件，   $Q$   称为蕴含式的结论或后件。 $P\rightarrow Q$   的真值为假，当且仅当   $P$ 为真且  $Q$ 为假。  
例如，若令 $P$ 表示“我喜欢唱歌”， $Q$表示“我喜欢跳舞”，则蕴涵式 $P\rightarrow Q$ 就表示复合命题“如果我喜欢唱歌，那么必然喜欢跳舞”。其中命题“我喜欢唱歌”是蕴含式的前提或前件，命题“我喜欢跳舞”是蕴含式的结论或后件。  
对于任意两个命题 $P$ 和 $Q$ ，蕴涵运算 $P\rightarrow Q$ 的真值取值规定如表3-2 第3 列所示。  
表${3 -2}\rightarrow,\ \leftrightarrow$的运算表
![](images/920c1058d83ec209cf5c8390304a73d783359e57457ba1d5a111c26950f592f9.jpg)  
由表3-2 可以看出，对于蕴涵运算 $P\rightarrow Q$ 的真值取值，只有当 $P$ 为真， $Q$ 为假时，$P\rightarrow Q$ 的真值才为假，在其余三种情况下 $P\rightarrow Q$ 的真值均为真。也就是说，当 $P$ 为为假时，无论 $Q$ 为真或者为假，$P\rightarrow Q$ 的真值均为真。  
其实，蕴含运算符$""{\rightarrow}""$既可表示充分条件，也可表示必要条件，关键是看哪个作为运算的前件，哪个作为运算的后件。具体地说，对于蕴涵式 $P\rightarrow Q$ ，具有如下结论：  
命题 $P$ 是命题 $Q$ 的充分条件，因为根据蕴涵式的含义有：若 $P$ 为真，则 $Q$ 必为真；  
命题 $Q$ 是命题 $P$ 的必要条件，因为根据蕴涵式的含义有：若 $Q$为假，则 $P$ 必为假。  
自然语言表达充分条件和必要条件的方式有很多种，实际使用的时候应注意区分。例如，若令 $P$ 表示命题“天气好”， $Q$ 表示命题“我去公园”，则对于如下4 个命题：  
（1）如果天气好，我就去公园；（2）只要天气好，我就去公园；  
（3）只有天气好，我才去公园；（4）仅当天气好，我才去公园。  
对于命题（1）2），$P$ 是 $Q$ 的充分条件，$Q$ 是 $P$ 的必要条件，可表示为 $P\rightarrow Q$；  
对于命题（3）4），$P$ 是 $Q$ 的必要条件，$Q$ 是 $P$ 的充分条件，可表示为 $Q\rightarrow P$ 。  
有时需要构造一个复合命题表示两个命题同时为真且同时为假的含义，相当于自然语言中“等价”、“当且仅当”的意思，由此得到的逻辑运算称为命题的“等价”运算或者“双蕴含”运算。该运算及其逻辑联结词的具体定义如下：  
【定义 3.6 】设   $P$ 、 $Q$   是任意两个命题，复合命题 “   $P$   等价   $Q$   ” 称为   $P$   与   $Q$   的等价 式或等价运算，有时也称为双蕴含运算，记作 $P\leftrightarrow Q$ ，其中符号$\leftrightarrow$称为等价联结词(简称为等价词)。$P\leftrightarrow Q$ 的取值为真，当且仅当 $P$ 与 $Q$具有相同的真值。  
例如，若令 $P$ 表示“我喜欢唱歌”，$Q$ 表示“我喜欢跳舞”，则等价式 $P\leftrightarrow Q$ 就表示复合命题“我喜欢唱歌当且仅当我喜欢跳舞”，或者“如果我喜欢唱歌，那么必然喜欢跳舞，并且如果我喜欢跳舞，那么必然喜欢唱歌”。  
对于任意两个命题 $P$ 和 $Q$ ，其等价运算$P\leftrightarrow Q$的真值取值情况如表3-2 第4 列所示。",等价运算涉及两个命题之间的关系
命题联结词,构成,命题运算,,"目前，我们学习了“否定”、 “合取”、 “析取”、 “蕴涵”和“等价”这5 个常用命题联结词，它们分别构成5 种不同的命题运算，其基本要点如表3-3 所示：  
表3-3  5 个常用命题联结词
![](images/cd7370ae4f3f6617837e091acd224e6d77723e30dcb7dd8be5213aea796aabec.jpg)  
![](images/8b3f0acea45c0f824a0da51d8118e72c060c29e3e9151811464ac93e02e86b47.jpg)  
通过这些命题运算联结词，就可用数学符号表示一些比较复杂的复合命题。例如，对于如下某计算机机房的一项规定：“凡进入机房者，必须换拖鞋、穿工作服，否则罚款人民币100 元。”可将其翻译成符号化的复合命题。  
为此，令$P$表示“某人进入机房”、 $Q$表示“某人换拖鞋、$R$表示“某人穿工作服”、 $S$表示“某人必须罚款100 元”，则此机房规则可表示为：$\neg(P\to(Q\land R))\ \to S$。",命题联结词如'否定'、'合取'、'析取'、'蕴涵'和'等价'分别构成不同的命题运算
命题公式,组成部分,命题代数,,前面我们学习了命题的基本概念及其若干常用的逻辑运算，要将这些概念和运算应用到计算机系统的设计与开发，必须对其用数学符号的方式进行形式化描述和处理，形成命题演算的数学表达式，使得命题逻辑能够像代数一样进行抽象的符号运算，建立一种命题代数。本节比较系统地介绍这种命题代数的基本理论，包括命题公式的基本概念、命题公式的解释与分类、命题公式的等值关系与等值演算、命题公式的内否式与对偶式等。,命题公式是命题代数的基本组成部分
命题公式,应用对象,等值演算,,前面我们学习了命题的基本概念及其若干常用的逻辑运算，要将这些概念和运算应用到计算机系统的设计与开发，必须对其用数学符号的方式进行形式化描述和处理，形成命题演算的数学表达式，使得命题逻辑能够像代数一样进行抽象的符号运算，建立一种命题代数。本节比较系统地介绍这种命题代数的基本理论，包括命题公式的基本概念、命题公式的解释与分类、命题公式的等值关系与等值演算、命题公式的内否式与对偶式等。,等值演算应用于命题公式，研究其等值关系
等值演算,理论内容,命题代数,,前面我们学习了命题的基本概念及其若干常用的逻辑运算，要将这些概念和运算应用到计算机系统的设计与开发，必须对其用数学符号的方式进行形式化描述和处理，形成命题演算的数学表达式，使得命题逻辑能够像代数一样进行抽象的符号运算，建立一种命题代数。本节比较系统地介绍这种命题代数的基本理论，包括命题公式的基本概念、命题公式的解释与分类、命题公式的等值关系与等值演算、命题公式的内否式与对偶式等。,等值演算是命题代数理论中的重要内容
命题公式,属于,命题代数,,运算表达式是代数运算的核心内容。命题代数中的运算表达式称为命题公式，相当于初等代数中的多项式。本小节介绍这种命题公式的基本知识，包括命题公式的概念及其归纳定义、命题公式的解释与真值表、命题公式的基本类型等。,命题公式是命题代数中的运算表达式
命题公式,相当于,初等代数,,运算表达式是代数运算的核心内容。命题代数中的运算表达式称为命题公式，相当于初等代数中的多项式。本小节介绍这种命题公式的基本知识，包括命题公式的概念及其归纳定义、命题公式的解释与真值表、命题公式的基本类型等。,命题公式在命题代数中的地位相当于初等代数中的多项式
命题变量,定义区分,命题常量,,"如前所述，可用大写英文字母作为标识符来表示命题。事实上，在具体的逻辑演算中，我们关注的重点往往是命题的真值取值状况而非命题的具体内容和含义。因此，可将作为命题标识符的字母符号取代具体的命题进行逻辑演算，由此形成一套形式化的符号逻辑代数演算系统。与初等代数中常量和变量的概念相类似，在这个系统中，对于一个给定的命题标识符，它不仅可用来特指某个具体的命题，成为命题常量，而且还可用于泛指一个任意的、没有具体内容的抽象命题，成为命题变量。命题常量和命题变量的具体定义如下：  
【定义3.7】如果一个命题标识符表示的是一个特定的、具有特定内容的具体命题，则称该标识符为命题常量；如果一个命题标识符表示的是一个泛指的、内容不确定的抽象命题，则称该标识符为命题变量。  
命题常量表示一个具体命题，其内容和真值都是确定的。因此，可将命题常量看成是一个命题。命题变量则表示任意一个命题，假定标识符𝑃是一个命题变量，则𝑃既可以表示“合肥是安徽的省会”，也可以表示“太阳从西方升起”，还可以表示其它任意命题。事实上，可以将命题变量理解成一个能够存放任意命题的空容器， 其含义随着容器中所存放具体命题的不 同而不同。因此，命题变量的真值取值是不确定的，不能将其看成命题。  
我们知道，复合命题是由原子命题经由联结词进行逻辑运算得到的命题。当复合命题中的原子命题变成命题变量时，该复合命题显然就变成了一种以这些命题变量为自变量的函数。由于这种函数的取值为或真或假的真值，故称这种函数为真值函数或命题公式。  
例如，下列表达式就是一些命题公式或真值函数：  
$$
P、 \neg(P\lor Q)、s\ (P\lor Q)\to R、\quad P\to(P\lor Q)
$$  
由此可知，命题公式或真值函数其实就是由表示命题变量的标识符和逻辑联结词构成的逻辑运算表达式。需要说明的是，命题公式之所以能够构成逻辑运算表达式，关键在于其能够根据逻辑联结词的含义进行运算，故此并不是由命题变量和标识符构成的任意字符串都能  
构成命题公式。例如，下列字符串都不是命题公式：  
$$
(P\lor Q)\to\lor\,\,(P\to Q)\to(\lor Q)\,,\,\,(P\to Q\setminus\,\,(P\to Q)\leftrightarrow
$$  
因此，必须要有一个严格的、具有可操作性的标准来区分哪些符号串是合法的命题公式，哪些字符串则不能构成命题公式。以下命题公式的归纳定义就确定了这个标准。  
【定义3.8】由表示命题变量的标识符、逻辑联结词和括弧构成的字符串称为命题演算的合式公式，又称为命题公式或真值函数，当且仅当它按下列4 条规则构造而成：  
（1）单个的命题变量是一个命题公式；  
（2）若𝐺是一个命题公式，则$(\neg G)$也是一个命题公式；  
（3）若𝐺, $H$是命题公式，则$(G\wedge H)$、$(G\lor H)$、$(G\to H)$)、$(G\leftrightarrow H)$)都是命题公式；  
（4）仅通过有限次使用规则（1）、（2）、（3）所得到的字符串才是命题公式。  
在上述定义中的四个规则确定了一个由所有命题公式为元素组成的集合，第（1）条规则决定了该集合为非空集合并确定了集合的初始元素，第（2）、（3）条规则则是根据集合中初始元素通过运算不断构造出新的元素，是集合的不断扩张的过程，第（4）条规则则是对集合的扩张进行了限制，给出了集合的边界，由此构成一个边界确定集合。这个集合就是命题函数的一种外延式定义。  
为书写简单起见，对命题公式中括弧使用和联结词运算优先级做如下约定：  
（1）命题公式中最外层的括弧可以省略；  
（2）5 种常用逻辑联结词的运算优先级从左到右按如下次序递减：
$$
\neg 、 \wedge 、 \vee 、 \rightarrow 、 \leftrightarrow
$$
例如，对于下列命题公式:
$$
(P \wedge(\neg Q)) 、(P \rightarrow Q) \rightarrow(Q \wedge(\neg R)) 、(P \vee(Q \wedge R)) \leftrightarrow(P \vee   (R \rightarrow \neg S)) 、(\neg Q) \rightarrow((P \wedge R) \rightarrow(\neg R \wedge Q))
$$
可分别将其简写为：  
$$
P\land\lnot Q\land\ {\cal P}\to Q\to Q\land\lnot R\land\ {\cal P}\lor Q\land R\leftrightarrow{\cal P}\lor(R\to\lnot S)\land\ \lnot Q\to P\land R\to\lnot R\lor Q
$$",命题变量表示泛指的、内容不确定的抽象命题，而命题常量表示特定的、具有特定内容的具体命题
命题变量,构成要素,命题公式,,"如前所述，可用大写英文字母作为标识符来表示命题。事实上，在具体的逻辑演算中，我们关注的重点往往是命题的真值取值状况而非命题的具体内容和含义。因此，可将作为命题标识符的字母符号取代具体的命题进行逻辑演算，由此形成一套形式化的符号逻辑代数演算系统。与初等代数中常量和变量的概念相类似，在这个系统中，对于一个给定的命题标识符，它不仅可用来特指某个具体的命题，成为命题常量，而且还可用于泛指一个任意的、没有具体内容的抽象命题，成为命题变量。命题常量和命题变量的具体定义如下：  
【定义3.7】如果一个命题标识符表示的是一个特定的、具有特定内容的具体命题，则称该标识符为命题常量；如果一个命题标识符表示的是一个泛指的、内容不确定的抽象命题，则称该标识符为命题变量。  
命题常量表示一个具体命题，其内容和真值都是确定的。因此，可将命题常量看成是一个命题。命题变量则表示任意一个命题，假定标识符𝑃是一个命题变量，则𝑃既可以表示“合肥是安徽的省会”，也可以表示“太阳从西方升起”，还可以表示其它任意命题。事实上，可以将命题变量理解成一个能够存放任意命题的空容器， 其含义随着容器中所存放具体命题的不 同而不同。因此，命题变量的真值取值是不确定的，不能将其看成命题。  
我们知道，复合命题是由原子命题经由联结词进行逻辑运算得到的命题。当复合命题中的原子命题变成命题变量时，该复合命题显然就变成了一种以这些命题变量为自变量的函数。由于这种函数的取值为或真或假的真值，故称这种函数为真值函数或命题公式。  
例如，下列表达式就是一些命题公式或真值函数：  
$$
P、 \neg(P\lor Q)、s\ (P\lor Q)\to R、\quad P\to(P\lor Q)
$$  
由此可知，命题公式或真值函数其实就是由表示命题变量的标识符和逻辑联结词构成的逻辑运算表达式。需要说明的是，命题公式之所以能够构成逻辑运算表达式，关键在于其能够根据逻辑联结词的含义进行运算，故此并不是由命题变量和标识符构成的任意字符串都能  
构成命题公式。例如，下列字符串都不是命题公式：  
$$
(P\lor Q)\to\lor\,\,(P\to Q)\to(\lor Q)\,,\,\,(P\to Q\setminus\,\,(P\to Q)\leftrightarrow
$$  
因此，必须要有一个严格的、具有可操作性的标准来区分哪些符号串是合法的命题公式，哪些字符串则不能构成命题公式。以下命题公式的归纳定义就确定了这个标准。  
【定义3.8】由表示命题变量的标识符、逻辑联结词和括弧构成的字符串称为命题演算的合式公式，又称为命题公式或真值函数，当且仅当它按下列4 条规则构造而成：  
（1）单个的命题变量是一个命题公式；  
（2）若𝐺是一个命题公式，则$(\neg G)$也是一个命题公式；  
（3）若𝐺, $H$是命题公式，则$(G\wedge H)$、$(G\lor H)$、$(G\to H)$)、$(G\leftrightarrow H)$)都是命题公式；  
（4）仅通过有限次使用规则（1）、（2）、（3）所得到的字符串才是命题公式。  
在上述定义中的四个规则确定了一个由所有命题公式为元素组成的集合，第（1）条规则决定了该集合为非空集合并确定了集合的初始元素，第（2）、（3）条规则则是根据集合中初始元素通过运算不断构造出新的元素，是集合的不断扩张的过程，第（4）条规则则是对集合的扩张进行了限制，给出了集合的边界，由此构成一个边界确定集合。这个集合就是命题函数的一种外延式定义。  
为书写简单起见，对命题公式中括弧使用和联结词运算优先级做如下约定：  
（1）命题公式中最外层的括弧可以省略；  
（2）5 种常用逻辑联结词的运算优先级从左到右按如下次序递减：
$$
\neg 、 \wedge 、 \vee 、 \rightarrow 、 \leftrightarrow
$$
例如，对于下列命题公式:
$$
(P \wedge(\neg Q)) 、(P \rightarrow Q) \rightarrow(Q \wedge(\neg R)) 、(P \vee(Q \wedge R)) \leftrightarrow(P \vee   (R \rightarrow \neg S)) 、(\neg Q) \rightarrow((P \wedge R) \rightarrow(\neg R \wedge Q))
$$
可分别将其简写为：  
$$
P\land\lnot Q\land\ {\cal P}\to Q\to Q\land\lnot R\land\ {\cal P}\lor Q\land R\leftrightarrow{\cal P}\lor(R\to\lnot S)\land\ \lnot Q\to P\land R\to\lnot R\lor Q
$$",命题公式是由表示命题变量的标识符和逻辑联结词构成的逻辑运算表达式
命题常量,应用场景,命题公式,,"如前所述，可用大写英文字母作为标识符来表示命题。事实上，在具体的逻辑演算中，我们关注的重点往往是命题的真值取值状况而非命题的具体内容和含义。因此，可将作为命题标识符的字母符号取代具体的命题进行逻辑演算，由此形成一套形式化的符号逻辑代数演算系统。与初等代数中常量和变量的概念相类似，在这个系统中，对于一个给定的命题标识符，它不仅可用来特指某个具体的命题，成为命题常量，而且还可用于泛指一个任意的、没有具体内容的抽象命题，成为命题变量。命题常量和命题变量的具体定义如下：  
【定义3.7】如果一个命题标识符表示的是一个特定的、具有特定内容的具体命题，则称该标识符为命题常量；如果一个命题标识符表示的是一个泛指的、内容不确定的抽象命题，则称该标识符为命题变量。  
命题常量表示一个具体命题，其内容和真值都是确定的。因此，可将命题常量看成是一个命题。命题变量则表示任意一个命题，假定标识符𝑃是一个命题变量，则𝑃既可以表示“合肥是安徽的省会”，也可以表示“太阳从西方升起”，还可以表示其它任意命题。事实上，可以将命题变量理解成一个能够存放任意命题的空容器， 其含义随着容器中所存放具体命题的不 同而不同。因此，命题变量的真值取值是不确定的，不能将其看成命题。  
我们知道，复合命题是由原子命题经由联结词进行逻辑运算得到的命题。当复合命题中的原子命题变成命题变量时，该复合命题显然就变成了一种以这些命题变量为自变量的函数。由于这种函数的取值为或真或假的真值，故称这种函数为真值函数或命题公式。  
例如，下列表达式就是一些命题公式或真值函数：  
$$
P、 \neg(P\lor Q)、s\ (P\lor Q)\to R、\quad P\to(P\lor Q)
$$  
由此可知，命题公式或真值函数其实就是由表示命题变量的标识符和逻辑联结词构成的逻辑运算表达式。需要说明的是，命题公式之所以能够构成逻辑运算表达式，关键在于其能够根据逻辑联结词的含义进行运算，故此并不是由命题变量和标识符构成的任意字符串都能  
构成命题公式。例如，下列字符串都不是命题公式：  
$$
(P\lor Q)\to\lor\,\,(P\to Q)\to(\lor Q)\,,\,\,(P\to Q\setminus\,\,(P\to Q)\leftrightarrow
$$  
因此，必须要有一个严格的、具有可操作性的标准来区分哪些符号串是合法的命题公式，哪些字符串则不能构成命题公式。以下命题公式的归纳定义就确定了这个标准。  
【定义3.8】由表示命题变量的标识符、逻辑联结词和括弧构成的字符串称为命题演算的合式公式，又称为命题公式或真值函数，当且仅当它按下列4 条规则构造而成：  
（1）单个的命题变量是一个命题公式；  
（2）若𝐺是一个命题公式，则$(\neg G)$也是一个命题公式；  
（3）若𝐺, $H$是命题公式，则$(G\wedge H)$、$(G\lor H)$、$(G\to H)$)、$(G\leftrightarrow H)$)都是命题公式；  
（4）仅通过有限次使用规则（1）、（2）、（3）所得到的字符串才是命题公式。  
在上述定义中的四个规则确定了一个由所有命题公式为元素组成的集合，第（1）条规则决定了该集合为非空集合并确定了集合的初始元素，第（2）、（3）条规则则是根据集合中初始元素通过运算不断构造出新的元素，是集合的不断扩张的过程，第（4）条规则则是对集合的扩张进行了限制，给出了集合的边界，由此构成一个边界确定集合。这个集合就是命题函数的一种外延式定义。  
为书写简单起见，对命题公式中括弧使用和联结词运算优先级做如下约定：  
（1）命题公式中最外层的括弧可以省略；  
（2）5 种常用逻辑联结词的运算优先级从左到右按如下次序递减：
$$
\neg 、 \wedge 、 \vee 、 \rightarrow 、 \leftrightarrow
$$
例如，对于下列命题公式:
$$
(P \wedge(\neg Q)) 、(P \rightarrow Q) \rightarrow(Q \wedge(\neg R)) 、(P \vee(Q \wedge R)) \leftrightarrow(P \vee   (R \rightarrow \neg S)) 、(\neg Q) \rightarrow((P \wedge R) \rightarrow(\neg R \wedge Q))
$$
可分别将其简写为：  
$$
P\land\lnot Q\land\ {\cal P}\to Q\to Q\land\lnot R\land\ {\cal P}\lor Q\land R\leftrightarrow{\cal P}\lor(R\to\lnot S)\land\ \lnot Q\to P\land R\to\lnot R\lor Q
$$",命题常量作为具体命题在命题公式中表示确定的真值
命题公式,等价关系,合式公式,,"如前所述，可用大写英文字母作为标识符来表示命题。事实上，在具体的逻辑演算中，我们关注的重点往往是命题的真值取值状况而非命题的具体内容和含义。因此，可将作为命题标识符的字母符号取代具体的命题进行逻辑演算，由此形成一套形式化的符号逻辑代数演算系统。与初等代数中常量和变量的概念相类似，在这个系统中，对于一个给定的命题标识符，它不仅可用来特指某个具体的命题，成为命题常量，而且还可用于泛指一个任意的、没有具体内容的抽象命题，成为命题变量。命题常量和命题变量的具体定义如下：  
【定义3.7】如果一个命题标识符表示的是一个特定的、具有特定内容的具体命题，则称该标识符为命题常量；如果一个命题标识符表示的是一个泛指的、内容不确定的抽象命题，则称该标识符为命题变量。  
命题常量表示一个具体命题，其内容和真值都是确定的。因此，可将命题常量看成是一个命题。命题变量则表示任意一个命题，假定标识符𝑃是一个命题变量，则𝑃既可以表示“合肥是安徽的省会”，也可以表示“太阳从西方升起”，还可以表示其它任意命题。事实上，可以将命题变量理解成一个能够存放任意命题的空容器， 其含义随着容器中所存放具体命题的不 同而不同。因此，命题变量的真值取值是不确定的，不能将其看成命题。  
我们知道，复合命题是由原子命题经由联结词进行逻辑运算得到的命题。当复合命题中的原子命题变成命题变量时，该复合命题显然就变成了一种以这些命题变量为自变量的函数。由于这种函数的取值为或真或假的真值，故称这种函数为真值函数或命题公式。  
例如，下列表达式就是一些命题公式或真值函数：  
$$
P、 \neg(P\lor Q)、s\ (P\lor Q)\to R、\quad P\to(P\lor Q)
$$  
由此可知，命题公式或真值函数其实就是由表示命题变量的标识符和逻辑联结词构成的逻辑运算表达式。需要说明的是，命题公式之所以能够构成逻辑运算表达式，关键在于其能够根据逻辑联结词的含义进行运算，故此并不是由命题变量和标识符构成的任意字符串都能  
构成命题公式。例如，下列字符串都不是命题公式：  
$$
(P\lor Q)\to\lor\,\,(P\to Q)\to(\lor Q)\,,\,\,(P\to Q\setminus\,\,(P\to Q)\leftrightarrow
$$  
因此，必须要有一个严格的、具有可操作性的标准来区分哪些符号串是合法的命题公式，哪些字符串则不能构成命题公式。以下命题公式的归纳定义就确定了这个标准。  
【定义3.8】由表示命题变量的标识符、逻辑联结词和括弧构成的字符串称为命题演算的合式公式，又称为命题公式或真值函数，当且仅当它按下列4 条规则构造而成：  
（1）单个的命题变量是一个命题公式；  
（2）若𝐺是一个命题公式，则$(\neg G)$也是一个命题公式；  
（3）若𝐺, $H$是命题公式，则$(G\wedge H)$、$(G\lor H)$、$(G\to H)$)、$(G\leftrightarrow H)$)都是命题公式；  
（4）仅通过有限次使用规则（1）、（2）、（3）所得到的字符串才是命题公式。  
在上述定义中的四个规则确定了一个由所有命题公式为元素组成的集合，第（1）条规则决定了该集合为非空集合并确定了集合的初始元素，第（2）、（3）条规则则是根据集合中初始元素通过运算不断构造出新的元素，是集合的不断扩张的过程，第（4）条规则则是对集合的扩张进行了限制，给出了集合的边界，由此构成一个边界确定集合。这个集合就是命题函数的一种外延式定义。  
为书写简单起见，对命题公式中括弧使用和联结词运算优先级做如下约定：  
（1）命题公式中最外层的括弧可以省略；  
（2）5 种常用逻辑联结词的运算优先级从左到右按如下次序递减：
$$
\neg 、 \wedge 、 \vee 、 \rightarrow 、 \leftrightarrow
$$
例如，对于下列命题公式:
$$
(P \wedge(\neg Q)) 、(P \rightarrow Q) \rightarrow(Q \wedge(\neg R)) 、(P \vee(Q \wedge R)) \leftrightarrow(P \vee   (R \rightarrow \neg S)) 、(\neg Q) \rightarrow((P \wedge R) \rightarrow(\neg R \wedge Q))
$$
可分别将其简写为：  
$$
P\land\lnot Q\land\ {\cal P}\to Q\to Q\land\lnot R\land\ {\cal P}\lor Q\land R\leftrightarrow{\cal P}\lor(R\to\lnot S)\land\ \lnot Q\to P\land R\to\lnot R\lor Q
$$",命题公式又称合式公式，是由命题变量、逻辑联结词和括弧按特定规则构成的字符串
命题公式,定义,解释或赋值,,"命题公式是由命题变量、，其中命题变量泛指的无确定真值的、抽象的命题。因此，命题公式一般没有确定的真值。但是，如果对命题公式中每个命题变量分别指定确定真值的具体命题，那么命题公式就变成一个具有确定真值的复合命题。由此得到如下关于命题公式解释或赋值的概念：  
【定义3.9】设$P_{1},P_{2},\cdots,P_{n}$是出现在命题公式$G$中所有命题变量，对$P_{1},P_{2},\cdots,P_{n}$分别指定真值，由此得到的一组真值称为命题公式$G$的一个解释或赋值，通常记为$\smash{I_{\circ}}$。  
命题公式中的每个变量都有𝑇和$F$两种真值指定方式，对于$\cdot n$个命题变量的公式就有$\cdot2^{n}$个不同解释。例如，含2 个命题变量公式有4 种不同解释，含有3 个变量公式有8 种不同解释。命题公式在每种解释下都会有相应的真值取值，由此可得如下定义：  
【定义3.10】对于任意一个给定的命题公式$G$，如果该命题公式在某种解释下的真值取值为真，则称该解释为$G$的成真赋值或弄真赋值；如果该命题公式在某种解释下的真值取值为假，则称该解释为$G$的成假赋值或弄假赋值。  
为直观表达命题公式在不同解释下的取值状态，在变量不太多的情况下，可将命题公式在所有不同解释下的取值状态枚举出来，做成一个表格。由此得到如下真值表的概念：  
【定义3.11】对于任意一个含有$\cdot_{n}$个命题变量的命题公式$G$，$G$的所有解释以及在每个解释下真值取值所构成的表格称为$G$的真值表。  
在真值表中，一般将命题公式中的命题变量放在最左边，将命题公式在解释下的真值取值结果放在右边并加粗表示。对于比较复杂的公式，通常将计算命题公式真值的中间结果依次放在表中，或者中间结果放在相关逻辑联结词的下方。此外，为节约篇幅，通常将含有相同命题变量个数的多个命题公式真值取值结果合并到一个真值表中。  
表3-4  例题3.11 的真值表
![](images/b78e9e94318e03b09f7351596ca332bf194681eedad2d1334bdc1ed7b6f02552.jpg)",命题公式通过对其中的命题变量指定真值得到解释或赋值
命题公式,结果,成真赋值,,"命题公式是由命题变量、，其中命题变量泛指的无确定真值的、抽象的命题。因此，命题公式一般没有确定的真值。但是，如果对命题公式中每个命题变量分别指定确定真值的具体命题，那么命题公式就变成一个具有确定真值的复合命题。由此得到如下关于命题公式解释或赋值的概念：  
【定义3.9】设$P_{1},P_{2},\cdots,P_{n}$是出现在命题公式$G$中所有命题变量，对$P_{1},P_{2},\cdots,P_{n}$分别指定真值，由此得到的一组真值称为命题公式$G$的一个解释或赋值，通常记为$\smash{I_{\circ}}$。  
命题公式中的每个变量都有𝑇和$F$两种真值指定方式，对于$\cdot n$个命题变量的公式就有$\cdot2^{n}$个不同解释。例如，含2 个命题变量公式有4 种不同解释，含有3 个变量公式有8 种不同解释。命题公式在每种解释下都会有相应的真值取值，由此可得如下定义：  
【定义3.10】对于任意一个给定的命题公式$G$，如果该命题公式在某种解释下的真值取值为真，则称该解释为$G$的成真赋值或弄真赋值；如果该命题公式在某种解释下的真值取值为假，则称该解释为$G$的成假赋值或弄假赋值。  
为直观表达命题公式在不同解释下的取值状态，在变量不太多的情况下，可将命题公式在所有不同解释下的取值状态枚举出来，做成一个表格。由此得到如下真值表的概念：  
【定义3.11】对于任意一个含有$\cdot_{n}$个命题变量的命题公式$G$，$G$的所有解释以及在每个解释下真值取值所构成的表格称为$G$的真值表。  
在真值表中，一般将命题公式中的命题变量放在最左边，将命题公式在解释下的真值取值结果放在右边并加粗表示。对于比较复杂的公式，通常将计算命题公式真值的中间结果依次放在表中，或者中间结果放在相关逻辑联结词的下方。此外，为节约篇幅，通常将含有相同命题变量个数的多个命题公式真值取值结果合并到一个真值表中。  
表3-4  例题3.11 的真值表
![](images/b78e9e94318e03b09f7351596ca332bf194681eedad2d1334bdc1ed7b6f02552.jpg)",命题公式在某种解释下真值取值为真时，该解释称为成真赋值
命题公式,结果,成假赋值,,"命题公式是由命题变量、，其中命题变量泛指的无确定真值的、抽象的命题。因此，命题公式一般没有确定的真值。但是，如果对命题公式中每个命题变量分别指定确定真值的具体命题，那么命题公式就变成一个具有确定真值的复合命题。由此得到如下关于命题公式解释或赋值的概念：  
【定义3.9】设$P_{1},P_{2},\cdots,P_{n}$是出现在命题公式$G$中所有命题变量，对$P_{1},P_{2},\cdots,P_{n}$分别指定真值，由此得到的一组真值称为命题公式$G$的一个解释或赋值，通常记为$\smash{I_{\circ}}$。  
命题公式中的每个变量都有𝑇和$F$两种真值指定方式，对于$\cdot n$个命题变量的公式就有$\cdot2^{n}$个不同解释。例如，含2 个命题变量公式有4 种不同解释，含有3 个变量公式有8 种不同解释。命题公式在每种解释下都会有相应的真值取值，由此可得如下定义：  
【定义3.10】对于任意一个给定的命题公式$G$，如果该命题公式在某种解释下的真值取值为真，则称该解释为$G$的成真赋值或弄真赋值；如果该命题公式在某种解释下的真值取值为假，则称该解释为$G$的成假赋值或弄假赋值。  
为直观表达命题公式在不同解释下的取值状态，在变量不太多的情况下，可将命题公式在所有不同解释下的取值状态枚举出来，做成一个表格。由此得到如下真值表的概念：  
【定义3.11】对于任意一个含有$\cdot_{n}$个命题变量的命题公式$G$，$G$的所有解释以及在每个解释下真值取值所构成的表格称为$G$的真值表。  
在真值表中，一般将命题公式中的命题变量放在最左边，将命题公式在解释下的真值取值结果放在右边并加粗表示。对于比较复杂的公式，通常将计算命题公式真值的中间结果依次放在表中，或者中间结果放在相关逻辑联结词的下方。此外，为节约篇幅，通常将含有相同命题变量个数的多个命题公式真值取值结果合并到一个真值表中。  
表3-4  例题3.11 的真值表
![](images/b78e9e94318e03b09f7351596ca332bf194681eedad2d1334bdc1ed7b6f02552.jpg)",命题公式在某种解释下真值取值为假时，该解释称为成假赋值
命题公式,构成,真值表,,"命题公式是由命题变量、，其中命题变量泛指的无确定真值的、抽象的命题。因此，命题公式一般没有确定的真值。但是，如果对命题公式中每个命题变量分别指定确定真值的具体命题，那么命题公式就变成一个具有确定真值的复合命题。由此得到如下关于命题公式解释或赋值的概念：  
【定义3.9】设$P_{1},P_{2},\cdots,P_{n}$是出现在命题公式$G$中所有命题变量，对$P_{1},P_{2},\cdots,P_{n}$分别指定真值，由此得到的一组真值称为命题公式$G$的一个解释或赋值，通常记为$\smash{I_{\circ}}$。  
命题公式中的每个变量都有𝑇和$F$两种真值指定方式，对于$\cdot n$个命题变量的公式就有$\cdot2^{n}$个不同解释。例如，含2 个命题变量公式有4 种不同解释，含有3 个变量公式有8 种不同解释。命题公式在每种解释下都会有相应的真值取值，由此可得如下定义：  
【定义3.10】对于任意一个给定的命题公式$G$，如果该命题公式在某种解释下的真值取值为真，则称该解释为$G$的成真赋值或弄真赋值；如果该命题公式在某种解释下的真值取值为假，则称该解释为$G$的成假赋值或弄假赋值。  
为直观表达命题公式在不同解释下的取值状态，在变量不太多的情况下，可将命题公式在所有不同解释下的取值状态枚举出来，做成一个表格。由此得到如下真值表的概念：  
【定义3.11】对于任意一个含有$\cdot_{n}$个命题变量的命题公式$G$，$G$的所有解释以及在每个解释下真值取值所构成的表格称为$G$的真值表。  
在真值表中，一般将命题公式中的命题变量放在最左边，将命题公式在解释下的真值取值结果放在右边并加粗表示。对于比较复杂的公式，通常将计算命题公式真值的中间结果依次放在表中，或者中间结果放在相关逻辑联结词的下方。此外，为节约篇幅，通常将含有相同命题变量个数的多个命题公式真值取值结果合并到一个真值表中。  
表3-4  例题3.11 的真值表
![](images/b78e9e94318e03b09f7351596ca332bf194681eedad2d1334bdc1ed7b6f02552.jpg)",命题公式在所有不同解释下的真值取值所构成的表格称为真值表
解释或赋值,分类,成真赋值,,"命题公式是由命题变量、，其中命题变量泛指的无确定真值的、抽象的命题。因此，命题公式一般没有确定的真值。但是，如果对命题公式中每个命题变量分别指定确定真值的具体命题，那么命题公式就变成一个具有确定真值的复合命题。由此得到如下关于命题公式解释或赋值的概念：  
【定义3.9】设$P_{1},P_{2},\cdots,P_{n}$是出现在命题公式$G$中所有命题变量，对$P_{1},P_{2},\cdots,P_{n}$分别指定真值，由此得到的一组真值称为命题公式$G$的一个解释或赋值，通常记为$\smash{I_{\circ}}$。  
命题公式中的每个变量都有𝑇和$F$两种真值指定方式，对于$\cdot n$个命题变量的公式就有$\cdot2^{n}$个不同解释。例如，含2 个命题变量公式有4 种不同解释，含有3 个变量公式有8 种不同解释。命题公式在每种解释下都会有相应的真值取值，由此可得如下定义：  
【定义3.10】对于任意一个给定的命题公式$G$，如果该命题公式在某种解释下的真值取值为真，则称该解释为$G$的成真赋值或弄真赋值；如果该命题公式在某种解释下的真值取值为假，则称该解释为$G$的成假赋值或弄假赋值。  
为直观表达命题公式在不同解释下的取值状态，在变量不太多的情况下，可将命题公式在所有不同解释下的取值状态枚举出来，做成一个表格。由此得到如下真值表的概念：  
【定义3.11】对于任意一个含有$\cdot_{n}$个命题变量的命题公式$G$，$G$的所有解释以及在每个解释下真值取值所构成的表格称为$G$的真值表。  
在真值表中，一般将命题公式中的命题变量放在最左边，将命题公式在解释下的真值取值结果放在右边并加粗表示。对于比较复杂的公式，通常将计算命题公式真值的中间结果依次放在表中，或者中间结果放在相关逻辑联结词的下方。此外，为节约篇幅，通常将含有相同命题变量个数的多个命题公式真值取值结果合并到一个真值表中。  
表3-4  例题3.11 的真值表
![](images/b78e9e94318e03b09f7351596ca332bf194681eedad2d1334bdc1ed7b6f02552.jpg)",解释或赋值中使命题公式真值取值为真的称为成真赋值
解释或赋值,分类,成假赋值,,"命题公式是由命题变量、，其中命题变量泛指的无确定真值的、抽象的命题。因此，命题公式一般没有确定的真值。但是，如果对命题公式中每个命题变量分别指定确定真值的具体命题，那么命题公式就变成一个具有确定真值的复合命题。由此得到如下关于命题公式解释或赋值的概念：  
【定义3.9】设$P_{1},P_{2},\cdots,P_{n}$是出现在命题公式$G$中所有命题变量，对$P_{1},P_{2},\cdots,P_{n}$分别指定真值，由此得到的一组真值称为命题公式$G$的一个解释或赋值，通常记为$\smash{I_{\circ}}$。  
命题公式中的每个变量都有𝑇和$F$两种真值指定方式，对于$\cdot n$个命题变量的公式就有$\cdot2^{n}$个不同解释。例如，含2 个命题变量公式有4 种不同解释，含有3 个变量公式有8 种不同解释。命题公式在每种解释下都会有相应的真值取值，由此可得如下定义：  
【定义3.10】对于任意一个给定的命题公式$G$，如果该命题公式在某种解释下的真值取值为真，则称该解释为$G$的成真赋值或弄真赋值；如果该命题公式在某种解释下的真值取值为假，则称该解释为$G$的成假赋值或弄假赋值。  
为直观表达命题公式在不同解释下的取值状态，在变量不太多的情况下，可将命题公式在所有不同解释下的取值状态枚举出来，做成一个表格。由此得到如下真值表的概念：  
【定义3.11】对于任意一个含有$\cdot_{n}$个命题变量的命题公式$G$，$G$的所有解释以及在每个解释下真值取值所构成的表格称为$G$的真值表。  
在真值表中，一般将命题公式中的命题变量放在最左边，将命题公式在解释下的真值取值结果放在右边并加粗表示。对于比较复杂的公式，通常将计算命题公式真值的中间结果依次放在表中，或者中间结果放在相关逻辑联结词的下方。此外，为节约篇幅，通常将含有相同命题变量个数的多个命题公式真值取值结果合并到一个真值表中。  
表3-4  例题3.11 的真值表
![](images/b78e9e94318e03b09f7351596ca332bf194681eedad2d1334bdc1ed7b6f02552.jpg)",解释或赋值中使命题公式真值取值为假的称为成假赋值
解释或赋值,包含,真值表,,"命题公式是由命题变量、，其中命题变量泛指的无确定真值的、抽象的命题。因此，命题公式一般没有确定的真值。但是，如果对命题公式中每个命题变量分别指定确定真值的具体命题，那么命题公式就变成一个具有确定真值的复合命题。由此得到如下关于命题公式解释或赋值的概念：  
【定义3.9】设$P_{1},P_{2},\cdots,P_{n}$是出现在命题公式$G$中所有命题变量，对$P_{1},P_{2},\cdots,P_{n}$分别指定真值，由此得到的一组真值称为命题公式$G$的一个解释或赋值，通常记为$\smash{I_{\circ}}$。  
命题公式中的每个变量都有𝑇和$F$两种真值指定方式，对于$\cdot n$个命题变量的公式就有$\cdot2^{n}$个不同解释。例如，含2 个命题变量公式有4 种不同解释，含有3 个变量公式有8 种不同解释。命题公式在每种解释下都会有相应的真值取值，由此可得如下定义：  
【定义3.10】对于任意一个给定的命题公式$G$，如果该命题公式在某种解释下的真值取值为真，则称该解释为$G$的成真赋值或弄真赋值；如果该命题公式在某种解释下的真值取值为假，则称该解释为$G$的成假赋值或弄假赋值。  
为直观表达命题公式在不同解释下的取值状态，在变量不太多的情况下，可将命题公式在所有不同解释下的取值状态枚举出来，做成一个表格。由此得到如下真值表的概念：  
【定义3.11】对于任意一个含有$\cdot_{n}$个命题变量的命题公式$G$，$G$的所有解释以及在每个解释下真值取值所构成的表格称为$G$的真值表。  
在真值表中，一般将命题公式中的命题变量放在最左边，将命题公式在解释下的真值取值结果放在右边并加粗表示。对于比较复杂的公式，通常将计算命题公式真值的中间结果依次放在表中，或者中间结果放在相关逻辑联结词的下方。此外，为节约篇幅，通常将含有相同命题变量个数的多个命题公式真值取值结果合并到一个真值表中。  
表3-4  例题3.11 的真值表
![](images/b78e9e94318e03b09f7351596ca332bf194681eedad2d1334bdc1ed7b6f02552.jpg)",真值表包含命题公式的所有解释及其对应的真值取值
命题公式,分类,永真公式,,"如表3-7 所示，有些命题公式在任何解释下均为真，例如 $(P\land(P\rightarrow Q))\rightarrow Q$；有些命题公式则在任何解释下均为假，例如$\neg(P\to Q)\land Q$；有些命题公式则在一些解释下为真、在另一些解释下为假，例如$P\rightarrow Q$。  
表3-7   命题公式真值的基本类型
![](images/ada5d39d23c2aab3e5ff74aa9eea0cba51046190f43c79f376715f46f49cb38f.jpg)  
![](images/cd9a8308cc683710575b4eca9243b69a0a582e5f86c663d5bdcde36ca15c8940.jpg)  
由此可将命题公式分为永真、永假和可满足这三种基本类型，具体定义如下：  
【定义3.12】对于任给定的命题公式$G$  
（1）如果$G$在所有解释下的真值取值都为真，则称其为永真公式或重言式；  
（2）如果$G$在所有解释下的真值取值都为假，则称其为永假公式或矛盾式；  
（3）如果命题公式不是矛盾式，则称其为可满足式。  
根据上述定义，不难看出这三类公式之间的基本关系：  
（1）命题公式$G$为永真式，当且仅当¬G为永假式。  
（2）若命题公式$G$为永真式，则𝐺必为可满足式；反之不然。  
（3）若命题公式$G$为可满足式，当且仅当至少存在一种解释$I$，使得$G$为真。",命题公式在所有解释下真值都为真时，称为永真公式
命题公式,分类,永假公式,,"如表3-7 所示，有些命题公式在任何解释下均为真，例如 $(P\land(P\rightarrow Q))\rightarrow Q$；有些命题公式则在任何解释下均为假，例如$\neg(P\to Q)\land Q$；有些命题公式则在一些解释下为真、在另一些解释下为假，例如$P\rightarrow Q$。  
表3-7   命题公式真值的基本类型
![](images/ada5d39d23c2aab3e5ff74aa9eea0cba51046190f43c79f376715f46f49cb38f.jpg)  
![](images/cd9a8308cc683710575b4eca9243b69a0a582e5f86c663d5bdcde36ca15c8940.jpg)  
由此可将命题公式分为永真、永假和可满足这三种基本类型，具体定义如下：  
【定义3.12】对于任给定的命题公式$G$  
（1）如果$G$在所有解释下的真值取值都为真，则称其为永真公式或重言式；  
（2）如果$G$在所有解释下的真值取值都为假，则称其为永假公式或矛盾式；  
（3）如果命题公式不是矛盾式，则称其为可满足式。  
根据上述定义，不难看出这三类公式之间的基本关系：  
（1）命题公式$G$为永真式，当且仅当¬G为永假式。  
（2）若命题公式$G$为永真式，则𝐺必为可满足式；反之不然。  
（3）若命题公式$G$为可满足式，当且仅当至少存在一种解释$I$，使得$G$为真。",命题公式在所有解释下真值都为假时，称为永假公式
命题公式,分类,可满足式,,"如表3-7 所示，有些命题公式在任何解释下均为真，例如 $(P\land(P\rightarrow Q))\rightarrow Q$；有些命题公式则在任何解释下均为假，例如$\neg(P\to Q)\land Q$；有些命题公式则在一些解释下为真、在另一些解释下为假，例如$P\rightarrow Q$。  
表3-7   命题公式真值的基本类型
![](images/ada5d39d23c2aab3e5ff74aa9eea0cba51046190f43c79f376715f46f49cb38f.jpg)  
![](images/cd9a8308cc683710575b4eca9243b69a0a582e5f86c663d5bdcde36ca15c8940.jpg)  
由此可将命题公式分为永真、永假和可满足这三种基本类型，具体定义如下：  
【定义3.12】对于任给定的命题公式$G$  
（1）如果$G$在所有解释下的真值取值都为真，则称其为永真公式或重言式；  
（2）如果$G$在所有解释下的真值取值都为假，则称其为永假公式或矛盾式；  
（3）如果命题公式不是矛盾式，则称其为可满足式。  
根据上述定义，不难看出这三类公式之间的基本关系：  
（1）命题公式$G$为永真式，当且仅当¬G为永假式。  
（2）若命题公式$G$为永真式，则𝐺必为可满足式；反之不然。  
（3）若命题公式$G$为可满足式，当且仅当至少存在一种解释$I$，使得$G$为真。",命题公式不是永假公式时，称为可满足式
永真公式,互斥,永假公式,,"如表3-7 所示，有些命题公式在任何解释下均为真，例如 $(P\land(P\rightarrow Q))\rightarrow Q$；有些命题公式则在任何解释下均为假，例如$\neg(P\to Q)\land Q$；有些命题公式则在一些解释下为真、在另一些解释下为假，例如$P\rightarrow Q$。  
表3-7   命题公式真值的基本类型
![](images/ada5d39d23c2aab3e5ff74aa9eea0cba51046190f43c79f376715f46f49cb38f.jpg)  
![](images/cd9a8308cc683710575b4eca9243b69a0a582e5f86c663d5bdcde36ca15c8940.jpg)  
由此可将命题公式分为永真、永假和可满足这三种基本类型，具体定义如下：  
【定义3.12】对于任给定的命题公式$G$  
（1）如果$G$在所有解释下的真值取值都为真，则称其为永真公式或重言式；  
（2）如果$G$在所有解释下的真值取值都为假，则称其为永假公式或矛盾式；  
（3）如果命题公式不是矛盾式，则称其为可满足式。  
根据上述定义，不难看出这三类公式之间的基本关系：  
（1）命题公式$G$为永真式，当且仅当¬G为永假式。  
（2）若命题公式$G$为永真式，则𝐺必为可满足式；反之不然。  
（3）若命题公式$G$为可满足式，当且仅当至少存在一种解释$I$，使得$G$为真。",命题公式为永真公式时，其否定为永假公式
永真公式,包含,可满足式,,"如表3-7 所示，有些命题公式在任何解释下均为真，例如 $(P\land(P\rightarrow Q))\rightarrow Q$；有些命题公式则在任何解释下均为假，例如$\neg(P\to Q)\land Q$；有些命题公式则在一些解释下为真、在另一些解释下为假，例如$P\rightarrow Q$。  
表3-7   命题公式真值的基本类型
![](images/ada5d39d23c2aab3e5ff74aa9eea0cba51046190f43c79f376715f46f49cb38f.jpg)  
![](images/cd9a8308cc683710575b4eca9243b69a0a582e5f86c663d5bdcde36ca15c8940.jpg)  
由此可将命题公式分为永真、永假和可满足这三种基本类型，具体定义如下：  
【定义3.12】对于任给定的命题公式$G$  
（1）如果$G$在所有解释下的真值取值都为真，则称其为永真公式或重言式；  
（2）如果$G$在所有解释下的真值取值都为假，则称其为永假公式或矛盾式；  
（3）如果命题公式不是矛盾式，则称其为可满足式。  
根据上述定义，不难看出这三类公式之间的基本关系：  
（1）命题公式$G$为永真式，当且仅当¬G为永假式。  
（2）若命题公式$G$为永真式，则𝐺必为可满足式；反之不然。  
（3）若命题公式$G$为可满足式，当且仅当至少存在一种解释$I$，使得$G$为真。",永真公式必为可满足式，但可满足式不一定是永真公式
可满足式,互斥,永假公式,,"如表3-7 所示，有些命题公式在任何解释下均为真，例如 $(P\land(P\rightarrow Q))\rightarrow Q$；有些命题公式则在任何解释下均为假，例如$\neg(P\to Q)\land Q$；有些命题公式则在一些解释下为真、在另一些解释下为假，例如$P\rightarrow Q$。  
表3-7   命题公式真值的基本类型
![](images/ada5d39d23c2aab3e5ff74aa9eea0cba51046190f43c79f376715f46f49cb38f.jpg)  
![](images/cd9a8308cc683710575b4eca9243b69a0a582e5f86c663d5bdcde36ca15c8940.jpg)  
由此可将命题公式分为永真、永假和可满足这三种基本类型，具体定义如下：  
【定义3.12】对于任给定的命题公式$G$  
（1）如果$G$在所有解释下的真值取值都为真，则称其为永真公式或重言式；  
（2）如果$G$在所有解释下的真值取值都为假，则称其为永假公式或矛盾式；  
（3）如果命题公式不是矛盾式，则称其为可满足式。  
根据上述定义，不难看出这三类公式之间的基本关系：  
（1）命题公式$G$为永真式，当且仅当¬G为永假式。  
（2）若命题公式$G$为永真式，则𝐺必为可满足式；反之不然。  
（3）若命题公式$G$为可满足式，当且仅当至少存在一种解释$I$，使得$G$为真。",可满足式至少存在一种解释使其为真，而永假公式在所有解释下都为假
命题公式等值关系,类似,多项式恒等,,"在中学学习多项式的时候，多项式的恒等是一个非常重要的概念。所谓两个多项式恒等，就是这两个多项式的值在变量的任何赋值情况下始终保持一致。在初等代数中，通常利用多项式恒等的概念进行恒等变形或代数演算。在命题逻辑中，同样需要一种类似于命题公式恒  
等的概念进行命题公式的演算和推理，这就是命题公式的等值关系。",命题公式等值关系在命题逻辑中的作用类似于多项式恒等在初等代数中的作用，用于命题公式的演算和推理
等值关系,判断方法,等值演算,,"【定义3.13】𝐴、$B$是含命题变元$P_{1},P_{2},\dots,P_{n}$的公式，如不论对$P_{1},P_{2},\dots,P_{n}$作何种真值指派，都使得𝐴和$B$的真值相同，则称命题公式$A$与$B$等价或等值，记为$A=B$或$A\Leftrightarrow B$。  
判断两个命题公式是否等值，最直观的方法就是将这两个公式的真值表列出，然后看看两者的取值是否一致。  
【定理3.1】对于命题公式$𝐴$和$B$，$A\Leftrightarrow B$的充分必要条件是公式$A\leftrightarrow B\Leftrightarrow T$  
【定理3.2】命题公式的等值满足如下三条性质：  
自反性：即对任意命题公式$𝐴$，$A=A$；  
对称性：即对任意命题公式𝐴和$B$，若$A\Leftrightarrow B$，则$B=A$；  
传递性：即对任意命题公式 𝐴 ， $B$ 和 $C$ ，若 $A\Leftrightarrow B$ ， $B\Leftrightarrow C$ ，则 $A\Leftrightarrow C$",等值演算通过列出真值表来判断两个命题公式是否具有等值关系
等值关系,定义,等值关系的充分必要条件,,"【定义3.13】𝐴、$B$是含命题变元$P_{1},P_{2},\dots,P_{n}$的公式，如不论对$P_{1},P_{2},\dots,P_{n}$作何种真值指派，都使得𝐴和$B$的真值相同，则称命题公式$A$与$B$等价或等值，记为$A=B$或$A\Leftrightarrow B$。  
判断两个命题公式是否等值，最直观的方法就是将这两个公式的真值表列出，然后看看两者的取值是否一致。  
【定理3.1】对于命题公式$𝐴$和$B$，$A\Leftrightarrow B$的充分必要条件是公式$A\leftrightarrow B\Leftrightarrow T$  
【定理3.2】命题公式的等值满足如下三条性质：  
自反性：即对任意命题公式$𝐴$，$A=A$；  
对称性：即对任意命题公式𝐴和$B$，若$A\Leftrightarrow B$，则$B=A$；  
传递性：即对任意命题公式 𝐴 ， $B$ 和 $C$ ，若 $A\Leftrightarrow B$ ， $B\Leftrightarrow C$ ，则 $A\Leftrightarrow C$",等值关系的充分必要条件是公式A↔B↔T
等值关系,满足,等值关系的性质,,"【定义3.13】𝐴、$B$是含命题变元$P_{1},P_{2},\dots,P_{n}$的公式，如不论对$P_{1},P_{2},\dots,P_{n}$作何种真值指派，都使得𝐴和$B$的真值相同，则称命题公式$A$与$B$等价或等值，记为$A=B$或$A\Leftrightarrow B$。  
判断两个命题公式是否等值，最直观的方法就是将这两个公式的真值表列出，然后看看两者的取值是否一致。  
【定理3.1】对于命题公式$𝐴$和$B$，$A\Leftrightarrow B$的充分必要条件是公式$A\leftrightarrow B\Leftrightarrow T$  
【定理3.2】命题公式的等值满足如下三条性质：  
自反性：即对任意命题公式$𝐴$，$A=A$；  
对称性：即对任意命题公式𝐴和$B$，若$A\Leftrightarrow B$，则$B=A$；  
传递性：即对任意命题公式 𝐴 ， $B$ 和 $C$ ，若 $A\Leftrightarrow B$ ， $B\Leftrightarrow C$ ，则 $A\Leftrightarrow C$",等值关系满足自反性、对称性和传递性三条性质
基本等值关系,应用于,命题公式,,"在初等代数中，我们常常借助一些已经证明为正确的恒等式，例如平方差公式等进行代数式的恒等变形或演算。在命题逻辑中，也可以这样做。具体地说，就是首先通过真值表证  
明一些基本的等值关系式，然后将这些基本等值关系式作为已知工具直接在命题公式等值演算中使用，达到简化演算过程的效果。这些基本等值关系式一共有24 个，具体如下：  
幂等律：$E_{1}\colon G\vee G\Leftrightarrow G$；                    $E_{2}\colon G\wedge G\Leftrightarrow G$；  
交换律：$E_{3}\colon G\vee H\Leftrightarrow H\vee G$；                 $E_{4}\colon G\wedge H=H\wedge\mathsf{G}$；  
结合律：$E_{5}\colon G\vee(H\vee S)\Leftrightarrow(G\vee H)\vee S \ \  \ \ E_{6}\colon G\wedge(H\wedge S)\Leftrightarrow(G\wedge H)\wedge S$  
同一律：$E_{7}\colon G\vee0\Leftrightarrow G$；                     $E_{8}\colon G\wedge1\Leftrightarrow G$；  
零  律： $E_{9}\colon G\vee1\Leftrightarrow1$；                     $𝐸_{10}: 𝐺∧0 ⇔0$；  
分配律：$E_{11}\colon G\vee(H\wedge S)\Leftrightarrow(G\vee H)\wedge(G\vee S)$$ 𝐸_{12}: 𝐺∧(𝐻∨𝑆) ⇔(𝐺∧𝐻) ∨(𝐺∧𝐻)；$  
吸收律：$E_{13}\colon G\vee(G\wedge H)\Leftrightarrow G$；               $𝐸_{14}: 𝐺∧(𝐺∨𝐻) ⇔𝐺； $  
矛盾律与排中律：$E_{15}{\colon G\wedge\neg G\Leftrightarrow0}$；            $E_{16}\colon G\vee\neg G\Leftrightarrow1;$；  
双从否定律：$E_{17}\colon\neg(\neg G)\Leftrightarrow G$  
德摩根律：$E_{18}\colon\neg(G\vee H)\Leftrightarrow\neg G\wedge\neg H$；         $E_{19}\colon\neg(G\wedge H)\Leftrightarrow\neg H\vee\neg G$  
等值蕴含与假言易位： $E_{20}\colon G\to H\Leftrightarrow\lnot G\vee H$ ； $E_{21}\colon G\to H=\neg H\to\neg G\colon$  
等价与等价否定：$E_{22}\colon G\leftrightarrow H\Leftrightarrow(\neg G\lor H)\land(\neg H\lor G);\quad $  
$E_{23}\colon G\leftrightarrow H\Leftrightarrow\neg G\leftrightarrow\neg H;$  
归谬论：$E_{24}\colon(G\to H)\wedge(G\to\lnot H)\Leftrightarrow\lnot G$。  
除了上述24 个基本等值关系之外，命题公式的等值演算还经常用到两个著名的定理，  
即代入定理和替换定理。  
对于任意一个永真式或永假式，其真值与公式中命题变元的取值状态无关。因此，用任意公式取代永真式或永假式中的变元，都不会改变其取值的永真性或永假性。下列代入定理正是表达了这个含义：  
【定理3.3**]**（代入定理）设$G(P_{1},P_{2},\cdots P_{n})$是一个命题公式，其中$P_{1},P_{2},\cdots P_{n}$是$G$中的$n$个命题变元，$G_{1}(P_{1},P_{2},\cdots P_{n})$，$G_{2}(P_{1},P_{2},\cdots P_{n})$，⋯，$G_{n}(P_{1},P_{2},\cdots P_{n})$为任意命题公式，此时若$G$为永真公式或永假公式，则用$G_{1}$取代$P_{1}$，用$G_{2}$取代$P_{2}$，⋯，用$G_{n}$取代$P_{n}$后得到的新的命题公式： $\mathsf{G}(G_{1},G_{2},\cdots G_{n})\,\Leftrightarrow\,G^{\prime}(P_{1},P_{2},\cdots P_{n})$也是一个永真公式或者永假公式。  
【定理3.4】（替换定理）设${\mathcal{G}}_{1}$是$G$的子公式，$H_{1}$是任一命题公式，在$G$中凡出现$G_{1}$处都以$H_{1}$替换后得到新的命题公式$\mathsf{H}$，若$G_{1}\Leftrightarrow H_{1}$，则$G\Leftrightarrow H$。",基本等值关系用于命题公式的等值演算中，简化演算过程
代入定理,应用于,命题公式,,"在初等代数中，我们常常借助一些已经证明为正确的恒等式，例如平方差公式等进行代数式的恒等变形或演算。在命题逻辑中，也可以这样做。具体地说，就是首先通过真值表证  
明一些基本的等值关系式，然后将这些基本等值关系式作为已知工具直接在命题公式等值演算中使用，达到简化演算过程的效果。这些基本等值关系式一共有24 个，具体如下：  
幂等律：$E_{1}\colon G\vee G\Leftrightarrow G$；                    $E_{2}\colon G\wedge G\Leftrightarrow G$；  
交换律：$E_{3}\colon G\vee H\Leftrightarrow H\vee G$；                 $E_{4}\colon G\wedge H=H\wedge\mathsf{G}$；  
结合律：$E_{5}\colon G\vee(H\vee S)\Leftrightarrow(G\vee H)\vee S \ \  \ \ E_{6}\colon G\wedge(H\wedge S)\Leftrightarrow(G\wedge H)\wedge S$  
同一律：$E_{7}\colon G\vee0\Leftrightarrow G$；                     $E_{8}\colon G\wedge1\Leftrightarrow G$；  
零  律： $E_{9}\colon G\vee1\Leftrightarrow1$；                     $𝐸_{10}: 𝐺∧0 ⇔0$；  
分配律：$E_{11}\colon G\vee(H\wedge S)\Leftrightarrow(G\vee H)\wedge(G\vee S)$$ 𝐸_{12}: 𝐺∧(𝐻∨𝑆) ⇔(𝐺∧𝐻) ∨(𝐺∧𝐻)；$  
吸收律：$E_{13}\colon G\vee(G\wedge H)\Leftrightarrow G$；               $𝐸_{14}: 𝐺∧(𝐺∨𝐻) ⇔𝐺； $  
矛盾律与排中律：$E_{15}{\colon G\wedge\neg G\Leftrightarrow0}$；            $E_{16}\colon G\vee\neg G\Leftrightarrow1;$；  
双从否定律：$E_{17}\colon\neg(\neg G)\Leftrightarrow G$  
德摩根律：$E_{18}\colon\neg(G\vee H)\Leftrightarrow\neg G\wedge\neg H$；         $E_{19}\colon\neg(G\wedge H)\Leftrightarrow\neg H\vee\neg G$  
等值蕴含与假言易位： $E_{20}\colon G\to H\Leftrightarrow\lnot G\vee H$ ； $E_{21}\colon G\to H=\neg H\to\neg G\colon$  
等价与等价否定：$E_{22}\colon G\leftrightarrow H\Leftrightarrow(\neg G\lor H)\land(\neg H\lor G);\quad $  
$E_{23}\colon G\leftrightarrow H\Leftrightarrow\neg G\leftrightarrow\neg H;$  
归谬论：$E_{24}\colon(G\to H)\wedge(G\to\lnot H)\Leftrightarrow\lnot G$。  
除了上述24 个基本等值关系之外，命题公式的等值演算还经常用到两个著名的定理，  
即代入定理和替换定理。  
对于任意一个永真式或永假式，其真值与公式中命题变元的取值状态无关。因此，用任意公式取代永真式或永假式中的变元，都不会改变其取值的永真性或永假性。下列代入定理正是表达了这个含义：  
【定理3.3**]**（代入定理）设$G(P_{1},P_{2},\cdots P_{n})$是一个命题公式，其中$P_{1},P_{2},\cdots P_{n}$是$G$中的$n$个命题变元，$G_{1}(P_{1},P_{2},\cdots P_{n})$，$G_{2}(P_{1},P_{2},\cdots P_{n})$，⋯，$G_{n}(P_{1},P_{2},\cdots P_{n})$为任意命题公式，此时若$G$为永真公式或永假公式，则用$G_{1}$取代$P_{1}$，用$G_{2}$取代$P_{2}$，⋯，用$G_{n}$取代$P_{n}$后得到的新的命题公式： $\mathsf{G}(G_{1},G_{2},\cdots G_{n})\,\Leftrightarrow\,G^{\prime}(P_{1},P_{2},\cdots P_{n})$也是一个永真公式或者永假公式。  
【定理3.4】（替换定理）设${\mathcal{G}}_{1}$是$G$的子公式，$H_{1}$是任一命题公式，在$G$中凡出现$G_{1}$处都以$H_{1}$替换后得到新的命题公式$\mathsf{H}$，若$G_{1}\Leftrightarrow H_{1}$，则$G\Leftrightarrow H$。",代入定理用于在命题公式中用任意公式取代永真式或永假式中的变元，保持其永真性或永假性
替换定理,应用于,命题公式,,"在初等代数中，我们常常借助一些已经证明为正确的恒等式，例如平方差公式等进行代数式的恒等变形或演算。在命题逻辑中，也可以这样做。具体地说，就是首先通过真值表证  
明一些基本的等值关系式，然后将这些基本等值关系式作为已知工具直接在命题公式等值演算中使用，达到简化演算过程的效果。这些基本等值关系式一共有24 个，具体如下：  
幂等律：$E_{1}\colon G\vee G\Leftrightarrow G$；                    $E_{2}\colon G\wedge G\Leftrightarrow G$；  
交换律：$E_{3}\colon G\vee H\Leftrightarrow H\vee G$；                 $E_{4}\colon G\wedge H=H\wedge\mathsf{G}$；  
结合律：$E_{5}\colon G\vee(H\vee S)\Leftrightarrow(G\vee H)\vee S \ \  \ \ E_{6}\colon G\wedge(H\wedge S)\Leftrightarrow(G\wedge H)\wedge S$  
同一律：$E_{7}\colon G\vee0\Leftrightarrow G$；                     $E_{8}\colon G\wedge1\Leftrightarrow G$；  
零  律： $E_{9}\colon G\vee1\Leftrightarrow1$；                     $𝐸_{10}: 𝐺∧0 ⇔0$；  
分配律：$E_{11}\colon G\vee(H\wedge S)\Leftrightarrow(G\vee H)\wedge(G\vee S)$$ 𝐸_{12}: 𝐺∧(𝐻∨𝑆) ⇔(𝐺∧𝐻) ∨(𝐺∧𝐻)；$  
吸收律：$E_{13}\colon G\vee(G\wedge H)\Leftrightarrow G$；               $𝐸_{14}: 𝐺∧(𝐺∨𝐻) ⇔𝐺； $  
矛盾律与排中律：$E_{15}{\colon G\wedge\neg G\Leftrightarrow0}$；            $E_{16}\colon G\vee\neg G\Leftrightarrow1;$；  
双从否定律：$E_{17}\colon\neg(\neg G)\Leftrightarrow G$  
德摩根律：$E_{18}\colon\neg(G\vee H)\Leftrightarrow\neg G\wedge\neg H$；         $E_{19}\colon\neg(G\wedge H)\Leftrightarrow\neg H\vee\neg G$  
等值蕴含与假言易位： $E_{20}\colon G\to H\Leftrightarrow\lnot G\vee H$ ； $E_{21}\colon G\to H=\neg H\to\neg G\colon$  
等价与等价否定：$E_{22}\colon G\leftrightarrow H\Leftrightarrow(\neg G\lor H)\land(\neg H\lor G);\quad $  
$E_{23}\colon G\leftrightarrow H\Leftrightarrow\neg G\leftrightarrow\neg H;$  
归谬论：$E_{24}\colon(G\to H)\wedge(G\to\lnot H)\Leftrightarrow\lnot G$。  
除了上述24 个基本等值关系之外，命题公式的等值演算还经常用到两个著名的定理，  
即代入定理和替换定理。  
对于任意一个永真式或永假式，其真值与公式中命题变元的取值状态无关。因此，用任意公式取代永真式或永假式中的变元，都不会改变其取值的永真性或永假性。下列代入定理正是表达了这个含义：  
【定理3.3**]**（代入定理）设$G(P_{1},P_{2},\cdots P_{n})$是一个命题公式，其中$P_{1},P_{2},\cdots P_{n}$是$G$中的$n$个命题变元，$G_{1}(P_{1},P_{2},\cdots P_{n})$，$G_{2}(P_{1},P_{2},\cdots P_{n})$，⋯，$G_{n}(P_{1},P_{2},\cdots P_{n})$为任意命题公式，此时若$G$为永真公式或永假公式，则用$G_{1}$取代$P_{1}$，用$G_{2}$取代$P_{2}$，⋯，用$G_{n}$取代$P_{n}$后得到的新的命题公式： $\mathsf{G}(G_{1},G_{2},\cdots G_{n})\,\Leftrightarrow\,G^{\prime}(P_{1},P_{2},\cdots P_{n})$也是一个永真公式或者永假公式。  
【定理3.4】（替换定理）设${\mathcal{G}}_{1}$是$G$的子公式，$H_{1}$是任一命题公式，在$G$中凡出现$G_{1}$处都以$H_{1}$替换后得到新的命题公式$\mathsf{H}$，若$G_{1}\Leftrightarrow H_{1}$，则$G\Leftrightarrow H$。",替换定理用于在命题公式中替换子公式，若子公式等值则整个公式等值
命题公式,通过,等值演算,,"通过上述24 个基本等值关系以及代入定理和替换定理，就可以进行命题公式的等值演算。一般来说，通过命题公式的等值演算，可以实现如下三个基本目的：  
第一、判定命题公式的基本类型，即判定或证明一个命题公式为永真或永假；  
第二、证明两个命题公式之间具有等值关系；  
第三、对复杂的命题公式进行化简。",通过等值演算可以对命题公式进行判定、证明等值关系和化简
等值关系,证明,命题公式,,"通过上述24 个基本等值关系以及代入定理和替换定理，就可以进行命题公式的等值演算。一般来说，通过命题公式的等值演算，可以实现如下三个基本目的：  
第一、判定命题公式的基本类型，即判定或证明一个命题公式为永真或永假；  
第二、证明两个命题公式之间具有等值关系；  
第三、对复杂的命题公式进行化简。",通过等值演算可以证明两个命题公式之间具有等值关系
代入定理,用于,等值演算,,"通过上述24 个基本等值关系以及代入定理和替换定理，就可以进行命题公式的等值演算。一般来说，通过命题公式的等值演算，可以实现如下三个基本目的：  
第一、判定命题公式的基本类型，即判定或证明一个命题公式为永真或永假；  
第二、证明两个命题公式之间具有等值关系；  
第三、对复杂的命题公式进行化简。",代入定理用于命题公式的等值演算
替换定理,用于,等值演算,,"通过上述24 个基本等值关系以及代入定理和替换定理，就可以进行命题公式的等值演算。一般来说，通过命题公式的等值演算，可以实现如下三个基本目的：  
第一、判定命题公式的基本类型，即判定或证明一个命题公式为永真或永假；  
第二、证明两个命题公式之间具有等值关系；  
第三、对复杂的命题公式进行化简。",替换定理用于命题公式的等值演算
命题公式,包含,限制性命题公式,,"前面学习了 “否定”、 “合取”、 “析取”、 “蕴涵”和“等价”这五个常用命题联结词，其中最常用的是“否定”、 “合取”、 “析取”这三个联结词。事实上，后面将会证明仅使用这三个最常用联结词就可以任意的命题公式。本小节主要考察仅由这三个联结词构成的命题公式，首先给出如下限制性命题公式的定义：  
【定义3.14】如果一个命题公式$G$中仅出现命题变量、命题常量，以及命题联结词“$\neg$”、“ $\wedge$“、”$\lor$“，则称$G$为限制性命题公式。  
例如公式$\neg Q\lor R\,\lor\,\neg(P\lor Q)\lor(Q\lor P)\,\lor\,G\lor(H\land S)$都是限制性命题公式。  
限制性命题公式中只有“$\neg$”、“ $\wedge$“、”$\lor$“这三种运算，其中”$\neg$”为一元运算，“ $\wedge$“和“$\lor$”均为二元运算。对于任意一个限制性命题公式，可以使用规律性修改其运算联结词的方式构造出与之相对应的新的命题公式。例如，对于“$\neg$”运算，可将命题公式中所有变量取反，即由$P$ 换成$\neg\mathrm{P}$，便可得到一个新的公式。由此得到如下内否公式的定义：  
【定义3.15】设$G\Leftrightarrow G(P_{1},P_{2},\cdots P_{n})$是任一限制性命题公式，$P_{1},P_{2},\cdots P_{n}$是其所有命题变量，则称$G(\neg P_{1},\neg P_{2},\cdots\neg P_{n})$是$G(P_{1},P_{2},\cdots P_{n})$的内否公式，记为$G^{\neg}$。  
例如：若 $G=\ \lnot P\lor Q$，则$G^{\neg}=P\lor\neg Q$。  
不难看出，$\wedge$和$\lor$运算具有一定的对等性。也就是说 $\wedge$运算具有的性质，$\lor$运算也都有，反之亦然。因此，对于任意一个限制性命题公式，可将其中 $\wedge$换成$\lor$、$\lor$换成$\wedge$、$T$换成$F$、$F$换成$T$，则可得到一个与之相关的新公式。由此得到如下命题公式对偶式的概念：  
【定义3.16】对于任意一个限制性命题公式$G$，将其中 $\wedge$换成$\lor$、$\vee$换成 $\wedge$、$T$换成$F$、$F$换成$T$，得到的新公式称为$G$的对偶式，记为$G^{*}$。  
例如：
$$
(1)G\Leftrightarrow(P\land F);\quad G^{*}=P\lor T_{\circ}\;\;(\,2\,)\;\;G\Leftrightarrow(P\lor Q)\land R;\;\;G^{*}\Leftrightarrow(P\land Q)\lor R\,_{\circ}
$$  
下面两个定理分别给出了内否式和对偶式的基本性质于基本关系：  
【定理3.5】假设$G$和$H$都是限制性命题公式，则成立下列等值式：  
$\begin{aligned}&(1) (G^{*})^{*}\Leftrightarrow G, (G^{\neg})^{\neg}\Leftrightarrow G; (2) (G\vee H)^{*}\Leftrightarrow G^{*}\wedge H^{*}; (G\vee H)^{\neg}\Leftrightarrow G^{\neg}\vee H^{\neg};\\&(3) (G\wedge H)^{*}\Leftrightarrow G^{*}\vee H^{*}; (G\wedge H)^{\neg}\Leftrightarrow G^{\neg}\wedge H^{\neg}。\end{aligned}$  
【定理3.6】设$G$和$G^{*}$互为对偶式，$P_{1},P_{2},\cdots P_{n}$是出现在$G$和$G^{*}$中的全部命题变项，将$G$和$G^{*}$写成$\mathsf{n}$ 元函数形式，则有：
$$
(1)\neg G(P_{1},P_{2},\cdots,P_{n})\Leftrightarrow G^{*}(\neg P_{1},\neg P_{2},\cdots,\neg P_{n})\Leftrightarrow(G^{\neg})^{*}(P_{1},\cdots,P_{n})\tag{3-1}
$$  
$$
G^{\neg}(P_{1},P_{2},\cdots,P_{n})\Leftrightarrow G(\neg P_{1},\neg P_{2},\cdots,\neg P_{n})\Leftrightarrow\neg G^{*}(P_{1},P_{2},\cdots,P_{n})\tag{3-2}
$$  
上述定理的第（1）条表明命题公式$G$的否定与其命题变元否定的对偶式，即与该公式内否式的对偶式等值；第（2）条表明命题公式$G$的内否式与该公式对偶式的否定等值。  
【定理3.7】（对偶原理）假设$P_{1},P_{2},\cdots,P_{n}$是出现在命题公式$P$和$Q$中的所有原子变元，如果$P\Leftrightarrow Q$，那么$P^{*}\Leftrightarrow Q^{*}$。  
对偶原理表明命题公式之间所有等值关系都是成对的。也就是说，对于任意一个等值式，都可由对偶原理构造一个与之对偶的等值式。例如，对于等值式$P\to Q\Leftrightarrow\neg P\lor Q$，则可构造出其对偶等值式$\neg P\land Q\Leftrightarrow\neg(\neg P\rightarrow\neg Q)$。因为$\neg P\land Q\Leftrightarrow\neg(P\lor\neg Q)\Leftrightarrow\neg(\neg P\to\neg Q)$。",限制性命题公式是命题公式的一种特殊形式，仅包含命题变量、命题常量和联结词“$\neg$”、“$\wedge$”、“$\lor$”。
限制性命题公式,生成,内否公式,,"前面学习了 “否定”、 “合取”、 “析取”、 “蕴涵”和“等价”这五个常用命题联结词，其中最常用的是“否定”、 “合取”、 “析取”这三个联结词。事实上，后面将会证明仅使用这三个最常用联结词就可以任意的命题公式。本小节主要考察仅由这三个联结词构成的命题公式，首先给出如下限制性命题公式的定义：  
【定义3.14】如果一个命题公式$G$中仅出现命题变量、命题常量，以及命题联结词“$\neg$”、“ $\wedge$“、”$\lor$“，则称$G$为限制性命题公式。  
例如公式$\neg Q\lor R\,\lor\,\neg(P\lor Q)\lor(Q\lor P)\,\lor\,G\lor(H\land S)$都是限制性命题公式。  
限制性命题公式中只有“$\neg$”、“ $\wedge$“、”$\lor$“这三种运算，其中”$\neg$”为一元运算，“ $\wedge$“和“$\lor$”均为二元运算。对于任意一个限制性命题公式，可以使用规律性修改其运算联结词的方式构造出与之相对应的新的命题公式。例如，对于“$\neg$”运算，可将命题公式中所有变量取反，即由$P$ 换成$\neg\mathrm{P}$，便可得到一个新的公式。由此得到如下内否公式的定义：  
【定义3.15】设$G\Leftrightarrow G(P_{1},P_{2},\cdots P_{n})$是任一限制性命题公式，$P_{1},P_{2},\cdots P_{n}$是其所有命题变量，则称$G(\neg P_{1},\neg P_{2},\cdots\neg P_{n})$是$G(P_{1},P_{2},\cdots P_{n})$的内否公式，记为$G^{\neg}$。  
例如：若 $G=\ \lnot P\lor Q$，则$G^{\neg}=P\lor\neg Q$。  
不难看出，$\wedge$和$\lor$运算具有一定的对等性。也就是说 $\wedge$运算具有的性质，$\lor$运算也都有，反之亦然。因此，对于任意一个限制性命题公式，可将其中 $\wedge$换成$\lor$、$\lor$换成$\wedge$、$T$换成$F$、$F$换成$T$，则可得到一个与之相关的新公式。由此得到如下命题公式对偶式的概念：  
【定义3.16】对于任意一个限制性命题公式$G$，将其中 $\wedge$换成$\lor$、$\vee$换成 $\wedge$、$T$换成$F$、$F$换成$T$，得到的新公式称为$G$的对偶式，记为$G^{*}$。  
例如：
$$
(1)G\Leftrightarrow(P\land F);\quad G^{*}=P\lor T_{\circ}\;\;(\,2\,)\;\;G\Leftrightarrow(P\lor Q)\land R;\;\;G^{*}\Leftrightarrow(P\land Q)\lor R\,_{\circ}
$$  
下面两个定理分别给出了内否式和对偶式的基本性质于基本关系：  
【定理3.5】假设$G$和$H$都是限制性命题公式，则成立下列等值式：  
$\begin{aligned}&(1) (G^{*})^{*}\Leftrightarrow G, (G^{\neg})^{\neg}\Leftrightarrow G; (2) (G\vee H)^{*}\Leftrightarrow G^{*}\wedge H^{*}; (G\vee H)^{\neg}\Leftrightarrow G^{\neg}\vee H^{\neg};\\&(3) (G\wedge H)^{*}\Leftrightarrow G^{*}\vee H^{*}; (G\wedge H)^{\neg}\Leftrightarrow G^{\neg}\wedge H^{\neg}。\end{aligned}$  
【定理3.6】设$G$和$G^{*}$互为对偶式，$P_{1},P_{2},\cdots P_{n}$是出现在$G$和$G^{*}$中的全部命题变项，将$G$和$G^{*}$写成$\mathsf{n}$ 元函数形式，则有：
$$
(1)\neg G(P_{1},P_{2},\cdots,P_{n})\Leftrightarrow G^{*}(\neg P_{1},\neg P_{2},\cdots,\neg P_{n})\Leftrightarrow(G^{\neg})^{*}(P_{1},\cdots,P_{n})\tag{3-1}
$$  
$$
G^{\neg}(P_{1},P_{2},\cdots,P_{n})\Leftrightarrow G(\neg P_{1},\neg P_{2},\cdots,\neg P_{n})\Leftrightarrow\neg G^{*}(P_{1},P_{2},\cdots,P_{n})\tag{3-2}
$$  
上述定理的第（1）条表明命题公式$G$的否定与其命题变元否定的对偶式，即与该公式内否式的对偶式等值；第（2）条表明命题公式$G$的内否式与该公式对偶式的否定等值。  
【定理3.7】（对偶原理）假设$P_{1},P_{2},\cdots,P_{n}$是出现在命题公式$P$和$Q$中的所有原子变元，如果$P\Leftrightarrow Q$，那么$P^{*}\Leftrightarrow Q^{*}$。  
对偶原理表明命题公式之间所有等值关系都是成对的。也就是说，对于任意一个等值式，都可由对偶原理构造一个与之对偶的等值式。例如，对于等值式$P\to Q\Leftrightarrow\neg P\lor Q$，则可构造出其对偶等值式$\neg P\land Q\Leftrightarrow\neg(\neg P\rightarrow\neg Q)$。因为$\neg P\land Q\Leftrightarrow\neg(P\lor\neg Q)\Leftrightarrow\neg(\neg P\to\neg Q)$。",通过将限制性命题公式中的所有命题变量取反，可以生成对应的内否公式。
限制性命题公式,生成,对偶式,,"前面学习了 “否定”、 “合取”、 “析取”、 “蕴涵”和“等价”这五个常用命题联结词，其中最常用的是“否定”、 “合取”、 “析取”这三个联结词。事实上，后面将会证明仅使用这三个最常用联结词就可以任意的命题公式。本小节主要考察仅由这三个联结词构成的命题公式，首先给出如下限制性命题公式的定义：  
【定义3.14】如果一个命题公式$G$中仅出现命题变量、命题常量，以及命题联结词“$\neg$”、“ $\wedge$“、”$\lor$“，则称$G$为限制性命题公式。  
例如公式$\neg Q\lor R\,\lor\,\neg(P\lor Q)\lor(Q\lor P)\,\lor\,G\lor(H\land S)$都是限制性命题公式。  
限制性命题公式中只有“$\neg$”、“ $\wedge$“、”$\lor$“这三种运算，其中”$\neg$”为一元运算，“ $\wedge$“和“$\lor$”均为二元运算。对于任意一个限制性命题公式，可以使用规律性修改其运算联结词的方式构造出与之相对应的新的命题公式。例如，对于“$\neg$”运算，可将命题公式中所有变量取反，即由$P$ 换成$\neg\mathrm{P}$，便可得到一个新的公式。由此得到如下内否公式的定义：  
【定义3.15】设$G\Leftrightarrow G(P_{1},P_{2},\cdots P_{n})$是任一限制性命题公式，$P_{1},P_{2},\cdots P_{n}$是其所有命题变量，则称$G(\neg P_{1},\neg P_{2},\cdots\neg P_{n})$是$G(P_{1},P_{2},\cdots P_{n})$的内否公式，记为$G^{\neg}$。  
例如：若 $G=\ \lnot P\lor Q$，则$G^{\neg}=P\lor\neg Q$。  
不难看出，$\wedge$和$\lor$运算具有一定的对等性。也就是说 $\wedge$运算具有的性质，$\lor$运算也都有，反之亦然。因此，对于任意一个限制性命题公式，可将其中 $\wedge$换成$\lor$、$\lor$换成$\wedge$、$T$换成$F$、$F$换成$T$，则可得到一个与之相关的新公式。由此得到如下命题公式对偶式的概念：  
【定义3.16】对于任意一个限制性命题公式$G$，将其中 $\wedge$换成$\lor$、$\vee$换成 $\wedge$、$T$换成$F$、$F$换成$T$，得到的新公式称为$G$的对偶式，记为$G^{*}$。  
例如：
$$
(1)G\Leftrightarrow(P\land F);\quad G^{*}=P\lor T_{\circ}\;\;(\,2\,)\;\;G\Leftrightarrow(P\lor Q)\land R;\;\;G^{*}\Leftrightarrow(P\land Q)\lor R\,_{\circ}
$$  
下面两个定理分别给出了内否式和对偶式的基本性质于基本关系：  
【定理3.5】假设$G$和$H$都是限制性命题公式，则成立下列等值式：  
$\begin{aligned}&(1) (G^{*})^{*}\Leftrightarrow G, (G^{\neg})^{\neg}\Leftrightarrow G; (2) (G\vee H)^{*}\Leftrightarrow G^{*}\wedge H^{*}; (G\vee H)^{\neg}\Leftrightarrow G^{\neg}\vee H^{\neg};\\&(3) (G\wedge H)^{*}\Leftrightarrow G^{*}\vee H^{*}; (G\wedge H)^{\neg}\Leftrightarrow G^{\neg}\wedge H^{\neg}。\end{aligned}$  
【定理3.6】设$G$和$G^{*}$互为对偶式，$P_{1},P_{2},\cdots P_{n}$是出现在$G$和$G^{*}$中的全部命题变项，将$G$和$G^{*}$写成$\mathsf{n}$ 元函数形式，则有：
$$
(1)\neg G(P_{1},P_{2},\cdots,P_{n})\Leftrightarrow G^{*}(\neg P_{1},\neg P_{2},\cdots,\neg P_{n})\Leftrightarrow(G^{\neg})^{*}(P_{1},\cdots,P_{n})\tag{3-1}
$$  
$$
G^{\neg}(P_{1},P_{2},\cdots,P_{n})\Leftrightarrow G(\neg P_{1},\neg P_{2},\cdots,\neg P_{n})\Leftrightarrow\neg G^{*}(P_{1},P_{2},\cdots,P_{n})\tag{3-2}
$$  
上述定理的第（1）条表明命题公式$G$的否定与其命题变元否定的对偶式，即与该公式内否式的对偶式等值；第（2）条表明命题公式$G$的内否式与该公式对偶式的否定等值。  
【定理3.7】（对偶原理）假设$P_{1},P_{2},\cdots,P_{n}$是出现在命题公式$P$和$Q$中的所有原子变元，如果$P\Leftrightarrow Q$，那么$P^{*}\Leftrightarrow Q^{*}$。  
对偶原理表明命题公式之间所有等值关系都是成对的。也就是说，对于任意一个等值式，都可由对偶原理构造一个与之对偶的等值式。例如，对于等值式$P\to Q\Leftrightarrow\neg P\lor Q$，则可构造出其对偶等值式$\neg P\land Q\Leftrightarrow\neg(\neg P\rightarrow\neg Q)$。因为$\neg P\land Q\Leftrightarrow\neg(P\lor\neg Q)\Leftrightarrow\neg(\neg P\to\neg Q)$。",通过将限制性命题公式中的联结词“$\wedge$”和“$\lor$”互换，以及将“$T$”和“$F$”互换，可以生成对应的对偶式。
内否公式,性质,定理3.5,,"前面学习了 “否定”、 “合取”、 “析取”、 “蕴涵”和“等价”这五个常用命题联结词，其中最常用的是“否定”、 “合取”、 “析取”这三个联结词。事实上，后面将会证明仅使用这三个最常用联结词就可以任意的命题公式。本小节主要考察仅由这三个联结词构成的命题公式，首先给出如下限制性命题公式的定义：  
【定义3.14】如果一个命题公式$G$中仅出现命题变量、命题常量，以及命题联结词“$\neg$”、“ $\wedge$“、”$\lor$“，则称$G$为限制性命题公式。  
例如公式$\neg Q\lor R\,\lor\,\neg(P\lor Q)\lor(Q\lor P)\,\lor\,G\lor(H\land S)$都是限制性命题公式。  
限制性命题公式中只有“$\neg$”、“ $\wedge$“、”$\lor$“这三种运算，其中”$\neg$”为一元运算，“ $\wedge$“和“$\lor$”均为二元运算。对于任意一个限制性命题公式，可以使用规律性修改其运算联结词的方式构造出与之相对应的新的命题公式。例如，对于“$\neg$”运算，可将命题公式中所有变量取反，即由$P$ 换成$\neg\mathrm{P}$，便可得到一个新的公式。由此得到如下内否公式的定义：  
【定义3.15】设$G\Leftrightarrow G(P_{1},P_{2},\cdots P_{n})$是任一限制性命题公式，$P_{1},P_{2},\cdots P_{n}$是其所有命题变量，则称$G(\neg P_{1},\neg P_{2},\cdots\neg P_{n})$是$G(P_{1},P_{2},\cdots P_{n})$的内否公式，记为$G^{\neg}$。  
例如：若 $G=\ \lnot P\lor Q$，则$G^{\neg}=P\lor\neg Q$。  
不难看出，$\wedge$和$\lor$运算具有一定的对等性。也就是说 $\wedge$运算具有的性质，$\lor$运算也都有，反之亦然。因此，对于任意一个限制性命题公式，可将其中 $\wedge$换成$\lor$、$\lor$换成$\wedge$、$T$换成$F$、$F$换成$T$，则可得到一个与之相关的新公式。由此得到如下命题公式对偶式的概念：  
【定义3.16】对于任意一个限制性命题公式$G$，将其中 $\wedge$换成$\lor$、$\vee$换成 $\wedge$、$T$换成$F$、$F$换成$T$，得到的新公式称为$G$的对偶式，记为$G^{*}$。  
例如：
$$
(1)G\Leftrightarrow(P\land F);\quad G^{*}=P\lor T_{\circ}\;\;(\,2\,)\;\;G\Leftrightarrow(P\lor Q)\land R;\;\;G^{*}\Leftrightarrow(P\land Q)\lor R\,_{\circ}
$$  
下面两个定理分别给出了内否式和对偶式的基本性质于基本关系：  
【定理3.5】假设$G$和$H$都是限制性命题公式，则成立下列等值式：  
$\begin{aligned}&(1) (G^{*})^{*}\Leftrightarrow G, (G^{\neg})^{\neg}\Leftrightarrow G; (2) (G\vee H)^{*}\Leftrightarrow G^{*}\wedge H^{*}; (G\vee H)^{\neg}\Leftrightarrow G^{\neg}\vee H^{\neg};\\&(3) (G\wedge H)^{*}\Leftrightarrow G^{*}\vee H^{*}; (G\wedge H)^{\neg}\Leftrightarrow G^{\neg}\wedge H^{\neg}。\end{aligned}$  
【定理3.6】设$G$和$G^{*}$互为对偶式，$P_{1},P_{2},\cdots P_{n}$是出现在$G$和$G^{*}$中的全部命题变项，将$G$和$G^{*}$写成$\mathsf{n}$ 元函数形式，则有：
$$
(1)\neg G(P_{1},P_{2},\cdots,P_{n})\Leftrightarrow G^{*}(\neg P_{1},\neg P_{2},\cdots,\neg P_{n})\Leftrightarrow(G^{\neg})^{*}(P_{1},\cdots,P_{n})\tag{3-1}
$$  
$$
G^{\neg}(P_{1},P_{2},\cdots,P_{n})\Leftrightarrow G(\neg P_{1},\neg P_{2},\cdots,\neg P_{n})\Leftrightarrow\neg G^{*}(P_{1},P_{2},\cdots,P_{n})\tag{3-2}
$$  
上述定理的第（1）条表明命题公式$G$的否定与其命题变元否定的对偶式，即与该公式内否式的对偶式等值；第（2）条表明命题公式$G$的内否式与该公式对偶式的否定等值。  
【定理3.7】（对偶原理）假设$P_{1},P_{2},\cdots,P_{n}$是出现在命题公式$P$和$Q$中的所有原子变元，如果$P\Leftrightarrow Q$，那么$P^{*}\Leftrightarrow Q^{*}$。  
对偶原理表明命题公式之间所有等值关系都是成对的。也就是说，对于任意一个等值式，都可由对偶原理构造一个与之对偶的等值式。例如，对于等值式$P\to Q\Leftrightarrow\neg P\lor Q$，则可构造出其对偶等值式$\neg P\land Q\Leftrightarrow\neg(\neg P\rightarrow\neg Q)$。因为$\neg P\land Q\Leftrightarrow\neg(P\lor\neg Q)\Leftrightarrow\neg(\neg P\to\neg Q)$。",定理3.5描述了内否公式的基本性质，包括内否公式的双重否定等于原公式等。
对偶式,性质,定理3.5,,"前面学习了 “否定”、 “合取”、 “析取”、 “蕴涵”和“等价”这五个常用命题联结词，其中最常用的是“否定”、 “合取”、 “析取”这三个联结词。事实上，后面将会证明仅使用这三个最常用联结词就可以任意的命题公式。本小节主要考察仅由这三个联结词构成的命题公式，首先给出如下限制性命题公式的定义：  
【定义3.14】如果一个命题公式$G$中仅出现命题变量、命题常量，以及命题联结词“$\neg$”、“ $\wedge$“、”$\lor$“，则称$G$为限制性命题公式。  
例如公式$\neg Q\lor R\,\lor\,\neg(P\lor Q)\lor(Q\lor P)\,\lor\,G\lor(H\land S)$都是限制性命题公式。  
限制性命题公式中只有“$\neg$”、“ $\wedge$“、”$\lor$“这三种运算，其中”$\neg$”为一元运算，“ $\wedge$“和“$\lor$”均为二元运算。对于任意一个限制性命题公式，可以使用规律性修改其运算联结词的方式构造出与之相对应的新的命题公式。例如，对于“$\neg$”运算，可将命题公式中所有变量取反，即由$P$ 换成$\neg\mathrm{P}$，便可得到一个新的公式。由此得到如下内否公式的定义：  
【定义3.15】设$G\Leftrightarrow G(P_{1},P_{2},\cdots P_{n})$是任一限制性命题公式，$P_{1},P_{2},\cdots P_{n}$是其所有命题变量，则称$G(\neg P_{1},\neg P_{2},\cdots\neg P_{n})$是$G(P_{1},P_{2},\cdots P_{n})$的内否公式，记为$G^{\neg}$。  
例如：若 $G=\ \lnot P\lor Q$，则$G^{\neg}=P\lor\neg Q$。  
不难看出，$\wedge$和$\lor$运算具有一定的对等性。也就是说 $\wedge$运算具有的性质，$\lor$运算也都有，反之亦然。因此，对于任意一个限制性命题公式，可将其中 $\wedge$换成$\lor$、$\lor$换成$\wedge$、$T$换成$F$、$F$换成$T$，则可得到一个与之相关的新公式。由此得到如下命题公式对偶式的概念：  
【定义3.16】对于任意一个限制性命题公式$G$，将其中 $\wedge$换成$\lor$、$\vee$换成 $\wedge$、$T$换成$F$、$F$换成$T$，得到的新公式称为$G$的对偶式，记为$G^{*}$。  
例如：
$$
(1)G\Leftrightarrow(P\land F);\quad G^{*}=P\lor T_{\circ}\;\;(\,2\,)\;\;G\Leftrightarrow(P\lor Q)\land R;\;\;G^{*}\Leftrightarrow(P\land Q)\lor R\,_{\circ}
$$  
下面两个定理分别给出了内否式和对偶式的基本性质于基本关系：  
【定理3.5】假设$G$和$H$都是限制性命题公式，则成立下列等值式：  
$\begin{aligned}&(1) (G^{*})^{*}\Leftrightarrow G, (G^{\neg})^{\neg}\Leftrightarrow G; (2) (G\vee H)^{*}\Leftrightarrow G^{*}\wedge H^{*}; (G\vee H)^{\neg}\Leftrightarrow G^{\neg}\vee H^{\neg};\\&(3) (G\wedge H)^{*}\Leftrightarrow G^{*}\vee H^{*}; (G\wedge H)^{\neg}\Leftrightarrow G^{\neg}\wedge H^{\neg}。\end{aligned}$  
【定理3.6】设$G$和$G^{*}$互为对偶式，$P_{1},P_{2},\cdots P_{n}$是出现在$G$和$G^{*}$中的全部命题变项，将$G$和$G^{*}$写成$\mathsf{n}$ 元函数形式，则有：
$$
(1)\neg G(P_{1},P_{2},\cdots,P_{n})\Leftrightarrow G^{*}(\neg P_{1},\neg P_{2},\cdots,\neg P_{n})\Leftrightarrow(G^{\neg})^{*}(P_{1},\cdots,P_{n})\tag{3-1}
$$  
$$
G^{\neg}(P_{1},P_{2},\cdots,P_{n})\Leftrightarrow G(\neg P_{1},\neg P_{2},\cdots,\neg P_{n})\Leftrightarrow\neg G^{*}(P_{1},P_{2},\cdots,P_{n})\tag{3-2}
$$  
上述定理的第（1）条表明命题公式$G$的否定与其命题变元否定的对偶式，即与该公式内否式的对偶式等值；第（2）条表明命题公式$G$的内否式与该公式对偶式的否定等值。  
【定理3.7】（对偶原理）假设$P_{1},P_{2},\cdots,P_{n}$是出现在命题公式$P$和$Q$中的所有原子变元，如果$P\Leftrightarrow Q$，那么$P^{*}\Leftrightarrow Q^{*}$。  
对偶原理表明命题公式之间所有等值关系都是成对的。也就是说，对于任意一个等值式，都可由对偶原理构造一个与之对偶的等值式。例如，对于等值式$P\to Q\Leftrightarrow\neg P\lor Q$，则可构造出其对偶等值式$\neg P\land Q\Leftrightarrow\neg(\neg P\rightarrow\neg Q)$。因为$\neg P\land Q\Leftrightarrow\neg(P\lor\neg Q)\Leftrightarrow\neg(\neg P\to\neg Q)$。",定理3.5描述了对偶式的基本性质，包括对偶式的双重对偶等于原公式等。
对偶式,关系,定理3.6,,"前面学习了 “否定”、 “合取”、 “析取”、 “蕴涵”和“等价”这五个常用命题联结词，其中最常用的是“否定”、 “合取”、 “析取”这三个联结词。事实上，后面将会证明仅使用这三个最常用联结词就可以任意的命题公式。本小节主要考察仅由这三个联结词构成的命题公式，首先给出如下限制性命题公式的定义：  
【定义3.14】如果一个命题公式$G$中仅出现命题变量、命题常量，以及命题联结词“$\neg$”、“ $\wedge$“、”$\lor$“，则称$G$为限制性命题公式。  
例如公式$\neg Q\lor R\,\lor\,\neg(P\lor Q)\lor(Q\lor P)\,\lor\,G\lor(H\land S)$都是限制性命题公式。  
限制性命题公式中只有“$\neg$”、“ $\wedge$“、”$\lor$“这三种运算，其中”$\neg$”为一元运算，“ $\wedge$“和“$\lor$”均为二元运算。对于任意一个限制性命题公式，可以使用规律性修改其运算联结词的方式构造出与之相对应的新的命题公式。例如，对于“$\neg$”运算，可将命题公式中所有变量取反，即由$P$ 换成$\neg\mathrm{P}$，便可得到一个新的公式。由此得到如下内否公式的定义：  
【定义3.15】设$G\Leftrightarrow G(P_{1},P_{2},\cdots P_{n})$是任一限制性命题公式，$P_{1},P_{2},\cdots P_{n}$是其所有命题变量，则称$G(\neg P_{1},\neg P_{2},\cdots\neg P_{n})$是$G(P_{1},P_{2},\cdots P_{n})$的内否公式，记为$G^{\neg}$。  
例如：若 $G=\ \lnot P\lor Q$，则$G^{\neg}=P\lor\neg Q$。  
不难看出，$\wedge$和$\lor$运算具有一定的对等性。也就是说 $\wedge$运算具有的性质，$\lor$运算也都有，反之亦然。因此，对于任意一个限制性命题公式，可将其中 $\wedge$换成$\lor$、$\lor$换成$\wedge$、$T$换成$F$、$F$换成$T$，则可得到一个与之相关的新公式。由此得到如下命题公式对偶式的概念：  
【定义3.16】对于任意一个限制性命题公式$G$，将其中 $\wedge$换成$\lor$、$\vee$换成 $\wedge$、$T$换成$F$、$F$换成$T$，得到的新公式称为$G$的对偶式，记为$G^{*}$。  
例如：
$$
(1)G\Leftrightarrow(P\land F);\quad G^{*}=P\lor T_{\circ}\;\;(\,2\,)\;\;G\Leftrightarrow(P\lor Q)\land R;\;\;G^{*}\Leftrightarrow(P\land Q)\lor R\,_{\circ}
$$  
下面两个定理分别给出了内否式和对偶式的基本性质于基本关系：  
【定理3.5】假设$G$和$H$都是限制性命题公式，则成立下列等值式：  
$\begin{aligned}&(1) (G^{*})^{*}\Leftrightarrow G, (G^{\neg})^{\neg}\Leftrightarrow G; (2) (G\vee H)^{*}\Leftrightarrow G^{*}\wedge H^{*}; (G\vee H)^{\neg}\Leftrightarrow G^{\neg}\vee H^{\neg};\\&(3) (G\wedge H)^{*}\Leftrightarrow G^{*}\vee H^{*}; (G\wedge H)^{\neg}\Leftrightarrow G^{\neg}\wedge H^{\neg}。\end{aligned}$  
【定理3.6】设$G$和$G^{*}$互为对偶式，$P_{1},P_{2},\cdots P_{n}$是出现在$G$和$G^{*}$中的全部命题变项，将$G$和$G^{*}$写成$\mathsf{n}$ 元函数形式，则有：
$$
(1)\neg G(P_{1},P_{2},\cdots,P_{n})\Leftrightarrow G^{*}(\neg P_{1},\neg P_{2},\cdots,\neg P_{n})\Leftrightarrow(G^{\neg})^{*}(P_{1},\cdots,P_{n})\tag{3-1}
$$  
$$
G^{\neg}(P_{1},P_{2},\cdots,P_{n})\Leftrightarrow G(\neg P_{1},\neg P_{2},\cdots,\neg P_{n})\Leftrightarrow\neg G^{*}(P_{1},P_{2},\cdots,P_{n})\tag{3-2}
$$  
上述定理的第（1）条表明命题公式$G$的否定与其命题变元否定的对偶式，即与该公式内否式的对偶式等值；第（2）条表明命题公式$G$的内否式与该公式对偶式的否定等值。  
【定理3.7】（对偶原理）假设$P_{1},P_{2},\cdots,P_{n}$是出现在命题公式$P$和$Q$中的所有原子变元，如果$P\Leftrightarrow Q$，那么$P^{*}\Leftrightarrow Q^{*}$。  
对偶原理表明命题公式之间所有等值关系都是成对的。也就是说，对于任意一个等值式，都可由对偶原理构造一个与之对偶的等值式。例如，对于等值式$P\to Q\Leftrightarrow\neg P\lor Q$，则可构造出其对偶等值式$\neg P\land Q\Leftrightarrow\neg(\neg P\rightarrow\neg Q)$。因为$\neg P\land Q\Leftrightarrow\neg(P\lor\neg Q)\Leftrightarrow\neg(\neg P\to\neg Q)$。",定理3.6描述了对偶式与内否公式之间的关系，包括命题公式的否定与其对偶式的关系等。
对偶原理,定义,定理3.7,,"前面学习了 “否定”、 “合取”、 “析取”、 “蕴涵”和“等价”这五个常用命题联结词，其中最常用的是“否定”、 “合取”、 “析取”这三个联结词。事实上，后面将会证明仅使用这三个最常用联结词就可以任意的命题公式。本小节主要考察仅由这三个联结词构成的命题公式，首先给出如下限制性命题公式的定义：  
【定义3.14】如果一个命题公式$G$中仅出现命题变量、命题常量，以及命题联结词“$\neg$”、“ $\wedge$“、”$\lor$“，则称$G$为限制性命题公式。  
例如公式$\neg Q\lor R\,\lor\,\neg(P\lor Q)\lor(Q\lor P)\,\lor\,G\lor(H\land S)$都是限制性命题公式。  
限制性命题公式中只有“$\neg$”、“ $\wedge$“、”$\lor$“这三种运算，其中”$\neg$”为一元运算，“ $\wedge$“和“$\lor$”均为二元运算。对于任意一个限制性命题公式，可以使用规律性修改其运算联结词的方式构造出与之相对应的新的命题公式。例如，对于“$\neg$”运算，可将命题公式中所有变量取反，即由$P$ 换成$\neg\mathrm{P}$，便可得到一个新的公式。由此得到如下内否公式的定义：  
【定义3.15】设$G\Leftrightarrow G(P_{1},P_{2},\cdots P_{n})$是任一限制性命题公式，$P_{1},P_{2},\cdots P_{n}$是其所有命题变量，则称$G(\neg P_{1},\neg P_{2},\cdots\neg P_{n})$是$G(P_{1},P_{2},\cdots P_{n})$的内否公式，记为$G^{\neg}$。  
例如：若 $G=\ \lnot P\lor Q$，则$G^{\neg}=P\lor\neg Q$。  
不难看出，$\wedge$和$\lor$运算具有一定的对等性。也就是说 $\wedge$运算具有的性质，$\lor$运算也都有，反之亦然。因此，对于任意一个限制性命题公式，可将其中 $\wedge$换成$\lor$、$\lor$换成$\wedge$、$T$换成$F$、$F$换成$T$，则可得到一个与之相关的新公式。由此得到如下命题公式对偶式的概念：  
【定义3.16】对于任意一个限制性命题公式$G$，将其中 $\wedge$换成$\lor$、$\vee$换成 $\wedge$、$T$换成$F$、$F$换成$T$，得到的新公式称为$G$的对偶式，记为$G^{*}$。  
例如：
$$
(1)G\Leftrightarrow(P\land F);\quad G^{*}=P\lor T_{\circ}\;\;(\,2\,)\;\;G\Leftrightarrow(P\lor Q)\land R;\;\;G^{*}\Leftrightarrow(P\land Q)\lor R\,_{\circ}
$$  
下面两个定理分别给出了内否式和对偶式的基本性质于基本关系：  
【定理3.5】假设$G$和$H$都是限制性命题公式，则成立下列等值式：  
$\begin{aligned}&(1) (G^{*})^{*}\Leftrightarrow G, (G^{\neg})^{\neg}\Leftrightarrow G; (2) (G\vee H)^{*}\Leftrightarrow G^{*}\wedge H^{*}; (G\vee H)^{\neg}\Leftrightarrow G^{\neg}\vee H^{\neg};\\&(3) (G\wedge H)^{*}\Leftrightarrow G^{*}\vee H^{*}; (G\wedge H)^{\neg}\Leftrightarrow G^{\neg}\wedge H^{\neg}。\end{aligned}$  
【定理3.6】设$G$和$G^{*}$互为对偶式，$P_{1},P_{2},\cdots P_{n}$是出现在$G$和$G^{*}$中的全部命题变项，将$G$和$G^{*}$写成$\mathsf{n}$ 元函数形式，则有：
$$
(1)\neg G(P_{1},P_{2},\cdots,P_{n})\Leftrightarrow G^{*}(\neg P_{1},\neg P_{2},\cdots,\neg P_{n})\Leftrightarrow(G^{\neg})^{*}(P_{1},\cdots,P_{n})\tag{3-1}
$$  
$$
G^{\neg}(P_{1},P_{2},\cdots,P_{n})\Leftrightarrow G(\neg P_{1},\neg P_{2},\cdots,\neg P_{n})\Leftrightarrow\neg G^{*}(P_{1},P_{2},\cdots,P_{n})\tag{3-2}
$$  
上述定理的第（1）条表明命题公式$G$的否定与其命题变元否定的对偶式，即与该公式内否式的对偶式等值；第（2）条表明命题公式$G$的内否式与该公式对偶式的否定等值。  
【定理3.7】（对偶原理）假设$P_{1},P_{2},\cdots,P_{n}$是出现在命题公式$P$和$Q$中的所有原子变元，如果$P\Leftrightarrow Q$，那么$P^{*}\Leftrightarrow Q^{*}$。  
对偶原理表明命题公式之间所有等值关系都是成对的。也就是说，对于任意一个等值式，都可由对偶原理构造一个与之对偶的等值式。例如，对于等值式$P\to Q\Leftrightarrow\neg P\lor Q$，则可构造出其对偶等值式$\neg P\land Q\Leftrightarrow\neg(\neg P\rightarrow\neg Q)$。因为$\neg P\land Q\Leftrightarrow\neg(P\lor\neg Q)\Leftrightarrow\neg(\neg P\to\neg Q)$。",定理3.7定义了对偶原理，表明命题公式之间的等值关系在对偶操作下保持成立。
联结词的完备集,关联,联结词的枚举问题,,前面学习了五个常用逻辑运算联结词。细心的读者可能会想到下面两个问题：一是联结词的枚举问题，或者说除了这五个常用联结词之外，还有哪些运算联结词？二是联结词的完备集问题，亦即：这五个常用联结词是否可以表示任意命题公式，至少需要多少种运算联结词才能表示任意命题公式？本节主要考察这两个问题。,联结词的完备集与联结词的枚举问题是逻辑运算联结词研究的两个主要问题
联结词的完备集,考察,常用逻辑运算联结词,,前面学习了五个常用逻辑运算联结词。细心的读者可能会想到下面两个问题：一是联结词的枚举问题，或者说除了这五个常用联结词之外，还有哪些运算联结词？二是联结词的完备集问题，亦即：这五个常用联结词是否可以表示任意命题公式，至少需要多少种运算联结词才能表示任意命题公式？本节主要考察这两个问题。,联结词的完备集问题考察常用逻辑运算联结词是否能表示任意命题公式
联结词的枚举,依赖,n元真值函数,,"不难看出，每个运算联结词分别对应一个命题公式，且彼此不同的运算联结词所对应的命题公式也互不相同。尽管可以通过命题公式的定义构造出无穷多个形态各异的命题公式，但是这些命题公式中有很多是彼此等值的。因此，如果我们将彼此等值命题公式视为同一种类型并且能够计算出类型的数目，那么命题运算联结词的枚举问题便迎刃而解。  
对于任意一个含有$\cdot_{n}$个命题变量的命题公式，都可以将它看成是一个由这$n$个变量为自变量的𝑛元函数。显然，每个自变量的取值以及函数值的取值均为{真，假}或{0, 1}，故有如下𝑛元真值函数的相关定义：  
【定义3.17】假设𝐺是一个含有$\cdot_{n}$个命题变元的命题公式，则称𝐺是一个$\mathbfit{n}$元真值函数。在所有的$n$元真值函数中，将相互等值的真值函数归为一类，并从每个类中分别选取一个$_{n}$元真值函数作为该的类代表，称这种具有代表性质的真值函数为$\mathbfit{n}$元真值函项。  
显然，$n$元真值函数的种类数就是$n$元真值函项的个数。因此，下面着重考察如何对n 元真值函项进行计数和枚举。  
对于一元真值函数$G(P)$，它只含有一个命题变元𝑃。由于$P$只有$T$和$F$两种取值状态且对于每种状态，$G(P)$都只有$T$和$F$两种不同取值方式，由计数的乘法原理知，$G(P)$有且仅有有4 种不同的表现形式，如表3-13 所示。  
表3-13  一元真值函数
![](images/7e299ca38127d46167de49648c7ba3b93226e9a0d0de2bd6d7016fad80f5bc00.jpg)  
从表3-13 中可以看出，一元真值函数$G(P)$有且仅有4 种不同类型。由此可以得到如下全部四个不同的一元真值函项：  
$$
G_{1}(P)\Leftrightarrow T;\,\,\,G_{2}(P)\Leftrightarrow P;\,\,\,G_{3}(P)\Leftrightarrow\neg P\,;\,\,\,\,\,G_{4}(P)\Leftrightarrow F
$$  
由此可见，非平凡的一元逻辑运算联结词只有$\neg$运算，即 $G_{3}(P)=\neg P$  
下面考察二元真值函数$G(P,Q)$：由于每个命题变量分别取T和F两种状态，故$P$与$Q$的取值状态组合数为4。对于$\cdot P$与$Q$每一种组合状态，$G(P,Q)$都有$T$和$F$这两种取值状态，由计数的乘法原理知，$G(P,Q)$有且仅有有$2^{4}{=}16$ 种不同表现形式，如表3-14 所示。  
![](images/07f980b35eb2afa32c89cb472f39cdcc1aa211c2d1dac882499a493bebe3a0fa.jpg)  
从表3-14 中可以看出，二元真值函数$G(P,Q)$有且仅有16 种不同类型。由此可以得到如下全部16 个不同的二元真值函项：  
$G_{1}(P,Q)\Leftrightarrow P\land\lnot P;\,\,\,G_{2}(P,Q)\Leftrightarrow P\land Q;\,\,\,G_{3}(P,Q)\Leftrightarrow\lnot(P\to Q)\,;\quad G_{4}(P,Q)\Leftrightarrow P\,;$ $G_{5}(P,Q)\Leftrightarrow\neg(Q\to P);\;\;G_{6}(P,Q)\Leftrightarrow Q;\;\;G_{7}(P,Q)\Leftrightarrow\neg(P\leftrightarrow Q);\quad G_{8}(P,Q)\Leftrightarrow P\lor Q;$ $G_{9}(P,Q)\Leftrightarrow\neg(P\vee Q);\;\;G_{10}(P,Q)\Leftrightarrow P\leftrightarrow Q;\;\;G_{11}(P,Q)\Leftrightarrow\neg Q;\quad G_{12}(P,Q)\Leftrightarrow Q\rightarrow P$ $G_{13}(P,Q)\Leftrightarrow\neg P;\;\;G_{14}(P,Q)\Leftrightarrow P\rightarrow Q;\;\;G_{15}(P,Q)\Leftrightarrow\neg(P\wedge Q);\quad\;G_{16}(P,Q)\Leftrightarrow P\vee\neg P$  
由此可见，非平凡二元逻辑运算联结词一共有9 个，除了前面已学的5 个常用联结词$\neg，\wedge，\vee，\rightarrow，\leftrightarrow$之外，还有如下4 个新的运算联结词，即：$\overline{{\mathsf{V}}}\,,\,\nrightarrow\,\uparrow\,,\,\downarrow$。这4 种联结词的真值取值规则如表3-15 和表3-16 所示。  
表3-15  4 种新联结词的含义与表示
![](images/06836354c54edf7769126bc450a894d316d020c9711d3c09afa06457b363815b.jpg)  
表3-16  4 种新联结词的真值
![](images/731846b634a2ef84c0898fbd837a1e716d721d529b86c9bb6916ff3a66582dbc.jpg)  
由表3-15 和表3-16 真可知：  
$P\;{\overline{{\lor}}}\;Q\Leftrightarrow\neg(P\leftrightarrow Q)\colon\;P\nrightarrow Q\Leftrightarrow\neg(P\rightarrow Q)\colon\;P\uparrow Q\Leftrightarrow\neg(P\wedge Q)\colon\;P\downarrow Q\Leftrightarrow\neg(P\vee Q)$  
对于一般$_{n}$元真值函数$G(P_{1},P_{2},\cdots,P_{n})$，其$.n$个命题变量$P_{1},P_{2},\cdots,P_{n}$的取值状态组合数为$2^{n}$。对于每个取值状态的组合，$G(P_{1},P_{2},\cdots,P_{n})$均有$T$和$F$这两种取值。因此，$G(P_{1},P_{2},\cdots,P_{n})$有且仅有$2^{2^{n}}$种不同表现形式，即有且仅有$\cdot2^{2^{n}}$个$_{n}$元真值函项。例如，当$n=3$时，有且仅有$2^{8}{=}256$ 个真值函项，由此可得到所有非平凡三元逻辑运算联结词，具体不再赘述。",联结词的枚举问题依赖于n元真值函数的计数和枚举
一元真值函数,包含,非平凡逻辑运算联结词,,"不难看出，每个运算联结词分别对应一个命题公式，且彼此不同的运算联结词所对应的命题公式也互不相同。尽管可以通过命题公式的定义构造出无穷多个形态各异的命题公式，但是这些命题公式中有很多是彼此等值的。因此，如果我们将彼此等值命题公式视为同一种类型并且能够计算出类型的数目，那么命题运算联结词的枚举问题便迎刃而解。  
对于任意一个含有$\cdot_{n}$个命题变量的命题公式，都可以将它看成是一个由这$n$个变量为自变量的𝑛元函数。显然，每个自变量的取值以及函数值的取值均为{真，假}或{0, 1}，故有如下𝑛元真值函数的相关定义：  
【定义3.17】假设𝐺是一个含有$\cdot_{n}$个命题变元的命题公式，则称𝐺是一个$\mathbfit{n}$元真值函数。在所有的$n$元真值函数中，将相互等值的真值函数归为一类，并从每个类中分别选取一个$_{n}$元真值函数作为该的类代表，称这种具有代表性质的真值函数为$\mathbfit{n}$元真值函项。  
显然，$n$元真值函数的种类数就是$n$元真值函项的个数。因此，下面着重考察如何对n 元真值函项进行计数和枚举。  
对于一元真值函数$G(P)$，它只含有一个命题变元𝑃。由于$P$只有$T$和$F$两种取值状态且对于每种状态，$G(P)$都只有$T$和$F$两种不同取值方式，由计数的乘法原理知，$G(P)$有且仅有有4 种不同的表现形式，如表3-13 所示。  
表3-13  一元真值函数
![](images/7e299ca38127d46167de49648c7ba3b93226e9a0d0de2bd6d7016fad80f5bc00.jpg)  
从表3-13 中可以看出，一元真值函数$G(P)$有且仅有4 种不同类型。由此可以得到如下全部四个不同的一元真值函项：  
$$
G_{1}(P)\Leftrightarrow T;\,\,\,G_{2}(P)\Leftrightarrow P;\,\,\,G_{3}(P)\Leftrightarrow\neg P\,;\,\,\,\,\,G_{4}(P)\Leftrightarrow F
$$  
由此可见，非平凡的一元逻辑运算联结词只有$\neg$运算，即 $G_{3}(P)=\neg P$  
下面考察二元真值函数$G(P,Q)$：由于每个命题变量分别取T和F两种状态，故$P$与$Q$的取值状态组合数为4。对于$\cdot P$与$Q$每一种组合状态，$G(P,Q)$都有$T$和$F$这两种取值状态，由计数的乘法原理知，$G(P,Q)$有且仅有有$2^{4}{=}16$ 种不同表现形式，如表3-14 所示。  
![](images/07f980b35eb2afa32c89cb472f39cdcc1aa211c2d1dac882499a493bebe3a0fa.jpg)  
从表3-14 中可以看出，二元真值函数$G(P,Q)$有且仅有16 种不同类型。由此可以得到如下全部16 个不同的二元真值函项：  
$G_{1}(P,Q)\Leftrightarrow P\land\lnot P;\,\,\,G_{2}(P,Q)\Leftrightarrow P\land Q;\,\,\,G_{3}(P,Q)\Leftrightarrow\lnot(P\to Q)\,;\quad G_{4}(P,Q)\Leftrightarrow P\,;$ $G_{5}(P,Q)\Leftrightarrow\neg(Q\to P);\;\;G_{6}(P,Q)\Leftrightarrow Q;\;\;G_{7}(P,Q)\Leftrightarrow\neg(P\leftrightarrow Q);\quad G_{8}(P,Q)\Leftrightarrow P\lor Q;$ $G_{9}(P,Q)\Leftrightarrow\neg(P\vee Q);\;\;G_{10}(P,Q)\Leftrightarrow P\leftrightarrow Q;\;\;G_{11}(P,Q)\Leftrightarrow\neg Q;\quad G_{12}(P,Q)\Leftrightarrow Q\rightarrow P$ $G_{13}(P,Q)\Leftrightarrow\neg P;\;\;G_{14}(P,Q)\Leftrightarrow P\rightarrow Q;\;\;G_{15}(P,Q)\Leftrightarrow\neg(P\wedge Q);\quad\;G_{16}(P,Q)\Leftrightarrow P\vee\neg P$  
由此可见，非平凡二元逻辑运算联结词一共有9 个，除了前面已学的5 个常用联结词$\neg，\wedge，\vee，\rightarrow，\leftrightarrow$之外，还有如下4 个新的运算联结词，即：$\overline{{\mathsf{V}}}\,,\,\nrightarrow\,\uparrow\,,\,\downarrow$。这4 种联结词的真值取值规则如表3-15 和表3-16 所示。  
表3-15  4 种新联结词的含义与表示
![](images/06836354c54edf7769126bc450a894d316d020c9711d3c09afa06457b363815b.jpg)  
表3-16  4 种新联结词的真值
![](images/731846b634a2ef84c0898fbd837a1e716d721d529b86c9bb6916ff3a66582dbc.jpg)  
由表3-15 和表3-16 真可知：  
$P\;{\overline{{\lor}}}\;Q\Leftrightarrow\neg(P\leftrightarrow Q)\colon\;P\nrightarrow Q\Leftrightarrow\neg(P\rightarrow Q)\colon\;P\uparrow Q\Leftrightarrow\neg(P\wedge Q)\colon\;P\downarrow Q\Leftrightarrow\neg(P\vee Q)$  
对于一般$_{n}$元真值函数$G(P_{1},P_{2},\cdots,P_{n})$，其$.n$个命题变量$P_{1},P_{2},\cdots,P_{n}$的取值状态组合数为$2^{n}$。对于每个取值状态的组合，$G(P_{1},P_{2},\cdots,P_{n})$均有$T$和$F$这两种取值。因此，$G(P_{1},P_{2},\cdots,P_{n})$有且仅有$2^{2^{n}}$种不同表现形式，即有且仅有$\cdot2^{2^{n}}$个$_{n}$元真值函项。例如，当$n=3$时，有且仅有$2^{8}{=}256$ 个真值函项，由此可得到所有非平凡三元逻辑运算联结词，具体不再赘述。",一元真值函数中包含唯一的非平凡逻辑运算联结词即否定运算
二元真值函数,包含,非平凡逻辑运算联结词,,"不难看出，每个运算联结词分别对应一个命题公式，且彼此不同的运算联结词所对应的命题公式也互不相同。尽管可以通过命题公式的定义构造出无穷多个形态各异的命题公式，但是这些命题公式中有很多是彼此等值的。因此，如果我们将彼此等值命题公式视为同一种类型并且能够计算出类型的数目，那么命题运算联结词的枚举问题便迎刃而解。  
对于任意一个含有$\cdot_{n}$个命题变量的命题公式，都可以将它看成是一个由这$n$个变量为自变量的𝑛元函数。显然，每个自变量的取值以及函数值的取值均为{真，假}或{0, 1}，故有如下𝑛元真值函数的相关定义：  
【定义3.17】假设𝐺是一个含有$\cdot_{n}$个命题变元的命题公式，则称𝐺是一个$\mathbfit{n}$元真值函数。在所有的$n$元真值函数中，将相互等值的真值函数归为一类，并从每个类中分别选取一个$_{n}$元真值函数作为该的类代表，称这种具有代表性质的真值函数为$\mathbfit{n}$元真值函项。  
显然，$n$元真值函数的种类数就是$n$元真值函项的个数。因此，下面着重考察如何对n 元真值函项进行计数和枚举。  
对于一元真值函数$G(P)$，它只含有一个命题变元𝑃。由于$P$只有$T$和$F$两种取值状态且对于每种状态，$G(P)$都只有$T$和$F$两种不同取值方式，由计数的乘法原理知，$G(P)$有且仅有有4 种不同的表现形式，如表3-13 所示。  
表3-13  一元真值函数
![](images/7e299ca38127d46167de49648c7ba3b93226e9a0d0de2bd6d7016fad80f5bc00.jpg)  
从表3-13 中可以看出，一元真值函数$G(P)$有且仅有4 种不同类型。由此可以得到如下全部四个不同的一元真值函项：  
$$
G_{1}(P)\Leftrightarrow T;\,\,\,G_{2}(P)\Leftrightarrow P;\,\,\,G_{3}(P)\Leftrightarrow\neg P\,;\,\,\,\,\,G_{4}(P)\Leftrightarrow F
$$  
由此可见，非平凡的一元逻辑运算联结词只有$\neg$运算，即 $G_{3}(P)=\neg P$  
下面考察二元真值函数$G(P,Q)$：由于每个命题变量分别取T和F两种状态，故$P$与$Q$的取值状态组合数为4。对于$\cdot P$与$Q$每一种组合状态，$G(P,Q)$都有$T$和$F$这两种取值状态，由计数的乘法原理知，$G(P,Q)$有且仅有有$2^{4}{=}16$ 种不同表现形式，如表3-14 所示。  
![](images/07f980b35eb2afa32c89cb472f39cdcc1aa211c2d1dac882499a493bebe3a0fa.jpg)  
从表3-14 中可以看出，二元真值函数$G(P,Q)$有且仅有16 种不同类型。由此可以得到如下全部16 个不同的二元真值函项：  
$G_{1}(P,Q)\Leftrightarrow P\land\lnot P;\,\,\,G_{2}(P,Q)\Leftrightarrow P\land Q;\,\,\,G_{3}(P,Q)\Leftrightarrow\lnot(P\to Q)\,;\quad G_{4}(P,Q)\Leftrightarrow P\,;$ $G_{5}(P,Q)\Leftrightarrow\neg(Q\to P);\;\;G_{6}(P,Q)\Leftrightarrow Q;\;\;G_{7}(P,Q)\Leftrightarrow\neg(P\leftrightarrow Q);\quad G_{8}(P,Q)\Leftrightarrow P\lor Q;$ $G_{9}(P,Q)\Leftrightarrow\neg(P\vee Q);\;\;G_{10}(P,Q)\Leftrightarrow P\leftrightarrow Q;\;\;G_{11}(P,Q)\Leftrightarrow\neg Q;\quad G_{12}(P,Q)\Leftrightarrow Q\rightarrow P$ $G_{13}(P,Q)\Leftrightarrow\neg P;\;\;G_{14}(P,Q)\Leftrightarrow P\rightarrow Q;\;\;G_{15}(P,Q)\Leftrightarrow\neg(P\wedge Q);\quad\;G_{16}(P,Q)\Leftrightarrow P\vee\neg P$  
由此可见，非平凡二元逻辑运算联结词一共有9 个，除了前面已学的5 个常用联结词$\neg，\wedge，\vee，\rightarrow，\leftrightarrow$之外，还有如下4 个新的运算联结词，即：$\overline{{\mathsf{V}}}\,,\,\nrightarrow\,\uparrow\,,\,\downarrow$。这4 种联结词的真值取值规则如表3-15 和表3-16 所示。  
表3-15  4 种新联结词的含义与表示
![](images/06836354c54edf7769126bc450a894d316d020c9711d3c09afa06457b363815b.jpg)  
表3-16  4 种新联结词的真值
![](images/731846b634a2ef84c0898fbd837a1e716d721d529b86c9bb6916ff3a66582dbc.jpg)  
由表3-15 和表3-16 真可知：  
$P\;{\overline{{\lor}}}\;Q\Leftrightarrow\neg(P\leftrightarrow Q)\colon\;P\nrightarrow Q\Leftrightarrow\neg(P\rightarrow Q)\colon\;P\uparrow Q\Leftrightarrow\neg(P\wedge Q)\colon\;P\downarrow Q\Leftrightarrow\neg(P\vee Q)$  
对于一般$_{n}$元真值函数$G(P_{1},P_{2},\cdots,P_{n})$，其$.n$个命题变量$P_{1},P_{2},\cdots,P_{n}$的取值状态组合数为$2^{n}$。对于每个取值状态的组合，$G(P_{1},P_{2},\cdots,P_{n})$均有$T$和$F$这两种取值。因此，$G(P_{1},P_{2},\cdots,P_{n})$有且仅有$2^{2^{n}}$种不同表现形式，即有且仅有$\cdot2^{2^{n}}$个$_{n}$元真值函项。例如，当$n=3$时，有且仅有$2^{8}{=}256$ 个真值函项，由此可得到所有非平凡三元逻辑运算联结词，具体不再赘述。",二元真值函数中包含多个非平凡逻辑运算联结词，包括常用联结词和新的联结词
n元真值函数,推导,非平凡逻辑运算联结词,,"不难看出，每个运算联结词分别对应一个命题公式，且彼此不同的运算联结词所对应的命题公式也互不相同。尽管可以通过命题公式的定义构造出无穷多个形态各异的命题公式，但是这些命题公式中有很多是彼此等值的。因此，如果我们将彼此等值命题公式视为同一种类型并且能够计算出类型的数目，那么命题运算联结词的枚举问题便迎刃而解。  
对于任意一个含有$\cdot_{n}$个命题变量的命题公式，都可以将它看成是一个由这$n$个变量为自变量的𝑛元函数。显然，每个自变量的取值以及函数值的取值均为{真，假}或{0, 1}，故有如下𝑛元真值函数的相关定义：  
【定义3.17】假设𝐺是一个含有$\cdot_{n}$个命题变元的命题公式，则称𝐺是一个$\mathbfit{n}$元真值函数。在所有的$n$元真值函数中，将相互等值的真值函数归为一类，并从每个类中分别选取一个$_{n}$元真值函数作为该的类代表，称这种具有代表性质的真值函数为$\mathbfit{n}$元真值函项。  
显然，$n$元真值函数的种类数就是$n$元真值函项的个数。因此，下面着重考察如何对n 元真值函项进行计数和枚举。  
对于一元真值函数$G(P)$，它只含有一个命题变元𝑃。由于$P$只有$T$和$F$两种取值状态且对于每种状态，$G(P)$都只有$T$和$F$两种不同取值方式，由计数的乘法原理知，$G(P)$有且仅有有4 种不同的表现形式，如表3-13 所示。  
表3-13  一元真值函数
![](images/7e299ca38127d46167de49648c7ba3b93226e9a0d0de2bd6d7016fad80f5bc00.jpg)  
从表3-13 中可以看出，一元真值函数$G(P)$有且仅有4 种不同类型。由此可以得到如下全部四个不同的一元真值函项：  
$$
G_{1}(P)\Leftrightarrow T;\,\,\,G_{2}(P)\Leftrightarrow P;\,\,\,G_{3}(P)\Leftrightarrow\neg P\,;\,\,\,\,\,G_{4}(P)\Leftrightarrow F
$$  
由此可见，非平凡的一元逻辑运算联结词只有$\neg$运算，即 $G_{3}(P)=\neg P$  
下面考察二元真值函数$G(P,Q)$：由于每个命题变量分别取T和F两种状态，故$P$与$Q$的取值状态组合数为4。对于$\cdot P$与$Q$每一种组合状态，$G(P,Q)$都有$T$和$F$这两种取值状态，由计数的乘法原理知，$G(P,Q)$有且仅有有$2^{4}{=}16$ 种不同表现形式，如表3-14 所示。  
![](images/07f980b35eb2afa32c89cb472f39cdcc1aa211c2d1dac882499a493bebe3a0fa.jpg)  
从表3-14 中可以看出，二元真值函数$G(P,Q)$有且仅有16 种不同类型。由此可以得到如下全部16 个不同的二元真值函项：  
$G_{1}(P,Q)\Leftrightarrow P\land\lnot P;\,\,\,G_{2}(P,Q)\Leftrightarrow P\land Q;\,\,\,G_{3}(P,Q)\Leftrightarrow\lnot(P\to Q)\,;\quad G_{4}(P,Q)\Leftrightarrow P\,;$ $G_{5}(P,Q)\Leftrightarrow\neg(Q\to P);\;\;G_{6}(P,Q)\Leftrightarrow Q;\;\;G_{7}(P,Q)\Leftrightarrow\neg(P\leftrightarrow Q);\quad G_{8}(P,Q)\Leftrightarrow P\lor Q;$ $G_{9}(P,Q)\Leftrightarrow\neg(P\vee Q);\;\;G_{10}(P,Q)\Leftrightarrow P\leftrightarrow Q;\;\;G_{11}(P,Q)\Leftrightarrow\neg Q;\quad G_{12}(P,Q)\Leftrightarrow Q\rightarrow P$ $G_{13}(P,Q)\Leftrightarrow\neg P;\;\;G_{14}(P,Q)\Leftrightarrow P\rightarrow Q;\;\;G_{15}(P,Q)\Leftrightarrow\neg(P\wedge Q);\quad\;G_{16}(P,Q)\Leftrightarrow P\vee\neg P$  
由此可见，非平凡二元逻辑运算联结词一共有9 个，除了前面已学的5 个常用联结词$\neg，\wedge，\vee，\rightarrow，\leftrightarrow$之外，还有如下4 个新的运算联结词，即：$\overline{{\mathsf{V}}}\,,\,\nrightarrow\,\uparrow\,,\,\downarrow$。这4 种联结词的真值取值规则如表3-15 和表3-16 所示。  
表3-15  4 种新联结词的含义与表示
![](images/06836354c54edf7769126bc450a894d316d020c9711d3c09afa06457b363815b.jpg)  
表3-16  4 种新联结词的真值
![](images/731846b634a2ef84c0898fbd837a1e716d721d529b86c9bb6916ff3a66582dbc.jpg)  
由表3-15 和表3-16 真可知：  
$P\;{\overline{{\lor}}}\;Q\Leftrightarrow\neg(P\leftrightarrow Q)\colon\;P\nrightarrow Q\Leftrightarrow\neg(P\rightarrow Q)\colon\;P\uparrow Q\Leftrightarrow\neg(P\wedge Q)\colon\;P\downarrow Q\Leftrightarrow\neg(P\vee Q)$  
对于一般$_{n}$元真值函数$G(P_{1},P_{2},\cdots,P_{n})$，其$.n$个命题变量$P_{1},P_{2},\cdots,P_{n}$的取值状态组合数为$2^{n}$。对于每个取值状态的组合，$G(P_{1},P_{2},\cdots,P_{n})$均有$T$和$F$这两种取值。因此，$G(P_{1},P_{2},\cdots,P_{n})$有且仅有$2^{2^{n}}$种不同表现形式，即有且仅有$\cdot2^{2^{n}}$个$_{n}$元真值函项。例如，当$n=3$时，有且仅有$2^{8}{=}256$ 个真值函项，由此可得到所有非平凡三元逻辑运算联结词，具体不再赘述。",通过n元真值函数的计数和枚举可以推导出所有非平凡逻辑运算联结词
联结词的完备集,包含,极小完备联结词集合,,"现在我们进一步考察联结词的表示功能的完备性问题，即至少需要多少种运算联结词才能表示任意命题公式？首先给出如下联结词功能完备集的概念：  
【定义3.18】假设𝑆是一个由逻辑运算联结词组成的集合，如果对于任意一个命题公式，都有由𝑆中联结词表示出来的命题公式与之等值，则称𝑆是一个完备的联结词集合，或者说𝑆是一个联结词的完备集。  
由联结词的枚举可知联结词的数量或种类有很多，其实不难发现其中有很多联结词之间是可以互推的，或者说可以相互表示。因此，对于一个联结词的完备集，其中可能会存在联结词的冗余，有时需要消除这种冗余，故有如下极小完备联结词集合的概念：  
【定义3.19】假设𝑆是一个任意给定的联结词的完备集，从𝑆中任意删除一个联结词后得到新的联结词集合$\boldsymbol{\cdot}\boldsymbol{S}^{*}$，则$S^{*}$不是联结词的完备集，也就是说，至少有一个命题公式不能等价于由$S^{*}$中联结词表示的任一公式，此时称𝑆是一个极小完备联结词集合。  
通常都需要选用适当的联结词完备集以更加方便地进行命题公式演算。由于命题公式的归纳定义仅涉及一元联结词和二元联结词，故仅需考察由一元联结词和二元联结词为元素组成的联结词集合。下面给出一些重要的联结词完备集：  
由于：$P\rightarrow Q\Leftrightarrow\neg P\rightarrow Q,\,\,\,P\leftrightarrow Q\Leftrightarrow(\neg P\lor Q)\land(\neg Q\lor P),\,\,\,P\land Q\Leftrightarrow\neg(\neg P\lor\neg Q)$。所以$\{\neg,\ \vee\}$可构成极小完备集，同理$\{\neg,\ \land\}$也可以构成极小完备集。  
由于：$P\vee Q\Leftrightarrow\neg P\rightarrow Q， \Rightarrow\neg P\to Q\ ,\ \ P\land Q\Leftrightarrow\neg(\neg P\lor\neg Q)\Leftrightarrow\neg(P\to\neg Q)\ ,\ \ P\leftrightarrow Q\Leftrightarrow(P\to Q)\land$  
$(Q\rightarrow P)$。所以$\{\neg,\ \ \rightarrow\}$可以构成极小完备集。  
由于$P\land Q\Leftrightarrow\neg(\neg P\lor\neg Q)\Leftrightarrow\neg(P\to\neg Q)\Leftrightarrow P\nRightarrow\neg Q$，故$\{\neg,\quad\nrightarrow\}$可构成极小完备集。  
由于$\neg P\Leftrightarrow\neg(P\land P)\Leftrightarrow P\uparrow P,$，$P\land Q\Leftrightarrow\neg\neg(P\land Q)\Leftrightarrow\neg\ P\uparrow Q$，故{↑}可构成极小完备集。同理，$\{\downarrow\}$可构成极小完备集。↑和↓在大规模集成电路中具有广泛应用。  
由以上的分析可知， $\{\neg,\ \ \vee\},\ \{\neg,\ \ \wedge\},\ \{\neg,\ \ \rightarrow\},\ \ \{\neg,\ \ \nrightarrow\},\ \ \{\uparrow\} \},$都是极小完备集，$\left\{\neg,\ \ \lor\ ,\ \ \land\right\}$是一个完备的联结词集合。但是$\{\lor\},\ \{\land\},\ \{\lor,\ \land\}$等都不是极小完备集",联结词的完备集可能包含冗余联结词，而极小完备联结词集合是去除冗余后的最小完备集
重要的联结词完备集,示例,极小完备联结词集合,,"现在我们进一步考察联结词的表示功能的完备性问题，即至少需要多少种运算联结词才能表示任意命题公式？首先给出如下联结词功能完备集的概念：  
【定义3.18】假设𝑆是一个由逻辑运算联结词组成的集合，如果对于任意一个命题公式，都有由𝑆中联结词表示出来的命题公式与之等值，则称𝑆是一个完备的联结词集合，或者说𝑆是一个联结词的完备集。  
由联结词的枚举可知联结词的数量或种类有很多，其实不难发现其中有很多联结词之间是可以互推的，或者说可以相互表示。因此，对于一个联结词的完备集，其中可能会存在联结词的冗余，有时需要消除这种冗余，故有如下极小完备联结词集合的概念：  
【定义3.19】假设𝑆是一个任意给定的联结词的完备集，从𝑆中任意删除一个联结词后得到新的联结词集合$\boldsymbol{\cdot}\boldsymbol{S}^{*}$，则$S^{*}$不是联结词的完备集，也就是说，至少有一个命题公式不能等价于由$S^{*}$中联结词表示的任一公式，此时称𝑆是一个极小完备联结词集合。  
通常都需要选用适当的联结词完备集以更加方便地进行命题公式演算。由于命题公式的归纳定义仅涉及一元联结词和二元联结词，故仅需考察由一元联结词和二元联结词为元素组成的联结词集合。下面给出一些重要的联结词完备集：  
由于：$P\rightarrow Q\Leftrightarrow\neg P\rightarrow Q,\,\,\,P\leftrightarrow Q\Leftrightarrow(\neg P\lor Q)\land(\neg Q\lor P),\,\,\,P\land Q\Leftrightarrow\neg(\neg P\lor\neg Q)$。所以$\{\neg,\ \vee\}$可构成极小完备集，同理$\{\neg,\ \land\}$也可以构成极小完备集。  
由于：$P\vee Q\Leftrightarrow\neg P\rightarrow Q， \Rightarrow\neg P\to Q\ ,\ \ P\land Q\Leftrightarrow\neg(\neg P\lor\neg Q)\Leftrightarrow\neg(P\to\neg Q)\ ,\ \ P\leftrightarrow Q\Leftrightarrow(P\to Q)\land$  
$(Q\rightarrow P)$。所以$\{\neg,\ \ \rightarrow\}$可以构成极小完备集。  
由于$P\land Q\Leftrightarrow\neg(\neg P\lor\neg Q)\Leftrightarrow\neg(P\to\neg Q)\Leftrightarrow P\nRightarrow\neg Q$，故$\{\neg,\quad\nrightarrow\}$可构成极小完备集。  
由于$\neg P\Leftrightarrow\neg(P\land P)\Leftrightarrow P\uparrow P,$，$P\land Q\Leftrightarrow\neg\neg(P\land Q)\Leftrightarrow\neg\ P\uparrow Q$，故{↑}可构成极小完备集。同理，$\{\downarrow\}$可构成极小完备集。↑和↓在大规模集成电路中具有广泛应用。  
由以上的分析可知， $\{\neg,\ \ \vee\},\ \{\neg,\ \ \wedge\},\ \{\neg,\ \ \rightarrow\},\ \ \{\neg,\ \ \nrightarrow\},\ \ \{\uparrow\} \},$都是极小完备集，$\left\{\neg,\ \ \lor\ ,\ \ \land\right\}$是一个完备的联结词集合。但是$\{\lor\},\ \{\land\},\ \{\lor,\ \land\}$等都不是极小完备集","重要的联结词完备集包括多个极小完备联结词集合，如{¬, ∨}, {¬, ∧}, {¬, →}, {¬, ↚}, {↑}"
命题公式的范式,代表,命题公式,,如前所述，虽然可以构造出无穷多个命题公式，但是这些命题公式中有很多是彼此等值的，将彼此等值的命题公式视为同一种类型，便可实现对所有命题公式的分类。属于同一种类型的命题公式除了在表现形式上有所差异之外，其它性质完全相同。因此，可以对命题公式的表达制定一个统一规范的标准形式，使得每种命题公式都分别具有唯一一个与之相对应的标准命题公式，并将这个标准命题公式作为其所属公式类型中所有命题公式的代表，或者说作为其所属公式类型中所有命题公式的范式。范式为千变万化的命题公式确定了一个统一的表达形式，在命题演算与推理中具有极其重要的作用，例如可以使用范式判断任意两个命题公式是否等值、判断命题公式的类型，还可以使用范式进行电路设计等等。,命题公式的范式是每种命题公式的唯一标准形式，作为其所属公式类型中所有命题公式的代表
命题公式的范式,作用,命题演算与推理,,如前所述，虽然可以构造出无穷多个命题公式，但是这些命题公式中有很多是彼此等值的，将彼此等值的命题公式视为同一种类型，便可实现对所有命题公式的分类。属于同一种类型的命题公式除了在表现形式上有所差异之外，其它性质完全相同。因此，可以对命题公式的表达制定一个统一规范的标准形式，使得每种命题公式都分别具有唯一一个与之相对应的标准命题公式，并将这个标准命题公式作为其所属公式类型中所有命题公式的代表，或者说作为其所属公式类型中所有命题公式的范式。范式为千变万化的命题公式确定了一个统一的表达形式，在命题演算与推理中具有极其重要的作用，例如可以使用范式判断任意两个命题公式是否等值、判断命题公式的类型，还可以使用范式进行电路设计等等。,命题公式的范式在命题演算与推理中具有重要作用，如判断命题公式是否等值和类型，以及用于电路设计
命题公式的范式,包含,否定,,现在考虑如何设计一个命题公式的范式。我们知道，否定、 合取、析取是三个最常用的逻辑运算联结词，而且可以表示任意命题公式。因此，命题公式的范式仅使用这三个联结词即可。设计命题公式范式的核心思想是将命题公式的运算分成内、中、外三个基本层次，将否定运算在公式的内层，将合取和析取中的一个统一放在中层，另外一个统一放在外层，由此形成一种比较规整的具有三层结构的表达形式。,命题公式的范式包含否定运算，并将其放在公式的内层
命题公式的范式,包含,合取,,现在考虑如何设计一个命题公式的范式。我们知道，否定、 合取、析取是三个最常用的逻辑运算联结词，而且可以表示任意命题公式。因此，命题公式的范式仅使用这三个联结词即可。设计命题公式范式的核心思想是将命题公式的运算分成内、中、外三个基本层次，将否定运算在公式的内层，将合取和析取中的一个统一放在中层，另外一个统一放在外层，由此形成一种比较规整的具有三层结构的表达形式。,命题公式的范式包含合取运算，并将其放在公式的中层或外层
命题公式的范式,包含,析取,,现在考虑如何设计一个命题公式的范式。我们知道，否定、 合取、析取是三个最常用的逻辑运算联结词，而且可以表示任意命题公式。因此，命题公式的范式仅使用这三个联结词即可。设计命题公式范式的核心思想是将命题公式的运算分成内、中、外三个基本层次，将否定运算在公式的内层，将合取和析取中的一个统一放在中层，另外一个统一放在外层，由此形成一种比较规整的具有三层结构的表达形式。,命题公式的范式包含析取运算，并将其放在公式的中层或外层
命题公式的范式,具有,三层结构,,现在考虑如何设计一个命题公式的范式。我们知道，否定、 合取、析取是三个最常用的逻辑运算联结词，而且可以表示任意命题公式。因此，命题公式的范式仅使用这三个联结词即可。设计命题公式范式的核心思想是将命题公式的运算分成内、中、外三个基本层次，将否定运算在公式的内层，将合取和析取中的一个统一放在中层，另外一个统一放在外层，由此形成一种比较规整的具有三层结构的表达形式。,命题公式的范式具有内、中、外三层结构的表达形式
文字,组成,析取式,,"在否定、合取、析取这三个联结词中，否定联结词具有最高的运算优先级，范式中用文字这个概念对其进行封装，规定范式中否定联结词只能作用于单个命题变量。这样就用文字的概念将否定运算封装命题公式范式的内层。下面给出文字概念的定义：  
【定义3.20】设𝑃是任意一个命题变量，则𝑃和$\neg P$均称为文字，且称𝑃和$\neg P$为互补对。由于合取和析取这两个联结词在运算上具有对等性质，也就是说合取运算具有析取运算的所有性质，析取运算也具有合取运算的所有性质。故有如下析取式与合取式的概念：  
【定义3.21】有限个文字的析取称为析取式，也称为子句；有限个文字的合取称为合取式，也称为短语。  
例如， $P$、 $\neg P$是文字、子句、短语； $P\lor Q\lor R$是子句； $P\land Q\land R$是短语。注意：一个命题变元或者其否定既可以是子句，也可以是短语。  
显然，析取式是一个具有两层结构的逻辑表达式，只有否定和析取这两种联结词，内层是否定联结词，外层是析取联结词；合取式也是一个具有两层结构的逻辑表达式，只有否定和合取这两种联结词，内层是否定联结词，外层是合取联结词。",有限个文字的析取称为析取式
文字,组成,合取式,,"在否定、合取、析取这三个联结词中，否定联结词具有最高的运算优先级，范式中用文字这个概念对其进行封装，规定范式中否定联结词只能作用于单个命题变量。这样就用文字的概念将否定运算封装命题公式范式的内层。下面给出文字概念的定义：  
【定义3.20】设𝑃是任意一个命题变量，则𝑃和$\neg P$均称为文字，且称𝑃和$\neg P$为互补对。由于合取和析取这两个联结词在运算上具有对等性质，也就是说合取运算具有析取运算的所有性质，析取运算也具有合取运算的所有性质。故有如下析取式与合取式的概念：  
【定义3.21】有限个文字的析取称为析取式，也称为子句；有限个文字的合取称为合取式，也称为短语。  
例如， $P$、 $\neg P$是文字、子句、短语； $P\lor Q\lor R$是子句； $P\land Q\land R$是短语。注意：一个命题变元或者其否定既可以是子句，也可以是短语。  
显然，析取式是一个具有两层结构的逻辑表达式，只有否定和析取这两种联结词，内层是否定联结词，外层是析取联结词；合取式也是一个具有两层结构的逻辑表达式，只有否定和合取这两种联结词，内层是否定联结词，外层是合取联结词。",有限个文字的合取称为合取式
析取式,对等性质,合取式,,"在否定、合取、析取这三个联结词中，否定联结词具有最高的运算优先级，范式中用文字这个概念对其进行封装，规定范式中否定联结词只能作用于单个命题变量。这样就用文字的概念将否定运算封装命题公式范式的内层。下面给出文字概念的定义：  
【定义3.20】设𝑃是任意一个命题变量，则𝑃和$\neg P$均称为文字，且称𝑃和$\neg P$为互补对。由于合取和析取这两个联结词在运算上具有对等性质，也就是说合取运算具有析取运算的所有性质，析取运算也具有合取运算的所有性质。故有如下析取式与合取式的概念：  
【定义3.21】有限个文字的析取称为析取式，也称为子句；有限个文字的合取称为合取式，也称为短语。  
例如， $P$、 $\neg P$是文字、子句、短语； $P\lor Q\lor R$是子句； $P\land Q\land R$是短语。注意：一个命题变元或者其否定既可以是子句，也可以是短语。  
显然，析取式是一个具有两层结构的逻辑表达式，只有否定和析取这两种联结词，内层是否定联结词，外层是析取联结词；合取式也是一个具有两层结构的逻辑表达式，只有否定和合取这两种联结词，内层是否定联结词，外层是合取联结词。",合取运算具有析取运算的所有性质，析取运算也具有合取运算的所有性质
析取范式,统称,合取范式,,"合取式是一个只有否定层与合取运算层的两层结构表达式，如果在其外层增加一个析取运算层，则得到所谓的析取范式；同样，析取式是一个只有否定层与析取运算层的两层结构表达式，如果在其外层增加一个合取运算层，则得到所谓的合取范式。  
【定义3.22】有限个短语的析取式称为析取范式；有限个子句的合取式称为合取范式。析取范式与合取范式统称为范式。 也就是说，一个命题公式为析取范式，当且仅当它具有形式：$A_{1}\lor A_{2}\lor\ldots\lor A_{n}$。其中，$A_{1}$，$A_{2}$，… ，$A_{n}$均为由命题变元或其否定所组成的合取式。  
例如，$(P\land\neg Q\land R)\lor(\neg P\land Q)\lor\neg R$是析取范式。  
同样地，一个命题公式称为合取范式，当且仅当该命题具形式：$B_{1}\wedge B_{2}\wedge\cdots\wedge B_{n}$。其中，$B_{1}$，$B_{2}$，⋯，$B_{n}$均为由命题变元或其否定所组成的析取式。  
例如，$(P\lor\neg Q\lor R)\land(\neg P\lor Q)\land\neg R$是合取范式。  
注意：①一个命题的析取范式或合取范式不唯一；②形如$P\land\neg Q\land R$的公式既可看成是由一个合取式构成的析取范式，也可以看成是由3 个析取式构成的合取范式，但是公式$(P\land$$\neg Q\land R)$只能将其看成是析取范式；③形如$P\lor\neg Q\lor R$的公式既是合取范式，又是析取范式，但$(P\lor\neg Q\lor R)$仅是合取范式。  
对于任意一个命题公式，下面定理保证了其析取范式和合取范式的存在性：  
【定理3.8】对于任意命题公式，都存在与其等值的析取范式和合取范式。",析取范式与合取范式统称为范式
析取范式,存在性保证,定理3.8,,"合取式是一个只有否定层与合取运算层的两层结构表达式，如果在其外层增加一个析取运算层，则得到所谓的析取范式；同样，析取式是一个只有否定层与析取运算层的两层结构表达式，如果在其外层增加一个合取运算层，则得到所谓的合取范式。  
【定义3.22】有限个短语的析取式称为析取范式；有限个子句的合取式称为合取范式。析取范式与合取范式统称为范式。 也就是说，一个命题公式为析取范式，当且仅当它具有形式：$A_{1}\lor A_{2}\lor\ldots\lor A_{n}$。其中，$A_{1}$，$A_{2}$，… ，$A_{n}$均为由命题变元或其否定所组成的合取式。  
例如，$(P\land\neg Q\land R)\lor(\neg P\land Q)\lor\neg R$是析取范式。  
同样地，一个命题公式称为合取范式，当且仅当该命题具形式：$B_{1}\wedge B_{2}\wedge\cdots\wedge B_{n}$。其中，$B_{1}$，$B_{2}$，⋯，$B_{n}$均为由命题变元或其否定所组成的析取式。  
例如，$(P\lor\neg Q\lor R)\land(\neg P\lor Q)\land\neg R$是合取范式。  
注意：①一个命题的析取范式或合取范式不唯一；②形如$P\land\neg Q\land R$的公式既可看成是由一个合取式构成的析取范式，也可以看成是由3 个析取式构成的合取范式，但是公式$(P\land$$\neg Q\land R)$只能将其看成是析取范式；③形如$P\lor\neg Q\lor R$的公式既是合取范式，又是析取范式，但$(P\lor\neg Q\lor R)$仅是合取范式。  
对于任意一个命题公式，下面定理保证了其析取范式和合取范式的存在性：  
【定理3.8】对于任意命题公式，都存在与其等值的析取范式和合取范式。",定理3.8保证对于任意命题公式，都存在与其等值的析取范式
合取范式,存在性保证,定理3.8,,"合取式是一个只有否定层与合取运算层的两层结构表达式，如果在其外层增加一个析取运算层，则得到所谓的析取范式；同样，析取式是一个只有否定层与析取运算层的两层结构表达式，如果在其外层增加一个合取运算层，则得到所谓的合取范式。  
【定义3.22】有限个短语的析取式称为析取范式；有限个子句的合取式称为合取范式。析取范式与合取范式统称为范式。 也就是说，一个命题公式为析取范式，当且仅当它具有形式：$A_{1}\lor A_{2}\lor\ldots\lor A_{n}$。其中，$A_{1}$，$A_{2}$，… ，$A_{n}$均为由命题变元或其否定所组成的合取式。  
例如，$(P\land\neg Q\land R)\lor(\neg P\land Q)\lor\neg R$是析取范式。  
同样地，一个命题公式称为合取范式，当且仅当该命题具形式：$B_{1}\wedge B_{2}\wedge\cdots\wedge B_{n}$。其中，$B_{1}$，$B_{2}$，⋯，$B_{n}$均为由命题变元或其否定所组成的析取式。  
例如，$(P\lor\neg Q\lor R)\land(\neg P\lor Q)\land\neg R$是合取范式。  
注意：①一个命题的析取范式或合取范式不唯一；②形如$P\land\neg Q\land R$的公式既可看成是由一个合取式构成的析取范式，也可以看成是由3 个析取式构成的合取范式，但是公式$(P\land$$\neg Q\land R)$只能将其看成是析取范式；③形如$P\lor\neg Q\lor R$的公式既是合取范式，又是析取范式，但$(P\lor\neg Q\lor R)$仅是合取范式。  
对于任意一个命题公式，下面定理保证了其析取范式和合取范式的存在性：  
【定理3.8】对于任意命题公式，都存在与其等值的析取范式和合取范式。",定理3.8保证对于任意命题公式，都存在与其等值的合取范式
范式,包含,析取范式,,"合取式是一个只有否定层与合取运算层的两层结构表达式，如果在其外层增加一个析取运算层，则得到所谓的析取范式；同样，析取式是一个只有否定层与析取运算层的两层结构表达式，如果在其外层增加一个合取运算层，则得到所谓的合取范式。  
【定义3.22】有限个短语的析取式称为析取范式；有限个子句的合取式称为合取范式。析取范式与合取范式统称为范式。 也就是说，一个命题公式为析取范式，当且仅当它具有形式：$A_{1}\lor A_{2}\lor\ldots\lor A_{n}$。其中，$A_{1}$，$A_{2}$，… ，$A_{n}$均为由命题变元或其否定所组成的合取式。  
例如，$(P\land\neg Q\land R)\lor(\neg P\land Q)\lor\neg R$是析取范式。  
同样地，一个命题公式称为合取范式，当且仅当该命题具形式：$B_{1}\wedge B_{2}\wedge\cdots\wedge B_{n}$。其中，$B_{1}$，$B_{2}$，⋯，$B_{n}$均为由命题变元或其否定所组成的析取式。  
例如，$(P\lor\neg Q\lor R)\land(\neg P\lor Q)\land\neg R$是合取范式。  
注意：①一个命题的析取范式或合取范式不唯一；②形如$P\land\neg Q\land R$的公式既可看成是由一个合取式构成的析取范式，也可以看成是由3 个析取式构成的合取范式，但是公式$(P\land$$\neg Q\land R)$只能将其看成是析取范式；③形如$P\lor\neg Q\lor R$的公式既是合取范式，又是析取范式，但$(P\lor\neg Q\lor R)$仅是合取范式。  
对于任意一个命题公式，下面定理保证了其析取范式和合取范式的存在性：  
【定理3.8】对于任意命题公式，都存在与其等值的析取范式和合取范式。",范式包含析取范式
范式,包含,合取范式,,"合取式是一个只有否定层与合取运算层的两层结构表达式，如果在其外层增加一个析取运算层，则得到所谓的析取范式；同样，析取式是一个只有否定层与析取运算层的两层结构表达式，如果在其外层增加一个合取运算层，则得到所谓的合取范式。  
【定义3.22】有限个短语的析取式称为析取范式；有限个子句的合取式称为合取范式。析取范式与合取范式统称为范式。 也就是说，一个命题公式为析取范式，当且仅当它具有形式：$A_{1}\lor A_{2}\lor\ldots\lor A_{n}$。其中，$A_{1}$，$A_{2}$，… ，$A_{n}$均为由命题变元或其否定所组成的合取式。  
例如，$(P\land\neg Q\land R)\lor(\neg P\land Q)\lor\neg R$是析取范式。  
同样地，一个命题公式称为合取范式，当且仅当该命题具形式：$B_{1}\wedge B_{2}\wedge\cdots\wedge B_{n}$。其中，$B_{1}$，$B_{2}$，⋯，$B_{n}$均为由命题变元或其否定所组成的析取式。  
例如，$(P\lor\neg Q\lor R)\land(\neg P\lor Q)\land\neg R$是合取范式。  
注意：①一个命题的析取范式或合取范式不唯一；②形如$P\land\neg Q\land R$的公式既可看成是由一个合取式构成的析取范式，也可以看成是由3 个析取式构成的合取范式，但是公式$(P\land$$\neg Q\land R)$只能将其看成是析取范式；③形如$P\lor\neg Q\lor R$的公式既是合取范式，又是析取范式，但$(P\lor\neg Q\lor R)$仅是合取范式。  
对于任意一个命题公式，下面定理保证了其析取范式和合取范式的存在性：  
【定理3.8】对于任意命题公式，都存在与其等值的析取范式和合取范式。",范式包含合取范式
命题公式的范式,包含,主范式,,"前述析取范式与合取范式虽然分别给出了命题公式的统一表达式，但这种表达形式并不唯一。例如公式$P\lor(Q\land R)$是一个析取范式，下述与其等值的公式也为其析取范式：
$$
\begin{array}{l}{P\lor(Q\land R) \Leftrightarrow (P\lor Q)\land(P\lor R)\Leftrightarrow((P\lor Q)\land P)\lor((P\lor Q)\land R)\Leftrightarrow\;\;(P\land P)\lor(P\land Q)\lor(P\land R)\lor(Q\land R)}\end{array}
$$  
范式表达形式的不唯一很容易给命题公式的研究与应用带来不便或混乱，应对其表达形式做进一步的限制使其满足唯一性，由此得到主范式的概念。主范式包括主析取范式和主合取范式两种基本类型，本小节主要讨论主析取范式，下一节介绍主合取范式。",主范式是命题公式的范式的一种，用于满足唯一性限制
主范式,包含,主析取范式,,"前述析取范式与合取范式虽然分别给出了命题公式的统一表达式，但这种表达形式并不唯一。例如公式$P\lor(Q\land R)$是一个析取范式，下述与其等值的公式也为其析取范式：
$$
\begin{array}{l}{P\lor(Q\land R) \Leftrightarrow (P\lor Q)\land(P\lor R)\Leftrightarrow((P\lor Q)\land P)\lor((P\lor Q)\land R)\Leftrightarrow\;\;(P\land P)\lor(P\land Q)\lor(P\land R)\lor(Q\land R)}\end{array}
$$  
范式表达形式的不唯一很容易给命题公式的研究与应用带来不便或混乱，应对其表达形式做进一步的限制使其满足唯一性，由此得到主范式的概念。主范式包括主析取范式和主合取范式两种基本类型，本小节主要讨论主析取范式，下一节介绍主合取范式。",主范式包括主析取范式和主合取范式两种基本类型
小项,组成,主析取范式,,"析取范式由若干合取式通过析取运算组合而成，合取式是组成析取范式的基本构件。不难看出，造成析取范式表达形式不唯一的根本原因是其基本构件的种类太多而且存在冗余。因此，必须对作为析取范式种中合取运算的表达做进一步限定，在保证析取范式基本构件完备性的前提下消除冗余的合取式，由此得到如下小项的定义：  
【定义3.23】对于任一含有$n$个命题变元的合取式$G(P_{1},P_{2},\cdots,P_{n})$，其中每个命题变元$P_{i}$与其否定$\neg P_{i}$不同时出现，但是两者之一必须出现一次且仅出现一次，而且出现次序与$P_{1},P_{2},\cdots,P_{n}$的次序保持一致，则称该$G(P_{1},P_{2},\cdots,P_{n})$为一个小项。  
显然，小项是一种在表达形式上具有特殊限制的合取式，要求合取式中的所含变量都要以一定方式出现一次且仅出现一次，对于每个变量，要么以其自身形态出现，要么以其否定形态出现。通过这种限制，就可实现对命题公式中合取运算的一种规范表达，而且很容易实现对这种规范表达形式的枚举。  
例如，含有一个命题变元$P$的小项有且仅有如下2 个，即：$P$和$\neg P$；含有两个命题变元$P$, $Q$的小项有且仅有如下4 个，即：  
$$
P\land Q\,,\,\,\,\neg P\land Q\,,\,\,\,P\land\neg Q\,,\,\,\,\neg P\land\neg Q
$$  
含有三个命题变元$\mathsf{P},\mathsf{Q},\mathsf{R}$ 的小项有且仅有如下8 个，即：  
$$
P\wedge Q\wedge R\,,\,\,\,P\wedge Q\wedge\neg R\,,\,\,\,P\wedge\neg Q\wedge R\,,\,\,\,P\wedge\neg Q\wedge\neg R\,,
$$  
$$
\neg P\land Q\land R\,,\;\;\neg P\land Q\land\neg R\,,\;\;\neg P\land\neg Q\land R\,,\;\;\neg P\land\neg Q\land\neg R
$$  
显然，含有$n$个命题变元小项有且仅有$2^{n}$个，且其中每个小项都有且仅有一个成真赋值。故可将小项唯一的成真赋值作为其编号，例如对于含两个命题变元$P$, $Q$的小项，可令：  
$$
m_{00}\Leftrightarrow\neg P\land\neg Q\,;\quad m_{01}\Leftrightarrow\neg P\land Q\,;\quad m_{10}\Leftrightarrow P\land\neg Q\,;\quad m_{11}\Leftrightarrow P\land Q
$$  
这4 个小项的真值取值情况如表3-18 所示：  
表3-18 含两个命题变元的小项
![](images/ada1d21632fe13781e4309d6e5d3eb1731aebb768a9fcff56bfcf38f1ae3303a.jpg)  
若将成真赋值对应的二进制数转化为十进制数𝑖，就可将所对应小项记作$m_{i}$。例如，对于含有两个命题变元的4 个小项，则有：  
$m_{00}\Leftrightarrow m_0; m_{01}\Leftrightarrow m_1; m_{10}\Leftrightarrow m_2; m_{11}\Leftrightarrow m_3$  
类似地，对于含三个命题变元$P$，$Q$，$R$的8 个小项，其编号如表3-19 所示。注意小项的下标： $P$、$Q\,,\ R$用1 表示；$\lnot\ P\cdot\lnot Q\cdot\lnot R.$用0 表示。  
表3-19 含三个命题变元的小项
![](images/5b90b354ff80dbf7ca55d15009478a0665bd260c70b031534983686132d847c1.jpg)  
由小项的真值取值特点易知，任意两个不同的小项的合取式为永假式，全体小项的析取式为永真式。即有：$m_{i}\wedge m_{j}=F$ $(i\neq j)$；$m_{0}\vee m_{1}\vee\cdots\vee m_{2^{n}-1}=\mathrm{T}$",小项是构成主析取范式的基本构件，通过特定限制的合取式实现对命题公式的规范表达
主析取范式,存在性,定理3.9,,"有了小项的概念，就可以给出如下主析取范式的定义：  
【定义3.24】对于任意一个给定的析取范式$|A_{1}$ ∨$A_{2}$ $\lor\ldots\;\lor A_{\mathrm{n}}$，如果其中的每个合取  式$A_{i}$$(i=1,2,\dots,n)$都是小项，则称该析取范式为主析取范式。  
在真值表中，公式真值为𝑇的指派所对应的小项的析取，即为该公式的主析取范式。这其实给出了主析取范式的真值表构造方法。例如，根据真值表3-20 可得：  
$$
P\to Q\Leftrightarrow(\neg P\land\neg Q)\lor(\neg P\land Q)\lor(P\land Q)\;\;\Leftrightarrow m_{0}\lor m_{1}\lor m_{3}
$$  
表3-20 主析取范式真值表构造法
![](images/674fb2a5e7888d6f416454b2b1e972db70580b4f43fc62f2b0ca65f4527d906c.jpg)  
与析取范式相比，主析取范式对其析取运算形式做了进一步规范，具有更加规整的表达形式。对于任一命题公式，下述定理3.9 表明了该公式主析取范式的存在性：  
【定理3.9】任何一个命题公式都有与之等价的主析取范式。",定理3.9 表明任何一个命题公式都有与之等价的主析取范式
命题公式,构造,主析取范式,,"由前面的讨论可知，对于任一给定的命题公式，其主析取范式的构造方法主要有两种，即真值表法和等值演算法。  
真值表法就是在真值表中选出公式为真的所有行，并在选出的每一行中找到该行解释所对应的小项，将所有这些小项进行析取即可得到相应的主析取范式。",命题公式的主析取范式可以通过真值表法和等值演算法两种方法构造
真值表法,得到,主析取范式,,"由前面的讨论可知，对于任一给定的命题公式，其主析取范式的构造方法主要有两种，即真值表法和等值演算法。  
真值表法就是在真值表中选出公式为真的所有行，并在选出的每一行中找到该行解释所对应的小项，将所有这些小项进行析取即可得到相应的主析取范式。",真值表法通过选出公式为真的所有行并找到对应的小项进行析取，得到主析取范式
等值演算法,构造,主析取范式,,"由前面的讨论可知，对于任一给定的命题公式，其主析取范式的构造方法主要有两种，即真值表法和等值演算法。  
真值表法就是在真值表中选出公式为真的所有行，并在选出的每一行中找到该行解释所对应的小项，将所有这些小项进行析取即可得到相应的主析取范式。",等值演算法是构造命题公式主析取范式的另一种方法
命题公式的范式,包含,主合取范式,,合取范式由若干析取式通过合取运算组合而成，析取式是组成析取范式的基本构件。同样，造成和取范式表达形式不唯一的根本原因是其基本构件的种类太多而且存在冗余。类似于前面做法，可以对析取式的表达做进一步限定或规范，在保证合取范式基本构件完备性的前提下消除冗余析取式，由此构建具有表达形式唯一性的主合取范式。,主合取范式是命题公式的范式的一种，通过限定和规范析取式的表达，消除冗余，确保表达形式唯一性
大项,特殊类型,析取式,,"【定义3.25】对于任意一个含有$\cdot_{n}$个命题变元的析取式$G(P_{1},P_{2},\cdots P_{n})$，若 $G(P_{1},P_{2},\cdots P_{n})$中每个命题变元$P_{i}$与其否定$\neg P_{i}$不同时出现，但是两者之一必须出现一次且仅出现一次，而且出现次序与 $P_{1},P_{2},\cdots P_{n}$ 的次序保持一致，则称该 $G(P_{1},P_{2},\cdots P_{n})$ 为一个大项。  
显然，大项是一种在表达形式上具有特殊限制的析取式，要求析取式中的所含变量都要以一定方式出现一次且仅出现一次，对于每个变量，要么以其自身形态出现，要么以其否定形态出现。通过这种限制，就可以实现对命题公式中合取运算的一种规范表达，而且很容易实现对这种规范表达形式的枚举。  
例如，（1）含有一个命题变元$P$的大项有且仅有如下2 个，即：$P$和$\neg P$（2）含有两个命题变元$P$, $Q$的大项有且仅有如下4 个，即：  
$$
P\lor Q\,,\;\,\neg P\lor Q\,,\;\,P\lor\neg Q\,,\;\,\neg P\lor\neg Q
$$  
（3）含有三个命题变元$P,~Q,~H$$R$的大项有且仅有如下8 个，即：  
$$
P\lor Q\lor R\,,\;\;P\lor Q\lor\neg R\,,\;\;P\lor\neg Q\lor R\,,\;\;P\lor\neg Q\lor\neg R\,,
$$  
$$
\neg P\lor Q\lor R\,,\;\;\neg P\lor Q\lor\neg R\,,\;\;\neg P\lor\neg Q\lor R\,,\;\;\neg P\lor Q\lor R\,,
$$  
易证：含有$\cdot_{n}$个命题变元大项有且仅有$2^{n}$个。其中每个大项都有且仅有一个成假赋值。若成假赋值所对应的二进制数转化为十进制数为𝑖，就将所对应大项记作$M_{i}$。  
对于含有两个命题变元$P$, $Q$的4 个以及含有三个命题变元$P$, $Q,\ R$的8 个大项，其按成假赋值方式的具体命名情况如表3-23 和表3-24 所示。注意大项下标：$P$、$Q\,,\ R$用0 表示；$\neg P、\,\,\neg Q、\,\,\neg R.$用1 表示。  
表3-23  二个命题变元的大项
![](images/b117159e2be17852c5b29f9e449d5deebdd08f3ecdbbe717331edc2f8ebcbe45.jpg)  
表3-24 三个命题变元的大项
![](images/9bbd0802cf95876287308868a0bba4b3a99b82a451062e84aca896f9d29d7f8b.jpg)  
由大项的真值取值特点易知，任意两个不同的大项的析取式为永真式，全体大项的合取式必为永假式，即有：$M_{i}\vee M_{j}\Leftrightarrow T(i\neq j)$；$M_{0}\wedge M_{1}\wedge\ldots\wedge M_{2^{n}-1}\Leftrightarrow F_{\circ}$。",大项是一种特殊的析取式，要求每个命题变元或其否定在析取式中出现一次且仅出现一次，且次序一致。
大项,包含,命题变元,,"【定义3.25】对于任意一个含有$\cdot_{n}$个命题变元的析取式$G(P_{1},P_{2},\cdots P_{n})$，若 $G(P_{1},P_{2},\cdots P_{n})$中每个命题变元$P_{i}$与其否定$\neg P_{i}$不同时出现，但是两者之一必须出现一次且仅出现一次，而且出现次序与 $P_{1},P_{2},\cdots P_{n}$ 的次序保持一致，则称该 $G(P_{1},P_{2},\cdots P_{n})$ 为一个大项。  
显然，大项是一种在表达形式上具有特殊限制的析取式，要求析取式中的所含变量都要以一定方式出现一次且仅出现一次，对于每个变量，要么以其自身形态出现，要么以其否定形态出现。通过这种限制，就可以实现对命题公式中合取运算的一种规范表达，而且很容易实现对这种规范表达形式的枚举。  
例如，（1）含有一个命题变元$P$的大项有且仅有如下2 个，即：$P$和$\neg P$（2）含有两个命题变元$P$, $Q$的大项有且仅有如下4 个，即：  
$$
P\lor Q\,,\;\,\neg P\lor Q\,,\;\,P\lor\neg Q\,,\;\,\neg P\lor\neg Q
$$  
（3）含有三个命题变元$P,~Q,~H$$R$的大项有且仅有如下8 个，即：  
$$
P\lor Q\lor R\,,\;\;P\lor Q\lor\neg R\,,\;\;P\lor\neg Q\lor R\,,\;\;P\lor\neg Q\lor\neg R\,,
$$  
$$
\neg P\lor Q\lor R\,,\;\;\neg P\lor Q\lor\neg R\,,\;\;\neg P\lor\neg Q\lor R\,,\;\;\neg P\lor Q\lor R\,,
$$  
易证：含有$\cdot_{n}$个命题变元大项有且仅有$2^{n}$个。其中每个大项都有且仅有一个成假赋值。若成假赋值所对应的二进制数转化为十进制数为𝑖，就将所对应大项记作$M_{i}$。  
对于含有两个命题变元$P$, $Q$的4 个以及含有三个命题变元$P$, $Q,\ R$的8 个大项，其按成假赋值方式的具体命名情况如表3-23 和表3-24 所示。注意大项下标：$P$、$Q\,,\ R$用0 表示；$\neg P、\,\,\neg Q、\,\,\neg R.$用1 表示。  
表3-23  二个命题变元的大项
![](images/b117159e2be17852c5b29f9e449d5deebdd08f3ecdbbe717331edc2f8ebcbe45.jpg)  
表3-24 三个命题变元的大项
![](images/9bbd0802cf95876287308868a0bba4b3a99b82a451062e84aca896f9d29d7f8b.jpg)  
由大项的真值取值特点易知，任意两个不同的大项的析取式为永真式，全体大项的合取式必为永假式，即有：$M_{i}\vee M_{j}\Leftrightarrow T(i\neq j)$；$M_{0}\wedge M_{1}\wedge\ldots\wedge M_{2^{n}-1}\Leftrightarrow F_{\circ}$。",大项包含命题变元，每个命题变元或其否定在大项中出现一次且仅出现一次。
大项,对应,成假赋值,,"【定义3.25】对于任意一个含有$\cdot_{n}$个命题变元的析取式$G(P_{1},P_{2},\cdots P_{n})$，若 $G(P_{1},P_{2},\cdots P_{n})$中每个命题变元$P_{i}$与其否定$\neg P_{i}$不同时出现，但是两者之一必须出现一次且仅出现一次，而且出现次序与 $P_{1},P_{2},\cdots P_{n}$ 的次序保持一致，则称该 $G(P_{1},P_{2},\cdots P_{n})$ 为一个大项。  
显然，大项是一种在表达形式上具有特殊限制的析取式，要求析取式中的所含变量都要以一定方式出现一次且仅出现一次，对于每个变量，要么以其自身形态出现，要么以其否定形态出现。通过这种限制，就可以实现对命题公式中合取运算的一种规范表达，而且很容易实现对这种规范表达形式的枚举。  
例如，（1）含有一个命题变元$P$的大项有且仅有如下2 个，即：$P$和$\neg P$（2）含有两个命题变元$P$, $Q$的大项有且仅有如下4 个，即：  
$$
P\lor Q\,,\;\,\neg P\lor Q\,,\;\,P\lor\neg Q\,,\;\,\neg P\lor\neg Q
$$  
（3）含有三个命题变元$P,~Q,~H$$R$的大项有且仅有如下8 个，即：  
$$
P\lor Q\lor R\,,\;\;P\lor Q\lor\neg R\,,\;\;P\lor\neg Q\lor R\,,\;\;P\lor\neg Q\lor\neg R\,,
$$  
$$
\neg P\lor Q\lor R\,,\;\;\neg P\lor Q\lor\neg R\,,\;\;\neg P\lor\neg Q\lor R\,,\;\;\neg P\lor Q\lor R\,,
$$  
易证：含有$\cdot_{n}$个命题变元大项有且仅有$2^{n}$个。其中每个大项都有且仅有一个成假赋值。若成假赋值所对应的二进制数转化为十进制数为𝑖，就将所对应大项记作$M_{i}$。  
对于含有两个命题变元$P$, $Q$的4 个以及含有三个命题变元$P$, $Q,\ R$的8 个大项，其按成假赋值方式的具体命名情况如表3-23 和表3-24 所示。注意大项下标：$P$、$Q\,,\ R$用0 表示；$\neg P、\,\,\neg Q、\,\,\neg R.$用1 表示。  
表3-23  二个命题变元的大项
![](images/b117159e2be17852c5b29f9e449d5deebdd08f3ecdbbe717331edc2f8ebcbe45.jpg)  
表3-24 三个命题变元的大项
![](images/9bbd0802cf95876287308868a0bba4b3a99b82a451062e84aca896f9d29d7f8b.jpg)  
由大项的真值取值特点易知，任意两个不同的大项的析取式为永真式，全体大项的合取式必为永假式，即有：$M_{i}\vee M_{j}\Leftrightarrow T(i\neq j)$；$M_{0}\wedge M_{1}\wedge\ldots\wedge M_{2^{n}-1}\Leftrightarrow F_{\circ}$。",每个大项有且仅有一个成假赋值，成假赋值对应的二进制数转化为十进制数用于命名大项。
大项,构成,永真式,,"【定义3.25】对于任意一个含有$\cdot_{n}$个命题变元的析取式$G(P_{1},P_{2},\cdots P_{n})$，若 $G(P_{1},P_{2},\cdots P_{n})$中每个命题变元$P_{i}$与其否定$\neg P_{i}$不同时出现，但是两者之一必须出现一次且仅出现一次，而且出现次序与 $P_{1},P_{2},\cdots P_{n}$ 的次序保持一致，则称该 $G(P_{1},P_{2},\cdots P_{n})$ 为一个大项。  
显然，大项是一种在表达形式上具有特殊限制的析取式，要求析取式中的所含变量都要以一定方式出现一次且仅出现一次，对于每个变量，要么以其自身形态出现，要么以其否定形态出现。通过这种限制，就可以实现对命题公式中合取运算的一种规范表达，而且很容易实现对这种规范表达形式的枚举。  
例如，（1）含有一个命题变元$P$的大项有且仅有如下2 个，即：$P$和$\neg P$（2）含有两个命题变元$P$, $Q$的大项有且仅有如下4 个，即：  
$$
P\lor Q\,,\;\,\neg P\lor Q\,,\;\,P\lor\neg Q\,,\;\,\neg P\lor\neg Q
$$  
（3）含有三个命题变元$P,~Q,~H$$R$的大项有且仅有如下8 个，即：  
$$
P\lor Q\lor R\,,\;\;P\lor Q\lor\neg R\,,\;\;P\lor\neg Q\lor R\,,\;\;P\lor\neg Q\lor\neg R\,,
$$  
$$
\neg P\lor Q\lor R\,,\;\;\neg P\lor Q\lor\neg R\,,\;\;\neg P\lor\neg Q\lor R\,,\;\;\neg P\lor Q\lor R\,,
$$  
易证：含有$\cdot_{n}$个命题变元大项有且仅有$2^{n}$个。其中每个大项都有且仅有一个成假赋值。若成假赋值所对应的二进制数转化为十进制数为𝑖，就将所对应大项记作$M_{i}$。  
对于含有两个命题变元$P$, $Q$的4 个以及含有三个命题变元$P$, $Q,\ R$的8 个大项，其按成假赋值方式的具体命名情况如表3-23 和表3-24 所示。注意大项下标：$P$、$Q\,,\ R$用0 表示；$\neg P、\,\,\neg Q、\,\,\neg R.$用1 表示。  
表3-23  二个命题变元的大项
![](images/b117159e2be17852c5b29f9e449d5deebdd08f3ecdbbe717331edc2f8ebcbe45.jpg)  
表3-24 三个命题变元的大项
![](images/9bbd0802cf95876287308868a0bba4b3a99b82a451062e84aca896f9d29d7f8b.jpg)  
由大项的真值取值特点易知，任意两个不同的大项的析取式为永真式，全体大项的合取式必为永假式，即有：$M_{i}\vee M_{j}\Leftrightarrow T(i\neq j)$；$M_{0}\wedge M_{1}\wedge\ldots\wedge M_{2^{n}-1}\Leftrightarrow F_{\circ}$。",任意两个不同大项的析取式为永真式。
大项,构成,永假式,,"【定义3.25】对于任意一个含有$\cdot_{n}$个命题变元的析取式$G(P_{1},P_{2},\cdots P_{n})$，若 $G(P_{1},P_{2},\cdots P_{n})$中每个命题变元$P_{i}$与其否定$\neg P_{i}$不同时出现，但是两者之一必须出现一次且仅出现一次，而且出现次序与 $P_{1},P_{2},\cdots P_{n}$ 的次序保持一致，则称该 $G(P_{1},P_{2},\cdots P_{n})$ 为一个大项。  
显然，大项是一种在表达形式上具有特殊限制的析取式，要求析取式中的所含变量都要以一定方式出现一次且仅出现一次，对于每个变量，要么以其自身形态出现，要么以其否定形态出现。通过这种限制，就可以实现对命题公式中合取运算的一种规范表达，而且很容易实现对这种规范表达形式的枚举。  
例如，（1）含有一个命题变元$P$的大项有且仅有如下2 个，即：$P$和$\neg P$（2）含有两个命题变元$P$, $Q$的大项有且仅有如下4 个，即：  
$$
P\lor Q\,,\;\,\neg P\lor Q\,,\;\,P\lor\neg Q\,,\;\,\neg P\lor\neg Q
$$  
（3）含有三个命题变元$P,~Q,~H$$R$的大项有且仅有如下8 个，即：  
$$
P\lor Q\lor R\,,\;\;P\lor Q\lor\neg R\,,\;\;P\lor\neg Q\lor R\,,\;\;P\lor\neg Q\lor\neg R\,,
$$  
$$
\neg P\lor Q\lor R\,,\;\;\neg P\lor Q\lor\neg R\,,\;\;\neg P\lor\neg Q\lor R\,,\;\;\neg P\lor Q\lor R\,,
$$  
易证：含有$\cdot_{n}$个命题变元大项有且仅有$2^{n}$个。其中每个大项都有且仅有一个成假赋值。若成假赋值所对应的二进制数转化为十进制数为𝑖，就将所对应大项记作$M_{i}$。  
对于含有两个命题变元$P$, $Q$的4 个以及含有三个命题变元$P$, $Q,\ R$的8 个大项，其按成假赋值方式的具体命名情况如表3-23 和表3-24 所示。注意大项下标：$P$、$Q\,,\ R$用0 表示；$\neg P、\,\,\neg Q、\,\,\neg R.$用1 表示。  
表3-23  二个命题变元的大项
![](images/b117159e2be17852c5b29f9e449d5deebdd08f3ecdbbe717331edc2f8ebcbe45.jpg)  
表3-24 三个命题变元的大项
![](images/9bbd0802cf95876287308868a0bba4b3a99b82a451062e84aca896f9d29d7f8b.jpg)  
由大项的真值取值特点易知，任意两个不同的大项的析取式为永真式，全体大项的合取式必为永假式，即有：$M_{i}\vee M_{j}\Leftrightarrow T(i\neq j)$；$M_{0}\wedge M_{1}\wedge\ldots\wedge M_{2^{n}-1}\Leftrightarrow F_{\circ}$。",全体大项的合取式必为永假式。
主合取范式,包含,合取范式,,"有了大项的概念，就可给出如下主合取范式的定义：  
【定义3.26】对于任意一个给定的合取范式$|A_{1}$ $\wedge A_{2}$ ∧… ∧$A_{\mathrm{n}}$，如果其中的每个析取  式$A_{i}(i=1,\!2,\dots,n)$都是大项，则称该合取范式为主合取范式。  
$例如，\begin{array}{r}{\phantom{\,\big(}\neg(P\to Q\big)\;\vee\,R\;\Leftrightarrow\;(P\lor Q\lor R)\;\wedge\;(P\lor\neg Q\lor R)\;\wedge\;(\neg P\lor\neg Q\lor R)\;\;\Leftrightarrow\;M_{0}\land M_{2}\land M_{6}}\end{array}$  
对于真值表中某个给定的命题公式，该公式真值为${\bf\nabla}F$的指派所对应大项的合取，即为此公式的主合取范式。由此可以得到主合取范式的一种构造方法，即真值表构造法。例如，根据真值表3-25 可以得到公式$G\iff P\leftrightarrow Q$的主合取范式：  
$$
G\iff P\leftrightarrow Q=(P\lor\lnot Q)\land(\lnot P\lor Q)=M_{1}\land M_{2}
$$  
表3-25 主合取范式真值表构造法
![](images/beb2748bf389a4f024a2a1903188d5f3d22819eca48ed0715a5415c2f3490873.jpg)  
与合取范式相比，主合取范式对其合取运算形式做了进一步规范，具有更加规整的表达形式。对于任一命题公式，下述定理3.10 表明了该公式主合取范式的存在性。  
【定理3.10】任何一个命题公式都有与之等价的主合取范式。",主合取范式是合取范式的一种特殊形式，其中每个析取式都是大项。
主合取范式,组成,大项,,"有了大项的概念，就可给出如下主合取范式的定义：  
【定义3.26】对于任意一个给定的合取范式$|A_{1}$ $\wedge A_{2}$ ∧… ∧$A_{\mathrm{n}}$，如果其中的每个析取  式$A_{i}(i=1,\!2,\dots,n)$都是大项，则称该合取范式为主合取范式。  
$例如，\begin{array}{r}{\phantom{\,\big(}\neg(P\to Q\big)\;\vee\,R\;\Leftrightarrow\;(P\lor Q\lor R)\;\wedge\;(P\lor\neg Q\lor R)\;\wedge\;(\neg P\lor\neg Q\lor R)\;\;\Leftrightarrow\;M_{0}\land M_{2}\land M_{6}}\end{array}$  
对于真值表中某个给定的命题公式，该公式真值为${\bf\nabla}F$的指派所对应大项的合取，即为此公式的主合取范式。由此可以得到主合取范式的一种构造方法，即真值表构造法。例如，根据真值表3-25 可以得到公式$G\iff P\leftrightarrow Q$的主合取范式：  
$$
G\iff P\leftrightarrow Q=(P\lor\lnot Q)\land(\lnot P\lor Q)=M_{1}\land M_{2}
$$  
表3-25 主合取范式真值表构造法
![](images/beb2748bf389a4f024a2a1903188d5f3d22819eca48ed0715a5415c2f3490873.jpg)  
与合取范式相比，主合取范式对其合取运算形式做了进一步规范，具有更加规整的表达形式。对于任一命题公式，下述定理3.10 表明了该公式主合取范式的存在性。  
【定理3.10】任何一个命题公式都有与之等价的主合取范式。",主合取范式由大项的合取构成。
主合取范式,方法,真值表构造法,,"有了大项的概念，就可给出如下主合取范式的定义：  
【定义3.26】对于任意一个给定的合取范式$|A_{1}$ $\wedge A_{2}$ ∧… ∧$A_{\mathrm{n}}$，如果其中的每个析取  式$A_{i}(i=1,\!2,\dots,n)$都是大项，则称该合取范式为主合取范式。  
$例如，\begin{array}{r}{\phantom{\,\big(}\neg(P\to Q\big)\;\vee\,R\;\Leftrightarrow\;(P\lor Q\lor R)\;\wedge\;(P\lor\neg Q\lor R)\;\wedge\;(\neg P\lor\neg Q\lor R)\;\;\Leftrightarrow\;M_{0}\land M_{2}\land M_{6}}\end{array}$  
对于真值表中某个给定的命题公式，该公式真值为${\bf\nabla}F$的指派所对应大项的合取，即为此公式的主合取范式。由此可以得到主合取范式的一种构造方法，即真值表构造法。例如，根据真值表3-25 可以得到公式$G\iff P\leftrightarrow Q$的主合取范式：  
$$
G\iff P\leftrightarrow Q=(P\lor\lnot Q)\land(\lnot P\lor Q)=M_{1}\land M_{2}
$$  
表3-25 主合取范式真值表构造法
![](images/beb2748bf389a4f024a2a1903188d5f3d22819eca48ed0715a5415c2f3490873.jpg)  
与合取范式相比，主合取范式对其合取运算形式做了进一步规范，具有更加规整的表达形式。对于任一命题公式，下述定理3.10 表明了该公式主合取范式的存在性。  
【定理3.10】任何一个命题公式都有与之等价的主合取范式。",真值表构造法是获取主合取范式的一种方法。
主合取范式,等价,命题公式,,"有了大项的概念，就可给出如下主合取范式的定义：  
【定义3.26】对于任意一个给定的合取范式$|A_{1}$ $\wedge A_{2}$ ∧… ∧$A_{\mathrm{n}}$，如果其中的每个析取  式$A_{i}(i=1,\!2,\dots,n)$都是大项，则称该合取范式为主合取范式。  
$例如，\begin{array}{r}{\phantom{\,\big(}\neg(P\to Q\big)\;\vee\,R\;\Leftrightarrow\;(P\lor Q\lor R)\;\wedge\;(P\lor\neg Q\lor R)\;\wedge\;(\neg P\lor\neg Q\lor R)\;\;\Leftrightarrow\;M_{0}\land M_{2}\land M_{6}}\end{array}$  
对于真值表中某个给定的命题公式，该公式真值为${\bf\nabla}F$的指派所对应大项的合取，即为此公式的主合取范式。由此可以得到主合取范式的一种构造方法，即真值表构造法。例如，根据真值表3-25 可以得到公式$G\iff P\leftrightarrow Q$的主合取范式：  
$$
G\iff P\leftrightarrow Q=(P\lor\lnot Q)\land(\lnot P\lor Q)=M_{1}\land M_{2}
$$  
表3-25 主合取范式真值表构造法
![](images/beb2748bf389a4f024a2a1903188d5f3d22819eca48ed0715a5415c2f3490873.jpg)  
与合取范式相比，主合取范式对其合取运算形式做了进一步规范，具有更加规整的表达形式。对于任一命题公式，下述定理3.10 表明了该公式主合取范式的存在性。  
【定理3.10】任何一个命题公式都有与之等价的主合取范式。",任何一个命题公式都有与之等价的主合取范式。
命题公式的范式,构造方法,主合取范式,,"与主析取范式类似，对于任一给定的命题公式，其主合取范式的构造方法主要有两种，即真值表法和等值演算法。  
真值表法就是在真值表中选出公式真值为假的所有行，并在选出的每一行中找到该行解释所对应的大项，将所有这些大项进行合取即可得到相应的主合取范式。",主合取范式是命题公式范式的一种构造方法，可以通过真值表法或等值演算法得到
主析取范式,统称,主合取范式,,"如前所述，主析取范式和主合取范式统称为主范式。在主范式的具体构造过程中，有时求主析取范式更加方便，有时求主合取范式更为方便。此时，可以利用其中的一个主范式求出另外一个主范式。为此，我们进一步考察这两种主范式之间的内在联系。  
根据小项与大项的定义，易知二者之间存在着如下关系：  
$$
m_{i}\Leftrightarrow\neg M_{i};\quad M_{i}\Leftrightarrow\neg m_{i}\;\;(i=0,1,2,3,\dotsc,2^{n}-1)
$$  
例如，对含有两个命题变元$P,~Q$的小项与大项：  
$$
m_{0}\Leftrightarrow\neg P\land\neg Q\,,\;\;M_{0}\Leftrightarrow P\lor Q;\qquad m_{1}\Leftrightarrow\neg P\land Q\,,\;\;M_{1}=P\lor\neg Q
$$  
$$
m_{2}\Leftrightarrow P\land\lnot Q\,,\;\;M_{2}\Leftrightarrow\lnot P\lor Q;\quad m_{3}\Leftrightarrow P\land Q\,,\;\;M_{3}=\lnot P\lor\lnot Q\,
$$  
显然有：$m_{i}\Leftrightarrow\lnot M_{i};\ \ \ \ \ M_{i}\Leftrightarrow\lnot m_{i}$。因此小项与大项之间存在着一种互补关系。  
由于小项与大项之间存在互补关系，而主析取范式和主合取范式又分别由小项或大项构成，因此主析取范式和主合取范式之间存在一种互补关系。下面介绍一种利用主析取范式求主合取范式以及利用主合取范式求主析取范式的方法。  
已知公式$G$的主析取范式，求出公式$G$的主合取范式的步骤如下：  
第一步：求出$\neg G$的主析取范式，即公式$G$的主析取范式中没有出现过的小项的析取；  
第二步：$G\Leftrightarrow\neg\;\left(\neg G\right)$，即公式$G$的主合取范式。 已知公式$G$的主合取范式，求出公式$G$的主析取范式的步骤如下：  
第一步：求出$\neg G$的主合取范式，即公式$G$的主合取范式中没有出现过的大项的合取；  
第二步：$G\Leftrightarrow\neg\;\left(\neg G\right)$，即公式$G$的主析取范式。  
不难看出，主范式有如下性质：  
（1）命题公式是永真公式当且仅当它的主析取范式包含所有的小项，此时无主合取范式或者说主合取范式为空；  
（2）命题公式是永假公式当且仅当它的主合取范式包含所有的大项，此时无主析取范式或者说主析取范式为空；  
（3）两个命题公式是相等的当且仅当它们所对应的主析取范式相等，或者它们的所对应的主合取范式相等。  
利用主范式的性质，可以使用主范式判断两个命题公式是否等值。  
使用主范式的性质，还可以判断命题公式的类型：设𝐴是含有$n$个命题变项的命题公式，若$𝐴$为重言式，当且仅当𝐴的主析取范式中含全部$2^{n}$个小项；若𝐴为矛盾式，当且仅当𝐴的主析取范式中不含任何小项，此时记𝐴的主析取范式为0；若𝐴为可满足式，当且仅当𝐴的主析取范式中至少含一个小项。",主析取范式和主合取范式统称为主范式
主析取范式,互补关系,主合取范式,,"如前所述，主析取范式和主合取范式统称为主范式。在主范式的具体构造过程中，有时求主析取范式更加方便，有时求主合取范式更为方便。此时，可以利用其中的一个主范式求出另外一个主范式。为此，我们进一步考察这两种主范式之间的内在联系。  
根据小项与大项的定义，易知二者之间存在着如下关系：  
$$
m_{i}\Leftrightarrow\neg M_{i};\quad M_{i}\Leftrightarrow\neg m_{i}\;\;(i=0,1,2,3,\dotsc,2^{n}-1)
$$  
例如，对含有两个命题变元$P,~Q$的小项与大项：  
$$
m_{0}\Leftrightarrow\neg P\land\neg Q\,,\;\;M_{0}\Leftrightarrow P\lor Q;\qquad m_{1}\Leftrightarrow\neg P\land Q\,,\;\;M_{1}=P\lor\neg Q
$$  
$$
m_{2}\Leftrightarrow P\land\lnot Q\,,\;\;M_{2}\Leftrightarrow\lnot P\lor Q;\quad m_{3}\Leftrightarrow P\land Q\,,\;\;M_{3}=\lnot P\lor\lnot Q\,
$$  
显然有：$m_{i}\Leftrightarrow\lnot M_{i};\ \ \ \ \ M_{i}\Leftrightarrow\lnot m_{i}$。因此小项与大项之间存在着一种互补关系。  
由于小项与大项之间存在互补关系，而主析取范式和主合取范式又分别由小项或大项构成，因此主析取范式和主合取范式之间存在一种互补关系。下面介绍一种利用主析取范式求主合取范式以及利用主合取范式求主析取范式的方法。  
已知公式$G$的主析取范式，求出公式$G$的主合取范式的步骤如下：  
第一步：求出$\neg G$的主析取范式，即公式$G$的主析取范式中没有出现过的小项的析取；  
第二步：$G\Leftrightarrow\neg\;\left(\neg G\right)$，即公式$G$的主合取范式。 已知公式$G$的主合取范式，求出公式$G$的主析取范式的步骤如下：  
第一步：求出$\neg G$的主合取范式，即公式$G$的主合取范式中没有出现过的大项的合取；  
第二步：$G\Leftrightarrow\neg\;\left(\neg G\right)$，即公式$G$的主析取范式。  
不难看出，主范式有如下性质：  
（1）命题公式是永真公式当且仅当它的主析取范式包含所有的小项，此时无主合取范式或者说主合取范式为空；  
（2）命题公式是永假公式当且仅当它的主合取范式包含所有的大项，此时无主析取范式或者说主析取范式为空；  
（3）两个命题公式是相等的当且仅当它们所对应的主析取范式相等，或者它们的所对应的主合取范式相等。  
利用主范式的性质，可以使用主范式判断两个命题公式是否等值。  
使用主范式的性质，还可以判断命题公式的类型：设𝐴是含有$n$个命题变项的命题公式，若$𝐴$为重言式，当且仅当𝐴的主析取范式中含全部$2^{n}$个小项；若𝐴为矛盾式，当且仅当𝐴的主析取范式中不含任何小项，此时记𝐴的主析取范式为0；若𝐴为可满足式，当且仅当𝐴的主析取范式中至少含一个小项。",由于小项与大项之间存在互补关系，而主析取范式和主合取范式又分别由小项或大项构成，因此主析取范式和主合取范式之间存在一种互补关系
小项与大项的关系,构成,主析取范式,,"如前所述，主析取范式和主合取范式统称为主范式。在主范式的具体构造过程中，有时求主析取范式更加方便，有时求主合取范式更为方便。此时，可以利用其中的一个主范式求出另外一个主范式。为此，我们进一步考察这两种主范式之间的内在联系。  
根据小项与大项的定义，易知二者之间存在着如下关系：  
$$
m_{i}\Leftrightarrow\neg M_{i};\quad M_{i}\Leftrightarrow\neg m_{i}\;\;(i=0,1,2,3,\dotsc,2^{n}-1)
$$  
例如，对含有两个命题变元$P,~Q$的小项与大项：  
$$
m_{0}\Leftrightarrow\neg P\land\neg Q\,,\;\;M_{0}\Leftrightarrow P\lor Q;\qquad m_{1}\Leftrightarrow\neg P\land Q\,,\;\;M_{1}=P\lor\neg Q
$$  
$$
m_{2}\Leftrightarrow P\land\lnot Q\,,\;\;M_{2}\Leftrightarrow\lnot P\lor Q;\quad m_{3}\Leftrightarrow P\land Q\,,\;\;M_{3}=\lnot P\lor\lnot Q\,
$$  
显然有：$m_{i}\Leftrightarrow\lnot M_{i};\ \ \ \ \ M_{i}\Leftrightarrow\lnot m_{i}$。因此小项与大项之间存在着一种互补关系。  
由于小项与大项之间存在互补关系，而主析取范式和主合取范式又分别由小项或大项构成，因此主析取范式和主合取范式之间存在一种互补关系。下面介绍一种利用主析取范式求主合取范式以及利用主合取范式求主析取范式的方法。  
已知公式$G$的主析取范式，求出公式$G$的主合取范式的步骤如下：  
第一步：求出$\neg G$的主析取范式，即公式$G$的主析取范式中没有出现过的小项的析取；  
第二步：$G\Leftrightarrow\neg\;\left(\neg G\right)$，即公式$G$的主合取范式。 已知公式$G$的主合取范式，求出公式$G$的主析取范式的步骤如下：  
第一步：求出$\neg G$的主合取范式，即公式$G$的主合取范式中没有出现过的大项的合取；  
第二步：$G\Leftrightarrow\neg\;\left(\neg G\right)$，即公式$G$的主析取范式。  
不难看出，主范式有如下性质：  
（1）命题公式是永真公式当且仅当它的主析取范式包含所有的小项，此时无主合取范式或者说主合取范式为空；  
（2）命题公式是永假公式当且仅当它的主合取范式包含所有的大项，此时无主析取范式或者说主析取范式为空；  
（3）两个命题公式是相等的当且仅当它们所对应的主析取范式相等，或者它们的所对应的主合取范式相等。  
利用主范式的性质，可以使用主范式判断两个命题公式是否等值。  
使用主范式的性质，还可以判断命题公式的类型：设𝐴是含有$n$个命题变项的命题公式，若$𝐴$为重言式，当且仅当𝐴的主析取范式中含全部$2^{n}$个小项；若𝐴为矛盾式，当且仅当𝐴的主析取范式中不含任何小项，此时记𝐴的主析取范式为0；若𝐴为可满足式，当且仅当𝐴的主析取范式中至少含一个小项。",主析取范式由小项构成
小项与大项的关系,构成,主合取范式,,"如前所述，主析取范式和主合取范式统称为主范式。在主范式的具体构造过程中，有时求主析取范式更加方便，有时求主合取范式更为方便。此时，可以利用其中的一个主范式求出另外一个主范式。为此，我们进一步考察这两种主范式之间的内在联系。  
根据小项与大项的定义，易知二者之间存在着如下关系：  
$$
m_{i}\Leftrightarrow\neg M_{i};\quad M_{i}\Leftrightarrow\neg m_{i}\;\;(i=0,1,2,3,\dotsc,2^{n}-1)
$$  
例如，对含有两个命题变元$P,~Q$的小项与大项：  
$$
m_{0}\Leftrightarrow\neg P\land\neg Q\,,\;\;M_{0}\Leftrightarrow P\lor Q;\qquad m_{1}\Leftrightarrow\neg P\land Q\,,\;\;M_{1}=P\lor\neg Q
$$  
$$
m_{2}\Leftrightarrow P\land\lnot Q\,,\;\;M_{2}\Leftrightarrow\lnot P\lor Q;\quad m_{3}\Leftrightarrow P\land Q\,,\;\;M_{3}=\lnot P\lor\lnot Q\,
$$  
显然有：$m_{i}\Leftrightarrow\lnot M_{i};\ \ \ \ \ M_{i}\Leftrightarrow\lnot m_{i}$。因此小项与大项之间存在着一种互补关系。  
由于小项与大项之间存在互补关系，而主析取范式和主合取范式又分别由小项或大项构成，因此主析取范式和主合取范式之间存在一种互补关系。下面介绍一种利用主析取范式求主合取范式以及利用主合取范式求主析取范式的方法。  
已知公式$G$的主析取范式，求出公式$G$的主合取范式的步骤如下：  
第一步：求出$\neg G$的主析取范式，即公式$G$的主析取范式中没有出现过的小项的析取；  
第二步：$G\Leftrightarrow\neg\;\left(\neg G\right)$，即公式$G$的主合取范式。 已知公式$G$的主合取范式，求出公式$G$的主析取范式的步骤如下：  
第一步：求出$\neg G$的主合取范式，即公式$G$的主合取范式中没有出现过的大项的合取；  
第二步：$G\Leftrightarrow\neg\;\left(\neg G\right)$，即公式$G$的主析取范式。  
不难看出，主范式有如下性质：  
（1）命题公式是永真公式当且仅当它的主析取范式包含所有的小项，此时无主合取范式或者说主合取范式为空；  
（2）命题公式是永假公式当且仅当它的主合取范式包含所有的大项，此时无主析取范式或者说主析取范式为空；  
（3）两个命题公式是相等的当且仅当它们所对应的主析取范式相等，或者它们的所对应的主合取范式相等。  
利用主范式的性质，可以使用主范式判断两个命题公式是否等值。  
使用主范式的性质，还可以判断命题公式的类型：设𝐴是含有$n$个命题变项的命题公式，若$𝐴$为重言式，当且仅当𝐴的主析取范式中含全部$2^{n}$个小项；若𝐴为矛盾式，当且仅当𝐴的主析取范式中不含任何小项，此时记𝐴的主析取范式为0；若𝐴为可满足式，当且仅当𝐴的主析取范式中至少含一个小项。",主合取范式由大项构成
主范式,具有,主范式性质,,"如前所述，主析取范式和主合取范式统称为主范式。在主范式的具体构造过程中，有时求主析取范式更加方便，有时求主合取范式更为方便。此时，可以利用其中的一个主范式求出另外一个主范式。为此，我们进一步考察这两种主范式之间的内在联系。  
根据小项与大项的定义，易知二者之间存在着如下关系：  
$$
m_{i}\Leftrightarrow\neg M_{i};\quad M_{i}\Leftrightarrow\neg m_{i}\;\;(i=0,1,2,3,\dotsc,2^{n}-1)
$$  
例如，对含有两个命题变元$P,~Q$的小项与大项：  
$$
m_{0}\Leftrightarrow\neg P\land\neg Q\,,\;\;M_{0}\Leftrightarrow P\lor Q;\qquad m_{1}\Leftrightarrow\neg P\land Q\,,\;\;M_{1}=P\lor\neg Q
$$  
$$
m_{2}\Leftrightarrow P\land\lnot Q\,,\;\;M_{2}\Leftrightarrow\lnot P\lor Q;\quad m_{3}\Leftrightarrow P\land Q\,,\;\;M_{3}=\lnot P\lor\lnot Q\,
$$  
显然有：$m_{i}\Leftrightarrow\lnot M_{i};\ \ \ \ \ M_{i}\Leftrightarrow\lnot m_{i}$。因此小项与大项之间存在着一种互补关系。  
由于小项与大项之间存在互补关系，而主析取范式和主合取范式又分别由小项或大项构成，因此主析取范式和主合取范式之间存在一种互补关系。下面介绍一种利用主析取范式求主合取范式以及利用主合取范式求主析取范式的方法。  
已知公式$G$的主析取范式，求出公式$G$的主合取范式的步骤如下：  
第一步：求出$\neg G$的主析取范式，即公式$G$的主析取范式中没有出现过的小项的析取；  
第二步：$G\Leftrightarrow\neg\;\left(\neg G\right)$，即公式$G$的主合取范式。 已知公式$G$的主合取范式，求出公式$G$的主析取范式的步骤如下：  
第一步：求出$\neg G$的主合取范式，即公式$G$的主合取范式中没有出现过的大项的合取；  
第二步：$G\Leftrightarrow\neg\;\left(\neg G\right)$，即公式$G$的主析取范式。  
不难看出，主范式有如下性质：  
（1）命题公式是永真公式当且仅当它的主析取范式包含所有的小项，此时无主合取范式或者说主合取范式为空；  
（2）命题公式是永假公式当且仅当它的主合取范式包含所有的大项，此时无主析取范式或者说主析取范式为空；  
（3）两个命题公式是相等的当且仅当它们所对应的主析取范式相等，或者它们的所对应的主合取范式相等。  
利用主范式的性质，可以使用主范式判断两个命题公式是否等值。  
使用主范式的性质，还可以判断命题公式的类型：设𝐴是含有$n$个命题变项的命题公式，若$𝐴$为重言式，当且仅当𝐴的主析取范式中含全部$2^{n}$个小项；若𝐴为矛盾式，当且仅当𝐴的主析取范式中不含任何小项，此时记𝐴的主析取范式为0；若𝐴为可满足式，当且仅当𝐴的主析取范式中至少含一个小项。",主范式具有特定的性质，如判断命题公式的类型和等值性
命题逻辑的演绎推理,研究对象,数理逻辑,,作为研究人类思维基本形式、基本规则和基本规律的逻辑科学，主要包括概念、判断、推理这三个层次内容，由概念形成判断，再由判断形成推理。人们总是将推理作为学习和研究逻辑学的主要任务和主要目的。因此，通常直接将逻辑学定义为研究推理的学科。所谓推理，其实就是由已知命题得到新命题的思维过程。已知的命题称为推理的条件或前提，推得的新命题称为推理的结论。推理一般分为演绎推理和归纳推理这两种基本类型。对于任意一个推理，如果其前提与结论之间具有必然的联系，则称该推理为演绎推理，否则称之为归纳推理。数理逻辑的研究对象为主要是演绎推理，除非特别说明，我们所说的推理均为演绎推理。数理逻辑主要是用数学的方法来研究推理，也就是说通过引入一套数学符号的方法来研究推理。因此，数理逻辑主要研究推理的形式结构，或者说研究采用什么样的形式结构进行推理是有效的，研究采用什么样的形式结构进行推理是无效的。本节主要学习命题逻辑推理的基本知识，包括命题推理的基本概念、命题公式永真蕴含关系与判定、命题推演系统的构成以及命题推证的基本策略。,数理逻辑的主要研究对象是命题逻辑的演绎推理，通过数学方法研究推理的形式结构及其有效性。
演绎推理,揭示,永真蕴含关系,,从数理逻辑的角度看，演绎推理就是从作为前提的命题公式中推出新的命题公式作为推理结论，而且前提与结论之间具有必然联系。这种必然联系就是如果前提为真，那么结论必然为真。因此，演绎推理的本质就是揭示前提与结论之间的这种永真蕴含关系。作为命题逻辑演绎推理的基础，本小节给出命题公式永真蕴含关系及其判定的基本知识。,演绎推理的本质是揭示前提与结论之间的永真蕴含关系
永真蕴含关系,基础,判定,,从数理逻辑的角度看，演绎推理就是从作为前提的命题公式中推出新的命题公式作为推理结论，而且前提与结论之间具有必然联系。这种必然联系就是如果前提为真，那么结论必然为真。因此，演绎推理的本质就是揭示前提与结论之间的这种永真蕴含关系。作为命题逻辑演绎推理的基础，本小节给出命题公式永真蕴含关系及其判定的基本知识。,永真蕴含关系是命题逻辑演绎推理的基础，涉及其判定知识
永真蕴含,满足,永真蕴含关系的基本性质,,"如同命题公式的等值关系相当于多项式的恒等式关系，命题公式的永真蕴含关系相当于多项式的不等式关系，表达的是命题公式真值的小于或等于关系。  
【定义3.27】设$G(P_{1},P_{2},\cdots,P_{n})$和$H(P_{1},P_{2},\cdots,P_{n})$是任意两个具有相同命题变量的命题公式，如果对于$P_{1},P_{2},\cdots P_{n}$的任意一组真值指派，$G(P_{1},P_{2},\cdots P_{n})$的真值总是不大于$H(P_{1},P_{2},\cdots P_{n})$的真值，即$v(G(P_{1},P_{2},\cdots P_{n}))\leq v(H(P_{1},P_{2},\cdots P_{n}))$，则称$G(P_{1},P_{2},\cdots P_{n})$永真蕴含$H(P_{1},P_{2},\cdots P_{n})$，记作$G(P_{1},P_{2},\cdots P_{n})\ \Rightarrow H(P_{1},P_{2},\cdots P_{n})$，且称$G(P_{1},P_{2},\cdots P_{n})$为永真蕴含的前件，$H(P_{1},P_{2},\cdots P_{n})$为永真蕴含的后件。  
从逻辑含义上看，命题公式$G(P_{1},P_{2},\cdots P_{n})$的真值总不大于$H(P_{1},P_{2},\cdots P_{n})$的真值就意味着：若 $G(P_{1},P_{2},\cdots P_{n})$ 真，则 $H(P_{1},P_{2},\cdots P_{n})$ 必为真，或者说由 $G(P_{1},P_{2},\cdots P_{n})$ 为真可符合逻辑 地推出$H(P_{1},P_{2},\cdots P_{n})$也为真。这正是命题公式之间永真蕴含关系“$\Rightarrow$”的本质含义。  
下面的定理表明命题公式的永真蕴含关系$\scriptstyle""\Rightarrow\ ""$与逻辑运算的蕴含联结词“${\rightarrow}$”之间有着非常紧密的联系。  
【定理3.11】设$G(P_{1},P_{2},\cdots P_{n})$和$H(P_{1},P_{2},\cdots P_{n})$是任意两个具有相同命题变量的命题公式，$G(P_{1},P_{2},\cdots P_{n})$永真蕴含$H(P_{1},P_{2},\cdots P_{n})$，有：$G(P_{1},P_{2},\cdots P_{n})\Rightarrow H(P_{1},P_{2},\cdots P_{n})$ 当且仅当命题公式$G(P_{1},P_{2},\cdots P_{n})\rightarrow H(P_{1},P_{2},\cdots P_{n})$为永真公式。  
下面定理表明了永真蕴含关系的基本性质：  
【定理3.12】命题公式的永真蕴含关系满足如下三条基本性质：  
（1）自反性：对任意命题公式𝐴，有$A\Rightarrow A$；  
（2）反对称性：对任意命题公式$\cdot A$，$B$，如果$A\Rightarrow B$，并且$B\Rightarrow A$，那么$A\Leftrightarrow B$  
（3）传递性：对任意命题公式𝐴，$B$，$C$，如果$A\Rightarrow B$，$B\Rightarrow C$，那么$A\Rightarrow C$。  
【定理3.13】设𝐴、$B$为任意两个命题公式，$A\Leftrightarrow B$的充分必要条件是$A\Rightarrow B$，且$B\Rightarrow A$",永真蕴含关系满足自反性、反对称性和传递性三条基本性质
永真蕴含,紧密联系,永真蕴含与逻辑运算的蕴含联结词的关系,,"如同命题公式的等值关系相当于多项式的恒等式关系，命题公式的永真蕴含关系相当于多项式的不等式关系，表达的是命题公式真值的小于或等于关系。  
【定义3.27】设$G(P_{1},P_{2},\cdots,P_{n})$和$H(P_{1},P_{2},\cdots,P_{n})$是任意两个具有相同命题变量的命题公式，如果对于$P_{1},P_{2},\cdots P_{n}$的任意一组真值指派，$G(P_{1},P_{2},\cdots P_{n})$的真值总是不大于$H(P_{1},P_{2},\cdots P_{n})$的真值，即$v(G(P_{1},P_{2},\cdots P_{n}))\leq v(H(P_{1},P_{2},\cdots P_{n}))$，则称$G(P_{1},P_{2},\cdots P_{n})$永真蕴含$H(P_{1},P_{2},\cdots P_{n})$，记作$G(P_{1},P_{2},\cdots P_{n})\ \Rightarrow H(P_{1},P_{2},\cdots P_{n})$，且称$G(P_{1},P_{2},\cdots P_{n})$为永真蕴含的前件，$H(P_{1},P_{2},\cdots P_{n})$为永真蕴含的后件。  
从逻辑含义上看，命题公式$G(P_{1},P_{2},\cdots P_{n})$的真值总不大于$H(P_{1},P_{2},\cdots P_{n})$的真值就意味着：若 $G(P_{1},P_{2},\cdots P_{n})$ 真，则 $H(P_{1},P_{2},\cdots P_{n})$ 必为真，或者说由 $G(P_{1},P_{2},\cdots P_{n})$ 为真可符合逻辑 地推出$H(P_{1},P_{2},\cdots P_{n})$也为真。这正是命题公式之间永真蕴含关系“$\Rightarrow$”的本质含义。  
下面的定理表明命题公式的永真蕴含关系$\scriptstyle""\Rightarrow\ ""$与逻辑运算的蕴含联结词“${\rightarrow}$”之间有着非常紧密的联系。  
【定理3.11】设$G(P_{1},P_{2},\cdots P_{n})$和$H(P_{1},P_{2},\cdots P_{n})$是任意两个具有相同命题变量的命题公式，$G(P_{1},P_{2},\cdots P_{n})$永真蕴含$H(P_{1},P_{2},\cdots P_{n})$，有：$G(P_{1},P_{2},\cdots P_{n})\Rightarrow H(P_{1},P_{2},\cdots P_{n})$ 当且仅当命题公式$G(P_{1},P_{2},\cdots P_{n})\rightarrow H(P_{1},P_{2},\cdots P_{n})$为永真公式。  
下面定理表明了永真蕴含关系的基本性质：  
【定理3.12】命题公式的永真蕴含关系满足如下三条基本性质：  
（1）自反性：对任意命题公式𝐴，有$A\Rightarrow A$；  
（2）反对称性：对任意命题公式$\cdot A$，$B$，如果$A\Rightarrow B$，并且$B\Rightarrow A$，那么$A\Leftrightarrow B$  
（3）传递性：对任意命题公式𝐴，$B$，$C$，如果$A\Rightarrow B$，$B\Rightarrow C$，那么$A\Rightarrow C$。  
【定理3.13】设𝐴、$B$为任意两个命题公式，$A\Leftrightarrow B$的充分必要条件是$A\Rightarrow B$，且$B\Rightarrow A$",永真蕴含关系与逻辑运算的蕴含联结词“→”之间有紧密联系，当且仅当命题公式G→H为永真公式时，G永真蕴含H
永真蕴含,充分必要条件,永真蕴含的充分必要条件,,"如同命题公式的等值关系相当于多项式的恒等式关系，命题公式的永真蕴含关系相当于多项式的不等式关系，表达的是命题公式真值的小于或等于关系。  
【定义3.27】设$G(P_{1},P_{2},\cdots,P_{n})$和$H(P_{1},P_{2},\cdots,P_{n})$是任意两个具有相同命题变量的命题公式，如果对于$P_{1},P_{2},\cdots P_{n}$的任意一组真值指派，$G(P_{1},P_{2},\cdots P_{n})$的真值总是不大于$H(P_{1},P_{2},\cdots P_{n})$的真值，即$v(G(P_{1},P_{2},\cdots P_{n}))\leq v(H(P_{1},P_{2},\cdots P_{n}))$，则称$G(P_{1},P_{2},\cdots P_{n})$永真蕴含$H(P_{1},P_{2},\cdots P_{n})$，记作$G(P_{1},P_{2},\cdots P_{n})\ \Rightarrow H(P_{1},P_{2},\cdots P_{n})$，且称$G(P_{1},P_{2},\cdots P_{n})$为永真蕴含的前件，$H(P_{1},P_{2},\cdots P_{n})$为永真蕴含的后件。  
从逻辑含义上看，命题公式$G(P_{1},P_{2},\cdots P_{n})$的真值总不大于$H(P_{1},P_{2},\cdots P_{n})$的真值就意味着：若 $G(P_{1},P_{2},\cdots P_{n})$ 真，则 $H(P_{1},P_{2},\cdots P_{n})$ 必为真，或者说由 $G(P_{1},P_{2},\cdots P_{n})$ 为真可符合逻辑 地推出$H(P_{1},P_{2},\cdots P_{n})$也为真。这正是命题公式之间永真蕴含关系“$\Rightarrow$”的本质含义。  
下面的定理表明命题公式的永真蕴含关系$\scriptstyle""\Rightarrow\ ""$与逻辑运算的蕴含联结词“${\rightarrow}$”之间有着非常紧密的联系。  
【定理3.11】设$G(P_{1},P_{2},\cdots P_{n})$和$H(P_{1},P_{2},\cdots P_{n})$是任意两个具有相同命题变量的命题公式，$G(P_{1},P_{2},\cdots P_{n})$永真蕴含$H(P_{1},P_{2},\cdots P_{n})$，有：$G(P_{1},P_{2},\cdots P_{n})\Rightarrow H(P_{1},P_{2},\cdots P_{n})$ 当且仅当命题公式$G(P_{1},P_{2},\cdots P_{n})\rightarrow H(P_{1},P_{2},\cdots P_{n})$为永真公式。  
下面定理表明了永真蕴含关系的基本性质：  
【定理3.12】命题公式的永真蕴含关系满足如下三条基本性质：  
（1）自反性：对任意命题公式𝐴，有$A\Rightarrow A$；  
（2）反对称性：对任意命题公式$\cdot A$，$B$，如果$A\Rightarrow B$，并且$B\Rightarrow A$，那么$A\Leftrightarrow B$  
（3）传递性：对任意命题公式𝐴，$B$，$C$，如果$A\Rightarrow B$，$B\Rightarrow C$，那么$A\Rightarrow C$。  
【定理3.13】设𝐴、$B$为任意两个命题公式，$A\Leftrightarrow B$的充分必要条件是$A\Rightarrow B$，且$B\Rightarrow A$",永真蕴含的充分必要条件是A⇒B且B⇒A，即A↔B
永真蕴含关系,包含,基本永真蕴含关系,,"命题公式的等值演算常常借助一些已经证明为正确的等值式来简化演算过程，例如使用等值蕴含式构造范式。在永真蕴含关系演算中，也可这样做。具体地说，就是首先通过真值表证明一些基本的永真蕴含关系式，然后将这些关系式作为已知工具直接使用，达到简化演算过程的效果。这些关系式一共有15 个，具体如下：  
基本化简律：$I_{1}\colon G\wedge H\Rightarrow G;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {I_{2}\colon G\wedge H\Rightarrow H;}$  
基本附加律：$I_{3}\colon G\Rightarrow G\vee H;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ {I_{4}\colon H\Rightarrow G\vee H;}$  
变形化简律：$I_{5}\colon\neg G\Rightarrow G\to H;\ \ \ \ \ \ \ \ \  \ \ \ \ {I_{6}\colon H\Rightarrow G\rightarrow H;}$  
变形附加律：$I_{7}\colon\neg(G\to H)\Rightarrow G;\ \ \ \ \ \ \ \ \ {I_{8}\colon\neg(G\rightarrow H)\Rightarrow\neg H;}$  
假言推理：$I_{9}\colon G\wedge(G\to H)\Rightarrow H$  ;  
拒取式：$I_{10}\colon(G\to H)\wedge\neg H\Rightarrow\neg G$  ;  
选言三段论： $I_{11}\colon(G\vee H)\wedge\neg H\Rightarrow G$  ;  
假言三段论： $I_{12}\colon(G\to H)\wedge(H\to R)\Rightarrow(G\to R)$  ;  
构造性二难推论：$I_{13}\colon(G\to H)\wedge(R\to J)\wedge(G\vee R)\ \ \Rightarrow(H\vee J)$;  
构造性特殊二难推论： $I_{14}\colon(G\to H)\wedge(\neg G\to H)\Rightarrow H$ ;  
破坏性二难推论：   $I_{15}$ :   $(G\to H)\land(R\to J)\land(\neg H\lor\neg J)\ \ \Rightarrow(\neg G\lor\neg R)$  。",永真蕴含关系包含基本永真蕴含关系，后者是前者的具体实例
命题逻辑的演绎推理,应用,永真蕴含关系,,"命题公式的等值演算常常借助一些已经证明为正确的等值式来简化演算过程，例如使用等值蕴含式构造范式。在永真蕴含关系演算中，也可这样做。具体地说，就是首先通过真值表证明一些基本的永真蕴含关系式，然后将这些关系式作为已知工具直接使用，达到简化演算过程的效果。这些关系式一共有15 个，具体如下：  
基本化简律：$I_{1}\colon G\wedge H\Rightarrow G;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {I_{2}\colon G\wedge H\Rightarrow H;}$  
基本附加律：$I_{3}\colon G\Rightarrow G\vee H;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ {I_{4}\colon H\Rightarrow G\vee H;}$  
变形化简律：$I_{5}\colon\neg G\Rightarrow G\to H;\ \ \ \ \ \ \ \ \  \ \ \ \ {I_{6}\colon H\Rightarrow G\rightarrow H;}$  
变形附加律：$I_{7}\colon\neg(G\to H)\Rightarrow G;\ \ \ \ \ \ \ \ \ {I_{8}\colon\neg(G\rightarrow H)\Rightarrow\neg H;}$  
假言推理：$I_{9}\colon G\wedge(G\to H)\Rightarrow H$  ;  
拒取式：$I_{10}\colon(G\to H)\wedge\neg H\Rightarrow\neg G$  ;  
选言三段论： $I_{11}\colon(G\vee H)\wedge\neg H\Rightarrow G$  ;  
假言三段论： $I_{12}\colon(G\to H)\wedge(H\to R)\Rightarrow(G\to R)$  ;  
构造性二难推论：$I_{13}\colon(G\to H)\wedge(R\to J)\wedge(G\vee R)\ \ \Rightarrow(H\vee J)$;  
构造性特殊二难推论： $I_{14}\colon(G\to H)\wedge(\neg G\to H)\Rightarrow H$ ;  
破坏性二难推论：   $I_{15}$ :   $(G\to H)\land(R\to J)\land(\neg H\lor\neg J)\ \ \Rightarrow(\neg G\lor\neg R)$  。",命题逻辑的演绎推理中应用永真蕴含关系来简化演算过程
命题逻辑的演绎推理,应用,基本永真蕴含关系,,"命题公式的等值演算常常借助一些已经证明为正确的等值式来简化演算过程，例如使用等值蕴含式构造范式。在永真蕴含关系演算中，也可这样做。具体地说，就是首先通过真值表证明一些基本的永真蕴含关系式，然后将这些关系式作为已知工具直接使用，达到简化演算过程的效果。这些关系式一共有15 个，具体如下：  
基本化简律：$I_{1}\colon G\wedge H\Rightarrow G;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {I_{2}\colon G\wedge H\Rightarrow H;}$  
基本附加律：$I_{3}\colon G\Rightarrow G\vee H;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ {I_{4}\colon H\Rightarrow G\vee H;}$  
变形化简律：$I_{5}\colon\neg G\Rightarrow G\to H;\ \ \ \ \ \ \ \ \  \ \ \ \ {I_{6}\colon H\Rightarrow G\rightarrow H;}$  
变形附加律：$I_{7}\colon\neg(G\to H)\Rightarrow G;\ \ \ \ \ \ \ \ \ {I_{8}\colon\neg(G\rightarrow H)\Rightarrow\neg H;}$  
假言推理：$I_{9}\colon G\wedge(G\to H)\Rightarrow H$  ;  
拒取式：$I_{10}\colon(G\to H)\wedge\neg H\Rightarrow\neg G$  ;  
选言三段论： $I_{11}\colon(G\vee H)\wedge\neg H\Rightarrow G$  ;  
假言三段论： $I_{12}\colon(G\to H)\wedge(H\to R)\Rightarrow(G\to R)$  ;  
构造性二难推论：$I_{13}\colon(G\to H)\wedge(R\to J)\wedge(G\vee R)\ \ \Rightarrow(H\vee J)$;  
构造性特殊二难推论： $I_{14}\colon(G\to H)\wedge(\neg G\to H)\Rightarrow H$ ;  
破坏性二难推论：   $I_{15}$ :   $(G\to H)\land(R\to J)\land(\neg H\lor\neg J)\ \ \Rightarrow(\neg G\lor\neg R)$  。",命题逻辑的演绎推理中应用基本永真蕴含关系作为已知工具简化演算
永真蕴含关系,判定方法,永真蕴含关系判定法,,命题公式永真蕴含关系的判定主要有如下两种基本方法，即真值表法、等值演算法。其每一种判定方法都对应三种不同的解法：①证明蕴含逻辑算式的永真性②假设前件为真，则后件也为真③假设后件为假，则前件也为假。下面将结合实例介绍这两种基本判定方法：,永真蕴含关系的判定方法包括真值表法和等值演算法
真值表法,判定,永真蕴含关系,,如果要判定公式$\boldsymbol{.A}$与公式$B$之间是否存在蕴含关系，可在真值表中分别列出公式𝐴与公式$B$的真值，并且验证在每一种真值指派下$A$的真值都小于$B$的真值，这时说明𝐴蕴含$\cdot B$。,真值表法用于判定公式之间是否存在永真蕴含关系
永真蕴含关系与判定,基本思路相似,公式演算法,,通过上述例子可以发现，对于永真蕴含关系的判定和证明，公式演算法与真值表法的基本思路几乎一样，二者的差别仅仅在于求解的表现形式不同，一个通过真值表的枚举，另外一个是通过命题公式的逻辑演算。,永真蕴含关系的判定和证明中，公式演算法与真值表法的基本思路几乎一样，仅在求解的表现形式上有所不同
有效推理,实现方式,命题公式推演系统,,"现在我们学习命题的数理逻辑推理。首先给出如下有效推理的概念：  
【定义3.28】设$G_{1},G_{2}\cdots G_{n}$，$H$是一些命题公式，如果它们满足下列性质：对于这些公式的任意一个解释𝐼，$G_{1},G_{2}\cdots G_{n}$在该解释下同时为真的情况下$\cdot_{H}$在该解释下也为真，则称命题公式$G_{1},G_{2}\cdots G_{n}$可有效推出公式$\cdot H$，或称由$G_{1},G_{2}\cdots G_{n}$得到$H$的逻辑推理为有效推理，记为$G_{1},G_{2}\cdots G_{n}\Rightarrow H$，并称$G_{1},G_{2}\cdots G_{n}$为推理前提，$H$为$G_{1},G_{2}\cdots G_{n}$的逻辑结论。  
从上述定义不难看出，有效推理其实就是把永真蕴含关系由两个命题公式之间的关系推广到多个命题公式之间的关系，即由一组命题公式构成的永真蕴含前件与一个永真蕴含后件之间的关系。下面定理表明有效推理的过程其实就是证明逻辑蕴含式的过程。  
【定理3.14】命题公式$H$是命题公式$G_{1},G_{2},\cdots,G_{n}$的逻辑结论，即$G_{1},G_{2},\cdots,G_{n}\Rightarrow H$，当且仅当$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\to H$为永真公式。  
从理论上讲，利用真值表技术完全可以在有限的步骤内完成对任意含有限个命题变量的永真蕴含关系进行判定或者说进行有效的命题逻辑推理。但是，在针对具体问题的命题逻辑推理时，推理的前提条件一般包含很多个命题公式，有时会涉及大量的命题变量，此时真值表方法就出现组合爆炸问题而变的不可行。因此，需要建立一种命题公式推演系统，在少量基本等值关系式和永真蕴含关系式的基础上，通过建立若干推理规则进行演绎推证的方式实现命题逻辑的有效推理。人们提出了很多各具特色的推演系统，对这系统的详细讨论已经超出了本课程的学习范畴，有兴趣的读者可以查阅相关资料。我们主要介绍一种最基本的推演系统，下图3-9 表示系统的基本结构。  
![](images/9e9fac00c2d40b2f3ec288b2f0ea17c474bc9160a1447874b9a37744cd5272d2.jpg)
图3-9 推演系统的基本结构  
上图表示的推演系统中包括事实库、公理库和推理规则这三个基本模块，公理库和事实库构成命题推理的基本依据。公理库包含已被证明为正确的24 个基本等值式和15 个基本永真蕴含式，这些基本关系式构成推演系统的基础知识资源，事实库由具体命题推理实例的所有前提条件以及推理过程中产生的有效中间结论组成；推理规则是命题逻辑推理的核心机制，主要由$P$规则、$T$规则和$C P$规则这三个基本规则组成。  
（1）$P$规则（前提引用规则）：推导过程中可随时引入前提集合中的任意一个前提。  
（2）$T$规则（逻辑结果引用规则）推导的过程中可随时引入公式𝑆，该公式𝑆是由其前的一个或多个公式推导出来的逻辑结果。  
（3）$C P$规则（附加前提规则）如果能从给定的前提集合$\Gamma$与公式$P$推导出𝑆，则能从此前提集合$\Gamma$ 推导出$P\rightarrow S$。  
注意：$C P$规则适用于结论为条件式的有效推理。使用𝐶𝑃规则就是把结论中的前件作为附加前提加入前提集合，共同去推出结论的后件。  
根据上述命题演算推理系统，就可进行有效的命题逻辑推理。通过有效推理，就可证明命题逻辑中所有定理。所谓证明，就是有效推理的具体推演过程，具体定义如下：  
【定义3.29】从前提集合Г 推出结论$\cdot H$的一个演绎或形式证明，就是构造一个命题公式的有限序列：$H_{1},H_{2},H_{3},\ldots,H_{n}$。其中：$H_{i}$或者是Г 中的某个前提，或者是前面的某些${\cdot}H_{j}(j{<}i)$的有效结论，并且${\cal H}_{n}$就是$H$。此时称$H$为该演绎的有效结论。",命题公式推演系统通过建立推理规则进行演绎推证，实现有效推理
P规则,组成部分,命题公式推演系统,,"现在我们学习命题的数理逻辑推理。首先给出如下有效推理的概念：  
【定义3.28】设$G_{1},G_{2}\cdots G_{n}$，$H$是一些命题公式，如果它们满足下列性质：对于这些公式的任意一个解释𝐼，$G_{1},G_{2}\cdots G_{n}$在该解释下同时为真的情况下$\cdot_{H}$在该解释下也为真，则称命题公式$G_{1},G_{2}\cdots G_{n}$可有效推出公式$\cdot H$，或称由$G_{1},G_{2}\cdots G_{n}$得到$H$的逻辑推理为有效推理，记为$G_{1},G_{2}\cdots G_{n}\Rightarrow H$，并称$G_{1},G_{2}\cdots G_{n}$为推理前提，$H$为$G_{1},G_{2}\cdots G_{n}$的逻辑结论。  
从上述定义不难看出，有效推理其实就是把永真蕴含关系由两个命题公式之间的关系推广到多个命题公式之间的关系，即由一组命题公式构成的永真蕴含前件与一个永真蕴含后件之间的关系。下面定理表明有效推理的过程其实就是证明逻辑蕴含式的过程。  
【定理3.14】命题公式$H$是命题公式$G_{1},G_{2},\cdots,G_{n}$的逻辑结论，即$G_{1},G_{2},\cdots,G_{n}\Rightarrow H$，当且仅当$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\to H$为永真公式。  
从理论上讲，利用真值表技术完全可以在有限的步骤内完成对任意含有限个命题变量的永真蕴含关系进行判定或者说进行有效的命题逻辑推理。但是，在针对具体问题的命题逻辑推理时，推理的前提条件一般包含很多个命题公式，有时会涉及大量的命题变量，此时真值表方法就出现组合爆炸问题而变的不可行。因此，需要建立一种命题公式推演系统，在少量基本等值关系式和永真蕴含关系式的基础上，通过建立若干推理规则进行演绎推证的方式实现命题逻辑的有效推理。人们提出了很多各具特色的推演系统，对这系统的详细讨论已经超出了本课程的学习范畴，有兴趣的读者可以查阅相关资料。我们主要介绍一种最基本的推演系统，下图3-9 表示系统的基本结构。  
![](images/9e9fac00c2d40b2f3ec288b2f0ea17c474bc9160a1447874b9a37744cd5272d2.jpg)
图3-9 推演系统的基本结构  
上图表示的推演系统中包括事实库、公理库和推理规则这三个基本模块，公理库和事实库构成命题推理的基本依据。公理库包含已被证明为正确的24 个基本等值式和15 个基本永真蕴含式，这些基本关系式构成推演系统的基础知识资源，事实库由具体命题推理实例的所有前提条件以及推理过程中产生的有效中间结论组成；推理规则是命题逻辑推理的核心机制，主要由$P$规则、$T$规则和$C P$规则这三个基本规则组成。  
（1）$P$规则（前提引用规则）：推导过程中可随时引入前提集合中的任意一个前提。  
（2）$T$规则（逻辑结果引用规则）推导的过程中可随时引入公式𝑆，该公式𝑆是由其前的一个或多个公式推导出来的逻辑结果。  
（3）$C P$规则（附加前提规则）如果能从给定的前提集合$\Gamma$与公式$P$推导出𝑆，则能从此前提集合$\Gamma$ 推导出$P\rightarrow S$。  
注意：$C P$规则适用于结论为条件式的有效推理。使用𝐶𝑃规则就是把结论中的前件作为附加前提加入前提集合，共同去推出结论的后件。  
根据上述命题演算推理系统，就可进行有效的命题逻辑推理。通过有效推理，就可证明命题逻辑中所有定理。所谓证明，就是有效推理的具体推演过程，具体定义如下：  
【定义3.29】从前提集合Г 推出结论$\cdot H$的一个演绎或形式证明，就是构造一个命题公式的有限序列：$H_{1},H_{2},H_{3},\ldots,H_{n}$。其中：$H_{i}$或者是Г 中的某个前提，或者是前面的某些${\cdot}H_{j}(j{<}i)$的有效结论，并且${\cal H}_{n}$就是$H$。此时称$H$为该演绎的有效结论。",P规则是命题公式推演系统中的基本推理规则之一
T规则,组成部分,命题公式推演系统,,"现在我们学习命题的数理逻辑推理。首先给出如下有效推理的概念：  
【定义3.28】设$G_{1},G_{2}\cdots G_{n}$，$H$是一些命题公式，如果它们满足下列性质：对于这些公式的任意一个解释𝐼，$G_{1},G_{2}\cdots G_{n}$在该解释下同时为真的情况下$\cdot_{H}$在该解释下也为真，则称命题公式$G_{1},G_{2}\cdots G_{n}$可有效推出公式$\cdot H$，或称由$G_{1},G_{2}\cdots G_{n}$得到$H$的逻辑推理为有效推理，记为$G_{1},G_{2}\cdots G_{n}\Rightarrow H$，并称$G_{1},G_{2}\cdots G_{n}$为推理前提，$H$为$G_{1},G_{2}\cdots G_{n}$的逻辑结论。  
从上述定义不难看出，有效推理其实就是把永真蕴含关系由两个命题公式之间的关系推广到多个命题公式之间的关系，即由一组命题公式构成的永真蕴含前件与一个永真蕴含后件之间的关系。下面定理表明有效推理的过程其实就是证明逻辑蕴含式的过程。  
【定理3.14】命题公式$H$是命题公式$G_{1},G_{2},\cdots,G_{n}$的逻辑结论，即$G_{1},G_{2},\cdots,G_{n}\Rightarrow H$，当且仅当$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\to H$为永真公式。  
从理论上讲，利用真值表技术完全可以在有限的步骤内完成对任意含有限个命题变量的永真蕴含关系进行判定或者说进行有效的命题逻辑推理。但是，在针对具体问题的命题逻辑推理时，推理的前提条件一般包含很多个命题公式，有时会涉及大量的命题变量，此时真值表方法就出现组合爆炸问题而变的不可行。因此，需要建立一种命题公式推演系统，在少量基本等值关系式和永真蕴含关系式的基础上，通过建立若干推理规则进行演绎推证的方式实现命题逻辑的有效推理。人们提出了很多各具特色的推演系统，对这系统的详细讨论已经超出了本课程的学习范畴，有兴趣的读者可以查阅相关资料。我们主要介绍一种最基本的推演系统，下图3-9 表示系统的基本结构。  
![](images/9e9fac00c2d40b2f3ec288b2f0ea17c474bc9160a1447874b9a37744cd5272d2.jpg)
图3-9 推演系统的基本结构  
上图表示的推演系统中包括事实库、公理库和推理规则这三个基本模块，公理库和事实库构成命题推理的基本依据。公理库包含已被证明为正确的24 个基本等值式和15 个基本永真蕴含式，这些基本关系式构成推演系统的基础知识资源，事实库由具体命题推理实例的所有前提条件以及推理过程中产生的有效中间结论组成；推理规则是命题逻辑推理的核心机制，主要由$P$规则、$T$规则和$C P$规则这三个基本规则组成。  
（1）$P$规则（前提引用规则）：推导过程中可随时引入前提集合中的任意一个前提。  
（2）$T$规则（逻辑结果引用规则）推导的过程中可随时引入公式𝑆，该公式𝑆是由其前的一个或多个公式推导出来的逻辑结果。  
（3）$C P$规则（附加前提规则）如果能从给定的前提集合$\Gamma$与公式$P$推导出𝑆，则能从此前提集合$\Gamma$ 推导出$P\rightarrow S$。  
注意：$C P$规则适用于结论为条件式的有效推理。使用𝐶𝑃规则就是把结论中的前件作为附加前提加入前提集合，共同去推出结论的后件。  
根据上述命题演算推理系统，就可进行有效的命题逻辑推理。通过有效推理，就可证明命题逻辑中所有定理。所谓证明，就是有效推理的具体推演过程，具体定义如下：  
【定义3.29】从前提集合Г 推出结论$\cdot H$的一个演绎或形式证明，就是构造一个命题公式的有限序列：$H_{1},H_{2},H_{3},\ldots,H_{n}$。其中：$H_{i}$或者是Г 中的某个前提，或者是前面的某些${\cdot}H_{j}(j{<}i)$的有效结论，并且${\cal H}_{n}$就是$H$。此时称$H$为该演绎的有效结论。",T规则是命题公式推演系统中的基本推理规则之一
CP规则,组成部分,命题公式推演系统,,"现在我们学习命题的数理逻辑推理。首先给出如下有效推理的概念：  
【定义3.28】设$G_{1},G_{2}\cdots G_{n}$，$H$是一些命题公式，如果它们满足下列性质：对于这些公式的任意一个解释𝐼，$G_{1},G_{2}\cdots G_{n}$在该解释下同时为真的情况下$\cdot_{H}$在该解释下也为真，则称命题公式$G_{1},G_{2}\cdots G_{n}$可有效推出公式$\cdot H$，或称由$G_{1},G_{2}\cdots G_{n}$得到$H$的逻辑推理为有效推理，记为$G_{1},G_{2}\cdots G_{n}\Rightarrow H$，并称$G_{1},G_{2}\cdots G_{n}$为推理前提，$H$为$G_{1},G_{2}\cdots G_{n}$的逻辑结论。  
从上述定义不难看出，有效推理其实就是把永真蕴含关系由两个命题公式之间的关系推广到多个命题公式之间的关系，即由一组命题公式构成的永真蕴含前件与一个永真蕴含后件之间的关系。下面定理表明有效推理的过程其实就是证明逻辑蕴含式的过程。  
【定理3.14】命题公式$H$是命题公式$G_{1},G_{2},\cdots,G_{n}$的逻辑结论，即$G_{1},G_{2},\cdots,G_{n}\Rightarrow H$，当且仅当$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\to H$为永真公式。  
从理论上讲，利用真值表技术完全可以在有限的步骤内完成对任意含有限个命题变量的永真蕴含关系进行判定或者说进行有效的命题逻辑推理。但是，在针对具体问题的命题逻辑推理时，推理的前提条件一般包含很多个命题公式，有时会涉及大量的命题变量，此时真值表方法就出现组合爆炸问题而变的不可行。因此，需要建立一种命题公式推演系统，在少量基本等值关系式和永真蕴含关系式的基础上，通过建立若干推理规则进行演绎推证的方式实现命题逻辑的有效推理。人们提出了很多各具特色的推演系统，对这系统的详细讨论已经超出了本课程的学习范畴，有兴趣的读者可以查阅相关资料。我们主要介绍一种最基本的推演系统，下图3-9 表示系统的基本结构。  
![](images/9e9fac00c2d40b2f3ec288b2f0ea17c474bc9160a1447874b9a37744cd5272d2.jpg)
图3-9 推演系统的基本结构  
上图表示的推演系统中包括事实库、公理库和推理规则这三个基本模块，公理库和事实库构成命题推理的基本依据。公理库包含已被证明为正确的24 个基本等值式和15 个基本永真蕴含式，这些基本关系式构成推演系统的基础知识资源，事实库由具体命题推理实例的所有前提条件以及推理过程中产生的有效中间结论组成；推理规则是命题逻辑推理的核心机制，主要由$P$规则、$T$规则和$C P$规则这三个基本规则组成。  
（1）$P$规则（前提引用规则）：推导过程中可随时引入前提集合中的任意一个前提。  
（2）$T$规则（逻辑结果引用规则）推导的过程中可随时引入公式𝑆，该公式𝑆是由其前的一个或多个公式推导出来的逻辑结果。  
（3）$C P$规则（附加前提规则）如果能从给定的前提集合$\Gamma$与公式$P$推导出𝑆，则能从此前提集合$\Gamma$ 推导出$P\rightarrow S$。  
注意：$C P$规则适用于结论为条件式的有效推理。使用𝐶𝑃规则就是把结论中的前件作为附加前提加入前提集合，共同去推出结论的后件。  
根据上述命题演算推理系统，就可进行有效的命题逻辑推理。通过有效推理，就可证明命题逻辑中所有定理。所谓证明，就是有效推理的具体推演过程，具体定义如下：  
【定义3.29】从前提集合Г 推出结论$\cdot H$的一个演绎或形式证明，就是构造一个命题公式的有限序列：$H_{1},H_{2},H_{3},\ldots,H_{n}$。其中：$H_{i}$或者是Г 中的某个前提，或者是前面的某些${\cdot}H_{j}(j{<}i)$的有效结论，并且${\cal H}_{n}$就是$H$。此时称$H$为该演绎的有效结论。",CP规则是命题公式推演系统中的基本推理规则之一
有效推理,具体表现,演绎或形式证明,,"现在我们学习命题的数理逻辑推理。首先给出如下有效推理的概念：  
【定义3.28】设$G_{1},G_{2}\cdots G_{n}$，$H$是一些命题公式，如果它们满足下列性质：对于这些公式的任意一个解释𝐼，$G_{1},G_{2}\cdots G_{n}$在该解释下同时为真的情况下$\cdot_{H}$在该解释下也为真，则称命题公式$G_{1},G_{2}\cdots G_{n}$可有效推出公式$\cdot H$，或称由$G_{1},G_{2}\cdots G_{n}$得到$H$的逻辑推理为有效推理，记为$G_{1},G_{2}\cdots G_{n}\Rightarrow H$，并称$G_{1},G_{2}\cdots G_{n}$为推理前提，$H$为$G_{1},G_{2}\cdots G_{n}$的逻辑结论。  
从上述定义不难看出，有效推理其实就是把永真蕴含关系由两个命题公式之间的关系推广到多个命题公式之间的关系，即由一组命题公式构成的永真蕴含前件与一个永真蕴含后件之间的关系。下面定理表明有效推理的过程其实就是证明逻辑蕴含式的过程。  
【定理3.14】命题公式$H$是命题公式$G_{1},G_{2},\cdots,G_{n}$的逻辑结论，即$G_{1},G_{2},\cdots,G_{n}\Rightarrow H$，当且仅当$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\to H$为永真公式。  
从理论上讲，利用真值表技术完全可以在有限的步骤内完成对任意含有限个命题变量的永真蕴含关系进行判定或者说进行有效的命题逻辑推理。但是，在针对具体问题的命题逻辑推理时，推理的前提条件一般包含很多个命题公式，有时会涉及大量的命题变量，此时真值表方法就出现组合爆炸问题而变的不可行。因此，需要建立一种命题公式推演系统，在少量基本等值关系式和永真蕴含关系式的基础上，通过建立若干推理规则进行演绎推证的方式实现命题逻辑的有效推理。人们提出了很多各具特色的推演系统，对这系统的详细讨论已经超出了本课程的学习范畴，有兴趣的读者可以查阅相关资料。我们主要介绍一种最基本的推演系统，下图3-9 表示系统的基本结构。  
![](images/9e9fac00c2d40b2f3ec288b2f0ea17c474bc9160a1447874b9a37744cd5272d2.jpg)
图3-9 推演系统的基本结构  
上图表示的推演系统中包括事实库、公理库和推理规则这三个基本模块，公理库和事实库构成命题推理的基本依据。公理库包含已被证明为正确的24 个基本等值式和15 个基本永真蕴含式，这些基本关系式构成推演系统的基础知识资源，事实库由具体命题推理实例的所有前提条件以及推理过程中产生的有效中间结论组成；推理规则是命题逻辑推理的核心机制，主要由$P$规则、$T$规则和$C P$规则这三个基本规则组成。  
（1）$P$规则（前提引用规则）：推导过程中可随时引入前提集合中的任意一个前提。  
（2）$T$规则（逻辑结果引用规则）推导的过程中可随时引入公式𝑆，该公式𝑆是由其前的一个或多个公式推导出来的逻辑结果。  
（3）$C P$规则（附加前提规则）如果能从给定的前提集合$\Gamma$与公式$P$推导出𝑆，则能从此前提集合$\Gamma$ 推导出$P\rightarrow S$。  
注意：$C P$规则适用于结论为条件式的有效推理。使用𝐶𝑃规则就是把结论中的前件作为附加前提加入前提集合，共同去推出结论的后件。  
根据上述命题演算推理系统，就可进行有效的命题逻辑推理。通过有效推理，就可证明命题逻辑中所有定理。所谓证明，就是有效推理的具体推演过程，具体定义如下：  
【定义3.29】从前提集合Г 推出结论$\cdot H$的一个演绎或形式证明，就是构造一个命题公式的有限序列：$H_{1},H_{2},H_{3},\ldots,H_{n}$。其中：$H_{i}$或者是Г 中的某个前提，或者是前面的某些${\cdot}H_{j}(j{<}i)$的有效结论，并且${\cal H}_{n}$就是$H$。此时称$H$为该演绎的有效结论。",演绎或形式证明是有效推理的具体推演过程
命题逻辑的演绎推理,包含,命题推证的基本策略,,如前所述，有效推理的过程其实就是证明逻辑蕴含式的过程。因此，命题推证的基本策略主要有真值表法、直接证明法和间接证明法这三种基本类型。,命题逻辑的演绎推理包含命题推证的基本策略，如真值表法、直接证明法和间接证明法
命题逻辑的演绎推理,应用,真值表法,,"设${\mathcal{}}P_{1},P_{2},\cdots,P_{n}$是出现在前提$G_{1},G_{2},\cdots,G_{n}$和结论H中的一切命题变元，如果将$P_{1},P_{2},\cdots,P_{n}$中所有可能的解释及$G_{1},G_{2},\cdots,G_{n},\mathrm{H}$的对应真值结果都列在一个表中，根据“ $\rightarrow$”的定义，则有判断方法如下：  
1。对所有$G_{1},G_{2},\cdots,G_{n}$都具有真值𝑇的行（表示前提为真的行），如果在每一个这样的行中，$H$也具有真值$T$，则$H$是$G_{1},G_{2},\cdots,G_{n}$的逻辑结果。  
2。对所有$H$具有真值为F的行（表示结论为假的行），如果在每一个这样的行中，$G_{1},G_{2},\cdots,G_{n}$中至少有一个公式的真值为$\cdot F$（前提也为假），则H是$G_{1},G_{2},\cdots,G_{n}$的逻辑结果。",真值表法用于判断命题逻辑的演绎推理中前提和结论的逻辑关系
直接证明法,基于,前提,,直接证明法就是由一组前提，利用一些公认的推理规则和推理定律进行逻辑推演得到有效结论，或者说仅使用$\pmb{P}$规则和𝑻规则进行证明的方法称为直接证明法。该方法的关键是要熟记常用的推理规则。,直接证明法基于一组前提进行逻辑推演
直接证明法,利用,推理规则,,直接证明法就是由一组前提，利用一些公认的推理规则和推理定律进行逻辑推演得到有效结论，或者说仅使用$\pmb{P}$规则和𝑻规则进行证明的方法称为直接证明法。该方法的关键是要熟记常用的推理规则。,直接证明法利用公认的推理规则进行证明
直接证明法,利用,推理定律,,直接证明法就是由一组前提，利用一些公认的推理规则和推理定律进行逻辑推演得到有效结论，或者说仅使用$\pmb{P}$规则和𝑻规则进行证明的方法称为直接证明法。该方法的关键是要熟记常用的推理规则。,直接证明法利用推理定律进行逻辑推演
直接证明法,使用,P规则,,直接证明法就是由一组前提，利用一些公认的推理规则和推理定律进行逻辑推演得到有效结论，或者说仅使用$\pmb{P}$规则和𝑻规则进行证明的方法称为直接证明法。该方法的关键是要熟记常用的推理规则。,直接证明法使用P规则进行证明
直接证明法,使用,T规则,,直接证明法就是由一组前提，利用一些公认的推理规则和推理定律进行逻辑推演得到有效结论，或者说仅使用$\pmb{P}$规则和𝑻规则进行证明的方法称为直接证明法。该方法的关键是要熟记常用的推理规则。,直接证明法使用T规则进行证明
间接证明法,等价,反证法,,"间接证明法不仅使用$P$规则，$T$规则，还使用反证法或$C P$规则的推理方法。在引入间接证明法之前，首先给出公式组相容概念：  
【定义3.30】假设$G_{1},G_{2},\cdots,G_{n}$是一组命题公式，$P_{1},P_{2},\cdots,P_{n}$是出现在$G_{1},G_{2},\cdots,G_{n}$中的一切命题变元，若有解释I使$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}$取值为“真”，则称公式$G_{1},G_{2},\cdots,G_{n}$是一致的或相容的，否则称公式$G_{1},G_{2},\cdots,G_{n}$为不一致的，或者说$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}$是一个矛盾式。  
利用矛盾式的概念，可以给出一种推导过程，这个过程通常称为矛盾法或间接证明法，常被称为反证法。下面给出反证法的证明。  
【定理3.15】如果命题公式集合$\{G_{1},G_{2},\cdots,G_{n}\}$是相容的，那么从前提集合$\{G_{1},G_{2},\cdots,G_{n}\}$可以逻辑推出公式$\cdot H$，即$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\Rightarrow H$，的充要条件是从前提集合$\{G_{1},G_{2},\cdots,G_{n},\lnot H\}$出发，可以逻辑推出一个矛盾（永假）式来，即$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\wedge\neg H\Rightarrow F_{\circ}$。",间接证明法常被称为反证法
间接证明法,应用,公式组相容,,"间接证明法不仅使用$P$规则，$T$规则，还使用反证法或$C P$规则的推理方法。在引入间接证明法之前，首先给出公式组相容概念：  
【定义3.30】假设$G_{1},G_{2},\cdots,G_{n}$是一组命题公式，$P_{1},P_{2},\cdots,P_{n}$是出现在$G_{1},G_{2},\cdots,G_{n}$中的一切命题变元，若有解释I使$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}$取值为“真”，则称公式$G_{1},G_{2},\cdots,G_{n}$是一致的或相容的，否则称公式$G_{1},G_{2},\cdots,G_{n}$为不一致的，或者说$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}$是一个矛盾式。  
利用矛盾式的概念，可以给出一种推导过程，这个过程通常称为矛盾法或间接证明法，常被称为反证法。下面给出反证法的证明。  
【定理3.15】如果命题公式集合$\{G_{1},G_{2},\cdots,G_{n}\}$是相容的，那么从前提集合$\{G_{1},G_{2},\cdots,G_{n}\}$可以逻辑推出公式$\cdot H$，即$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\Rightarrow H$，的充要条件是从前提集合$\{G_{1},G_{2},\cdots,G_{n},\lnot H\}$出发，可以逻辑推出一个矛盾（永假）式来，即$G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\wedge\neg H\Rightarrow F_{\circ}$。",间接证明法利用公式组相容的概念进行推导
命题逻辑,培养,逻辑思维能力,,命题逻辑不仅可以培养良好的逻辑思维能力，而且在案件侦破、电路设计等领域具有广泛的实际应用价值。本节主要介绍命题逻辑在案件侦查的自动推理、组合电路设计以及计算机加法器电路设计中的应用。,命题逻辑可以培养良好的逻辑思维能力
命题逻辑,应用,案件侦破,,命题逻辑不仅可以培养良好的逻辑思维能力，而且在案件侦破、电路设计等领域具有广泛的实际应用价值。本节主要介绍命题逻辑在案件侦查的自动推理、组合电路设计以及计算机加法器电路设计中的应用。,命题逻辑在案件侦破中具有实际应用价值
命题逻辑,应用,电路设计,,命题逻辑不仅可以培养良好的逻辑思维能力，而且在案件侦破、电路设计等领域具有广泛的实际应用价值。本节主要介绍命题逻辑在案件侦查的自动推理、组合电路设计以及计算机加法器电路设计中的应用。,命题逻辑在电路设计中具有实际应用价值
命题逻辑,应用,自动推理,,命题逻辑不仅可以培养良好的逻辑思维能力，而且在案件侦破、电路设计等领域具有广泛的实际应用价值。本节主要介绍命题逻辑在案件侦查的自动推理、组合电路设计以及计算机加法器电路设计中的应用。,命题逻辑在案件侦查的自动推理中应用
命题逻辑,应用,组合电路设计,,命题逻辑不仅可以培养良好的逻辑思维能力，而且在案件侦破、电路设计等领域具有广泛的实际应用价值。本节主要介绍命题逻辑在案件侦查的自动推理、组合电路设计以及计算机加法器电路设计中的应用。,命题逻辑在组合电路设计中应用
命题逻辑,应用,计算机加法器电路设计,,命题逻辑不仅可以培养良好的逻辑思维能力，而且在案件侦破、电路设计等领域具有广泛的实际应用价值。本节主要介绍命题逻辑在案件侦查的自动推理、组合电路设计以及计算机加法器电路设计中的应用。,命题逻辑在计算机加法器电路设计中应用
命题逻辑推理,应用,案件侦破,,命题逻辑推理在案件侦破等领域具有十分重要的作用，可以现有案件线索作为命题逻辑的推理的前提条件进行有效推理，得到有价值的推理结论供案件侦破人员参考。,命题逻辑推理在案件侦破中具有重要作用，通过现有案件线索作为前提条件进行有效推理，得出有价值的结论供侦破人员参考
命题逻辑,理论基础,组合逻辑电路,,"逻辑电路，又分为逻辑电路和时序逻辑电路。前者由最基本的“与门”、“或门”和“非门”电路组成，其输出值仅依赖于其输入变量的当前值，与输入变量的过去值无关—即不具记忆和存储功能；后者也由上述基本逻辑门电路组成，但存在反馈回路—它的输出值不仅依赖于输入变量的当前值， 也依赖于输入变量的过去值。 命题逻辑是组合逻辑电路设计的理论基础 和基本工具。如图3-10 所示，组合逻辑电路中的 “非门”、 “与门”、 “或门”，即为命题逻辑的“与”、“或”、“非”三种运算。通过利用这三种门，就可以构造出各种组合逻辑电路。  
![](images/e4f21b269b175874de7115f5156d6a3c1eb9e6666a1338dc9d4727bc0ca3ab30.jpg)
图3-10 基本类型的门  
“与门”和“或门”允许有多个输入，具有 $n$个输入的“与门”和“或门”如图3-11 所示。  
![](images/b8e3cbd2c8e7532c3d5f1acea4bd76306cd188918c6130d6354e264b174b34dc.jpg)
图3-11 具有 $n$ 个输入的门",命题逻辑是组合逻辑电路设计的理论基础和基本工具
组合逻辑电路,组成,与门,,"逻辑电路，又分为逻辑电路和时序逻辑电路。前者由最基本的“与门”、“或门”和“非门”电路组成，其输出值仅依赖于其输入变量的当前值，与输入变量的过去值无关—即不具记忆和存储功能；后者也由上述基本逻辑门电路组成，但存在反馈回路—它的输出值不仅依赖于输入变量的当前值， 也依赖于输入变量的过去值。 命题逻辑是组合逻辑电路设计的理论基础 和基本工具。如图3-10 所示，组合逻辑电路中的 “非门”、 “与门”、 “或门”，即为命题逻辑的“与”、“或”、“非”三种运算。通过利用这三种门，就可以构造出各种组合逻辑电路。  
![](images/e4f21b269b175874de7115f5156d6a3c1eb9e6666a1338dc9d4727bc0ca3ab30.jpg)
图3-10 基本类型的门  
“与门”和“或门”允许有多个输入，具有 $n$个输入的“与门”和“或门”如图3-11 所示。  
![](images/b8e3cbd2c8e7532c3d5f1acea4bd76306cd188918c6130d6354e264b174b34dc.jpg)
图3-11 具有 $n$ 个输入的门",组合逻辑电路由与门等基本逻辑门电路组成
组合逻辑电路,组成,或门,,"逻辑电路，又分为逻辑电路和时序逻辑电路。前者由最基本的“与门”、“或门”和“非门”电路组成，其输出值仅依赖于其输入变量的当前值，与输入变量的过去值无关—即不具记忆和存储功能；后者也由上述基本逻辑门电路组成，但存在反馈回路—它的输出值不仅依赖于输入变量的当前值， 也依赖于输入变量的过去值。 命题逻辑是组合逻辑电路设计的理论基础 和基本工具。如图3-10 所示，组合逻辑电路中的 “非门”、 “与门”、 “或门”，即为命题逻辑的“与”、“或”、“非”三种运算。通过利用这三种门，就可以构造出各种组合逻辑电路。  
![](images/e4f21b269b175874de7115f5156d6a3c1eb9e6666a1338dc9d4727bc0ca3ab30.jpg)
图3-10 基本类型的门  
“与门”和“或门”允许有多个输入，具有 $n$个输入的“与门”和“或门”如图3-11 所示。  
![](images/b8e3cbd2c8e7532c3d5f1acea4bd76306cd188918c6130d6354e264b174b34dc.jpg)
图3-11 具有 $n$ 个输入的门",组合逻辑电路由或门等基本逻辑门电路组成
组合逻辑电路,组成,非门,,"逻辑电路，又分为逻辑电路和时序逻辑电路。前者由最基本的“与门”、“或门”和“非门”电路组成，其输出值仅依赖于其输入变量的当前值，与输入变量的过去值无关—即不具记忆和存储功能；后者也由上述基本逻辑门电路组成，但存在反馈回路—它的输出值不仅依赖于输入变量的当前值， 也依赖于输入变量的过去值。 命题逻辑是组合逻辑电路设计的理论基础 和基本工具。如图3-10 所示，组合逻辑电路中的 “非门”、 “与门”、 “或门”，即为命题逻辑的“与”、“或”、“非”三种运算。通过利用这三种门，就可以构造出各种组合逻辑电路。  
![](images/e4f21b269b175874de7115f5156d6a3c1eb9e6666a1338dc9d4727bc0ca3ab30.jpg)
图3-10 基本类型的门  
“与门”和“或门”允许有多个输入，具有 $n$个输入的“与门”和“或门”如图3-11 所示。  
![](images/b8e3cbd2c8e7532c3d5f1acea4bd76306cd188918c6130d6354e264b174b34dc.jpg)
图3-11 具有 $n$ 个输入的门",组合逻辑电路由非门等基本逻辑门电路组成
与门,对应,命题逻辑,,"逻辑电路，又分为逻辑电路和时序逻辑电路。前者由最基本的“与门”、“或门”和“非门”电路组成，其输出值仅依赖于其输入变量的当前值，与输入变量的过去值无关—即不具记忆和存储功能；后者也由上述基本逻辑门电路组成，但存在反馈回路—它的输出值不仅依赖于输入变量的当前值， 也依赖于输入变量的过去值。 命题逻辑是组合逻辑电路设计的理论基础 和基本工具。如图3-10 所示，组合逻辑电路中的 “非门”、 “与门”、 “或门”，即为命题逻辑的“与”、“或”、“非”三种运算。通过利用这三种门，就可以构造出各种组合逻辑电路。  
![](images/e4f21b269b175874de7115f5156d6a3c1eb9e6666a1338dc9d4727bc0ca3ab30.jpg)
图3-10 基本类型的门  
“与门”和“或门”允许有多个输入，具有 $n$个输入的“与门”和“或门”如图3-11 所示。  
![](images/b8e3cbd2c8e7532c3d5f1acea4bd76306cd188918c6130d6354e264b174b34dc.jpg)
图3-11 具有 $n$ 个输入的门",与门对应命题逻辑中的与运算
或门,对应,命题逻辑,,"逻辑电路，又分为逻辑电路和时序逻辑电路。前者由最基本的“与门”、“或门”和“非门”电路组成，其输出值仅依赖于其输入变量的当前值，与输入变量的过去值无关—即不具记忆和存储功能；后者也由上述基本逻辑门电路组成，但存在反馈回路—它的输出值不仅依赖于输入变量的当前值， 也依赖于输入变量的过去值。 命题逻辑是组合逻辑电路设计的理论基础 和基本工具。如图3-10 所示，组合逻辑电路中的 “非门”、 “与门”、 “或门”，即为命题逻辑的“与”、“或”、“非”三种运算。通过利用这三种门，就可以构造出各种组合逻辑电路。  
![](images/e4f21b269b175874de7115f5156d6a3c1eb9e6666a1338dc9d4727bc0ca3ab30.jpg)
图3-10 基本类型的门  
“与门”和“或门”允许有多个输入，具有 $n$个输入的“与门”和“或门”如图3-11 所示。  
![](images/b8e3cbd2c8e7532c3d5f1acea4bd76306cd188918c6130d6354e264b174b34dc.jpg)
图3-11 具有 $n$ 个输入的门",或门对应命题逻辑中的或运算
非门,对应,命题逻辑,,"逻辑电路，又分为逻辑电路和时序逻辑电路。前者由最基本的“与门”、“或门”和“非门”电路组成，其输出值仅依赖于其输入变量的当前值，与输入变量的过去值无关—即不具记忆和存储功能；后者也由上述基本逻辑门电路组成，但存在反馈回路—它的输出值不仅依赖于输入变量的当前值， 也依赖于输入变量的过去值。 命题逻辑是组合逻辑电路设计的理论基础 和基本工具。如图3-10 所示，组合逻辑电路中的 “非门”、 “与门”、 “或门”，即为命题逻辑的“与”、“或”、“非”三种运算。通过利用这三种门，就可以构造出各种组合逻辑电路。  
![](images/e4f21b269b175874de7115f5156d6a3c1eb9e6666a1338dc9d4727bc0ca3ab30.jpg)
图3-10 基本类型的门  
“与门”和“或门”允许有多个输入，具有 $n$个输入的“与门”和“或门”如图3-11 所示。  
![](images/b8e3cbd2c8e7532c3d5f1acea4bd76306cd188918c6130d6354e264b174b34dc.jpg)
图3-11 具有 $n$ 个输入的门",非门对应命题逻辑中的非运算
命题逻辑,应用,加法器,,"在逻辑电路中，加法器是产生数的和的装置。加数和被加数作为输入，和位与进位作为输出的装置称为半加法器；若加数、被加数与低位的进位数为输入，而和位与进位作为输出则称为全加法器。  
半加法器可以实现两个1 位的二进制数字 $P$ 、$Q$ 相加，并且输出和位 𝑆 和进位 𝐶 。它的真值表如表3-32 所示。  
表3-32 半加法器的输入与输出
![](images/9689097c676031a12dcdfab5a48f08fd719b8383be3b5172b102fc03f27a71e7.jpg)  
根据上表可知，当 $P$ 、 $Q$ 一个为0 一个为1 的时候 $S$为1，两个为0 或两个为1 时 $S$ 为0，故半加法器和位 $S$电路可用异或门连接；进位 $C$ 为1 当且仅当$P$ 、 $Q$均为1，故进位 $C$可用与门连接。由此得到如图3-13 所示半加法器的逻辑电路。  
![](images/8a81f68b8c44145e96e891e90743f2ca9882446c59fc73fdfee13d6f2c5f1b13.jpg)
图3-13 半加法器的电路设计  
全加法器在半加法器基础上增加了进位。全加法器的输入是两个二进制数字 $P$ 、$Q$ 以及进位 $C_{i}$ ，输出是和位 $S$与新的进位 $C_{i+1}$。其真值表如表3-33 所示。  
表3-33 全加法器的输入与输出
![](images/1ea8c2c861e85eb801e288410f57e7cba295768b5bcae6bea64e43846da2ba11.jpg)  
![](images/42947b900b463b9ae2f3888ade392740333e71f1053a92da3ad12ea4d82efdab.jpg)  
全加法器的两个输出和位 $S$ 与新的进位 $C_{i+1}$的逻辑表达式分别为  
$𝑆⇔(𝑃∧𝑄∧𝐶 𝑖 ) ∨(𝑃∧¬𝑄∧¬𝐶 𝑖 ) ∨(¬𝑃∧𝑄∧¬𝐶 𝑖 ) ∨(¬𝑃∧¬𝑄∧𝐶 𝑖 )  $  
$C_{i+1}\Leftrightarrow(P\land Q\land C_{i})\lor(P\land Q\land\lnot C_{i})\lor(P\land\lnot Q\land C_{i})\lor(\lnot P\land Q\land C_{i})$  
可以使用多个半加法器来产生全加法器输出，具体方法如图3-14 所示。  
$$
S=(P\land Q\land C i)\lor(P\land\neg Q\land\neg C i)
$$  
![](images/9df62bca098fc41c520e9ff9d6db19c4f6d68584c0507d0b3d41e80e5d278fa9.jpg)
图3-14 全加法器的电路设计  
图3-15 表示两个三位二进制整数相加的全加法器逻辑电路，一般的$n$二进制整数相加的全加法器逻辑电路与此类似，不再赘述。  
![](images/6c12fab6c51fb1324fd503ee6e6cc64b62965159f5f6a90bb7a62c5a1055cbb6.jpg)
图3-15 三位全加法器电路设计",命题逻辑用于设计和分析加法器的逻辑电路，通过逻辑表达式描述加法器的输入输出关系
命题逻辑,局限性,谓词演算与推理,,"前面我们学习了命题逻辑的基本理论及其应用，可以看出命题逻辑具有一整套非常完备的演算与推理理论体系，并且在数字电路设计与优化等多个领域有着广泛应用。但不可否认的是命题逻辑以命题为基本单位考察命题之间的逻辑关系，不能深入到命题内部从概念这个更加基本的层次上进行逻辑演算与推理。当两个命题之间在概念层次上具有某些共同特征或具有某种逻辑上的联系时，命题逻辑则无法揭示这些特征与联系。这不能不说是逻辑学和数理逻辑理论的重大局限。为此，著名数学家弗雷格在1879 年出版了一部名为《概念文字：一种模仿算术语言构造的纯思维形式语言》的天才著作，提出一整套相对完备的谓词逻辑演算与推理理论， 轰动了整个逻辑学界和数理逻辑学界， 被誉为自亚里士多德以来人类在逻辑 学方面取得的最大进展。弗雷格通过在命题逻辑中引入个体词、谓词、量词与约束变元等概念，在保持命题逻辑知识体系架构基本不变的情况下，将命题层次上的逻辑演算与推理，推进到更为深入复杂的概念层次，使得数理逻辑能够在概念层次上进行更为精细复杂的推演.如果说布尔是初步实现了莱布尼茨梦想，那么弗雷格则是基本上实现了莱布尼茨梦想。  
谓词逻辑能够有效实现对概念的数学表达和逻辑推演，提供了比命题逻辑更加丰富、更加深刻的信息表达与符号计算方法，在数据库与网络通信协议的模型设计、词法分析与代码编译、知识发现与数据挖掘、专家系统的知识表示与推理、自然语言理解与人机交互等多个领域都有着广泛应用，是计算机研发人员必须掌握的基础知识。本章比较系统地介绍谓词演算与推理的基本知识，包括谓词和量词的基本概念与性质、谓词公式与等值演算、谓词公式的范式、谓词逻辑的推理理论与方法等。",命题逻辑在概念层次上的局限性导致其无法深入揭示命题内部的逻辑关系，而谓词演算与推理则能够推进到概念层次进行更精细的推演
谓词逻辑,包含,谓词演算与推理,,"前面我们学习了命题逻辑的基本理论及其应用，可以看出命题逻辑具有一整套非常完备的演算与推理理论体系，并且在数字电路设计与优化等多个领域有着广泛应用。但不可否认的是命题逻辑以命题为基本单位考察命题之间的逻辑关系，不能深入到命题内部从概念这个更加基本的层次上进行逻辑演算与推理。当两个命题之间在概念层次上具有某些共同特征或具有某种逻辑上的联系时，命题逻辑则无法揭示这些特征与联系。这不能不说是逻辑学和数理逻辑理论的重大局限。为此，著名数学家弗雷格在1879 年出版了一部名为《概念文字：一种模仿算术语言构造的纯思维形式语言》的天才著作，提出一整套相对完备的谓词逻辑演算与推理理论， 轰动了整个逻辑学界和数理逻辑学界， 被誉为自亚里士多德以来人类在逻辑 学方面取得的最大进展。弗雷格通过在命题逻辑中引入个体词、谓词、量词与约束变元等概念，在保持命题逻辑知识体系架构基本不变的情况下，将命题层次上的逻辑演算与推理，推进到更为深入复杂的概念层次，使得数理逻辑能够在概念层次上进行更为精细复杂的推演.如果说布尔是初步实现了莱布尼茨梦想，那么弗雷格则是基本上实现了莱布尼茨梦想。  
谓词逻辑能够有效实现对概念的数学表达和逻辑推演，提供了比命题逻辑更加丰富、更加深刻的信息表达与符号计算方法，在数据库与网络通信协议的模型设计、词法分析与代码编译、知识发现与数据挖掘、专家系统的知识表示与推理、自然语言理解与人机交互等多个领域都有着广泛应用，是计算机研发人员必须掌握的基础知识。本章比较系统地介绍谓词演算与推理的基本知识，包括谓词和量词的基本概念与性质、谓词公式与等值演算、谓词公式的范式、谓词逻辑的推理理论与方法等。",谓词逻辑包含谓词演算与推理的理论和方法，提供了比命题逻辑更丰富的信息表达与符号计算方法
命题逻辑,扩展,谓词逻辑,,"前面我们学习了命题逻辑的基本理论及其应用，可以看出命题逻辑具有一整套非常完备的演算与推理理论体系，并且在数字电路设计与优化等多个领域有着广泛应用。但不可否认的是命题逻辑以命题为基本单位考察命题之间的逻辑关系，不能深入到命题内部从概念这个更加基本的层次上进行逻辑演算与推理。当两个命题之间在概念层次上具有某些共同特征或具有某种逻辑上的联系时，命题逻辑则无法揭示这些特征与联系。这不能不说是逻辑学和数理逻辑理论的重大局限。为此，著名数学家弗雷格在1879 年出版了一部名为《概念文字：一种模仿算术语言构造的纯思维形式语言》的天才著作，提出一整套相对完备的谓词逻辑演算与推理理论， 轰动了整个逻辑学界和数理逻辑学界， 被誉为自亚里士多德以来人类在逻辑 学方面取得的最大进展。弗雷格通过在命题逻辑中引入个体词、谓词、量词与约束变元等概念，在保持命题逻辑知识体系架构基本不变的情况下，将命题层次上的逻辑演算与推理，推进到更为深入复杂的概念层次，使得数理逻辑能够在概念层次上进行更为精细复杂的推演.如果说布尔是初步实现了莱布尼茨梦想，那么弗雷格则是基本上实现了莱布尼茨梦想。  
谓词逻辑能够有效实现对概念的数学表达和逻辑推演，提供了比命题逻辑更加丰富、更加深刻的信息表达与符号计算方法，在数据库与网络通信协议的模型设计、词法分析与代码编译、知识发现与数据挖掘、专家系统的知识表示与推理、自然语言理解与人机交互等多个领域都有着广泛应用，是计算机研发人员必须掌握的基础知识。本章比较系统地介绍谓词演算与推理的基本知识，包括谓词和量词的基本概念与性质、谓词公式与等值演算、谓词公式的范式、谓词逻辑的推理理论与方法等。",谓词逻辑在命题逻辑的基础上引入个体词、谓词、量词等概念，扩展了逻辑演算与推理的深度和广度
谓词逻辑,包含,个体词,,谓词逻辑的核心思想是将作为命题的陈述句分解成个体词与谓词这两个更为基本的要素。个体词表示各种具体或抽象的对象，相当于陈述句中的主语或宾语部分；谓词则表示对象的属性或对象之间的联系，相当于陈述句中的谓语部分。不同个体词会使命题产生不同含义以至于形成不同真值，同一个体词使用场合的不同也可能使命题的真值产生变化。为此，谓词逻辑引入量词概念，并通过将其与谓词相结合实现对个体词含义的准确限定。个体词、谓词和量词是谓词逻辑中最核心、最基本的概念，本节通过讨论这三个概念及其性质比较系统地介绍谓词逻辑中最基本的知识，包括谓词逻辑的由来、命题函数与谓词的概念、量词与特性谓词的概念、谓词逻辑的符号化等。,谓词逻辑的核心思想是将陈述句分解成个体词和谓词，个体词是谓词逻辑的基本要素之一。
谓词逻辑,包含,谓词,,谓词逻辑的核心思想是将作为命题的陈述句分解成个体词与谓词这两个更为基本的要素。个体词表示各种具体或抽象的对象，相当于陈述句中的主语或宾语部分；谓词则表示对象的属性或对象之间的联系，相当于陈述句中的谓语部分。不同个体词会使命题产生不同含义以至于形成不同真值，同一个体词使用场合的不同也可能使命题的真值产生变化。为此，谓词逻辑引入量词概念，并通过将其与谓词相结合实现对个体词含义的准确限定。个体词、谓词和量词是谓词逻辑中最核心、最基本的概念，本节通过讨论这三个概念及其性质比较系统地介绍谓词逻辑中最基本的知识，包括谓词逻辑的由来、命题函数与谓词的概念、量词与特性谓词的概念、谓词逻辑的符号化等。,谓词逻辑的核心思想是将陈述句分解成个体词和谓词，谓词是谓词逻辑的基本要素之一。
谓词逻辑,引入,量词,,谓词逻辑的核心思想是将作为命题的陈述句分解成个体词与谓词这两个更为基本的要素。个体词表示各种具体或抽象的对象，相当于陈述句中的主语或宾语部分；谓词则表示对象的属性或对象之间的联系，相当于陈述句中的谓语部分。不同个体词会使命题产生不同含义以至于形成不同真值，同一个体词使用场合的不同也可能使命题的真值产生变化。为此，谓词逻辑引入量词概念，并通过将其与谓词相结合实现对个体词含义的准确限定。个体词、谓词和量词是谓词逻辑中最核心、最基本的概念，本节通过讨论这三个概念及其性质比较系统地介绍谓词逻辑中最基本的知识，包括谓词逻辑的由来、命题函数与谓词的概念、量词与特性谓词的概念、谓词逻辑的符号化等。,谓词逻辑引入量词概念，通过量词与谓词的结合实现对个体词含义的准确限定。
个体词,组合,谓词,,谓词逻辑的核心思想是将作为命题的陈述句分解成个体词与谓词这两个更为基本的要素。个体词表示各种具体或抽象的对象，相当于陈述句中的主语或宾语部分；谓词则表示对象的属性或对象之间的联系，相当于陈述句中的谓语部分。不同个体词会使命题产生不同含义以至于形成不同真值，同一个体词使用场合的不同也可能使命题的真值产生变化。为此，谓词逻辑引入量词概念，并通过将其与谓词相结合实现对个体词含义的准确限定。个体词、谓词和量词是谓词逻辑中最核心、最基本的概念，本节通过讨论这三个概念及其性质比较系统地介绍谓词逻辑中最基本的知识，包括谓词逻辑的由来、命题函数与谓词的概念、量词与特性谓词的概念、谓词逻辑的符号化等。,个体词和谓词共同构成谓词逻辑的基本要素，个体词表示对象，谓词表示属性或联系。
量词,结合,谓词,,谓词逻辑的核心思想是将作为命题的陈述句分解成个体词与谓词这两个更为基本的要素。个体词表示各种具体或抽象的对象，相当于陈述句中的主语或宾语部分；谓词则表示对象的属性或对象之间的联系，相当于陈述句中的谓语部分。不同个体词会使命题产生不同含义以至于形成不同真值，同一个体词使用场合的不同也可能使命题的真值产生变化。为此，谓词逻辑引入量词概念，并通过将其与谓词相结合实现对个体词含义的准确限定。个体词、谓词和量词是谓词逻辑中最核心、最基本的概念，本节通过讨论这三个概念及其性质比较系统地介绍谓词逻辑中最基本的知识，包括谓词逻辑的由来、命题函数与谓词的概念、量词与特性谓词的概念、谓词逻辑的符号化等。,量词与谓词相结合，实现对个体词含义的准确限定。
命题逻辑,无法解决,苏格拉底三段论,,"我们知道，命题是一个具有确切真假含义的陈述句，一般由主语和谓语这两个基本部分组成。例如对于如下命题：  
小张是合肥工业大学学生；小李是合肥工业大学学生。  
小张”、“小李”都是主语，“是合肥工业大学的学生”是谓语。  
从命题逻辑的角度看，上述两个命题都是原子命题，它们之间没有任何联系。但是，事实上这两个命题之间显然有着“是合肥工业大学学生”这一共同特性。由此可知，命题逻辑无法表达这种概念层次上的共同特性。值得注意的是，重的问题，甚至导致无法进行一些非常简单的推理。例如，对于如下苏格拉底三段论：  
所有的人都是要死的；苏格拉底是人；所以，苏格拉底是要死的。  
显然这三个命题之间具有紧密联系，若前两个命题为真，则最后一个命题必为真。用命题逻辑表示这个三段论推理，令$P$，$\mathcal{Q}$，$R$ 分别表示上述三个命题，则有 $P\Lambda Q\Rightarrow R$ 。根据命题逻辑永真蕴含的性质，可知 $P\Lambda Q\to R$ 为永真公式，这显然是不可能的。  
产生这种错误结果的根本原因在于这三个命题之间的逻辑关系并不是体现在命题与命题之间的层次，而是体现在命题内部的概念层次上。命题逻辑以原子命题为基本单元来研究命题的性质和逻辑推演，对于这种命题内部成分之间的联系自然是无能为力的，既不能将前两个命题中关于“人”的共同概念表达出来，也不能将第一个和第三个命题中关于“死”的共同概念表达出来。因此，命题逻辑无法解决苏格拉底三段论推理问题。  
通过以上讨论可以看出，仅在命题层次上研究逻辑推演问题是不够的，必须对原子命题做进一步分解，研究命题在更深层结构上的性质和关系。例如，可将命题“所有的人都是要死的”，分解成“所有的”，“人”和“要死的”这三个部分，分别对其做进一步分析，研究其概念性质、形式结构和逻辑关系，形成有效的推演形式和规则，这正是谓词逻辑的基本内容。事实上，这三个部分分别对应于谓词逻辑中三个最基本的概念，即量词、个体词和谓词，整个谓词逻辑的理论体系基本上由这三个概念衍生而成。",命题逻辑无法解决苏格拉底三段论推理问题，因为它无法表达命题内部的概念层次关系
谓词逻辑,包含,量词,,"我们知道，命题是一个具有确切真假含义的陈述句，一般由主语和谓语这两个基本部分组成。例如对于如下命题：  
小张是合肥工业大学学生；小李是合肥工业大学学生。  
小张”、“小李”都是主语，“是合肥工业大学的学生”是谓语。  
从命题逻辑的角度看，上述两个命题都是原子命题，它们之间没有任何联系。但是，事实上这两个命题之间显然有着“是合肥工业大学学生”这一共同特性。由此可知，命题逻辑无法表达这种概念层次上的共同特性。值得注意的是，重的问题，甚至导致无法进行一些非常简单的推理。例如，对于如下苏格拉底三段论：  
所有的人都是要死的；苏格拉底是人；所以，苏格拉底是要死的。  
显然这三个命题之间具有紧密联系，若前两个命题为真，则最后一个命题必为真。用命题逻辑表示这个三段论推理，令$P$，$\mathcal{Q}$，$R$ 分别表示上述三个命题，则有 $P\Lambda Q\Rightarrow R$ 。根据命题逻辑永真蕴含的性质，可知 $P\Lambda Q\to R$ 为永真公式，这显然是不可能的。  
产生这种错误结果的根本原因在于这三个命题之间的逻辑关系并不是体现在命题与命题之间的层次，而是体现在命题内部的概念层次上。命题逻辑以原子命题为基本单元来研究命题的性质和逻辑推演，对于这种命题内部成分之间的联系自然是无能为力的，既不能将前两个命题中关于“人”的共同概念表达出来，也不能将第一个和第三个命题中关于“死”的共同概念表达出来。因此，命题逻辑无法解决苏格拉底三段论推理问题。  
通过以上讨论可以看出，仅在命题层次上研究逻辑推演问题是不够的，必须对原子命题做进一步分解，研究命题在更深层结构上的性质和关系。例如，可将命题“所有的人都是要死的”，分解成“所有的”，“人”和“要死的”这三个部分，分别对其做进一步分析，研究其概念性质、形式结构和逻辑关系，形成有效的推演形式和规则，这正是谓词逻辑的基本内容。事实上，这三个部分分别对应于谓词逻辑中三个最基本的概念，即量词、个体词和谓词，整个谓词逻辑的理论体系基本上由这三个概念衍生而成。",谓词逻辑包含量词作为其基本概念之一
谓词逻辑,包含,个体词,,"我们知道，命题是一个具有确切真假含义的陈述句，一般由主语和谓语这两个基本部分组成。例如对于如下命题：  
小张是合肥工业大学学生；小李是合肥工业大学学生。  
小张”、“小李”都是主语，“是合肥工业大学的学生”是谓语。  
从命题逻辑的角度看，上述两个命题都是原子命题，它们之间没有任何联系。但是，事实上这两个命题之间显然有着“是合肥工业大学学生”这一共同特性。由此可知，命题逻辑无法表达这种概念层次上的共同特性。值得注意的是，重的问题，甚至导致无法进行一些非常简单的推理。例如，对于如下苏格拉底三段论：  
所有的人都是要死的；苏格拉底是人；所以，苏格拉底是要死的。  
显然这三个命题之间具有紧密联系，若前两个命题为真，则最后一个命题必为真。用命题逻辑表示这个三段论推理，令$P$，$\mathcal{Q}$，$R$ 分别表示上述三个命题，则有 $P\Lambda Q\Rightarrow R$ 。根据命题逻辑永真蕴含的性质，可知 $P\Lambda Q\to R$ 为永真公式，这显然是不可能的。  
产生这种错误结果的根本原因在于这三个命题之间的逻辑关系并不是体现在命题与命题之间的层次，而是体现在命题内部的概念层次上。命题逻辑以原子命题为基本单元来研究命题的性质和逻辑推演，对于这种命题内部成分之间的联系自然是无能为力的，既不能将前两个命题中关于“人”的共同概念表达出来，也不能将第一个和第三个命题中关于“死”的共同概念表达出来。因此，命题逻辑无法解决苏格拉底三段论推理问题。  
通过以上讨论可以看出，仅在命题层次上研究逻辑推演问题是不够的，必须对原子命题做进一步分解，研究命题在更深层结构上的性质和关系。例如，可将命题“所有的人都是要死的”，分解成“所有的”，“人”和“要死的”这三个部分，分别对其做进一步分析，研究其概念性质、形式结构和逻辑关系，形成有效的推演形式和规则，这正是谓词逻辑的基本内容。事实上，这三个部分分别对应于谓词逻辑中三个最基本的概念，即量词、个体词和谓词，整个谓词逻辑的理论体系基本上由这三个概念衍生而成。",谓词逻辑包含个体词作为其基本概念之一
谓词逻辑,包含,谓词,,"我们知道，命题是一个具有确切真假含义的陈述句，一般由主语和谓语这两个基本部分组成。例如对于如下命题：  
小张是合肥工业大学学生；小李是合肥工业大学学生。  
小张”、“小李”都是主语，“是合肥工业大学的学生”是谓语。  
从命题逻辑的角度看，上述两个命题都是原子命题，它们之间没有任何联系。但是，事实上这两个命题之间显然有着“是合肥工业大学学生”这一共同特性。由此可知，命题逻辑无法表达这种概念层次上的共同特性。值得注意的是，重的问题，甚至导致无法进行一些非常简单的推理。例如，对于如下苏格拉底三段论：  
所有的人都是要死的；苏格拉底是人；所以，苏格拉底是要死的。  
显然这三个命题之间具有紧密联系，若前两个命题为真，则最后一个命题必为真。用命题逻辑表示这个三段论推理，令$P$，$\mathcal{Q}$，$R$ 分别表示上述三个命题，则有 $P\Lambda Q\Rightarrow R$ 。根据命题逻辑永真蕴含的性质，可知 $P\Lambda Q\to R$ 为永真公式，这显然是不可能的。  
产生这种错误结果的根本原因在于这三个命题之间的逻辑关系并不是体现在命题与命题之间的层次，而是体现在命题内部的概念层次上。命题逻辑以原子命题为基本单元来研究命题的性质和逻辑推演，对于这种命题内部成分之间的联系自然是无能为力的，既不能将前两个命题中关于“人”的共同概念表达出来，也不能将第一个和第三个命题中关于“死”的共同概念表达出来。因此，命题逻辑无法解决苏格拉底三段论推理问题。  
通过以上讨论可以看出，仅在命题层次上研究逻辑推演问题是不够的，必须对原子命题做进一步分解，研究命题在更深层结构上的性质和关系。例如，可将命题“所有的人都是要死的”，分解成“所有的”，“人”和“要死的”这三个部分，分别对其做进一步分析，研究其概念性质、形式结构和逻辑关系，形成有效的推演形式和规则，这正是谓词逻辑的基本内容。事实上，这三个部分分别对应于谓词逻辑中三个最基本的概念，即量词、个体词和谓词，整个谓词逻辑的理论体系基本上由这三个概念衍生而成。",谓词逻辑包含谓词作为其基本概念之一
谓词逻辑,补充,命题逻辑,,"我们知道，命题是一个具有确切真假含义的陈述句，一般由主语和谓语这两个基本部分组成。例如对于如下命题：  
小张是合肥工业大学学生；小李是合肥工业大学学生。  
小张”、“小李”都是主语，“是合肥工业大学的学生”是谓语。  
从命题逻辑的角度看，上述两个命题都是原子命题，它们之间没有任何联系。但是，事实上这两个命题之间显然有着“是合肥工业大学学生”这一共同特性。由此可知，命题逻辑无法表达这种概念层次上的共同特性。值得注意的是，重的问题，甚至导致无法进行一些非常简单的推理。例如，对于如下苏格拉底三段论：  
所有的人都是要死的；苏格拉底是人；所以，苏格拉底是要死的。  
显然这三个命题之间具有紧密联系，若前两个命题为真，则最后一个命题必为真。用命题逻辑表示这个三段论推理，令$P$，$\mathcal{Q}$，$R$ 分别表示上述三个命题，则有 $P\Lambda Q\Rightarrow R$ 。根据命题逻辑永真蕴含的性质，可知 $P\Lambda Q\to R$ 为永真公式，这显然是不可能的。  
产生这种错误结果的根本原因在于这三个命题之间的逻辑关系并不是体现在命题与命题之间的层次，而是体现在命题内部的概念层次上。命题逻辑以原子命题为基本单元来研究命题的性质和逻辑推演，对于这种命题内部成分之间的联系自然是无能为力的，既不能将前两个命题中关于“人”的共同概念表达出来，也不能将第一个和第三个命题中关于“死”的共同概念表达出来。因此，命题逻辑无法解决苏格拉底三段论推理问题。  
通过以上讨论可以看出，仅在命题层次上研究逻辑推演问题是不够的，必须对原子命题做进一步分解，研究命题在更深层结构上的性质和关系。例如，可将命题“所有的人都是要死的”，分解成“所有的”，“人”和“要死的”这三个部分，分别对其做进一步分析，研究其概念性质、形式结构和逻辑关系，形成有效的推演形式和规则，这正是谓词逻辑的基本内容。事实上，这三个部分分别对应于谓词逻辑中三个最基本的概念，即量词、个体词和谓词，整个谓词逻辑的理论体系基本上由这三个概念衍生而成。",谓词逻辑补充了命题逻辑在表达命题内部概念层次关系上的不足
谓词逻辑,形成,命题函数,,谓词逻辑通过对原子命题中的主语和宾语指代对象进行抽象和泛化，形成一种含有变量的语句来表示一类命题，并随着变量的不同指派得到各自相应的具体命题，因而可将这种有变量的语句看成是一种命题函数。在这个抽象过程中，原子命题中的谓语部分则不做任何抽象或改变而直接继承到命题函数之中，并称其为谓词。在命题函数中，谓词刻画了变量的性质和变量之间的联系，反映了命题函数的本质内涵并构成命题函数的主体内容。事实上，也可以进一步对命题中的谓语部分进行抽象形成谓词变量，但是这种更高层次的抽象已经超出了我们的讨论范畴，不再赘述。,谓词逻辑通过抽象和泛化形成命题函数
命题函数,包含,谓词,,谓词逻辑通过对原子命题中的主语和宾语指代对象进行抽象和泛化，形成一种含有变量的语句来表示一类命题，并随着变量的不同指派得到各自相应的具体命题，因而可将这种有变量的语句看成是一种命题函数。在这个抽象过程中，原子命题中的谓语部分则不做任何抽象或改变而直接继承到命题函数之中，并称其为谓词。在命题函数中，谓词刻画了变量的性质和变量之间的联系，反映了命题函数的本质内涵并构成命题函数的主体内容。事实上，也可以进一步对命题中的谓语部分进行抽象形成谓词变量，但是这种更高层次的抽象已经超出了我们的讨论范畴，不再赘述。,命题函数包含谓词，谓词刻画变量的性质和联系
个体词,表示,命题函数,,"对于“小张是大学生”这个原子命题，可将其主语“小张”进行抽象，得到如下语句：  
某某是大学生  
上述语句表示的不是一个具体的命题，因为其主语“某某”的指代是不确定的，语句真值会随着“某某”的不同指代而有所不同。事实上，该语句表示的是一类命题，每给“某某”一个确定的取值，就会得到一个具有确定真值的具体命题，例如“小张是大学生”、 “小李是大学生”等。因此，可将“某某是大学生”看成是一种含变量的语句。  
令$x$ 表示“某某”，则可将上述含变量的语句表示为：$x$是大学生”。若再令$P$ 表示谓语部分“是大学生”，则可将其表示为$P(x)$，即：$P(x)$：$x$ 是大学生。事实上，在数学计算、计算机程序等领域存在大量类似于这种含变量的语句，例如：  
“$x>5$”、“$x+y=10$”、“$x+y<z$”  
对于这些含有变量的语句，当句中变量没有给定具体取值时，语句的真值是不确定的因而不是命题。只有当这些语句中所有变量均获得具体赋值时，它们才变成具有确定真值的命题。因此，可将这些含有变量的语句看成是以这些变量为自变量的命题函数。下面给出命题函数及其相关概念定义与性质。",个体词作为命题函数的自变量，用于表示具体的命题
谓词,构成,命题函数,,"对于“小张是大学生”这个原子命题，可将其主语“小张”进行抽象，得到如下语句：  
某某是大学生  
上述语句表示的不是一个具体的命题，因为其主语“某某”的指代是不确定的，语句真值会随着“某某”的不同指代而有所不同。事实上，该语句表示的是一类命题，每给“某某”一个确定的取值，就会得到一个具有确定真值的具体命题，例如“小张是大学生”、 “小李是大学生”等。因此，可将“某某是大学生”看成是一种含变量的语句。  
令$x$ 表示“某某”，则可将上述含变量的语句表示为：$x$是大学生”。若再令$P$ 表示谓语部分“是大学生”，则可将其表示为$P(x)$，即：$P(x)$：$x$ 是大学生。事实上，在数学计算、计算机程序等领域存在大量类似于这种含变量的语句，例如：  
“$x>5$”、“$x+y=10$”、“$x+y<z$”  
对于这些含有变量的语句，当句中变量没有给定具体取值时，语句的真值是不确定的因而不是命题。只有当这些语句中所有变量均获得具体赋值时，它们才变成具有确定真值的命题。因此，可将这些含有变量的语句看成是以这些变量为自变量的命题函数。下面给出命题函数及其相关概念定义与性质。",谓词与个体词结合构成命题函数，表示含变量的语句
命题函数,基础,谓词演算,,"对于“小张是大学生”这个原子命题，可将其主语“小张”进行抽象，得到如下语句：  
某某是大学生  
上述语句表示的不是一个具体的命题，因为其主语“某某”的指代是不确定的，语句真值会随着“某某”的不同指代而有所不同。事实上，该语句表示的是一类命题，每给“某某”一个确定的取值，就会得到一个具有确定真值的具体命题，例如“小张是大学生”、 “小李是大学生”等。因此，可将“某某是大学生”看成是一种含变量的语句。  
令$x$ 表示“某某”，则可将上述含变量的语句表示为：$x$是大学生”。若再令$P$ 表示谓语部分“是大学生”，则可将其表示为$P(x)$，即：$P(x)$：$x$ 是大学生。事实上，在数学计算、计算机程序等领域存在大量类似于这种含变量的语句，例如：  
“$x>5$”、“$x+y=10$”、“$x+y<z$”  
对于这些含有变量的语句，当句中变量没有给定具体取值时，语句的真值是不确定的因而不是命题。只有当这些语句中所有变量均获得具体赋值时，它们才变成具有确定真值的命题。因此，可将这些含有变量的语句看成是以这些变量为自变量的命题函数。下面给出命题函数及其相关概念定义与性质。",命题函数是谓词演算的基础组成部分，用于表达含变量的命题
个体常量,抽象关系,个体变量,,"对于任一给定的原子命题，其主语或宾语是一种可以独立存在的确定对象，我们称之为个体常量，将个体常量抽象成含义不确定的变量后，则称之为个体变量。相关定义如下：  
【定义4.1】客观世界中可以独立存在的具体或抽象对象称为个体，表示个体的词称为个体词。若个体词以常量的方式表示特定个体，则称之为个体常量；若个体词以变量的方式泛指不确定的个体，则称之为个体变量。  
例如，前述原子命题“小张是大学生”中的个体为“小张”。再如，命题“电子计算机是科学技术的工具”中的个体为“电子计算机”；命题“张三比李四高”中的个体为：“张三”、“李四”.可用个体常量表示这些确定的个体。  
对于个体常量，通常用带下标或不带下标的英文字母$a$，$b$，$c$，…表示。例如，可用$a$和$b$ 分别表示前述个体“小张”和“电子计算机”。  
对于前述含变量的语句“$x$是大学生”、“$x>5$”、“$x+y=10$”、“$x+y<z$”，其中的x，y，$z$均表示泛指的不确定个体，因而它们都是个体变量。  
对于个体变量，通常用带下标或不带下标的英文字母$x$，y，$z$，…表示。  
个体变量的取值应有一个明确范围，故有如下个体域的概念：  
【定义4.2】个体变量的取值范围称为个体域或论域。宇宙间所有的个体域聚集在一起构成的个体域，称为全总个体域。  
个体变量的个体域可根据问题的实际状况或需要来确定。例如，对于含变量语句“$\cdot_{x}$ 是大学生”，其中个体变量$x$ 的变化范围，可以确定为全体人类，也可以确定为某单位的全体职工，还可以确定为某个大学的全班同学或者某个中学的全班同学，等等。显然，个体变量的个体域的不同，其相应含变量语句的含义也会有所不同。  
现在个体变量与个体域概念基础上，给出命题函数的定义：  
【定义4.3】设$x_{1},x_{2},\cdots x_{n}$为$n$个个体变量，其个体域均为非空集合$D$，则定义在$D^{n}$上取值于$\{0,1\}$的$n$元函数称为$^n$元简单命题函数，记为$P(x_{1},x_{2},\cdots x_{n})$。  
例如，前述表示“$x$ 是大学生”的式子”$P(x)$“，以及“$x>5$”、“$x+y=10$”、“$x+y<z$”，都是简单命题函数。其中”$P(x)$“和“$x>5$”为一元简单命题函数，“$x+y=10$”和“$x+y<z$”分别是二元和三元简单命题函数。  
如同原子命题可以通过联结词进行逻辑演算得到复合命题一样，简单命题函数也可通过联结词的逻辑演算，得到一种更为复杂的表达式，即复合命题函数。其具体定义如下：  
【定义4.4】简单命题函数通过“$\neg$”、“$\land$”、“$\lor$”、“$\rightarrow$”、“$\leftrightarrow$”等联结词进行逻辑演算得到的逻辑表达式，称为复合命题函数。  
例如，对于如下给定的简单命题函数：  
${A(x)\colon x\text{身体好};B(x)\colon x\text{学习好};C(x)\colon x\text{工作好}}$  
复合命题函数：  
$$
\neg A(x)\to(\neg B(x)\land\neg C(x))
$$  
表示如果$x$身体不好，那么学习和工作都不会好。",个体常量抽象成含义不确定的变量后，称为个体变量
个体词,表示关系,个体常量,,"对于任一给定的原子命题，其主语或宾语是一种可以独立存在的确定对象，我们称之为个体常量，将个体常量抽象成含义不确定的变量后，则称之为个体变量。相关定义如下：  
【定义4.1】客观世界中可以独立存在的具体或抽象对象称为个体，表示个体的词称为个体词。若个体词以常量的方式表示特定个体，则称之为个体常量；若个体词以变量的方式泛指不确定的个体，则称之为个体变量。  
例如，前述原子命题“小张是大学生”中的个体为“小张”。再如，命题“电子计算机是科学技术的工具”中的个体为“电子计算机”；命题“张三比李四高”中的个体为：“张三”、“李四”.可用个体常量表示这些确定的个体。  
对于个体常量，通常用带下标或不带下标的英文字母$a$，$b$，$c$，…表示。例如，可用$a$和$b$ 分别表示前述个体“小张”和“电子计算机”。  
对于前述含变量的语句“$x$是大学生”、“$x>5$”、“$x+y=10$”、“$x+y<z$”，其中的x，y，$z$均表示泛指的不确定个体，因而它们都是个体变量。  
对于个体变量，通常用带下标或不带下标的英文字母$x$，y，$z$，…表示。  
个体变量的取值应有一个明确范围，故有如下个体域的概念：  
【定义4.2】个体变量的取值范围称为个体域或论域。宇宙间所有的个体域聚集在一起构成的个体域，称为全总个体域。  
个体变量的个体域可根据问题的实际状况或需要来确定。例如，对于含变量语句“$\cdot_{x}$ 是大学生”，其中个体变量$x$ 的变化范围，可以确定为全体人类，也可以确定为某单位的全体职工，还可以确定为某个大学的全班同学或者某个中学的全班同学，等等。显然，个体变量的个体域的不同，其相应含变量语句的含义也会有所不同。  
现在个体变量与个体域概念基础上，给出命题函数的定义：  
【定义4.3】设$x_{1},x_{2},\cdots x_{n}$为$n$个个体变量，其个体域均为非空集合$D$，则定义在$D^{n}$上取值于$\{0,1\}$的$n$元函数称为$^n$元简单命题函数，记为$P(x_{1},x_{2},\cdots x_{n})$。  
例如，前述表示“$x$ 是大学生”的式子”$P(x)$“，以及“$x>5$”、“$x+y=10$”、“$x+y<z$”，都是简单命题函数。其中”$P(x)$“和“$x>5$”为一元简单命题函数，“$x+y=10$”和“$x+y<z$”分别是二元和三元简单命题函数。  
如同原子命题可以通过联结词进行逻辑演算得到复合命题一样，简单命题函数也可通过联结词的逻辑演算，得到一种更为复杂的表达式，即复合命题函数。其具体定义如下：  
【定义4.4】简单命题函数通过“$\neg$”、“$\land$”、“$\lor$”、“$\rightarrow$”、“$\leftrightarrow$”等联结词进行逻辑演算得到的逻辑表达式，称为复合命题函数。  
例如，对于如下给定的简单命题函数：  
${A(x)\colon x\text{身体好};B(x)\colon x\text{学习好};C(x)\colon x\text{工作好}}$  
复合命题函数：  
$$
\neg A(x)\to(\neg B(x)\land\neg C(x))
$$  
表示如果$x$身体不好，那么学习和工作都不会好。",个体词以常量的方式表示特定个体，称为个体常量
个体词,表示关系,个体变量,,"对于任一给定的原子命题，其主语或宾语是一种可以独立存在的确定对象，我们称之为个体常量，将个体常量抽象成含义不确定的变量后，则称之为个体变量。相关定义如下：  
【定义4.1】客观世界中可以独立存在的具体或抽象对象称为个体，表示个体的词称为个体词。若个体词以常量的方式表示特定个体，则称之为个体常量；若个体词以变量的方式泛指不确定的个体，则称之为个体变量。  
例如，前述原子命题“小张是大学生”中的个体为“小张”。再如，命题“电子计算机是科学技术的工具”中的个体为“电子计算机”；命题“张三比李四高”中的个体为：“张三”、“李四”.可用个体常量表示这些确定的个体。  
对于个体常量，通常用带下标或不带下标的英文字母$a$，$b$，$c$，…表示。例如，可用$a$和$b$ 分别表示前述个体“小张”和“电子计算机”。  
对于前述含变量的语句“$x$是大学生”、“$x>5$”、“$x+y=10$”、“$x+y<z$”，其中的x，y，$z$均表示泛指的不确定个体，因而它们都是个体变量。  
对于个体变量，通常用带下标或不带下标的英文字母$x$，y，$z$，…表示。  
个体变量的取值应有一个明确范围，故有如下个体域的概念：  
【定义4.2】个体变量的取值范围称为个体域或论域。宇宙间所有的个体域聚集在一起构成的个体域，称为全总个体域。  
个体变量的个体域可根据问题的实际状况或需要来确定。例如，对于含变量语句“$\cdot_{x}$ 是大学生”，其中个体变量$x$ 的变化范围，可以确定为全体人类，也可以确定为某单位的全体职工，还可以确定为某个大学的全班同学或者某个中学的全班同学，等等。显然，个体变量的个体域的不同，其相应含变量语句的含义也会有所不同。  
现在个体变量与个体域概念基础上，给出命题函数的定义：  
【定义4.3】设$x_{1},x_{2},\cdots x_{n}$为$n$个个体变量，其个体域均为非空集合$D$，则定义在$D^{n}$上取值于$\{0,1\}$的$n$元函数称为$^n$元简单命题函数，记为$P(x_{1},x_{2},\cdots x_{n})$。  
例如，前述表示“$x$ 是大学生”的式子”$P(x)$“，以及“$x>5$”、“$x+y=10$”、“$x+y<z$”，都是简单命题函数。其中”$P(x)$“和“$x>5$”为一元简单命题函数，“$x+y=10$”和“$x+y<z$”分别是二元和三元简单命题函数。  
如同原子命题可以通过联结词进行逻辑演算得到复合命题一样，简单命题函数也可通过联结词的逻辑演算，得到一种更为复杂的表达式，即复合命题函数。其具体定义如下：  
【定义4.4】简单命题函数通过“$\neg$”、“$\land$”、“$\lor$”、“$\rightarrow$”、“$\leftrightarrow$”等联结词进行逻辑演算得到的逻辑表达式，称为复合命题函数。  
例如，对于如下给定的简单命题函数：  
${A(x)\colon x\text{身体好};B(x)\colon x\text{学习好};C(x)\colon x\text{工作好}}$  
复合命题函数：  
$$
\neg A(x)\to(\neg B(x)\land\neg C(x))
$$  
表示如果$x$身体不好，那么学习和工作都不会好。",个体词以变量的方式泛指不确定的个体，称为个体变量
个体变量,取值范围关系,个体域,,"对于任一给定的原子命题，其主语或宾语是一种可以独立存在的确定对象，我们称之为个体常量，将个体常量抽象成含义不确定的变量后，则称之为个体变量。相关定义如下：  
【定义4.1】客观世界中可以独立存在的具体或抽象对象称为个体，表示个体的词称为个体词。若个体词以常量的方式表示特定个体，则称之为个体常量；若个体词以变量的方式泛指不确定的个体，则称之为个体变量。  
例如，前述原子命题“小张是大学生”中的个体为“小张”。再如，命题“电子计算机是科学技术的工具”中的个体为“电子计算机”；命题“张三比李四高”中的个体为：“张三”、“李四”.可用个体常量表示这些确定的个体。  
对于个体常量，通常用带下标或不带下标的英文字母$a$，$b$，$c$，…表示。例如，可用$a$和$b$ 分别表示前述个体“小张”和“电子计算机”。  
对于前述含变量的语句“$x$是大学生”、“$x>5$”、“$x+y=10$”、“$x+y<z$”，其中的x，y，$z$均表示泛指的不确定个体，因而它们都是个体变量。  
对于个体变量，通常用带下标或不带下标的英文字母$x$，y，$z$，…表示。  
个体变量的取值应有一个明确范围，故有如下个体域的概念：  
【定义4.2】个体变量的取值范围称为个体域或论域。宇宙间所有的个体域聚集在一起构成的个体域，称为全总个体域。  
个体变量的个体域可根据问题的实际状况或需要来确定。例如，对于含变量语句“$\cdot_{x}$ 是大学生”，其中个体变量$x$ 的变化范围，可以确定为全体人类，也可以确定为某单位的全体职工，还可以确定为某个大学的全班同学或者某个中学的全班同学，等等。显然，个体变量的个体域的不同，其相应含变量语句的含义也会有所不同。  
现在个体变量与个体域概念基础上，给出命题函数的定义：  
【定义4.3】设$x_{1},x_{2},\cdots x_{n}$为$n$个个体变量，其个体域均为非空集合$D$，则定义在$D^{n}$上取值于$\{0,1\}$的$n$元函数称为$^n$元简单命题函数，记为$P(x_{1},x_{2},\cdots x_{n})$。  
例如，前述表示“$x$ 是大学生”的式子”$P(x)$“，以及“$x>5$”、“$x+y=10$”、“$x+y<z$”，都是简单命题函数。其中”$P(x)$“和“$x>5$”为一元简单命题函数，“$x+y=10$”和“$x+y<z$”分别是二元和三元简单命题函数。  
如同原子命题可以通过联结词进行逻辑演算得到复合命题一样，简单命题函数也可通过联结词的逻辑演算，得到一种更为复杂的表达式，即复合命题函数。其具体定义如下：  
【定义4.4】简单命题函数通过“$\neg$”、“$\land$”、“$\lor$”、“$\rightarrow$”、“$\leftrightarrow$”等联结词进行逻辑演算得到的逻辑表达式，称为复合命题函数。  
例如，对于如下给定的简单命题函数：  
${A(x)\colon x\text{身体好};B(x)\colon x\text{学习好};C(x)\colon x\text{工作好}}$  
复合命题函数：  
$$
\neg A(x)\to(\neg B(x)\land\neg C(x))
$$  
表示如果$x$身体不好，那么学习和工作都不会好。",个体变量的取值范围称为个体域
简单命题函数,定义关系,个体变量,,"对于任一给定的原子命题，其主语或宾语是一种可以独立存在的确定对象，我们称之为个体常量，将个体常量抽象成含义不确定的变量后，则称之为个体变量。相关定义如下：  
【定义4.1】客观世界中可以独立存在的具体或抽象对象称为个体，表示个体的词称为个体词。若个体词以常量的方式表示特定个体，则称之为个体常量；若个体词以变量的方式泛指不确定的个体，则称之为个体变量。  
例如，前述原子命题“小张是大学生”中的个体为“小张”。再如，命题“电子计算机是科学技术的工具”中的个体为“电子计算机”；命题“张三比李四高”中的个体为：“张三”、“李四”.可用个体常量表示这些确定的个体。  
对于个体常量，通常用带下标或不带下标的英文字母$a$，$b$，$c$，…表示。例如，可用$a$和$b$ 分别表示前述个体“小张”和“电子计算机”。  
对于前述含变量的语句“$x$是大学生”、“$x>5$”、“$x+y=10$”、“$x+y<z$”，其中的x，y，$z$均表示泛指的不确定个体，因而它们都是个体变量。  
对于个体变量，通常用带下标或不带下标的英文字母$x$，y，$z$，…表示。  
个体变量的取值应有一个明确范围，故有如下个体域的概念：  
【定义4.2】个体变量的取值范围称为个体域或论域。宇宙间所有的个体域聚集在一起构成的个体域，称为全总个体域。  
个体变量的个体域可根据问题的实际状况或需要来确定。例如，对于含变量语句“$\cdot_{x}$ 是大学生”，其中个体变量$x$ 的变化范围，可以确定为全体人类，也可以确定为某单位的全体职工，还可以确定为某个大学的全班同学或者某个中学的全班同学，等等。显然，个体变量的个体域的不同，其相应含变量语句的含义也会有所不同。  
现在个体变量与个体域概念基础上，给出命题函数的定义：  
【定义4.3】设$x_{1},x_{2},\cdots x_{n}$为$n$个个体变量，其个体域均为非空集合$D$，则定义在$D^{n}$上取值于$\{0,1\}$的$n$元函数称为$^n$元简单命题函数，记为$P(x_{1},x_{2},\cdots x_{n})$。  
例如，前述表示“$x$ 是大学生”的式子”$P(x)$“，以及“$x>5$”、“$x+y=10$”、“$x+y<z$”，都是简单命题函数。其中”$P(x)$“和“$x>5$”为一元简单命题函数，“$x+y=10$”和“$x+y<z$”分别是二元和三元简单命题函数。  
如同原子命题可以通过联结词进行逻辑演算得到复合命题一样，简单命题函数也可通过联结词的逻辑演算，得到一种更为复杂的表达式，即复合命题函数。其具体定义如下：  
【定义4.4】简单命题函数通过“$\neg$”、“$\land$”、“$\lor$”、“$\rightarrow$”、“$\leftrightarrow$”等联结词进行逻辑演算得到的逻辑表达式，称为复合命题函数。  
例如，对于如下给定的简单命题函数：  
${A(x)\colon x\text{身体好};B(x)\colon x\text{学习好};C(x)\colon x\text{工作好}}$  
复合命题函数：  
$$
\neg A(x)\to(\neg B(x)\land\neg C(x))
$$  
表示如果$x$身体不好，那么学习和工作都不会好。",简单命题函数是定义在个体变量上的n元函数
复合命题函数,演算关系,简单命题函数,,"对于任一给定的原子命题，其主语或宾语是一种可以独立存在的确定对象，我们称之为个体常量，将个体常量抽象成含义不确定的变量后，则称之为个体变量。相关定义如下：  
【定义4.1】客观世界中可以独立存在的具体或抽象对象称为个体，表示个体的词称为个体词。若个体词以常量的方式表示特定个体，则称之为个体常量；若个体词以变量的方式泛指不确定的个体，则称之为个体变量。  
例如，前述原子命题“小张是大学生”中的个体为“小张”。再如，命题“电子计算机是科学技术的工具”中的个体为“电子计算机”；命题“张三比李四高”中的个体为：“张三”、“李四”.可用个体常量表示这些确定的个体。  
对于个体常量，通常用带下标或不带下标的英文字母$a$，$b$，$c$，…表示。例如，可用$a$和$b$ 分别表示前述个体“小张”和“电子计算机”。  
对于前述含变量的语句“$x$是大学生”、“$x>5$”、“$x+y=10$”、“$x+y<z$”，其中的x，y，$z$均表示泛指的不确定个体，因而它们都是个体变量。  
对于个体变量，通常用带下标或不带下标的英文字母$x$，y，$z$，…表示。  
个体变量的取值应有一个明确范围，故有如下个体域的概念：  
【定义4.2】个体变量的取值范围称为个体域或论域。宇宙间所有的个体域聚集在一起构成的个体域，称为全总个体域。  
个体变量的个体域可根据问题的实际状况或需要来确定。例如，对于含变量语句“$\cdot_{x}$ 是大学生”，其中个体变量$x$ 的变化范围，可以确定为全体人类，也可以确定为某单位的全体职工，还可以确定为某个大学的全班同学或者某个中学的全班同学，等等。显然，个体变量的个体域的不同，其相应含变量语句的含义也会有所不同。  
现在个体变量与个体域概念基础上，给出命题函数的定义：  
【定义4.3】设$x_{1},x_{2},\cdots x_{n}$为$n$个个体变量，其个体域均为非空集合$D$，则定义在$D^{n}$上取值于$\{0,1\}$的$n$元函数称为$^n$元简单命题函数，记为$P(x_{1},x_{2},\cdots x_{n})$。  
例如，前述表示“$x$ 是大学生”的式子”$P(x)$“，以及“$x>5$”、“$x+y=10$”、“$x+y<z$”，都是简单命题函数。其中”$P(x)$“和“$x>5$”为一元简单命题函数，“$x+y=10$”和“$x+y<z$”分别是二元和三元简单命题函数。  
如同原子命题可以通过联结词进行逻辑演算得到复合命题一样，简单命题函数也可通过联结词的逻辑演算，得到一种更为复杂的表达式，即复合命题函数。其具体定义如下：  
【定义4.4】简单命题函数通过“$\neg$”、“$\land$”、“$\lor$”、“$\rightarrow$”、“$\leftrightarrow$”等联结词进行逻辑演算得到的逻辑表达式，称为复合命题函数。  
例如，对于如下给定的简单命题函数：  
${A(x)\colon x\text{身体好};B(x)\colon x\text{学习好};C(x)\colon x\text{工作好}}$  
复合命题函数：  
$$
\neg A(x)\to(\neg B(x)\land\neg C(x))
$$  
表示如果$x$身体不好，那么学习和工作都不会好。",简单命题函数通过联结词进行逻辑演算得到复合命题函数
谓词,构成,命题函数,,"从结构上看，简单命题函数主要通过将原子命题中的个体常量泛化为个体变量的方式实现对命题结构的分解和对命题含义的抽象。在这个分解与抽象过程中，原子命题中表示个体性质与联系的谓语部分则不做任何抽象和改变而直接继承下来成为命题函数的函数名，并称之为谓词。谓词是简单命题函数中具有实质性含义的部分，刻画了命题函数中个体变量的性质与联系，构成了简单命题函数的主体。从本质上看，含有变元的简单命题函数其实就是含有变元的谓词。因此，通常将$_{\cdot n}$元简单命题函数称为$^n$元谓词。具体定义如下：  
【定义4.5】对于$\cdot n$元简单命题函数$P(x_{1},x_{2},\cdots x_{n})$，将其中的函数名$P$ 称为谓词，将$n$元简单命题函数$P(x_{1},x_{2},\cdots x_{n})$称为$n$元谓词。  
单纯的个体词或单纯的谓词都无法完成一个完整的逻辑含义，只有将它们结合起来才能构成完整独立的逻辑断言。因此，除非特别说明，通常情况下我们所说的谓词指的就是含有个体变元的谓词，即$n$元谓词。  
通过以上例题可以看出$n$元谓词主要用来描述个体的性质或者个体之间的联系。当$n=$1时，谓词描述的是个体的性质；当$n>1$时，谓词描述的是个体之间的联系。  
$n$元谓词$P(x_{1},x_{2},\cdots x_{n})$是表示含有$\cdot_{n}$个个体变量的语句。变量对个体指定的不确定性使得语句无法确定具体的真值，因而不是命题。当这些变量$x_{1},x_{2},\cdots x_{n}$均得到具体赋值或通过其它方式受到约束而获得明确具体的含义时，$P(x_{1},x_{2},\cdots x_{n})$就表示一个具体命题。  
例如，令一元谓词$P(x)$表示“$\cdot_{x}$ 是大学生”，则$P($小张)就是一个具体命题：小张是大学生。同样，$P($小李)也表示一个具体命题：小李是大学生。  
给$n$元谓词的个体变量赋值是一种最简单的约束方式，由此得到谓词填式的概念：  
【定义4.6】对于$\cdot n$元谓词$P(x_{1},x_{2},\cdots x_{n})$，若将其中每个个体变量$\cdot x_{1},x_{2},\cdots x_{n}$分别指定具体的个体，由此得到的命题$P(a_{1},a,\cdots a_{n})$，称为谓词填式，也称为命题的谓词式。  
谓词填式具有谓词的形式结构但不再含有个体变量，可以看成是零元谓词，是具体命题的谓词表示形式。例如：$P($小张)就是一个0 元谓词。因此，命题其实就是一种特殊的零元谓词，谓词逻辑是命题逻辑的一种自然推广。",谓词是命题函数的函数名，刻画了命题函数中个体变量的性质与联系
n元谓词,等价,命题函数,,"从结构上看，简单命题函数主要通过将原子命题中的个体常量泛化为个体变量的方式实现对命题结构的分解和对命题含义的抽象。在这个分解与抽象过程中，原子命题中表示个体性质与联系的谓语部分则不做任何抽象和改变而直接继承下来成为命题函数的函数名，并称之为谓词。谓词是简单命题函数中具有实质性含义的部分，刻画了命题函数中个体变量的性质与联系，构成了简单命题函数的主体。从本质上看，含有变元的简单命题函数其实就是含有变元的谓词。因此，通常将$_{\cdot n}$元简单命题函数称为$^n$元谓词。具体定义如下：  
【定义4.5】对于$\cdot n$元简单命题函数$P(x_{1},x_{2},\cdots x_{n})$，将其中的函数名$P$ 称为谓词，将$n$元简单命题函数$P(x_{1},x_{2},\cdots x_{n})$称为$n$元谓词。  
单纯的个体词或单纯的谓词都无法完成一个完整的逻辑含义，只有将它们结合起来才能构成完整独立的逻辑断言。因此，除非特别说明，通常情况下我们所说的谓词指的就是含有个体变元的谓词，即$n$元谓词。  
通过以上例题可以看出$n$元谓词主要用来描述个体的性质或者个体之间的联系。当$n=$1时，谓词描述的是个体的性质；当$n>1$时，谓词描述的是个体之间的联系。  
$n$元谓词$P(x_{1},x_{2},\cdots x_{n})$是表示含有$\cdot_{n}$个个体变量的语句。变量对个体指定的不确定性使得语句无法确定具体的真值，因而不是命题。当这些变量$x_{1},x_{2},\cdots x_{n}$均得到具体赋值或通过其它方式受到约束而获得明确具体的含义时，$P(x_{1},x_{2},\cdots x_{n})$就表示一个具体命题。  
例如，令一元谓词$P(x)$表示“$\cdot_{x}$ 是大学生”，则$P($小张)就是一个具体命题：小张是大学生。同样，$P($小李)也表示一个具体命题：小李是大学生。  
给$n$元谓词的个体变量赋值是一种最简单的约束方式，由此得到谓词填式的概念：  
【定义4.6】对于$\cdot n$元谓词$P(x_{1},x_{2},\cdots x_{n})$，若将其中每个个体变量$\cdot x_{1},x_{2},\cdots x_{n}$分别指定具体的个体，由此得到的命题$P(a_{1},a,\cdots a_{n})$，称为谓词填式，也称为命题的谓词式。  
谓词填式具有谓词的形式结构但不再含有个体变量，可以看成是零元谓词，是具体命题的谓词表示形式。例如：$P($小张)就是一个0 元谓词。因此，命题其实就是一种特殊的零元谓词，谓词逻辑是命题逻辑的一种自然推广。",含有变元的简单命题函数即为n元谓词
谓词填式,派生,n元谓词,,"从结构上看，简单命题函数主要通过将原子命题中的个体常量泛化为个体变量的方式实现对命题结构的分解和对命题含义的抽象。在这个分解与抽象过程中，原子命题中表示个体性质与联系的谓语部分则不做任何抽象和改变而直接继承下来成为命题函数的函数名，并称之为谓词。谓词是简单命题函数中具有实质性含义的部分，刻画了命题函数中个体变量的性质与联系，构成了简单命题函数的主体。从本质上看，含有变元的简单命题函数其实就是含有变元的谓词。因此，通常将$_{\cdot n}$元简单命题函数称为$^n$元谓词。具体定义如下：  
【定义4.5】对于$\cdot n$元简单命题函数$P(x_{1},x_{2},\cdots x_{n})$，将其中的函数名$P$ 称为谓词，将$n$元简单命题函数$P(x_{1},x_{2},\cdots x_{n})$称为$n$元谓词。  
单纯的个体词或单纯的谓词都无法完成一个完整的逻辑含义，只有将它们结合起来才能构成完整独立的逻辑断言。因此，除非特别说明，通常情况下我们所说的谓词指的就是含有个体变元的谓词，即$n$元谓词。  
通过以上例题可以看出$n$元谓词主要用来描述个体的性质或者个体之间的联系。当$n=$1时，谓词描述的是个体的性质；当$n>1$时，谓词描述的是个体之间的联系。  
$n$元谓词$P(x_{1},x_{2},\cdots x_{n})$是表示含有$\cdot_{n}$个个体变量的语句。变量对个体指定的不确定性使得语句无法确定具体的真值，因而不是命题。当这些变量$x_{1},x_{2},\cdots x_{n}$均得到具体赋值或通过其它方式受到约束而获得明确具体的含义时，$P(x_{1},x_{2},\cdots x_{n})$就表示一个具体命题。  
例如，令一元谓词$P(x)$表示“$\cdot_{x}$ 是大学生”，则$P($小张)就是一个具体命题：小张是大学生。同样，$P($小李)也表示一个具体命题：小李是大学生。  
给$n$元谓词的个体变量赋值是一种最简单的约束方式，由此得到谓词填式的概念：  
【定义4.6】对于$\cdot n$元谓词$P(x_{1},x_{2},\cdots x_{n})$，若将其中每个个体变量$\cdot x_{1},x_{2},\cdots x_{n}$分别指定具体的个体，由此得到的命题$P(a_{1},a,\cdots a_{n})$，称为谓词填式，也称为命题的谓词式。  
谓词填式具有谓词的形式结构但不再含有个体变量，可以看成是零元谓词，是具体命题的谓词表示形式。例如：$P($小张)就是一个0 元谓词。因此，命题其实就是一种特殊的零元谓词，谓词逻辑是命题逻辑的一种自然推广。",谓词填式是通过给n元谓词的个体变量赋值得到的命题
谓词,包含,n元谓词,,"从结构上看，简单命题函数主要通过将原子命题中的个体常量泛化为个体变量的方式实现对命题结构的分解和对命题含义的抽象。在这个分解与抽象过程中，原子命题中表示个体性质与联系的谓语部分则不做任何抽象和改变而直接继承下来成为命题函数的函数名，并称之为谓词。谓词是简单命题函数中具有实质性含义的部分，刻画了命题函数中个体变量的性质与联系，构成了简单命题函数的主体。从本质上看，含有变元的简单命题函数其实就是含有变元的谓词。因此，通常将$_{\cdot n}$元简单命题函数称为$^n$元谓词。具体定义如下：  
【定义4.5】对于$\cdot n$元简单命题函数$P(x_{1},x_{2},\cdots x_{n})$，将其中的函数名$P$ 称为谓词，将$n$元简单命题函数$P(x_{1},x_{2},\cdots x_{n})$称为$n$元谓词。  
单纯的个体词或单纯的谓词都无法完成一个完整的逻辑含义，只有将它们结合起来才能构成完整独立的逻辑断言。因此，除非特别说明，通常情况下我们所说的谓词指的就是含有个体变元的谓词，即$n$元谓词。  
通过以上例题可以看出$n$元谓词主要用来描述个体的性质或者个体之间的联系。当$n=$1时，谓词描述的是个体的性质；当$n>1$时，谓词描述的是个体之间的联系。  
$n$元谓词$P(x_{1},x_{2},\cdots x_{n})$是表示含有$\cdot_{n}$个个体变量的语句。变量对个体指定的不确定性使得语句无法确定具体的真值，因而不是命题。当这些变量$x_{1},x_{2},\cdots x_{n}$均得到具体赋值或通过其它方式受到约束而获得明确具体的含义时，$P(x_{1},x_{2},\cdots x_{n})$就表示一个具体命题。  
例如，令一元谓词$P(x)$表示“$\cdot_{x}$ 是大学生”，则$P($小张)就是一个具体命题：小张是大学生。同样，$P($小李)也表示一个具体命题：小李是大学生。  
给$n$元谓词的个体变量赋值是一种最简单的约束方式，由此得到谓词填式的概念：  
【定义4.6】对于$\cdot n$元谓词$P(x_{1},x_{2},\cdots x_{n})$，若将其中每个个体变量$\cdot x_{1},x_{2},\cdots x_{n}$分别指定具体的个体，由此得到的命题$P(a_{1},a,\cdots a_{n})$，称为谓词填式，也称为命题的谓词式。  
谓词填式具有谓词的形式结构但不再含有个体变量，可以看成是零元谓词，是具体命题的谓词表示形式。例如：$P($小张)就是一个0 元谓词。因此，命题其实就是一种特殊的零元谓词，谓词逻辑是命题逻辑的一种自然推广。",谓词通常指含有个体变元的谓词，即n元谓词
量词,约束,特性谓词,,不同的谓词，其变量的个体域会有所不同，这些具有不同个体域的谓词在一起进行逻辑演算时往往会导致演算结果在个体域界定上的混乱。通过引入量词和特性谓词，可以较好地解决这个问题。事实上，量词实现了对谓词中个体变量含义的约束，消除了谓词在语义上的抽象性和不确定性，可使谓词成为具有确定真值的命题。,量词通过对谓词中个体变量含义的约束，消除谓词在语义上的抽象性和不确定性，使谓词成为具有确定真值的命题，从而与特性谓词共同解决个体域界定上的混乱问题
量词,包含,全称量词,,"如前所述，若给谓词中每个变量分别指定确定个体，则谓词就变成谓词填式并由此成为一个具体命题。事实上，除了直接给变量赋值之外，还可通过其它方法实现对变量的限制或者约束，使得谓词具有明确具体的含义而变成命题，即具有命题谓词式的具体命题。  
例如，对于前述苏格拉底三段论中的命题“所有人都是要死的”，句中的主语“人”其实并不是一个具体的个体常量，而是一个变量，但是整个句子却是一个真命题。原因是句中的“人”受到“所有的”这个词的限定或者约束，使得整个语句具有明确的含义。  
同理，对于“所有的老虎都吃人”、“有一些自然数是素数”、“有一些动物是哺乳动物”、“所有人都长着黑头发”等等之类的陈述句，其主语尽管是变量，但是都受到“所有的”、“有一些”之类词的约束或限定，具有明确的含义和指代，因此这些陈述句都是命题。  
这些能够对谓词中变量进行约束或限定的词，我们称之为量词。其具体定义如下：  
【定义4.7】对于给定的谓词$P(x)$，若个体变量$x$在其个体域内的所有赋值都使得$P(x)$的取值为真，则称$P(x)$得到全称量化，记为：$\forall x P(x)$。其中$\forall$称为全称量词，$\forall$后面的$x$ 称为其作用变量，$\forall x$的含义为“对于变量$x$ 个体域中的每个个体…”。  
【定义4.8】对于给定的谓词$P(x)$，若个体变量$x$在其个体域内至少存在一个赋值都使得$P(x)$的谓词填式取值为真，则称$P(x)$得到存在量化，记为：$\exists x P(x)$。其中∃称为全称量词，∃后面的$x$ 称为其作用变量，$\exists x$的含义为“变量$x$ 个体域中至少存在一个个体…”。",全称量词是量词的一种，用于对谓词中变量进行全称量化
量词,包含,存在量词,,"如前所述，若给谓词中每个变量分别指定确定个体，则谓词就变成谓词填式并由此成为一个具体命题。事实上，除了直接给变量赋值之外，还可通过其它方法实现对变量的限制或者约束，使得谓词具有明确具体的含义而变成命题，即具有命题谓词式的具体命题。  
例如，对于前述苏格拉底三段论中的命题“所有人都是要死的”，句中的主语“人”其实并不是一个具体的个体常量，而是一个变量，但是整个句子却是一个真命题。原因是句中的“人”受到“所有的”这个词的限定或者约束，使得整个语句具有明确的含义。  
同理，对于“所有的老虎都吃人”、“有一些自然数是素数”、“有一些动物是哺乳动物”、“所有人都长着黑头发”等等之类的陈述句，其主语尽管是变量，但是都受到“所有的”、“有一些”之类词的约束或限定，具有明确的含义和指代，因此这些陈述句都是命题。  
这些能够对谓词中变量进行约束或限定的词，我们称之为量词。其具体定义如下：  
【定义4.7】对于给定的谓词$P(x)$，若个体变量$x$在其个体域内的所有赋值都使得$P(x)$的取值为真，则称$P(x)$得到全称量化，记为：$\forall x P(x)$。其中$\forall$称为全称量词，$\forall$后面的$x$ 称为其作用变量，$\forall x$的含义为“对于变量$x$ 个体域中的每个个体…”。  
【定义4.8】对于给定的谓词$P(x)$，若个体变量$x$在其个体域内至少存在一个赋值都使得$P(x)$的谓词填式取值为真，则称$P(x)$得到存在量化，记为：$\exists x P(x)$。其中∃称为全称量词，∃后面的$x$ 称为其作用变量，$\exists x$的含义为“变量$x$ 个体域中至少存在一个个体…”。",存在量词是量词的一种，用于对谓词中变量进行存在量化
全称量词,并列,存在量词,,"如前所述，若给谓词中每个变量分别指定确定个体，则谓词就变成谓词填式并由此成为一个具体命题。事实上，除了直接给变量赋值之外，还可通过其它方法实现对变量的限制或者约束，使得谓词具有明确具体的含义而变成命题，即具有命题谓词式的具体命题。  
例如，对于前述苏格拉底三段论中的命题“所有人都是要死的”，句中的主语“人”其实并不是一个具体的个体常量，而是一个变量，但是整个句子却是一个真命题。原因是句中的“人”受到“所有的”这个词的限定或者约束，使得整个语句具有明确的含义。  
同理，对于“所有的老虎都吃人”、“有一些自然数是素数”、“有一些动物是哺乳动物”、“所有人都长着黑头发”等等之类的陈述句，其主语尽管是变量，但是都受到“所有的”、“有一些”之类词的约束或限定，具有明确的含义和指代，因此这些陈述句都是命题。  
这些能够对谓词中变量进行约束或限定的词，我们称之为量词。其具体定义如下：  
【定义4.7】对于给定的谓词$P(x)$，若个体变量$x$在其个体域内的所有赋值都使得$P(x)$的取值为真，则称$P(x)$得到全称量化，记为：$\forall x P(x)$。其中$\forall$称为全称量词，$\forall$后面的$x$ 称为其作用变量，$\forall x$的含义为“对于变量$x$ 个体域中的每个个体…”。  
【定义4.8】对于给定的谓词$P(x)$，若个体变量$x$在其个体域内至少存在一个赋值都使得$P(x)$的谓词填式取值为真，则称$P(x)$得到存在量化，记为：$\exists x P(x)$。其中∃称为全称量词，∃后面的$x$ 称为其作用变量，$\exists x$的含义为“变量$x$ 个体域中至少存在一个个体…”。",全称量词和存在量词都是量词的不同类型，分别用于全称和存在量化
全称量词,否定转换,存在量词,,"假设$P(x)$是关于个体变量$x$的一元谓词，$D$ 是$x$ 的个体域，现讨论全称量词的性质：  
由全称量词定义可知，$\forall x P(x)$表示这样的一个命题：“对于$D$ 中任意一个个体$x$，$P(x)$均为真”。因此，$\forall x P(x)$作为一个具体命题，其真值应按如下方式确定：  
$\forall x P(x)$取值为真，当且仅当对于$D$ 中任意一个个体$x$，都使得$P(x)$的取值均为真；  
$\forall x P(x)$取值为假，当且仅当$D$ 中至少存在一个个体$x_{0}$，使得$P(x_{0})$的取值为假。  
即有：
$$
\forall x P(x)=\left\{\!\!\begin{array}{l l}{1,\,\,\forall x\in D,\,\,\,\,\,\,\,\,\,P(x)=1}\\ {0,\,\,\exists x_{0}\in D,\,\,\,P(x_{0})=0}\end{array}\right.\tag{4-1}
$$  
下面讨论存在量词的性质，由存在量词定义可知，$\exists x P(x)$表示这样的一个命题：$^{\cdot}\!D$中至少一个个体$x_{0}$，使得$P(x_{0})$的取值为真”。因此，$\exists x P(x)$作为一个具体命题，其真值应按如下方式确定：  
$\exists x P(x)$取值为真，当且仅当$D$ 中至少存在一个个体$x_{0}$，使得$P(x_{0})$的取值为真；  
$\exists x P(x)$取值为假，当且仅当对于$D$ 中任意一个个体$x$，都使得 $P(x)$的取值为假。  
即有：
$$
\exists x P(x)=\left\{\!\!\begin{array}{l l}{1,\ \exists x_{0}\in D,\quad\quad P(x_{0})=1}\\ {0,\ \forall x\in D,\quad\quad\quad P(x)=0}\end{array}\!\!\right.\tag{4-2}
$$  
当$D$ 为有限集$\{x_{0},x_{1},\cdots,x_{n}\}$时$\forall x P(x)$和$\exists x P(x)$的可分别用如下与之等价的命题逻辑运算表示：  
$$
\forall x P(x)\Leftrightarrow P(x_{0})\land P(x_{1})\land\cdots\land P(x_{n})\tag{4-3}
$$  
$$
\exists x P(x)\Leftrightarrow P(x_{0})\lor P(x_{1})\lor\cdots\lor P(x_{n})\tag{4-4}
$$  
上式为量词的展开式，可根据实际问题需使用上式添加或消除量词。  
由以上讨论分析可知，对于一个$_{n}$元谓词，如果其中每个变量都分别受到量词约束，那么它就不再是一个命题函数，而是蜕化为一个具体的命题。但是，这些由$n$元谓词蜕化而来命题与命题逻辑中的命题还是有所不同。因为这些命题里含有变量，但这些变量与命题函数中的变量也有所不同。我们将在后续相关部分对此做进一步分析讨论。  
有时需要对量词含义进行否定。例如，对命题“每个老虎都吃人”的否定，就是命题“不是每个老虎都吃人”或者“至少存在一个老虎不吃人”；对命题“至少有一个人登上过月球”的否定，就是命题“所有人都没有登上过月球”。  
由此可见，全称量词否定就变成存在量词，存在量词否定就变成全称量词。这种量词否定的转换规则称为量词德摩根律。具体地说，对于含有量词的谓词式$\forall x P(x)$和$\exists x Q(x)$，其否定式的量词德摩根转换规则如下：  
$$
\lnot\forall x P(x)\Leftrightarrow\exists x\lnot P(x);\;\;\lnot\exists x Q(x)\Leftrightarrow\forall x\lnot Q(x)
$$  
量词德摩根律的具体逻辑含义由如表4-1 所示：  
表4-1 量词的德摩根律
![](images/2e2c83ee13b235854c72d43e04351502ef18cc9745bc1007f7d5f66d67c0c3ec.jpg)  
当个体变量$x$ 的个体域$D$ 为有限集$\{x_{0},x_{1},\cdots,x_{n}$}时，显然有：  
$$
\lnot\forall x P(x)\Leftrightarrow\lnot P(x_{0})\lor\lnot P(x_{1})\lor\cdots\lor\lnot P(x_{n})
$$  
$$
\lnot\exists x Q(x)\Leftrightarrow\lnot Q(x_{0})\land\lnot Q(x_{1})\land\cdots\land\lnot Q(x_{n})
$$",全称量词的否定转换为存在量词，存在量词的否定转换为全称量词，符合量词德摩根律
全称量词,等价表示,量词的展开,,"假设$P(x)$是关于个体变量$x$的一元谓词，$D$ 是$x$ 的个体域，现讨论全称量词的性质：  
由全称量词定义可知，$\forall x P(x)$表示这样的一个命题：“对于$D$ 中任意一个个体$x$，$P(x)$均为真”。因此，$\forall x P(x)$作为一个具体命题，其真值应按如下方式确定：  
$\forall x P(x)$取值为真，当且仅当对于$D$ 中任意一个个体$x$，都使得$P(x)$的取值均为真；  
$\forall x P(x)$取值为假，当且仅当$D$ 中至少存在一个个体$x_{0}$，使得$P(x_{0})$的取值为假。  
即有：
$$
\forall x P(x)=\left\{\!\!\begin{array}{l l}{1,\,\,\forall x\in D,\,\,\,\,\,\,\,\,\,P(x)=1}\\ {0,\,\,\exists x_{0}\in D,\,\,\,P(x_{0})=0}\end{array}\right.\tag{4-1}
$$  
下面讨论存在量词的性质，由存在量词定义可知，$\exists x P(x)$表示这样的一个命题：$^{\cdot}\!D$中至少一个个体$x_{0}$，使得$P(x_{0})$的取值为真”。因此，$\exists x P(x)$作为一个具体命题，其真值应按如下方式确定：  
$\exists x P(x)$取值为真，当且仅当$D$ 中至少存在一个个体$x_{0}$，使得$P(x_{0})$的取值为真；  
$\exists x P(x)$取值为假，当且仅当对于$D$ 中任意一个个体$x$，都使得 $P(x)$的取值为假。  
即有：
$$
\exists x P(x)=\left\{\!\!\begin{array}{l l}{1,\ \exists x_{0}\in D,\quad\quad P(x_{0})=1}\\ {0,\ \forall x\in D,\quad\quad\quad P(x)=0}\end{array}\!\!\right.\tag{4-2}
$$  
当$D$ 为有限集$\{x_{0},x_{1},\cdots,x_{n}\}$时$\forall x P(x)$和$\exists x P(x)$的可分别用如下与之等价的命题逻辑运算表示：  
$$
\forall x P(x)\Leftrightarrow P(x_{0})\land P(x_{1})\land\cdots\land P(x_{n})\tag{4-3}
$$  
$$
\exists x P(x)\Leftrightarrow P(x_{0})\lor P(x_{1})\lor\cdots\lor P(x_{n})\tag{4-4}
$$  
上式为量词的展开式，可根据实际问题需使用上式添加或消除量词。  
由以上讨论分析可知，对于一个$_{n}$元谓词，如果其中每个变量都分别受到量词约束，那么它就不再是一个命题函数，而是蜕化为一个具体的命题。但是，这些由$n$元谓词蜕化而来命题与命题逻辑中的命题还是有所不同。因为这些命题里含有变量，但这些变量与命题函数中的变量也有所不同。我们将在后续相关部分对此做进一步分析讨论。  
有时需要对量词含义进行否定。例如，对命题“每个老虎都吃人”的否定，就是命题“不是每个老虎都吃人”或者“至少存在一个老虎不吃人”；对命题“至少有一个人登上过月球”的否定，就是命题“所有人都没有登上过月球”。  
由此可见，全称量词否定就变成存在量词，存在量词否定就变成全称量词。这种量词否定的转换规则称为量词德摩根律。具体地说，对于含有量词的谓词式$\forall x P(x)$和$\exists x Q(x)$，其否定式的量词德摩根转换规则如下：  
$$
\lnot\forall x P(x)\Leftrightarrow\exists x\lnot P(x);\;\;\lnot\exists x Q(x)\Leftrightarrow\forall x\lnot Q(x)
$$  
量词德摩根律的具体逻辑含义由如表4-1 所示：  
表4-1 量词的德摩根律
![](images/2e2c83ee13b235854c72d43e04351502ef18cc9745bc1007f7d5f66d67c0c3ec.jpg)  
当个体变量$x$ 的个体域$D$ 为有限集$\{x_{0},x_{1},\cdots,x_{n}$}时，显然有：  
$$
\lnot\forall x P(x)\Leftrightarrow\lnot P(x_{0})\lor\lnot P(x_{1})\lor\cdots\lor\lnot P(x_{n})
$$  
$$
\lnot\exists x Q(x)\Leftrightarrow\lnot Q(x_{0})\land\lnot Q(x_{1})\land\cdots\land\lnot Q(x_{n})
$$",全称量词在有限集上可以等价表示为命题逻辑的合取运算
存在量词,等价表示,量词的展开,,"假设$P(x)$是关于个体变量$x$的一元谓词，$D$ 是$x$ 的个体域，现讨论全称量词的性质：  
由全称量词定义可知，$\forall x P(x)$表示这样的一个命题：“对于$D$ 中任意一个个体$x$，$P(x)$均为真”。因此，$\forall x P(x)$作为一个具体命题，其真值应按如下方式确定：  
$\forall x P(x)$取值为真，当且仅当对于$D$ 中任意一个个体$x$，都使得$P(x)$的取值均为真；  
$\forall x P(x)$取值为假，当且仅当$D$ 中至少存在一个个体$x_{0}$，使得$P(x_{0})$的取值为假。  
即有：
$$
\forall x P(x)=\left\{\!\!\begin{array}{l l}{1,\,\,\forall x\in D,\,\,\,\,\,\,\,\,\,P(x)=1}\\ {0,\,\,\exists x_{0}\in D,\,\,\,P(x_{0})=0}\end{array}\right.\tag{4-1}
$$  
下面讨论存在量词的性质，由存在量词定义可知，$\exists x P(x)$表示这样的一个命题：$^{\cdot}\!D$中至少一个个体$x_{0}$，使得$P(x_{0})$的取值为真”。因此，$\exists x P(x)$作为一个具体命题，其真值应按如下方式确定：  
$\exists x P(x)$取值为真，当且仅当$D$ 中至少存在一个个体$x_{0}$，使得$P(x_{0})$的取值为真；  
$\exists x P(x)$取值为假，当且仅当对于$D$ 中任意一个个体$x$，都使得 $P(x)$的取值为假。  
即有：
$$
\exists x P(x)=\left\{\!\!\begin{array}{l l}{1,\ \exists x_{0}\in D,\quad\quad P(x_{0})=1}\\ {0,\ \forall x\in D,\quad\quad\quad P(x)=0}\end{array}\!\!\right.\tag{4-2}
$$  
当$D$ 为有限集$\{x_{0},x_{1},\cdots,x_{n}\}$时$\forall x P(x)$和$\exists x P(x)$的可分别用如下与之等价的命题逻辑运算表示：  
$$
\forall x P(x)\Leftrightarrow P(x_{0})\land P(x_{1})\land\cdots\land P(x_{n})\tag{4-3}
$$  
$$
\exists x P(x)\Leftrightarrow P(x_{0})\lor P(x_{1})\lor\cdots\lor P(x_{n})\tag{4-4}
$$  
上式为量词的展开式，可根据实际问题需使用上式添加或消除量词。  
由以上讨论分析可知，对于一个$_{n}$元谓词，如果其中每个变量都分别受到量词约束，那么它就不再是一个命题函数，而是蜕化为一个具体的命题。但是，这些由$n$元谓词蜕化而来命题与命题逻辑中的命题还是有所不同。因为这些命题里含有变量，但这些变量与命题函数中的变量也有所不同。我们将在后续相关部分对此做进一步分析讨论。  
有时需要对量词含义进行否定。例如，对命题“每个老虎都吃人”的否定，就是命题“不是每个老虎都吃人”或者“至少存在一个老虎不吃人”；对命题“至少有一个人登上过月球”的否定，就是命题“所有人都没有登上过月球”。  
由此可见，全称量词否定就变成存在量词，存在量词否定就变成全称量词。这种量词否定的转换规则称为量词德摩根律。具体地说，对于含有量词的谓词式$\forall x P(x)$和$\exists x Q(x)$，其否定式的量词德摩根转换规则如下：  
$$
\lnot\forall x P(x)\Leftrightarrow\exists x\lnot P(x);\;\;\lnot\exists x Q(x)\Leftrightarrow\forall x\lnot Q(x)
$$  
量词德摩根律的具体逻辑含义由如表4-1 所示：  
表4-1 量词的德摩根律
![](images/2e2c83ee13b235854c72d43e04351502ef18cc9745bc1007f7d5f66d67c0c3ec.jpg)  
当个体变量$x$ 的个体域$D$ 为有限集$\{x_{0},x_{1},\cdots,x_{n}$}时，显然有：  
$$
\lnot\forall x P(x)\Leftrightarrow\lnot P(x_{0})\lor\lnot P(x_{1})\lor\cdots\lor\lnot P(x_{n})
$$  
$$
\lnot\exists x Q(x)\Leftrightarrow\lnot Q(x_{0})\land\lnot Q(x_{1})\land\cdots\land\lnot Q(x_{n})
$$",存在量词在有限集上可以等价表示为命题逻辑的析取运算
量词德摩根律,应用规则,全称量词,,"假设$P(x)$是关于个体变量$x$的一元谓词，$D$ 是$x$ 的个体域，现讨论全称量词的性质：  
由全称量词定义可知，$\forall x P(x)$表示这样的一个命题：“对于$D$ 中任意一个个体$x$，$P(x)$均为真”。因此，$\forall x P(x)$作为一个具体命题，其真值应按如下方式确定：  
$\forall x P(x)$取值为真，当且仅当对于$D$ 中任意一个个体$x$，都使得$P(x)$的取值均为真；  
$\forall x P(x)$取值为假，当且仅当$D$ 中至少存在一个个体$x_{0}$，使得$P(x_{0})$的取值为假。  
即有：
$$
\forall x P(x)=\left\{\!\!\begin{array}{l l}{1,\,\,\forall x\in D,\,\,\,\,\,\,\,\,\,P(x)=1}\\ {0,\,\,\exists x_{0}\in D,\,\,\,P(x_{0})=0}\end{array}\right.\tag{4-1}
$$  
下面讨论存在量词的性质，由存在量词定义可知，$\exists x P(x)$表示这样的一个命题：$^{\cdot}\!D$中至少一个个体$x_{0}$，使得$P(x_{0})$的取值为真”。因此，$\exists x P(x)$作为一个具体命题，其真值应按如下方式确定：  
$\exists x P(x)$取值为真，当且仅当$D$ 中至少存在一个个体$x_{0}$，使得$P(x_{0})$的取值为真；  
$\exists x P(x)$取值为假，当且仅当对于$D$ 中任意一个个体$x$，都使得 $P(x)$的取值为假。  
即有：
$$
\exists x P(x)=\left\{\!\!\begin{array}{l l}{1,\ \exists x_{0}\in D,\quad\quad P(x_{0})=1}\\ {0,\ \forall x\in D,\quad\quad\quad P(x)=0}\end{array}\!\!\right.\tag{4-2}
$$  
当$D$ 为有限集$\{x_{0},x_{1},\cdots,x_{n}\}$时$\forall x P(x)$和$\exists x P(x)$的可分别用如下与之等价的命题逻辑运算表示：  
$$
\forall x P(x)\Leftrightarrow P(x_{0})\land P(x_{1})\land\cdots\land P(x_{n})\tag{4-3}
$$  
$$
\exists x P(x)\Leftrightarrow P(x_{0})\lor P(x_{1})\lor\cdots\lor P(x_{n})\tag{4-4}
$$  
上式为量词的展开式，可根据实际问题需使用上式添加或消除量词。  
由以上讨论分析可知，对于一个$_{n}$元谓词，如果其中每个变量都分别受到量词约束，那么它就不再是一个命题函数，而是蜕化为一个具体的命题。但是，这些由$n$元谓词蜕化而来命题与命题逻辑中的命题还是有所不同。因为这些命题里含有变量，但这些变量与命题函数中的变量也有所不同。我们将在后续相关部分对此做进一步分析讨论。  
有时需要对量词含义进行否定。例如，对命题“每个老虎都吃人”的否定，就是命题“不是每个老虎都吃人”或者“至少存在一个老虎不吃人”；对命题“至少有一个人登上过月球”的否定，就是命题“所有人都没有登上过月球”。  
由此可见，全称量词否定就变成存在量词，存在量词否定就变成全称量词。这种量词否定的转换规则称为量词德摩根律。具体地说，对于含有量词的谓词式$\forall x P(x)$和$\exists x Q(x)$，其否定式的量词德摩根转换规则如下：  
$$
\lnot\forall x P(x)\Leftrightarrow\exists x\lnot P(x);\;\;\lnot\exists x Q(x)\Leftrightarrow\forall x\lnot Q(x)
$$  
量词德摩根律的具体逻辑含义由如表4-1 所示：  
表4-1 量词的德摩根律
![](images/2e2c83ee13b235854c72d43e04351502ef18cc9745bc1007f7d5f66d67c0c3ec.jpg)  
当个体变量$x$ 的个体域$D$ 为有限集$\{x_{0},x_{1},\cdots,x_{n}$}时，显然有：  
$$
\lnot\forall x P(x)\Leftrightarrow\lnot P(x_{0})\lor\lnot P(x_{1})\lor\cdots\lor\lnot P(x_{n})
$$  
$$
\lnot\exists x Q(x)\Leftrightarrow\lnot Q(x_{0})\land\lnot Q(x_{1})\land\cdots\land\lnot Q(x_{n})
$$",量词德摩根律应用于全称量词的否定，转换为存在量词的否定形式
量词德摩根律,应用规则,存在量词,,"假设$P(x)$是关于个体变量$x$的一元谓词，$D$ 是$x$ 的个体域，现讨论全称量词的性质：  
由全称量词定义可知，$\forall x P(x)$表示这样的一个命题：“对于$D$ 中任意一个个体$x$，$P(x)$均为真”。因此，$\forall x P(x)$作为一个具体命题，其真值应按如下方式确定：  
$\forall x P(x)$取值为真，当且仅当对于$D$ 中任意一个个体$x$，都使得$P(x)$的取值均为真；  
$\forall x P(x)$取值为假，当且仅当$D$ 中至少存在一个个体$x_{0}$，使得$P(x_{0})$的取值为假。  
即有：
$$
\forall x P(x)=\left\{\!\!\begin{array}{l l}{1,\,\,\forall x\in D,\,\,\,\,\,\,\,\,\,P(x)=1}\\ {0,\,\,\exists x_{0}\in D,\,\,\,P(x_{0})=0}\end{array}\right.\tag{4-1}
$$  
下面讨论存在量词的性质，由存在量词定义可知，$\exists x P(x)$表示这样的一个命题：$^{\cdot}\!D$中至少一个个体$x_{0}$，使得$P(x_{0})$的取值为真”。因此，$\exists x P(x)$作为一个具体命题，其真值应按如下方式确定：  
$\exists x P(x)$取值为真，当且仅当$D$ 中至少存在一个个体$x_{0}$，使得$P(x_{0})$的取值为真；  
$\exists x P(x)$取值为假，当且仅当对于$D$ 中任意一个个体$x$，都使得 $P(x)$的取值为假。  
即有：
$$
\exists x P(x)=\left\{\!\!\begin{array}{l l}{1,\ \exists x_{0}\in D,\quad\quad P(x_{0})=1}\\ {0,\ \forall x\in D,\quad\quad\quad P(x)=0}\end{array}\!\!\right.\tag{4-2}
$$  
当$D$ 为有限集$\{x_{0},x_{1},\cdots,x_{n}\}$时$\forall x P(x)$和$\exists x P(x)$的可分别用如下与之等价的命题逻辑运算表示：  
$$
\forall x P(x)\Leftrightarrow P(x_{0})\land P(x_{1})\land\cdots\land P(x_{n})\tag{4-3}
$$  
$$
\exists x P(x)\Leftrightarrow P(x_{0})\lor P(x_{1})\lor\cdots\lor P(x_{n})\tag{4-4}
$$  
上式为量词的展开式，可根据实际问题需使用上式添加或消除量词。  
由以上讨论分析可知，对于一个$_{n}$元谓词，如果其中每个变量都分别受到量词约束，那么它就不再是一个命题函数，而是蜕化为一个具体的命题。但是，这些由$n$元谓词蜕化而来命题与命题逻辑中的命题还是有所不同。因为这些命题里含有变量，但这些变量与命题函数中的变量也有所不同。我们将在后续相关部分对此做进一步分析讨论。  
有时需要对量词含义进行否定。例如，对命题“每个老虎都吃人”的否定，就是命题“不是每个老虎都吃人”或者“至少存在一个老虎不吃人”；对命题“至少有一个人登上过月球”的否定，就是命题“所有人都没有登上过月球”。  
由此可见，全称量词否定就变成存在量词，存在量词否定就变成全称量词。这种量词否定的转换规则称为量词德摩根律。具体地说，对于含有量词的谓词式$\forall x P(x)$和$\exists x Q(x)$，其否定式的量词德摩根转换规则如下：  
$$
\lnot\forall x P(x)\Leftrightarrow\exists x\lnot P(x);\;\;\lnot\exists x Q(x)\Leftrightarrow\forall x\lnot Q(x)
$$  
量词德摩根律的具体逻辑含义由如表4-1 所示：  
表4-1 量词的德摩根律
![](images/2e2c83ee13b235854c72d43e04351502ef18cc9745bc1007f7d5f66d67c0c3ec.jpg)  
当个体变量$x$ 的个体域$D$ 为有限集$\{x_{0},x_{1},\cdots,x_{n}$}时，显然有：  
$$
\lnot\forall x P(x)\Leftrightarrow\lnot P(x_{0})\lor\lnot P(x_{1})\lor\cdots\lor\lnot P(x_{n})
$$  
$$
\lnot\exists x Q(x)\Leftrightarrow\lnot Q(x_{0})\land\lnot Q(x_{1})\land\cdots\land\lnot Q(x_{n})
$$",量词德摩根律应用于存在量词的否定，转换为全称量词的否定形式
谓词,包含,个体词,,"我们知道，谓词中含有个体变量，不同谓词的个体变量和个体域经常会有所不同。此时会给谓词逻辑运算结果的个体域确定带来混乱和困难。例如符号化下面两个命题：  
设立如下谓词：$P(x)$：$X$吃人；$Q(x)$：$X$ 登上过月球。则可将上述两个命题符号化为：  
$$
(\,1\,)\ \forall x P(x),\ \operatorname{x}\!\in\!\ \{ 老虎\};\ (\,2\,)\ \exists x Q(x),\ \operatorname{x}\!\in\!\{人\}
$$  
上述符号化表示，对每个表达式都注明了个体域。如果需要对上述两个命题的谓词式进行合取运算，得可到如下新命题的谓词式：$\forall x P(x)\land\exists x Q(x)$。则该谓词式的个体域就比较含糊和混乱。如果有多个类似的命题谓词式进行复杂的逻辑运算，那么对运算结果个体域的确定显然是一件非常麻烦的事情。  
另一方面，对于一个命题的谓词表达式，其个体域的确定又是非常重要的。因为个体域的差异往往会导致其真值取值的不同。例如对于命题“所有人都是大学生”，如果个体域是某大学的某个班，那么该命题显然为真；如果个体域是某中学的某个班，那么该命题显然为假；如果个体域为某电影院某场电影的全体观众，那么命题的真值就比较难以确定。  
因此，命题的谓词表达式不能采用对每个表达式分别指定个体域的方式。事实上，可以让所有的谓词和命题函数共用全总个体域作为一种统一的个体域，不同的个体变量可以通过设立与其含义相对应的特性谓词来确定其个体域。  
例如，可以设定特性谓词$U(x)$表示：$x$是老虎，则命题“所有的老虎都吃人”，就可完整地符号化为：$\forall x(U(x)\rightarrow P(x))$。该谓词式准确而完整地表达了命题的含义，可理解为：对于全总个体域中的每个$x$，如果$x$ 是老虎，则$x$一定吃人。  
如果将命题“所有的老虎都吃人” 符号化为：$(\forall x)(U(x)\ \land\ P(x))$。则这种表达显然是错误的，因为该式的含义是：“对于任意的一个对象$x,\ x$ 是老虎，并且$x$ 会吃人”，这与命题所表达的逻辑含义不符。  
同理，可以设定特性谓词$H(x)$表示：$x$是人，则命题“有些人登上过月球”，就可以完整地符号化为：$\exists x(H(x)\land Q(x))$。该谓词式准确而完整地表达了命题的含义，可理解为：在全总个体域中存在一些$x$，这些$x$ 不仅是人，而且登上过月球。  
如果将命题“有些人登上过月球”符号化为：$(\exists x)~(H(x)~\rightarrow~S(x))$。则这种表达显然是错误的，因为该式的含义是：“存在一些对象$x$，只要$x$ 是人，则$x$一定登上过月球”，这与命题所表达的逻辑含义不符。  
由此可知，特性谓词的使用与量词类型有着密切关系，具体方法如下：  
（1）对于全称量词$\forall x$，刻画其作用变量$x$ 个体域的特性谓词作为蕴含式前件加入；  
（2）对于存在量词$\exists x$，刻画其作用变量$x$ 个体域的特性谓词作为合取项加入。",谓词中含有个体变量
谓词逻辑运算,影响,个体域,,"我们知道，谓词中含有个体变量，不同谓词的个体变量和个体域经常会有所不同。此时会给谓词逻辑运算结果的个体域确定带来混乱和困难。例如符号化下面两个命题：  
设立如下谓词：$P(x)$：$X$吃人；$Q(x)$：$X$ 登上过月球。则可将上述两个命题符号化为：  
$$
(\,1\,)\ \forall x P(x),\ \operatorname{x}\!\in\!\ \{ 老虎\};\ (\,2\,)\ \exists x Q(x),\ \operatorname{x}\!\in\!\{人\}
$$  
上述符号化表示，对每个表达式都注明了个体域。如果需要对上述两个命题的谓词式进行合取运算，得可到如下新命题的谓词式：$\forall x P(x)\land\exists x Q(x)$。则该谓词式的个体域就比较含糊和混乱。如果有多个类似的命题谓词式进行复杂的逻辑运算，那么对运算结果个体域的确定显然是一件非常麻烦的事情。  
另一方面，对于一个命题的谓词表达式，其个体域的确定又是非常重要的。因为个体域的差异往往会导致其真值取值的不同。例如对于命题“所有人都是大学生”，如果个体域是某大学的某个班，那么该命题显然为真；如果个体域是某中学的某个班，那么该命题显然为假；如果个体域为某电影院某场电影的全体观众，那么命题的真值就比较难以确定。  
因此，命题的谓词表达式不能采用对每个表达式分别指定个体域的方式。事实上，可以让所有的谓词和命题函数共用全总个体域作为一种统一的个体域，不同的个体变量可以通过设立与其含义相对应的特性谓词来确定其个体域。  
例如，可以设定特性谓词$U(x)$表示：$x$是老虎，则命题“所有的老虎都吃人”，就可完整地符号化为：$\forall x(U(x)\rightarrow P(x))$。该谓词式准确而完整地表达了命题的含义，可理解为：对于全总个体域中的每个$x$，如果$x$ 是老虎，则$x$一定吃人。  
如果将命题“所有的老虎都吃人” 符号化为：$(\forall x)(U(x)\ \land\ P(x))$。则这种表达显然是错误的，因为该式的含义是：“对于任意的一个对象$x,\ x$ 是老虎，并且$x$ 会吃人”，这与命题所表达的逻辑含义不符。  
同理，可以设定特性谓词$H(x)$表示：$x$是人，则命题“有些人登上过月球”，就可以完整地符号化为：$\exists x(H(x)\land Q(x))$。该谓词式准确而完整地表达了命题的含义，可理解为：在全总个体域中存在一些$x$，这些$x$ 不仅是人，而且登上过月球。  
如果将命题“有些人登上过月球”符号化为：$(\exists x)~(H(x)~\rightarrow~S(x))$。则这种表达显然是错误的，因为该式的含义是：“存在一些对象$x$，只要$x$ 是人，则$x$一定登上过月球”，这与命题所表达的逻辑含义不符。  
由此可知，特性谓词的使用与量词类型有着密切关系，具体方法如下：  
（1）对于全称量词$\forall x$，刻画其作用变量$x$ 个体域的特性谓词作为蕴含式前件加入；  
（2）对于存在量词$\exists x$，刻画其作用变量$x$ 个体域的特性谓词作为合取项加入。",谓词逻辑运算结果的个体域确定带来混乱和困难
特性谓词,确定,个体域,,"我们知道，谓词中含有个体变量，不同谓词的个体变量和个体域经常会有所不同。此时会给谓词逻辑运算结果的个体域确定带来混乱和困难。例如符号化下面两个命题：  
设立如下谓词：$P(x)$：$X$吃人；$Q(x)$：$X$ 登上过月球。则可将上述两个命题符号化为：  
$$
(\,1\,)\ \forall x P(x),\ \operatorname{x}\!\in\!\ \{ 老虎\};\ (\,2\,)\ \exists x Q(x),\ \operatorname{x}\!\in\!\{人\}
$$  
上述符号化表示，对每个表达式都注明了个体域。如果需要对上述两个命题的谓词式进行合取运算，得可到如下新命题的谓词式：$\forall x P(x)\land\exists x Q(x)$。则该谓词式的个体域就比较含糊和混乱。如果有多个类似的命题谓词式进行复杂的逻辑运算，那么对运算结果个体域的确定显然是一件非常麻烦的事情。  
另一方面，对于一个命题的谓词表达式，其个体域的确定又是非常重要的。因为个体域的差异往往会导致其真值取值的不同。例如对于命题“所有人都是大学生”，如果个体域是某大学的某个班，那么该命题显然为真；如果个体域是某中学的某个班，那么该命题显然为假；如果个体域为某电影院某场电影的全体观众，那么命题的真值就比较难以确定。  
因此，命题的谓词表达式不能采用对每个表达式分别指定个体域的方式。事实上，可以让所有的谓词和命题函数共用全总个体域作为一种统一的个体域，不同的个体变量可以通过设立与其含义相对应的特性谓词来确定其个体域。  
例如，可以设定特性谓词$U(x)$表示：$x$是老虎，则命题“所有的老虎都吃人”，就可完整地符号化为：$\forall x(U(x)\rightarrow P(x))$。该谓词式准确而完整地表达了命题的含义，可理解为：对于全总个体域中的每个$x$，如果$x$ 是老虎，则$x$一定吃人。  
如果将命题“所有的老虎都吃人” 符号化为：$(\forall x)(U(x)\ \land\ P(x))$。则这种表达显然是错误的，因为该式的含义是：“对于任意的一个对象$x,\ x$ 是老虎，并且$x$ 会吃人”，这与命题所表达的逻辑含义不符。  
同理，可以设定特性谓词$H(x)$表示：$x$是人，则命题“有些人登上过月球”，就可以完整地符号化为：$\exists x(H(x)\land Q(x))$。该谓词式准确而完整地表达了命题的含义，可理解为：在全总个体域中存在一些$x$，这些$x$ 不仅是人，而且登上过月球。  
如果将命题“有些人登上过月球”符号化为：$(\exists x)~(H(x)~\rightarrow~S(x))$。则这种表达显然是错误的，因为该式的含义是：“存在一些对象$x$，只要$x$ 是人，则$x$一定登上过月球”，这与命题所表达的逻辑含义不符。  
由此可知，特性谓词的使用与量词类型有着密切关系，具体方法如下：  
（1）对于全称量词$\forall x$，刻画其作用变量$x$ 个体域的特性谓词作为蕴含式前件加入；  
（2）对于存在量词$\exists x$，刻画其作用变量$x$ 个体域的特性谓词作为合取项加入。",特性谓词用于确定个体变量的个体域
全总个体域,共用,谓词,,"我们知道，谓词中含有个体变量，不同谓词的个体变量和个体域经常会有所不同。此时会给谓词逻辑运算结果的个体域确定带来混乱和困难。例如符号化下面两个命题：  
设立如下谓词：$P(x)$：$X$吃人；$Q(x)$：$X$ 登上过月球。则可将上述两个命题符号化为：  
$$
(\,1\,)\ \forall x P(x),\ \operatorname{x}\!\in\!\ \{ 老虎\};\ (\,2\,)\ \exists x Q(x),\ \operatorname{x}\!\in\!\{人\}
$$  
上述符号化表示，对每个表达式都注明了个体域。如果需要对上述两个命题的谓词式进行合取运算，得可到如下新命题的谓词式：$\forall x P(x)\land\exists x Q(x)$。则该谓词式的个体域就比较含糊和混乱。如果有多个类似的命题谓词式进行复杂的逻辑运算，那么对运算结果个体域的确定显然是一件非常麻烦的事情。  
另一方面，对于一个命题的谓词表达式，其个体域的确定又是非常重要的。因为个体域的差异往往会导致其真值取值的不同。例如对于命题“所有人都是大学生”，如果个体域是某大学的某个班，那么该命题显然为真；如果个体域是某中学的某个班，那么该命题显然为假；如果个体域为某电影院某场电影的全体观众，那么命题的真值就比较难以确定。  
因此，命题的谓词表达式不能采用对每个表达式分别指定个体域的方式。事实上，可以让所有的谓词和命题函数共用全总个体域作为一种统一的个体域，不同的个体变量可以通过设立与其含义相对应的特性谓词来确定其个体域。  
例如，可以设定特性谓词$U(x)$表示：$x$是老虎，则命题“所有的老虎都吃人”，就可完整地符号化为：$\forall x(U(x)\rightarrow P(x))$。该谓词式准确而完整地表达了命题的含义，可理解为：对于全总个体域中的每个$x$，如果$x$ 是老虎，则$x$一定吃人。  
如果将命题“所有的老虎都吃人” 符号化为：$(\forall x)(U(x)\ \land\ P(x))$。则这种表达显然是错误的，因为该式的含义是：“对于任意的一个对象$x,\ x$ 是老虎，并且$x$ 会吃人”，这与命题所表达的逻辑含义不符。  
同理，可以设定特性谓词$H(x)$表示：$x$是人，则命题“有些人登上过月球”，就可以完整地符号化为：$\exists x(H(x)\land Q(x))$。该谓词式准确而完整地表达了命题的含义，可理解为：在全总个体域中存在一些$x$，这些$x$ 不仅是人，而且登上过月球。  
如果将命题“有些人登上过月球”符号化为：$(\exists x)~(H(x)~\rightarrow~S(x))$。则这种表达显然是错误的，因为该式的含义是：“存在一些对象$x$，只要$x$ 是人，则$x$一定登上过月球”，这与命题所表达的逻辑含义不符。  
由此可知，特性谓词的使用与量词类型有着密切关系，具体方法如下：  
（1）对于全称量词$\forall x$，刻画其作用变量$x$ 个体域的特性谓词作为蕴含式前件加入；  
（2）对于存在量词$\exists x$，刻画其作用变量$x$ 个体域的特性谓词作为合取项加入。",所有谓词和命题函数可以共用全总个体域
量词,关联,特性谓词,,"我们知道，谓词中含有个体变量，不同谓词的个体变量和个体域经常会有所不同。此时会给谓词逻辑运算结果的个体域确定带来混乱和困难。例如符号化下面两个命题：  
设立如下谓词：$P(x)$：$X$吃人；$Q(x)$：$X$ 登上过月球。则可将上述两个命题符号化为：  
$$
(\,1\,)\ \forall x P(x),\ \operatorname{x}\!\in\!\ \{ 老虎\};\ (\,2\,)\ \exists x Q(x),\ \operatorname{x}\!\in\!\{人\}
$$  
上述符号化表示，对每个表达式都注明了个体域。如果需要对上述两个命题的谓词式进行合取运算，得可到如下新命题的谓词式：$\forall x P(x)\land\exists x Q(x)$。则该谓词式的个体域就比较含糊和混乱。如果有多个类似的命题谓词式进行复杂的逻辑运算，那么对运算结果个体域的确定显然是一件非常麻烦的事情。  
另一方面，对于一个命题的谓词表达式，其个体域的确定又是非常重要的。因为个体域的差异往往会导致其真值取值的不同。例如对于命题“所有人都是大学生”，如果个体域是某大学的某个班，那么该命题显然为真；如果个体域是某中学的某个班，那么该命题显然为假；如果个体域为某电影院某场电影的全体观众，那么命题的真值就比较难以确定。  
因此，命题的谓词表达式不能采用对每个表达式分别指定个体域的方式。事实上，可以让所有的谓词和命题函数共用全总个体域作为一种统一的个体域，不同的个体变量可以通过设立与其含义相对应的特性谓词来确定其个体域。  
例如，可以设定特性谓词$U(x)$表示：$x$是老虎，则命题“所有的老虎都吃人”，就可完整地符号化为：$\forall x(U(x)\rightarrow P(x))$。该谓词式准确而完整地表达了命题的含义，可理解为：对于全总个体域中的每个$x$，如果$x$ 是老虎，则$x$一定吃人。  
如果将命题“所有的老虎都吃人” 符号化为：$(\forall x)(U(x)\ \land\ P(x))$。则这种表达显然是错误的，因为该式的含义是：“对于任意的一个对象$x,\ x$ 是老虎，并且$x$ 会吃人”，这与命题所表达的逻辑含义不符。  
同理，可以设定特性谓词$H(x)$表示：$x$是人，则命题“有些人登上过月球”，就可以完整地符号化为：$\exists x(H(x)\land Q(x))$。该谓词式准确而完整地表达了命题的含义，可理解为：在全总个体域中存在一些$x$，这些$x$ 不仅是人，而且登上过月球。  
如果将命题“有些人登上过月球”符号化为：$(\exists x)~(H(x)~\rightarrow~S(x))$。则这种表达显然是错误的，因为该式的含义是：“存在一些对象$x$，只要$x$ 是人，则$x$一定登上过月球”，这与命题所表达的逻辑含义不符。  
由此可知，特性谓词的使用与量词类型有着密切关系，具体方法如下：  
（1）对于全称量词$\forall x$，刻画其作用变量$x$ 个体域的特性谓词作为蕴含式前件加入；  
（2）对于存在量词$\exists x$，刻画其作用变量$x$ 个体域的特性谓词作为合取项加入。",特性谓词的使用与量词类型有密切关系
谓词公式,包含,等值演算,,谓词逻辑的问题求解思路与命题逻辑类似，首先通过符号化将现实问题抽象成谓词符号形式，然后使用谓词逻辑的符号演算机制实现对问题的求解。因此，谓词符号的表达系统和演算机制是谓词逻辑理论的核心内容。本节着重学习这些内容，包括谓词公式的概念、自由变元与约束变元、谓词公式的解释与分类、谓词公式的等值关系与演算等。,谓词公式的学习内容包括其等值关系与演算
谓词公式,包含,原子谓词公式,,"类似于命题逻辑，谓词逻辑采用谓词公式的方式实现对谓词符号的表达。但谓词公式的定义比命题公式更加复杂，因为谓词公式的表达要深入到概念层次，需要用到更多种类的特殊符号来表达命题在概念层次上的各种组件。具体地说，除了前述两种量词符号之外，还有四种特殊符号，即：表示个体的个体常量符号、个体变量符号、个体函数符号，以及表示谓词的谓词符号。这四种符号的表达方式如下：  
（1）个体常量符号：用带或不带下标的小写英文字母$a,b,c,\cdots$表示个体常量。  
（2）个体变量符号：用带或不带下标的小写英文字母$x,y,z,$…表示个体变量。  
（3）个体函数符号：用带或不带下标的小写英文字母$f,\,g,\,h,\cdots$表示个体函数。所谓个体函数，就是个体与个体之间的映射关系。  
（4）谓词符号：用带或不带下标的大写英文字母$P,Q,R,\cdots$表示谓词。  
个体函数表示谓词逻辑中个体与个体之间的映射关系。例如，对于命题：小张的爸爸是教授。如果设立如下谓词和个体函数：  
$P(x)$:$x$是教授；$f(x)$:$x$的爸爸  
则该命题的谓词式可表示为：$P(f(x))$  
个体函数的使用为谓词逻辑中个体之间映射关系的表达带来了很大的方便，大大提升了谓词逻辑符号系统的表达能力。基于个体函数，可按如下方式定义一个称之为个体项的概念来专门表达谓词逻辑中的个体之间复杂的映射关系：  
【定义4.9】谓词逻辑中的个体项，被递归地定义为：  
（1）个体常量符号是个体项；  
（2）个体变量符号是个体项；  
（3）若$f(x_{1}\,,\ x_{2}\,,\ \ \dots\,,\ x_{n})$是$.n$元函数，$t_{1}$，$t_{2}$，… ，$t_{n}$是个体项，则$f(t_{1}\,,\,\,\,t_{2}\,,\,\,\,\dots\,,\,\,\,t_{n})$是个体项；  
（4）所有个体项都是有限次使用(1)，(2)，(3)生成的符号串。  
由定义可知，个体项具有非常强大的表达能力，能有效地表达个体以及个体之间的复杂的映射关系，谓词中的个体常量、个体变量和个体函数都可以统一用个体项的概念进行表达。例如复合函数$f(g(x,y),\ h(a,g(x,y),z))$都是个体项；再如，令$f(x)$表示“$x$ 的叔叔”；$P(x)$表示“$x$ 是医生”；$c$ 表示“周红”，则$f(c)$是一个体项，此时$P(f(c))$表示命题“周红的叔叔是医生”。有了个体项的概念，就可在$n$元谓词的基础上得到如下原子谓词公式的定义：  
【定义4.10】设$P(x_{1}\,,\ x_{2}\,,\ \ \dots\,,\ x_{n})$是$n$元谓词公式，$t_{1}\,,\,\,\,t_{2}\,,\,\,\,\dots\,,\,\,\,t_{n}$是个体项，则称$P(t_{1},\ t_{2},\ \dots,\ t_{n})$为谓词演算的原子公式，简称为原子谓词公式。  
可原子谓词公式的基础上进一步得到如下谓词合式公式的定义：  
【定义4.11】谓词合式公式亦称为谓词公式，它按下列递归方式定义：  
（1）原子谓词公式是谓词公式；  
（2）若$G$，$H$是谓词公式，则$(\neg G)$$),\;(G\!\!\lor \!\!H),\;(G\!\!\ \ \wedge  H),\;(G\!\!\to\!\!H),\;$$(G{\leftrightarrow}H)$是合式公式；  
（3）若$G$ 是谓词公式，$x$是$G$ 中的自由变量，则$\forall x G$，$\exists x G$都是谓词公式；  
（4）所有谓词公式都是有限次使用（1），（2），（3）生成的符号串。  
由上述定义可知，谓词公式是原子谓词公式、联结词、量词、圆括号和逗号按上述规则组成的符号串，且命题公式是谓词公式的一个特例。为方便起见，谓词公式中的括号可以像命题公式那样省略最外层括号。  
例如：$(\forall x)(\forall y)(P(x,y)\rightarrow(Q(x,y)\vee\neg R(x,a,f(z)))), (\forall x)(P(x)\vee(\exists y)R(x,y))$等都是谓词公式；$(\forall x)(P(x)\to R(x),\ (\exists y)(\forall x)(\lor P(x,y))$等则都不是公式，前者括号不配对，后者联结词无联结对象。",谓词公式包含原子谓词公式作为其基本组成部分
谓词公式,使用,个体项,,"类似于命题逻辑，谓词逻辑采用谓词公式的方式实现对谓词符号的表达。但谓词公式的定义比命题公式更加复杂，因为谓词公式的表达要深入到概念层次，需要用到更多种类的特殊符号来表达命题在概念层次上的各种组件。具体地说，除了前述两种量词符号之外，还有四种特殊符号，即：表示个体的个体常量符号、个体变量符号、个体函数符号，以及表示谓词的谓词符号。这四种符号的表达方式如下：  
（1）个体常量符号：用带或不带下标的小写英文字母$a,b,c,\cdots$表示个体常量。  
（2）个体变量符号：用带或不带下标的小写英文字母$x,y,z,$…表示个体变量。  
（3）个体函数符号：用带或不带下标的小写英文字母$f,\,g,\,h,\cdots$表示个体函数。所谓个体函数，就是个体与个体之间的映射关系。  
（4）谓词符号：用带或不带下标的大写英文字母$P,Q,R,\cdots$表示谓词。  
个体函数表示谓词逻辑中个体与个体之间的映射关系。例如，对于命题：小张的爸爸是教授。如果设立如下谓词和个体函数：  
$P(x)$:$x$是教授；$f(x)$:$x$的爸爸  
则该命题的谓词式可表示为：$P(f(x))$  
个体函数的使用为谓词逻辑中个体之间映射关系的表达带来了很大的方便，大大提升了谓词逻辑符号系统的表达能力。基于个体函数，可按如下方式定义一个称之为个体项的概念来专门表达谓词逻辑中的个体之间复杂的映射关系：  
【定义4.9】谓词逻辑中的个体项，被递归地定义为：  
（1）个体常量符号是个体项；  
（2）个体变量符号是个体项；  
（3）若$f(x_{1}\,,\ x_{2}\,,\ \ \dots\,,\ x_{n})$是$.n$元函数，$t_{1}$，$t_{2}$，… ，$t_{n}$是个体项，则$f(t_{1}\,,\,\,\,t_{2}\,,\,\,\,\dots\,,\,\,\,t_{n})$是个体项；  
（4）所有个体项都是有限次使用(1)，(2)，(3)生成的符号串。  
由定义可知，个体项具有非常强大的表达能力，能有效地表达个体以及个体之间的复杂的映射关系，谓词中的个体常量、个体变量和个体函数都可以统一用个体项的概念进行表达。例如复合函数$f(g(x,y),\ h(a,g(x,y),z))$都是个体项；再如，令$f(x)$表示“$x$ 的叔叔”；$P(x)$表示“$x$ 是医生”；$c$ 表示“周红”，则$f(c)$是一个体项，此时$P(f(c))$表示命题“周红的叔叔是医生”。有了个体项的概念，就可在$n$元谓词的基础上得到如下原子谓词公式的定义：  
【定义4.10】设$P(x_{1}\,,\ x_{2}\,,\ \ \dots\,,\ x_{n})$是$n$元谓词公式，$t_{1}\,,\,\,\,t_{2}\,,\,\,\,\dots\,,\,\,\,t_{n}$是个体项，则称$P(t_{1},\ t_{2},\ \dots,\ t_{n})$为谓词演算的原子公式，简称为原子谓词公式。  
可原子谓词公式的基础上进一步得到如下谓词合式公式的定义：  
【定义4.11】谓词合式公式亦称为谓词公式，它按下列递归方式定义：  
（1）原子谓词公式是谓词公式；  
（2）若$G$，$H$是谓词公式，则$(\neg G)$$),\;(G\!\!\lor \!\!H),\;(G\!\!\ \ \wedge  H),\;(G\!\!\to\!\!H),\;$$(G{\leftrightarrow}H)$是合式公式；  
（3）若$G$ 是谓词公式，$x$是$G$ 中的自由变量，则$\forall x G$，$\exists x G$都是谓词公式；  
（4）所有谓词公式都是有限次使用（1），（2），（3）生成的符号串。  
由上述定义可知，谓词公式是原子谓词公式、联结词、量词、圆括号和逗号按上述规则组成的符号串，且命题公式是谓词公式的一个特例。为方便起见，谓词公式中的括号可以像命题公式那样省略最外层括号。  
例如：$(\forall x)(\forall y)(P(x,y)\rightarrow(Q(x,y)\vee\neg R(x,a,f(z)))), (\forall x)(P(x)\vee(\exists y)R(x,y))$等都是谓词公式；$(\forall x)(P(x)\to R(x),\ (\exists y)(\forall x)(\lor P(x,y))$等则都不是公式，前者括号不配对，后者联结词无联结对象。",谓词公式中使用个体项来表达个体及其之间的复杂映射关系
原子谓词公式,组成,个体项,,"类似于命题逻辑，谓词逻辑采用谓词公式的方式实现对谓词符号的表达。但谓词公式的定义比命题公式更加复杂，因为谓词公式的表达要深入到概念层次，需要用到更多种类的特殊符号来表达命题在概念层次上的各种组件。具体地说，除了前述两种量词符号之外，还有四种特殊符号，即：表示个体的个体常量符号、个体变量符号、个体函数符号，以及表示谓词的谓词符号。这四种符号的表达方式如下：  
（1）个体常量符号：用带或不带下标的小写英文字母$a,b,c,\cdots$表示个体常量。  
（2）个体变量符号：用带或不带下标的小写英文字母$x,y,z,$…表示个体变量。  
（3）个体函数符号：用带或不带下标的小写英文字母$f,\,g,\,h,\cdots$表示个体函数。所谓个体函数，就是个体与个体之间的映射关系。  
（4）谓词符号：用带或不带下标的大写英文字母$P,Q,R,\cdots$表示谓词。  
个体函数表示谓词逻辑中个体与个体之间的映射关系。例如，对于命题：小张的爸爸是教授。如果设立如下谓词和个体函数：  
$P(x)$:$x$是教授；$f(x)$:$x$的爸爸  
则该命题的谓词式可表示为：$P(f(x))$  
个体函数的使用为谓词逻辑中个体之间映射关系的表达带来了很大的方便，大大提升了谓词逻辑符号系统的表达能力。基于个体函数，可按如下方式定义一个称之为个体项的概念来专门表达谓词逻辑中的个体之间复杂的映射关系：  
【定义4.9】谓词逻辑中的个体项，被递归地定义为：  
（1）个体常量符号是个体项；  
（2）个体变量符号是个体项；  
（3）若$f(x_{1}\,,\ x_{2}\,,\ \ \dots\,,\ x_{n})$是$.n$元函数，$t_{1}$，$t_{2}$，… ，$t_{n}$是个体项，则$f(t_{1}\,,\,\,\,t_{2}\,,\,\,\,\dots\,,\,\,\,t_{n})$是个体项；  
（4）所有个体项都是有限次使用(1)，(2)，(3)生成的符号串。  
由定义可知，个体项具有非常强大的表达能力，能有效地表达个体以及个体之间的复杂的映射关系，谓词中的个体常量、个体变量和个体函数都可以统一用个体项的概念进行表达。例如复合函数$f(g(x,y),\ h(a,g(x,y),z))$都是个体项；再如，令$f(x)$表示“$x$ 的叔叔”；$P(x)$表示“$x$ 是医生”；$c$ 表示“周红”，则$f(c)$是一个体项，此时$P(f(c))$表示命题“周红的叔叔是医生”。有了个体项的概念，就可在$n$元谓词的基础上得到如下原子谓词公式的定义：  
【定义4.10】设$P(x_{1}\,,\ x_{2}\,,\ \ \dots\,,\ x_{n})$是$n$元谓词公式，$t_{1}\,,\,\,\,t_{2}\,,\,\,\,\dots\,,\,\,\,t_{n}$是个体项，则称$P(t_{1},\ t_{2},\ \dots,\ t_{n})$为谓词演算的原子公式，简称为原子谓词公式。  
可原子谓词公式的基础上进一步得到如下谓词合式公式的定义：  
【定义4.11】谓词合式公式亦称为谓词公式，它按下列递归方式定义：  
（1）原子谓词公式是谓词公式；  
（2）若$G$，$H$是谓词公式，则$(\neg G)$$),\;(G\!\!\lor \!\!H),\;(G\!\!\ \ \wedge  H),\;(G\!\!\to\!\!H),\;$$(G{\leftrightarrow}H)$是合式公式；  
（3）若$G$ 是谓词公式，$x$是$G$ 中的自由变量，则$\forall x G$，$\exists x G$都是谓词公式；  
（4）所有谓词公式都是有限次使用（1），（2），（3）生成的符号串。  
由上述定义可知，谓词公式是原子谓词公式、联结词、量词、圆括号和逗号按上述规则组成的符号串，且命题公式是谓词公式的一个特例。为方便起见，谓词公式中的括号可以像命题公式那样省略最外层括号。  
例如：$(\forall x)(\forall y)(P(x,y)\rightarrow(Q(x,y)\vee\neg R(x,a,f(z)))), (\forall x)(P(x)\vee(\exists y)R(x,y))$等都是谓词公式；$(\forall x)(P(x)\to R(x),\ (\exists y)(\forall x)(\lor P(x,y))$等则都不是公式，前者括号不配对，后者联结词无联结对象。",原子谓词公式由个体项和谓词符号组成
谓词合式公式,等价,谓词公式,,"类似于命题逻辑，谓词逻辑采用谓词公式的方式实现对谓词符号的表达。但谓词公式的定义比命题公式更加复杂，因为谓词公式的表达要深入到概念层次，需要用到更多种类的特殊符号来表达命题在概念层次上的各种组件。具体地说，除了前述两种量词符号之外，还有四种特殊符号，即：表示个体的个体常量符号、个体变量符号、个体函数符号，以及表示谓词的谓词符号。这四种符号的表达方式如下：  
（1）个体常量符号：用带或不带下标的小写英文字母$a,b,c,\cdots$表示个体常量。  
（2）个体变量符号：用带或不带下标的小写英文字母$x,y,z,$…表示个体变量。  
（3）个体函数符号：用带或不带下标的小写英文字母$f,\,g,\,h,\cdots$表示个体函数。所谓个体函数，就是个体与个体之间的映射关系。  
（4）谓词符号：用带或不带下标的大写英文字母$P,Q,R,\cdots$表示谓词。  
个体函数表示谓词逻辑中个体与个体之间的映射关系。例如，对于命题：小张的爸爸是教授。如果设立如下谓词和个体函数：  
$P(x)$:$x$是教授；$f(x)$:$x$的爸爸  
则该命题的谓词式可表示为：$P(f(x))$  
个体函数的使用为谓词逻辑中个体之间映射关系的表达带来了很大的方便，大大提升了谓词逻辑符号系统的表达能力。基于个体函数，可按如下方式定义一个称之为个体项的概念来专门表达谓词逻辑中的个体之间复杂的映射关系：  
【定义4.9】谓词逻辑中的个体项，被递归地定义为：  
（1）个体常量符号是个体项；  
（2）个体变量符号是个体项；  
（3）若$f(x_{1}\,,\ x_{2}\,,\ \ \dots\,,\ x_{n})$是$.n$元函数，$t_{1}$，$t_{2}$，… ，$t_{n}$是个体项，则$f(t_{1}\,,\,\,\,t_{2}\,,\,\,\,\dots\,,\,\,\,t_{n})$是个体项；  
（4）所有个体项都是有限次使用(1)，(2)，(3)生成的符号串。  
由定义可知，个体项具有非常强大的表达能力，能有效地表达个体以及个体之间的复杂的映射关系，谓词中的个体常量、个体变量和个体函数都可以统一用个体项的概念进行表达。例如复合函数$f(g(x,y),\ h(a,g(x,y),z))$都是个体项；再如，令$f(x)$表示“$x$ 的叔叔”；$P(x)$表示“$x$ 是医生”；$c$ 表示“周红”，则$f(c)$是一个体项，此时$P(f(c))$表示命题“周红的叔叔是医生”。有了个体项的概念，就可在$n$元谓词的基础上得到如下原子谓词公式的定义：  
【定义4.10】设$P(x_{1}\,,\ x_{2}\,,\ \ \dots\,,\ x_{n})$是$n$元谓词公式，$t_{1}\,,\,\,\,t_{2}\,,\,\,\,\dots\,,\,\,\,t_{n}$是个体项，则称$P(t_{1},\ t_{2},\ \dots,\ t_{n})$为谓词演算的原子公式，简称为原子谓词公式。  
可原子谓词公式的基础上进一步得到如下谓词合式公式的定义：  
【定义4.11】谓词合式公式亦称为谓词公式，它按下列递归方式定义：  
（1）原子谓词公式是谓词公式；  
（2）若$G$，$H$是谓词公式，则$(\neg G)$$),\;(G\!\!\lor \!\!H),\;(G\!\!\ \ \wedge  H),\;(G\!\!\to\!\!H),\;$$(G{\leftrightarrow}H)$是合式公式；  
（3）若$G$ 是谓词公式，$x$是$G$ 中的自由变量，则$\forall x G$，$\exists x G$都是谓词公式；  
（4）所有谓词公式都是有限次使用（1），（2），（3）生成的符号串。  
由上述定义可知，谓词公式是原子谓词公式、联结词、量词、圆括号和逗号按上述规则组成的符号串，且命题公式是谓词公式的一个特例。为方便起见，谓词公式中的括号可以像命题公式那样省略最外层括号。  
例如：$(\forall x)(\forall y)(P(x,y)\rightarrow(Q(x,y)\vee\neg R(x,a,f(z)))), (\forall x)(P(x)\vee(\exists y)R(x,y))$等都是谓词公式；$(\forall x)(P(x)\to R(x),\ (\exists y)(\forall x)(\lor P(x,y))$等则都不是公式，前者括号不配对，后者联结词无联结对象。",谓词合式公式亦称为谓词公式，两者是等价的概念
谓词合式公式,包含,原子谓词公式,,"类似于命题逻辑，谓词逻辑采用谓词公式的方式实现对谓词符号的表达。但谓词公式的定义比命题公式更加复杂，因为谓词公式的表达要深入到概念层次，需要用到更多种类的特殊符号来表达命题在概念层次上的各种组件。具体地说，除了前述两种量词符号之外，还有四种特殊符号，即：表示个体的个体常量符号、个体变量符号、个体函数符号，以及表示谓词的谓词符号。这四种符号的表达方式如下：  
（1）个体常量符号：用带或不带下标的小写英文字母$a,b,c,\cdots$表示个体常量。  
（2）个体变量符号：用带或不带下标的小写英文字母$x,y,z,$…表示个体变量。  
（3）个体函数符号：用带或不带下标的小写英文字母$f,\,g,\,h,\cdots$表示个体函数。所谓个体函数，就是个体与个体之间的映射关系。  
（4）谓词符号：用带或不带下标的大写英文字母$P,Q,R,\cdots$表示谓词。  
个体函数表示谓词逻辑中个体与个体之间的映射关系。例如，对于命题：小张的爸爸是教授。如果设立如下谓词和个体函数：  
$P(x)$:$x$是教授；$f(x)$:$x$的爸爸  
则该命题的谓词式可表示为：$P(f(x))$  
个体函数的使用为谓词逻辑中个体之间映射关系的表达带来了很大的方便，大大提升了谓词逻辑符号系统的表达能力。基于个体函数，可按如下方式定义一个称之为个体项的概念来专门表达谓词逻辑中的个体之间复杂的映射关系：  
【定义4.9】谓词逻辑中的个体项，被递归地定义为：  
（1）个体常量符号是个体项；  
（2）个体变量符号是个体项；  
（3）若$f(x_{1}\,,\ x_{2}\,,\ \ \dots\,,\ x_{n})$是$.n$元函数，$t_{1}$，$t_{2}$，… ，$t_{n}$是个体项，则$f(t_{1}\,,\,\,\,t_{2}\,,\,\,\,\dots\,,\,\,\,t_{n})$是个体项；  
（4）所有个体项都是有限次使用(1)，(2)，(3)生成的符号串。  
由定义可知，个体项具有非常强大的表达能力，能有效地表达个体以及个体之间的复杂的映射关系，谓词中的个体常量、个体变量和个体函数都可以统一用个体项的概念进行表达。例如复合函数$f(g(x,y),\ h(a,g(x,y),z))$都是个体项；再如，令$f(x)$表示“$x$ 的叔叔”；$P(x)$表示“$x$ 是医生”；$c$ 表示“周红”，则$f(c)$是一个体项，此时$P(f(c))$表示命题“周红的叔叔是医生”。有了个体项的概念，就可在$n$元谓词的基础上得到如下原子谓词公式的定义：  
【定义4.10】设$P(x_{1}\,,\ x_{2}\,,\ \ \dots\,,\ x_{n})$是$n$元谓词公式，$t_{1}\,,\,\,\,t_{2}\,,\,\,\,\dots\,,\,\,\,t_{n}$是个体项，则称$P(t_{1},\ t_{2},\ \dots,\ t_{n})$为谓词演算的原子公式，简称为原子谓词公式。  
可原子谓词公式的基础上进一步得到如下谓词合式公式的定义：  
【定义4.11】谓词合式公式亦称为谓词公式，它按下列递归方式定义：  
（1）原子谓词公式是谓词公式；  
（2）若$G$，$H$是谓词公式，则$(\neg G)$$),\;(G\!\!\lor \!\!H),\;(G\!\!\ \ \wedge  H),\;(G\!\!\to\!\!H),\;$$(G{\leftrightarrow}H)$是合式公式；  
（3）若$G$ 是谓词公式，$x$是$G$ 中的自由变量，则$\forall x G$，$\exists x G$都是谓词公式；  
（4）所有谓词公式都是有限次使用（1），（2），（3）生成的符号串。  
由上述定义可知，谓词公式是原子谓词公式、联结词、量词、圆括号和逗号按上述规则组成的符号串，且命题公式是谓词公式的一个特例。为方便起见，谓词公式中的括号可以像命题公式那样省略最外层括号。  
例如：$(\forall x)(\forall y)(P(x,y)\rightarrow(Q(x,y)\vee\neg R(x,a,f(z)))), (\forall x)(P(x)\vee(\exists y)R(x,y))$等都是谓词公式；$(\forall x)(P(x)\to R(x),\ (\exists y)(\forall x)(\lor P(x,y))$等则都不是公式，前者括号不配对，后者联结词无联结对象。",谓词合式公式包含原子谓词公式作为其基本组成部分
谓词公式,包含,量词辖域,,"如前所述，量词实现了对谓词中个体变量含义的约束，消除了谓词在语义上的抽象性和不确定性，对于一个$\cdot n$元谓词，如果其中每个变量都分别受到量词的约束，那么它就不再是一个命题函数而蜕化一个具体命题。因此，对于任意一个$\cdot n$元谓词，可将其中所以命题变量分为两种具体不同性质的基本类型：一种是受到量词约束的命题变量，其含义是明确具体的，不再具有自由诠释的性质；另外一种是没有受到量词约束的命题变量，是传统意义上的命题变量，其含义是泛指某个不确定的个体对象，具有自由诠释的性质。这两种变量在谓词公式及谓词演算中扮演着完全不同的角色，在具体的表示形式上必须有明确的区分。本节主要介绍具体的区分方法，首先给出量词辖域的相关概念。  
【定义4.12】假设$G(x)$是任意一个含有命题变量$x$的谓词，在公式$(\forall x)G(x)$或$(\exists x)G(x)$中，$(\forall x)$或$(\exists x)$的作用变量$x$ 在$G(x)$中存在的范围称为量词$(\forall x)$或$(\exists x)$的辖域。如果辖域不是原子谓词公式，其两侧必须有括号，否则不应有括号。  
例如：在谓词公式$\exists x(P(x,y)\rightarrow Q(x,y))\vee P(y,z)$中，$\exists x$的辖域是$(P(x,y)\to Q(x,y))$  
在谓词公式$\forall x P(x)\rightarrow Q(x)$中，$\forall x$的辖域是$P(x)$。  
一般来说，一个量词的辖域是某个谓词公式的子公式。因此，确定一个量词的辖域就是要找出位于该量词之后与之相邻接的子公式，具体方法如下：  
（1）若量词后面有括弧，则括弧内的子公式就是该量词的辖域；  
（2）若量词后面无括弧，则与该量词邻接的子公式为该量词的辖域。  
下面在量词辖域的基础上给出自由变量和约束变量的定义：  
【定义4.13】假设𝐺是任一谓词公式，$x$是𝐺的任意一个命题变量，如果$x$出现在以它为作用变量的量词辖域之内，则称$x$的出现为约束出现，称变量$x$为约束变量；如果$x$不是约束出现，则称其为自由出现，此时称$x$为自由变量。  
从上述定义不难看出，所谓约束变量，就是其含义受到量词约束的命题变量。约束变量的含义是明确具体的，不再具有自由诠释的性质。自由变量则是含义没有受到量词约束的命题变量，是传统意义上的命题变量，可以对其含义进行自由诠释。  
如果谓词公式中所有命题变量都受到量词约束，则称其为封闭公式，具体定义如下：  
【定义4.14】若谓词公式$G$ 中不含自由变量，则称该公式为封闭公式或闭式。  
例如，$(\forall x)(P(x)\rightarrow(\exists y)R(x,y))$就是一个闭式。显然，要想使得含有$n$个自由变量的谓词公式变成闭式，需要添加$|n$个量词。  
从上述例题不难看出，有时候在同一个谓词公式中同一个命题变量既可以约束出现也可以自由出现，例如对于如下谓词公式：  
$(\forall x)(P(x)\rightarrow R(x))\land(\exists y)Q(x,y)$  
该式中个体变量$\cdot x$既是约束变量又是自由变量。这很容易引起在概念理解上的歧义或混乱，需要通过一些方法对这种变量进行换名，使得同一个个体变量在同一个谓词公式中要么自由出现，要么约束出现，不能兼而有之，避免个体变量在概念理解上的歧义或混乱。下面介绍具体的个体变量改名方法。  
对于任意一个含有量词的谓词公式，以约束方式出现的个体变量到底用哪一个字母表示其实是无关紧要的。事实上，用其它任意字母表示这个约束变量都不会改变谓词公式的含义。由此可得如下约束变量的换名规则：  
（1）将量词中出现的变量以及该量词辖域中此变量的所有约束出现都替换为新的变量；  
（2）新变量名一定要有别于辖域中的所有其它变量名。  
为使一个个体变量在同一个谓词公式中只以一种方式出现，还可以使用一定的规则实现对自由变量换名。该规则称为自由变量的代入规则，具体内容如下：  
（1）将公式中出现该自由变量的每一处都用新的变量替换；  
（2）新变量不允许在原公式中以任何约束形式出现。",量词辖域是谓词公式的一部分，表示量词作用的范围
谓词公式,包含,自由变量,,"如前所述，量词实现了对谓词中个体变量含义的约束，消除了谓词在语义上的抽象性和不确定性，对于一个$\cdot n$元谓词，如果其中每个变量都分别受到量词的约束，那么它就不再是一个命题函数而蜕化一个具体命题。因此，对于任意一个$\cdot n$元谓词，可将其中所以命题变量分为两种具体不同性质的基本类型：一种是受到量词约束的命题变量，其含义是明确具体的，不再具有自由诠释的性质；另外一种是没有受到量词约束的命题变量，是传统意义上的命题变量，其含义是泛指某个不确定的个体对象，具有自由诠释的性质。这两种变量在谓词公式及谓词演算中扮演着完全不同的角色，在具体的表示形式上必须有明确的区分。本节主要介绍具体的区分方法，首先给出量词辖域的相关概念。  
【定义4.12】假设$G(x)$是任意一个含有命题变量$x$的谓词，在公式$(\forall x)G(x)$或$(\exists x)G(x)$中，$(\forall x)$或$(\exists x)$的作用变量$x$ 在$G(x)$中存在的范围称为量词$(\forall x)$或$(\exists x)$的辖域。如果辖域不是原子谓词公式，其两侧必须有括号，否则不应有括号。  
例如：在谓词公式$\exists x(P(x,y)\rightarrow Q(x,y))\vee P(y,z)$中，$\exists x$的辖域是$(P(x,y)\to Q(x,y))$  
在谓词公式$\forall x P(x)\rightarrow Q(x)$中，$\forall x$的辖域是$P(x)$。  
一般来说，一个量词的辖域是某个谓词公式的子公式。因此，确定一个量词的辖域就是要找出位于该量词之后与之相邻接的子公式，具体方法如下：  
（1）若量词后面有括弧，则括弧内的子公式就是该量词的辖域；  
（2）若量词后面无括弧，则与该量词邻接的子公式为该量词的辖域。  
下面在量词辖域的基础上给出自由变量和约束变量的定义：  
【定义4.13】假设𝐺是任一谓词公式，$x$是𝐺的任意一个命题变量，如果$x$出现在以它为作用变量的量词辖域之内，则称$x$的出现为约束出现，称变量$x$为约束变量；如果$x$不是约束出现，则称其为自由出现，此时称$x$为自由变量。  
从上述定义不难看出，所谓约束变量，就是其含义受到量词约束的命题变量。约束变量的含义是明确具体的，不再具有自由诠释的性质。自由变量则是含义没有受到量词约束的命题变量，是传统意义上的命题变量，可以对其含义进行自由诠释。  
如果谓词公式中所有命题变量都受到量词约束，则称其为封闭公式，具体定义如下：  
【定义4.14】若谓词公式$G$ 中不含自由变量，则称该公式为封闭公式或闭式。  
例如，$(\forall x)(P(x)\rightarrow(\exists y)R(x,y))$就是一个闭式。显然，要想使得含有$n$个自由变量的谓词公式变成闭式，需要添加$|n$个量词。  
从上述例题不难看出，有时候在同一个谓词公式中同一个命题变量既可以约束出现也可以自由出现，例如对于如下谓词公式：  
$(\forall x)(P(x)\rightarrow R(x))\land(\exists y)Q(x,y)$  
该式中个体变量$\cdot x$既是约束变量又是自由变量。这很容易引起在概念理解上的歧义或混乱，需要通过一些方法对这种变量进行换名，使得同一个个体变量在同一个谓词公式中要么自由出现，要么约束出现，不能兼而有之，避免个体变量在概念理解上的歧义或混乱。下面介绍具体的个体变量改名方法。  
对于任意一个含有量词的谓词公式，以约束方式出现的个体变量到底用哪一个字母表示其实是无关紧要的。事实上，用其它任意字母表示这个约束变量都不会改变谓词公式的含义。由此可得如下约束变量的换名规则：  
（1）将量词中出现的变量以及该量词辖域中此变量的所有约束出现都替换为新的变量；  
（2）新变量名一定要有别于辖域中的所有其它变量名。  
为使一个个体变量在同一个谓词公式中只以一种方式出现，还可以使用一定的规则实现对自由变量换名。该规则称为自由变量的代入规则，具体内容如下：  
（1）将公式中出现该自由变量的每一处都用新的变量替换；  
（2）新变量不允许在原公式中以任何约束形式出现。",谓词公式中可以包含自由变量，即未受量词约束的变量
谓词公式,包含,约束变量,,"如前所述，量词实现了对谓词中个体变量含义的约束，消除了谓词在语义上的抽象性和不确定性，对于一个$\cdot n$元谓词，如果其中每个变量都分别受到量词的约束，那么它就不再是一个命题函数而蜕化一个具体命题。因此，对于任意一个$\cdot n$元谓词，可将其中所以命题变量分为两种具体不同性质的基本类型：一种是受到量词约束的命题变量，其含义是明确具体的，不再具有自由诠释的性质；另外一种是没有受到量词约束的命题变量，是传统意义上的命题变量，其含义是泛指某个不确定的个体对象，具有自由诠释的性质。这两种变量在谓词公式及谓词演算中扮演着完全不同的角色，在具体的表示形式上必须有明确的区分。本节主要介绍具体的区分方法，首先给出量词辖域的相关概念。  
【定义4.12】假设$G(x)$是任意一个含有命题变量$x$的谓词，在公式$(\forall x)G(x)$或$(\exists x)G(x)$中，$(\forall x)$或$(\exists x)$的作用变量$x$ 在$G(x)$中存在的范围称为量词$(\forall x)$或$(\exists x)$的辖域。如果辖域不是原子谓词公式，其两侧必须有括号，否则不应有括号。  
例如：在谓词公式$\exists x(P(x,y)\rightarrow Q(x,y))\vee P(y,z)$中，$\exists x$的辖域是$(P(x,y)\to Q(x,y))$  
在谓词公式$\forall x P(x)\rightarrow Q(x)$中，$\forall x$的辖域是$P(x)$。  
一般来说，一个量词的辖域是某个谓词公式的子公式。因此，确定一个量词的辖域就是要找出位于该量词之后与之相邻接的子公式，具体方法如下：  
（1）若量词后面有括弧，则括弧内的子公式就是该量词的辖域；  
（2）若量词后面无括弧，则与该量词邻接的子公式为该量词的辖域。  
下面在量词辖域的基础上给出自由变量和约束变量的定义：  
【定义4.13】假设𝐺是任一谓词公式，$x$是𝐺的任意一个命题变量，如果$x$出现在以它为作用变量的量词辖域之内，则称$x$的出现为约束出现，称变量$x$为约束变量；如果$x$不是约束出现，则称其为自由出现，此时称$x$为自由变量。  
从上述定义不难看出，所谓约束变量，就是其含义受到量词约束的命题变量。约束变量的含义是明确具体的，不再具有自由诠释的性质。自由变量则是含义没有受到量词约束的命题变量，是传统意义上的命题变量，可以对其含义进行自由诠释。  
如果谓词公式中所有命题变量都受到量词约束，则称其为封闭公式，具体定义如下：  
【定义4.14】若谓词公式$G$ 中不含自由变量，则称该公式为封闭公式或闭式。  
例如，$(\forall x)(P(x)\rightarrow(\exists y)R(x,y))$就是一个闭式。显然，要想使得含有$n$个自由变量的谓词公式变成闭式，需要添加$|n$个量词。  
从上述例题不难看出，有时候在同一个谓词公式中同一个命题变量既可以约束出现也可以自由出现，例如对于如下谓词公式：  
$(\forall x)(P(x)\rightarrow R(x))\land(\exists y)Q(x,y)$  
该式中个体变量$\cdot x$既是约束变量又是自由变量。这很容易引起在概念理解上的歧义或混乱，需要通过一些方法对这种变量进行换名，使得同一个个体变量在同一个谓词公式中要么自由出现，要么约束出现，不能兼而有之，避免个体变量在概念理解上的歧义或混乱。下面介绍具体的个体变量改名方法。  
对于任意一个含有量词的谓词公式，以约束方式出现的个体变量到底用哪一个字母表示其实是无关紧要的。事实上，用其它任意字母表示这个约束变量都不会改变谓词公式的含义。由此可得如下约束变量的换名规则：  
（1）将量词中出现的变量以及该量词辖域中此变量的所有约束出现都替换为新的变量；  
（2）新变量名一定要有别于辖域中的所有其它变量名。  
为使一个个体变量在同一个谓词公式中只以一种方式出现，还可以使用一定的规则实现对自由变量换名。该规则称为自由变量的代入规则，具体内容如下：  
（1）将公式中出现该自由变量的每一处都用新的变量替换；  
（2）新变量不允许在原公式中以任何约束形式出现。",谓词公式中可以包含约束变量，即受量词约束的变量
量词辖域,区分,自由变量,,"如前所述，量词实现了对谓词中个体变量含义的约束，消除了谓词在语义上的抽象性和不确定性，对于一个$\cdot n$元谓词，如果其中每个变量都分别受到量词的约束，那么它就不再是一个命题函数而蜕化一个具体命题。因此，对于任意一个$\cdot n$元谓词，可将其中所以命题变量分为两种具体不同性质的基本类型：一种是受到量词约束的命题变量，其含义是明确具体的，不再具有自由诠释的性质；另外一种是没有受到量词约束的命题变量，是传统意义上的命题变量，其含义是泛指某个不确定的个体对象，具有自由诠释的性质。这两种变量在谓词公式及谓词演算中扮演着完全不同的角色，在具体的表示形式上必须有明确的区分。本节主要介绍具体的区分方法，首先给出量词辖域的相关概念。  
【定义4.12】假设$G(x)$是任意一个含有命题变量$x$的谓词，在公式$(\forall x)G(x)$或$(\exists x)G(x)$中，$(\forall x)$或$(\exists x)$的作用变量$x$ 在$G(x)$中存在的范围称为量词$(\forall x)$或$(\exists x)$的辖域。如果辖域不是原子谓词公式，其两侧必须有括号，否则不应有括号。  
例如：在谓词公式$\exists x(P(x,y)\rightarrow Q(x,y))\vee P(y,z)$中，$\exists x$的辖域是$(P(x,y)\to Q(x,y))$  
在谓词公式$\forall x P(x)\rightarrow Q(x)$中，$\forall x$的辖域是$P(x)$。  
一般来说，一个量词的辖域是某个谓词公式的子公式。因此，确定一个量词的辖域就是要找出位于该量词之后与之相邻接的子公式，具体方法如下：  
（1）若量词后面有括弧，则括弧内的子公式就是该量词的辖域；  
（2）若量词后面无括弧，则与该量词邻接的子公式为该量词的辖域。  
下面在量词辖域的基础上给出自由变量和约束变量的定义：  
【定义4.13】假设𝐺是任一谓词公式，$x$是𝐺的任意一个命题变量，如果$x$出现在以它为作用变量的量词辖域之内，则称$x$的出现为约束出现，称变量$x$为约束变量；如果$x$不是约束出现，则称其为自由出现，此时称$x$为自由变量。  
从上述定义不难看出，所谓约束变量，就是其含义受到量词约束的命题变量。约束变量的含义是明确具体的，不再具有自由诠释的性质。自由变量则是含义没有受到量词约束的命题变量，是传统意义上的命题变量，可以对其含义进行自由诠释。  
如果谓词公式中所有命题变量都受到量词约束，则称其为封闭公式，具体定义如下：  
【定义4.14】若谓词公式$G$ 中不含自由变量，则称该公式为封闭公式或闭式。  
例如，$(\forall x)(P(x)\rightarrow(\exists y)R(x,y))$就是一个闭式。显然，要想使得含有$n$个自由变量的谓词公式变成闭式，需要添加$|n$个量词。  
从上述例题不难看出，有时候在同一个谓词公式中同一个命题变量既可以约束出现也可以自由出现，例如对于如下谓词公式：  
$(\forall x)(P(x)\rightarrow R(x))\land(\exists y)Q(x,y)$  
该式中个体变量$\cdot x$既是约束变量又是自由变量。这很容易引起在概念理解上的歧义或混乱，需要通过一些方法对这种变量进行换名，使得同一个个体变量在同一个谓词公式中要么自由出现，要么约束出现，不能兼而有之，避免个体变量在概念理解上的歧义或混乱。下面介绍具体的个体变量改名方法。  
对于任意一个含有量词的谓词公式，以约束方式出现的个体变量到底用哪一个字母表示其实是无关紧要的。事实上，用其它任意字母表示这个约束变量都不会改变谓词公式的含义。由此可得如下约束变量的换名规则：  
（1）将量词中出现的变量以及该量词辖域中此变量的所有约束出现都替换为新的变量；  
（2）新变量名一定要有别于辖域中的所有其它变量名。  
为使一个个体变量在同一个谓词公式中只以一种方式出现，还可以使用一定的规则实现对自由变量换名。该规则称为自由变量的代入规则，具体内容如下：  
（1）将公式中出现该自由变量的每一处都用新的变量替换；  
（2）新变量不允许在原公式中以任何约束形式出现。",量词辖域内出现的变量为约束变量，辖域外出现的变量为自由变量
量词辖域,定义,约束变量,,"如前所述，量词实现了对谓词中个体变量含义的约束，消除了谓词在语义上的抽象性和不确定性，对于一个$\cdot n$元谓词，如果其中每个变量都分别受到量词的约束，那么它就不再是一个命题函数而蜕化一个具体命题。因此，对于任意一个$\cdot n$元谓词，可将其中所以命题变量分为两种具体不同性质的基本类型：一种是受到量词约束的命题变量，其含义是明确具体的，不再具有自由诠释的性质；另外一种是没有受到量词约束的命题变量，是传统意义上的命题变量，其含义是泛指某个不确定的个体对象，具有自由诠释的性质。这两种变量在谓词公式及谓词演算中扮演着完全不同的角色，在具体的表示形式上必须有明确的区分。本节主要介绍具体的区分方法，首先给出量词辖域的相关概念。  
【定义4.12】假设$G(x)$是任意一个含有命题变量$x$的谓词，在公式$(\forall x)G(x)$或$(\exists x)G(x)$中，$(\forall x)$或$(\exists x)$的作用变量$x$ 在$G(x)$中存在的范围称为量词$(\forall x)$或$(\exists x)$的辖域。如果辖域不是原子谓词公式，其两侧必须有括号，否则不应有括号。  
例如：在谓词公式$\exists x(P(x,y)\rightarrow Q(x,y))\vee P(y,z)$中，$\exists x$的辖域是$(P(x,y)\to Q(x,y))$  
在谓词公式$\forall x P(x)\rightarrow Q(x)$中，$\forall x$的辖域是$P(x)$。  
一般来说，一个量词的辖域是某个谓词公式的子公式。因此，确定一个量词的辖域就是要找出位于该量词之后与之相邻接的子公式，具体方法如下：  
（1）若量词后面有括弧，则括弧内的子公式就是该量词的辖域；  
（2）若量词后面无括弧，则与该量词邻接的子公式为该量词的辖域。  
下面在量词辖域的基础上给出自由变量和约束变量的定义：  
【定义4.13】假设𝐺是任一谓词公式，$x$是𝐺的任意一个命题变量，如果$x$出现在以它为作用变量的量词辖域之内，则称$x$的出现为约束出现，称变量$x$为约束变量；如果$x$不是约束出现，则称其为自由出现，此时称$x$为自由变量。  
从上述定义不难看出，所谓约束变量，就是其含义受到量词约束的命题变量。约束变量的含义是明确具体的，不再具有自由诠释的性质。自由变量则是含义没有受到量词约束的命题变量，是传统意义上的命题变量，可以对其含义进行自由诠释。  
如果谓词公式中所有命题变量都受到量词约束，则称其为封闭公式，具体定义如下：  
【定义4.14】若谓词公式$G$ 中不含自由变量，则称该公式为封闭公式或闭式。  
例如，$(\forall x)(P(x)\rightarrow(\exists y)R(x,y))$就是一个闭式。显然，要想使得含有$n$个自由变量的谓词公式变成闭式，需要添加$|n$个量词。  
从上述例题不难看出，有时候在同一个谓词公式中同一个命题变量既可以约束出现也可以自由出现，例如对于如下谓词公式：  
$(\forall x)(P(x)\rightarrow R(x))\land(\exists y)Q(x,y)$  
该式中个体变量$\cdot x$既是约束变量又是自由变量。这很容易引起在概念理解上的歧义或混乱，需要通过一些方法对这种变量进行换名，使得同一个个体变量在同一个谓词公式中要么自由出现，要么约束出现，不能兼而有之，避免个体变量在概念理解上的歧义或混乱。下面介绍具体的个体变量改名方法。  
对于任意一个含有量词的谓词公式，以约束方式出现的个体变量到底用哪一个字母表示其实是无关紧要的。事实上，用其它任意字母表示这个约束变量都不会改变谓词公式的含义。由此可得如下约束变量的换名规则：  
（1）将量词中出现的变量以及该量词辖域中此变量的所有约束出现都替换为新的变量；  
（2）新变量名一定要有别于辖域中的所有其它变量名。  
为使一个个体变量在同一个谓词公式中只以一种方式出现，还可以使用一定的规则实现对自由变量换名。该规则称为自由变量的代入规则，具体内容如下：  
（1）将公式中出现该自由变量的每一处都用新的变量替换；  
（2）新变量不允许在原公式中以任何约束形式出现。",量词辖域内出现的变量定义为约束变量
谓词公式,特化,封闭公式,,"如前所述，量词实现了对谓词中个体变量含义的约束，消除了谓词在语义上的抽象性和不确定性，对于一个$\cdot n$元谓词，如果其中每个变量都分别受到量词的约束，那么它就不再是一个命题函数而蜕化一个具体命题。因此，对于任意一个$\cdot n$元谓词，可将其中所以命题变量分为两种具体不同性质的基本类型：一种是受到量词约束的命题变量，其含义是明确具体的，不再具有自由诠释的性质；另外一种是没有受到量词约束的命题变量，是传统意义上的命题变量，其含义是泛指某个不确定的个体对象，具有自由诠释的性质。这两种变量在谓词公式及谓词演算中扮演着完全不同的角色，在具体的表示形式上必须有明确的区分。本节主要介绍具体的区分方法，首先给出量词辖域的相关概念。  
【定义4.12】假设$G(x)$是任意一个含有命题变量$x$的谓词，在公式$(\forall x)G(x)$或$(\exists x)G(x)$中，$(\forall x)$或$(\exists x)$的作用变量$x$ 在$G(x)$中存在的范围称为量词$(\forall x)$或$(\exists x)$的辖域。如果辖域不是原子谓词公式，其两侧必须有括号，否则不应有括号。  
例如：在谓词公式$\exists x(P(x,y)\rightarrow Q(x,y))\vee P(y,z)$中，$\exists x$的辖域是$(P(x,y)\to Q(x,y))$  
在谓词公式$\forall x P(x)\rightarrow Q(x)$中，$\forall x$的辖域是$P(x)$。  
一般来说，一个量词的辖域是某个谓词公式的子公式。因此，确定一个量词的辖域就是要找出位于该量词之后与之相邻接的子公式，具体方法如下：  
（1）若量词后面有括弧，则括弧内的子公式就是该量词的辖域；  
（2）若量词后面无括弧，则与该量词邻接的子公式为该量词的辖域。  
下面在量词辖域的基础上给出自由变量和约束变量的定义：  
【定义4.13】假设𝐺是任一谓词公式，$x$是𝐺的任意一个命题变量，如果$x$出现在以它为作用变量的量词辖域之内，则称$x$的出现为约束出现，称变量$x$为约束变量；如果$x$不是约束出现，则称其为自由出现，此时称$x$为自由变量。  
从上述定义不难看出，所谓约束变量，就是其含义受到量词约束的命题变量。约束变量的含义是明确具体的，不再具有自由诠释的性质。自由变量则是含义没有受到量词约束的命题变量，是传统意义上的命题变量，可以对其含义进行自由诠释。  
如果谓词公式中所有命题变量都受到量词约束，则称其为封闭公式，具体定义如下：  
【定义4.14】若谓词公式$G$ 中不含自由变量，则称该公式为封闭公式或闭式。  
例如，$(\forall x)(P(x)\rightarrow(\exists y)R(x,y))$就是一个闭式。显然，要想使得含有$n$个自由变量的谓词公式变成闭式，需要添加$|n$个量词。  
从上述例题不难看出，有时候在同一个谓词公式中同一个命题变量既可以约束出现也可以自由出现，例如对于如下谓词公式：  
$(\forall x)(P(x)\rightarrow R(x))\land(\exists y)Q(x,y)$  
该式中个体变量$\cdot x$既是约束变量又是自由变量。这很容易引起在概念理解上的歧义或混乱，需要通过一些方法对这种变量进行换名，使得同一个个体变量在同一个谓词公式中要么自由出现，要么约束出现，不能兼而有之，避免个体变量在概念理解上的歧义或混乱。下面介绍具体的个体变量改名方法。  
对于任意一个含有量词的谓词公式，以约束方式出现的个体变量到底用哪一个字母表示其实是无关紧要的。事实上，用其它任意字母表示这个约束变量都不会改变谓词公式的含义。由此可得如下约束变量的换名规则：  
（1）将量词中出现的变量以及该量词辖域中此变量的所有约束出现都替换为新的变量；  
（2）新变量名一定要有别于辖域中的所有其它变量名。  
为使一个个体变量在同一个谓词公式中只以一种方式出现，还可以使用一定的规则实现对自由变量换名。该规则称为自由变量的代入规则，具体内容如下：  
（1）将公式中出现该自由变量的每一处都用新的变量替换；  
（2）新变量不允许在原公式中以任何约束形式出现。",不含自由变量的谓词公式称为封闭公式
约束变量,应用,约束变量换名规则,,"如前所述，量词实现了对谓词中个体变量含义的约束，消除了谓词在语义上的抽象性和不确定性，对于一个$\cdot n$元谓词，如果其中每个变量都分别受到量词的约束，那么它就不再是一个命题函数而蜕化一个具体命题。因此，对于任意一个$\cdot n$元谓词，可将其中所以命题变量分为两种具体不同性质的基本类型：一种是受到量词约束的命题变量，其含义是明确具体的，不再具有自由诠释的性质；另外一种是没有受到量词约束的命题变量，是传统意义上的命题变量，其含义是泛指某个不确定的个体对象，具有自由诠释的性质。这两种变量在谓词公式及谓词演算中扮演着完全不同的角色，在具体的表示形式上必须有明确的区分。本节主要介绍具体的区分方法，首先给出量词辖域的相关概念。  
【定义4.12】假设$G(x)$是任意一个含有命题变量$x$的谓词，在公式$(\forall x)G(x)$或$(\exists x)G(x)$中，$(\forall x)$或$(\exists x)$的作用变量$x$ 在$G(x)$中存在的范围称为量词$(\forall x)$或$(\exists x)$的辖域。如果辖域不是原子谓词公式，其两侧必须有括号，否则不应有括号。  
例如：在谓词公式$\exists x(P(x,y)\rightarrow Q(x,y))\vee P(y,z)$中，$\exists x$的辖域是$(P(x,y)\to Q(x,y))$  
在谓词公式$\forall x P(x)\rightarrow Q(x)$中，$\forall x$的辖域是$P(x)$。  
一般来说，一个量词的辖域是某个谓词公式的子公式。因此，确定一个量词的辖域就是要找出位于该量词之后与之相邻接的子公式，具体方法如下：  
（1）若量词后面有括弧，则括弧内的子公式就是该量词的辖域；  
（2）若量词后面无括弧，则与该量词邻接的子公式为该量词的辖域。  
下面在量词辖域的基础上给出自由变量和约束变量的定义：  
【定义4.13】假设𝐺是任一谓词公式，$x$是𝐺的任意一个命题变量，如果$x$出现在以它为作用变量的量词辖域之内，则称$x$的出现为约束出现，称变量$x$为约束变量；如果$x$不是约束出现，则称其为自由出现，此时称$x$为自由变量。  
从上述定义不难看出，所谓约束变量，就是其含义受到量词约束的命题变量。约束变量的含义是明确具体的，不再具有自由诠释的性质。自由变量则是含义没有受到量词约束的命题变量，是传统意义上的命题变量，可以对其含义进行自由诠释。  
如果谓词公式中所有命题变量都受到量词约束，则称其为封闭公式，具体定义如下：  
【定义4.14】若谓词公式$G$ 中不含自由变量，则称该公式为封闭公式或闭式。  
例如，$(\forall x)(P(x)\rightarrow(\exists y)R(x,y))$就是一个闭式。显然，要想使得含有$n$个自由变量的谓词公式变成闭式，需要添加$|n$个量词。  
从上述例题不难看出，有时候在同一个谓词公式中同一个命题变量既可以约束出现也可以自由出现，例如对于如下谓词公式：  
$(\forall x)(P(x)\rightarrow R(x))\land(\exists y)Q(x,y)$  
该式中个体变量$\cdot x$既是约束变量又是自由变量。这很容易引起在概念理解上的歧义或混乱，需要通过一些方法对这种变量进行换名，使得同一个个体变量在同一个谓词公式中要么自由出现，要么约束出现，不能兼而有之，避免个体变量在概念理解上的歧义或混乱。下面介绍具体的个体变量改名方法。  
对于任意一个含有量词的谓词公式，以约束方式出现的个体变量到底用哪一个字母表示其实是无关紧要的。事实上，用其它任意字母表示这个约束变量都不会改变谓词公式的含义。由此可得如下约束变量的换名规则：  
（1）将量词中出现的变量以及该量词辖域中此变量的所有约束出现都替换为新的变量；  
（2）新变量名一定要有别于辖域中的所有其它变量名。  
为使一个个体变量在同一个谓词公式中只以一种方式出现，还可以使用一定的规则实现对自由变量换名。该规则称为自由变量的代入规则，具体内容如下：  
（1）将公式中出现该自由变量的每一处都用新的变量替换；  
（2）新变量不允许在原公式中以任何约束形式出现。",约束变量换名规则用于避免同一变量在谓词公式中既自由出现又约束出现
自由变量,应用,自由变量代入规则,,"如前所述，量词实现了对谓词中个体变量含义的约束，消除了谓词在语义上的抽象性和不确定性，对于一个$\cdot n$元谓词，如果其中每个变量都分别受到量词的约束，那么它就不再是一个命题函数而蜕化一个具体命题。因此，对于任意一个$\cdot n$元谓词，可将其中所以命题变量分为两种具体不同性质的基本类型：一种是受到量词约束的命题变量，其含义是明确具体的，不再具有自由诠释的性质；另外一种是没有受到量词约束的命题变量，是传统意义上的命题变量，其含义是泛指某个不确定的个体对象，具有自由诠释的性质。这两种变量在谓词公式及谓词演算中扮演着完全不同的角色，在具体的表示形式上必须有明确的区分。本节主要介绍具体的区分方法，首先给出量词辖域的相关概念。  
【定义4.12】假设$G(x)$是任意一个含有命题变量$x$的谓词，在公式$(\forall x)G(x)$或$(\exists x)G(x)$中，$(\forall x)$或$(\exists x)$的作用变量$x$ 在$G(x)$中存在的范围称为量词$(\forall x)$或$(\exists x)$的辖域。如果辖域不是原子谓词公式，其两侧必须有括号，否则不应有括号。  
例如：在谓词公式$\exists x(P(x,y)\rightarrow Q(x,y))\vee P(y,z)$中，$\exists x$的辖域是$(P(x,y)\to Q(x,y))$  
在谓词公式$\forall x P(x)\rightarrow Q(x)$中，$\forall x$的辖域是$P(x)$。  
一般来说，一个量词的辖域是某个谓词公式的子公式。因此，确定一个量词的辖域就是要找出位于该量词之后与之相邻接的子公式，具体方法如下：  
（1）若量词后面有括弧，则括弧内的子公式就是该量词的辖域；  
（2）若量词后面无括弧，则与该量词邻接的子公式为该量词的辖域。  
下面在量词辖域的基础上给出自由变量和约束变量的定义：  
【定义4.13】假设𝐺是任一谓词公式，$x$是𝐺的任意一个命题变量，如果$x$出现在以它为作用变量的量词辖域之内，则称$x$的出现为约束出现，称变量$x$为约束变量；如果$x$不是约束出现，则称其为自由出现，此时称$x$为自由变量。  
从上述定义不难看出，所谓约束变量，就是其含义受到量词约束的命题变量。约束变量的含义是明确具体的，不再具有自由诠释的性质。自由变量则是含义没有受到量词约束的命题变量，是传统意义上的命题变量，可以对其含义进行自由诠释。  
如果谓词公式中所有命题变量都受到量词约束，则称其为封闭公式，具体定义如下：  
【定义4.14】若谓词公式$G$ 中不含自由变量，则称该公式为封闭公式或闭式。  
例如，$(\forall x)(P(x)\rightarrow(\exists y)R(x,y))$就是一个闭式。显然，要想使得含有$n$个自由变量的谓词公式变成闭式，需要添加$|n$个量词。  
从上述例题不难看出，有时候在同一个谓词公式中同一个命题变量既可以约束出现也可以自由出现，例如对于如下谓词公式：  
$(\forall x)(P(x)\rightarrow R(x))\land(\exists y)Q(x,y)$  
该式中个体变量$\cdot x$既是约束变量又是自由变量。这很容易引起在概念理解上的歧义或混乱，需要通过一些方法对这种变量进行换名，使得同一个个体变量在同一个谓词公式中要么自由出现，要么约束出现，不能兼而有之，避免个体变量在概念理解上的歧义或混乱。下面介绍具体的个体变量改名方法。  
对于任意一个含有量词的谓词公式，以约束方式出现的个体变量到底用哪一个字母表示其实是无关紧要的。事实上，用其它任意字母表示这个约束变量都不会改变谓词公式的含义。由此可得如下约束变量的换名规则：  
（1）将量词中出现的变量以及该量词辖域中此变量的所有约束出现都替换为新的变量；  
（2）新变量名一定要有别于辖域中的所有其它变量名。  
为使一个个体变量在同一个谓词公式中只以一种方式出现，还可以使用一定的规则实现对自由变量换名。该规则称为自由变量的代入规则，具体内容如下：  
（1）将公式中出现该自由变量的每一处都用新的变量替换；  
（2）新变量不允许在原公式中以任何约束形式出现。",自由变量代入规则用于将自由变量替换为新的变量，避免与约束变量冲突
谓词公式,依赖,解释,,"我们知道，对于一个命题公式，确定其真值取值状态是比较简单的，只需对命题公式中各个变量逐个指派真值便可得到命题公式的真值，而且在命题变量不是太多的情况下还可通过对命题变量真值指派的各种状态进行枚举的方式列出命题公式的真值表。然而，要确定一个谓词公式的真值取值状态，通常就没有这么简单了。  
例如，要确定谓词公式$(\forall x)(H(x){\rightarrow}D(x))$的真值，首先要确定其个体域，然后还要确定谓词$H(x)$和$D(x)$的具体含义。如果使用全总个体域$H(x)$表示 $x$是人$D(x)$表示 $x$会死的，则该谓词公式的取值为真，若将$D(x)$表示为 $x$是勇敢的，则谓词公式的取值为真为假。  
一般来说，对于任意给定的谓词公式，其含义与真值取值不仅依赖于个体域，依赖于公式中各个个体变量的取值状况，还依赖于对公式中谓词符号、函数符号、常量符号具体含义的确认，这些所有的依赖信息构成对谓词公式的解释。如果不对谓词公式中常量符号、变量符号、函数符号、谓词符号进行具体的解释，则公式就没有确定的含义和确定的真值取值.下面给出关于谓词公式解释的具体定义：  
【定义4.15】 谓词公式$G$的每一个解释$I$由如下四个部分组成：  
（1）确定非空的个体域集合$D$；  
（2）确定公式$G$ 中的每个常量符号的含义，即指定$D$ 中的某个特定的元素；  
（3）确定公式$G$ 中的每个$n$元函数的具体形式，即对于公式$G$ 中每个$n$元函数分别指定一个从$D^{n}$ 到$D$ 中的特定函数与之对应；  
（4）确定公式$G$ 中的每个$n$元谓词符号的具体形式，即对于公式$G$ 中每个$n$元谓词符号分别指定一个从$D^{n}$ 到$\{0,1\}$的特定函数与之对应。  
易知，对于任意一个给定的谓词公式，如果该公式是封闭公式，即不含有任何自由个体变量，则该公式在任何解释下均有确定的真值。  
由上述例题可知，与命题公式一样，有些谓词公式在有些解释下为真，在另外一些解释下为假；而有些谓词公式则在所有解释下均为真；还有一些谓词公式在所有解释下均为假。由此可以得到如下有效公式、矛盾公式和可满足公式的定义：  
【定义4.16】 对于任意一个给定的谓词公式$G$，如果$G$ 在其所有的解释$I$下的真值取值为真，则称$G$ 称为有效公式；如果$G$ 在其所有的解释$I$下的真值取值都为假，则称$G$为矛盾公式；如果$G$ 不是矛盾公式，则称其为可满足公式。  
从上述定义可知三种特殊公式之间具有如下关系：有效公式的否定为矛盾公式；矛盾公式的否定为有效公式；有效公式一定为可满足公式。",谓词公式的含义和真值取值依赖于其解释，包括个体域、常量符号、变量符号、函数符号和谓词符号的具体含义
谓词公式,定义,有效公式,,"我们知道，对于一个命题公式，确定其真值取值状态是比较简单的，只需对命题公式中各个变量逐个指派真值便可得到命题公式的真值，而且在命题变量不是太多的情况下还可通过对命题变量真值指派的各种状态进行枚举的方式列出命题公式的真值表。然而，要确定一个谓词公式的真值取值状态，通常就没有这么简单了。  
例如，要确定谓词公式$(\forall x)(H(x){\rightarrow}D(x))$的真值，首先要确定其个体域，然后还要确定谓词$H(x)$和$D(x)$的具体含义。如果使用全总个体域$H(x)$表示 $x$是人$D(x)$表示 $x$会死的，则该谓词公式的取值为真，若将$D(x)$表示为 $x$是勇敢的，则谓词公式的取值为真为假。  
一般来说，对于任意给定的谓词公式，其含义与真值取值不仅依赖于个体域，依赖于公式中各个个体变量的取值状况，还依赖于对公式中谓词符号、函数符号、常量符号具体含义的确认，这些所有的依赖信息构成对谓词公式的解释。如果不对谓词公式中常量符号、变量符号、函数符号、谓词符号进行具体的解释，则公式就没有确定的含义和确定的真值取值.下面给出关于谓词公式解释的具体定义：  
【定义4.15】 谓词公式$G$的每一个解释$I$由如下四个部分组成：  
（1）确定非空的个体域集合$D$；  
（2）确定公式$G$ 中的每个常量符号的含义，即指定$D$ 中的某个特定的元素；  
（3）确定公式$G$ 中的每个$n$元函数的具体形式，即对于公式$G$ 中每个$n$元函数分别指定一个从$D^{n}$ 到$D$ 中的特定函数与之对应；  
（4）确定公式$G$ 中的每个$n$元谓词符号的具体形式，即对于公式$G$ 中每个$n$元谓词符号分别指定一个从$D^{n}$ 到$\{0,1\}$的特定函数与之对应。  
易知，对于任意一个给定的谓词公式，如果该公式是封闭公式，即不含有任何自由个体变量，则该公式在任何解释下均有确定的真值。  
由上述例题可知，与命题公式一样，有些谓词公式在有些解释下为真，在另外一些解释下为假；而有些谓词公式则在所有解释下均为真；还有一些谓词公式在所有解释下均为假。由此可以得到如下有效公式、矛盾公式和可满足公式的定义：  
【定义4.16】 对于任意一个给定的谓词公式$G$，如果$G$ 在其所有的解释$I$下的真值取值为真，则称$G$ 称为有效公式；如果$G$ 在其所有的解释$I$下的真值取值都为假，则称$G$为矛盾公式；如果$G$ 不是矛盾公式，则称其为可满足公式。  
从上述定义可知三种特殊公式之间具有如下关系：有效公式的否定为矛盾公式；矛盾公式的否定为有效公式；有效公式一定为可满足公式。",谓词公式在其所有解释下真值均为真时，称为有效公式
谓词公式,定义,矛盾公式,,"我们知道，对于一个命题公式，确定其真值取值状态是比较简单的，只需对命题公式中各个变量逐个指派真值便可得到命题公式的真值，而且在命题变量不是太多的情况下还可通过对命题变量真值指派的各种状态进行枚举的方式列出命题公式的真值表。然而，要确定一个谓词公式的真值取值状态，通常就没有这么简单了。  
例如，要确定谓词公式$(\forall x)(H(x){\rightarrow}D(x))$的真值，首先要确定其个体域，然后还要确定谓词$H(x)$和$D(x)$的具体含义。如果使用全总个体域$H(x)$表示 $x$是人$D(x)$表示 $x$会死的，则该谓词公式的取值为真，若将$D(x)$表示为 $x$是勇敢的，则谓词公式的取值为真为假。  
一般来说，对于任意给定的谓词公式，其含义与真值取值不仅依赖于个体域，依赖于公式中各个个体变量的取值状况，还依赖于对公式中谓词符号、函数符号、常量符号具体含义的确认，这些所有的依赖信息构成对谓词公式的解释。如果不对谓词公式中常量符号、变量符号、函数符号、谓词符号进行具体的解释，则公式就没有确定的含义和确定的真值取值.下面给出关于谓词公式解释的具体定义：  
【定义4.15】 谓词公式$G$的每一个解释$I$由如下四个部分组成：  
（1）确定非空的个体域集合$D$；  
（2）确定公式$G$ 中的每个常量符号的含义，即指定$D$ 中的某个特定的元素；  
（3）确定公式$G$ 中的每个$n$元函数的具体形式，即对于公式$G$ 中每个$n$元函数分别指定一个从$D^{n}$ 到$D$ 中的特定函数与之对应；  
（4）确定公式$G$ 中的每个$n$元谓词符号的具体形式，即对于公式$G$ 中每个$n$元谓词符号分别指定一个从$D^{n}$ 到$\{0,1\}$的特定函数与之对应。  
易知，对于任意一个给定的谓词公式，如果该公式是封闭公式，即不含有任何自由个体变量，则该公式在任何解释下均有确定的真值。  
由上述例题可知，与命题公式一样，有些谓词公式在有些解释下为真，在另外一些解释下为假；而有些谓词公式则在所有解释下均为真；还有一些谓词公式在所有解释下均为假。由此可以得到如下有效公式、矛盾公式和可满足公式的定义：  
【定义4.16】 对于任意一个给定的谓词公式$G$，如果$G$ 在其所有的解释$I$下的真值取值为真，则称$G$ 称为有效公式；如果$G$ 在其所有的解释$I$下的真值取值都为假，则称$G$为矛盾公式；如果$G$ 不是矛盾公式，则称其为可满足公式。  
从上述定义可知三种特殊公式之间具有如下关系：有效公式的否定为矛盾公式；矛盾公式的否定为有效公式；有效公式一定为可满足公式。",谓词公式在其所有解释下真值均为假时，称为矛盾公式
谓词公式,定义,可满足公式,,"我们知道，对于一个命题公式，确定其真值取值状态是比较简单的，只需对命题公式中各个变量逐个指派真值便可得到命题公式的真值，而且在命题变量不是太多的情况下还可通过对命题变量真值指派的各种状态进行枚举的方式列出命题公式的真值表。然而，要确定一个谓词公式的真值取值状态，通常就没有这么简单了。  
例如，要确定谓词公式$(\forall x)(H(x){\rightarrow}D(x))$的真值，首先要确定其个体域，然后还要确定谓词$H(x)$和$D(x)$的具体含义。如果使用全总个体域$H(x)$表示 $x$是人$D(x)$表示 $x$会死的，则该谓词公式的取值为真，若将$D(x)$表示为 $x$是勇敢的，则谓词公式的取值为真为假。  
一般来说，对于任意给定的谓词公式，其含义与真值取值不仅依赖于个体域，依赖于公式中各个个体变量的取值状况，还依赖于对公式中谓词符号、函数符号、常量符号具体含义的确认，这些所有的依赖信息构成对谓词公式的解释。如果不对谓词公式中常量符号、变量符号、函数符号、谓词符号进行具体的解释，则公式就没有确定的含义和确定的真值取值.下面给出关于谓词公式解释的具体定义：  
【定义4.15】 谓词公式$G$的每一个解释$I$由如下四个部分组成：  
（1）确定非空的个体域集合$D$；  
（2）确定公式$G$ 中的每个常量符号的含义，即指定$D$ 中的某个特定的元素；  
（3）确定公式$G$ 中的每个$n$元函数的具体形式，即对于公式$G$ 中每个$n$元函数分别指定一个从$D^{n}$ 到$D$ 中的特定函数与之对应；  
（4）确定公式$G$ 中的每个$n$元谓词符号的具体形式，即对于公式$G$ 中每个$n$元谓词符号分别指定一个从$D^{n}$ 到$\{0,1\}$的特定函数与之对应。  
易知，对于任意一个给定的谓词公式，如果该公式是封闭公式，即不含有任何自由个体变量，则该公式在任何解释下均有确定的真值。  
由上述例题可知，与命题公式一样，有些谓词公式在有些解释下为真，在另外一些解释下为假；而有些谓词公式则在所有解释下均为真；还有一些谓词公式在所有解释下均为假。由此可以得到如下有效公式、矛盾公式和可满足公式的定义：  
【定义4.16】 对于任意一个给定的谓词公式$G$，如果$G$ 在其所有的解释$I$下的真值取值为真，则称$G$ 称为有效公式；如果$G$ 在其所有的解释$I$下的真值取值都为假，则称$G$为矛盾公式；如果$G$ 不是矛盾公式，则称其为可满足公式。  
从上述定义可知三种特殊公式之间具有如下关系：有效公式的否定为矛盾公式；矛盾公式的否定为有效公式；有效公式一定为可满足公式。",谓词公式不是矛盾公式时，称为可满足公式
有效公式,否定关系,矛盾公式,,"我们知道，对于一个命题公式，确定其真值取值状态是比较简单的，只需对命题公式中各个变量逐个指派真值便可得到命题公式的真值，而且在命题变量不是太多的情况下还可通过对命题变量真值指派的各种状态进行枚举的方式列出命题公式的真值表。然而，要确定一个谓词公式的真值取值状态，通常就没有这么简单了。  
例如，要确定谓词公式$(\forall x)(H(x){\rightarrow}D(x))$的真值，首先要确定其个体域，然后还要确定谓词$H(x)$和$D(x)$的具体含义。如果使用全总个体域$H(x)$表示 $x$是人$D(x)$表示 $x$会死的，则该谓词公式的取值为真，若将$D(x)$表示为 $x$是勇敢的，则谓词公式的取值为真为假。  
一般来说，对于任意给定的谓词公式，其含义与真值取值不仅依赖于个体域，依赖于公式中各个个体变量的取值状况，还依赖于对公式中谓词符号、函数符号、常量符号具体含义的确认，这些所有的依赖信息构成对谓词公式的解释。如果不对谓词公式中常量符号、变量符号、函数符号、谓词符号进行具体的解释，则公式就没有确定的含义和确定的真值取值.下面给出关于谓词公式解释的具体定义：  
【定义4.15】 谓词公式$G$的每一个解释$I$由如下四个部分组成：  
（1）确定非空的个体域集合$D$；  
（2）确定公式$G$ 中的每个常量符号的含义，即指定$D$ 中的某个特定的元素；  
（3）确定公式$G$ 中的每个$n$元函数的具体形式，即对于公式$G$ 中每个$n$元函数分别指定一个从$D^{n}$ 到$D$ 中的特定函数与之对应；  
（4）确定公式$G$ 中的每个$n$元谓词符号的具体形式，即对于公式$G$ 中每个$n$元谓词符号分别指定一个从$D^{n}$ 到$\{0,1\}$的特定函数与之对应。  
易知，对于任意一个给定的谓词公式，如果该公式是封闭公式，即不含有任何自由个体变量，则该公式在任何解释下均有确定的真值。  
由上述例题可知，与命题公式一样，有些谓词公式在有些解释下为真，在另外一些解释下为假；而有些谓词公式则在所有解释下均为真；还有一些谓词公式在所有解释下均为假。由此可以得到如下有效公式、矛盾公式和可满足公式的定义：  
【定义4.16】 对于任意一个给定的谓词公式$G$，如果$G$ 在其所有的解释$I$下的真值取值为真，则称$G$ 称为有效公式；如果$G$ 在其所有的解释$I$下的真值取值都为假，则称$G$为矛盾公式；如果$G$ 不是矛盾公式，则称其为可满足公式。  
从上述定义可知三种特殊公式之间具有如下关系：有效公式的否定为矛盾公式；矛盾公式的否定为有效公式；有效公式一定为可满足公式。",有效公式的否定为矛盾公式，矛盾公式的否定为有效公式
有效公式,包含,可满足公式,,"我们知道，对于一个命题公式，确定其真值取值状态是比较简单的，只需对命题公式中各个变量逐个指派真值便可得到命题公式的真值，而且在命题变量不是太多的情况下还可通过对命题变量真值指派的各种状态进行枚举的方式列出命题公式的真值表。然而，要确定一个谓词公式的真值取值状态，通常就没有这么简单了。  
例如，要确定谓词公式$(\forall x)(H(x){\rightarrow}D(x))$的真值，首先要确定其个体域，然后还要确定谓词$H(x)$和$D(x)$的具体含义。如果使用全总个体域$H(x)$表示 $x$是人$D(x)$表示 $x$会死的，则该谓词公式的取值为真，若将$D(x)$表示为 $x$是勇敢的，则谓词公式的取值为真为假。  
一般来说，对于任意给定的谓词公式，其含义与真值取值不仅依赖于个体域，依赖于公式中各个个体变量的取值状况，还依赖于对公式中谓词符号、函数符号、常量符号具体含义的确认，这些所有的依赖信息构成对谓词公式的解释。如果不对谓词公式中常量符号、变量符号、函数符号、谓词符号进行具体的解释，则公式就没有确定的含义和确定的真值取值.下面给出关于谓词公式解释的具体定义：  
【定义4.15】 谓词公式$G$的每一个解释$I$由如下四个部分组成：  
（1）确定非空的个体域集合$D$；  
（2）确定公式$G$ 中的每个常量符号的含义，即指定$D$ 中的某个特定的元素；  
（3）确定公式$G$ 中的每个$n$元函数的具体形式，即对于公式$G$ 中每个$n$元函数分别指定一个从$D^{n}$ 到$D$ 中的特定函数与之对应；  
（4）确定公式$G$ 中的每个$n$元谓词符号的具体形式，即对于公式$G$ 中每个$n$元谓词符号分别指定一个从$D^{n}$ 到$\{0,1\}$的特定函数与之对应。  
易知，对于任意一个给定的谓词公式，如果该公式是封闭公式，即不含有任何自由个体变量，则该公式在任何解释下均有确定的真值。  
由上述例题可知，与命题公式一样，有些谓词公式在有些解释下为真，在另外一些解释下为假；而有些谓词公式则在所有解释下均为真；还有一些谓词公式在所有解释下均为假。由此可以得到如下有效公式、矛盾公式和可满足公式的定义：  
【定义4.16】 对于任意一个给定的谓词公式$G$，如果$G$ 在其所有的解释$I$下的真值取值为真，则称$G$ 称为有效公式；如果$G$ 在其所有的解释$I$下的真值取值都为假，则称$G$为矛盾公式；如果$G$ 不是矛盾公式，则称其为可满足公式。  
从上述定义可知三种特殊公式之间具有如下关系：有效公式的否定为矛盾公式；矛盾公式的否定为有效公式；有效公式一定为可满足公式。",有效公式一定为可满足公式
谓词公式等值关系,共同作用,永真蕴含关系,,在命题逻辑中，命题公式之间的等值关系和永真蕴含关系是两种非常重要的基本关系，使用这两种关系，我们不仅可以对命题公式进行化简和适当的变形，而且还可以进行有效的命题推理。类似于命题逻辑，在谓词逻辑中也需要定义谓词公式之间的等值关系和永真蕴含关系来实现对谓词公式进行化简或适当的变形，更需要这两种关系进行谓词逻辑的推理。为此，本小节着重介绍和讨论谓词公式的等值关系和永真蕴含关系。,在谓词逻辑中，谓词公式等值关系和永真蕴含关系共同用于对谓词公式进行化简、变形和推理
谓词公式等值关系,定义,等值表达式,,"谓词公式等值关系的含义与命题公式等值关系很类似，是指两个谓词公式在任意相同的解释下具有完全相同的真值，表达的是两个谓词公式之间的恒等关系。下面借助谓词公式的概念给出谓词公式等值关系的具体定义：  
【定义4.17】 假设$G$ 和$H$ 是任意两个给定的谓词公式，若公式$G\leftrightarrow H$是有效公式，则称公式$G$ 和$H$ 称为等值的，记为$G\Leftrightarrow H$，并称$G\Leftrightarrow H$为等值表达式或等值式。  
由上述定义可知，判断两个谓词公式$G$ 和$H$是否等值，关键在于证明谓词公式$G\leftrightarrow H$为有效公式，这种思路与证明命题公式等值关系的基本思路是一致的。类似于命题公式的等值演算系统，在谓词公式的等值演算系统中，通常也是先证明出一些重要的谓词公式等值式，然后将这些重要谓词等值式作为基本等值式进一步推演出更多的谓词公式等值式，这种推演过程构成了谓词公式等值演算的主要内容。下面不加证明地给出这些重要而基本的谓词公式等值式，读者可自行给出证明。  
第一组  命题公式中永真公式的谓词公式代换实例显然是有效谓词公式。因此，按命题逻辑中24 个基本等值式模式使用谓词公式代换出来的实例必定是谓词公式等值式。例如：  
$\forall x P(x)\Leftrightarrow\neg\neg\forall x P(x);\;\;\forall x\exists y\big(H(x,y)\to R(x,y)\big)\Leftrightarrow\neg\neg\forall x\exists y\big(H(x,y)\to R(x,y)\big)$ 等都是双重否定律的代换实例。再如：  
$$
\forall x(\ P(x)\rightarrow Q(y))\rightarrow\exists z H(z)\Leftrightarrow\lnot\forall x(\ P(x)\rightarrow Q(y))\lor\exists z H(z)
$$  
等都是蕴含等值式的代替实例。  
第二组  关于量词的若干等值式：  
（1）消去量词等值式：设个体域$D$ 为有限集$\{x_{0},x_{1},\cdots,x_{n}\ \}$，则有： $\forall x P(x)\Leftrightarrow P(x_{0})\land P(x_{1})\land\cdots\land P(x_{n});\ \ \exists x P(x)\Leftrightarrow P(x_{0})\lor P(x_{1})\lor\cdots\lor P(x_{n})$  
（2）量词否定等值式：对于含有量词的谓词式$\forall x P(x)$和$\exists x Q(x)$，有：$\lnot\forall x P(x)\Leftrightarrow\exists x\lnot P(x);\;\;\lnot\exists x Q(x)\Leftrightarrow\forall x\lnot Q(x)$  
（3）量词辖域的收缩与扩张等值式：  
$$
\forall x(P(x)\lor S)\Leftrightarrow\forall x P(x)\lor S;\;\;\forall x(P(x)\land S)\Leftrightarrow\forall x P(x)\land S;
$$  
$$
\exists x(P(x)\lor S)\Leftrightarrow\exists x P(x)\lor S;\ \exists x(P(x)\land S)\Leftrightarrow\exists x P(x)\land S;
$$  
$$
\forall x(P(x)\rightarrow S)\Leftrightarrow\exists x P(x)\rightarrow S;\quad\exists x(P(x)\rightarrow S)\Leftrightarrow\forall x P(x)\rightarrow S;
$$  
$$
\forall x(S\rightarrow P(x))\Leftrightarrow S\rightarrow\forall x P(x);\ \exists x(S\rightarrow P(x))\Leftrightarrow S\rightarrow\exists x P(x)\\,
$$  
(4）量词分配等值式  
$$
\forall x(P(x)\land Q(x))\Leftrightarrow\forall x P(x)\land\forall x Q(x);\ \exists x(P(x)\lor Q(x))\Leftrightarrow\exists x P(x)\lor\exists x Q(x);
$$  
上述基本的等值关系式很多可以互相推导。特别是当个体域为有限集时，很容易理解上述等值关系的合理性。  
例如，假设$P(x)$表示$x$ 今天上课，个体域为计算机学院全体学生的集合，则：  
$(\forall x)P(x)$表示今天所有学生都上课了；$\neg(\forall x)P(x)$表示今天不是所有学生上课了；$(\exists x)\lnot P(x)$表示今天有学生没上课。即有：$\lnot(\forall x)P(x)\Leftrightarrow(\exists x)\lnot P(x).$。  
$(\exists x)P(x)$表示今天有学生上课；$\neg(\exists x)P(x)$表示今天没有学生上课；$(\forall x)\neg P(x)$表示今天所有学生都没上课。即有：$\lnot(\exists x)P(x)\Leftrightarrow(\forall x)\lnot P(x)\,$。  
再如，假设谓词$G(x)$表示$x$ 勤奋学习，谓词$H(x)$表示$x$ 喜欢体育运动，个体域是某大学里的全体学生。则有：  
谓词公式$(\forall x)(G(x)\land H(x))$表示：“某大学里的所有学生既勤奋学习又喜欢体育运动”；谓词公式$(\forall x)G(x)\land(\forall x)H(x).$表示：“某大学里的所有学生都勤奋学习且大学里的所有学生都喜欢体育运动”。两者含义显然相同，即有$\forall x(G(x)\land H(x))\Leftrightarrow\forall x G(x)\land\forall x H(x)\,$。  
谓词公式 $(\exists x)(G(x)\lor H(x))$表示：“某大学里有些学生勤奋学习或喜欢体育运动”；谓词公式$(\exists x)G(x)\lor(\exists x)H(x)$表示：“某大学里有些学生勤奋学习或大学里有些学生喜欢体育运动”。两者的含义显然相同，即有$\exists x(G(x)\lor H(x))\Leftrightarrow\exists x G(x)\lor\exists x H(x)\,\mathrm{s}$。",谓词公式等值关系是指两个谓词公式在任意相同的解释下具有完全相同的真值，等值表达式是表示这种关系的具体形式
谓词公式等值演算系统,包含,谓词公式等值关系,,"谓词公式等值关系的含义与命题公式等值关系很类似，是指两个谓词公式在任意相同的解释下具有完全相同的真值，表达的是两个谓词公式之间的恒等关系。下面借助谓词公式的概念给出谓词公式等值关系的具体定义：  
【定义4.17】 假设$G$ 和$H$ 是任意两个给定的谓词公式，若公式$G\leftrightarrow H$是有效公式，则称公式$G$ 和$H$ 称为等值的，记为$G\Leftrightarrow H$，并称$G\Leftrightarrow H$为等值表达式或等值式。  
由上述定义可知，判断两个谓词公式$G$ 和$H$是否等值，关键在于证明谓词公式$G\leftrightarrow H$为有效公式，这种思路与证明命题公式等值关系的基本思路是一致的。类似于命题公式的等值演算系统，在谓词公式的等值演算系统中，通常也是先证明出一些重要的谓词公式等值式，然后将这些重要谓词等值式作为基本等值式进一步推演出更多的谓词公式等值式，这种推演过程构成了谓词公式等值演算的主要内容。下面不加证明地给出这些重要而基本的谓词公式等值式，读者可自行给出证明。  
第一组  命题公式中永真公式的谓词公式代换实例显然是有效谓词公式。因此，按命题逻辑中24 个基本等值式模式使用谓词公式代换出来的实例必定是谓词公式等值式。例如：  
$\forall x P(x)\Leftrightarrow\neg\neg\forall x P(x);\;\;\forall x\exists y\big(H(x,y)\to R(x,y)\big)\Leftrightarrow\neg\neg\forall x\exists y\big(H(x,y)\to R(x,y)\big)$ 等都是双重否定律的代换实例。再如：  
$$
\forall x(\ P(x)\rightarrow Q(y))\rightarrow\exists z H(z)\Leftrightarrow\lnot\forall x(\ P(x)\rightarrow Q(y))\lor\exists z H(z)
$$  
等都是蕴含等值式的代替实例。  
第二组  关于量词的若干等值式：  
（1）消去量词等值式：设个体域$D$ 为有限集$\{x_{0},x_{1},\cdots,x_{n}\ \}$，则有： $\forall x P(x)\Leftrightarrow P(x_{0})\land P(x_{1})\land\cdots\land P(x_{n});\ \ \exists x P(x)\Leftrightarrow P(x_{0})\lor P(x_{1})\lor\cdots\lor P(x_{n})$  
（2）量词否定等值式：对于含有量词的谓词式$\forall x P(x)$和$\exists x Q(x)$，有：$\lnot\forall x P(x)\Leftrightarrow\exists x\lnot P(x);\;\;\lnot\exists x Q(x)\Leftrightarrow\forall x\lnot Q(x)$  
（3）量词辖域的收缩与扩张等值式：  
$$
\forall x(P(x)\lor S)\Leftrightarrow\forall x P(x)\lor S;\;\;\forall x(P(x)\land S)\Leftrightarrow\forall x P(x)\land S;
$$  
$$
\exists x(P(x)\lor S)\Leftrightarrow\exists x P(x)\lor S;\ \exists x(P(x)\land S)\Leftrightarrow\exists x P(x)\land S;
$$  
$$
\forall x(P(x)\rightarrow S)\Leftrightarrow\exists x P(x)\rightarrow S;\quad\exists x(P(x)\rightarrow S)\Leftrightarrow\forall x P(x)\rightarrow S;
$$  
$$
\forall x(S\rightarrow P(x))\Leftrightarrow S\rightarrow\forall x P(x);\ \exists x(S\rightarrow P(x))\Leftrightarrow S\rightarrow\exists x P(x)\\,
$$  
(4）量词分配等值式  
$$
\forall x(P(x)\land Q(x))\Leftrightarrow\forall x P(x)\land\forall x Q(x);\ \exists x(P(x)\lor Q(x))\Leftrightarrow\exists x P(x)\lor\exists x Q(x);
$$  
上述基本的等值关系式很多可以互相推导。特别是当个体域为有限集时，很容易理解上述等值关系的合理性。  
例如，假设$P(x)$表示$x$ 今天上课，个体域为计算机学院全体学生的集合，则：  
$(\forall x)P(x)$表示今天所有学生都上课了；$\neg(\forall x)P(x)$表示今天不是所有学生上课了；$(\exists x)\lnot P(x)$表示今天有学生没上课。即有：$\lnot(\forall x)P(x)\Leftrightarrow(\exists x)\lnot P(x).$。  
$(\exists x)P(x)$表示今天有学生上课；$\neg(\exists x)P(x)$表示今天没有学生上课；$(\forall x)\neg P(x)$表示今天所有学生都没上课。即有：$\lnot(\exists x)P(x)\Leftrightarrow(\forall x)\lnot P(x)\,$。  
再如，假设谓词$G(x)$表示$x$ 勤奋学习，谓词$H(x)$表示$x$ 喜欢体育运动，个体域是某大学里的全体学生。则有：  
谓词公式$(\forall x)(G(x)\land H(x))$表示：“某大学里的所有学生既勤奋学习又喜欢体育运动”；谓词公式$(\forall x)G(x)\land(\forall x)H(x).$表示：“某大学里的所有学生都勤奋学习且大学里的所有学生都喜欢体育运动”。两者含义显然相同，即有$\forall x(G(x)\land H(x))\Leftrightarrow\forall x G(x)\land\forall x H(x)\,$。  
谓词公式 $(\exists x)(G(x)\lor H(x))$表示：“某大学里有些学生勤奋学习或喜欢体育运动”；谓词公式$(\exists x)G(x)\lor(\exists x)H(x)$表示：“某大学里有些学生勤奋学习或大学里有些学生喜欢体育运动”。两者的含义显然相同，即有$\exists x(G(x)\lor H(x))\Leftrightarrow\exists x G(x)\lor\exists x H(x)\,\mathrm{s}$。",谓词公式等值演算系统包含一系列重要的谓词公式等值式，用于推演出更多的谓词公式等值关系
消去量词等值式,实例,谓词公式等值关系,,"谓词公式等值关系的含义与命题公式等值关系很类似，是指两个谓词公式在任意相同的解释下具有完全相同的真值，表达的是两个谓词公式之间的恒等关系。下面借助谓词公式的概念给出谓词公式等值关系的具体定义：  
【定义4.17】 假设$G$ 和$H$ 是任意两个给定的谓词公式，若公式$G\leftrightarrow H$是有效公式，则称公式$G$ 和$H$ 称为等值的，记为$G\Leftrightarrow H$，并称$G\Leftrightarrow H$为等值表达式或等值式。  
由上述定义可知，判断两个谓词公式$G$ 和$H$是否等值，关键在于证明谓词公式$G\leftrightarrow H$为有效公式，这种思路与证明命题公式等值关系的基本思路是一致的。类似于命题公式的等值演算系统，在谓词公式的等值演算系统中，通常也是先证明出一些重要的谓词公式等值式，然后将这些重要谓词等值式作为基本等值式进一步推演出更多的谓词公式等值式，这种推演过程构成了谓词公式等值演算的主要内容。下面不加证明地给出这些重要而基本的谓词公式等值式，读者可自行给出证明。  
第一组  命题公式中永真公式的谓词公式代换实例显然是有效谓词公式。因此，按命题逻辑中24 个基本等值式模式使用谓词公式代换出来的实例必定是谓词公式等值式。例如：  
$\forall x P(x)\Leftrightarrow\neg\neg\forall x P(x);\;\;\forall x\exists y\big(H(x,y)\to R(x,y)\big)\Leftrightarrow\neg\neg\forall x\exists y\big(H(x,y)\to R(x,y)\big)$ 等都是双重否定律的代换实例。再如：  
$$
\forall x(\ P(x)\rightarrow Q(y))\rightarrow\exists z H(z)\Leftrightarrow\lnot\forall x(\ P(x)\rightarrow Q(y))\lor\exists z H(z)
$$  
等都是蕴含等值式的代替实例。  
第二组  关于量词的若干等值式：  
（1）消去量词等值式：设个体域$D$ 为有限集$\{x_{0},x_{1},\cdots,x_{n}\ \}$，则有： $\forall x P(x)\Leftrightarrow P(x_{0})\land P(x_{1})\land\cdots\land P(x_{n});\ \ \exists x P(x)\Leftrightarrow P(x_{0})\lor P(x_{1})\lor\cdots\lor P(x_{n})$  
（2）量词否定等值式：对于含有量词的谓词式$\forall x P(x)$和$\exists x Q(x)$，有：$\lnot\forall x P(x)\Leftrightarrow\exists x\lnot P(x);\;\;\lnot\exists x Q(x)\Leftrightarrow\forall x\lnot Q(x)$  
（3）量词辖域的收缩与扩张等值式：  
$$
\forall x(P(x)\lor S)\Leftrightarrow\forall x P(x)\lor S;\;\;\forall x(P(x)\land S)\Leftrightarrow\forall x P(x)\land S;
$$  
$$
\exists x(P(x)\lor S)\Leftrightarrow\exists x P(x)\lor S;\ \exists x(P(x)\land S)\Leftrightarrow\exists x P(x)\land S;
$$  
$$
\forall x(P(x)\rightarrow S)\Leftrightarrow\exists x P(x)\rightarrow S;\quad\exists x(P(x)\rightarrow S)\Leftrightarrow\forall x P(x)\rightarrow S;
$$  
$$
\forall x(S\rightarrow P(x))\Leftrightarrow S\rightarrow\forall x P(x);\ \exists x(S\rightarrow P(x))\Leftrightarrow S\rightarrow\exists x P(x)\\,
$$  
(4）量词分配等值式  
$$
\forall x(P(x)\land Q(x))\Leftrightarrow\forall x P(x)\land\forall x Q(x);\ \exists x(P(x)\lor Q(x))\Leftrightarrow\exists x P(x)\lor\exists x Q(x);
$$  
上述基本的等值关系式很多可以互相推导。特别是当个体域为有限集时，很容易理解上述等值关系的合理性。  
例如，假设$P(x)$表示$x$ 今天上课，个体域为计算机学院全体学生的集合，则：  
$(\forall x)P(x)$表示今天所有学生都上课了；$\neg(\forall x)P(x)$表示今天不是所有学生上课了；$(\exists x)\lnot P(x)$表示今天有学生没上课。即有：$\lnot(\forall x)P(x)\Leftrightarrow(\exists x)\lnot P(x).$。  
$(\exists x)P(x)$表示今天有学生上课；$\neg(\exists x)P(x)$表示今天没有学生上课；$(\forall x)\neg P(x)$表示今天所有学生都没上课。即有：$\lnot(\exists x)P(x)\Leftrightarrow(\forall x)\lnot P(x)\,$。  
再如，假设谓词$G(x)$表示$x$ 勤奋学习，谓词$H(x)$表示$x$ 喜欢体育运动，个体域是某大学里的全体学生。则有：  
谓词公式$(\forall x)(G(x)\land H(x))$表示：“某大学里的所有学生既勤奋学习又喜欢体育运动”；谓词公式$(\forall x)G(x)\land(\forall x)H(x).$表示：“某大学里的所有学生都勤奋学习且大学里的所有学生都喜欢体育运动”。两者含义显然相同，即有$\forall x(G(x)\land H(x))\Leftrightarrow\forall x G(x)\land\forall x H(x)\,$。  
谓词公式 $(\exists x)(G(x)\lor H(x))$表示：“某大学里有些学生勤奋学习或喜欢体育运动”；谓词公式$(\exists x)G(x)\lor(\exists x)H(x)$表示：“某大学里有些学生勤奋学习或大学里有些学生喜欢体育运动”。两者的含义显然相同，即有$\exists x(G(x)\lor H(x))\Leftrightarrow\exists x G(x)\lor\exists x H(x)\,\mathrm{s}$。",消去量词等值式是谓词公式等值关系的一种具体实例，用于处理有限集上的量词消去
量词否定等值式,实例,谓词公式等值关系,,"谓词公式等值关系的含义与命题公式等值关系很类似，是指两个谓词公式在任意相同的解释下具有完全相同的真值，表达的是两个谓词公式之间的恒等关系。下面借助谓词公式的概念给出谓词公式等值关系的具体定义：  
【定义4.17】 假设$G$ 和$H$ 是任意两个给定的谓词公式，若公式$G\leftrightarrow H$是有效公式，则称公式$G$ 和$H$ 称为等值的，记为$G\Leftrightarrow H$，并称$G\Leftrightarrow H$为等值表达式或等值式。  
由上述定义可知，判断两个谓词公式$G$ 和$H$是否等值，关键在于证明谓词公式$G\leftrightarrow H$为有效公式，这种思路与证明命题公式等值关系的基本思路是一致的。类似于命题公式的等值演算系统，在谓词公式的等值演算系统中，通常也是先证明出一些重要的谓词公式等值式，然后将这些重要谓词等值式作为基本等值式进一步推演出更多的谓词公式等值式，这种推演过程构成了谓词公式等值演算的主要内容。下面不加证明地给出这些重要而基本的谓词公式等值式，读者可自行给出证明。  
第一组  命题公式中永真公式的谓词公式代换实例显然是有效谓词公式。因此，按命题逻辑中24 个基本等值式模式使用谓词公式代换出来的实例必定是谓词公式等值式。例如：  
$\forall x P(x)\Leftrightarrow\neg\neg\forall x P(x);\;\;\forall x\exists y\big(H(x,y)\to R(x,y)\big)\Leftrightarrow\neg\neg\forall x\exists y\big(H(x,y)\to R(x,y)\big)$ 等都是双重否定律的代换实例。再如：  
$$
\forall x(\ P(x)\rightarrow Q(y))\rightarrow\exists z H(z)\Leftrightarrow\lnot\forall x(\ P(x)\rightarrow Q(y))\lor\exists z H(z)
$$  
等都是蕴含等值式的代替实例。  
第二组  关于量词的若干等值式：  
（1）消去量词等值式：设个体域$D$ 为有限集$\{x_{0},x_{1},\cdots,x_{n}\ \}$，则有： $\forall x P(x)\Leftrightarrow P(x_{0})\land P(x_{1})\land\cdots\land P(x_{n});\ \ \exists x P(x)\Leftrightarrow P(x_{0})\lor P(x_{1})\lor\cdots\lor P(x_{n})$  
（2）量词否定等值式：对于含有量词的谓词式$\forall x P(x)$和$\exists x Q(x)$，有：$\lnot\forall x P(x)\Leftrightarrow\exists x\lnot P(x);\;\;\lnot\exists x Q(x)\Leftrightarrow\forall x\lnot Q(x)$  
（3）量词辖域的收缩与扩张等值式：  
$$
\forall x(P(x)\lor S)\Leftrightarrow\forall x P(x)\lor S;\;\;\forall x(P(x)\land S)\Leftrightarrow\forall x P(x)\land S;
$$  
$$
\exists x(P(x)\lor S)\Leftrightarrow\exists x P(x)\lor S;\ \exists x(P(x)\land S)\Leftrightarrow\exists x P(x)\land S;
$$  
$$
\forall x(P(x)\rightarrow S)\Leftrightarrow\exists x P(x)\rightarrow S;\quad\exists x(P(x)\rightarrow S)\Leftrightarrow\forall x P(x)\rightarrow S;
$$  
$$
\forall x(S\rightarrow P(x))\Leftrightarrow S\rightarrow\forall x P(x);\ \exists x(S\rightarrow P(x))\Leftrightarrow S\rightarrow\exists x P(x)\\,
$$  
(4）量词分配等值式  
$$
\forall x(P(x)\land Q(x))\Leftrightarrow\forall x P(x)\land\forall x Q(x);\ \exists x(P(x)\lor Q(x))\Leftrightarrow\exists x P(x)\lor\exists x Q(x);
$$  
上述基本的等值关系式很多可以互相推导。特别是当个体域为有限集时，很容易理解上述等值关系的合理性。  
例如，假设$P(x)$表示$x$ 今天上课，个体域为计算机学院全体学生的集合，则：  
$(\forall x)P(x)$表示今天所有学生都上课了；$\neg(\forall x)P(x)$表示今天不是所有学生上课了；$(\exists x)\lnot P(x)$表示今天有学生没上课。即有：$\lnot(\forall x)P(x)\Leftrightarrow(\exists x)\lnot P(x).$。  
$(\exists x)P(x)$表示今天有学生上课；$\neg(\exists x)P(x)$表示今天没有学生上课；$(\forall x)\neg P(x)$表示今天所有学生都没上课。即有：$\lnot(\exists x)P(x)\Leftrightarrow(\forall x)\lnot P(x)\,$。  
再如，假设谓词$G(x)$表示$x$ 勤奋学习，谓词$H(x)$表示$x$ 喜欢体育运动，个体域是某大学里的全体学生。则有：  
谓词公式$(\forall x)(G(x)\land H(x))$表示：“某大学里的所有学生既勤奋学习又喜欢体育运动”；谓词公式$(\forall x)G(x)\land(\forall x)H(x).$表示：“某大学里的所有学生都勤奋学习且大学里的所有学生都喜欢体育运动”。两者含义显然相同，即有$\forall x(G(x)\land H(x))\Leftrightarrow\forall x G(x)\land\forall x H(x)\,$。  
谓词公式 $(\exists x)(G(x)\lor H(x))$表示：“某大学里有些学生勤奋学习或喜欢体育运动”；谓词公式$(\exists x)G(x)\lor(\exists x)H(x)$表示：“某大学里有些学生勤奋学习或大学里有些学生喜欢体育运动”。两者的含义显然相同，即有$\exists x(G(x)\lor H(x))\Leftrightarrow\exists x G(x)\lor\exists x H(x)\,\mathrm{s}$。",量词否定等值式是谓词公式等值关系的一种具体实例，用于处理量词的否定
量词辖域的收缩与扩张等值式,实例,谓词公式等值关系,,"谓词公式等值关系的含义与命题公式等值关系很类似，是指两个谓词公式在任意相同的解释下具有完全相同的真值，表达的是两个谓词公式之间的恒等关系。下面借助谓词公式的概念给出谓词公式等值关系的具体定义：  
【定义4.17】 假设$G$ 和$H$ 是任意两个给定的谓词公式，若公式$G\leftrightarrow H$是有效公式，则称公式$G$ 和$H$ 称为等值的，记为$G\Leftrightarrow H$，并称$G\Leftrightarrow H$为等值表达式或等值式。  
由上述定义可知，判断两个谓词公式$G$ 和$H$是否等值，关键在于证明谓词公式$G\leftrightarrow H$为有效公式，这种思路与证明命题公式等值关系的基本思路是一致的。类似于命题公式的等值演算系统，在谓词公式的等值演算系统中，通常也是先证明出一些重要的谓词公式等值式，然后将这些重要谓词等值式作为基本等值式进一步推演出更多的谓词公式等值式，这种推演过程构成了谓词公式等值演算的主要内容。下面不加证明地给出这些重要而基本的谓词公式等值式，读者可自行给出证明。  
第一组  命题公式中永真公式的谓词公式代换实例显然是有效谓词公式。因此，按命题逻辑中24 个基本等值式模式使用谓词公式代换出来的实例必定是谓词公式等值式。例如：  
$\forall x P(x)\Leftrightarrow\neg\neg\forall x P(x);\;\;\forall x\exists y\big(H(x,y)\to R(x,y)\big)\Leftrightarrow\neg\neg\forall x\exists y\big(H(x,y)\to R(x,y)\big)$ 等都是双重否定律的代换实例。再如：  
$$
\forall x(\ P(x)\rightarrow Q(y))\rightarrow\exists z H(z)\Leftrightarrow\lnot\forall x(\ P(x)\rightarrow Q(y))\lor\exists z H(z)
$$  
等都是蕴含等值式的代替实例。  
第二组  关于量词的若干等值式：  
（1）消去量词等值式：设个体域$D$ 为有限集$\{x_{0},x_{1},\cdots,x_{n}\ \}$，则有： $\forall x P(x)\Leftrightarrow P(x_{0})\land P(x_{1})\land\cdots\land P(x_{n});\ \ \exists x P(x)\Leftrightarrow P(x_{0})\lor P(x_{1})\lor\cdots\lor P(x_{n})$  
（2）量词否定等值式：对于含有量词的谓词式$\forall x P(x)$和$\exists x Q(x)$，有：$\lnot\forall x P(x)\Leftrightarrow\exists x\lnot P(x);\;\;\lnot\exists x Q(x)\Leftrightarrow\forall x\lnot Q(x)$  
（3）量词辖域的收缩与扩张等值式：  
$$
\forall x(P(x)\lor S)\Leftrightarrow\forall x P(x)\lor S;\;\;\forall x(P(x)\land S)\Leftrightarrow\forall x P(x)\land S;
$$  
$$
\exists x(P(x)\lor S)\Leftrightarrow\exists x P(x)\lor S;\ \exists x(P(x)\land S)\Leftrightarrow\exists x P(x)\land S;
$$  
$$
\forall x(P(x)\rightarrow S)\Leftrightarrow\exists x P(x)\rightarrow S;\quad\exists x(P(x)\rightarrow S)\Leftrightarrow\forall x P(x)\rightarrow S;
$$  
$$
\forall x(S\rightarrow P(x))\Leftrightarrow S\rightarrow\forall x P(x);\ \exists x(S\rightarrow P(x))\Leftrightarrow S\rightarrow\exists x P(x)\\,
$$  
(4）量词分配等值式  
$$
\forall x(P(x)\land Q(x))\Leftrightarrow\forall x P(x)\land\forall x Q(x);\ \exists x(P(x)\lor Q(x))\Leftrightarrow\exists x P(x)\lor\exists x Q(x);
$$  
上述基本的等值关系式很多可以互相推导。特别是当个体域为有限集时，很容易理解上述等值关系的合理性。  
例如，假设$P(x)$表示$x$ 今天上课，个体域为计算机学院全体学生的集合，则：  
$(\forall x)P(x)$表示今天所有学生都上课了；$\neg(\forall x)P(x)$表示今天不是所有学生上课了；$(\exists x)\lnot P(x)$表示今天有学生没上课。即有：$\lnot(\forall x)P(x)\Leftrightarrow(\exists x)\lnot P(x).$。  
$(\exists x)P(x)$表示今天有学生上课；$\neg(\exists x)P(x)$表示今天没有学生上课；$(\forall x)\neg P(x)$表示今天所有学生都没上课。即有：$\lnot(\exists x)P(x)\Leftrightarrow(\forall x)\lnot P(x)\,$。  
再如，假设谓词$G(x)$表示$x$ 勤奋学习，谓词$H(x)$表示$x$ 喜欢体育运动，个体域是某大学里的全体学生。则有：  
谓词公式$(\forall x)(G(x)\land H(x))$表示：“某大学里的所有学生既勤奋学习又喜欢体育运动”；谓词公式$(\forall x)G(x)\land(\forall x)H(x).$表示：“某大学里的所有学生都勤奋学习且大学里的所有学生都喜欢体育运动”。两者含义显然相同，即有$\forall x(G(x)\land H(x))\Leftrightarrow\forall x G(x)\land\forall x H(x)\,$。  
谓词公式 $(\exists x)(G(x)\lor H(x))$表示：“某大学里有些学生勤奋学习或喜欢体育运动”；谓词公式$(\exists x)G(x)\lor(\exists x)H(x)$表示：“某大学里有些学生勤奋学习或大学里有些学生喜欢体育运动”。两者的含义显然相同，即有$\exists x(G(x)\lor H(x))\Leftrightarrow\exists x G(x)\lor\exists x H(x)\,\mathrm{s}$。",量词辖域的收缩与扩张等值式是谓词公式等值关系的一种具体实例，用于处理量词辖域的变化
量词分配等值式,实例,谓词公式等值关系,,"谓词公式等值关系的含义与命题公式等值关系很类似，是指两个谓词公式在任意相同的解释下具有完全相同的真值，表达的是两个谓词公式之间的恒等关系。下面借助谓词公式的概念给出谓词公式等值关系的具体定义：  
【定义4.17】 假设$G$ 和$H$ 是任意两个给定的谓词公式，若公式$G\leftrightarrow H$是有效公式，则称公式$G$ 和$H$ 称为等值的，记为$G\Leftrightarrow H$，并称$G\Leftrightarrow H$为等值表达式或等值式。  
由上述定义可知，判断两个谓词公式$G$ 和$H$是否等值，关键在于证明谓词公式$G\leftrightarrow H$为有效公式，这种思路与证明命题公式等值关系的基本思路是一致的。类似于命题公式的等值演算系统，在谓词公式的等值演算系统中，通常也是先证明出一些重要的谓词公式等值式，然后将这些重要谓词等值式作为基本等值式进一步推演出更多的谓词公式等值式，这种推演过程构成了谓词公式等值演算的主要内容。下面不加证明地给出这些重要而基本的谓词公式等值式，读者可自行给出证明。  
第一组  命题公式中永真公式的谓词公式代换实例显然是有效谓词公式。因此，按命题逻辑中24 个基本等值式模式使用谓词公式代换出来的实例必定是谓词公式等值式。例如：  
$\forall x P(x)\Leftrightarrow\neg\neg\forall x P(x);\;\;\forall x\exists y\big(H(x,y)\to R(x,y)\big)\Leftrightarrow\neg\neg\forall x\exists y\big(H(x,y)\to R(x,y)\big)$ 等都是双重否定律的代换实例。再如：  
$$
\forall x(\ P(x)\rightarrow Q(y))\rightarrow\exists z H(z)\Leftrightarrow\lnot\forall x(\ P(x)\rightarrow Q(y))\lor\exists z H(z)
$$  
等都是蕴含等值式的代替实例。  
第二组  关于量词的若干等值式：  
（1）消去量词等值式：设个体域$D$ 为有限集$\{x_{0},x_{1},\cdots,x_{n}\ \}$，则有： $\forall x P(x)\Leftrightarrow P(x_{0})\land P(x_{1})\land\cdots\land P(x_{n});\ \ \exists x P(x)\Leftrightarrow P(x_{0})\lor P(x_{1})\lor\cdots\lor P(x_{n})$  
（2）量词否定等值式：对于含有量词的谓词式$\forall x P(x)$和$\exists x Q(x)$，有：$\lnot\forall x P(x)\Leftrightarrow\exists x\lnot P(x);\;\;\lnot\exists x Q(x)\Leftrightarrow\forall x\lnot Q(x)$  
（3）量词辖域的收缩与扩张等值式：  
$$
\forall x(P(x)\lor S)\Leftrightarrow\forall x P(x)\lor S;\;\;\forall x(P(x)\land S)\Leftrightarrow\forall x P(x)\land S;
$$  
$$
\exists x(P(x)\lor S)\Leftrightarrow\exists x P(x)\lor S;\ \exists x(P(x)\land S)\Leftrightarrow\exists x P(x)\land S;
$$  
$$
\forall x(P(x)\rightarrow S)\Leftrightarrow\exists x P(x)\rightarrow S;\quad\exists x(P(x)\rightarrow S)\Leftrightarrow\forall x P(x)\rightarrow S;
$$  
$$
\forall x(S\rightarrow P(x))\Leftrightarrow S\rightarrow\forall x P(x);\ \exists x(S\rightarrow P(x))\Leftrightarrow S\rightarrow\exists x P(x)\\,
$$  
(4）量词分配等值式  
$$
\forall x(P(x)\land Q(x))\Leftrightarrow\forall x P(x)\land\forall x Q(x);\ \exists x(P(x)\lor Q(x))\Leftrightarrow\exists x P(x)\lor\exists x Q(x);
$$  
上述基本的等值关系式很多可以互相推导。特别是当个体域为有限集时，很容易理解上述等值关系的合理性。  
例如，假设$P(x)$表示$x$ 今天上课，个体域为计算机学院全体学生的集合，则：  
$(\forall x)P(x)$表示今天所有学生都上课了；$\neg(\forall x)P(x)$表示今天不是所有学生上课了；$(\exists x)\lnot P(x)$表示今天有学生没上课。即有：$\lnot(\forall x)P(x)\Leftrightarrow(\exists x)\lnot P(x).$。  
$(\exists x)P(x)$表示今天有学生上课；$\neg(\exists x)P(x)$表示今天没有学生上课；$(\forall x)\neg P(x)$表示今天所有学生都没上课。即有：$\lnot(\exists x)P(x)\Leftrightarrow(\forall x)\lnot P(x)\,$。  
再如，假设谓词$G(x)$表示$x$ 勤奋学习，谓词$H(x)$表示$x$ 喜欢体育运动，个体域是某大学里的全体学生。则有：  
谓词公式$(\forall x)(G(x)\land H(x))$表示：“某大学里的所有学生既勤奋学习又喜欢体育运动”；谓词公式$(\forall x)G(x)\land(\forall x)H(x).$表示：“某大学里的所有学生都勤奋学习且大学里的所有学生都喜欢体育运动”。两者含义显然相同，即有$\forall x(G(x)\land H(x))\Leftrightarrow\forall x G(x)\land\forall x H(x)\,$。  
谓词公式 $(\exists x)(G(x)\lor H(x))$表示：“某大学里有些学生勤奋学习或喜欢体育运动”；谓词公式$(\exists x)G(x)\lor(\exists x)H(x)$表示：“某大学里有些学生勤奋学习或大学里有些学生喜欢体育运动”。两者的含义显然相同，即有$\exists x(G(x)\lor H(x))\Leftrightarrow\exists x G(x)\lor\exists x H(x)\,\mathrm{s}$。",量词分配等值式是谓词公式等值关系的一种具体实例，用于处理量词的分配
谓词公式,使用,谓词公式的等值关系,,"如同多项式演算不仅要用到恒等式，还经常用到不等式，谓词公式的逻辑演算与推理也是不仅要用到谓词公式之间的等值关系，而且还需要用到谓词公式之间的蕴含关系。谓词公式之间的蕴含关系如同多项式代数系统中多项式之间的小于或等于关系， 具体地说， 所谓两 个谓词公式之间存在蕴含关系，其实就是两个谓词公式在任何解释下，其中一个谓词公式的真值永远不会大于另外一个谓词公式的真值。下面借助有效公式的概念给出具体定义：  
【定义4.18】假设$G$和$H$是任意两个谓词公式，如果谓词公式$G\rightarrow H$是有效公式，则称谓词公式$\pmb{G}$逻辑蕴含谓词公式$\pmb{H}$，亦称$G$ 与$H$之间具有逻辑蕴含关系，通常简称为蕴含关系，记作$G\Rightarrow H$，并称该式为谓词公式的逻辑蕴含式，通常简称为蕴含式。  
由上述定义可知，判断两个谓词公式$G$ 和$H$ 是否具有逻辑蕴含关系，关键在于证明谓词公式$G\rightarrow H$为有效公式，这种思路与证明命题公式永真蕴含关系的基本思路是一致的。类似于命题公式的永真蕴含演算系统，在谓词公式的逻辑蕴含演算系统中，通常也是先证明出一些重要的谓词公式蕴含式，然后将这些重要谓词蕴含式作为基本蕴含式进一步推演出更多的谓词公式蕴含式，这种推演过程构成了谓词公式蕴含演算的主要内容。下面不加证明地给出这些重要而基本的谓词公式蕴含式，读者可自行给出证明。  
由于谓词公式的逻辑蕴含式依据谓词公式的有效公式定义，而命题公式中永真公式的谓词公式代换实例显然是有效谓词公式，因此与前述谓词公式的等值式类似，前述命题逻辑中15 个基本永真蕴含式经过谓词公式代换后，就可以得到相应的谓词公式基本逻辑蕴含式。当然，由前述每组谓词公式基本等值式显然都可以得到两组相应的基本逻辑蕴含式，这里不再一一赘述。这里主要介绍如下与量词有关的逻辑蕴含式。  
【定理4.1】假设$G(x)$和$H(x)$是任意两个谓词公式，则存在如下逻辑蕴含关系：  
$$
\forall x G(x)\lor\forall x H(x)\Rightarrow\forall x(G(x)\lor H(x))\tag{4-7}
$$  
$$
\exists x(G(x)\land H(x))\Rightarrow\exists x G(x)\land\exists x H(x)\tag{4-8}
$$  
不难看出，上述定理的两个式子仅仅是蕴含式而不是等值式。例如对于（1）式如下解释，由这些人都跳舞或这些人都唱歌，可以推出这些人都跳舞或唱歌。但是反之不然，由这些人都跳舞或唱歌不能推出这些人都跳舞或这些人都唱歌。（2）式可做类似理解。",谓词公式的逻辑演算与推理需要用到谓词公式之间的等值关系
谓词公式,使用,谓词公式的蕴含关系,,"如同多项式演算不仅要用到恒等式，还经常用到不等式，谓词公式的逻辑演算与推理也是不仅要用到谓词公式之间的等值关系，而且还需要用到谓词公式之间的蕴含关系。谓词公式之间的蕴含关系如同多项式代数系统中多项式之间的小于或等于关系， 具体地说， 所谓两 个谓词公式之间存在蕴含关系，其实就是两个谓词公式在任何解释下，其中一个谓词公式的真值永远不会大于另外一个谓词公式的真值。下面借助有效公式的概念给出具体定义：  
【定义4.18】假设$G$和$H$是任意两个谓词公式，如果谓词公式$G\rightarrow H$是有效公式，则称谓词公式$\pmb{G}$逻辑蕴含谓词公式$\pmb{H}$，亦称$G$ 与$H$之间具有逻辑蕴含关系，通常简称为蕴含关系，记作$G\Rightarrow H$，并称该式为谓词公式的逻辑蕴含式，通常简称为蕴含式。  
由上述定义可知，判断两个谓词公式$G$ 和$H$ 是否具有逻辑蕴含关系，关键在于证明谓词公式$G\rightarrow H$为有效公式，这种思路与证明命题公式永真蕴含关系的基本思路是一致的。类似于命题公式的永真蕴含演算系统，在谓词公式的逻辑蕴含演算系统中，通常也是先证明出一些重要的谓词公式蕴含式，然后将这些重要谓词蕴含式作为基本蕴含式进一步推演出更多的谓词公式蕴含式，这种推演过程构成了谓词公式蕴含演算的主要内容。下面不加证明地给出这些重要而基本的谓词公式蕴含式，读者可自行给出证明。  
由于谓词公式的逻辑蕴含式依据谓词公式的有效公式定义，而命题公式中永真公式的谓词公式代换实例显然是有效谓词公式，因此与前述谓词公式的等值式类似，前述命题逻辑中15 个基本永真蕴含式经过谓词公式代换后，就可以得到相应的谓词公式基本逻辑蕴含式。当然，由前述每组谓词公式基本等值式显然都可以得到两组相应的基本逻辑蕴含式，这里不再一一赘述。这里主要介绍如下与量词有关的逻辑蕴含式。  
【定理4.1】假设$G(x)$和$H(x)$是任意两个谓词公式，则存在如下逻辑蕴含关系：  
$$
\forall x G(x)\lor\forall x H(x)\Rightarrow\forall x(G(x)\lor H(x))\tag{4-7}
$$  
$$
\exists x(G(x)\land H(x))\Rightarrow\exists x G(x)\land\exists x H(x)\tag{4-8}
$$  
不难看出，上述定理的两个式子仅仅是蕴含式而不是等值式。例如对于（1）式如下解释，由这些人都跳舞或这些人都唱歌，可以推出这些人都跳舞或唱歌。但是反之不然，由这些人都跳舞或唱歌不能推出这些人都跳舞或这些人都唱歌。（2）式可做类似理解。",谓词公式的逻辑演算与推理需要用到谓词公式之间的蕴含关系
谓词公式的蕴含关系,定义,逻辑蕴含式,,"如同多项式演算不仅要用到恒等式，还经常用到不等式，谓词公式的逻辑演算与推理也是不仅要用到谓词公式之间的等值关系，而且还需要用到谓词公式之间的蕴含关系。谓词公式之间的蕴含关系如同多项式代数系统中多项式之间的小于或等于关系， 具体地说， 所谓两 个谓词公式之间存在蕴含关系，其实就是两个谓词公式在任何解释下，其中一个谓词公式的真值永远不会大于另外一个谓词公式的真值。下面借助有效公式的概念给出具体定义：  
【定义4.18】假设$G$和$H$是任意两个谓词公式，如果谓词公式$G\rightarrow H$是有效公式，则称谓词公式$\pmb{G}$逻辑蕴含谓词公式$\pmb{H}$，亦称$G$ 与$H$之间具有逻辑蕴含关系，通常简称为蕴含关系，记作$G\Rightarrow H$，并称该式为谓词公式的逻辑蕴含式，通常简称为蕴含式。  
由上述定义可知，判断两个谓词公式$G$ 和$H$ 是否具有逻辑蕴含关系，关键在于证明谓词公式$G\rightarrow H$为有效公式，这种思路与证明命题公式永真蕴含关系的基本思路是一致的。类似于命题公式的永真蕴含演算系统，在谓词公式的逻辑蕴含演算系统中，通常也是先证明出一些重要的谓词公式蕴含式，然后将这些重要谓词蕴含式作为基本蕴含式进一步推演出更多的谓词公式蕴含式，这种推演过程构成了谓词公式蕴含演算的主要内容。下面不加证明地给出这些重要而基本的谓词公式蕴含式，读者可自行给出证明。  
由于谓词公式的逻辑蕴含式依据谓词公式的有效公式定义，而命题公式中永真公式的谓词公式代换实例显然是有效谓词公式，因此与前述谓词公式的等值式类似，前述命题逻辑中15 个基本永真蕴含式经过谓词公式代换后，就可以得到相应的谓词公式基本逻辑蕴含式。当然，由前述每组谓词公式基本等值式显然都可以得到两组相应的基本逻辑蕴含式，这里不再一一赘述。这里主要介绍如下与量词有关的逻辑蕴含式。  
【定理4.1】假设$G(x)$和$H(x)$是任意两个谓词公式，则存在如下逻辑蕴含关系：  
$$
\forall x G(x)\lor\forall x H(x)\Rightarrow\forall x(G(x)\lor H(x))\tag{4-7}
$$  
$$
\exists x(G(x)\land H(x))\Rightarrow\exists x G(x)\land\exists x H(x)\tag{4-8}
$$  
不难看出，上述定理的两个式子仅仅是蕴含式而不是等值式。例如对于（1）式如下解释，由这些人都跳舞或这些人都唱歌，可以推出这些人都跳舞或唱歌。但是反之不然，由这些人都跳舞或唱歌不能推出这些人都跳舞或这些人都唱歌。（2）式可做类似理解。",谓词公式之间的蕴含关系定义为逻辑蕴含式
逻辑蕴含式,推演,基本逻辑蕴含式,,"如同多项式演算不仅要用到恒等式，还经常用到不等式，谓词公式的逻辑演算与推理也是不仅要用到谓词公式之间的等值关系，而且还需要用到谓词公式之间的蕴含关系。谓词公式之间的蕴含关系如同多项式代数系统中多项式之间的小于或等于关系， 具体地说， 所谓两 个谓词公式之间存在蕴含关系，其实就是两个谓词公式在任何解释下，其中一个谓词公式的真值永远不会大于另外一个谓词公式的真值。下面借助有效公式的概念给出具体定义：  
【定义4.18】假设$G$和$H$是任意两个谓词公式，如果谓词公式$G\rightarrow H$是有效公式，则称谓词公式$\pmb{G}$逻辑蕴含谓词公式$\pmb{H}$，亦称$G$ 与$H$之间具有逻辑蕴含关系，通常简称为蕴含关系，记作$G\Rightarrow H$，并称该式为谓词公式的逻辑蕴含式，通常简称为蕴含式。  
由上述定义可知，判断两个谓词公式$G$ 和$H$ 是否具有逻辑蕴含关系，关键在于证明谓词公式$G\rightarrow H$为有效公式，这种思路与证明命题公式永真蕴含关系的基本思路是一致的。类似于命题公式的永真蕴含演算系统，在谓词公式的逻辑蕴含演算系统中，通常也是先证明出一些重要的谓词公式蕴含式，然后将这些重要谓词蕴含式作为基本蕴含式进一步推演出更多的谓词公式蕴含式，这种推演过程构成了谓词公式蕴含演算的主要内容。下面不加证明地给出这些重要而基本的谓词公式蕴含式，读者可自行给出证明。  
由于谓词公式的逻辑蕴含式依据谓词公式的有效公式定义，而命题公式中永真公式的谓词公式代换实例显然是有效谓词公式，因此与前述谓词公式的等值式类似，前述命题逻辑中15 个基本永真蕴含式经过谓词公式代换后，就可以得到相应的谓词公式基本逻辑蕴含式。当然，由前述每组谓词公式基本等值式显然都可以得到两组相应的基本逻辑蕴含式，这里不再一一赘述。这里主要介绍如下与量词有关的逻辑蕴含式。  
【定理4.1】假设$G(x)$和$H(x)$是任意两个谓词公式，则存在如下逻辑蕴含关系：  
$$
\forall x G(x)\lor\forall x H(x)\Rightarrow\forall x(G(x)\lor H(x))\tag{4-7}
$$  
$$
\exists x(G(x)\land H(x))\Rightarrow\exists x G(x)\land\exists x H(x)\tag{4-8}
$$  
不难看出，上述定理的两个式子仅仅是蕴含式而不是等值式。例如对于（1）式如下解释，由这些人都跳舞或这些人都唱歌，可以推出这些人都跳舞或唱歌。但是反之不然，由这些人都跳舞或唱歌不能推出这些人都跳舞或这些人都唱歌。（2）式可做类似理解。",通过基本逻辑蕴含式推演出更多的谓词公式蕴含式
定理4.1,描述,逻辑蕴含关系,,"如同多项式演算不仅要用到恒等式，还经常用到不等式，谓词公式的逻辑演算与推理也是不仅要用到谓词公式之间的等值关系，而且还需要用到谓词公式之间的蕴含关系。谓词公式之间的蕴含关系如同多项式代数系统中多项式之间的小于或等于关系， 具体地说， 所谓两 个谓词公式之间存在蕴含关系，其实就是两个谓词公式在任何解释下，其中一个谓词公式的真值永远不会大于另外一个谓词公式的真值。下面借助有效公式的概念给出具体定义：  
【定义4.18】假设$G$和$H$是任意两个谓词公式，如果谓词公式$G\rightarrow H$是有效公式，则称谓词公式$\pmb{G}$逻辑蕴含谓词公式$\pmb{H}$，亦称$G$ 与$H$之间具有逻辑蕴含关系，通常简称为蕴含关系，记作$G\Rightarrow H$，并称该式为谓词公式的逻辑蕴含式，通常简称为蕴含式。  
由上述定义可知，判断两个谓词公式$G$ 和$H$ 是否具有逻辑蕴含关系，关键在于证明谓词公式$G\rightarrow H$为有效公式，这种思路与证明命题公式永真蕴含关系的基本思路是一致的。类似于命题公式的永真蕴含演算系统，在谓词公式的逻辑蕴含演算系统中，通常也是先证明出一些重要的谓词公式蕴含式，然后将这些重要谓词蕴含式作为基本蕴含式进一步推演出更多的谓词公式蕴含式，这种推演过程构成了谓词公式蕴含演算的主要内容。下面不加证明地给出这些重要而基本的谓词公式蕴含式，读者可自行给出证明。  
由于谓词公式的逻辑蕴含式依据谓词公式的有效公式定义，而命题公式中永真公式的谓词公式代换实例显然是有效谓词公式，因此与前述谓词公式的等值式类似，前述命题逻辑中15 个基本永真蕴含式经过谓词公式代换后，就可以得到相应的谓词公式基本逻辑蕴含式。当然，由前述每组谓词公式基本等值式显然都可以得到两组相应的基本逻辑蕴含式，这里不再一一赘述。这里主要介绍如下与量词有关的逻辑蕴含式。  
【定理4.1】假设$G(x)$和$H(x)$是任意两个谓词公式，则存在如下逻辑蕴含关系：  
$$
\forall x G(x)\lor\forall x H(x)\Rightarrow\forall x(G(x)\lor H(x))\tag{4-7}
$$  
$$
\exists x(G(x)\land H(x))\Rightarrow\exists x G(x)\land\exists x H(x)\tag{4-8}
$$  
不难看出，上述定理的两个式子仅仅是蕴含式而不是等值式。例如对于（1）式如下解释，由这些人都跳舞或这些人都唱歌，可以推出这些人都跳舞或唱歌。但是反之不然，由这些人都跳舞或唱歌不能推出这些人都跳舞或这些人都唱歌。（2）式可做类似理解。",定理4.1描述了特定的逻辑蕴含关系
谓词公式,包含,双量词式,,"不失一般性，这只讨论两个量词的情况，更多量词的使用方法与此类似。因为对于含两个量词的谓词公式$(\forall x)(\forall y)B(x,y)$，若将其中$(\forall y)B(x,y)$视为$A(x)$，则$(\forall x)(\forall y)B(x,y)$便可视为$(\forall x)A(x)$。依此类推，含$n$个量词的谓词公式可依照含两个量词谓词公式的处理方法进行讨论。两个量词的谓词共有如下8 种排列情况，分别表示不同的含义：  
$(\ 1\ )(\exists x)(\exists y)A(x,y);~(\,2\,)~(\exists y)(\exists x)A(x,y);~(\,3\,)~(\forall x)(\exists y)A(x,y);~(\,4\,)~(\forall y)(\exists x)A(x,y)$  
$(\ 3\ )\exists x)(\forall y)A(x,y);\ \ \ (6)\ (\exists y)(\forall x)A(x,y);\ (7)\ (\forall x)(\forall y)A(x,y);\ (8)\ (\forall y)(\forall x)A(x,y)$","谓词公式可以包含双量词式，例如含两个量词的谓词公式$(\\forall x)(\\forall y)B(x,y)$"
双量词式,构成,谓词公式,,"不失一般性，这只讨论两个量词的情况，更多量词的使用方法与此类似。因为对于含两个量词的谓词公式$(\forall x)(\forall y)B(x,y)$，若将其中$(\forall y)B(x,y)$视为$A(x)$，则$(\forall x)(\forall y)B(x,y)$便可视为$(\forall x)A(x)$。依此类推，含$n$个量词的谓词公式可依照含两个量词谓词公式的处理方法进行讨论。两个量词的谓词共有如下8 种排列情况，分别表示不同的含义：  
$(\ 1\ )(\exists x)(\exists y)A(x,y);~(\,2\,)~(\exists y)(\exists x)A(x,y);~(\,3\,)~(\forall x)(\exists y)A(x,y);~(\,4\,)~(\forall y)(\exists x)A(x,y)$  
$(\ 3\ )\exists x)(\forall y)A(x,y);\ \ \ (6)\ (\exists y)(\forall x)A(x,y);\ (7)\ (\forall x)(\forall y)A(x,y);\ (8)\ (\forall y)(\forall x)A(x,y)$","双量词式构成谓词公式的一部分，如$(\\forall x)(\\forall y)B(x,y)$是含两个量词的谓词公式"
谓词公式,应用,等值演算,,"不失一般性，这只讨论两个量词的情况，更多量词的使用方法与此类似。因为对于含两个量词的谓词公式$(\forall x)(\forall y)B(x,y)$，若将其中$(\forall y)B(x,y)$视为$A(x)$，则$(\forall x)(\forall y)B(x,y)$便可视为$(\forall x)A(x)$。依此类推，含$n$个量词的谓词公式可依照含两个量词谓词公式的处理方法进行讨论。两个量词的谓词共有如下8 种排列情况，分别表示不同的含义：  
$(\ 1\ )(\exists x)(\exists y)A(x,y);~(\,2\,)~(\exists y)(\exists x)A(x,y);~(\,3\,)~(\forall x)(\exists y)A(x,y);~(\,4\,)~(\forall y)(\exists x)A(x,y)$  
$(\ 3\ )\exists x)(\forall y)A(x,y);\ \ \ (6)\ (\exists y)(\forall x)A(x,y);\ (7)\ (\forall x)(\forall y)A(x,y);\ (8)\ (\forall y)(\forall x)A(x,y)$","谓词公式可以通过等值演算进行简化，例如将$(\\forall x)(\\forall y)B(x,y)$视为$(\\forall x)A(x)$"
谓词公式的范式,属于,谓词逻辑,,"命题逻辑中每个命题公式都有一种统一的范式表达方式，当考察一个命题公式性质时，其范式表达方式通常起着非常重要的作用，有时候甚至是决定性作用。类似于命题逻辑，谓  
词逻辑也希望建立谓词公式的范式。由于谓词公式中存在个体变量和量词，因此其范式的建立比命题公式要复杂得多，而且所建立范式不满足唯一性要求，有的范式甚至不能满足等值。事实上，除了前束范式满足等值性之外，其它谓词公式范式均不满足等值性。值得注意的是，不满足等值性的范式有时也非常有用。例如斯科伦范式虽然不满足等值性，但对保持永真性或永假性具有保持性，可用于谓词逻辑推理。本节主要介绍两类典型的谓词公式范式，一类满足等值性，另一类不满足等值性。",谓词公式的范式是谓词逻辑中的一种表达方式
谓词公式的范式,包含,个体变量和量词,,"命题逻辑中每个命题公式都有一种统一的范式表达方式，当考察一个命题公式性质时，其范式表达方式通常起着非常重要的作用，有时候甚至是决定性作用。类似于命题逻辑，谓  
词逻辑也希望建立谓词公式的范式。由于谓词公式中存在个体变量和量词，因此其范式的建立比命题公式要复杂得多，而且所建立范式不满足唯一性要求，有的范式甚至不能满足等值。事实上，除了前束范式满足等值性之外，其它谓词公式范式均不满足等值性。值得注意的是，不满足等值性的范式有时也非常有用。例如斯科伦范式虽然不满足等值性，但对保持永真性或永假性具有保持性，可用于谓词逻辑推理。本节主要介绍两类典型的谓词公式范式，一类满足等值性，另一类不满足等值性。",谓词公式的范式包含个体变量和量词
谓词公式的范式,不满足,唯一性,,"命题逻辑中每个命题公式都有一种统一的范式表达方式，当考察一个命题公式性质时，其范式表达方式通常起着非常重要的作用，有时候甚至是决定性作用。类似于命题逻辑，谓  
词逻辑也希望建立谓词公式的范式。由于谓词公式中存在个体变量和量词，因此其范式的建立比命题公式要复杂得多，而且所建立范式不满足唯一性要求，有的范式甚至不能满足等值。事实上，除了前束范式满足等值性之外，其它谓词公式范式均不满足等值性。值得注意的是，不满足等值性的范式有时也非常有用。例如斯科伦范式虽然不满足等值性，但对保持永真性或永假性具有保持性，可用于谓词逻辑推理。本节主要介绍两类典型的谓词公式范式，一类满足等值性，另一类不满足等值性。",谓词公式的范式不满足唯一性要求
谓词公式的范式,部分满足,等值性,,"命题逻辑中每个命题公式都有一种统一的范式表达方式，当考察一个命题公式性质时，其范式表达方式通常起着非常重要的作用，有时候甚至是决定性作用。类似于命题逻辑，谓  
词逻辑也希望建立谓词公式的范式。由于谓词公式中存在个体变量和量词，因此其范式的建立比命题公式要复杂得多，而且所建立范式不满足唯一性要求，有的范式甚至不能满足等值。事实上，除了前束范式满足等值性之外，其它谓词公式范式均不满足等值性。值得注意的是，不满足等值性的范式有时也非常有用。例如斯科伦范式虽然不满足等值性，但对保持永真性或永假性具有保持性，可用于谓词逻辑推理。本节主要介绍两类典型的谓词公式范式，一类满足等值性，另一类不满足等值性。",除了前束范式满足等值性外，其它谓词公式范式均不满足等值性
谓词公式的范式,特例,斯科伦范式,,"命题逻辑中每个命题公式都有一种统一的范式表达方式，当考察一个命题公式性质时，其范式表达方式通常起着非常重要的作用，有时候甚至是决定性作用。类似于命题逻辑，谓  
词逻辑也希望建立谓词公式的范式。由于谓词公式中存在个体变量和量词，因此其范式的建立比命题公式要复杂得多，而且所建立范式不满足唯一性要求，有的范式甚至不能满足等值。事实上，除了前束范式满足等值性之外，其它谓词公式范式均不满足等值性。值得注意的是，不满足等值性的范式有时也非常有用。例如斯科伦范式虽然不满足等值性，但对保持永真性或永假性具有保持性，可用于谓词逻辑推理。本节主要介绍两类典型的谓词公式范式，一类满足等值性，另一类不满足等值性。",斯科伦范式是谓词公式范式的一种，不满足等值性但对保持永真性或永假性具有保持性
谓词公式的范式,应用,谓词逻辑推理,,"命题逻辑中每个命题公式都有一种统一的范式表达方式，当考察一个命题公式性质时，其范式表达方式通常起着非常重要的作用，有时候甚至是决定性作用。类似于命题逻辑，谓  
词逻辑也希望建立谓词公式的范式。由于谓词公式中存在个体变量和量词，因此其范式的建立比命题公式要复杂得多，而且所建立范式不满足唯一性要求，有的范式甚至不能满足等值。事实上，除了前束范式满足等值性之外，其它谓词公式范式均不满足等值性。值得注意的是，不满足等值性的范式有时也非常有用。例如斯科伦范式虽然不满足等值性，但对保持永真性或永假性具有保持性，可用于谓词逻辑推理。本节主要介绍两类典型的谓词公式范式，一类满足等值性，另一类不满足等值性。",谓词公式的范式可用于谓词逻辑推理
前束范式,满足,等值型范式,,前束范式是谓词公式中所有范式中唯一满足等值性质的方式。所谓满足等值性质，是指对于任意一个谓词公式，将其做规范化表示后所得到的范式与原谓词公式等值。本小节主要介绍前束范式的概念与构造方法。,前束范式是唯一满足等值性质的范式，即规范化表示后的范式与原谓词公式等值
前束型公式,存在性保证,定理4.2,,"在对谓词公式进行演算或推理等分析处理时，经常需要添加或消除量词。为了便于处理，特别是为了便于计算机的机械化处理，在添加或删除量词之前，将通过等值变换将谓词公式中所有量词移到公式的最前端，由此得到如下前束型谓词公式的概念：  
【定义4.19】假设$G$ 是任意一个谓词公式，如果$G$ 的一切量词都位于该公式的最前端(不含否定词)且这些量词的辖域都延伸到公式的末端，则称$G$ 是一个前束型公式。换句话说，谓词公式$G$ 作为前束型公式必须满足如下表达形式：  
$$
G\Leftrightarrow(Q_{1}x_{1})(Q_{1}x_{2})\cdots(Q_{n}x_{n})M(x_{1},x_{2},\cdots x_{n})\tag{4-11}
$$  
其中$Q_{i}$为量词$\forall$或$\exists$，$M$中不能含有任何量词，称$M$为谓词公式$G$ 的母式或基式。  
例如，$\forall x\forall y(G(x)\land H(y)\rightarrow R(x,y)),\,\,\,\forall x\forall y\exists z(G(x,y)\land H(z)\rightarrow R(x,y,z))$ 等都是束型公式。而下列公式$\forall x(G(x)\rightarrow\exists y(H(y)\land R(x,y)),\,\exists x(G(x)\land\forall y(H(y)\rightarrow R(x,y))∃𝑥(𝐺(𝑥) ∧∀y(𝐻(𝑦) →𝑅(𝑥, 𝑦))$等都不是前束型公式。下列定理保证了谓词公式前束型公式的存在性，但并不能保证唯一性。  
【定理4.2】任意一个含有量词的谓词公式都可以转化为与之等值的前束型公式的形式，但是这种形式并不唯一。",定理4.2保证了任意含有量词的谓词公式都可以转化为与之等值的前束型公式，但转化后的形式不唯一
前束范式,包含,前束析取范式,,"有了前束型公式，就不难得到前束范式。所谓前束范式，其实就是母式为析取范式或合取范式的前束型公式。前束范式的具体定义如下：  
【定义4.20】假设谓词公式$G$ 是任意一个前束型公式，即有：  
$$
G\Leftrightarrow(Q_{1}x_{1})(Q_{1}x_{2})\cdots(Q_{n}x_{n})M(x_{1},x_{2},\cdots x_{n})\tag{4-12}
$$  
其中$Q_{i}$为量词$\forall$或$∃$，$M$中不含有任何量词。如果$G$ 的母式$M$是一个析取范式，则称$G$ 是一个前束析取范式；如果$G$的母式$M$是一个合取范式，则称$G$ 是一前束合取范式。前束析取范式和前束合取范式统称为前束范式。  
例如，$(\forall x)(\exists y)(\forall z)((\lnot P(x)\lor R(x,y))\land(Q(x,y)));$就是一个前束合取范式。  
由于前束型谓词公式中的母式已不再含有量词，表达形式上类似于命题公式，因此可用类似于命题逻辑的方法将前束型公式中的母式转化为析取范式或合取范式，便可得到谓词公式的前束析取范式或者前束合取范式。  
【定理4.3】任意一个含有量词的谓词公式都分别存在与之等值的前束析取范式和前束合取范式，但范式的形式并不唯一。",前束范式包括前束析取范式
前束范式,包含,前束合取范式,,"有了前束型公式，就不难得到前束范式。所谓前束范式，其实就是母式为析取范式或合取范式的前束型公式。前束范式的具体定义如下：  
【定义4.20】假设谓词公式$G$ 是任意一个前束型公式，即有：  
$$
G\Leftrightarrow(Q_{1}x_{1})(Q_{1}x_{2})\cdots(Q_{n}x_{n})M(x_{1},x_{2},\cdots x_{n})\tag{4-12}
$$  
其中$Q_{i}$为量词$\forall$或$∃$，$M$中不含有任何量词。如果$G$ 的母式$M$是一个析取范式，则称$G$ 是一个前束析取范式；如果$G$的母式$M$是一个合取范式，则称$G$ 是一前束合取范式。前束析取范式和前束合取范式统称为前束范式。  
例如，$(\forall x)(\exists y)(\forall z)((\lnot P(x)\lor R(x,y))\land(Q(x,y)));$就是一个前束合取范式。  
由于前束型谓词公式中的母式已不再含有量词，表达形式上类似于命题公式，因此可用类似于命题逻辑的方法将前束型公式中的母式转化为析取范式或合取范式，便可得到谓词公式的前束析取范式或者前束合取范式。  
【定理4.3】任意一个含有量词的谓词公式都分别存在与之等值的前束析取范式和前束合取范式，但范式的形式并不唯一。",前束范式包括前束合取范式
前束析取范式,统称,前束合取范式,,"有了前束型公式，就不难得到前束范式。所谓前束范式，其实就是母式为析取范式或合取范式的前束型公式。前束范式的具体定义如下：  
【定义4.20】假设谓词公式$G$ 是任意一个前束型公式，即有：  
$$
G\Leftrightarrow(Q_{1}x_{1})(Q_{1}x_{2})\cdots(Q_{n}x_{n})M(x_{1},x_{2},\cdots x_{n})\tag{4-12}
$$  
其中$Q_{i}$为量词$\forall$或$∃$，$M$中不含有任何量词。如果$G$ 的母式$M$是一个析取范式，则称$G$ 是一个前束析取范式；如果$G$的母式$M$是一个合取范式，则称$G$ 是一前束合取范式。前束析取范式和前束合取范式统称为前束范式。  
例如，$(\forall x)(\exists y)(\forall z)((\lnot P(x)\lor R(x,y))\land(Q(x,y)));$就是一个前束合取范式。  
由于前束型谓词公式中的母式已不再含有量词，表达形式上类似于命题公式，因此可用类似于命题逻辑的方法将前束型公式中的母式转化为析取范式或合取范式，便可得到谓词公式的前束析取范式或者前束合取范式。  
【定理4.3】任意一个含有量词的谓词公式都分别存在与之等值的前束析取范式和前束合取范式，但范式的形式并不唯一。",前束析取范式和前束合取范式统称为前束范式
定理4.3,存在性,前束析取范式,,"有了前束型公式，就不难得到前束范式。所谓前束范式，其实就是母式为析取范式或合取范式的前束型公式。前束范式的具体定义如下：  
【定义4.20】假设谓词公式$G$ 是任意一个前束型公式，即有：  
$$
G\Leftrightarrow(Q_{1}x_{1})(Q_{1}x_{2})\cdots(Q_{n}x_{n})M(x_{1},x_{2},\cdots x_{n})\tag{4-12}
$$  
其中$Q_{i}$为量词$\forall$或$∃$，$M$中不含有任何量词。如果$G$ 的母式$M$是一个析取范式，则称$G$ 是一个前束析取范式；如果$G$的母式$M$是一个合取范式，则称$G$ 是一前束合取范式。前束析取范式和前束合取范式统称为前束范式。  
例如，$(\forall x)(\exists y)(\forall z)((\lnot P(x)\lor R(x,y))\land(Q(x,y)));$就是一个前束合取范式。  
由于前束型谓词公式中的母式已不再含有量词，表达形式上类似于命题公式，因此可用类似于命题逻辑的方法将前束型公式中的母式转化为析取范式或合取范式，便可得到谓词公式的前束析取范式或者前束合取范式。  
【定理4.3】任意一个含有量词的谓词公式都分别存在与之等值的前束析取范式和前束合取范式，但范式的形式并不唯一。",任意含有量词的谓词公式都存在与之等值的前束析取范式
定理4.3,存在性,前束合取范式,,"有了前束型公式，就不难得到前束范式。所谓前束范式，其实就是母式为析取范式或合取范式的前束型公式。前束范式的具体定义如下：  
【定义4.20】假设谓词公式$G$ 是任意一个前束型公式，即有：  
$$
G\Leftrightarrow(Q_{1}x_{1})(Q_{1}x_{2})\cdots(Q_{n}x_{n})M(x_{1},x_{2},\cdots x_{n})\tag{4-12}
$$  
其中$Q_{i}$为量词$\forall$或$∃$，$M$中不含有任何量词。如果$G$ 的母式$M$是一个析取范式，则称$G$ 是一个前束析取范式；如果$G$的母式$M$是一个合取范式，则称$G$ 是一前束合取范式。前束析取范式和前束合取范式统称为前束范式。  
例如，$(\forall x)(\exists y)(\forall z)((\lnot P(x)\lor R(x,y))\land(Q(x,y)));$就是一个前束合取范式。  
由于前束型谓词公式中的母式已不再含有量词，表达形式上类似于命题公式，因此可用类似于命题逻辑的方法将前束型公式中的母式转化为析取范式或合取范式，便可得到谓词公式的前束析取范式或者前束合取范式。  
【定理4.3】任意一个含有量词的谓词公式都分别存在与之等值的前束析取范式和前束合取范式，但范式的形式并不唯一。",任意含有量词的谓词公式都存在与之等值的前束合取范式
谓词公式的范式,包含,斯科伦范式,,前束范式虽然能够与原谓词公式等值，但是这种范式中的量词的排列不够规整。在谓词逻辑演算或推理中，有时候只需要判断某个公式是否为永真式或者矛盾式，此时并不一定需要等值演算，可以牺牲等值的要求得到一些量词排列更加规整的前束公式或前束范式。例如，可以要求谓词公式中所有存在量词排在所有全称量词的左边，或者保留所有的全称量词而消去所有的存在量词，这些都是所谓斯科伦范式或斯科伦标准型的由来。本小节简要介绍两种基本的斯科伦标准型，即∃型前束范式和无∃型前束范式。,斯科伦范式是谓词公式的范式的一种特殊形式，用于量词排列更加规整的前束公式或前束范式
谓词公式的范式,包含,斯科伦标准型,,前束范式虽然能够与原谓词公式等值，但是这种范式中的量词的排列不够规整。在谓词逻辑演算或推理中，有时候只需要判断某个公式是否为永真式或者矛盾式，此时并不一定需要等值演算，可以牺牲等值的要求得到一些量词排列更加规整的前束公式或前束范式。例如，可以要求谓词公式中所有存在量词排在所有全称量词的左边，或者保留所有的全称量词而消去所有的存在量词，这些都是所谓斯科伦范式或斯科伦标准型的由来。本小节简要介绍两种基本的斯科伦标准型，即∃型前束范式和无∃型前束范式。,斯科伦标准型是谓词公式的范式的一种特殊形式，用于量词排列更加规整的前束公式或前束范式
斯科伦范式,等价,斯科伦标准型,,前束范式虽然能够与原谓词公式等值，但是这种范式中的量词的排列不够规整。在谓词逻辑演算或推理中，有时候只需要判断某个公式是否为永真式或者矛盾式，此时并不一定需要等值演算，可以牺牲等值的要求得到一些量词排列更加规整的前束公式或前束范式。例如，可以要求谓词公式中所有存在量词排在所有全称量词的左边，或者保留所有的全称量词而消去所有的存在量词，这些都是所谓斯科伦范式或斯科伦标准型的由来。本小节简要介绍两种基本的斯科伦标准型，即∃型前束范式和无∃型前束范式。,斯科伦范式和斯科伦标准型是同一概念的不同表述，均用于量词排列更加规整的前束公式或前束范式
∃型前束范式,定义与性质,定理4.4,,"∃型前束范式将所有存在量词排在所有全称量词的左边，具体定义如下：  
【定义4.21】假设$G$ 是任意一个谓词公式，如果$G$ 具有如下形式：
$$
G\Leftrightarrow(\exists x_{1})(\exists x_{2})\cdots(\exists x_{i})(\forall x_{i+1})\cdots(\forall x_{n})M(x_{1},x_{2},\cdots x_{n})\tag{4-13}
$$  
即所有存在量词排在所有全称量词的左边且G中至少含有一个存在量词，则称$G$ 是一个∃型前束公式，其中$M(x_{1},x_{2},\cdots x_{n})$为公式的母式，要求既不含任何量词也无任何自由变量。如果∃型前束公式的模式是一个析取范式或合取范式，则称该∃型前束公式为∃型前束范式。  
例如，谓词公式$\exists z\exists w\forall x\forall y$$(\left(\neg P(x)\land\neg R(x,w)\right)\lor\left(\neg Q(z,y)\land\;\neg\;R(x,w)\right)$就是一个∃型前束析取范式。  
下面的定理给出了∃型前束范式的存在性以及在永真性保持上的性质。  
【定理4.4】假设$G$ 是任意一个谓词公式，则可将$G$ 转化为一个∃型前束范式，并且G是有效公式当且仅当其∃型前束范式也是一个有效公式。  
该定理表明有效谓词公式与其∃型前束范式等值，当一个谓词公式为有效公式时，便可使用其∃型前束范式进行演算。不过相对于前束范式的构造，∃型前束范式的构造稍微复杂一些，对于任意一个给定的谓词公式，其∃型前束范式的构造方法如下：  
第一步 将该谓词公式转化为前束型公式。  
第二步 将前束型公式转化为∃型前束范式。对于任意一个前束型公式$G$，显然只需将其转化为∃型前束公式即可，具体转化方法需要根据以下几种情况讨论：  
（1）当$G$ 中含有自由变量时，则需要将其每个自由变量分别加上相应的全称量词，使得谓词公式不再含有自由变量，即将公式变成一个闭式；  
（2）当$G$ 中不含自由变量且不含存在量词∃时，则需在公式中引入一个新的一元谓词及相应的个体变量$Q(u)$，得到一个新的公式：$\exists u(\iff G\land(Q(u)\lor\lnot Q(u)))$。然后将$G$中量词的辖域扩大到整个公式，即将$G$中所有量词提到$(G\wedge(Q(u)\vee\neg Q(u)))$的前面；  
（3）当$G$ 中不含自由变量且含有存在量词∃时，则需要通过引入新谓词的方法逐步将存在量词∃左边的全称量词$\forall$转化为存在量词$∃$。  
经过上述过程，便可将任意一个谓词公式转化为∃型前束型公式，从而可进一步转化为∃型前束范式。",定理4.4定义了∃型前束范式的存在性及其在永真性保持上的性质，指出任意谓词公式可转化为∃型前束范式，且有效公式与其∃型前束范式等值
谓词公式的范式,转化,无∃型前束范式,,"另外一种斯科伦范式是仅保留全称量词的前束范式，称之为无∃型前束范式。对于任意一个谓词公式，可由下列方法构造其无∃型前束范式：  
第一步  将该谓词公式转化为前束型公式。  
第二步  将前束型公式转化为无$∃$型前束公式：在含有存在量词的前束型公式中，从左边数第一个存在量词开始，依次消除每个存在量词。消除的规则如下：如果存在量词$\exists x$的左边有$n$个全称量词，则任取一个新的以这些全称量词的指导变元为自变量的𝑛元个体函数取代谓词公式中的所有$x$的出现。特别地，当$n=0$时，即$\exists x$的左边无全称量词，则在消除$\exists x$后，以论域中某个未在公式中出现的个体常量取代谓词公式中的所有$\cdot_{x}$的出现。  
第三步  将无∃型前束型公式中不含量词的部分，即母式部分转化为析取范式或合取范式，便可得到所求的无∃型前束范式。  
【定理4.5】假设$G$ 是任意一个谓词公式，则可将$G$ 转化为一个无∃型前束范式，并且$G$ 是永假公式当且仅当其无∃型前束范式也是一个永假公式。  
该定理表明永假式与其无∃型前束范式等值，当一个谓词公式为永假式时，便可使用其无∃型前束范式进行谓词演算和推理。",谓词公式的范式可以通过特定步骤转化为无∃型前束范式
无∃型前束范式,证明,定理4.5,,"另外一种斯科伦范式是仅保留全称量词的前束范式，称之为无∃型前束范式。对于任意一个谓词公式，可由下列方法构造其无∃型前束范式：  
第一步  将该谓词公式转化为前束型公式。  
第二步  将前束型公式转化为无$∃$型前束公式：在含有存在量词的前束型公式中，从左边数第一个存在量词开始，依次消除每个存在量词。消除的规则如下：如果存在量词$\exists x$的左边有$n$个全称量词，则任取一个新的以这些全称量词的指导变元为自变量的𝑛元个体函数取代谓词公式中的所有$x$的出现。特别地，当$n=0$时，即$\exists x$的左边无全称量词，则在消除$\exists x$后，以论域中某个未在公式中出现的个体常量取代谓词公式中的所有$\cdot_{x}$的出现。  
第三步  将无∃型前束型公式中不含量词的部分，即母式部分转化为析取范式或合取范式，便可得到所求的无∃型前束范式。  
【定理4.5】假设$G$ 是任意一个谓词公式，则可将$G$ 转化为一个无∃型前束范式，并且$G$ 是永假公式当且仅当其无∃型前束范式也是一个永假公式。  
该定理表明永假式与其无∃型前束范式等值，当一个谓词公式为永假式时，便可使用其无∃型前束范式进行谓词演算和推理。",定理4.5证明了任意谓词公式可以转化为无∃型前束范式，且永假公式与其无∃型前束范式等值
谓词逻辑的推理,延伸,命题逻辑的推理,,与命题逻辑类似，谓词逻辑的演绎推理是学习和研究谓词逻辑的主要目的。谓词逻辑的推理演算方法可以看成是命题逻辑推理演算方法的自然延伸。命题逻辑推理系统中的很多概念、等值式、永真蕴含式、推理规则和推证策略都可以在谓词逻辑推理中得到直接应用或类似应用。与命题逻辑推理不同的是，谓词公式中含有个体词、谓词、量词等新概念，具有比命题公式更加丰富、深刻、复杂的表达形式。因此，谓词逻辑推理需要引入一些新的规则来处理这些概念，从而得到比命题逻辑推理更加精细的推理结论。本节主要介绍谓词逻辑推理的基本知识，包括谓词公式的推演系统、谓词推证的基本方法以及谓词推理实例选讲。,谓词逻辑的推理演算方法是命题逻辑推理演算方法的自然延伸
谓词逻辑的推理,应用,命题逻辑推理系统中的概念,,与命题逻辑类似，谓词逻辑的演绎推理是学习和研究谓词逻辑的主要目的。谓词逻辑的推理演算方法可以看成是命题逻辑推理演算方法的自然延伸。命题逻辑推理系统中的很多概念、等值式、永真蕴含式、推理规则和推证策略都可以在谓词逻辑推理中得到直接应用或类似应用。与命题逻辑推理不同的是，谓词公式中含有个体词、谓词、量词等新概念，具有比命题公式更加丰富、深刻、复杂的表达形式。因此，谓词逻辑推理需要引入一些新的规则来处理这些概念，从而得到比命题逻辑推理更加精细的推理结论。本节主要介绍谓词逻辑推理的基本知识，包括谓词公式的推演系统、谓词推证的基本方法以及谓词推理实例选讲。,命题逻辑推理系统中的概念、等值式、永真蕴含式、推理规则和推证策略在谓词逻辑推理中得到直接应用或类似应用
谓词逻辑的推理,引入,新概念,,与命题逻辑类似，谓词逻辑的演绎推理是学习和研究谓词逻辑的主要目的。谓词逻辑的推理演算方法可以看成是命题逻辑推理演算方法的自然延伸。命题逻辑推理系统中的很多概念、等值式、永真蕴含式、推理规则和推证策略都可以在谓词逻辑推理中得到直接应用或类似应用。与命题逻辑推理不同的是，谓词公式中含有个体词、谓词、量词等新概念，具有比命题公式更加丰富、深刻、复杂的表达形式。因此，谓词逻辑推理需要引入一些新的规则来处理这些概念，从而得到比命题逻辑推理更加精细的推理结论。本节主要介绍谓词逻辑推理的基本知识，包括谓词公式的推演系统、谓词推证的基本方法以及谓词推理实例选讲。,谓词逻辑推理需要引入新的规则来处理个体词、谓词、量词等新概念
谓词逻辑的推理,精细化,推理结论,,与命题逻辑类似，谓词逻辑的演绎推理是学习和研究谓词逻辑的主要目的。谓词逻辑的推理演算方法可以看成是命题逻辑推理演算方法的自然延伸。命题逻辑推理系统中的很多概念、等值式、永真蕴含式、推理规则和推证策略都可以在谓词逻辑推理中得到直接应用或类似应用。与命题逻辑推理不同的是，谓词公式中含有个体词、谓词、量词等新概念，具有比命题公式更加丰富、深刻、复杂的表达形式。因此，谓词逻辑推理需要引入一些新的规则来处理这些概念，从而得到比命题逻辑推理更加精细的推理结论。本节主要介绍谓词逻辑推理的基本知识，包括谓词公式的推演系统、谓词推证的基本方法以及谓词推理实例选讲。,谓词逻辑推理得到比命题逻辑推理更加精细的推理结论
谓词公式推演系统,包含,谓词公式有效推理,,"谓词公式的推演系统与命题公式的推演系统非常类似，主要由有效推理的基本概念、事实库、公理库和推理规则这几个部分组成。事实库和公理库构成谓词公式推理的基本依据，推理规则是谓词公式推理的核心机制。谓词公式推演系统的公理库和推理规则不仅涵盖了命题公式的推演系统的所有相关内容，而且更加丰富、复杂。  
谓词公式有效推理的概念与命题逻辑推理非常相似，具体定义如下：  
【定义4.22】设$G_{1},G_{2}\cdots G_{n}$，$\mathrm{H}$ 是一些谓词公式，如果它们满足下列性质：对于这些公式的任意一个解释I，$G_{1},G_{2}\cdots G_{n}$在该解释下同时为真的情况下$H$在该解释下也为真，则称公式$G_{1},G_{2}\cdots G_{n}$可有效推出公式$\mathrm{H}$，或称由$G_{1},G_{2}\cdots G_{n}$得到H 的逻辑推理为有效推理，记为$G_{1},G_{2}\cdots G_{n}\Rightarrow H$，并称$G_{1},G_{2}\cdots G_{n}$为推理前提，$\mathrm{H}$ 为$G_{1},G_{2}\cdots G_{n}$的逻辑结论。  
从上述定义不难看出，谓词逻辑推理的形式结构与命题逻辑推理的形式结构一致，是命题逻辑推理的自然推广。  
【定理4.6】谓词公式$H$是谓词公式$G_{1},G_{2}\cdots G_{n}$的逻辑结论，当且仅当下式：  
$$
G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\to H\tag{4-14}
$$  
为有效公式。  
上述定理表明谓词逻辑有效推理的过程就是证明谓词逻辑蕴含式的过程，这与命题逻辑的有效推理完全一致。  
谓词公式的推理依据主要是谓词公式推演系统中的事实库和公理库。事实库由具体谓词逻辑推理实例的所有前提条件以及推理过程中产生的有效中间结论组成；公理库不仅包含命题逻辑推演系统的公理库，即关于命题公式的24 个基本等值式和9 个基本永真蕴含式，而且还包含了关于谓词公式的所有基本等值式和基本逻辑蕴含式，具体可参加本章4.2.4 节中相关内容，这里不再一一罗列。  
现在着重介绍谓词公式的推理规则。由于在谓词合式公式中含有大量的量词，直接对其进行推理显然十分不便。为此，谓词公式推演系统引入一些专门处理量词的规则，以便在需要的时候可以方便地增加或消除量词。谓词逻辑中主要有全称特指、存在特指、全称推广和存在推广这四条基本的量词处理规则，其中全称特指和存在特指消除量词的规则，全称推广和存在推广则是添加量词的规则。下面具体介绍这些规则：  
1．全称特指规则(简称US 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)\forall x\ P(x)\Rightarrow\ P(y);\ (2)\forall x\ P(x){\Rightarrow}\ P(c)
$$  
US 规则的基本含义是：如果$\forall x\;\;P(x)$为真，那么对于论域中任何指定的个体$.c$，必有${P(c)}$为真。其中，$P$ 是谓词，(1)中的$y$ 是任意不在$P(x)$中约束出现的个体变量；(2)中的c为个体域中任意指定的一个个体常量。  
当谓词公式$P(x)$中不含任何量词和其它个体变量时，$US $规则显然不需要附加任何限制条件。但是，若$P(x)$中包含量词或其它个体变量时，(1)式中的约束“$y$ 是任意不在$P(x)$中约束出现的个体变量”就是必须的。例如，设$P(x)=\exists y(x<y)$，则$P(x)$在实数域上显然是真命题。但是，当$P(x)$中的$x$取𝑦时得到的$P(y)=\exists y(y<y)$显然是假命题。因此，限制引入的变量“不是在$P(x)$中约束出现的个体变量”是任何规则在引入变量时必需遵守的约定。  
2．存在特指规则(简称ES 规则)
$$
\exists x\ P(x)\Rightarrow\ P(c)
$$  
ES 规则的基本含义是：如果$\exists x$ $P(x)$为真，那么在个体域中必然至少存在某一个个体𝑐，使得$P(c)$为真。其中，$c$ 为个体域中使$P$ 成立的特定个体常量。  
当谓词公式$P(x)$中自由变量只是$x$的时候，上述规定可以保证使用ES 规则引入个体符号$c$ 的正确性。但是，如果谓词公式$P(x)$还含有其它自由个体变量，例如还有自由变量𝑦，那么使用ES 规则引入的符号c必须是以𝑦为自变量的个体函数，即$C(y)$。此外，还应当注意，在应用ES 规则时，其指定的个体$c$ 并不是任意含义下的自由变量，$c$ 的本质含义是某个或某些个体。因此，每次使用ES 规则指定的特定个体不能用之前的ES 规则或US 规则确定的个体替代，否则就会引起个体指代的混淆和错误。因为通常不能保证某次ES 指定的个体能够与其它次ES 或US 指定的个体之间具有必然的联系。  
3．全称推广规则(简称UG 规则)：  
$$
P(\boldsymbol{y})\Rightarrow\ \forall\boldsymbol{x}\ \ P(\boldsymbol{x})
$$
UG 规则的基本含义是：如果个体变量$y$在个体域内取到每一个个体时都有$P(y)$为真，那么必有$\forall x\;\;P(x)$为真。这里要求$x$既不是$P(y)$中约束变量也不是$P(y)$中的自由变量，即要求个体变量$x$不能在$P(y)$中出现。  
4．存在推广规则(简称EG 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)P(y)\Rightarrow\ \exists x\ P(x);\ (2)P(c)\Rightarrow\ \exists x\ P(x)
$$  
UG 规则的基本含义是：如果对于个体域中某个或某些指定的个体$.c$满足$P(c)$为真，那么必有 $\exists x P(x)$为真。其中，(1)式要求$P(y)$中无自由变量$x$；(2)式中要求$c$为个体域中的某个或某些个体常量。  
由以上分析可知，上述四个规则表面上看起来非常简单，但要能够做到真正理解并正确使用则不是一件容易的事情，实际使用时往往稍不注意就会出现错误。下面举例说明：",谓词公式推演系统包含谓词公式有效推理的基本概念、事实库、公理库和推理规则
谓词公式推演系统,构成,谓词公式的推理依据,,"谓词公式的推演系统与命题公式的推演系统非常类似，主要由有效推理的基本概念、事实库、公理库和推理规则这几个部分组成。事实库和公理库构成谓词公式推理的基本依据，推理规则是谓词公式推理的核心机制。谓词公式推演系统的公理库和推理规则不仅涵盖了命题公式的推演系统的所有相关内容，而且更加丰富、复杂。  
谓词公式有效推理的概念与命题逻辑推理非常相似，具体定义如下：  
【定义4.22】设$G_{1},G_{2}\cdots G_{n}$，$\mathrm{H}$ 是一些谓词公式，如果它们满足下列性质：对于这些公式的任意一个解释I，$G_{1},G_{2}\cdots G_{n}$在该解释下同时为真的情况下$H$在该解释下也为真，则称公式$G_{1},G_{2}\cdots G_{n}$可有效推出公式$\mathrm{H}$，或称由$G_{1},G_{2}\cdots G_{n}$得到H 的逻辑推理为有效推理，记为$G_{1},G_{2}\cdots G_{n}\Rightarrow H$，并称$G_{1},G_{2}\cdots G_{n}$为推理前提，$\mathrm{H}$ 为$G_{1},G_{2}\cdots G_{n}$的逻辑结论。  
从上述定义不难看出，谓词逻辑推理的形式结构与命题逻辑推理的形式结构一致，是命题逻辑推理的自然推广。  
【定理4.6】谓词公式$H$是谓词公式$G_{1},G_{2}\cdots G_{n}$的逻辑结论，当且仅当下式：  
$$
G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\to H\tag{4-14}
$$  
为有效公式。  
上述定理表明谓词逻辑有效推理的过程就是证明谓词逻辑蕴含式的过程，这与命题逻辑的有效推理完全一致。  
谓词公式的推理依据主要是谓词公式推演系统中的事实库和公理库。事实库由具体谓词逻辑推理实例的所有前提条件以及推理过程中产生的有效中间结论组成；公理库不仅包含命题逻辑推演系统的公理库，即关于命题公式的24 个基本等值式和9 个基本永真蕴含式，而且还包含了关于谓词公式的所有基本等值式和基本逻辑蕴含式，具体可参加本章4.2.4 节中相关内容，这里不再一一罗列。  
现在着重介绍谓词公式的推理规则。由于在谓词合式公式中含有大量的量词，直接对其进行推理显然十分不便。为此，谓词公式推演系统引入一些专门处理量词的规则，以便在需要的时候可以方便地增加或消除量词。谓词逻辑中主要有全称特指、存在特指、全称推广和存在推广这四条基本的量词处理规则，其中全称特指和存在特指消除量词的规则，全称推广和存在推广则是添加量词的规则。下面具体介绍这些规则：  
1．全称特指规则(简称US 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)\forall x\ P(x)\Rightarrow\ P(y);\ (2)\forall x\ P(x){\Rightarrow}\ P(c)
$$  
US 规则的基本含义是：如果$\forall x\;\;P(x)$为真，那么对于论域中任何指定的个体$.c$，必有${P(c)}$为真。其中，$P$ 是谓词，(1)中的$y$ 是任意不在$P(x)$中约束出现的个体变量；(2)中的c为个体域中任意指定的一个个体常量。  
当谓词公式$P(x)$中不含任何量词和其它个体变量时，$US $规则显然不需要附加任何限制条件。但是，若$P(x)$中包含量词或其它个体变量时，(1)式中的约束“$y$ 是任意不在$P(x)$中约束出现的个体变量”就是必须的。例如，设$P(x)=\exists y(x<y)$，则$P(x)$在实数域上显然是真命题。但是，当$P(x)$中的$x$取𝑦时得到的$P(y)=\exists y(y<y)$显然是假命题。因此，限制引入的变量“不是在$P(x)$中约束出现的个体变量”是任何规则在引入变量时必需遵守的约定。  
2．存在特指规则(简称ES 规则)
$$
\exists x\ P(x)\Rightarrow\ P(c)
$$  
ES 规则的基本含义是：如果$\exists x$ $P(x)$为真，那么在个体域中必然至少存在某一个个体𝑐，使得$P(c)$为真。其中，$c$ 为个体域中使$P$ 成立的特定个体常量。  
当谓词公式$P(x)$中自由变量只是$x$的时候，上述规定可以保证使用ES 规则引入个体符号$c$ 的正确性。但是，如果谓词公式$P(x)$还含有其它自由个体变量，例如还有自由变量𝑦，那么使用ES 规则引入的符号c必须是以𝑦为自变量的个体函数，即$C(y)$。此外，还应当注意，在应用ES 规则时，其指定的个体$c$ 并不是任意含义下的自由变量，$c$ 的本质含义是某个或某些个体。因此，每次使用ES 规则指定的特定个体不能用之前的ES 规则或US 规则确定的个体替代，否则就会引起个体指代的混淆和错误。因为通常不能保证某次ES 指定的个体能够与其它次ES 或US 指定的个体之间具有必然的联系。  
3．全称推广规则(简称UG 规则)：  
$$
P(\boldsymbol{y})\Rightarrow\ \forall\boldsymbol{x}\ \ P(\boldsymbol{x})
$$
UG 规则的基本含义是：如果个体变量$y$在个体域内取到每一个个体时都有$P(y)$为真，那么必有$\forall x\;\;P(x)$为真。这里要求$x$既不是$P(y)$中约束变量也不是$P(y)$中的自由变量，即要求个体变量$x$不能在$P(y)$中出现。  
4．存在推广规则(简称EG 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)P(y)\Rightarrow\ \exists x\ P(x);\ (2)P(c)\Rightarrow\ \exists x\ P(x)
$$  
UG 规则的基本含义是：如果对于个体域中某个或某些指定的个体$.c$满足$P(c)$为真，那么必有 $\exists x P(x)$为真。其中，(1)式要求$P(y)$中无自由变量$x$；(2)式中要求$c$为个体域中的某个或某些个体常量。  
由以上分析可知，上述四个规则表面上看起来非常简单，但要能够做到真正理解并正确使用则不是一件容易的事情，实际使用时往往稍不注意就会出现错误。下面举例说明：",谓词公式推演系统中的事实库和公理库构成谓词公式的推理依据
谓词公式有效推理,一致,谓词逻辑推理的形式结构,,"谓词公式的推演系统与命题公式的推演系统非常类似，主要由有效推理的基本概念、事实库、公理库和推理规则这几个部分组成。事实库和公理库构成谓词公式推理的基本依据，推理规则是谓词公式推理的核心机制。谓词公式推演系统的公理库和推理规则不仅涵盖了命题公式的推演系统的所有相关内容，而且更加丰富、复杂。  
谓词公式有效推理的概念与命题逻辑推理非常相似，具体定义如下：  
【定义4.22】设$G_{1},G_{2}\cdots G_{n}$，$\mathrm{H}$ 是一些谓词公式，如果它们满足下列性质：对于这些公式的任意一个解释I，$G_{1},G_{2}\cdots G_{n}$在该解释下同时为真的情况下$H$在该解释下也为真，则称公式$G_{1},G_{2}\cdots G_{n}$可有效推出公式$\mathrm{H}$，或称由$G_{1},G_{2}\cdots G_{n}$得到H 的逻辑推理为有效推理，记为$G_{1},G_{2}\cdots G_{n}\Rightarrow H$，并称$G_{1},G_{2}\cdots G_{n}$为推理前提，$\mathrm{H}$ 为$G_{1},G_{2}\cdots G_{n}$的逻辑结论。  
从上述定义不难看出，谓词逻辑推理的形式结构与命题逻辑推理的形式结构一致，是命题逻辑推理的自然推广。  
【定理4.6】谓词公式$H$是谓词公式$G_{1},G_{2}\cdots G_{n}$的逻辑结论，当且仅当下式：  
$$
G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\to H\tag{4-14}
$$  
为有效公式。  
上述定理表明谓词逻辑有效推理的过程就是证明谓词逻辑蕴含式的过程，这与命题逻辑的有效推理完全一致。  
谓词公式的推理依据主要是谓词公式推演系统中的事实库和公理库。事实库由具体谓词逻辑推理实例的所有前提条件以及推理过程中产生的有效中间结论组成；公理库不仅包含命题逻辑推演系统的公理库，即关于命题公式的24 个基本等值式和9 个基本永真蕴含式，而且还包含了关于谓词公式的所有基本等值式和基本逻辑蕴含式，具体可参加本章4.2.4 节中相关内容，这里不再一一罗列。  
现在着重介绍谓词公式的推理规则。由于在谓词合式公式中含有大量的量词，直接对其进行推理显然十分不便。为此，谓词公式推演系统引入一些专门处理量词的规则，以便在需要的时候可以方便地增加或消除量词。谓词逻辑中主要有全称特指、存在特指、全称推广和存在推广这四条基本的量词处理规则，其中全称特指和存在特指消除量词的规则，全称推广和存在推广则是添加量词的规则。下面具体介绍这些规则：  
1．全称特指规则(简称US 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)\forall x\ P(x)\Rightarrow\ P(y);\ (2)\forall x\ P(x){\Rightarrow}\ P(c)
$$  
US 规则的基本含义是：如果$\forall x\;\;P(x)$为真，那么对于论域中任何指定的个体$.c$，必有${P(c)}$为真。其中，$P$ 是谓词，(1)中的$y$ 是任意不在$P(x)$中约束出现的个体变量；(2)中的c为个体域中任意指定的一个个体常量。  
当谓词公式$P(x)$中不含任何量词和其它个体变量时，$US $规则显然不需要附加任何限制条件。但是，若$P(x)$中包含量词或其它个体变量时，(1)式中的约束“$y$ 是任意不在$P(x)$中约束出现的个体变量”就是必须的。例如，设$P(x)=\exists y(x<y)$，则$P(x)$在实数域上显然是真命题。但是，当$P(x)$中的$x$取𝑦时得到的$P(y)=\exists y(y<y)$显然是假命题。因此，限制引入的变量“不是在$P(x)$中约束出现的个体变量”是任何规则在引入变量时必需遵守的约定。  
2．存在特指规则(简称ES 规则)
$$
\exists x\ P(x)\Rightarrow\ P(c)
$$  
ES 规则的基本含义是：如果$\exists x$ $P(x)$为真，那么在个体域中必然至少存在某一个个体𝑐，使得$P(c)$为真。其中，$c$ 为个体域中使$P$ 成立的特定个体常量。  
当谓词公式$P(x)$中自由变量只是$x$的时候，上述规定可以保证使用ES 规则引入个体符号$c$ 的正确性。但是，如果谓词公式$P(x)$还含有其它自由个体变量，例如还有自由变量𝑦，那么使用ES 规则引入的符号c必须是以𝑦为自变量的个体函数，即$C(y)$。此外，还应当注意，在应用ES 规则时，其指定的个体$c$ 并不是任意含义下的自由变量，$c$ 的本质含义是某个或某些个体。因此，每次使用ES 规则指定的特定个体不能用之前的ES 规则或US 规则确定的个体替代，否则就会引起个体指代的混淆和错误。因为通常不能保证某次ES 指定的个体能够与其它次ES 或US 指定的个体之间具有必然的联系。  
3．全称推广规则(简称UG 规则)：  
$$
P(\boldsymbol{y})\Rightarrow\ \forall\boldsymbol{x}\ \ P(\boldsymbol{x})
$$
UG 规则的基本含义是：如果个体变量$y$在个体域内取到每一个个体时都有$P(y)$为真，那么必有$\forall x\;\;P(x)$为真。这里要求$x$既不是$P(y)$中约束变量也不是$P(y)$中的自由变量，即要求个体变量$x$不能在$P(y)$中出现。  
4．存在推广规则(简称EG 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)P(y)\Rightarrow\ \exists x\ P(x);\ (2)P(c)\Rightarrow\ \exists x\ P(x)
$$  
UG 规则的基本含义是：如果对于个体域中某个或某些指定的个体$.c$满足$P(c)$为真，那么必有 $\exists x P(x)$为真。其中，(1)式要求$P(y)$中无自由变量$x$；(2)式中要求$c$为个体域中的某个或某些个体常量。  
由以上分析可知，上述四个规则表面上看起来非常简单，但要能够做到真正理解并正确使用则不是一件容易的事情，实际使用时往往稍不注意就会出现错误。下面举例说明：",谓词公式有效推理的形式结构与命题逻辑推理的形式结构一致
"谓词公式$H$是谓词公式$G_{1},G_{2}\\\\cdots G_{n}$的逻辑结论",体现,谓词逻辑有效推理,,"谓词公式的推演系统与命题公式的推演系统非常类似，主要由有效推理的基本概念、事实库、公理库和推理规则这几个部分组成。事实库和公理库构成谓词公式推理的基本依据，推理规则是谓词公式推理的核心机制。谓词公式推演系统的公理库和推理规则不仅涵盖了命题公式的推演系统的所有相关内容，而且更加丰富、复杂。  
谓词公式有效推理的概念与命题逻辑推理非常相似，具体定义如下：  
【定义4.22】设$G_{1},G_{2}\cdots G_{n}$，$\mathrm{H}$ 是一些谓词公式，如果它们满足下列性质：对于这些公式的任意一个解释I，$G_{1},G_{2}\cdots G_{n}$在该解释下同时为真的情况下$H$在该解释下也为真，则称公式$G_{1},G_{2}\cdots G_{n}$可有效推出公式$\mathrm{H}$，或称由$G_{1},G_{2}\cdots G_{n}$得到H 的逻辑推理为有效推理，记为$G_{1},G_{2}\cdots G_{n}\Rightarrow H$，并称$G_{1},G_{2}\cdots G_{n}$为推理前提，$\mathrm{H}$ 为$G_{1},G_{2}\cdots G_{n}$的逻辑结论。  
从上述定义不难看出，谓词逻辑推理的形式结构与命题逻辑推理的形式结构一致，是命题逻辑推理的自然推广。  
【定理4.6】谓词公式$H$是谓词公式$G_{1},G_{2}\cdots G_{n}$的逻辑结论，当且仅当下式：  
$$
G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\to H\tag{4-14}
$$  
为有效公式。  
上述定理表明谓词逻辑有效推理的过程就是证明谓词逻辑蕴含式的过程，这与命题逻辑的有效推理完全一致。  
谓词公式的推理依据主要是谓词公式推演系统中的事实库和公理库。事实库由具体谓词逻辑推理实例的所有前提条件以及推理过程中产生的有效中间结论组成；公理库不仅包含命题逻辑推演系统的公理库，即关于命题公式的24 个基本等值式和9 个基本永真蕴含式，而且还包含了关于谓词公式的所有基本等值式和基本逻辑蕴含式，具体可参加本章4.2.4 节中相关内容，这里不再一一罗列。  
现在着重介绍谓词公式的推理规则。由于在谓词合式公式中含有大量的量词，直接对其进行推理显然十分不便。为此，谓词公式推演系统引入一些专门处理量词的规则，以便在需要的时候可以方便地增加或消除量词。谓词逻辑中主要有全称特指、存在特指、全称推广和存在推广这四条基本的量词处理规则，其中全称特指和存在特指消除量词的规则，全称推广和存在推广则是添加量词的规则。下面具体介绍这些规则：  
1．全称特指规则(简称US 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)\forall x\ P(x)\Rightarrow\ P(y);\ (2)\forall x\ P(x){\Rightarrow}\ P(c)
$$  
US 规则的基本含义是：如果$\forall x\;\;P(x)$为真，那么对于论域中任何指定的个体$.c$，必有${P(c)}$为真。其中，$P$ 是谓词，(1)中的$y$ 是任意不在$P(x)$中约束出现的个体变量；(2)中的c为个体域中任意指定的一个个体常量。  
当谓词公式$P(x)$中不含任何量词和其它个体变量时，$US $规则显然不需要附加任何限制条件。但是，若$P(x)$中包含量词或其它个体变量时，(1)式中的约束“$y$ 是任意不在$P(x)$中约束出现的个体变量”就是必须的。例如，设$P(x)=\exists y(x<y)$，则$P(x)$在实数域上显然是真命题。但是，当$P(x)$中的$x$取𝑦时得到的$P(y)=\exists y(y<y)$显然是假命题。因此，限制引入的变量“不是在$P(x)$中约束出现的个体变量”是任何规则在引入变量时必需遵守的约定。  
2．存在特指规则(简称ES 规则)
$$
\exists x\ P(x)\Rightarrow\ P(c)
$$  
ES 规则的基本含义是：如果$\exists x$ $P(x)$为真，那么在个体域中必然至少存在某一个个体𝑐，使得$P(c)$为真。其中，$c$ 为个体域中使$P$ 成立的特定个体常量。  
当谓词公式$P(x)$中自由变量只是$x$的时候，上述规定可以保证使用ES 规则引入个体符号$c$ 的正确性。但是，如果谓词公式$P(x)$还含有其它自由个体变量，例如还有自由变量𝑦，那么使用ES 规则引入的符号c必须是以𝑦为自变量的个体函数，即$C(y)$。此外，还应当注意，在应用ES 规则时，其指定的个体$c$ 并不是任意含义下的自由变量，$c$ 的本质含义是某个或某些个体。因此，每次使用ES 规则指定的特定个体不能用之前的ES 规则或US 规则确定的个体替代，否则就会引起个体指代的混淆和错误。因为通常不能保证某次ES 指定的个体能够与其它次ES 或US 指定的个体之间具有必然的联系。  
3．全称推广规则(简称UG 规则)：  
$$
P(\boldsymbol{y})\Rightarrow\ \forall\boldsymbol{x}\ \ P(\boldsymbol{x})
$$
UG 规则的基本含义是：如果个体变量$y$在个体域内取到每一个个体时都有$P(y)$为真，那么必有$\forall x\;\;P(x)$为真。这里要求$x$既不是$P(y)$中约束变量也不是$P(y)$中的自由变量，即要求个体变量$x$不能在$P(y)$中出现。  
4．存在推广规则(简称EG 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)P(y)\Rightarrow\ \exists x\ P(x);\ (2)P(c)\Rightarrow\ \exists x\ P(x)
$$  
UG 规则的基本含义是：如果对于个体域中某个或某些指定的个体$.c$满足$P(c)$为真，那么必有 $\exists x P(x)$为真。其中，(1)式要求$P(y)$中无自由变量$x$；(2)式中要求$c$为个体域中的某个或某些个体常量。  
由以上分析可知，上述四个规则表面上看起来非常简单，但要能够做到真正理解并正确使用则不是一件容易的事情，实际使用时往往稍不注意就会出现错误。下面举例说明：","谓词公式$H$是谓词公式$G_{1},G_{2}\\\\cdots G_{n}$的逻辑结论体现了谓词逻辑有效推理的过程"
全称特指规则(US 规则),引入,谓词公式推演系统,,"谓词公式的推演系统与命题公式的推演系统非常类似，主要由有效推理的基本概念、事实库、公理库和推理规则这几个部分组成。事实库和公理库构成谓词公式推理的基本依据，推理规则是谓词公式推理的核心机制。谓词公式推演系统的公理库和推理规则不仅涵盖了命题公式的推演系统的所有相关内容，而且更加丰富、复杂。  
谓词公式有效推理的概念与命题逻辑推理非常相似，具体定义如下：  
【定义4.22】设$G_{1},G_{2}\cdots G_{n}$，$\mathrm{H}$ 是一些谓词公式，如果它们满足下列性质：对于这些公式的任意一个解释I，$G_{1},G_{2}\cdots G_{n}$在该解释下同时为真的情况下$H$在该解释下也为真，则称公式$G_{1},G_{2}\cdots G_{n}$可有效推出公式$\mathrm{H}$，或称由$G_{1},G_{2}\cdots G_{n}$得到H 的逻辑推理为有效推理，记为$G_{1},G_{2}\cdots G_{n}\Rightarrow H$，并称$G_{1},G_{2}\cdots G_{n}$为推理前提，$\mathrm{H}$ 为$G_{1},G_{2}\cdots G_{n}$的逻辑结论。  
从上述定义不难看出，谓词逻辑推理的形式结构与命题逻辑推理的形式结构一致，是命题逻辑推理的自然推广。  
【定理4.6】谓词公式$H$是谓词公式$G_{1},G_{2}\cdots G_{n}$的逻辑结论，当且仅当下式：  
$$
G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\to H\tag{4-14}
$$  
为有效公式。  
上述定理表明谓词逻辑有效推理的过程就是证明谓词逻辑蕴含式的过程，这与命题逻辑的有效推理完全一致。  
谓词公式的推理依据主要是谓词公式推演系统中的事实库和公理库。事实库由具体谓词逻辑推理实例的所有前提条件以及推理过程中产生的有效中间结论组成；公理库不仅包含命题逻辑推演系统的公理库，即关于命题公式的24 个基本等值式和9 个基本永真蕴含式，而且还包含了关于谓词公式的所有基本等值式和基本逻辑蕴含式，具体可参加本章4.2.4 节中相关内容，这里不再一一罗列。  
现在着重介绍谓词公式的推理规则。由于在谓词合式公式中含有大量的量词，直接对其进行推理显然十分不便。为此，谓词公式推演系统引入一些专门处理量词的规则，以便在需要的时候可以方便地增加或消除量词。谓词逻辑中主要有全称特指、存在特指、全称推广和存在推广这四条基本的量词处理规则，其中全称特指和存在特指消除量词的规则，全称推广和存在推广则是添加量词的规则。下面具体介绍这些规则：  
1．全称特指规则(简称US 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)\forall x\ P(x)\Rightarrow\ P(y);\ (2)\forall x\ P(x){\Rightarrow}\ P(c)
$$  
US 规则的基本含义是：如果$\forall x\;\;P(x)$为真，那么对于论域中任何指定的个体$.c$，必有${P(c)}$为真。其中，$P$ 是谓词，(1)中的$y$ 是任意不在$P(x)$中约束出现的个体变量；(2)中的c为个体域中任意指定的一个个体常量。  
当谓词公式$P(x)$中不含任何量词和其它个体变量时，$US $规则显然不需要附加任何限制条件。但是，若$P(x)$中包含量词或其它个体变量时，(1)式中的约束“$y$ 是任意不在$P(x)$中约束出现的个体变量”就是必须的。例如，设$P(x)=\exists y(x<y)$，则$P(x)$在实数域上显然是真命题。但是，当$P(x)$中的$x$取𝑦时得到的$P(y)=\exists y(y<y)$显然是假命题。因此，限制引入的变量“不是在$P(x)$中约束出现的个体变量”是任何规则在引入变量时必需遵守的约定。  
2．存在特指规则(简称ES 规则)
$$
\exists x\ P(x)\Rightarrow\ P(c)
$$  
ES 规则的基本含义是：如果$\exists x$ $P(x)$为真，那么在个体域中必然至少存在某一个个体𝑐，使得$P(c)$为真。其中，$c$ 为个体域中使$P$ 成立的特定个体常量。  
当谓词公式$P(x)$中自由变量只是$x$的时候，上述规定可以保证使用ES 规则引入个体符号$c$ 的正确性。但是，如果谓词公式$P(x)$还含有其它自由个体变量，例如还有自由变量𝑦，那么使用ES 规则引入的符号c必须是以𝑦为自变量的个体函数，即$C(y)$。此外，还应当注意，在应用ES 规则时，其指定的个体$c$ 并不是任意含义下的自由变量，$c$ 的本质含义是某个或某些个体。因此，每次使用ES 规则指定的特定个体不能用之前的ES 规则或US 规则确定的个体替代，否则就会引起个体指代的混淆和错误。因为通常不能保证某次ES 指定的个体能够与其它次ES 或US 指定的个体之间具有必然的联系。  
3．全称推广规则(简称UG 规则)：  
$$
P(\boldsymbol{y})\Rightarrow\ \forall\boldsymbol{x}\ \ P(\boldsymbol{x})
$$
UG 规则的基本含义是：如果个体变量$y$在个体域内取到每一个个体时都有$P(y)$为真，那么必有$\forall x\;\;P(x)$为真。这里要求$x$既不是$P(y)$中约束变量也不是$P(y)$中的自由变量，即要求个体变量$x$不能在$P(y)$中出现。  
4．存在推广规则(简称EG 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)P(y)\Rightarrow\ \exists x\ P(x);\ (2)P(c)\Rightarrow\ \exists x\ P(x)
$$  
UG 规则的基本含义是：如果对于个体域中某个或某些指定的个体$.c$满足$P(c)$为真，那么必有 $\exists x P(x)$为真。其中，(1)式要求$P(y)$中无自由变量$x$；(2)式中要求$c$为个体域中的某个或某些个体常量。  
由以上分析可知，上述四个规则表面上看起来非常简单，但要能够做到真正理解并正确使用则不是一件容易的事情，实际使用时往往稍不注意就会出现错误。下面举例说明：",谓词公式推演系统引入全称特指规则(US 规则)以处理量词
存在特指规则(ES 规则),引入,谓词公式推演系统,,"谓词公式的推演系统与命题公式的推演系统非常类似，主要由有效推理的基本概念、事实库、公理库和推理规则这几个部分组成。事实库和公理库构成谓词公式推理的基本依据，推理规则是谓词公式推理的核心机制。谓词公式推演系统的公理库和推理规则不仅涵盖了命题公式的推演系统的所有相关内容，而且更加丰富、复杂。  
谓词公式有效推理的概念与命题逻辑推理非常相似，具体定义如下：  
【定义4.22】设$G_{1},G_{2}\cdots G_{n}$，$\mathrm{H}$ 是一些谓词公式，如果它们满足下列性质：对于这些公式的任意一个解释I，$G_{1},G_{2}\cdots G_{n}$在该解释下同时为真的情况下$H$在该解释下也为真，则称公式$G_{1},G_{2}\cdots G_{n}$可有效推出公式$\mathrm{H}$，或称由$G_{1},G_{2}\cdots G_{n}$得到H 的逻辑推理为有效推理，记为$G_{1},G_{2}\cdots G_{n}\Rightarrow H$，并称$G_{1},G_{2}\cdots G_{n}$为推理前提，$\mathrm{H}$ 为$G_{1},G_{2}\cdots G_{n}$的逻辑结论。  
从上述定义不难看出，谓词逻辑推理的形式结构与命题逻辑推理的形式结构一致，是命题逻辑推理的自然推广。  
【定理4.6】谓词公式$H$是谓词公式$G_{1},G_{2}\cdots G_{n}$的逻辑结论，当且仅当下式：  
$$
G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\to H\tag{4-14}
$$  
为有效公式。  
上述定理表明谓词逻辑有效推理的过程就是证明谓词逻辑蕴含式的过程，这与命题逻辑的有效推理完全一致。  
谓词公式的推理依据主要是谓词公式推演系统中的事实库和公理库。事实库由具体谓词逻辑推理实例的所有前提条件以及推理过程中产生的有效中间结论组成；公理库不仅包含命题逻辑推演系统的公理库，即关于命题公式的24 个基本等值式和9 个基本永真蕴含式，而且还包含了关于谓词公式的所有基本等值式和基本逻辑蕴含式，具体可参加本章4.2.4 节中相关内容，这里不再一一罗列。  
现在着重介绍谓词公式的推理规则。由于在谓词合式公式中含有大量的量词，直接对其进行推理显然十分不便。为此，谓词公式推演系统引入一些专门处理量词的规则，以便在需要的时候可以方便地增加或消除量词。谓词逻辑中主要有全称特指、存在特指、全称推广和存在推广这四条基本的量词处理规则，其中全称特指和存在特指消除量词的规则，全称推广和存在推广则是添加量词的规则。下面具体介绍这些规则：  
1．全称特指规则(简称US 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)\forall x\ P(x)\Rightarrow\ P(y);\ (2)\forall x\ P(x){\Rightarrow}\ P(c)
$$  
US 规则的基本含义是：如果$\forall x\;\;P(x)$为真，那么对于论域中任何指定的个体$.c$，必有${P(c)}$为真。其中，$P$ 是谓词，(1)中的$y$ 是任意不在$P(x)$中约束出现的个体变量；(2)中的c为个体域中任意指定的一个个体常量。  
当谓词公式$P(x)$中不含任何量词和其它个体变量时，$US $规则显然不需要附加任何限制条件。但是，若$P(x)$中包含量词或其它个体变量时，(1)式中的约束“$y$ 是任意不在$P(x)$中约束出现的个体变量”就是必须的。例如，设$P(x)=\exists y(x<y)$，则$P(x)$在实数域上显然是真命题。但是，当$P(x)$中的$x$取𝑦时得到的$P(y)=\exists y(y<y)$显然是假命题。因此，限制引入的变量“不是在$P(x)$中约束出现的个体变量”是任何规则在引入变量时必需遵守的约定。  
2．存在特指规则(简称ES 规则)
$$
\exists x\ P(x)\Rightarrow\ P(c)
$$  
ES 规则的基本含义是：如果$\exists x$ $P(x)$为真，那么在个体域中必然至少存在某一个个体𝑐，使得$P(c)$为真。其中，$c$ 为个体域中使$P$ 成立的特定个体常量。  
当谓词公式$P(x)$中自由变量只是$x$的时候，上述规定可以保证使用ES 规则引入个体符号$c$ 的正确性。但是，如果谓词公式$P(x)$还含有其它自由个体变量，例如还有自由变量𝑦，那么使用ES 规则引入的符号c必须是以𝑦为自变量的个体函数，即$C(y)$。此外，还应当注意，在应用ES 规则时，其指定的个体$c$ 并不是任意含义下的自由变量，$c$ 的本质含义是某个或某些个体。因此，每次使用ES 规则指定的特定个体不能用之前的ES 规则或US 规则确定的个体替代，否则就会引起个体指代的混淆和错误。因为通常不能保证某次ES 指定的个体能够与其它次ES 或US 指定的个体之间具有必然的联系。  
3．全称推广规则(简称UG 规则)：  
$$
P(\boldsymbol{y})\Rightarrow\ \forall\boldsymbol{x}\ \ P(\boldsymbol{x})
$$
UG 规则的基本含义是：如果个体变量$y$在个体域内取到每一个个体时都有$P(y)$为真，那么必有$\forall x\;\;P(x)$为真。这里要求$x$既不是$P(y)$中约束变量也不是$P(y)$中的自由变量，即要求个体变量$x$不能在$P(y)$中出现。  
4．存在推广规则(简称EG 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)P(y)\Rightarrow\ \exists x\ P(x);\ (2)P(c)\Rightarrow\ \exists x\ P(x)
$$  
UG 规则的基本含义是：如果对于个体域中某个或某些指定的个体$.c$满足$P(c)$为真，那么必有 $\exists x P(x)$为真。其中，(1)式要求$P(y)$中无自由变量$x$；(2)式中要求$c$为个体域中的某个或某些个体常量。  
由以上分析可知，上述四个规则表面上看起来非常简单，但要能够做到真正理解并正确使用则不是一件容易的事情，实际使用时往往稍不注意就会出现错误。下面举例说明：",谓词公式推演系统引入存在特指规则(ES 规则)以处理量词
全称推广规则(UG 规则),引入,谓词公式推演系统,,"谓词公式的推演系统与命题公式的推演系统非常类似，主要由有效推理的基本概念、事实库、公理库和推理规则这几个部分组成。事实库和公理库构成谓词公式推理的基本依据，推理规则是谓词公式推理的核心机制。谓词公式推演系统的公理库和推理规则不仅涵盖了命题公式的推演系统的所有相关内容，而且更加丰富、复杂。  
谓词公式有效推理的概念与命题逻辑推理非常相似，具体定义如下：  
【定义4.22】设$G_{1},G_{2}\cdots G_{n}$，$\mathrm{H}$ 是一些谓词公式，如果它们满足下列性质：对于这些公式的任意一个解释I，$G_{1},G_{2}\cdots G_{n}$在该解释下同时为真的情况下$H$在该解释下也为真，则称公式$G_{1},G_{2}\cdots G_{n}$可有效推出公式$\mathrm{H}$，或称由$G_{1},G_{2}\cdots G_{n}$得到H 的逻辑推理为有效推理，记为$G_{1},G_{2}\cdots G_{n}\Rightarrow H$，并称$G_{1},G_{2}\cdots G_{n}$为推理前提，$\mathrm{H}$ 为$G_{1},G_{2}\cdots G_{n}$的逻辑结论。  
从上述定义不难看出，谓词逻辑推理的形式结构与命题逻辑推理的形式结构一致，是命题逻辑推理的自然推广。  
【定理4.6】谓词公式$H$是谓词公式$G_{1},G_{2}\cdots G_{n}$的逻辑结论，当且仅当下式：  
$$
G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\to H\tag{4-14}
$$  
为有效公式。  
上述定理表明谓词逻辑有效推理的过程就是证明谓词逻辑蕴含式的过程，这与命题逻辑的有效推理完全一致。  
谓词公式的推理依据主要是谓词公式推演系统中的事实库和公理库。事实库由具体谓词逻辑推理实例的所有前提条件以及推理过程中产生的有效中间结论组成；公理库不仅包含命题逻辑推演系统的公理库，即关于命题公式的24 个基本等值式和9 个基本永真蕴含式，而且还包含了关于谓词公式的所有基本等值式和基本逻辑蕴含式，具体可参加本章4.2.4 节中相关内容，这里不再一一罗列。  
现在着重介绍谓词公式的推理规则。由于在谓词合式公式中含有大量的量词，直接对其进行推理显然十分不便。为此，谓词公式推演系统引入一些专门处理量词的规则，以便在需要的时候可以方便地增加或消除量词。谓词逻辑中主要有全称特指、存在特指、全称推广和存在推广这四条基本的量词处理规则，其中全称特指和存在特指消除量词的规则，全称推广和存在推广则是添加量词的规则。下面具体介绍这些规则：  
1．全称特指规则(简称US 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)\forall x\ P(x)\Rightarrow\ P(y);\ (2)\forall x\ P(x){\Rightarrow}\ P(c)
$$  
US 规则的基本含义是：如果$\forall x\;\;P(x)$为真，那么对于论域中任何指定的个体$.c$，必有${P(c)}$为真。其中，$P$ 是谓词，(1)中的$y$ 是任意不在$P(x)$中约束出现的个体变量；(2)中的c为个体域中任意指定的一个个体常量。  
当谓词公式$P(x)$中不含任何量词和其它个体变量时，$US $规则显然不需要附加任何限制条件。但是，若$P(x)$中包含量词或其它个体变量时，(1)式中的约束“$y$ 是任意不在$P(x)$中约束出现的个体变量”就是必须的。例如，设$P(x)=\exists y(x<y)$，则$P(x)$在实数域上显然是真命题。但是，当$P(x)$中的$x$取𝑦时得到的$P(y)=\exists y(y<y)$显然是假命题。因此，限制引入的变量“不是在$P(x)$中约束出现的个体变量”是任何规则在引入变量时必需遵守的约定。  
2．存在特指规则(简称ES 规则)
$$
\exists x\ P(x)\Rightarrow\ P(c)
$$  
ES 规则的基本含义是：如果$\exists x$ $P(x)$为真，那么在个体域中必然至少存在某一个个体𝑐，使得$P(c)$为真。其中，$c$ 为个体域中使$P$ 成立的特定个体常量。  
当谓词公式$P(x)$中自由变量只是$x$的时候，上述规定可以保证使用ES 规则引入个体符号$c$ 的正确性。但是，如果谓词公式$P(x)$还含有其它自由个体变量，例如还有自由变量𝑦，那么使用ES 规则引入的符号c必须是以𝑦为自变量的个体函数，即$C(y)$。此外，还应当注意，在应用ES 规则时，其指定的个体$c$ 并不是任意含义下的自由变量，$c$ 的本质含义是某个或某些个体。因此，每次使用ES 规则指定的特定个体不能用之前的ES 规则或US 规则确定的个体替代，否则就会引起个体指代的混淆和错误。因为通常不能保证某次ES 指定的个体能够与其它次ES 或US 指定的个体之间具有必然的联系。  
3．全称推广规则(简称UG 规则)：  
$$
P(\boldsymbol{y})\Rightarrow\ \forall\boldsymbol{x}\ \ P(\boldsymbol{x})
$$
UG 规则的基本含义是：如果个体变量$y$在个体域内取到每一个个体时都有$P(y)$为真，那么必有$\forall x\;\;P(x)$为真。这里要求$x$既不是$P(y)$中约束变量也不是$P(y)$中的自由变量，即要求个体变量$x$不能在$P(y)$中出现。  
4．存在推广规则(简称EG 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)P(y)\Rightarrow\ \exists x\ P(x);\ (2)P(c)\Rightarrow\ \exists x\ P(x)
$$  
UG 规则的基本含义是：如果对于个体域中某个或某些指定的个体$.c$满足$P(c)$为真，那么必有 $\exists x P(x)$为真。其中，(1)式要求$P(y)$中无自由变量$x$；(2)式中要求$c$为个体域中的某个或某些个体常量。  
由以上分析可知，上述四个规则表面上看起来非常简单，但要能够做到真正理解并正确使用则不是一件容易的事情，实际使用时往往稍不注意就会出现错误。下面举例说明：",谓词公式推演系统引入全称推广规则(UG 规则)以处理量词
存在推广规则(EG 规则),引入,谓词公式推演系统,,"谓词公式的推演系统与命题公式的推演系统非常类似，主要由有效推理的基本概念、事实库、公理库和推理规则这几个部分组成。事实库和公理库构成谓词公式推理的基本依据，推理规则是谓词公式推理的核心机制。谓词公式推演系统的公理库和推理规则不仅涵盖了命题公式的推演系统的所有相关内容，而且更加丰富、复杂。  
谓词公式有效推理的概念与命题逻辑推理非常相似，具体定义如下：  
【定义4.22】设$G_{1},G_{2}\cdots G_{n}$，$\mathrm{H}$ 是一些谓词公式，如果它们满足下列性质：对于这些公式的任意一个解释I，$G_{1},G_{2}\cdots G_{n}$在该解释下同时为真的情况下$H$在该解释下也为真，则称公式$G_{1},G_{2}\cdots G_{n}$可有效推出公式$\mathrm{H}$，或称由$G_{1},G_{2}\cdots G_{n}$得到H 的逻辑推理为有效推理，记为$G_{1},G_{2}\cdots G_{n}\Rightarrow H$，并称$G_{1},G_{2}\cdots G_{n}$为推理前提，$\mathrm{H}$ 为$G_{1},G_{2}\cdots G_{n}$的逻辑结论。  
从上述定义不难看出，谓词逻辑推理的形式结构与命题逻辑推理的形式结构一致，是命题逻辑推理的自然推广。  
【定理4.6】谓词公式$H$是谓词公式$G_{1},G_{2}\cdots G_{n}$的逻辑结论，当且仅当下式：  
$$
G_{1}\wedge G_{2}\wedge\cdots\wedge G_{n}\to H\tag{4-14}
$$  
为有效公式。  
上述定理表明谓词逻辑有效推理的过程就是证明谓词逻辑蕴含式的过程，这与命题逻辑的有效推理完全一致。  
谓词公式的推理依据主要是谓词公式推演系统中的事实库和公理库。事实库由具体谓词逻辑推理实例的所有前提条件以及推理过程中产生的有效中间结论组成；公理库不仅包含命题逻辑推演系统的公理库，即关于命题公式的24 个基本等值式和9 个基本永真蕴含式，而且还包含了关于谓词公式的所有基本等值式和基本逻辑蕴含式，具体可参加本章4.2.4 节中相关内容，这里不再一一罗列。  
现在着重介绍谓词公式的推理规则。由于在谓词合式公式中含有大量的量词，直接对其进行推理显然十分不便。为此，谓词公式推演系统引入一些专门处理量词的规则，以便在需要的时候可以方便地增加或消除量词。谓词逻辑中主要有全称特指、存在特指、全称推广和存在推广这四条基本的量词处理规则，其中全称特指和存在特指消除量词的规则，全称推广和存在推广则是添加量词的规则。下面具体介绍这些规则：  
1．全称特指规则(简称US 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)\forall x\ P(x)\Rightarrow\ P(y);\ (2)\forall x\ P(x){\Rightarrow}\ P(c)
$$  
US 规则的基本含义是：如果$\forall x\;\;P(x)$为真，那么对于论域中任何指定的个体$.c$，必有${P(c)}$为真。其中，$P$ 是谓词，(1)中的$y$ 是任意不在$P(x)$中约束出现的个体变量；(2)中的c为个体域中任意指定的一个个体常量。  
当谓词公式$P(x)$中不含任何量词和其它个体变量时，$US $规则显然不需要附加任何限制条件。但是，若$P(x)$中包含量词或其它个体变量时，(1)式中的约束“$y$ 是任意不在$P(x)$中约束出现的个体变量”就是必须的。例如，设$P(x)=\exists y(x<y)$，则$P(x)$在实数域上显然是真命题。但是，当$P(x)$中的$x$取𝑦时得到的$P(y)=\exists y(y<y)$显然是假命题。因此，限制引入的变量“不是在$P(x)$中约束出现的个体变量”是任何规则在引入变量时必需遵守的约定。  
2．存在特指规则(简称ES 规则)
$$
\exists x\ P(x)\Rightarrow\ P(c)
$$  
ES 规则的基本含义是：如果$\exists x$ $P(x)$为真，那么在个体域中必然至少存在某一个个体𝑐，使得$P(c)$为真。其中，$c$ 为个体域中使$P$ 成立的特定个体常量。  
当谓词公式$P(x)$中自由变量只是$x$的时候，上述规定可以保证使用ES 规则引入个体符号$c$ 的正确性。但是，如果谓词公式$P(x)$还含有其它自由个体变量，例如还有自由变量𝑦，那么使用ES 规则引入的符号c必须是以𝑦为自变量的个体函数，即$C(y)$。此外，还应当注意，在应用ES 规则时，其指定的个体$c$ 并不是任意含义下的自由变量，$c$ 的本质含义是某个或某些个体。因此，每次使用ES 规则指定的特定个体不能用之前的ES 规则或US 规则确定的个体替代，否则就会引起个体指代的混淆和错误。因为通常不能保证某次ES 指定的个体能够与其它次ES 或US 指定的个体之间具有必然的联系。  
3．全称推广规则(简称UG 规则)：  
$$
P(\boldsymbol{y})\Rightarrow\ \forall\boldsymbol{x}\ \ P(\boldsymbol{x})
$$
UG 规则的基本含义是：如果个体变量$y$在个体域内取到每一个个体时都有$P(y)$为真，那么必有$\forall x\;\;P(x)$为真。这里要求$x$既不是$P(y)$中约束变量也不是$P(y)$中的自由变量，即要求个体变量$x$不能在$P(y)$中出现。  
4．存在推广规则(简称EG 规则)：这条规则具有如下两种基本形式，即：  
$$
(1)P(y)\Rightarrow\ \exists x\ P(x);\ (2)P(c)\Rightarrow\ \exists x\ P(x)
$$  
UG 规则的基本含义是：如果对于个体域中某个或某些指定的个体$.c$满足$P(c)$为真，那么必有 $\exists x P(x)$为真。其中，(1)式要求$P(y)$中无自由变量$x$；(2)式中要求$c$为个体域中的某个或某些个体常量。  
由以上分析可知，上述四个规则表面上看起来非常简单，但要能够做到真正理解并正确使用则不是一件容易的事情，实际使用时往往稍不注意就会出现错误。下面举例说明：",谓词公式推演系统引入存在推广规则(EG 规则)以处理量词
谓词逻辑,包含,谓词逻辑推理,,"我们知道，谓词逻辑是命题逻辑的一种自然扩展，谓词逻辑的知识体系完全涵盖了命题逻辑的知识体系，或者说命题逻辑是谓词逻辑的一种特例。因此，命题逻辑推演系统的全部知识完全可以照搬到命题逻辑推演系统之中，可以将命题推理的T 规则、 规则和CP 规则，以及命题推理的基本策略例如直接证明法和间接证明法等，直接应用于谓词逻辑的推理。  
另外一方面，我们也应该注意到谓词逻辑与命题逻辑之间最大的区别在于谓词逻辑引进了个体域、个体词、量词，以及由此而产生的约束变量和自由变量。因此，在考虑和处理谓词推理问题时，不能单纯地将其看成是命题逻辑推理，还需要根据谓词逻辑的特点采用适当的方法。其中最为关键的是如下几个基本要点：  
第一、在谓词逻辑中，一般无法在不同个体域基础上衡量两个谓词公式之间的等值关系或逻辑蕴含关系，就像两种不同类型的东西无法进行比较一样。因此，在谓词逻辑演算和推理过程中，我们总是假定所有的谓词公式具有相同的个体域，一般默认为全总个体域。  
第二、谓词逻辑推演的基本思路，一般是首先根据$US$和$E S$ 规则消除谓词公式中的量词，把谓词公式的推理问题转化为命题公式的推理问题，在使用命题公式的推理策略和方法完成相关的推理后，再根据具体需要使用UG 和$E G$规则，将基于命题公式的推理结论还原成谓词公式的推理结论。  
第三、在谓词逻辑的推演过程中，可以引用命题演算中的$P$ 规则和$T$ 规则，如果结论是以蕴涵形式或析取形式给出，还可使用$C P$ 规则。对含有量词的公式可以引用谓词中的基本等值公式和基本蕴涵公式，对于已经消去量词的谓词公式或谓词公式中不含量词的子公式，完全可以引用命题演算中的基本等价公式和基本蕴涵公式。  
下面结合实例介绍谓词逻辑推证的基本方法。首先，我们使用谓词逻辑推理来解决在本章开头提及的苏格拉底三段论问题：  
从以上例题的证明过程可以看出，在谓词演算的推证过程中，必须注意遵守所使用各项推理规则的限制条件，正确合理地使用推理规则。当既需要消除存在量词，由需要消除全称量词的时候，一般都是先消除存在量词，后消除全称量词，被消除或新添加的量词必须位于谓词公式的最左边。当需要推证的结论为蕴含式的时候，可以考虑使用附加前提证明法。当证明给出的前提条件较少且多为蕴含式或析取式时，会感到无从下手，此时可以考虑使用反证法，将结论的否定作为附加前提引入，以增加可用的前提。",谓词逻辑的知识体系完全涵盖了命题逻辑的知识体系，可以将命题推理的规则和策略直接应用于谓词逻辑的推理
谓词逻辑,基础,谓词演算,,"我们知道，谓词逻辑是命题逻辑的一种自然扩展，谓词逻辑的知识体系完全涵盖了命题逻辑的知识体系，或者说命题逻辑是谓词逻辑的一种特例。因此，命题逻辑推演系统的全部知识完全可以照搬到命题逻辑推演系统之中，可以将命题推理的T 规则、 规则和CP 规则，以及命题推理的基本策略例如直接证明法和间接证明法等，直接应用于谓词逻辑的推理。  
另外一方面，我们也应该注意到谓词逻辑与命题逻辑之间最大的区别在于谓词逻辑引进了个体域、个体词、量词，以及由此而产生的约束变量和自由变量。因此，在考虑和处理谓词推理问题时，不能单纯地将其看成是命题逻辑推理，还需要根据谓词逻辑的特点采用适当的方法。其中最为关键的是如下几个基本要点：  
第一、在谓词逻辑中，一般无法在不同个体域基础上衡量两个谓词公式之间的等值关系或逻辑蕴含关系，就像两种不同类型的东西无法进行比较一样。因此，在谓词逻辑演算和推理过程中，我们总是假定所有的谓词公式具有相同的个体域，一般默认为全总个体域。  
第二、谓词逻辑推演的基本思路，一般是首先根据$US$和$E S$ 规则消除谓词公式中的量词，把谓词公式的推理问题转化为命题公式的推理问题，在使用命题公式的推理策略和方法完成相关的推理后，再根据具体需要使用UG 和$E G$规则，将基于命题公式的推理结论还原成谓词公式的推理结论。  
第三、在谓词逻辑的推演过程中，可以引用命题演算中的$P$ 规则和$T$ 规则，如果结论是以蕴涵形式或析取形式给出，还可使用$C P$ 规则。对含有量词的公式可以引用谓词中的基本等值公式和基本蕴涵公式，对于已经消去量词的谓词公式或谓词公式中不含量词的子公式，完全可以引用命题演算中的基本等价公式和基本蕴涵公式。  
下面结合实例介绍谓词逻辑推证的基本方法。首先，我们使用谓词逻辑推理来解决在本章开头提及的苏格拉底三段论问题：  
从以上例题的证明过程可以看出，在谓词演算的推证过程中，必须注意遵守所使用各项推理规则的限制条件，正确合理地使用推理规则。当既需要消除存在量词，由需要消除全称量词的时候，一般都是先消除存在量词，后消除全称量词，被消除或新添加的量词必须位于谓词公式的最左边。当需要推证的结论为蕴含式的时候，可以考虑使用附加前提证明法。当证明给出的前提条件较少且多为蕴含式或析取式时，会感到无从下手，此时可以考虑使用反证法，将结论的否定作为附加前提引入，以增加可用的前提。",谓词逻辑演算和推理过程中，假定所有谓词公式具有相同的个体域，谓词逻辑推演的基本思路是将谓词公式的推理问题转化为命题公式的推理问题
谓词逻辑推理,应用,谓词演算,,"我们知道，谓词逻辑是命题逻辑的一种自然扩展，谓词逻辑的知识体系完全涵盖了命题逻辑的知识体系，或者说命题逻辑是谓词逻辑的一种特例。因此，命题逻辑推演系统的全部知识完全可以照搬到命题逻辑推演系统之中，可以将命题推理的T 规则、 规则和CP 规则，以及命题推理的基本策略例如直接证明法和间接证明法等，直接应用于谓词逻辑的推理。  
另外一方面，我们也应该注意到谓词逻辑与命题逻辑之间最大的区别在于谓词逻辑引进了个体域、个体词、量词，以及由此而产生的约束变量和自由变量。因此，在考虑和处理谓词推理问题时，不能单纯地将其看成是命题逻辑推理，还需要根据谓词逻辑的特点采用适当的方法。其中最为关键的是如下几个基本要点：  
第一、在谓词逻辑中，一般无法在不同个体域基础上衡量两个谓词公式之间的等值关系或逻辑蕴含关系，就像两种不同类型的东西无法进行比较一样。因此，在谓词逻辑演算和推理过程中，我们总是假定所有的谓词公式具有相同的个体域，一般默认为全总个体域。  
第二、谓词逻辑推演的基本思路，一般是首先根据$US$和$E S$ 规则消除谓词公式中的量词，把谓词公式的推理问题转化为命题公式的推理问题，在使用命题公式的推理策略和方法完成相关的推理后，再根据具体需要使用UG 和$E G$规则，将基于命题公式的推理结论还原成谓词公式的推理结论。  
第三、在谓词逻辑的推演过程中，可以引用命题演算中的$P$ 规则和$T$ 规则，如果结论是以蕴涵形式或析取形式给出，还可使用$C P$ 规则。对含有量词的公式可以引用谓词中的基本等值公式和基本蕴涵公式，对于已经消去量词的谓词公式或谓词公式中不含量词的子公式，完全可以引用命题演算中的基本等价公式和基本蕴涵公式。  
下面结合实例介绍谓词逻辑推证的基本方法。首先，我们使用谓词逻辑推理来解决在本章开头提及的苏格拉底三段论问题：  
从以上例题的证明过程可以看出，在谓词演算的推证过程中，必须注意遵守所使用各项推理规则的限制条件，正确合理地使用推理规则。当既需要消除存在量词，由需要消除全称量词的时候，一般都是先消除存在量词，后消除全称量词，被消除或新添加的量词必须位于谓词公式的最左边。当需要推证的结论为蕴含式的时候，可以考虑使用附加前提证明法。当证明给出的前提条件较少且多为蕴含式或析取式时，会感到无从下手，此时可以考虑使用反证法，将结论的否定作为附加前提引入，以增加可用的前提。",在谓词演算的推证过程中，必须遵守所使用的推理规则，正确合理地使用推理规则进行谓词逻辑推理
谓词逻辑,应用于,实际问题,,"在使用谓词逻辑对实际问题进行推理时，需要对问题进行符号化处理。在符号化过程中，首先需要确定个体域，若无特别要求，一般将个体域确定为全总个体域，通过属性谓词限定个体变量的变化范围。然后，选择适当的量词和谓词对问题进行符号化描述，建立问题推证前提条件和结论的谓词公式。  
从上述实例可以看出，谓词逻辑提供了在概念层次上的信息或知识的表达方式，可以实现比命题逻辑更加精细、更加深刻、更加复杂的逻辑推理。",谓词逻辑用于对实际问题进行推理
谓词逻辑,需要,符号化处理,,"在使用谓词逻辑对实际问题进行推理时，需要对问题进行符号化处理。在符号化过程中，首先需要确定个体域，若无特别要求，一般将个体域确定为全总个体域，通过属性谓词限定个体变量的变化范围。然后，选择适当的量词和谓词对问题进行符号化描述，建立问题推证前提条件和结论的谓词公式。  
从上述实例可以看出，谓词逻辑提供了在概念层次上的信息或知识的表达方式，可以实现比命题逻辑更加精细、更加深刻、更加复杂的逻辑推理。",谓词逻辑推理需要对问题进行符号化处理
谓词逻辑,确定,个体域,,"在使用谓词逻辑对实际问题进行推理时，需要对问题进行符号化处理。在符号化过程中，首先需要确定个体域，若无特别要求，一般将个体域确定为全总个体域，通过属性谓词限定个体变量的变化范围。然后，选择适当的量词和谓词对问题进行符号化描述，建立问题推证前提条件和结论的谓词公式。  
从上述实例可以看出，谓词逻辑提供了在概念层次上的信息或知识的表达方式，可以实现比命题逻辑更加精细、更加深刻、更加复杂的逻辑推理。",谓词逻辑符号化过程中需要确定个体域
谓词逻辑,选择,量词和谓词,,"在使用谓词逻辑对实际问题进行推理时，需要对问题进行符号化处理。在符号化过程中，首先需要确定个体域，若无特别要求，一般将个体域确定为全总个体域，通过属性谓词限定个体变量的变化范围。然后，选择适当的量词和谓词对问题进行符号化描述，建立问题推证前提条件和结论的谓词公式。  
从上述实例可以看出，谓词逻辑提供了在概念层次上的信息或知识的表达方式，可以实现比命题逻辑更加精细、更加深刻、更加复杂的逻辑推理。",谓词逻辑符号化描述需要选择适当的量词和谓词
谓词逻辑,建立,谓词公式,,"在使用谓词逻辑对实际问题进行推理时，需要对问题进行符号化处理。在符号化过程中，首先需要确定个体域，若无特别要求，一般将个体域确定为全总个体域，通过属性谓词限定个体变量的变化范围。然后，选择适当的量词和谓词对问题进行符号化描述，建立问题推证前提条件和结论的谓词公式。  
从上述实例可以看出，谓词逻辑提供了在概念层次上的信息或知识的表达方式，可以实现比命题逻辑更加精细、更加深刻、更加复杂的逻辑推理。",谓词逻辑用于建立问题推证前提条件和结论的谓词公式
谓词逻辑,表达,信息或知识,,"在使用谓词逻辑对实际问题进行推理时，需要对问题进行符号化处理。在符号化过程中，首先需要确定个体域，若无特别要求，一般将个体域确定为全总个体域，通过属性谓词限定个体变量的变化范围。然后，选择适当的量词和谓词对问题进行符号化描述，建立问题推证前提条件和结论的谓词公式。  
从上述实例可以看出，谓词逻辑提供了在概念层次上的信息或知识的表达方式，可以实现比命题逻辑更加精细、更加深刻、更加复杂的逻辑推理。",谓词逻辑提供在概念层次上表达信息或知识的方式
谓词逻辑,实现,逻辑推理,,"在使用谓词逻辑对实际问题进行推理时，需要对问题进行符号化处理。在符号化过程中，首先需要确定个体域，若无特别要求，一般将个体域确定为全总个体域，通过属性谓词限定个体变量的变化范围。然后，选择适当的量词和谓词对问题进行符号化描述，建立问题推证前提条件和结论的谓词公式。  
从上述实例可以看出，谓词逻辑提供了在概念层次上的信息或知识的表达方式，可以实现比命题逻辑更加精细、更加深刻、更加复杂的逻辑推理。",谓词逻辑可以实现比命题逻辑更精细、更深刻、更复杂的逻辑推理
谓词逻辑,应用,人工智能,,谓词逻辑使用抽象数学符号在概念、判断和推理这三个层次上表达人类思维的基本规律，具有一套比较完备严谨的理论体系，是当前能够表达人类思维基本规律的一种最精确的形式语言。谓词逻辑在计算机相关学科的众多领域都发挥着重要的基础性作用，是计算机进行智能信息处理的基本工具和理论基础。在人工智能与知识工程领域，通常使用谓词逻辑强大的信息表达能力进行知识表示和推理；数据库核心技术中最典型的关系数据模型就是使用谓词逻辑表示和处理关系的增删查改等基本操作，形成一整套完备的关系演算语言；还可以使用谓词逻辑进行机器证明和自动问题求解，等等。下面结合具体实例介绍谓词逻辑在人工智能中知识表示以及规划问题自动求解等场合的应用。,谓词逻辑在人工智能领域用于知识表示和推理
谓词逻辑,应用,知识工程,,谓词逻辑使用抽象数学符号在概念、判断和推理这三个层次上表达人类思维的基本规律，具有一套比较完备严谨的理论体系，是当前能够表达人类思维基本规律的一种最精确的形式语言。谓词逻辑在计算机相关学科的众多领域都发挥着重要的基础性作用，是计算机进行智能信息处理的基本工具和理论基础。在人工智能与知识工程领域，通常使用谓词逻辑强大的信息表达能力进行知识表示和推理；数据库核心技术中最典型的关系数据模型就是使用谓词逻辑表示和处理关系的增删查改等基本操作，形成一整套完备的关系演算语言；还可以使用谓词逻辑进行机器证明和自动问题求解，等等。下面结合具体实例介绍谓词逻辑在人工智能中知识表示以及规划问题自动求解等场合的应用。,谓词逻辑在知识工程领域用于知识表示和推理
谓词逻辑,应用,数据库,,谓词逻辑使用抽象数学符号在概念、判断和推理这三个层次上表达人类思维的基本规律，具有一套比较完备严谨的理论体系，是当前能够表达人类思维基本规律的一种最精确的形式语言。谓词逻辑在计算机相关学科的众多领域都发挥着重要的基础性作用，是计算机进行智能信息处理的基本工具和理论基础。在人工智能与知识工程领域，通常使用谓词逻辑强大的信息表达能力进行知识表示和推理；数据库核心技术中最典型的关系数据模型就是使用谓词逻辑表示和处理关系的增删查改等基本操作，形成一整套完备的关系演算语言；还可以使用谓词逻辑进行机器证明和自动问题求解，等等。下面结合具体实例介绍谓词逻辑在人工智能中知识表示以及规划问题自动求解等场合的应用。,谓词逻辑在数据库核心技术中用于表示和处理关系数据模型的增删查改操作
谓词逻辑,应用,机器证明,,谓词逻辑使用抽象数学符号在概念、判断和推理这三个层次上表达人类思维的基本规律，具有一套比较完备严谨的理论体系，是当前能够表达人类思维基本规律的一种最精确的形式语言。谓词逻辑在计算机相关学科的众多领域都发挥着重要的基础性作用，是计算机进行智能信息处理的基本工具和理论基础。在人工智能与知识工程领域，通常使用谓词逻辑强大的信息表达能力进行知识表示和推理；数据库核心技术中最典型的关系数据模型就是使用谓词逻辑表示和处理关系的增删查改等基本操作，形成一整套完备的关系演算语言；还可以使用谓词逻辑进行机器证明和自动问题求解，等等。下面结合具体实例介绍谓词逻辑在人工智能中知识表示以及规划问题自动求解等场合的应用。,谓词逻辑用于机器证明
谓词逻辑,应用,自动问题求解,,谓词逻辑使用抽象数学符号在概念、判断和推理这三个层次上表达人类思维的基本规律，具有一套比较完备严谨的理论体系，是当前能够表达人类思维基本规律的一种最精确的形式语言。谓词逻辑在计算机相关学科的众多领域都发挥着重要的基础性作用，是计算机进行智能信息处理的基本工具和理论基础。在人工智能与知识工程领域，通常使用谓词逻辑强大的信息表达能力进行知识表示和推理；数据库核心技术中最典型的关系数据模型就是使用谓词逻辑表示和处理关系的增删查改等基本操作，形成一整套完备的关系演算语言；还可以使用谓词逻辑进行机器证明和自动问题求解，等等。下面结合具体实例介绍谓词逻辑在人工智能中知识表示以及规划问题自动求解等场合的应用。,谓词逻辑用于自动问题求解
谓词逻辑,表示,摘香蕉问题,,"假设某房间里有一只猴子（不妨设想其为机器人），位于$c$ 点；另有一只箱子，位于$a$点；而在$b$ 点的顶棚上吊着一把香蕉，如图4-2 所示。猴子自然希望能得到这把香蕉，但它因身材矮小够不到，当然，如果它站在箱子上便可如愿。但猴子的智慧尚不能像人那样，对将箱子推到香蕉下，踩在箱子上就可摘到香蕉的解决方案一目了然。试为猴子规划一个能摘到香蕉的行动计划。  
![](images/da6043b2c963f12fe3915d340fe42ec9b81a097c121fa6b1d07e9ec34d8173bb.jpg)
图4-2 猴子与香蕉问题  
可用谓词逻辑进行问题表示和求解。首先定义以下几个谓词：$A T\ (x,\ y)$，表示$x$ 在$y$处”；On_Box 表示“猴子在箱子上面”；Hold_$B$ 表示“猴子已经摘到香蕉”。并规定$x$的个体域为｛猴子、箱子、香蕉｝，$y$的个体域为$\{a,\ b,\ c\}$。则该问题可表示为：  
（1） 初始状态：  
AT（猴子，$a.$）：猴子在$a$ 处；$A T$（箱子，$c$）：箱子在$c$ 处；  
¬On_Box：猴子没有在箱子上面；  
¬Hold_$B$：猴子尚未摘到香蕉。  
（2） 目标状态：  
AT（猴子，$b$）：猴子在$b$ 处；$A T$（箱子，$b$）：箱子在$b$ 处；  
On_Box：猴子在箱子上面；Hold_B：猴子已经摘到香蕉。  
上述谓词只能描述事实性知识。下面再定义几个谓词表示过程性知识：  
Goto$(u,~\nu)$）：猴子从$u$ 处走到$\nu$ 处。  
条件：$A T$（猴子，$u$）为真——猴子必须在$u$ 处；$\neg O n\_B o x$ 为真——猴子不能在箱子上。  
动作：删除$A T$（猴子，$u$）；    增添$A T$（猴子，$\nu_{\cdot}$）。  
（1） pushBox$(\nu,\ \ w)$）：猴子将箱子从$\nu$ 处推到$w$ 处。  
条件：$A T$（猴子，$\nu$）为真——猴子须在$\nu$ 处；  
$A T$（箱子，$\nu$）为真——箱子须在$\nu$ 处；  
$\neg O n\_B o x$ 为真——猴子在箱子下才能推箱子。  
动作：删除$A T$（猴子，$\nu$）、$A T$（箱子，$\nu_{\perp}$）； 增添$A T$（猴子，$w$）、$A T$（箱子，$w$）  
（2） $ClimBox$：猴子爬上箱子。  
条件：AT（猴子，$u$）为真——猴子必须在$u$ 处；  
AT（箱子，$u$）为真——箱子也必须在$u$ 处；  
¬On_Box 为真——猴子不能在箱子上。  
动作：删除 $\neg O n\_B o x$ ；增添 On _ Box  
（3） Grasp：猴子已经摘到香蕉。  
条件：AT（猴子，$b$）为真——猴子必须在$b$ 处；  
AT（箱子，$b$）为真——箱子也必须在$b$ 处；  
On_Box 为真——猴子必须在箱子上；¬Hold_$B$ 为真——猴子没有摘到香蕉。  
动作：删除 ¬ Hold _ B ；   增添 Hold _ B  
可将该问题的状态描述成有序四元组$(\,W,\,x,\,y,\,z\,)$）。其中，$W$表示“猴子的水平位置”；$x$ 表示“猴子是否在箱顶（在则取1，否则为$_{0})$”；$y$ 表示“箱子的水平位置”；$z$ 表示“猴子是否摘到香蕉（摘到取1，否则为0）”。显然，$W$和$y$ 只能取$a$，$b$，$c$三个值，则基于上述操作性的谓词描述，该问题的求解过程即可描述如图4-3 所示。  
![](images/05c5b968cbbbe5fedfad9e5c185e1f46a65784eeb2eace9649980413581f7dfb.jpg)
图4-3 猴子与香蕉问题求解过程  
其实，在基于谓词逻辑思想的人工只能知识表示法中，还有产生式表示法，该表示法在信息识别和判断等诸多领域都有十分广泛的运用，此处不在赘述。",谓词逻辑用于表示和求解摘香蕉问题
谓词,描述,摘香蕉问题,,"假设某房间里有一只猴子（不妨设想其为机器人），位于$c$ 点；另有一只箱子，位于$a$点；而在$b$ 点的顶棚上吊着一把香蕉，如图4-2 所示。猴子自然希望能得到这把香蕉，但它因身材矮小够不到，当然，如果它站在箱子上便可如愿。但猴子的智慧尚不能像人那样，对将箱子推到香蕉下，踩在箱子上就可摘到香蕉的解决方案一目了然。试为猴子规划一个能摘到香蕉的行动计划。  
![](images/da6043b2c963f12fe3915d340fe42ec9b81a097c121fa6b1d07e9ec34d8173bb.jpg)
图4-2 猴子与香蕉问题  
可用谓词逻辑进行问题表示和求解。首先定义以下几个谓词：$A T\ (x,\ y)$，表示$x$ 在$y$处”；On_Box 表示“猴子在箱子上面”；Hold_$B$ 表示“猴子已经摘到香蕉”。并规定$x$的个体域为｛猴子、箱子、香蕉｝，$y$的个体域为$\{a,\ b,\ c\}$。则该问题可表示为：  
（1） 初始状态：  
AT（猴子，$a.$）：猴子在$a$ 处；$A T$（箱子，$c$）：箱子在$c$ 处；  
¬On_Box：猴子没有在箱子上面；  
¬Hold_$B$：猴子尚未摘到香蕉。  
（2） 目标状态：  
AT（猴子，$b$）：猴子在$b$ 处；$A T$（箱子，$b$）：箱子在$b$ 处；  
On_Box：猴子在箱子上面；Hold_B：猴子已经摘到香蕉。  
上述谓词只能描述事实性知识。下面再定义几个谓词表示过程性知识：  
Goto$(u,~\nu)$）：猴子从$u$ 处走到$\nu$ 处。  
条件：$A T$（猴子，$u$）为真——猴子必须在$u$ 处；$\neg O n\_B o x$ 为真——猴子不能在箱子上。  
动作：删除$A T$（猴子，$u$）；    增添$A T$（猴子，$\nu_{\cdot}$）。  
（1） pushBox$(\nu,\ \ w)$）：猴子将箱子从$\nu$ 处推到$w$ 处。  
条件：$A T$（猴子，$\nu$）为真——猴子须在$\nu$ 处；  
$A T$（箱子，$\nu$）为真——箱子须在$\nu$ 处；  
$\neg O n\_B o x$ 为真——猴子在箱子下才能推箱子。  
动作：删除$A T$（猴子，$\nu$）、$A T$（箱子，$\nu_{\perp}$）； 增添$A T$（猴子，$w$）、$A T$（箱子，$w$）  
（2） $ClimBox$：猴子爬上箱子。  
条件：AT（猴子，$u$）为真——猴子必须在$u$ 处；  
AT（箱子，$u$）为真——箱子也必须在$u$ 处；  
¬On_Box 为真——猴子不能在箱子上。  
动作：删除 $\neg O n\_B o x$ ；增添 On _ Box  
（3） Grasp：猴子已经摘到香蕉。  
条件：AT（猴子，$b$）为真——猴子必须在$b$ 处；  
AT（箱子，$b$）为真——箱子也必须在$b$ 处；  
On_Box 为真——猴子必须在箱子上；¬Hold_$B$ 为真——猴子没有摘到香蕉。  
动作：删除 ¬ Hold _ B ；   增添 Hold _ B  
可将该问题的状态描述成有序四元组$(\,W,\,x,\,y,\,z\,)$）。其中，$W$表示“猴子的水平位置”；$x$ 表示“猴子是否在箱顶（在则取1，否则为$_{0})$”；$y$ 表示“箱子的水平位置”；$z$ 表示“猴子是否摘到香蕉（摘到取1，否则为0）”。显然，$W$和$y$ 只能取$a$，$b$，$c$三个值，则基于上述操作性的谓词描述，该问题的求解过程即可描述如图4-3 所示。  
![](images/05c5b968cbbbe5fedfad9e5c185e1f46a65784eeb2eace9649980413581f7dfb.jpg)
图4-3 猴子与香蕉问题求解过程  
其实，在基于谓词逻辑思想的人工只能知识表示法中，还有产生式表示法，该表示法在信息识别和判断等诸多领域都有十分广泛的运用，此处不在赘述。",谓词用于描述摘香蕉问题的状态和动作
产生式表示法,基于,谓词逻辑,,"假设某房间里有一只猴子（不妨设想其为机器人），位于$c$ 点；另有一只箱子，位于$a$点；而在$b$ 点的顶棚上吊着一把香蕉，如图4-2 所示。猴子自然希望能得到这把香蕉，但它因身材矮小够不到，当然，如果它站在箱子上便可如愿。但猴子的智慧尚不能像人那样，对将箱子推到香蕉下，踩在箱子上就可摘到香蕉的解决方案一目了然。试为猴子规划一个能摘到香蕉的行动计划。  
![](images/da6043b2c963f12fe3915d340fe42ec9b81a097c121fa6b1d07e9ec34d8173bb.jpg)
图4-2 猴子与香蕉问题  
可用谓词逻辑进行问题表示和求解。首先定义以下几个谓词：$A T\ (x,\ y)$，表示$x$ 在$y$处”；On_Box 表示“猴子在箱子上面”；Hold_$B$ 表示“猴子已经摘到香蕉”。并规定$x$的个体域为｛猴子、箱子、香蕉｝，$y$的个体域为$\{a,\ b,\ c\}$。则该问题可表示为：  
（1） 初始状态：  
AT（猴子，$a.$）：猴子在$a$ 处；$A T$（箱子，$c$）：箱子在$c$ 处；  
¬On_Box：猴子没有在箱子上面；  
¬Hold_$B$：猴子尚未摘到香蕉。  
（2） 目标状态：  
AT（猴子，$b$）：猴子在$b$ 处；$A T$（箱子，$b$）：箱子在$b$ 处；  
On_Box：猴子在箱子上面；Hold_B：猴子已经摘到香蕉。  
上述谓词只能描述事实性知识。下面再定义几个谓词表示过程性知识：  
Goto$(u,~\nu)$）：猴子从$u$ 处走到$\nu$ 处。  
条件：$A T$（猴子，$u$）为真——猴子必须在$u$ 处；$\neg O n\_B o x$ 为真——猴子不能在箱子上。  
动作：删除$A T$（猴子，$u$）；    增添$A T$（猴子，$\nu_{\cdot}$）。  
（1） pushBox$(\nu,\ \ w)$）：猴子将箱子从$\nu$ 处推到$w$ 处。  
条件：$A T$（猴子，$\nu$）为真——猴子须在$\nu$ 处；  
$A T$（箱子，$\nu$）为真——箱子须在$\nu$ 处；  
$\neg O n\_B o x$ 为真——猴子在箱子下才能推箱子。  
动作：删除$A T$（猴子，$\nu$）、$A T$（箱子，$\nu_{\perp}$）； 增添$A T$（猴子，$w$）、$A T$（箱子，$w$）  
（2） $ClimBox$：猴子爬上箱子。  
条件：AT（猴子，$u$）为真——猴子必须在$u$ 处；  
AT（箱子，$u$）为真——箱子也必须在$u$ 处；  
¬On_Box 为真——猴子不能在箱子上。  
动作：删除 $\neg O n\_B o x$ ；增添 On _ Box  
（3） Grasp：猴子已经摘到香蕉。  
条件：AT（猴子，$b$）为真——猴子必须在$b$ 处；  
AT（箱子，$b$）为真——箱子也必须在$b$ 处；  
On_Box 为真——猴子必须在箱子上；¬Hold_$B$ 为真——猴子没有摘到香蕉。  
动作：删除 ¬ Hold _ B ；   增添 Hold _ B  
可将该问题的状态描述成有序四元组$(\,W,\,x,\,y,\,z\,)$）。其中，$W$表示“猴子的水平位置”；$x$ 表示“猴子是否在箱顶（在则取1，否则为$_{0})$”；$y$ 表示“箱子的水平位置”；$z$ 表示“猴子是否摘到香蕉（摘到取1，否则为0）”。显然，$W$和$y$ 只能取$a$，$b$，$c$三个值，则基于上述操作性的谓词描述，该问题的求解过程即可描述如图4-3 所示。  
![](images/05c5b968cbbbe5fedfad9e5c185e1f46a65784eeb2eace9649980413581f7dfb.jpg)
图4-3 猴子与香蕉问题求解过程  
其实，在基于谓词逻辑思想的人工只能知识表示法中，还有产生式表示法，该表示法在信息识别和判断等诸多领域都有十分广泛的运用，此处不在赘述。",产生式表示法是基于谓词逻辑思想的知识表示法
谓词逻辑,表示,水容器问题,,"设有两个分别能盛7 升与5 升的水容器，初始均为空，允许对容器做以下三种操作：  
（1） 向容器倒满水；  
（2） 将容器中的水倒光；  
（3） 从一个容器倒水至另一个容器，使一个容器倒光或另一容器倒满。最后要求能使大容器（能盛7 升的容器）中有4 升水，并求其操作过程。  
用一个谓词𝑆（𝑢，𝑣）表示两个容器的盛水状态，如𝑆（3，1）表示大容器盛3 升，小容器盛1 升。  
因此在这个问题中的公理系统为：（1）开始时两个容器为空；（2）允许做三种操作。要求得到的结论为：大容器装4 升水，小容器不限。  
上述问题可用如下语句表示：  
开始时两个容器均为空：𝑆（0，0）；  
向大容器倒满水：$(\forall x)\ (\forall y)\ (S\ (x,\ y)\ \to S\ (7,\ y))$；  
向小容器倒满水：$(\forall x)\ (\forall y)\ (S\ (x,\ y)\ \rightarrow S\ (x,\ 5))$；  
将大容器的水倒光：$(\forall x)\ (\forall y)\ (S\ (x,\ y)\ \to S\ (\,0,\ y))$；  
将小容器的水倒光：$(\forall x)\ (\forall y)\ (S\ (x,\ y)\ \rightarrow S\ (x,\ 0))$；  
从容器$x$ 将水倒至$y$，使$x$空：$(∀𝑥)(∀𝑦)(∃𝑧) (𝑆(𝑥，𝑦) →𝑆(0，𝑧))$ ，$𝑥+ 𝑦= 𝑧，𝑧≤5$；  
从容器$y$ 将水倒至$x$，使$y$ 空：$(∀𝑥)(∀𝑦)(∃𝑧) (𝑆(𝑥，𝑦) →𝑆(𝑧，0))$，$𝑥+ 𝑦= 𝑧，𝑧≤7$；  
从容器$y$ 倒水至$x$，使$x$ 满：$(∀𝑥)(∀𝑦)(∃𝑧) (𝑆(𝑥，𝑦) →𝑆(7，𝑧))$，$𝑥+ 𝑦= 7 + 𝑧$；  
从容器$x$ 倒水至$y$，使$y$满：$(\forall x)(\forall y)(\exists z)\left(S\!\left(x,\,\,y\right)\to S\!\left(z,\,\,5\right)\right)$ ，$𝑥+ 𝑦= 𝑧+ 5$。  
所求的结论为：$S$（4，0）。  
$\begin{aligned}
&(1) S (0, 0) &&\text{P}\\
&(2) (\forall x) (\forall y) (S (x, y) \to S (7, y)) && \text{P} \\
&(3) (\forall y) (S (0, y) \to S (7, y))&& US, (2) \\
& (4) S (0, 0) \to S (7, 0) && US, (3) \\
&(5) S (7, 0)&& T, (1), (4), \mathrm{I} \\
&(6) (\forall x)(\forall y)(\exists z)\left(S(x, y)\to S(z, 5)\right)&& \text{P} \\
&(7) (\forall y)(\exists z)\left(S\big(7, y\big)\to S\big(z, 5\big)\right)&& US, (6) \\
&(8) (\exists z)\left(S\big(7, 0\big)\to S\big(z, 5\big)\right)&& US, (7) \\
& (9) S(7, 0)\to S(2, 5) && ES, (8) \\
&10 ) S(2, 5) && T, (5), (9), \mathrm{I} \\
& (11) (\forall x) (\forall y) (S (x, y) \to S (x, 0)) && \text{P} \\
&(12)\quad(\forall y) (S (2, y) \to S (2, 0))&& US, (11) \\
&(13) S\big(2, 5\big)\to S\big(2, 0\big)&& ES, (12) \\
& (14) S(2, 0) && T, (10), (13), \mathrm{I} \\
&( 15 ) (\forall x)(\forall y)(\exists z)\left(S(x, y)\rightarrow S(0, z)\right)&& \text{P} \\
&(16) (\forall y)(\exists z)\left(S\bigl(2, y\bigr)\rightarrow S\bigl(0, z\bigr)\right)&& US, (15) \\
&(17) (\exists z)\Big(S\big(2, 0\big)\to S\big(0, z\big)\Big)&& US, (16) \\
& (18) S\bigl(2, 0\bigr)\rightarrow S\bigl(0, 2\bigr) && ES, (17) \\
&( 19 ) S(0 , 2)&& T, (14), (18), \mathrm{I} \\
& (20) (\forall x) (\forall y) (S (x, y) \to S (7, y)) && \text{P}
\\&(21)\quad(\forall y) (S (0, y) \to S (7, y))\quad&& US, (20)\end{aligned}$  
$\begin{aligned}
&(22) S (0, 2) \to S (7, 2)&& US, (21) \\
&(23) S (7, 2)&& T, (19), (22), \mathrm{I} \\
&(24) (\forall x)(\forall y)(\exists z)\Big(S\big(x, y\big)\rightarrow S\big(z, 5\big)\Big)&& \text{P} \\
&(25) (\forall y)(\exists z)\left(S(7, y)\rightarrow S(z, 5)\right)&& US, (24) \\
&(26) (\exists z)\Big(S\big(7, 2\big)\to S\big(z, 5\big)\Big)&& US, (25) \\
&(27) S\big(7, 2\big)\to S\big(4, 5\big)&& ES, (26) \\
&(28) S(4, 5)&& T, (23), (27), \mathrm{I} \\
&(29) (\forall x) (\forall y) (S (x, y) \rightarrow S (x, 0))&& \text{P} \\
&(30)\quad(\forall y) (S (4, y) \rightarrow S (4, 0))&& US, (29) \\
&(31)S(4, 5) \to S(4, 0)&& US, (30) \\
&(32)S(4,0)&& T, (28), (31), \mathrm{I}
\end{aligned}$  
上述推导过程如图4-4 所示：  
![](images/7fd9db7f4d707c709f0cb5214a897d2f9fdc915f8ef2986abce312f2e7c7143c.jpg)
图4-4 水容器问题求解过程",谓词逻辑用于表示水容器问题的状态和操作过程
关系模型与理论,基础与扩展,关系的数学理论,,"我们知道，日常生活或工作中的各种对象之间存在着千丝万缕的联系，包括人与人之间、人与物之间、物与物之间的联系。这种联系通常称之为关系，例如人与人之间的关系有兄弟关系、姻亲关系、朋友关系、同学关系、同事关系等等。这些关系反映了人与人之间各种错综复杂的活动，以这些关系为基础便可进一步衍生出许许多多不同的含义。事实上，一个人社会关系的宽泛程度通常标志着这个人某种能力的大小、威望的高低等等。同样，计算机领域的各种对象之间也存在诸多错综复杂的关系，例如计算机程序中输入与输出之间的关系、数据库中各种数据属性之间的关系、计算机语言中各种标识符之间的关系等等。要想让计算机系统能够自动、高效、正确地处理好这些关系，就必须建立一套完备严谨的关系模型与理论，为数据结构、数据库、信息检索、算法设计与分析、操作系统等计算机专业课程中各种对象之间关系的表达和处理提供有效的基础工具。  
正如计算机不能正确理解和处理基于自然语言表达的形式逻辑，计算机同样不能正确理解和处理用自然语言表达的关系模型与理论。因此，就像使用数理逻辑表达和处理形式逻辑问题一样，我们必须使用数学方法来表达和处理关系问题，面向关系问题建立一整套完备严谨的数学模型与数学理论。事实上，关系问题也是数学学科的一个重要研究对象，处理关系的数学理论诞生于著名数学家豪斯道夫1914 年出版的著作《集论基础》。经过100 多年的发展，关系数学理论已与集合论、数理逻辑、组合学、图论和布尔代数等多个数学分支交叉融 合，并通过吸收、借鉴这些数学分支的相关内容形成了一套相对完备的关系数学理论。  
关系的数学理论以集合论为基础，旨在描述给定集合上元素与元素之间的二元或多元关系，并考察集合中元素之间在一定次序下是否具备某些特定关系。从本章开始的连续三章将系统地介绍和讨论关系的数学模型与理论，本章着重介绍关系数学模型与理论的基本知识，包括关系的数学模型、关系的基本运算、关系的基本性质、关系集合的闭包等。",关系模型与理论是计算机领域处理各种对象之间关系的工具，而关系的数学理论则是以集合论为基础，描述和考察集合上元素之间关系的完备严谨的数学模型与理论，为关系模型与理论提供数学基础和理论支持。
关系数学模型,基于,序偶,,从数学角度看，有些关系比较容易用数学符号表达。例如，自然数集合上自然数的大小比较关系，可用符号≤进行表示。但在很多时候，问题并没有这么简单，例如要表示某班每个学生与其籍贯之间的关系，这就涉及到该班学生集合与地域集合这两个集合元素之间的一种对应关系。此时，要想用数学符号表示这种对应关系，就需要一些巧妙的设计。事实上，可分别将学生集合和地域集合看成是两个在不同维度上的一维空间，并将这两个一维空间进行有序组合张成一个二维空间。此时，对于学生集合中任意一个给定的学生，将这个学生与其籍贯进行有序绑定后，就形成了这个二维空间中的一个点。所有这样的点构成的集合显然就准确地表示了该班每个学生与其籍贯之间的关系。由此可见，我们其实得到一种刻画两个集合中元素之间关系新方法，即首先将这两个集合组合成一个高维空间，然后用高维空间中点的集合来表示两个集合元素之间的关系。显然，这种新方法比前述用符号≤表示大小关系的传统方法更具普适性。本节着重介绍使用这种新方法构建的关系数学模型，为此首先介绍由两个集合组合成一个高维空间的数学机制，即元素的序偶与集合的笛卡尔积。,关系数学模型基于元素的序偶来构建
关系数学模型,利用,笛卡尔积,,从数学角度看，有些关系比较容易用数学符号表达。例如，自然数集合上自然数的大小比较关系，可用符号≤进行表示。但在很多时候，问题并没有这么简单，例如要表示某班每个学生与其籍贯之间的关系，这就涉及到该班学生集合与地域集合这两个集合元素之间的一种对应关系。此时，要想用数学符号表示这种对应关系，就需要一些巧妙的设计。事实上，可分别将学生集合和地域集合看成是两个在不同维度上的一维空间，并将这两个一维空间进行有序组合张成一个二维空间。此时，对于学生集合中任意一个给定的学生，将这个学生与其籍贯进行有序绑定后，就形成了这个二维空间中的一个点。所有这样的点构成的集合显然就准确地表示了该班每个学生与其籍贯之间的关系。由此可见，我们其实得到一种刻画两个集合中元素之间关系新方法，即首先将这两个集合组合成一个高维空间，然后用高维空间中点的集合来表示两个集合元素之间的关系。显然，这种新方法比前述用符号≤表示大小关系的传统方法更具普适性。本节着重介绍使用这种新方法构建的关系数学模型，为此首先介绍由两个集合组合成一个高维空间的数学机制，即元素的序偶与集合的笛卡尔积。,关系数学模型利用集合的笛卡尔积来组合成高维空间
序偶,组成,笛卡尔积,,从数学角度看，有些关系比较容易用数学符号表达。例如，自然数集合上自然数的大小比较关系，可用符号≤进行表示。但在很多时候，问题并没有这么简单，例如要表示某班每个学生与其籍贯之间的关系，这就涉及到该班学生集合与地域集合这两个集合元素之间的一种对应关系。此时，要想用数学符号表示这种对应关系，就需要一些巧妙的设计。事实上，可分别将学生集合和地域集合看成是两个在不同维度上的一维空间，并将这两个一维空间进行有序组合张成一个二维空间。此时，对于学生集合中任意一个给定的学生，将这个学生与其籍贯进行有序绑定后，就形成了这个二维空间中的一个点。所有这样的点构成的集合显然就准确地表示了该班每个学生与其籍贯之间的关系。由此可见，我们其实得到一种刻画两个集合中元素之间关系新方法，即首先将这两个集合组合成一个高维空间，然后用高维空间中点的集合来表示两个集合元素之间的关系。显然，这种新方法比前述用符号≤表示大小关系的传统方法更具普适性。本节着重介绍使用这种新方法构建的关系数学模型，为此首先介绍由两个集合组合成一个高维空间的数学机制，即元素的序偶与集合的笛卡尔积。,序偶是构成笛卡尔积的基本元素
序偶,定义区分,无序偶,,"要用数学方式表达关系模型，首先必须建立有一种有效的数学机制将来自相同集合或不同集合的两个元素绑定在一起，以表明它们之间具体某种特定的关系。为此，下面给出二元组的相关概念来实现这种机制。  
【定义5.1】假设𝐴和$B$是任意给定的两个集合，则对于分别来自这两个集合中的元素$x$和𝑦，可将它们组合成一个整体并称之为二元组。如果这个二元组为无序二元组，则称其为无序偶对，简称为无序偶，通常记为$(x,y)$；如果这个二元组为有序二元组，则称其为有序偶对，简称为序偶，通常记为$\langle x,y\rangle$，并称$\cdot x\in A$为第一元素，$y\in B$为第二元素。  
在关系的数学理论中，通常使用序偶的概念绑定具有某种确定联系的两个元素。事实上序偶的用途非常广泛，日常生活和工作中的很多问题或概念都可用序偶表示。例如，平面上点$A$ 的横坐标是$x$，纵坐标是$y$，可用序偶表示为$\langle x,y\rangle$，$x,y\in R$；合肥是安徽的省会、南京是江苏的省会，可分别用序偶表示为〈合肥, 安徽〉，〈南京, 江苏〉；数学书在桌上、英语书在床上，可分别用序偶表示为〈数学书, 桌上〉，〈英语书,床上〉。  
由序偶的定义容易知道，序偶可以看作是具有两个元素的集合，但序偶中的两个元素是具有确定次序的，如果两个含有两个元素的集合相等，并不意味着这两个集合元素构成的序偶相等，因此即使成立$\{a,b\}=\{b,a\}$，在$a\neq b$的情况下会有：成立$\langle a,b\rangle\neq\langle b,a\rangle$。例如，对于前述的序偶〈合肥, 安徽〉，从集合的角度看，显然有{合肥, 安徽}$\}=$ {安徽,合肥}，但是序偶〈合肥, 安徽〉和〈安徽, 合肥〉显然代表的是两个不同的含义：前者表示合肥是安徽的省会，前者表示安徽是合肥的省会。因此，有：〈合肥, 安徽〉 $\neq$〈安徽,合肥〉。  
下面给出两个序偶相等的具体定义：  
【定义5.2】假设$\langle a,b\rangle$和$\langle c,d\rangle$是任意给定的两个序偶，如果$a=b$，$c=d$，那称这两个序偶相等，记为：$\langle a,b\rangle=\langle c,d\rangle$。  
从上述定义可知，两个序偶相等当且仅当这两个序偶在对应位置上的元素相等。例如，若有$\langle2x-3y,3x+2y\rangle=\langle1,3\rangle$，则有$2x-3y=1$且$3x+2y=3$；反之亦然。  
显然，可将上述序偶及其相等的相关定义自然推广到多个元素的情形。例如，对于任意给定的三个元素$x,y,z$，则可根据如下递归方式定义由这三个元素组成的有序三元组：  
$$
\langle x,y,\mathrm{z}\rangle=\langle\langle x,y\rangle,\mathrm{z}\rangle\tag{5-1}
$$  
从上式可以看出，所谓有序三元组，其实就是序偶的序偶。一般地，可得到如下关于$^{\cdot n}$元有序组的相关定义：  
【定义5.3】由$n$个元素$a_{1}$ ,$a_{2},\dotsc,a_{n}$组成 $n$元有序组由$n-1$元有序组$\langle a_{1}\;\,,a_{2},\dots,a_{n-1}\rangle$和元素$a_{n}$组成的序偶，记作$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$。即：$\langle a_{1}\;\;,a_{2},\ldots,a_{n}\rangle=\langle\langle a_{1}\;\;,a_{2},\ldots,a_{n-1}\rangle,a_{n}\rangle$。  
【定义5.4】假设$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$和$\langle b_{1},b_{2},\dots,b_{n}\rangle$是任意给定的两个$ n$元有序组，如果$a_{i}=$$b_{i}$，$i=1,2,\dots,n$，则称它们相等，记为：$\langle a_{1}\,\ ,a_{2},\ldots,a_{n}\rangle=\langle b_{1},b_{2},\ldots,b_{n}\rangle\,.$。  
【定义5.5】设$A,B$是任意给定的两个集合，用$A$中任意一个元素为第一元素、$B$中任任意一个元素为第二元素构成的所有可能的序偶组成的集合，称为$A$ 与$B$ 的笛卡尔积，亦称为$A$ 与$B$ 的直积，记为$A\times B$。即有：$A\times B=\{\langle x,y\rangle|(x\in A)\land(y\in B)\}$。  
由上述定义可知，集合$A$ 与$B$ 的笛卡尔积运算结果$A\times B$仍是一个集合，并且$A\times B$中的每个元素都是一个序偶，序偶中第一个元素取自集合$A$、第二个元素取自集合$B$。  
假设根据笛卡尔积的定义，不难证明笛卡尔积运算满足如下几条基本性质：  
（1）假设$A$,$B$是任意给定的两个集合，则有：$A\times\emptyset=B\times\emptyset=\emptyset$；  
（2）假设 $A$, $B$ 是任意给定的两个集合，则有 $A\times B=\emptyset$ ，当且仅当 $A=\emptyset$ 或 $B=\emptyset$；  
（3）当$A,B$是有限集合时，有：$|A\times B|=|B\times A|=|A||B|$  
下面定理表明笛卡尔积运算对集合的并运算和交运算均满足分配律：  
【定理5.1】设$A$、$B$、$C$ 是任意集合，则有：  
$A\times(B\cup C)=(A\times B)\cup(A\times C);\quad A\times(B\cap C)=(A\times B)\cap(A\times C);$  
$(A\cup B)\times C=(A\times C)\cup(B\times C);\quad(A\cap B)\times C=(A\cup C)\times(B\times C)\,$。  
【定理5.2】设$A$、${B}、{C}$ 是任意集合且$C\neq\emptyset$，则有：
$$
A\subseteq B\Leftrightarrow(A\times C\subseteq B\times C);\,\,\,A\subseteq B\Leftrightarrow(C\times A\subseteq C\times B)
$$  
【定理5.3】设$A、\ B、C、D$为非空集合，则有：
$$
A\subseteq C\land B\subseteq D\Leftrightarrow A\times B\subseteq C\times D
$$  
【定理5.4】假设集合$\cdot A_{1},A_{2},\cdots,A_{n}$均为有限集合，则有：
$$
|A_{1}\times A_{2}\times\cdots\times A_{n}|=|A_{1}|\times|A_{2}|\times\cdots\times|A_{n}|
$$",序偶是有序的二元组，而无序偶是无序的二元组
序偶,同义,有序偶,,"要用数学方式表达关系模型，首先必须建立有一种有效的数学机制将来自相同集合或不同集合的两个元素绑定在一起，以表明它们之间具体某种特定的关系。为此，下面给出二元组的相关概念来实现这种机制。  
【定义5.1】假设𝐴和$B$是任意给定的两个集合，则对于分别来自这两个集合中的元素$x$和𝑦，可将它们组合成一个整体并称之为二元组。如果这个二元组为无序二元组，则称其为无序偶对，简称为无序偶，通常记为$(x,y)$；如果这个二元组为有序二元组，则称其为有序偶对，简称为序偶，通常记为$\langle x,y\rangle$，并称$\cdot x\in A$为第一元素，$y\in B$为第二元素。  
在关系的数学理论中，通常使用序偶的概念绑定具有某种确定联系的两个元素。事实上序偶的用途非常广泛，日常生活和工作中的很多问题或概念都可用序偶表示。例如，平面上点$A$ 的横坐标是$x$，纵坐标是$y$，可用序偶表示为$\langle x,y\rangle$，$x,y\in R$；合肥是安徽的省会、南京是江苏的省会，可分别用序偶表示为〈合肥, 安徽〉，〈南京, 江苏〉；数学书在桌上、英语书在床上，可分别用序偶表示为〈数学书, 桌上〉，〈英语书,床上〉。  
由序偶的定义容易知道，序偶可以看作是具有两个元素的集合，但序偶中的两个元素是具有确定次序的，如果两个含有两个元素的集合相等，并不意味着这两个集合元素构成的序偶相等，因此即使成立$\{a,b\}=\{b,a\}$，在$a\neq b$的情况下会有：成立$\langle a,b\rangle\neq\langle b,a\rangle$。例如，对于前述的序偶〈合肥, 安徽〉，从集合的角度看，显然有{合肥, 安徽}$\}=$ {安徽,合肥}，但是序偶〈合肥, 安徽〉和〈安徽, 合肥〉显然代表的是两个不同的含义：前者表示合肥是安徽的省会，前者表示安徽是合肥的省会。因此，有：〈合肥, 安徽〉 $\neq$〈安徽,合肥〉。  
下面给出两个序偶相等的具体定义：  
【定义5.2】假设$\langle a,b\rangle$和$\langle c,d\rangle$是任意给定的两个序偶，如果$a=b$，$c=d$，那称这两个序偶相等，记为：$\langle a,b\rangle=\langle c,d\rangle$。  
从上述定义可知，两个序偶相等当且仅当这两个序偶在对应位置上的元素相等。例如，若有$\langle2x-3y,3x+2y\rangle=\langle1,3\rangle$，则有$2x-3y=1$且$3x+2y=3$；反之亦然。  
显然，可将上述序偶及其相等的相关定义自然推广到多个元素的情形。例如，对于任意给定的三个元素$x,y,z$，则可根据如下递归方式定义由这三个元素组成的有序三元组：  
$$
\langle x,y,\mathrm{z}\rangle=\langle\langle x,y\rangle,\mathrm{z}\rangle\tag{5-1}
$$  
从上式可以看出，所谓有序三元组，其实就是序偶的序偶。一般地，可得到如下关于$^{\cdot n}$元有序组的相关定义：  
【定义5.3】由$n$个元素$a_{1}$ ,$a_{2},\dotsc,a_{n}$组成 $n$元有序组由$n-1$元有序组$\langle a_{1}\;\,,a_{2},\dots,a_{n-1}\rangle$和元素$a_{n}$组成的序偶，记作$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$。即：$\langle a_{1}\;\;,a_{2},\ldots,a_{n}\rangle=\langle\langle a_{1}\;\;,a_{2},\ldots,a_{n-1}\rangle,a_{n}\rangle$。  
【定义5.4】假设$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$和$\langle b_{1},b_{2},\dots,b_{n}\rangle$是任意给定的两个$ n$元有序组，如果$a_{i}=$$b_{i}$，$i=1,2,\dots,n$，则称它们相等，记为：$\langle a_{1}\,\ ,a_{2},\ldots,a_{n}\rangle=\langle b_{1},b_{2},\ldots,b_{n}\rangle\,.$。  
【定义5.5】设$A,B$是任意给定的两个集合，用$A$中任意一个元素为第一元素、$B$中任任意一个元素为第二元素构成的所有可能的序偶组成的集合，称为$A$ 与$B$ 的笛卡尔积，亦称为$A$ 与$B$ 的直积，记为$A\times B$。即有：$A\times B=\{\langle x,y\rangle|(x\in A)\land(y\in B)\}$。  
由上述定义可知，集合$A$ 与$B$ 的笛卡尔积运算结果$A\times B$仍是一个集合，并且$A\times B$中的每个元素都是一个序偶，序偶中第一个元素取自集合$A$、第二个元素取自集合$B$。  
假设根据笛卡尔积的定义，不难证明笛卡尔积运算满足如下几条基本性质：  
（1）假设$A$,$B$是任意给定的两个集合，则有：$A\times\emptyset=B\times\emptyset=\emptyset$；  
（2）假设 $A$, $B$ 是任意给定的两个集合，则有 $A\times B=\emptyset$ ，当且仅当 $A=\emptyset$ 或 $B=\emptyset$；  
（3）当$A,B$是有限集合时，有：$|A\times B|=|B\times A|=|A||B|$  
下面定理表明笛卡尔积运算对集合的并运算和交运算均满足分配律：  
【定理5.1】设$A$、$B$、$C$ 是任意集合，则有：  
$A\times(B\cup C)=(A\times B)\cup(A\times C);\quad A\times(B\cap C)=(A\times B)\cap(A\times C);$  
$(A\cup B)\times C=(A\times C)\cup(B\times C);\quad(A\cap B)\times C=(A\cup C)\times(B\times C)\,$。  
【定理5.2】设$A$、${B}、{C}$ 是任意集合且$C\neq\emptyset$，则有：
$$
A\subseteq B\Leftrightarrow(A\times C\subseteq B\times C);\,\,\,A\subseteq B\Leftrightarrow(C\times A\subseteq C\times B)
$$  
【定理5.3】设$A、\ B、C、D$为非空集合，则有：
$$
A\subseteq C\land B\subseteq D\Leftrightarrow A\times B\subseteq C\times D
$$  
【定理5.4】假设集合$\cdot A_{1},A_{2},\cdots,A_{n}$均为有限集合，则有：
$$
|A_{1}\times A_{2}\times\cdots\times A_{n}|=|A_{1}|\times|A_{2}|\times\cdots\times|A_{n}|
$$",序偶即为有序偶
序偶相等,条件,序偶,,"要用数学方式表达关系模型，首先必须建立有一种有效的数学机制将来自相同集合或不同集合的两个元素绑定在一起，以表明它们之间具体某种特定的关系。为此，下面给出二元组的相关概念来实现这种机制。  
【定义5.1】假设𝐴和$B$是任意给定的两个集合，则对于分别来自这两个集合中的元素$x$和𝑦，可将它们组合成一个整体并称之为二元组。如果这个二元组为无序二元组，则称其为无序偶对，简称为无序偶，通常记为$(x,y)$；如果这个二元组为有序二元组，则称其为有序偶对，简称为序偶，通常记为$\langle x,y\rangle$，并称$\cdot x\in A$为第一元素，$y\in B$为第二元素。  
在关系的数学理论中，通常使用序偶的概念绑定具有某种确定联系的两个元素。事实上序偶的用途非常广泛，日常生活和工作中的很多问题或概念都可用序偶表示。例如，平面上点$A$ 的横坐标是$x$，纵坐标是$y$，可用序偶表示为$\langle x,y\rangle$，$x,y\in R$；合肥是安徽的省会、南京是江苏的省会，可分别用序偶表示为〈合肥, 安徽〉，〈南京, 江苏〉；数学书在桌上、英语书在床上，可分别用序偶表示为〈数学书, 桌上〉，〈英语书,床上〉。  
由序偶的定义容易知道，序偶可以看作是具有两个元素的集合，但序偶中的两个元素是具有确定次序的，如果两个含有两个元素的集合相等，并不意味着这两个集合元素构成的序偶相等，因此即使成立$\{a,b\}=\{b,a\}$，在$a\neq b$的情况下会有：成立$\langle a,b\rangle\neq\langle b,a\rangle$。例如，对于前述的序偶〈合肥, 安徽〉，从集合的角度看，显然有{合肥, 安徽}$\}=$ {安徽,合肥}，但是序偶〈合肥, 安徽〉和〈安徽, 合肥〉显然代表的是两个不同的含义：前者表示合肥是安徽的省会，前者表示安徽是合肥的省会。因此，有：〈合肥, 安徽〉 $\neq$〈安徽,合肥〉。  
下面给出两个序偶相等的具体定义：  
【定义5.2】假设$\langle a,b\rangle$和$\langle c,d\rangle$是任意给定的两个序偶，如果$a=b$，$c=d$，那称这两个序偶相等，记为：$\langle a,b\rangle=\langle c,d\rangle$。  
从上述定义可知，两个序偶相等当且仅当这两个序偶在对应位置上的元素相等。例如，若有$\langle2x-3y,3x+2y\rangle=\langle1,3\rangle$，则有$2x-3y=1$且$3x+2y=3$；反之亦然。  
显然，可将上述序偶及其相等的相关定义自然推广到多个元素的情形。例如，对于任意给定的三个元素$x,y,z$，则可根据如下递归方式定义由这三个元素组成的有序三元组：  
$$
\langle x,y,\mathrm{z}\rangle=\langle\langle x,y\rangle,\mathrm{z}\rangle\tag{5-1}
$$  
从上式可以看出，所谓有序三元组，其实就是序偶的序偶。一般地，可得到如下关于$^{\cdot n}$元有序组的相关定义：  
【定义5.3】由$n$个元素$a_{1}$ ,$a_{2},\dotsc,a_{n}$组成 $n$元有序组由$n-1$元有序组$\langle a_{1}\;\,,a_{2},\dots,a_{n-1}\rangle$和元素$a_{n}$组成的序偶，记作$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$。即：$\langle a_{1}\;\;,a_{2},\ldots,a_{n}\rangle=\langle\langle a_{1}\;\;,a_{2},\ldots,a_{n-1}\rangle,a_{n}\rangle$。  
【定义5.4】假设$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$和$\langle b_{1},b_{2},\dots,b_{n}\rangle$是任意给定的两个$ n$元有序组，如果$a_{i}=$$b_{i}$，$i=1,2,\dots,n$，则称它们相等，记为：$\langle a_{1}\,\ ,a_{2},\ldots,a_{n}\rangle=\langle b_{1},b_{2},\ldots,b_{n}\rangle\,.$。  
【定义5.5】设$A,B$是任意给定的两个集合，用$A$中任意一个元素为第一元素、$B$中任任意一个元素为第二元素构成的所有可能的序偶组成的集合，称为$A$ 与$B$ 的笛卡尔积，亦称为$A$ 与$B$ 的直积，记为$A\times B$。即有：$A\times B=\{\langle x,y\rangle|(x\in A)\land(y\in B)\}$。  
由上述定义可知，集合$A$ 与$B$ 的笛卡尔积运算结果$A\times B$仍是一个集合，并且$A\times B$中的每个元素都是一个序偶，序偶中第一个元素取自集合$A$、第二个元素取自集合$B$。  
假设根据笛卡尔积的定义，不难证明笛卡尔积运算满足如下几条基本性质：  
（1）假设$A$,$B$是任意给定的两个集合，则有：$A\times\emptyset=B\times\emptyset=\emptyset$；  
（2）假设 $A$, $B$ 是任意给定的两个集合，则有 $A\times B=\emptyset$ ，当且仅当 $A=\emptyset$ 或 $B=\emptyset$；  
（3）当$A,B$是有限集合时，有：$|A\times B|=|B\times A|=|A||B|$  
下面定理表明笛卡尔积运算对集合的并运算和交运算均满足分配律：  
【定理5.1】设$A$、$B$、$C$ 是任意集合，则有：  
$A\times(B\cup C)=(A\times B)\cup(A\times C);\quad A\times(B\cap C)=(A\times B)\cap(A\times C);$  
$(A\cup B)\times C=(A\times C)\cup(B\times C);\quad(A\cap B)\times C=(A\cup C)\times(B\times C)\,$。  
【定理5.2】设$A$、${B}、{C}$ 是任意集合且$C\neq\emptyset$，则有：
$$
A\subseteq B\Leftrightarrow(A\times C\subseteq B\times C);\,\,\,A\subseteq B\Leftrightarrow(C\times A\subseteq C\times B)
$$  
【定理5.3】设$A、\ B、C、D$为非空集合，则有：
$$
A\subseteq C\land B\subseteq D\Leftrightarrow A\times B\subseteq C\times D
$$  
【定理5.4】假设集合$\cdot A_{1},A_{2},\cdots,A_{n}$均为有限集合，则有：
$$
|A_{1}\times A_{2}\times\cdots\times A_{n}|=|A_{1}|\times|A_{2}|\times\cdots\times|A_{n}|
$$",两个序偶相等当且仅当对应位置上的元素相等
有序三元组,组成,序偶,,"要用数学方式表达关系模型，首先必须建立有一种有效的数学机制将来自相同集合或不同集合的两个元素绑定在一起，以表明它们之间具体某种特定的关系。为此，下面给出二元组的相关概念来实现这种机制。  
【定义5.1】假设𝐴和$B$是任意给定的两个集合，则对于分别来自这两个集合中的元素$x$和𝑦，可将它们组合成一个整体并称之为二元组。如果这个二元组为无序二元组，则称其为无序偶对，简称为无序偶，通常记为$(x,y)$；如果这个二元组为有序二元组，则称其为有序偶对，简称为序偶，通常记为$\langle x,y\rangle$，并称$\cdot x\in A$为第一元素，$y\in B$为第二元素。  
在关系的数学理论中，通常使用序偶的概念绑定具有某种确定联系的两个元素。事实上序偶的用途非常广泛，日常生活和工作中的很多问题或概念都可用序偶表示。例如，平面上点$A$ 的横坐标是$x$，纵坐标是$y$，可用序偶表示为$\langle x,y\rangle$，$x,y\in R$；合肥是安徽的省会、南京是江苏的省会，可分别用序偶表示为〈合肥, 安徽〉，〈南京, 江苏〉；数学书在桌上、英语书在床上，可分别用序偶表示为〈数学书, 桌上〉，〈英语书,床上〉。  
由序偶的定义容易知道，序偶可以看作是具有两个元素的集合，但序偶中的两个元素是具有确定次序的，如果两个含有两个元素的集合相等，并不意味着这两个集合元素构成的序偶相等，因此即使成立$\{a,b\}=\{b,a\}$，在$a\neq b$的情况下会有：成立$\langle a,b\rangle\neq\langle b,a\rangle$。例如，对于前述的序偶〈合肥, 安徽〉，从集合的角度看，显然有{合肥, 安徽}$\}=$ {安徽,合肥}，但是序偶〈合肥, 安徽〉和〈安徽, 合肥〉显然代表的是两个不同的含义：前者表示合肥是安徽的省会，前者表示安徽是合肥的省会。因此，有：〈合肥, 安徽〉 $\neq$〈安徽,合肥〉。  
下面给出两个序偶相等的具体定义：  
【定义5.2】假设$\langle a,b\rangle$和$\langle c,d\rangle$是任意给定的两个序偶，如果$a=b$，$c=d$，那称这两个序偶相等，记为：$\langle a,b\rangle=\langle c,d\rangle$。  
从上述定义可知，两个序偶相等当且仅当这两个序偶在对应位置上的元素相等。例如，若有$\langle2x-3y,3x+2y\rangle=\langle1,3\rangle$，则有$2x-3y=1$且$3x+2y=3$；反之亦然。  
显然，可将上述序偶及其相等的相关定义自然推广到多个元素的情形。例如，对于任意给定的三个元素$x,y,z$，则可根据如下递归方式定义由这三个元素组成的有序三元组：  
$$
\langle x,y,\mathrm{z}\rangle=\langle\langle x,y\rangle,\mathrm{z}\rangle\tag{5-1}
$$  
从上式可以看出，所谓有序三元组，其实就是序偶的序偶。一般地，可得到如下关于$^{\cdot n}$元有序组的相关定义：  
【定义5.3】由$n$个元素$a_{1}$ ,$a_{2},\dotsc,a_{n}$组成 $n$元有序组由$n-1$元有序组$\langle a_{1}\;\,,a_{2},\dots,a_{n-1}\rangle$和元素$a_{n}$组成的序偶，记作$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$。即：$\langle a_{1}\;\;,a_{2},\ldots,a_{n}\rangle=\langle\langle a_{1}\;\;,a_{2},\ldots,a_{n-1}\rangle,a_{n}\rangle$。  
【定义5.4】假设$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$和$\langle b_{1},b_{2},\dots,b_{n}\rangle$是任意给定的两个$ n$元有序组，如果$a_{i}=$$b_{i}$，$i=1,2,\dots,n$，则称它们相等，记为：$\langle a_{1}\,\ ,a_{2},\ldots,a_{n}\rangle=\langle b_{1},b_{2},\ldots,b_{n}\rangle\,.$。  
【定义5.5】设$A,B$是任意给定的两个集合，用$A$中任意一个元素为第一元素、$B$中任任意一个元素为第二元素构成的所有可能的序偶组成的集合，称为$A$ 与$B$ 的笛卡尔积，亦称为$A$ 与$B$ 的直积，记为$A\times B$。即有：$A\times B=\{\langle x,y\rangle|(x\in A)\land(y\in B)\}$。  
由上述定义可知，集合$A$ 与$B$ 的笛卡尔积运算结果$A\times B$仍是一个集合，并且$A\times B$中的每个元素都是一个序偶，序偶中第一个元素取自集合$A$、第二个元素取自集合$B$。  
假设根据笛卡尔积的定义，不难证明笛卡尔积运算满足如下几条基本性质：  
（1）假设$A$,$B$是任意给定的两个集合，则有：$A\times\emptyset=B\times\emptyset=\emptyset$；  
（2）假设 $A$, $B$ 是任意给定的两个集合，则有 $A\times B=\emptyset$ ，当且仅当 $A=\emptyset$ 或 $B=\emptyset$；  
（3）当$A,B$是有限集合时，有：$|A\times B|=|B\times A|=|A||B|$  
下面定理表明笛卡尔积运算对集合的并运算和交运算均满足分配律：  
【定理5.1】设$A$、$B$、$C$ 是任意集合，则有：  
$A\times(B\cup C)=(A\times B)\cup(A\times C);\quad A\times(B\cap C)=(A\times B)\cap(A\times C);$  
$(A\cup B)\times C=(A\times C)\cup(B\times C);\quad(A\cap B)\times C=(A\cup C)\times(B\times C)\,$。  
【定理5.2】设$A$、${B}、{C}$ 是任意集合且$C\neq\emptyset$，则有：
$$
A\subseteq B\Leftrightarrow(A\times C\subseteq B\times C);\,\,\,A\subseteq B\Leftrightarrow(C\times A\subseteq C\times B)
$$  
【定理5.3】设$A、\ B、C、D$为非空集合，则有：
$$
A\subseteq C\land B\subseteq D\Leftrightarrow A\times B\subseteq C\times D
$$  
【定理5.4】假设集合$\cdot A_{1},A_{2},\cdots,A_{n}$均为有限集合，则有：
$$
|A_{1}\times A_{2}\times\cdots\times A_{n}|=|A_{1}|\times|A_{2}|\times\cdots\times|A_{n}|
$$",有序三元组是序偶的序偶
n元有序组,递归定义,序偶,,"要用数学方式表达关系模型，首先必须建立有一种有效的数学机制将来自相同集合或不同集合的两个元素绑定在一起，以表明它们之间具体某种特定的关系。为此，下面给出二元组的相关概念来实现这种机制。  
【定义5.1】假设𝐴和$B$是任意给定的两个集合，则对于分别来自这两个集合中的元素$x$和𝑦，可将它们组合成一个整体并称之为二元组。如果这个二元组为无序二元组，则称其为无序偶对，简称为无序偶，通常记为$(x,y)$；如果这个二元组为有序二元组，则称其为有序偶对，简称为序偶，通常记为$\langle x,y\rangle$，并称$\cdot x\in A$为第一元素，$y\in B$为第二元素。  
在关系的数学理论中，通常使用序偶的概念绑定具有某种确定联系的两个元素。事实上序偶的用途非常广泛，日常生活和工作中的很多问题或概念都可用序偶表示。例如，平面上点$A$ 的横坐标是$x$，纵坐标是$y$，可用序偶表示为$\langle x,y\rangle$，$x,y\in R$；合肥是安徽的省会、南京是江苏的省会，可分别用序偶表示为〈合肥, 安徽〉，〈南京, 江苏〉；数学书在桌上、英语书在床上，可分别用序偶表示为〈数学书, 桌上〉，〈英语书,床上〉。  
由序偶的定义容易知道，序偶可以看作是具有两个元素的集合，但序偶中的两个元素是具有确定次序的，如果两个含有两个元素的集合相等，并不意味着这两个集合元素构成的序偶相等，因此即使成立$\{a,b\}=\{b,a\}$，在$a\neq b$的情况下会有：成立$\langle a,b\rangle\neq\langle b,a\rangle$。例如，对于前述的序偶〈合肥, 安徽〉，从集合的角度看，显然有{合肥, 安徽}$\}=$ {安徽,合肥}，但是序偶〈合肥, 安徽〉和〈安徽, 合肥〉显然代表的是两个不同的含义：前者表示合肥是安徽的省会，前者表示安徽是合肥的省会。因此，有：〈合肥, 安徽〉 $\neq$〈安徽,合肥〉。  
下面给出两个序偶相等的具体定义：  
【定义5.2】假设$\langle a,b\rangle$和$\langle c,d\rangle$是任意给定的两个序偶，如果$a=b$，$c=d$，那称这两个序偶相等，记为：$\langle a,b\rangle=\langle c,d\rangle$。  
从上述定义可知，两个序偶相等当且仅当这两个序偶在对应位置上的元素相等。例如，若有$\langle2x-3y,3x+2y\rangle=\langle1,3\rangle$，则有$2x-3y=1$且$3x+2y=3$；反之亦然。  
显然，可将上述序偶及其相等的相关定义自然推广到多个元素的情形。例如，对于任意给定的三个元素$x,y,z$，则可根据如下递归方式定义由这三个元素组成的有序三元组：  
$$
\langle x,y,\mathrm{z}\rangle=\langle\langle x,y\rangle,\mathrm{z}\rangle\tag{5-1}
$$  
从上式可以看出，所谓有序三元组，其实就是序偶的序偶。一般地，可得到如下关于$^{\cdot n}$元有序组的相关定义：  
【定义5.3】由$n$个元素$a_{1}$ ,$a_{2},\dotsc,a_{n}$组成 $n$元有序组由$n-1$元有序组$\langle a_{1}\;\,,a_{2},\dots,a_{n-1}\rangle$和元素$a_{n}$组成的序偶，记作$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$。即：$\langle a_{1}\;\;,a_{2},\ldots,a_{n}\rangle=\langle\langle a_{1}\;\;,a_{2},\ldots,a_{n-1}\rangle,a_{n}\rangle$。  
【定义5.4】假设$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$和$\langle b_{1},b_{2},\dots,b_{n}\rangle$是任意给定的两个$ n$元有序组，如果$a_{i}=$$b_{i}$，$i=1,2,\dots,n$，则称它们相等，记为：$\langle a_{1}\,\ ,a_{2},\ldots,a_{n}\rangle=\langle b_{1},b_{2},\ldots,b_{n}\rangle\,.$。  
【定义5.5】设$A,B$是任意给定的两个集合，用$A$中任意一个元素为第一元素、$B$中任任意一个元素为第二元素构成的所有可能的序偶组成的集合，称为$A$ 与$B$ 的笛卡尔积，亦称为$A$ 与$B$ 的直积，记为$A\times B$。即有：$A\times B=\{\langle x,y\rangle|(x\in A)\land(y\in B)\}$。  
由上述定义可知，集合$A$ 与$B$ 的笛卡尔积运算结果$A\times B$仍是一个集合，并且$A\times B$中的每个元素都是一个序偶，序偶中第一个元素取自集合$A$、第二个元素取自集合$B$。  
假设根据笛卡尔积的定义，不难证明笛卡尔积运算满足如下几条基本性质：  
（1）假设$A$,$B$是任意给定的两个集合，则有：$A\times\emptyset=B\times\emptyset=\emptyset$；  
（2）假设 $A$, $B$ 是任意给定的两个集合，则有 $A\times B=\emptyset$ ，当且仅当 $A=\emptyset$ 或 $B=\emptyset$；  
（3）当$A,B$是有限集合时，有：$|A\times B|=|B\times A|=|A||B|$  
下面定理表明笛卡尔积运算对集合的并运算和交运算均满足分配律：  
【定理5.1】设$A$、$B$、$C$ 是任意集合，则有：  
$A\times(B\cup C)=(A\times B)\cup(A\times C);\quad A\times(B\cap C)=(A\times B)\cap(A\times C);$  
$(A\cup B)\times C=(A\times C)\cup(B\times C);\quad(A\cap B)\times C=(A\cup C)\times(B\times C)\,$。  
【定理5.2】设$A$、${B}、{C}$ 是任意集合且$C\neq\emptyset$，则有：
$$
A\subseteq B\Leftrightarrow(A\times C\subseteq B\times C);\,\,\,A\subseteq B\Leftrightarrow(C\times A\subseteq C\times B)
$$  
【定理5.3】设$A、\ B、C、D$为非空集合，则有：
$$
A\subseteq C\land B\subseteq D\Leftrightarrow A\times B\subseteq C\times D
$$  
【定理5.4】假设集合$\cdot A_{1},A_{2},\cdots,A_{n}$均为有限集合，则有：
$$
|A_{1}\times A_{2}\times\cdots\times A_{n}|=|A_{1}|\times|A_{2}|\times\cdots\times|A_{n}|
$$",n元有序组由n-1元有序组和元素组成的序偶定义
笛卡尔积,组成,序偶,,"要用数学方式表达关系模型，首先必须建立有一种有效的数学机制将来自相同集合或不同集合的两个元素绑定在一起，以表明它们之间具体某种特定的关系。为此，下面给出二元组的相关概念来实现这种机制。  
【定义5.1】假设𝐴和$B$是任意给定的两个集合，则对于分别来自这两个集合中的元素$x$和𝑦，可将它们组合成一个整体并称之为二元组。如果这个二元组为无序二元组，则称其为无序偶对，简称为无序偶，通常记为$(x,y)$；如果这个二元组为有序二元组，则称其为有序偶对，简称为序偶，通常记为$\langle x,y\rangle$，并称$\cdot x\in A$为第一元素，$y\in B$为第二元素。  
在关系的数学理论中，通常使用序偶的概念绑定具有某种确定联系的两个元素。事实上序偶的用途非常广泛，日常生活和工作中的很多问题或概念都可用序偶表示。例如，平面上点$A$ 的横坐标是$x$，纵坐标是$y$，可用序偶表示为$\langle x,y\rangle$，$x,y\in R$；合肥是安徽的省会、南京是江苏的省会，可分别用序偶表示为〈合肥, 安徽〉，〈南京, 江苏〉；数学书在桌上、英语书在床上，可分别用序偶表示为〈数学书, 桌上〉，〈英语书,床上〉。  
由序偶的定义容易知道，序偶可以看作是具有两个元素的集合，但序偶中的两个元素是具有确定次序的，如果两个含有两个元素的集合相等，并不意味着这两个集合元素构成的序偶相等，因此即使成立$\{a,b\}=\{b,a\}$，在$a\neq b$的情况下会有：成立$\langle a,b\rangle\neq\langle b,a\rangle$。例如，对于前述的序偶〈合肥, 安徽〉，从集合的角度看，显然有{合肥, 安徽}$\}=$ {安徽,合肥}，但是序偶〈合肥, 安徽〉和〈安徽, 合肥〉显然代表的是两个不同的含义：前者表示合肥是安徽的省会，前者表示安徽是合肥的省会。因此，有：〈合肥, 安徽〉 $\neq$〈安徽,合肥〉。  
下面给出两个序偶相等的具体定义：  
【定义5.2】假设$\langle a,b\rangle$和$\langle c,d\rangle$是任意给定的两个序偶，如果$a=b$，$c=d$，那称这两个序偶相等，记为：$\langle a,b\rangle=\langle c,d\rangle$。  
从上述定义可知，两个序偶相等当且仅当这两个序偶在对应位置上的元素相等。例如，若有$\langle2x-3y,3x+2y\rangle=\langle1,3\rangle$，则有$2x-3y=1$且$3x+2y=3$；反之亦然。  
显然，可将上述序偶及其相等的相关定义自然推广到多个元素的情形。例如，对于任意给定的三个元素$x,y,z$，则可根据如下递归方式定义由这三个元素组成的有序三元组：  
$$
\langle x,y,\mathrm{z}\rangle=\langle\langle x,y\rangle,\mathrm{z}\rangle\tag{5-1}
$$  
从上式可以看出，所谓有序三元组，其实就是序偶的序偶。一般地，可得到如下关于$^{\cdot n}$元有序组的相关定义：  
【定义5.3】由$n$个元素$a_{1}$ ,$a_{2},\dotsc,a_{n}$组成 $n$元有序组由$n-1$元有序组$\langle a_{1}\;\,,a_{2},\dots,a_{n-1}\rangle$和元素$a_{n}$组成的序偶，记作$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$。即：$\langle a_{1}\;\;,a_{2},\ldots,a_{n}\rangle=\langle\langle a_{1}\;\;,a_{2},\ldots,a_{n-1}\rangle,a_{n}\rangle$。  
【定义5.4】假设$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$和$\langle b_{1},b_{2},\dots,b_{n}\rangle$是任意给定的两个$ n$元有序组，如果$a_{i}=$$b_{i}$，$i=1,2,\dots,n$，则称它们相等，记为：$\langle a_{1}\,\ ,a_{2},\ldots,a_{n}\rangle=\langle b_{1},b_{2},\ldots,b_{n}\rangle\,.$。  
【定义5.5】设$A,B$是任意给定的两个集合，用$A$中任意一个元素为第一元素、$B$中任任意一个元素为第二元素构成的所有可能的序偶组成的集合，称为$A$ 与$B$ 的笛卡尔积，亦称为$A$ 与$B$ 的直积，记为$A\times B$。即有：$A\times B=\{\langle x,y\rangle|(x\in A)\land(y\in B)\}$。  
由上述定义可知，集合$A$ 与$B$ 的笛卡尔积运算结果$A\times B$仍是一个集合，并且$A\times B$中的每个元素都是一个序偶，序偶中第一个元素取自集合$A$、第二个元素取自集合$B$。  
假设根据笛卡尔积的定义，不难证明笛卡尔积运算满足如下几条基本性质：  
（1）假设$A$,$B$是任意给定的两个集合，则有：$A\times\emptyset=B\times\emptyset=\emptyset$；  
（2）假设 $A$, $B$ 是任意给定的两个集合，则有 $A\times B=\emptyset$ ，当且仅当 $A=\emptyset$ 或 $B=\emptyset$；  
（3）当$A,B$是有限集合时，有：$|A\times B|=|B\times A|=|A||B|$  
下面定理表明笛卡尔积运算对集合的并运算和交运算均满足分配律：  
【定理5.1】设$A$、$B$、$C$ 是任意集合，则有：  
$A\times(B\cup C)=(A\times B)\cup(A\times C);\quad A\times(B\cap C)=(A\times B)\cap(A\times C);$  
$(A\cup B)\times C=(A\times C)\cup(B\times C);\quad(A\cap B)\times C=(A\cup C)\times(B\times C)\,$。  
【定理5.2】设$A$、${B}、{C}$ 是任意集合且$C\neq\emptyset$，则有：
$$
A\subseteq B\Leftrightarrow(A\times C\subseteq B\times C);\,\,\,A\subseteq B\Leftrightarrow(C\times A\subseteq C\times B)
$$  
【定理5.3】设$A、\ B、C、D$为非空集合，则有：
$$
A\subseteq C\land B\subseteq D\Leftrightarrow A\times B\subseteq C\times D
$$  
【定理5.4】假设集合$\cdot A_{1},A_{2},\cdots,A_{n}$均为有限集合，则有：
$$
|A_{1}\times A_{2}\times\cdots\times A_{n}|=|A_{1}|\times|A_{2}|\times\cdots\times|A_{n}|
$$",笛卡尔积是由两个集合中元素构成的所有可能的序偶组成的集合
定理5.1,性质,笛卡尔积,,"要用数学方式表达关系模型，首先必须建立有一种有效的数学机制将来自相同集合或不同集合的两个元素绑定在一起，以表明它们之间具体某种特定的关系。为此，下面给出二元组的相关概念来实现这种机制。  
【定义5.1】假设𝐴和$B$是任意给定的两个集合，则对于分别来自这两个集合中的元素$x$和𝑦，可将它们组合成一个整体并称之为二元组。如果这个二元组为无序二元组，则称其为无序偶对，简称为无序偶，通常记为$(x,y)$；如果这个二元组为有序二元组，则称其为有序偶对，简称为序偶，通常记为$\langle x,y\rangle$，并称$\cdot x\in A$为第一元素，$y\in B$为第二元素。  
在关系的数学理论中，通常使用序偶的概念绑定具有某种确定联系的两个元素。事实上序偶的用途非常广泛，日常生活和工作中的很多问题或概念都可用序偶表示。例如，平面上点$A$ 的横坐标是$x$，纵坐标是$y$，可用序偶表示为$\langle x,y\rangle$，$x,y\in R$；合肥是安徽的省会、南京是江苏的省会，可分别用序偶表示为〈合肥, 安徽〉，〈南京, 江苏〉；数学书在桌上、英语书在床上，可分别用序偶表示为〈数学书, 桌上〉，〈英语书,床上〉。  
由序偶的定义容易知道，序偶可以看作是具有两个元素的集合，但序偶中的两个元素是具有确定次序的，如果两个含有两个元素的集合相等，并不意味着这两个集合元素构成的序偶相等，因此即使成立$\{a,b\}=\{b,a\}$，在$a\neq b$的情况下会有：成立$\langle a,b\rangle\neq\langle b,a\rangle$。例如，对于前述的序偶〈合肥, 安徽〉，从集合的角度看，显然有{合肥, 安徽}$\}=$ {安徽,合肥}，但是序偶〈合肥, 安徽〉和〈安徽, 合肥〉显然代表的是两个不同的含义：前者表示合肥是安徽的省会，前者表示安徽是合肥的省会。因此，有：〈合肥, 安徽〉 $\neq$〈安徽,合肥〉。  
下面给出两个序偶相等的具体定义：  
【定义5.2】假设$\langle a,b\rangle$和$\langle c,d\rangle$是任意给定的两个序偶，如果$a=b$，$c=d$，那称这两个序偶相等，记为：$\langle a,b\rangle=\langle c,d\rangle$。  
从上述定义可知，两个序偶相等当且仅当这两个序偶在对应位置上的元素相等。例如，若有$\langle2x-3y,3x+2y\rangle=\langle1,3\rangle$，则有$2x-3y=1$且$3x+2y=3$；反之亦然。  
显然，可将上述序偶及其相等的相关定义自然推广到多个元素的情形。例如，对于任意给定的三个元素$x,y,z$，则可根据如下递归方式定义由这三个元素组成的有序三元组：  
$$
\langle x,y,\mathrm{z}\rangle=\langle\langle x,y\rangle,\mathrm{z}\rangle\tag{5-1}
$$  
从上式可以看出，所谓有序三元组，其实就是序偶的序偶。一般地，可得到如下关于$^{\cdot n}$元有序组的相关定义：  
【定义5.3】由$n$个元素$a_{1}$ ,$a_{2},\dotsc,a_{n}$组成 $n$元有序组由$n-1$元有序组$\langle a_{1}\;\,,a_{2},\dots,a_{n-1}\rangle$和元素$a_{n}$组成的序偶，记作$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$。即：$\langle a_{1}\;\;,a_{2},\ldots,a_{n}\rangle=\langle\langle a_{1}\;\;,a_{2},\ldots,a_{n-1}\rangle,a_{n}\rangle$。  
【定义5.4】假设$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$和$\langle b_{1},b_{2},\dots,b_{n}\rangle$是任意给定的两个$ n$元有序组，如果$a_{i}=$$b_{i}$，$i=1,2,\dots,n$，则称它们相等，记为：$\langle a_{1}\,\ ,a_{2},\ldots,a_{n}\rangle=\langle b_{1},b_{2},\ldots,b_{n}\rangle\,.$。  
【定义5.5】设$A,B$是任意给定的两个集合，用$A$中任意一个元素为第一元素、$B$中任任意一个元素为第二元素构成的所有可能的序偶组成的集合，称为$A$ 与$B$ 的笛卡尔积，亦称为$A$ 与$B$ 的直积，记为$A\times B$。即有：$A\times B=\{\langle x,y\rangle|(x\in A)\land(y\in B)\}$。  
由上述定义可知，集合$A$ 与$B$ 的笛卡尔积运算结果$A\times B$仍是一个集合，并且$A\times B$中的每个元素都是一个序偶，序偶中第一个元素取自集合$A$、第二个元素取自集合$B$。  
假设根据笛卡尔积的定义，不难证明笛卡尔积运算满足如下几条基本性质：  
（1）假设$A$,$B$是任意给定的两个集合，则有：$A\times\emptyset=B\times\emptyset=\emptyset$；  
（2）假设 $A$, $B$ 是任意给定的两个集合，则有 $A\times B=\emptyset$ ，当且仅当 $A=\emptyset$ 或 $B=\emptyset$；  
（3）当$A,B$是有限集合时，有：$|A\times B|=|B\times A|=|A||B|$  
下面定理表明笛卡尔积运算对集合的并运算和交运算均满足分配律：  
【定理5.1】设$A$、$B$、$C$ 是任意集合，则有：  
$A\times(B\cup C)=(A\times B)\cup(A\times C);\quad A\times(B\cap C)=(A\times B)\cap(A\times C);$  
$(A\cup B)\times C=(A\times C)\cup(B\times C);\quad(A\cap B)\times C=(A\cup C)\times(B\times C)\,$。  
【定理5.2】设$A$、${B}、{C}$ 是任意集合且$C\neq\emptyset$，则有：
$$
A\subseteq B\Leftrightarrow(A\times C\subseteq B\times C);\,\,\,A\subseteq B\Leftrightarrow(C\times A\subseteq C\times B)
$$  
【定理5.3】设$A、\ B、C、D$为非空集合，则有：
$$
A\subseteq C\land B\subseteq D\Leftrightarrow A\times B\subseteq C\times D
$$  
【定理5.4】假设集合$\cdot A_{1},A_{2},\cdots,A_{n}$均为有限集合，则有：
$$
|A_{1}\times A_{2}\times\cdots\times A_{n}|=|A_{1}|\times|A_{2}|\times\cdots\times|A_{n}|
$$",笛卡尔积运算对集合的并运算和交运算满足分配律
定理5.2,性质,笛卡尔积,,"要用数学方式表达关系模型，首先必须建立有一种有效的数学机制将来自相同集合或不同集合的两个元素绑定在一起，以表明它们之间具体某种特定的关系。为此，下面给出二元组的相关概念来实现这种机制。  
【定义5.1】假设𝐴和$B$是任意给定的两个集合，则对于分别来自这两个集合中的元素$x$和𝑦，可将它们组合成一个整体并称之为二元组。如果这个二元组为无序二元组，则称其为无序偶对，简称为无序偶，通常记为$(x,y)$；如果这个二元组为有序二元组，则称其为有序偶对，简称为序偶，通常记为$\langle x,y\rangle$，并称$\cdot x\in A$为第一元素，$y\in B$为第二元素。  
在关系的数学理论中，通常使用序偶的概念绑定具有某种确定联系的两个元素。事实上序偶的用途非常广泛，日常生活和工作中的很多问题或概念都可用序偶表示。例如，平面上点$A$ 的横坐标是$x$，纵坐标是$y$，可用序偶表示为$\langle x,y\rangle$，$x,y\in R$；合肥是安徽的省会、南京是江苏的省会，可分别用序偶表示为〈合肥, 安徽〉，〈南京, 江苏〉；数学书在桌上、英语书在床上，可分别用序偶表示为〈数学书, 桌上〉，〈英语书,床上〉。  
由序偶的定义容易知道，序偶可以看作是具有两个元素的集合，但序偶中的两个元素是具有确定次序的，如果两个含有两个元素的集合相等，并不意味着这两个集合元素构成的序偶相等，因此即使成立$\{a,b\}=\{b,a\}$，在$a\neq b$的情况下会有：成立$\langle a,b\rangle\neq\langle b,a\rangle$。例如，对于前述的序偶〈合肥, 安徽〉，从集合的角度看，显然有{合肥, 安徽}$\}=$ {安徽,合肥}，但是序偶〈合肥, 安徽〉和〈安徽, 合肥〉显然代表的是两个不同的含义：前者表示合肥是安徽的省会，前者表示安徽是合肥的省会。因此，有：〈合肥, 安徽〉 $\neq$〈安徽,合肥〉。  
下面给出两个序偶相等的具体定义：  
【定义5.2】假设$\langle a,b\rangle$和$\langle c,d\rangle$是任意给定的两个序偶，如果$a=b$，$c=d$，那称这两个序偶相等，记为：$\langle a,b\rangle=\langle c,d\rangle$。  
从上述定义可知，两个序偶相等当且仅当这两个序偶在对应位置上的元素相等。例如，若有$\langle2x-3y,3x+2y\rangle=\langle1,3\rangle$，则有$2x-3y=1$且$3x+2y=3$；反之亦然。  
显然，可将上述序偶及其相等的相关定义自然推广到多个元素的情形。例如，对于任意给定的三个元素$x,y,z$，则可根据如下递归方式定义由这三个元素组成的有序三元组：  
$$
\langle x,y,\mathrm{z}\rangle=\langle\langle x,y\rangle,\mathrm{z}\rangle\tag{5-1}
$$  
从上式可以看出，所谓有序三元组，其实就是序偶的序偶。一般地，可得到如下关于$^{\cdot n}$元有序组的相关定义：  
【定义5.3】由$n$个元素$a_{1}$ ,$a_{2},\dotsc,a_{n}$组成 $n$元有序组由$n-1$元有序组$\langle a_{1}\;\,,a_{2},\dots,a_{n-1}\rangle$和元素$a_{n}$组成的序偶，记作$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$。即：$\langle a_{1}\;\;,a_{2},\ldots,a_{n}\rangle=\langle\langle a_{1}\;\;,a_{2},\ldots,a_{n-1}\rangle,a_{n}\rangle$。  
【定义5.4】假设$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$和$\langle b_{1},b_{2},\dots,b_{n}\rangle$是任意给定的两个$ n$元有序组，如果$a_{i}=$$b_{i}$，$i=1,2,\dots,n$，则称它们相等，记为：$\langle a_{1}\,\ ,a_{2},\ldots,a_{n}\rangle=\langle b_{1},b_{2},\ldots,b_{n}\rangle\,.$。  
【定义5.5】设$A,B$是任意给定的两个集合，用$A$中任意一个元素为第一元素、$B$中任任意一个元素为第二元素构成的所有可能的序偶组成的集合，称为$A$ 与$B$ 的笛卡尔积，亦称为$A$ 与$B$ 的直积，记为$A\times B$。即有：$A\times B=\{\langle x,y\rangle|(x\in A)\land(y\in B)\}$。  
由上述定义可知，集合$A$ 与$B$ 的笛卡尔积运算结果$A\times B$仍是一个集合，并且$A\times B$中的每个元素都是一个序偶，序偶中第一个元素取自集合$A$、第二个元素取自集合$B$。  
假设根据笛卡尔积的定义，不难证明笛卡尔积运算满足如下几条基本性质：  
（1）假设$A$,$B$是任意给定的两个集合，则有：$A\times\emptyset=B\times\emptyset=\emptyset$；  
（2）假设 $A$, $B$ 是任意给定的两个集合，则有 $A\times B=\emptyset$ ，当且仅当 $A=\emptyset$ 或 $B=\emptyset$；  
（3）当$A,B$是有限集合时，有：$|A\times B|=|B\times A|=|A||B|$  
下面定理表明笛卡尔积运算对集合的并运算和交运算均满足分配律：  
【定理5.1】设$A$、$B$、$C$ 是任意集合，则有：  
$A\times(B\cup C)=(A\times B)\cup(A\times C);\quad A\times(B\cap C)=(A\times B)\cap(A\times C);$  
$(A\cup B)\times C=(A\times C)\cup(B\times C);\quad(A\cap B)\times C=(A\cup C)\times(B\times C)\,$。  
【定理5.2】设$A$、${B}、{C}$ 是任意集合且$C\neq\emptyset$，则有：
$$
A\subseteq B\Leftrightarrow(A\times C\subseteq B\times C);\,\,\,A\subseteq B\Leftrightarrow(C\times A\subseteq C\times B)
$$  
【定理5.3】设$A、\ B、C、D$为非空集合，则有：
$$
A\subseteq C\land B\subseteq D\Leftrightarrow A\times B\subseteq C\times D
$$  
【定理5.4】假设集合$\cdot A_{1},A_{2},\cdots,A_{n}$均为有限集合，则有：
$$
|A_{1}\times A_{2}\times\cdots\times A_{n}|=|A_{1}|\times|A_{2}|\times\cdots\times|A_{n}|
$$",集合的包含关系与笛卡尔积的包含关系等价
定理5.3,性质,笛卡尔积,,"要用数学方式表达关系模型，首先必须建立有一种有效的数学机制将来自相同集合或不同集合的两个元素绑定在一起，以表明它们之间具体某种特定的关系。为此，下面给出二元组的相关概念来实现这种机制。  
【定义5.1】假设𝐴和$B$是任意给定的两个集合，则对于分别来自这两个集合中的元素$x$和𝑦，可将它们组合成一个整体并称之为二元组。如果这个二元组为无序二元组，则称其为无序偶对，简称为无序偶，通常记为$(x,y)$；如果这个二元组为有序二元组，则称其为有序偶对，简称为序偶，通常记为$\langle x,y\rangle$，并称$\cdot x\in A$为第一元素，$y\in B$为第二元素。  
在关系的数学理论中，通常使用序偶的概念绑定具有某种确定联系的两个元素。事实上序偶的用途非常广泛，日常生活和工作中的很多问题或概念都可用序偶表示。例如，平面上点$A$ 的横坐标是$x$，纵坐标是$y$，可用序偶表示为$\langle x,y\rangle$，$x,y\in R$；合肥是安徽的省会、南京是江苏的省会，可分别用序偶表示为〈合肥, 安徽〉，〈南京, 江苏〉；数学书在桌上、英语书在床上，可分别用序偶表示为〈数学书, 桌上〉，〈英语书,床上〉。  
由序偶的定义容易知道，序偶可以看作是具有两个元素的集合，但序偶中的两个元素是具有确定次序的，如果两个含有两个元素的集合相等，并不意味着这两个集合元素构成的序偶相等，因此即使成立$\{a,b\}=\{b,a\}$，在$a\neq b$的情况下会有：成立$\langle a,b\rangle\neq\langle b,a\rangle$。例如，对于前述的序偶〈合肥, 安徽〉，从集合的角度看，显然有{合肥, 安徽}$\}=$ {安徽,合肥}，但是序偶〈合肥, 安徽〉和〈安徽, 合肥〉显然代表的是两个不同的含义：前者表示合肥是安徽的省会，前者表示安徽是合肥的省会。因此，有：〈合肥, 安徽〉 $\neq$〈安徽,合肥〉。  
下面给出两个序偶相等的具体定义：  
【定义5.2】假设$\langle a,b\rangle$和$\langle c,d\rangle$是任意给定的两个序偶，如果$a=b$，$c=d$，那称这两个序偶相等，记为：$\langle a,b\rangle=\langle c,d\rangle$。  
从上述定义可知，两个序偶相等当且仅当这两个序偶在对应位置上的元素相等。例如，若有$\langle2x-3y,3x+2y\rangle=\langle1,3\rangle$，则有$2x-3y=1$且$3x+2y=3$；反之亦然。  
显然，可将上述序偶及其相等的相关定义自然推广到多个元素的情形。例如，对于任意给定的三个元素$x,y,z$，则可根据如下递归方式定义由这三个元素组成的有序三元组：  
$$
\langle x,y,\mathrm{z}\rangle=\langle\langle x,y\rangle,\mathrm{z}\rangle\tag{5-1}
$$  
从上式可以看出，所谓有序三元组，其实就是序偶的序偶。一般地，可得到如下关于$^{\cdot n}$元有序组的相关定义：  
【定义5.3】由$n$个元素$a_{1}$ ,$a_{2},\dotsc,a_{n}$组成 $n$元有序组由$n-1$元有序组$\langle a_{1}\;\,,a_{2},\dots,a_{n-1}\rangle$和元素$a_{n}$组成的序偶，记作$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$。即：$\langle a_{1}\;\;,a_{2},\ldots,a_{n}\rangle=\langle\langle a_{1}\;\;,a_{2},\ldots,a_{n-1}\rangle,a_{n}\rangle$。  
【定义5.4】假设$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$和$\langle b_{1},b_{2},\dots,b_{n}\rangle$是任意给定的两个$ n$元有序组，如果$a_{i}=$$b_{i}$，$i=1,2,\dots,n$，则称它们相等，记为：$\langle a_{1}\,\ ,a_{2},\ldots,a_{n}\rangle=\langle b_{1},b_{2},\ldots,b_{n}\rangle\,.$。  
【定义5.5】设$A,B$是任意给定的两个集合，用$A$中任意一个元素为第一元素、$B$中任任意一个元素为第二元素构成的所有可能的序偶组成的集合，称为$A$ 与$B$ 的笛卡尔积，亦称为$A$ 与$B$ 的直积，记为$A\times B$。即有：$A\times B=\{\langle x,y\rangle|(x\in A)\land(y\in B)\}$。  
由上述定义可知，集合$A$ 与$B$ 的笛卡尔积运算结果$A\times B$仍是一个集合，并且$A\times B$中的每个元素都是一个序偶，序偶中第一个元素取自集合$A$、第二个元素取自集合$B$。  
假设根据笛卡尔积的定义，不难证明笛卡尔积运算满足如下几条基本性质：  
（1）假设$A$,$B$是任意给定的两个集合，则有：$A\times\emptyset=B\times\emptyset=\emptyset$；  
（2）假设 $A$, $B$ 是任意给定的两个集合，则有 $A\times B=\emptyset$ ，当且仅当 $A=\emptyset$ 或 $B=\emptyset$；  
（3）当$A,B$是有限集合时，有：$|A\times B|=|B\times A|=|A||B|$  
下面定理表明笛卡尔积运算对集合的并运算和交运算均满足分配律：  
【定理5.1】设$A$、$B$、$C$ 是任意集合，则有：  
$A\times(B\cup C)=(A\times B)\cup(A\times C);\quad A\times(B\cap C)=(A\times B)\cap(A\times C);$  
$(A\cup B)\times C=(A\times C)\cup(B\times C);\quad(A\cap B)\times C=(A\cup C)\times(B\times C)\,$。  
【定理5.2】设$A$、${B}、{C}$ 是任意集合且$C\neq\emptyset$，则有：
$$
A\subseteq B\Leftrightarrow(A\times C\subseteq B\times C);\,\,\,A\subseteq B\Leftrightarrow(C\times A\subseteq C\times B)
$$  
【定理5.3】设$A、\ B、C、D$为非空集合，则有：
$$
A\subseteq C\land B\subseteq D\Leftrightarrow A\times B\subseteq C\times D
$$  
【定理5.4】假设集合$\cdot A_{1},A_{2},\cdots,A_{n}$均为有限集合，则有：
$$
|A_{1}\times A_{2}\times\cdots\times A_{n}|=|A_{1}|\times|A_{2}|\times\cdots\times|A_{n}|
$$",多个集合的包含关系与它们的笛卡尔积的包含关系等价
定理5.4,性质,笛卡尔积,,"要用数学方式表达关系模型，首先必须建立有一种有效的数学机制将来自相同集合或不同集合的两个元素绑定在一起，以表明它们之间具体某种特定的关系。为此，下面给出二元组的相关概念来实现这种机制。  
【定义5.1】假设𝐴和$B$是任意给定的两个集合，则对于分别来自这两个集合中的元素$x$和𝑦，可将它们组合成一个整体并称之为二元组。如果这个二元组为无序二元组，则称其为无序偶对，简称为无序偶，通常记为$(x,y)$；如果这个二元组为有序二元组，则称其为有序偶对，简称为序偶，通常记为$\langle x,y\rangle$，并称$\cdot x\in A$为第一元素，$y\in B$为第二元素。  
在关系的数学理论中，通常使用序偶的概念绑定具有某种确定联系的两个元素。事实上序偶的用途非常广泛，日常生活和工作中的很多问题或概念都可用序偶表示。例如，平面上点$A$ 的横坐标是$x$，纵坐标是$y$，可用序偶表示为$\langle x,y\rangle$，$x,y\in R$；合肥是安徽的省会、南京是江苏的省会，可分别用序偶表示为〈合肥, 安徽〉，〈南京, 江苏〉；数学书在桌上、英语书在床上，可分别用序偶表示为〈数学书, 桌上〉，〈英语书,床上〉。  
由序偶的定义容易知道，序偶可以看作是具有两个元素的集合，但序偶中的两个元素是具有确定次序的，如果两个含有两个元素的集合相等，并不意味着这两个集合元素构成的序偶相等，因此即使成立$\{a,b\}=\{b,a\}$，在$a\neq b$的情况下会有：成立$\langle a,b\rangle\neq\langle b,a\rangle$。例如，对于前述的序偶〈合肥, 安徽〉，从集合的角度看，显然有{合肥, 安徽}$\}=$ {安徽,合肥}，但是序偶〈合肥, 安徽〉和〈安徽, 合肥〉显然代表的是两个不同的含义：前者表示合肥是安徽的省会，前者表示安徽是合肥的省会。因此，有：〈合肥, 安徽〉 $\neq$〈安徽,合肥〉。  
下面给出两个序偶相等的具体定义：  
【定义5.2】假设$\langle a,b\rangle$和$\langle c,d\rangle$是任意给定的两个序偶，如果$a=b$，$c=d$，那称这两个序偶相等，记为：$\langle a,b\rangle=\langle c,d\rangle$。  
从上述定义可知，两个序偶相等当且仅当这两个序偶在对应位置上的元素相等。例如，若有$\langle2x-3y,3x+2y\rangle=\langle1,3\rangle$，则有$2x-3y=1$且$3x+2y=3$；反之亦然。  
显然，可将上述序偶及其相等的相关定义自然推广到多个元素的情形。例如，对于任意给定的三个元素$x,y,z$，则可根据如下递归方式定义由这三个元素组成的有序三元组：  
$$
\langle x,y,\mathrm{z}\rangle=\langle\langle x,y\rangle,\mathrm{z}\rangle\tag{5-1}
$$  
从上式可以看出，所谓有序三元组，其实就是序偶的序偶。一般地，可得到如下关于$^{\cdot n}$元有序组的相关定义：  
【定义5.3】由$n$个元素$a_{1}$ ,$a_{2},\dotsc,a_{n}$组成 $n$元有序组由$n-1$元有序组$\langle a_{1}\;\,,a_{2},\dots,a_{n-1}\rangle$和元素$a_{n}$组成的序偶，记作$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$。即：$\langle a_{1}\;\;,a_{2},\ldots,a_{n}\rangle=\langle\langle a_{1}\;\;,a_{2},\ldots,a_{n-1}\rangle,a_{n}\rangle$。  
【定义5.4】假设$\langle a_{1}\ ,a_{2},\ldots,a_{n}\rangle$和$\langle b_{1},b_{2},\dots,b_{n}\rangle$是任意给定的两个$ n$元有序组，如果$a_{i}=$$b_{i}$，$i=1,2,\dots,n$，则称它们相等，记为：$\langle a_{1}\,\ ,a_{2},\ldots,a_{n}\rangle=\langle b_{1},b_{2},\ldots,b_{n}\rangle\,.$。  
【定义5.5】设$A,B$是任意给定的两个集合，用$A$中任意一个元素为第一元素、$B$中任任意一个元素为第二元素构成的所有可能的序偶组成的集合，称为$A$ 与$B$ 的笛卡尔积，亦称为$A$ 与$B$ 的直积，记为$A\times B$。即有：$A\times B=\{\langle x,y\rangle|(x\in A)\land(y\in B)\}$。  
由上述定义可知，集合$A$ 与$B$ 的笛卡尔积运算结果$A\times B$仍是一个集合，并且$A\times B$中的每个元素都是一个序偶，序偶中第一个元素取自集合$A$、第二个元素取自集合$B$。  
假设根据笛卡尔积的定义，不难证明笛卡尔积运算满足如下几条基本性质：  
（1）假设$A$,$B$是任意给定的两个集合，则有：$A\times\emptyset=B\times\emptyset=\emptyset$；  
（2）假设 $A$, $B$ 是任意给定的两个集合，则有 $A\times B=\emptyset$ ，当且仅当 $A=\emptyset$ 或 $B=\emptyset$；  
（3）当$A,B$是有限集合时，有：$|A\times B|=|B\times A|=|A||B|$  
下面定理表明笛卡尔积运算对集合的并运算和交运算均满足分配律：  
【定理5.1】设$A$、$B$、$C$ 是任意集合，则有：  
$A\times(B\cup C)=(A\times B)\cup(A\times C);\quad A\times(B\cap C)=(A\times B)\cap(A\times C);$  
$(A\cup B)\times C=(A\times C)\cup(B\times C);\quad(A\cap B)\times C=(A\cup C)\times(B\times C)\,$。  
【定理5.2】设$A$、${B}、{C}$ 是任意集合且$C\neq\emptyset$，则有：
$$
A\subseteq B\Leftrightarrow(A\times C\subseteq B\times C);\,\,\,A\subseteq B\Leftrightarrow(C\times A\subseteq C\times B)
$$  
【定理5.3】设$A、\ B、C、D$为非空集合，则有：
$$
A\subseteq C\land B\subseteq D\Leftrightarrow A\times B\subseteq C\times D
$$  
【定理5.4】假设集合$\cdot A_{1},A_{2},\cdots,A_{n}$均为有限集合，则有：
$$
|A_{1}\times A_{2}\times\cdots\times A_{n}|=|A_{1}|\times|A_{2}|\times\cdots\times|A_{n}|
$$",多个有限集合的笛卡尔积的基数等于各集合基数的乘积
二元关系,是,关系,,"现在我们使用序偶与笛卡尔积这两个概念建立表示两个元素之间二元关系的数学模型。首先考察一个具体实例：假设某个班级正在上离散数学课，教室里有100 个座位和85 名学生，那么教室里有些座位有学生坐、有些座位没有学生坐，如果某个座位被某个学生坐了，则称这个座位与这个学生有关系，否则称这个座位与这个学生没有关系，现在考虑要用什么样的数学模型来表示或定义这种学生与座位之间的二元关系。  
令集合$A$表示该教室所有学生组成的集合，集合B表示该教室所有座位组成的集合，则根据乘法原理，$A$与$B$的笛卡尔集$A\times B$就表示将这85 名学生分布到100 个座位上所有可能发生的状态，$A\times B$中每个元素$\langle x,y\rangle$就表示学生$x$与座位𝑦之间可能发生的一种关系，即学生$x$坐在座位𝑦上的一种可能发生的状态。显然，一共有$85\times100=8500$可能的状态。但是，这些状态一般不会都发生，事实上，此时实际发生的只有85 个状态，即学生和座位之间实际发生关系的有且只有$A\times B$中的85 个元素。因此，可以将$A\times B$中这85 个实际发生的状态作为集合来表示这85 名学生和100 个座位之间的关系。换句话说，这85 名学生和100 个座位之间的二元关系其实就是$A$与$B$的笛卡尔集$A\times B$的某个子集。  
也可以从另外一个角度理解这个问题：将集合$𝐴$和$B$分别看成是学生维度和座位维度这两个一维空间，则$𝐴$与$B$的笛卡尔集$A\times B$就表示由这两个维度的元素组合而成的二维空间。现从𝐴中任选一位学生$x$，从$B$中任选一个座位𝑦，让学生$x$坐到座位𝑦上，由此形成一个序偶$\langle x,y\rangle$。这个序偶对应着$A\times B$所形成二维空间的一个点，所有这样的点或者序偶显然构成了这个二维空间的一个子集合。另外一方面，所有这样的点或序偶组成的集合完全枚举了学生与座位实际发生的关系，故可将学生与座位之间的二元关系就定义为所有这样的序偶组成的集合。因此，座位和学生之间的二元关系其实就是$𝐴$与$B$的笛卡尔集$A\times B$的某个子集。  
在实际生活中，还有很多类似的例子。再如机票和座位之间对号关系，若令$X$为机票的集合，Y 为座位号的集合， $R$ 表示对号关系，则对任意$x\in X$和$y\in Y$，$x$与$y$ 之间有对号和不对号两种状态。若将$R$ 看成是一些序偶的某个集合或$X$与$Y$ 的笛卡尔集$X\times Y$的某个子集，则对于任意一个序偶$\langle x,\ y\rangle$， $x$与$y$具有对号关系当且仅当$\langle x,y\rangle\in R$。因此，可将这里的对号关系定义为序偶的某个集合或$X\times Y$的某个子集合。  
通过以上分析发现，可用序偶的集合或者笛卡尔集的某个子集合来构造二元关系的数学模型。据此得到如下关于二元关系的定义：  
【定义5.6】设$𝐴$, $B$是任意给定的两个非空集合，$R$是$A\times B$的任何一个给定的子集合，则称$R$ 是一个从$𝐴$到$B$的二元关系，简称为关系。也就是说，若$R\subseteq A\times B$，则称$R$是$𝐴$到$B$的一个二元关系，若$\ R\subseteq A\times A$，则称$R$是$𝐴$上的一个二元关系。特别地，若$R=\emptyset$，则称$R$ 为空关系；若$R=A\times B$，则称$R$ 为全关系。  
【定义5.7】设$𝐴$, $B$是任意给定的两个非空集合，$R$是$𝐴$到$B$的一个二元关系，对于$A\times B$中的任意一个序偶$\langle x,y\rangle$，若$\langle x,y\rangle\in R$，这称集合$𝐴$中的元素$x$与集合$\ B$中的元素$𝑦$之间具有关系$R$；若$R$是$𝐴$上的一个二元关系且$\langle x,y\rangle\in R$，则称集合𝐴中的元素$x$与$𝑦$之间具有关系$R$。  
由上述两个定义可以看出，我们以集合为基本工具通过确定关系外延的方式给出关系概念的数学定义。这样就不必用数学符号来表示关系概念的内涵。事实上，对于有些关系，即使用自然语言也无法清楚表达其复杂的内涵。  
![](images/f21a296fae3e098faaa3900cc4615cee3ba4531b4f17c607a85fa8fb673d5d95.jpg)
图5-1 关系的五个域  
如图5-1 所示，集合$C$和$D$满足：$C=\{x|\langle x,y\rangle\in R\}$；$D=\{y|\langle x,y\rangle\in R\}$。此时称$C$为$R$ 的定义域，记为$C=\mathsf{d o m}R$；称$D$为$R$ 的值域，记为$D=ranR$；$A$ 为$R$ 的前域，$B$ 为$R$ 的后域，并称$\mathrm{fld}R=D\cup C$为$R$ 的域。一般地，我们有如下定义：  
【定义5.8】设$𝐴$, $B$是任意给定的两个非空集合，$R$是$𝐴$到$B$的一个二元关系，则有：称$A$是$R$的前域， $B$是$R$的后域；由$R$ 中所有序偶的第一元素构成的集合称为$R$ 的定义域，记作$dom𝑅$，即有$\mathrm{dom}R=\{x|\langle x,y\rangle\in R\}$；由$R$ 中所有序偶的第二元素构成的集合称为$R$ 的值域，记作$ran𝑅$，即有$\mathrm{ran}R=\{y|\langle x,y\rangle\in R\}$；称$\mathrm{fld}R=\mathrm{dom}R\cup\mathrm{ran}R$为$R$ 的域。",二元关系是关系的特例
定义域,属于,二元关系,,"现在我们使用序偶与笛卡尔积这两个概念建立表示两个元素之间二元关系的数学模型。首先考察一个具体实例：假设某个班级正在上离散数学课，教室里有100 个座位和85 名学生，那么教室里有些座位有学生坐、有些座位没有学生坐，如果某个座位被某个学生坐了，则称这个座位与这个学生有关系，否则称这个座位与这个学生没有关系，现在考虑要用什么样的数学模型来表示或定义这种学生与座位之间的二元关系。  
令集合$A$表示该教室所有学生组成的集合，集合B表示该教室所有座位组成的集合，则根据乘法原理，$A$与$B$的笛卡尔集$A\times B$就表示将这85 名学生分布到100 个座位上所有可能发生的状态，$A\times B$中每个元素$\langle x,y\rangle$就表示学生$x$与座位𝑦之间可能发生的一种关系，即学生$x$坐在座位𝑦上的一种可能发生的状态。显然，一共有$85\times100=8500$可能的状态。但是，这些状态一般不会都发生，事实上，此时实际发生的只有85 个状态，即学生和座位之间实际发生关系的有且只有$A\times B$中的85 个元素。因此，可以将$A\times B$中这85 个实际发生的状态作为集合来表示这85 名学生和100 个座位之间的关系。换句话说，这85 名学生和100 个座位之间的二元关系其实就是$A$与$B$的笛卡尔集$A\times B$的某个子集。  
也可以从另外一个角度理解这个问题：将集合$𝐴$和$B$分别看成是学生维度和座位维度这两个一维空间，则$𝐴$与$B$的笛卡尔集$A\times B$就表示由这两个维度的元素组合而成的二维空间。现从𝐴中任选一位学生$x$，从$B$中任选一个座位𝑦，让学生$x$坐到座位𝑦上，由此形成一个序偶$\langle x,y\rangle$。这个序偶对应着$A\times B$所形成二维空间的一个点，所有这样的点或者序偶显然构成了这个二维空间的一个子集合。另外一方面，所有这样的点或序偶组成的集合完全枚举了学生与座位实际发生的关系，故可将学生与座位之间的二元关系就定义为所有这样的序偶组成的集合。因此，座位和学生之间的二元关系其实就是$𝐴$与$B$的笛卡尔集$A\times B$的某个子集。  
在实际生活中，还有很多类似的例子。再如机票和座位之间对号关系，若令$X$为机票的集合，Y 为座位号的集合， $R$ 表示对号关系，则对任意$x\in X$和$y\in Y$，$x$与$y$ 之间有对号和不对号两种状态。若将$R$ 看成是一些序偶的某个集合或$X$与$Y$ 的笛卡尔集$X\times Y$的某个子集，则对于任意一个序偶$\langle x,\ y\rangle$， $x$与$y$具有对号关系当且仅当$\langle x,y\rangle\in R$。因此，可将这里的对号关系定义为序偶的某个集合或$X\times Y$的某个子集合。  
通过以上分析发现，可用序偶的集合或者笛卡尔集的某个子集合来构造二元关系的数学模型。据此得到如下关于二元关系的定义：  
【定义5.6】设$𝐴$, $B$是任意给定的两个非空集合，$R$是$A\times B$的任何一个给定的子集合，则称$R$ 是一个从$𝐴$到$B$的二元关系，简称为关系。也就是说，若$R\subseteq A\times B$，则称$R$是$𝐴$到$B$的一个二元关系，若$\ R\subseteq A\times A$，则称$R$是$𝐴$上的一个二元关系。特别地，若$R=\emptyset$，则称$R$ 为空关系；若$R=A\times B$，则称$R$ 为全关系。  
【定义5.7】设$𝐴$, $B$是任意给定的两个非空集合，$R$是$𝐴$到$B$的一个二元关系，对于$A\times B$中的任意一个序偶$\langle x,y\rangle$，若$\langle x,y\rangle\in R$，这称集合$𝐴$中的元素$x$与集合$\ B$中的元素$𝑦$之间具有关系$R$；若$R$是$𝐴$上的一个二元关系且$\langle x,y\rangle\in R$，则称集合𝐴中的元素$x$与$𝑦$之间具有关系$R$。  
由上述两个定义可以看出，我们以集合为基本工具通过确定关系外延的方式给出关系概念的数学定义。这样就不必用数学符号来表示关系概念的内涵。事实上，对于有些关系，即使用自然语言也无法清楚表达其复杂的内涵。  
![](images/f21a296fae3e098faaa3900cc4615cee3ba4531b4f17c607a85fa8fb673d5d95.jpg)
图5-1 关系的五个域  
如图5-1 所示，集合$C$和$D$满足：$C=\{x|\langle x,y\rangle\in R\}$；$D=\{y|\langle x,y\rangle\in R\}$。此时称$C$为$R$ 的定义域，记为$C=\mathsf{d o m}R$；称$D$为$R$ 的值域，记为$D=ranR$；$A$ 为$R$ 的前域，$B$ 为$R$ 的后域，并称$\mathrm{fld}R=D\cup C$为$R$ 的域。一般地，我们有如下定义：  
【定义5.8】设$𝐴$, $B$是任意给定的两个非空集合，$R$是$𝐴$到$B$的一个二元关系，则有：称$A$是$R$的前域， $B$是$R$的后域；由$R$ 中所有序偶的第一元素构成的集合称为$R$ 的定义域，记作$dom𝑅$，即有$\mathrm{dom}R=\{x|\langle x,y\rangle\in R\}$；由$R$ 中所有序偶的第二元素构成的集合称为$R$ 的值域，记作$ran𝑅$，即有$\mathrm{ran}R=\{y|\langle x,y\rangle\in R\}$；称$\mathrm{fld}R=\mathrm{dom}R\cup\mathrm{ran}R$为$R$ 的域。",定义域是二元关系中所有序偶的第一元素构成的集合
值域,属于,二元关系,,"现在我们使用序偶与笛卡尔积这两个概念建立表示两个元素之间二元关系的数学模型。首先考察一个具体实例：假设某个班级正在上离散数学课，教室里有100 个座位和85 名学生，那么教室里有些座位有学生坐、有些座位没有学生坐，如果某个座位被某个学生坐了，则称这个座位与这个学生有关系，否则称这个座位与这个学生没有关系，现在考虑要用什么样的数学模型来表示或定义这种学生与座位之间的二元关系。  
令集合$A$表示该教室所有学生组成的集合，集合B表示该教室所有座位组成的集合，则根据乘法原理，$A$与$B$的笛卡尔集$A\times B$就表示将这85 名学生分布到100 个座位上所有可能发生的状态，$A\times B$中每个元素$\langle x,y\rangle$就表示学生$x$与座位𝑦之间可能发生的一种关系，即学生$x$坐在座位𝑦上的一种可能发生的状态。显然，一共有$85\times100=8500$可能的状态。但是，这些状态一般不会都发生，事实上，此时实际发生的只有85 个状态，即学生和座位之间实际发生关系的有且只有$A\times B$中的85 个元素。因此，可以将$A\times B$中这85 个实际发生的状态作为集合来表示这85 名学生和100 个座位之间的关系。换句话说，这85 名学生和100 个座位之间的二元关系其实就是$A$与$B$的笛卡尔集$A\times B$的某个子集。  
也可以从另外一个角度理解这个问题：将集合$𝐴$和$B$分别看成是学生维度和座位维度这两个一维空间，则$𝐴$与$B$的笛卡尔集$A\times B$就表示由这两个维度的元素组合而成的二维空间。现从𝐴中任选一位学生$x$，从$B$中任选一个座位𝑦，让学生$x$坐到座位𝑦上，由此形成一个序偶$\langle x,y\rangle$。这个序偶对应着$A\times B$所形成二维空间的一个点，所有这样的点或者序偶显然构成了这个二维空间的一个子集合。另外一方面，所有这样的点或序偶组成的集合完全枚举了学生与座位实际发生的关系，故可将学生与座位之间的二元关系就定义为所有这样的序偶组成的集合。因此，座位和学生之间的二元关系其实就是$𝐴$与$B$的笛卡尔集$A\times B$的某个子集。  
在实际生活中，还有很多类似的例子。再如机票和座位之间对号关系，若令$X$为机票的集合，Y 为座位号的集合， $R$ 表示对号关系，则对任意$x\in X$和$y\in Y$，$x$与$y$ 之间有对号和不对号两种状态。若将$R$ 看成是一些序偶的某个集合或$X$与$Y$ 的笛卡尔集$X\times Y$的某个子集，则对于任意一个序偶$\langle x,\ y\rangle$， $x$与$y$具有对号关系当且仅当$\langle x,y\rangle\in R$。因此，可将这里的对号关系定义为序偶的某个集合或$X\times Y$的某个子集合。  
通过以上分析发现，可用序偶的集合或者笛卡尔集的某个子集合来构造二元关系的数学模型。据此得到如下关于二元关系的定义：  
【定义5.6】设$𝐴$, $B$是任意给定的两个非空集合，$R$是$A\times B$的任何一个给定的子集合，则称$R$ 是一个从$𝐴$到$B$的二元关系，简称为关系。也就是说，若$R\subseteq A\times B$，则称$R$是$𝐴$到$B$的一个二元关系，若$\ R\subseteq A\times A$，则称$R$是$𝐴$上的一个二元关系。特别地，若$R=\emptyset$，则称$R$ 为空关系；若$R=A\times B$，则称$R$ 为全关系。  
【定义5.7】设$𝐴$, $B$是任意给定的两个非空集合，$R$是$𝐴$到$B$的一个二元关系，对于$A\times B$中的任意一个序偶$\langle x,y\rangle$，若$\langle x,y\rangle\in R$，这称集合$𝐴$中的元素$x$与集合$\ B$中的元素$𝑦$之间具有关系$R$；若$R$是$𝐴$上的一个二元关系且$\langle x,y\rangle\in R$，则称集合𝐴中的元素$x$与$𝑦$之间具有关系$R$。  
由上述两个定义可以看出，我们以集合为基本工具通过确定关系外延的方式给出关系概念的数学定义。这样就不必用数学符号来表示关系概念的内涵。事实上，对于有些关系，即使用自然语言也无法清楚表达其复杂的内涵。  
![](images/f21a296fae3e098faaa3900cc4615cee3ba4531b4f17c607a85fa8fb673d5d95.jpg)
图5-1 关系的五个域  
如图5-1 所示，集合$C$和$D$满足：$C=\{x|\langle x,y\rangle\in R\}$；$D=\{y|\langle x,y\rangle\in R\}$。此时称$C$为$R$ 的定义域，记为$C=\mathsf{d o m}R$；称$D$为$R$ 的值域，记为$D=ranR$；$A$ 为$R$ 的前域，$B$ 为$R$ 的后域，并称$\mathrm{fld}R=D\cup C$为$R$ 的域。一般地，我们有如下定义：  
【定义5.8】设$𝐴$, $B$是任意给定的两个非空集合，$R$是$𝐴$到$B$的一个二元关系，则有：称$A$是$R$的前域， $B$是$R$的后域；由$R$ 中所有序偶的第一元素构成的集合称为$R$ 的定义域，记作$dom𝑅$，即有$\mathrm{dom}R=\{x|\langle x,y\rangle\in R\}$；由$R$ 中所有序偶的第二元素构成的集合称为$R$ 的值域，记作$ran𝑅$，即有$\mathrm{ran}R=\{y|\langle x,y\rangle\in R\}$；称$\mathrm{fld}R=\mathrm{dom}R\cup\mathrm{ran}R$为$R$ 的域。",值域是二元关系中所有序偶的第二元素构成的集合
域,包含,二元关系,,"现在我们使用序偶与笛卡尔积这两个概念建立表示两个元素之间二元关系的数学模型。首先考察一个具体实例：假设某个班级正在上离散数学课，教室里有100 个座位和85 名学生，那么教室里有些座位有学生坐、有些座位没有学生坐，如果某个座位被某个学生坐了，则称这个座位与这个学生有关系，否则称这个座位与这个学生没有关系，现在考虑要用什么样的数学模型来表示或定义这种学生与座位之间的二元关系。  
令集合$A$表示该教室所有学生组成的集合，集合B表示该教室所有座位组成的集合，则根据乘法原理，$A$与$B$的笛卡尔集$A\times B$就表示将这85 名学生分布到100 个座位上所有可能发生的状态，$A\times B$中每个元素$\langle x,y\rangle$就表示学生$x$与座位𝑦之间可能发生的一种关系，即学生$x$坐在座位𝑦上的一种可能发生的状态。显然，一共有$85\times100=8500$可能的状态。但是，这些状态一般不会都发生，事实上，此时实际发生的只有85 个状态，即学生和座位之间实际发生关系的有且只有$A\times B$中的85 个元素。因此，可以将$A\times B$中这85 个实际发生的状态作为集合来表示这85 名学生和100 个座位之间的关系。换句话说，这85 名学生和100 个座位之间的二元关系其实就是$A$与$B$的笛卡尔集$A\times B$的某个子集。  
也可以从另外一个角度理解这个问题：将集合$𝐴$和$B$分别看成是学生维度和座位维度这两个一维空间，则$𝐴$与$B$的笛卡尔集$A\times B$就表示由这两个维度的元素组合而成的二维空间。现从𝐴中任选一位学生$x$，从$B$中任选一个座位𝑦，让学生$x$坐到座位𝑦上，由此形成一个序偶$\langle x,y\rangle$。这个序偶对应着$A\times B$所形成二维空间的一个点，所有这样的点或者序偶显然构成了这个二维空间的一个子集合。另外一方面，所有这样的点或序偶组成的集合完全枚举了学生与座位实际发生的关系，故可将学生与座位之间的二元关系就定义为所有这样的序偶组成的集合。因此，座位和学生之间的二元关系其实就是$𝐴$与$B$的笛卡尔集$A\times B$的某个子集。  
在实际生活中，还有很多类似的例子。再如机票和座位之间对号关系，若令$X$为机票的集合，Y 为座位号的集合， $R$ 表示对号关系，则对任意$x\in X$和$y\in Y$，$x$与$y$ 之间有对号和不对号两种状态。若将$R$ 看成是一些序偶的某个集合或$X$与$Y$ 的笛卡尔集$X\times Y$的某个子集，则对于任意一个序偶$\langle x,\ y\rangle$， $x$与$y$具有对号关系当且仅当$\langle x,y\rangle\in R$。因此，可将这里的对号关系定义为序偶的某个集合或$X\times Y$的某个子集合。  
通过以上分析发现，可用序偶的集合或者笛卡尔集的某个子集合来构造二元关系的数学模型。据此得到如下关于二元关系的定义：  
【定义5.6】设$𝐴$, $B$是任意给定的两个非空集合，$R$是$A\times B$的任何一个给定的子集合，则称$R$ 是一个从$𝐴$到$B$的二元关系，简称为关系。也就是说，若$R\subseteq A\times B$，则称$R$是$𝐴$到$B$的一个二元关系，若$\ R\subseteq A\times A$，则称$R$是$𝐴$上的一个二元关系。特别地，若$R=\emptyset$，则称$R$ 为空关系；若$R=A\times B$，则称$R$ 为全关系。  
【定义5.7】设$𝐴$, $B$是任意给定的两个非空集合，$R$是$𝐴$到$B$的一个二元关系，对于$A\times B$中的任意一个序偶$\langle x,y\rangle$，若$\langle x,y\rangle\in R$，这称集合$𝐴$中的元素$x$与集合$\ B$中的元素$𝑦$之间具有关系$R$；若$R$是$𝐴$上的一个二元关系且$\langle x,y\rangle\in R$，则称集合𝐴中的元素$x$与$𝑦$之间具有关系$R$。  
由上述两个定义可以看出，我们以集合为基本工具通过确定关系外延的方式给出关系概念的数学定义。这样就不必用数学符号来表示关系概念的内涵。事实上，对于有些关系，即使用自然语言也无法清楚表达其复杂的内涵。  
![](images/f21a296fae3e098faaa3900cc4615cee3ba4531b4f17c607a85fa8fb673d5d95.jpg)
图5-1 关系的五个域  
如图5-1 所示，集合$C$和$D$满足：$C=\{x|\langle x,y\rangle\in R\}$；$D=\{y|\langle x,y\rangle\in R\}$。此时称$C$为$R$ 的定义域，记为$C=\mathsf{d o m}R$；称$D$为$R$ 的值域，记为$D=ranR$；$A$ 为$R$ 的前域，$B$ 为$R$ 的后域，并称$\mathrm{fld}R=D\cup C$为$R$ 的域。一般地，我们有如下定义：  
【定义5.8】设$𝐴$, $B$是任意给定的两个非空集合，$R$是$𝐴$到$B$的一个二元关系，则有：称$A$是$R$的前域， $B$是$R$的后域；由$R$ 中所有序偶的第一元素构成的集合称为$R$ 的定义域，记作$dom𝑅$，即有$\mathrm{dom}R=\{x|\langle x,y\rangle\in R\}$；由$R$ 中所有序偶的第二元素构成的集合称为$R$ 的值域，记作$ran𝑅$，即有$\mathrm{ran}R=\{y|\langle x,y\rangle\in R\}$；称$\mathrm{fld}R=\mathrm{dom}R\cup\mathrm{ran}R$为$R$ 的域。",域是二元关系的定义域和值域的并集
关系,表示为,笛卡尔积,,"现在我们使用序偶与笛卡尔积这两个概念建立表示两个元素之间二元关系的数学模型。首先考察一个具体实例：假设某个班级正在上离散数学课，教室里有100 个座位和85 名学生，那么教室里有些座位有学生坐、有些座位没有学生坐，如果某个座位被某个学生坐了，则称这个座位与这个学生有关系，否则称这个座位与这个学生没有关系，现在考虑要用什么样的数学模型来表示或定义这种学生与座位之间的二元关系。  
令集合$A$表示该教室所有学生组成的集合，集合B表示该教室所有座位组成的集合，则根据乘法原理，$A$与$B$的笛卡尔集$A\times B$就表示将这85 名学生分布到100 个座位上所有可能发生的状态，$A\times B$中每个元素$\langle x,y\rangle$就表示学生$x$与座位𝑦之间可能发生的一种关系，即学生$x$坐在座位𝑦上的一种可能发生的状态。显然，一共有$85\times100=8500$可能的状态。但是，这些状态一般不会都发生，事实上，此时实际发生的只有85 个状态，即学生和座位之间实际发生关系的有且只有$A\times B$中的85 个元素。因此，可以将$A\times B$中这85 个实际发生的状态作为集合来表示这85 名学生和100 个座位之间的关系。换句话说，这85 名学生和100 个座位之间的二元关系其实就是$A$与$B$的笛卡尔集$A\times B$的某个子集。  
也可以从另外一个角度理解这个问题：将集合$𝐴$和$B$分别看成是学生维度和座位维度这两个一维空间，则$𝐴$与$B$的笛卡尔集$A\times B$就表示由这两个维度的元素组合而成的二维空间。现从𝐴中任选一位学生$x$，从$B$中任选一个座位𝑦，让学生$x$坐到座位𝑦上，由此形成一个序偶$\langle x,y\rangle$。这个序偶对应着$A\times B$所形成二维空间的一个点，所有这样的点或者序偶显然构成了这个二维空间的一个子集合。另外一方面，所有这样的点或序偶组成的集合完全枚举了学生与座位实际发生的关系，故可将学生与座位之间的二元关系就定义为所有这样的序偶组成的集合。因此，座位和学生之间的二元关系其实就是$𝐴$与$B$的笛卡尔集$A\times B$的某个子集。  
在实际生活中，还有很多类似的例子。再如机票和座位之间对号关系，若令$X$为机票的集合，Y 为座位号的集合， $R$ 表示对号关系，则对任意$x\in X$和$y\in Y$，$x$与$y$ 之间有对号和不对号两种状态。若将$R$ 看成是一些序偶的某个集合或$X$与$Y$ 的笛卡尔集$X\times Y$的某个子集，则对于任意一个序偶$\langle x,\ y\rangle$， $x$与$y$具有对号关系当且仅当$\langle x,y\rangle\in R$。因此，可将这里的对号关系定义为序偶的某个集合或$X\times Y$的某个子集合。  
通过以上分析发现，可用序偶的集合或者笛卡尔集的某个子集合来构造二元关系的数学模型。据此得到如下关于二元关系的定义：  
【定义5.6】设$𝐴$, $B$是任意给定的两个非空集合，$R$是$A\times B$的任何一个给定的子集合，则称$R$ 是一个从$𝐴$到$B$的二元关系，简称为关系。也就是说，若$R\subseteq A\times B$，则称$R$是$𝐴$到$B$的一个二元关系，若$\ R\subseteq A\times A$，则称$R$是$𝐴$上的一个二元关系。特别地，若$R=\emptyset$，则称$R$ 为空关系；若$R=A\times B$，则称$R$ 为全关系。  
【定义5.7】设$𝐴$, $B$是任意给定的两个非空集合，$R$是$𝐴$到$B$的一个二元关系，对于$A\times B$中的任意一个序偶$\langle x,y\rangle$，若$\langle x,y\rangle\in R$，这称集合$𝐴$中的元素$x$与集合$\ B$中的元素$𝑦$之间具有关系$R$；若$R$是$𝐴$上的一个二元关系且$\langle x,y\rangle\in R$，则称集合𝐴中的元素$x$与$𝑦$之间具有关系$R$。  
由上述两个定义可以看出，我们以集合为基本工具通过确定关系外延的方式给出关系概念的数学定义。这样就不必用数学符号来表示关系概念的内涵。事实上，对于有些关系，即使用自然语言也无法清楚表达其复杂的内涵。  
![](images/f21a296fae3e098faaa3900cc4615cee3ba4531b4f17c607a85fa8fb673d5d95.jpg)
图5-1 关系的五个域  
如图5-1 所示，集合$C$和$D$满足：$C=\{x|\langle x,y\rangle\in R\}$；$D=\{y|\langle x,y\rangle\in R\}$。此时称$C$为$R$ 的定义域，记为$C=\mathsf{d o m}R$；称$D$为$R$ 的值域，记为$D=ranR$；$A$ 为$R$ 的前域，$B$ 为$R$ 的后域，并称$\mathrm{fld}R=D\cup C$为$R$ 的域。一般地，我们有如下定义：  
【定义5.8】设$𝐴$, $B$是任意给定的两个非空集合，$R$是$𝐴$到$B$的一个二元关系，则有：称$A$是$R$的前域， $B$是$R$的后域；由$R$ 中所有序偶的第一元素构成的集合称为$R$ 的定义域，记作$dom𝑅$，即有$\mathrm{dom}R=\{x|\langle x,y\rangle\in R\}$；由$R$ 中所有序偶的第二元素构成的集合称为$R$ 的值域，记作$ran𝑅$，即有$\mathrm{ran}R=\{y|\langle x,y\rangle\in R\}$；称$\mathrm{fld}R=\mathrm{dom}R\cup\mathrm{ran}R$为$R$ 的域。",关系可以表示为笛卡尔积的某个子集
关系的集合表示法,包含,枚举法,,"关系的集合表示法主要有枚举法和描述法两种。所谓枚举法，就是将作为关系的集合中所有序偶一一枚举出来；所谓描述法，就是用集合的描述法表示作为关系的集合。例如，对于集合$A=\{1,2,3,4\}$上的整除关系$R$，如果用描述法表示，则有：${R=\{\langle a,b\rangle|a|b\}}$；如果用$R=\{\langle1,1\rangle,\langle1,2\rangle,\langle1,3\rangle,\langle1,4\rangle,\langle2,2\rangle,\langle2,4\rangle,\langle3,3\rangle,\langle4,4\rangle\}.$",关系的集合表示法包含枚举法
关系的集合表示法,包含,描述法,,"关系的集合表示法主要有枚举法和描述法两种。所谓枚举法，就是将作为关系的集合中所有序偶一一枚举出来；所谓描述法，就是用集合的描述法表示作为关系的集合。例如，对于集合$A=\{1,2,3,4\}$上的整除关系$R$，如果用描述法表示，则有：${R=\{\langle a,b\rangle|a|b\}}$；如果用$R=\{\langle1,1\rangle,\langle1,2\rangle,\langle1,3\rangle,\langle1,4\rangle,\langle2,2\rangle,\langle2,4\rangle,\langle3,3\rangle,\langle4,4\rangle\}.$",关系的集合表示法包含描述法
关系模型,表示,有向图表示法,,"图是一种非常重要的数学模型，是问题表示和求解的基本工具。本书将在后续相关内容专门介绍和讨论图模型的基本理论及应用。这里主要给出二元关系的一种图模型表示方法。一般来说，图模型由一些结点和一些联结结点的边构成，一条边关联且仅关联两个结点。对于任意给定的一条边，如果将关联这条边的其中一个结点确定为起点，另外一个结点确定为终点，则称该边为有向边，若一个图中的每条边都是有向边，则称该图为有向图。在一般情况下，有向图只能表示有限集合上的二元关系。下面给出二元关系的一种有向图表示方法，通常称表示关系的有向图为关系图。  
假设𝐴, $B$是任意给定的两个非空有限集合，$R$是$𝐴$到$B$的一个二元关系： （1）当$A\ne B$时，不妨设$A=\{a_{1},a_{2},\cdots,a_{n}\}$，$B=\{b_{1},b_{2},\cdots,b_{m}\}$，则可将$𝐴,$ $B$中每个元素分别看成是有向图的一个结点，用“ ∘”表示，并将$𝐴$中元素$a_{1},a_{2},\cdots,a_{n}$对应的结点放在左边一列作为有向边的起点，将$B$中元素$\cdot b_{1},b_{2},\cdots,b_{m}$对应的结点放在右边一列作为有向边的终点。对于关系$R$中的每个序偶，则构成有向图中的一条有向边，也就是说，对于$𝐴$中的任一元素$a_{i}$和$B$中的任一元素$b_{j}$组合而成的序偶$\langle a_{i},b_{j}\rangle$，当且仅当$\langle a_{i},b_{j}\rangle\in R$时，以$a_{i}$对应的结点为起点、以$b_{j}$对应的结点为终点画出一条有向边，由此得到$R$的关系图。  
（2）当$A=B$时，设$A=B=\{a_{1},a_{2},\cdots,a_{n}\}$，此时$R$ 是集合$𝐴$上的关系，则将$𝐴$中的每个元素分别看成是有向图中的一个结点，用“ ∘”表示，对于任意一个序偶$\langle a_{i},a_{j}\rangle$：  
如果$a_{i}$和$a_{j}$对应的不是同一个结点，则当且仅当$\langle a_{i},a_{j}\rangle\in R$时，使用以$a_{i}$对应的结点为起点、以$b_{j}$对应的结点为终点的有向边联结$a_{i}$和$a_{j}$对应的两个结点；如果$a_{i}$和$a_{j}$对应的是同一个结点，即$a_{i}$和$a_{j}$是$𝐴$中同一个元素，则当且仅当$\langle a_{i},a_{i}\rangle\in R$时，则在$a_{i}$对应的结点上画一个从该结点出发并回到该结点的有向小圆环。  
下面举例说明关系图的构造方法：",关系模型可以通过有向图表示法来表示
有向图表示法,构成,关系图,,"图是一种非常重要的数学模型，是问题表示和求解的基本工具。本书将在后续相关内容专门介绍和讨论图模型的基本理论及应用。这里主要给出二元关系的一种图模型表示方法。一般来说，图模型由一些结点和一些联结结点的边构成，一条边关联且仅关联两个结点。对于任意给定的一条边，如果将关联这条边的其中一个结点确定为起点，另外一个结点确定为终点，则称该边为有向边，若一个图中的每条边都是有向边，则称该图为有向图。在一般情况下，有向图只能表示有限集合上的二元关系。下面给出二元关系的一种有向图表示方法，通常称表示关系的有向图为关系图。  
假设𝐴, $B$是任意给定的两个非空有限集合，$R$是$𝐴$到$B$的一个二元关系： （1）当$A\ne B$时，不妨设$A=\{a_{1},a_{2},\cdots,a_{n}\}$，$B=\{b_{1},b_{2},\cdots,b_{m}\}$，则可将$𝐴,$ $B$中每个元素分别看成是有向图的一个结点，用“ ∘”表示，并将$𝐴$中元素$a_{1},a_{2},\cdots,a_{n}$对应的结点放在左边一列作为有向边的起点，将$B$中元素$\cdot b_{1},b_{2},\cdots,b_{m}$对应的结点放在右边一列作为有向边的终点。对于关系$R$中的每个序偶，则构成有向图中的一条有向边，也就是说，对于$𝐴$中的任一元素$a_{i}$和$B$中的任一元素$b_{j}$组合而成的序偶$\langle a_{i},b_{j}\rangle$，当且仅当$\langle a_{i},b_{j}\rangle\in R$时，以$a_{i}$对应的结点为起点、以$b_{j}$对应的结点为终点画出一条有向边，由此得到$R$的关系图。  
（2）当$A=B$时，设$A=B=\{a_{1},a_{2},\cdots,a_{n}\}$，此时$R$ 是集合$𝐴$上的关系，则将$𝐴$中的每个元素分别看成是有向图中的一个结点，用“ ∘”表示，对于任意一个序偶$\langle a_{i},a_{j}\rangle$：  
如果$a_{i}$和$a_{j}$对应的不是同一个结点，则当且仅当$\langle a_{i},a_{j}\rangle\in R$时，使用以$a_{i}$对应的结点为起点、以$b_{j}$对应的结点为终点的有向边联结$a_{i}$和$a_{j}$对应的两个结点；如果$a_{i}$和$a_{j}$对应的是同一个结点，即$a_{i}$和$a_{j}$是$𝐴$中同一个元素，则当且仅当$\langle a_{i},a_{i}\rangle\in R$时，则在$a_{i}$对应的结点上画一个从该结点出发并回到该结点的有向小圆环。  
下面举例说明关系图的构造方法：",有向图表示法用于构成关系图
关系模型,表示,关系图,,"图是一种非常重要的数学模型，是问题表示和求解的基本工具。本书将在后续相关内容专门介绍和讨论图模型的基本理论及应用。这里主要给出二元关系的一种图模型表示方法。一般来说，图模型由一些结点和一些联结结点的边构成，一条边关联且仅关联两个结点。对于任意给定的一条边，如果将关联这条边的其中一个结点确定为起点，另外一个结点确定为终点，则称该边为有向边，若一个图中的每条边都是有向边，则称该图为有向图。在一般情况下，有向图只能表示有限集合上的二元关系。下面给出二元关系的一种有向图表示方法，通常称表示关系的有向图为关系图。  
假设𝐴, $B$是任意给定的两个非空有限集合，$R$是$𝐴$到$B$的一个二元关系： （1）当$A\ne B$时，不妨设$A=\{a_{1},a_{2},\cdots,a_{n}\}$，$B=\{b_{1},b_{2},\cdots,b_{m}\}$，则可将$𝐴,$ $B$中每个元素分别看成是有向图的一个结点，用“ ∘”表示，并将$𝐴$中元素$a_{1},a_{2},\cdots,a_{n}$对应的结点放在左边一列作为有向边的起点，将$B$中元素$\cdot b_{1},b_{2},\cdots,b_{m}$对应的结点放在右边一列作为有向边的终点。对于关系$R$中的每个序偶，则构成有向图中的一条有向边，也就是说，对于$𝐴$中的任一元素$a_{i}$和$B$中的任一元素$b_{j}$组合而成的序偶$\langle a_{i},b_{j}\rangle$，当且仅当$\langle a_{i},b_{j}\rangle\in R$时，以$a_{i}$对应的结点为起点、以$b_{j}$对应的结点为终点画出一条有向边，由此得到$R$的关系图。  
（2）当$A=B$时，设$A=B=\{a_{1},a_{2},\cdots,a_{n}\}$，此时$R$ 是集合$𝐴$上的关系，则将$𝐴$中的每个元素分别看成是有向图中的一个结点，用“ ∘”表示，对于任意一个序偶$\langle a_{i},a_{j}\rangle$：  
如果$a_{i}$和$a_{j}$对应的不是同一个结点，则当且仅当$\langle a_{i},a_{j}\rangle\in R$时，使用以$a_{i}$对应的结点为起点、以$b_{j}$对应的结点为终点的有向边联结$a_{i}$和$a_{j}$对应的两个结点；如果$a_{i}$和$a_{j}$对应的是同一个结点，即$a_{i}$和$a_{j}$是$𝐴$中同一个元素，则当且仅当$\langle a_{i},a_{i}\rangle\in R$时，则在$a_{i}$对应的结点上画一个从该结点出发并回到该结点的有向小圆环。  
下面举例说明关系图的构造方法：",关系模型可以通过关系图来表示
关系的数学模型,引入,矩阵表示法,,"在使用关系的数学模型对实际问题进行建模的时候，通常需要对关系模型进行一些定量的数值计算以实现对实际问题的求解，此时无论是关系的集合表示方法和关系图法，都不方便实现对关系模型定量的数值计算。为此，我们引入二元关系的矩阵表示法。  
假设$\boldsymbol A=\{a_{1},a_{2},\cdots,a_{n}\}$, $B=\{b_{1},b_{2},\cdots,b_{m}\}$是任意给定的两个非空有限集合，$R$是$A$到$B$的一个二元关系，则按下列方式定义的$m\times n$阶矩阵$M_{R}=(r_{i j})_{m\times n}$称为$R$的关系矩阵：
$$
r_{ij}=\begin{cases}1\text{,若}\langle a_i,b_j\rangle\in R\\0\text{,若}\langle a_i,b_j\rangle\not\in R\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-3)}
$$
其中$A$中元素$a_{i\cdot}$序号对应矩阵元素的行下标，$B$中元素$b_{j}$序号对应矩阵元素的列下标。  
值得注意的是：由关系矩阵的定义可知，关系矩阵的元素有且仅有0 和1 这两种状态，这样的矩阵一般称之为布尔矩阵，主要用于一些逻辑演算，在运算规则上与普通矩阵有一些差异。为满足后续内容学习的需要，在此简要介绍布尔矩阵的若干基本运算，具体包括并运算、交运算、补运算和布尔积运算，其具体定义如下：  
【定义5.9】设$A=\left(a_{i j}\right)$和$B=\left(b_{i j}\right)$是两个$m\times n$布尔矩阵，则$𝐴$和$B$的并矩阵定义为如下$m\times n$布尔矩阵：$A\lor B=C=\left(c_{i j}\right)$，其中：  
$c_{ij}=\begin{cases}1\text{,如果}a_{ij}=1\text{ 或}b_{ij}=1\\0\text{,如果}a_{ij}=0\text{ 且}b_{ij}=0\end{cases}(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-4)}$      （5-4）  
【定义5.10】设$A=\left(a_{i j}\right)$和$B=\left(b_{i j}\right)$是两个$m\times n$布尔矩阵，则$A$和$B$的交矩阵定义为如下一个$m\times n$布尔矩阵：$A\land B=C=\left(c_{i j}\right)$，其中：
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=1\text{ 且}b_{ij}=1\\0\text{,如果}a_{ij}=0\text{ 或}b_{ij}=0\end{cases}(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-5)}
$$
【定义5.11】设$A=\left(a_{i j}\right)$任意给定的一个$m\times n$布尔矩阵，则𝐴的补矩阵定义为如下$m\times$$n$布尔矩阵：$\bar{A}=C=\left(c_{i j}\right)$，其中：
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=0\\0\text{,如果}a_{ij}=1\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-6)}
$$
【定义5.12】设$A=\left(a_{i j}\right)$是$m\times p$矩阵，$B=\left(b_{i j}\right)$是$p\times n$矩阵，则$𝐴$和$B$的布尔积矩阵定义为如下$m\times n$布尔矩阵：$A\odot B=C=\left(c_{i j}\right)$，其中：  
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=0\\0\text{,如果}a_{ij}=1\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-6)}
$$
需要注意的是：两个布尔矩阵可进行布尔或和布尔与运算的前提是这两个矩阵具有相同的行数和列数，可进行布尔积运算的前提是前一个矩阵的列数等于后一个矩阵的行数。  
在学习了二元关系的三个基本表示方法后，下面我们考察空关系、完全关系和恒等关系这三个常用特殊关系的关系矩阵和关系图各有什么特点：  
(1) 空关系$\varnothing$  因为$\emptyset\subseteq A\times B$(或$\emptyset\subseteq A\times A)$)，所以$\varnothing$也是一个从$𝐴$到$B$(或$𝐴$上)的关系，称之为空关系，即无任何元素的关系。空关系的关系图中只有结点，无任何边，且关系矩阵中的元素全是0  
(2) 完全关系（全域关系） $A\times B$或(或$A\times A)$本身也是一个从$𝐴$到$B$(或$𝐴$上)的关系，称之为完全关系，即含有全部序偶的关系。完全关系的关系图中所有结点之间都有有向边互联，关系矩阵中的元素全是1。  
(3) 恒等关系 $I_{A}$  $I_{A}\subseteq A\times A$，则$I_{A}=\{\langle x,x\rangle|x\in A\}$为$A$上的恒等关系。完全关系的关系图中所有结点都有一个有向环，不同结点之间无任何有向边联结。  
![](images/9a95167e68610708edb7fef0f0474b8284d349dcc5f3b662d3280809d00fbf1e.jpg)
图5-6 空关系、全关系与恒等关系  
设$A=\left\{1,\ 2,\ 3\right\}$，则$A$ 上的空关系∅、完全关系$A\times A$及恒等关系$I_{A}$的关系图如图5-6 所示，下面三个布尔矩阵分别是它们的关系矩阵：  
$M_{\emptyset}=\left(\begin{array}{ccc}0&0&0\\0&0&0\\0&0&0\end{array}\right)\quad M_{A\times A}=\left(\begin{array}{ccc}1&1&1\\1&1&1\\1&1&1\end{array}\right)\quad M_{I_A}=\left(\begin{array}{ccc}1&0&0\\0&1&0\\0&0&1\end{array}\right)$",关系的数学模型引入矩阵表示法以方便进行定量数值计算
矩阵表示法,定义,布尔矩阵,,"在使用关系的数学模型对实际问题进行建模的时候，通常需要对关系模型进行一些定量的数值计算以实现对实际问题的求解，此时无论是关系的集合表示方法和关系图法，都不方便实现对关系模型定量的数值计算。为此，我们引入二元关系的矩阵表示法。  
假设$\boldsymbol A=\{a_{1},a_{2},\cdots,a_{n}\}$, $B=\{b_{1},b_{2},\cdots,b_{m}\}$是任意给定的两个非空有限集合，$R$是$A$到$B$的一个二元关系，则按下列方式定义的$m\times n$阶矩阵$M_{R}=(r_{i j})_{m\times n}$称为$R$的关系矩阵：
$$
r_{ij}=\begin{cases}1\text{,若}\langle a_i,b_j\rangle\in R\\0\text{,若}\langle a_i,b_j\rangle\not\in R\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-3)}
$$
其中$A$中元素$a_{i\cdot}$序号对应矩阵元素的行下标，$B$中元素$b_{j}$序号对应矩阵元素的列下标。  
值得注意的是：由关系矩阵的定义可知，关系矩阵的元素有且仅有0 和1 这两种状态，这样的矩阵一般称之为布尔矩阵，主要用于一些逻辑演算，在运算规则上与普通矩阵有一些差异。为满足后续内容学习的需要，在此简要介绍布尔矩阵的若干基本运算，具体包括并运算、交运算、补运算和布尔积运算，其具体定义如下：  
【定义5.9】设$A=\left(a_{i j}\right)$和$B=\left(b_{i j}\right)$是两个$m\times n$布尔矩阵，则$𝐴$和$B$的并矩阵定义为如下$m\times n$布尔矩阵：$A\lor B=C=\left(c_{i j}\right)$，其中：  
$c_{ij}=\begin{cases}1\text{,如果}a_{ij}=1\text{ 或}b_{ij}=1\\0\text{,如果}a_{ij}=0\text{ 且}b_{ij}=0\end{cases}(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-4)}$      （5-4）  
【定义5.10】设$A=\left(a_{i j}\right)$和$B=\left(b_{i j}\right)$是两个$m\times n$布尔矩阵，则$A$和$B$的交矩阵定义为如下一个$m\times n$布尔矩阵：$A\land B=C=\left(c_{i j}\right)$，其中：
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=1\text{ 且}b_{ij}=1\\0\text{,如果}a_{ij}=0\text{ 或}b_{ij}=0\end{cases}(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-5)}
$$
【定义5.11】设$A=\left(a_{i j}\right)$任意给定的一个$m\times n$布尔矩阵，则𝐴的补矩阵定义为如下$m\times$$n$布尔矩阵：$\bar{A}=C=\left(c_{i j}\right)$，其中：
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=0\\0\text{,如果}a_{ij}=1\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-6)}
$$
【定义5.12】设$A=\left(a_{i j}\right)$是$m\times p$矩阵，$B=\left(b_{i j}\right)$是$p\times n$矩阵，则$𝐴$和$B$的布尔积矩阵定义为如下$m\times n$布尔矩阵：$A\odot B=C=\left(c_{i j}\right)$，其中：  
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=0\\0\text{,如果}a_{ij}=1\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-6)}
$$
需要注意的是：两个布尔矩阵可进行布尔或和布尔与运算的前提是这两个矩阵具有相同的行数和列数，可进行布尔积运算的前提是前一个矩阵的列数等于后一个矩阵的行数。  
在学习了二元关系的三个基本表示方法后，下面我们考察空关系、完全关系和恒等关系这三个常用特殊关系的关系矩阵和关系图各有什么特点：  
(1) 空关系$\varnothing$  因为$\emptyset\subseteq A\times B$(或$\emptyset\subseteq A\times A)$)，所以$\varnothing$也是一个从$𝐴$到$B$(或$𝐴$上)的关系，称之为空关系，即无任何元素的关系。空关系的关系图中只有结点，无任何边，且关系矩阵中的元素全是0  
(2) 完全关系（全域关系） $A\times B$或(或$A\times A)$本身也是一个从$𝐴$到$B$(或$𝐴$上)的关系，称之为完全关系，即含有全部序偶的关系。完全关系的关系图中所有结点之间都有有向边互联，关系矩阵中的元素全是1。  
(3) 恒等关系 $I_{A}$  $I_{A}\subseteq A\times A$，则$I_{A}=\{\langle x,x\rangle|x\in A\}$为$A$上的恒等关系。完全关系的关系图中所有结点都有一个有向环，不同结点之间无任何有向边联结。  
![](images/9a95167e68610708edb7fef0f0474b8284d349dcc5f3b662d3280809d00fbf1e.jpg)
图5-6 空关系、全关系与恒等关系  
设$A=\left\{1,\ 2,\ 3\right\}$，则$A$ 上的空关系∅、完全关系$A\times A$及恒等关系$I_{A}$的关系图如图5-6 所示，下面三个布尔矩阵分别是它们的关系矩阵：  
$M_{\emptyset}=\left(\begin{array}{ccc}0&0&0\\0&0&0\\0&0&0\end{array}\right)\quad M_{A\times A}=\left(\begin{array}{ccc}1&1&1\\1&1&1\\1&1&1\end{array}\right)\quad M_{I_A}=\left(\begin{array}{ccc}1&0&0\\0&1&0\\0&0&1\end{array}\right)$",矩阵表示法中定义的关系矩阵元素仅有0和1，称为布尔矩阵
空关系,对应,布尔矩阵,,"在使用关系的数学模型对实际问题进行建模的时候，通常需要对关系模型进行一些定量的数值计算以实现对实际问题的求解，此时无论是关系的集合表示方法和关系图法，都不方便实现对关系模型定量的数值计算。为此，我们引入二元关系的矩阵表示法。  
假设$\boldsymbol A=\{a_{1},a_{2},\cdots,a_{n}\}$, $B=\{b_{1},b_{2},\cdots,b_{m}\}$是任意给定的两个非空有限集合，$R$是$A$到$B$的一个二元关系，则按下列方式定义的$m\times n$阶矩阵$M_{R}=(r_{i j})_{m\times n}$称为$R$的关系矩阵：
$$
r_{ij}=\begin{cases}1\text{,若}\langle a_i,b_j\rangle\in R\\0\text{,若}\langle a_i,b_j\rangle\not\in R\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-3)}
$$
其中$A$中元素$a_{i\cdot}$序号对应矩阵元素的行下标，$B$中元素$b_{j}$序号对应矩阵元素的列下标。  
值得注意的是：由关系矩阵的定义可知，关系矩阵的元素有且仅有0 和1 这两种状态，这样的矩阵一般称之为布尔矩阵，主要用于一些逻辑演算，在运算规则上与普通矩阵有一些差异。为满足后续内容学习的需要，在此简要介绍布尔矩阵的若干基本运算，具体包括并运算、交运算、补运算和布尔积运算，其具体定义如下：  
【定义5.9】设$A=\left(a_{i j}\right)$和$B=\left(b_{i j}\right)$是两个$m\times n$布尔矩阵，则$𝐴$和$B$的并矩阵定义为如下$m\times n$布尔矩阵：$A\lor B=C=\left(c_{i j}\right)$，其中：  
$c_{ij}=\begin{cases}1\text{,如果}a_{ij}=1\text{ 或}b_{ij}=1\\0\text{,如果}a_{ij}=0\text{ 且}b_{ij}=0\end{cases}(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-4)}$      （5-4）  
【定义5.10】设$A=\left(a_{i j}\right)$和$B=\left(b_{i j}\right)$是两个$m\times n$布尔矩阵，则$A$和$B$的交矩阵定义为如下一个$m\times n$布尔矩阵：$A\land B=C=\left(c_{i j}\right)$，其中：
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=1\text{ 且}b_{ij}=1\\0\text{,如果}a_{ij}=0\text{ 或}b_{ij}=0\end{cases}(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-5)}
$$
【定义5.11】设$A=\left(a_{i j}\right)$任意给定的一个$m\times n$布尔矩阵，则𝐴的补矩阵定义为如下$m\times$$n$布尔矩阵：$\bar{A}=C=\left(c_{i j}\right)$，其中：
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=0\\0\text{,如果}a_{ij}=1\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-6)}
$$
【定义5.12】设$A=\left(a_{i j}\right)$是$m\times p$矩阵，$B=\left(b_{i j}\right)$是$p\times n$矩阵，则$𝐴$和$B$的布尔积矩阵定义为如下$m\times n$布尔矩阵：$A\odot B=C=\left(c_{i j}\right)$，其中：  
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=0\\0\text{,如果}a_{ij}=1\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-6)}
$$
需要注意的是：两个布尔矩阵可进行布尔或和布尔与运算的前提是这两个矩阵具有相同的行数和列数，可进行布尔积运算的前提是前一个矩阵的列数等于后一个矩阵的行数。  
在学习了二元关系的三个基本表示方法后，下面我们考察空关系、完全关系和恒等关系这三个常用特殊关系的关系矩阵和关系图各有什么特点：  
(1) 空关系$\varnothing$  因为$\emptyset\subseteq A\times B$(或$\emptyset\subseteq A\times A)$)，所以$\varnothing$也是一个从$𝐴$到$B$(或$𝐴$上)的关系，称之为空关系，即无任何元素的关系。空关系的关系图中只有结点，无任何边，且关系矩阵中的元素全是0  
(2) 完全关系（全域关系） $A\times B$或(或$A\times A)$本身也是一个从$𝐴$到$B$(或$𝐴$上)的关系，称之为完全关系，即含有全部序偶的关系。完全关系的关系图中所有结点之间都有有向边互联，关系矩阵中的元素全是1。  
(3) 恒等关系 $I_{A}$  $I_{A}\subseteq A\times A$，则$I_{A}=\{\langle x,x\rangle|x\in A\}$为$A$上的恒等关系。完全关系的关系图中所有结点都有一个有向环，不同结点之间无任何有向边联结。  
![](images/9a95167e68610708edb7fef0f0474b8284d349dcc5f3b662d3280809d00fbf1e.jpg)
图5-6 空关系、全关系与恒等关系  
设$A=\left\{1,\ 2,\ 3\right\}$，则$A$ 上的空关系∅、完全关系$A\times A$及恒等关系$I_{A}$的关系图如图5-6 所示，下面三个布尔矩阵分别是它们的关系矩阵：  
$M_{\emptyset}=\left(\begin{array}{ccc}0&0&0\\0&0&0\\0&0&0\end{array}\right)\quad M_{A\times A}=\left(\begin{array}{ccc}1&1&1\\1&1&1\\1&1&1\end{array}\right)\quad M_{I_A}=\left(\begin{array}{ccc}1&0&0\\0&1&0\\0&0&1\end{array}\right)$",空关系的关系矩阵中元素全是0
完全关系,对应,布尔矩阵,,"在使用关系的数学模型对实际问题进行建模的时候，通常需要对关系模型进行一些定量的数值计算以实现对实际问题的求解，此时无论是关系的集合表示方法和关系图法，都不方便实现对关系模型定量的数值计算。为此，我们引入二元关系的矩阵表示法。  
假设$\boldsymbol A=\{a_{1},a_{2},\cdots,a_{n}\}$, $B=\{b_{1},b_{2},\cdots,b_{m}\}$是任意给定的两个非空有限集合，$R$是$A$到$B$的一个二元关系，则按下列方式定义的$m\times n$阶矩阵$M_{R}=(r_{i j})_{m\times n}$称为$R$的关系矩阵：
$$
r_{ij}=\begin{cases}1\text{,若}\langle a_i,b_j\rangle\in R\\0\text{,若}\langle a_i,b_j\rangle\not\in R\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-3)}
$$
其中$A$中元素$a_{i\cdot}$序号对应矩阵元素的行下标，$B$中元素$b_{j}$序号对应矩阵元素的列下标。  
值得注意的是：由关系矩阵的定义可知，关系矩阵的元素有且仅有0 和1 这两种状态，这样的矩阵一般称之为布尔矩阵，主要用于一些逻辑演算，在运算规则上与普通矩阵有一些差异。为满足后续内容学习的需要，在此简要介绍布尔矩阵的若干基本运算，具体包括并运算、交运算、补运算和布尔积运算，其具体定义如下：  
【定义5.9】设$A=\left(a_{i j}\right)$和$B=\left(b_{i j}\right)$是两个$m\times n$布尔矩阵，则$𝐴$和$B$的并矩阵定义为如下$m\times n$布尔矩阵：$A\lor B=C=\left(c_{i j}\right)$，其中：  
$c_{ij}=\begin{cases}1\text{,如果}a_{ij}=1\text{ 或}b_{ij}=1\\0\text{,如果}a_{ij}=0\text{ 且}b_{ij}=0\end{cases}(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-4)}$      （5-4）  
【定义5.10】设$A=\left(a_{i j}\right)$和$B=\left(b_{i j}\right)$是两个$m\times n$布尔矩阵，则$A$和$B$的交矩阵定义为如下一个$m\times n$布尔矩阵：$A\land B=C=\left(c_{i j}\right)$，其中：
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=1\text{ 且}b_{ij}=1\\0\text{,如果}a_{ij}=0\text{ 或}b_{ij}=0\end{cases}(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-5)}
$$
【定义5.11】设$A=\left(a_{i j}\right)$任意给定的一个$m\times n$布尔矩阵，则𝐴的补矩阵定义为如下$m\times$$n$布尔矩阵：$\bar{A}=C=\left(c_{i j}\right)$，其中：
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=0\\0\text{,如果}a_{ij}=1\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-6)}
$$
【定义5.12】设$A=\left(a_{i j}\right)$是$m\times p$矩阵，$B=\left(b_{i j}\right)$是$p\times n$矩阵，则$𝐴$和$B$的布尔积矩阵定义为如下$m\times n$布尔矩阵：$A\odot B=C=\left(c_{i j}\right)$，其中：  
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=0\\0\text{,如果}a_{ij}=1\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-6)}
$$
需要注意的是：两个布尔矩阵可进行布尔或和布尔与运算的前提是这两个矩阵具有相同的行数和列数，可进行布尔积运算的前提是前一个矩阵的列数等于后一个矩阵的行数。  
在学习了二元关系的三个基本表示方法后，下面我们考察空关系、完全关系和恒等关系这三个常用特殊关系的关系矩阵和关系图各有什么特点：  
(1) 空关系$\varnothing$  因为$\emptyset\subseteq A\times B$(或$\emptyset\subseteq A\times A)$)，所以$\varnothing$也是一个从$𝐴$到$B$(或$𝐴$上)的关系，称之为空关系，即无任何元素的关系。空关系的关系图中只有结点，无任何边，且关系矩阵中的元素全是0  
(2) 完全关系（全域关系） $A\times B$或(或$A\times A)$本身也是一个从$𝐴$到$B$(或$𝐴$上)的关系，称之为完全关系，即含有全部序偶的关系。完全关系的关系图中所有结点之间都有有向边互联，关系矩阵中的元素全是1。  
(3) 恒等关系 $I_{A}$  $I_{A}\subseteq A\times A$，则$I_{A}=\{\langle x,x\rangle|x\in A\}$为$A$上的恒等关系。完全关系的关系图中所有结点都有一个有向环，不同结点之间无任何有向边联结。  
![](images/9a95167e68610708edb7fef0f0474b8284d349dcc5f3b662d3280809d00fbf1e.jpg)
图5-6 空关系、全关系与恒等关系  
设$A=\left\{1,\ 2,\ 3\right\}$，则$A$ 上的空关系∅、完全关系$A\times A$及恒等关系$I_{A}$的关系图如图5-6 所示，下面三个布尔矩阵分别是它们的关系矩阵：  
$M_{\emptyset}=\left(\begin{array}{ccc}0&0&0\\0&0&0\\0&0&0\end{array}\right)\quad M_{A\times A}=\left(\begin{array}{ccc}1&1&1\\1&1&1\\1&1&1\end{array}\right)\quad M_{I_A}=\left(\begin{array}{ccc}1&0&0\\0&1&0\\0&0&1\end{array}\right)$",完全关系的关系矩阵中元素全是1
恒等关系,对应,布尔矩阵,,"在使用关系的数学模型对实际问题进行建模的时候，通常需要对关系模型进行一些定量的数值计算以实现对实际问题的求解，此时无论是关系的集合表示方法和关系图法，都不方便实现对关系模型定量的数值计算。为此，我们引入二元关系的矩阵表示法。  
假设$\boldsymbol A=\{a_{1},a_{2},\cdots,a_{n}\}$, $B=\{b_{1},b_{2},\cdots,b_{m}\}$是任意给定的两个非空有限集合，$R$是$A$到$B$的一个二元关系，则按下列方式定义的$m\times n$阶矩阵$M_{R}=(r_{i j})_{m\times n}$称为$R$的关系矩阵：
$$
r_{ij}=\begin{cases}1\text{,若}\langle a_i,b_j\rangle\in R\\0\text{,若}\langle a_i,b_j\rangle\not\in R\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-3)}
$$
其中$A$中元素$a_{i\cdot}$序号对应矩阵元素的行下标，$B$中元素$b_{j}$序号对应矩阵元素的列下标。  
值得注意的是：由关系矩阵的定义可知，关系矩阵的元素有且仅有0 和1 这两种状态，这样的矩阵一般称之为布尔矩阵，主要用于一些逻辑演算，在运算规则上与普通矩阵有一些差异。为满足后续内容学习的需要，在此简要介绍布尔矩阵的若干基本运算，具体包括并运算、交运算、补运算和布尔积运算，其具体定义如下：  
【定义5.9】设$A=\left(a_{i j}\right)$和$B=\left(b_{i j}\right)$是两个$m\times n$布尔矩阵，则$𝐴$和$B$的并矩阵定义为如下$m\times n$布尔矩阵：$A\lor B=C=\left(c_{i j}\right)$，其中：  
$c_{ij}=\begin{cases}1\text{,如果}a_{ij}=1\text{ 或}b_{ij}=1\\0\text{,如果}a_{ij}=0\text{ 且}b_{ij}=0\end{cases}(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-4)}$      （5-4）  
【定义5.10】设$A=\left(a_{i j}\right)$和$B=\left(b_{i j}\right)$是两个$m\times n$布尔矩阵，则$A$和$B$的交矩阵定义为如下一个$m\times n$布尔矩阵：$A\land B=C=\left(c_{i j}\right)$，其中：
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=1\text{ 且}b_{ij}=1\\0\text{,如果}a_{ij}=0\text{ 或}b_{ij}=0\end{cases}(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-5)}
$$
【定义5.11】设$A=\left(a_{i j}\right)$任意给定的一个$m\times n$布尔矩阵，则𝐴的补矩阵定义为如下$m\times$$n$布尔矩阵：$\bar{A}=C=\left(c_{i j}\right)$，其中：
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=0\\0\text{,如果}a_{ij}=1\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-6)}
$$
【定义5.12】设$A=\left(a_{i j}\right)$是$m\times p$矩阵，$B=\left(b_{i j}\right)$是$p\times n$矩阵，则$𝐴$和$B$的布尔积矩阵定义为如下$m\times n$布尔矩阵：$A\odot B=C=\left(c_{i j}\right)$，其中：  
$$
c_{ij}=\begin{cases}1\text{,如果}a_{ij}=0\\0\text{,如果}a_{ij}=1\end{cases}\quad(1\leq i\leq m,1\leq j\leq n)\quad\text{(5-6)}
$$
需要注意的是：两个布尔矩阵可进行布尔或和布尔与运算的前提是这两个矩阵具有相同的行数和列数，可进行布尔积运算的前提是前一个矩阵的列数等于后一个矩阵的行数。  
在学习了二元关系的三个基本表示方法后，下面我们考察空关系、完全关系和恒等关系这三个常用特殊关系的关系矩阵和关系图各有什么特点：  
(1) 空关系$\varnothing$  因为$\emptyset\subseteq A\times B$(或$\emptyset\subseteq A\times A)$)，所以$\varnothing$也是一个从$𝐴$到$B$(或$𝐴$上)的关系，称之为空关系，即无任何元素的关系。空关系的关系图中只有结点，无任何边，且关系矩阵中的元素全是0  
(2) 完全关系（全域关系） $A\times B$或(或$A\times A)$本身也是一个从$𝐴$到$B$(或$𝐴$上)的关系，称之为完全关系，即含有全部序偶的关系。完全关系的关系图中所有结点之间都有有向边互联，关系矩阵中的元素全是1。  
(3) 恒等关系 $I_{A}$  $I_{A}\subseteq A\times A$，则$I_{A}=\{\langle x,x\rangle|x\in A\}$为$A$上的恒等关系。完全关系的关系图中所有结点都有一个有向环，不同结点之间无任何有向边联结。  
![](images/9a95167e68610708edb7fef0f0474b8284d349dcc5f3b662d3280809d00fbf1e.jpg)
图5-6 空关系、全关系与恒等关系  
设$A=\left\{1,\ 2,\ 3\right\}$，则$A$ 上的空关系∅、完全关系$A\times A$及恒等关系$I_{A}$的关系图如图5-6 所示，下面三个布尔矩阵分别是它们的关系矩阵：  
$M_{\emptyset}=\left(\begin{array}{ccc}0&0&0\\0&0&0\\0&0&0\end{array}\right)\quad M_{A\times A}=\left(\begin{array}{ccc}1&1&1\\1&1&1\\1&1&1\end{array}\right)\quad M_{I_A}=\left(\begin{array}{ccc}1&0&0\\0&1&0\\0&0&1\end{array}\right)$",恒等关系的关系矩阵中对角线元素为1，其余为0
关系的基本运算,包含,集合运算,,本节在关系概念的基础上考察关系的基本运算。首先，关系作为一种特殊的集合，可以按集合的概念进行交、并、差、补等集合运算。此外，从关系图可以看出，从集合$𝐴$到集合$B$的关系是一种从此到彼的方向性联系，故此可将两个关系通过适当的方式进行合成或串接形成一个新的关系，由此得到关系的复合运算。由关系的集合运算与复合运算还可进一步衍生出关系的幂运算、逆运算，以及面向数据库操作的连接、投影等专用关系运算。,关系的基本运算包括交、并、差、补等集合运算
关系的基本运算,包含,复合运算,,本节在关系概念的基础上考察关系的基本运算。首先，关系作为一种特殊的集合，可以按集合的概念进行交、并、差、补等集合运算。此外，从关系图可以看出，从集合$𝐴$到集合$B$的关系是一种从此到彼的方向性联系，故此可将两个关系通过适当的方式进行合成或串接形成一个新的关系，由此得到关系的复合运算。由关系的集合运算与复合运算还可进一步衍生出关系的幂运算、逆运算，以及面向数据库操作的连接、投影等专用关系运算。,关系的基本运算包括通过合成或串接形成新关系的复合运算
关系的基本运算,衍生,幂运算,,本节在关系概念的基础上考察关系的基本运算。首先，关系作为一种特殊的集合，可以按集合的概念进行交、并、差、补等集合运算。此外，从关系图可以看出，从集合$𝐴$到集合$B$的关系是一种从此到彼的方向性联系，故此可将两个关系通过适当的方式进行合成或串接形成一个新的关系，由此得到关系的复合运算。由关系的集合运算与复合运算还可进一步衍生出关系的幂运算、逆运算，以及面向数据库操作的连接、投影等专用关系运算。,关系的集合运算与复合运算衍生出关系的幂运算
关系的基本运算,衍生,逆运算,,本节在关系概念的基础上考察关系的基本运算。首先，关系作为一种特殊的集合，可以按集合的概念进行交、并、差、补等集合运算。此外，从关系图可以看出，从集合$𝐴$到集合$B$的关系是一种从此到彼的方向性联系，故此可将两个关系通过适当的方式进行合成或串接形成一个新的关系，由此得到关系的复合运算。由关系的集合运算与复合运算还可进一步衍生出关系的幂运算、逆运算，以及面向数据库操作的连接、投影等专用关系运算。,关系的集合运算与复合运算衍生出关系的逆运算
关系的基本运算,衍生,连接,,本节在关系概念的基础上考察关系的基本运算。首先，关系作为一种特殊的集合，可以按集合的概念进行交、并、差、补等集合运算。此外，从关系图可以看出，从集合$𝐴$到集合$B$的关系是一种从此到彼的方向性联系，故此可将两个关系通过适当的方式进行合成或串接形成一个新的关系，由此得到关系的复合运算。由关系的集合运算与复合运算还可进一步衍生出关系的幂运算、逆运算，以及面向数据库操作的连接、投影等专用关系运算。,关系的集合运算与复合运算衍生出面向数据库操作的连接运算
关系的基本运算,衍生,投影,,本节在关系概念的基础上考察关系的基本运算。首先，关系作为一种特殊的集合，可以按集合的概念进行交、并、差、补等集合运算。此外，从关系图可以看出，从集合$𝐴$到集合$B$的关系是一种从此到彼的方向性联系，故此可将两个关系通过适当的方式进行合成或串接形成一个新的关系，由此得到关系的复合运算。由关系的集合运算与复合运算还可进一步衍生出关系的幂运算、逆运算，以及面向数据库操作的连接、投影等专用关系运算。,关系的集合运算与复合运算衍生出面向数据库操作的投影运算
关系的基本运算,包含,关系的集合运算,,"二元关系是以序偶为元素的集合，因此可以对它进行集合的运算，通过集合的交、并、差、补等运算而产生新的集合。这些新的集合显然也是由序偶组成的集合，因而也是关系。具体地说，如果$R、{S}$ 是$X$到$Y$的二元关系，那么$R\cup S$，$R\cap S$，$R-S$，$\bar{R}$也是$X$到$Y$的二元关系。具体定义如下：  
【定义5.13】设$R$、$S$都是从集合$A$ 到$B$ 的两个关系，则可按下列方式定义它们的交、并、差、补运算：
$$
R\cup S=\{\langle x,y\rangle|(x R y)\lor(x S y)\};\quad R\cap S=\{\langle x,y\rangle|(x R y)\land(x S y)\}
$$  
$$
R-S=\{\langle x,y\rangle|(x R y)\wedge(x S y)\};\quad\bar{R}=\{\langle x,y\rangle|(x S y)\}
$$
有关集合交、并、差、补运算的性质，对上述定义的关系集合运算显然也是成立的，这些性质就不再一一赘述了。这里就需要注意的是：对于任意一个从集合$A$ 到$B$ 的二元关系$R$，从集合的角度看$A\times B$是相对于$R$ 的全集，故有：
$$
\bar{R}=A\times B-R;\;\;\bar{R}\cup R=A\times B;\;\;\bar{R}\cap R=\emptyset;\;\;\bar{R}=R;\;\;S\subseteq R\Leftrightarrow\bar{R}\subseteq\bar{S}
$$
不难看出，关系的交、并、差、补运算结果还可以通过关系矩阵的计算得到：
$$
M_{H\cup S}=M_{H}\lor M_{S};\,\,\,M_{H\cap S}=M_{H}\land M_{S};\,\,\,M_{\bar{H}}=\bar{M}_{H};\,\,\,M_{H-S}=M_{H}\land\bar{M}_{S}
$$",关系的基本运算包括关系的集合运算，如交、并、差、补等
关系的集合运算,实现方式,关系矩阵的计算,,"二元关系是以序偶为元素的集合，因此可以对它进行集合的运算，通过集合的交、并、差、补等运算而产生新的集合。这些新的集合显然也是由序偶组成的集合，因而也是关系。具体地说，如果$R、{S}$ 是$X$到$Y$的二元关系，那么$R\cup S$，$R\cap S$，$R-S$，$\bar{R}$也是$X$到$Y$的二元关系。具体定义如下：  
【定义5.13】设$R$、$S$都是从集合$A$ 到$B$ 的两个关系，则可按下列方式定义它们的交、并、差、补运算：
$$
R\cup S=\{\langle x,y\rangle|(x R y)\lor(x S y)\};\quad R\cap S=\{\langle x,y\rangle|(x R y)\land(x S y)\}
$$  
$$
R-S=\{\langle x,y\rangle|(x R y)\wedge(x S y)\};\quad\bar{R}=\{\langle x,y\rangle|(x S y)\}
$$
有关集合交、并、差、补运算的性质，对上述定义的关系集合运算显然也是成立的，这些性质就不再一一赘述了。这里就需要注意的是：对于任意一个从集合$A$ 到$B$ 的二元关系$R$，从集合的角度看$A\times B$是相对于$R$ 的全集，故有：
$$
\bar{R}=A\times B-R;\;\;\bar{R}\cup R=A\times B;\;\;\bar{R}\cap R=\emptyset;\;\;\bar{R}=R;\;\;S\subseteq R\Leftrightarrow\bar{R}\subseteq\bar{S}
$$
不难看出，关系的交、并、差、补运算结果还可以通过关系矩阵的计算得到：
$$
M_{H\cup S}=M_{H}\lor M_{S};\,\,\,M_{H\cap S}=M_{H}\land M_{S};\,\,\,M_{\bar{H}}=\bar{M}_{H};\,\,\,M_{H-S}=M_{H}\land\bar{M}_{S}
$$",关系的集合运算结果可以通过关系矩阵的计算得到
关系的基本运算,区别,关系的复合运算,,"日常生活和工作中很多关系问题仅用关系的集合运算不能得到有效的解决。例如：假设集合$𝐴$表示某家族的全部成员构成的集合，在$𝐴$上定义如下两个关系$R$和$𝑆$：  
$R$表示$A$上的兄弟关系，$\langle x,y\rangle\in R$,当且仅当$x$是$y$的兄弟;  
$S$表示 $A$ 上的父子关系，$\langle y,z\rangle\in S$,当且仅当$y$ 是$z$ 的父亲。  
则可通过元素$y$的中间媒介或传递作用，在$x$与$z$之间产生一个新的关系，即叔侄关系。换句话说，叔侄关系是由兄弟关系和父子关系的合成。  
![](images/8ed5b0cc3c8222133404e26aeb757d647b1fb51cdae3d0c7fbf0c3754976758e.jpg)
图5-7 叔侄关系图  
例如，假设在小说《红楼梦》中人物的兄弟关系为𝑅、父子关系为𝑆，则有：
$$
\begin{aligned}&R=\left\{\langle\text{贾宝玉},\text{贾环}\rangle,\langle\text{贾政},\textbf{贾赦}\rangle,\cdots\right\};\\&S=\left\{\langle\text{贾政},\text{贾宝玉}\rangle,\langle\text{贾政},\text{贾环}\rangle,\langle\textbf{贾赦 贾琏}\rangle,\cdots\right\}\end{aligned}
$$
如图5-7 所示，在上述$R$和$𝑆$这两个二元关系中，贾政和贾琏之间通过贾赦的中间媒介或传递作用建立了叔侄关系。一般地，将关系这种合成机制进行抽象，用数学语言进行表达，就得到如下关系复合运算的定义：  
【定义5.14】假设$A$、$B$、$C$ 是三个非空集合，$R$ 是从$A$ 到$B$ 的关系，$S$ 是从$B$ 到$C$的关系，则$R$ 与$S$ 的复合关系$R\circ S$定义为如下从$A$ 到$C$的关系：  
$$R\circ S=\{\langle x,z\rangle|x\in A\land z\in C\land(\exists y)(y\in B\land x R y\land y S z)\quad\text{(5-5)}$$  
运算“ ∘”称为复合运算。  
从上述定义可知：不是任意两个关系都能进行复合运算，当且仅当$R$ 的后域是$S$的前域时，$R$ 和$S$ 才可复合；$R\circ S$的前域是$R$ 的前域$A$，$R\circ S$的后域是$S$ 的后域$C$。  
任何一个关系都有集合、关系图和矩阵这三种表现形式，复合运算在这三种不同表现形式下分别具有相应的具体计算方法，下面分别介绍这三种复合计算方法。  
令$A=\{a_1,a_2,\cdots,a_m\},B=\{b_1,b_2,\cdots,b_n\},C=\{c_1,c_2,\cdots,c_t\},R$ 是$A$ 到$B$ 的关系，$S$ 是$B$ 到 $C$ 的关系，即有$R$$\subseteq{A}\times{B}$, $S$$\subseteq{B}\times{C}$, 则$R\circ S$可按下列方法进行计算.  
1 ．集合法    由复合运算的定义可知，对于任意的 $a_{i}\in A,c_{j}\in C$ ，若 $\langle a_{i},c_{j}\rangle\in R\circ S$ ，则 必然存在某个$b_{k}\in B$，使得$\langle a_{i},b_{k}\rangle\in R$并且$\langle b_{k},c_{j}\rangle\in S$。故对于$R$中每个给定的序偶$\langle a_{i},b_{k}\rangle$，要在$S$中寻遍第一元素为$b_{k}$的序偶$\langle b_{k},c_{j}\rangle$，若存在$\langle b_{k},c_{j}\rangle\in S$，则取$R$中$\langle a_{i},b_{k}\rangle$的第一元素，以及$S$中对应序偶$\langle b_{k},c_{j}\rangle$的第二元素，形成一个新的序偶$\langle a_{i},c_{j}\rangle$，该序偶即为$R\circ S$中的一个元素。同理可找出$R\circ S$中的所有元素。  
2. 关系图法  由复合运算的定义可知，对于分别属于关系$R$ 和$S$的两个序偶，它们之间能够复合的关键在于能够在这两个序偶之间找到一个桥梁$b_{k}$，使得$b_{k}$既是前一个序偶($R$中序偶)的第二元素，同时又是后一个序偶(S 中序偶)的第一元素。因此，在画复合关系的关系图时，首先应该在$R$ 和$S$ 这两个关系的关系图中搭起这个桥梁，然后拆掉中间的桥梁，直接联结经过该桥梁的两个结点，便可得到$R\circ S$的关系图。  
3.关系矩阵法  将$R$ 和$S$ 的关系矩阵做布尔积运算$\odot$，即可得到$\mathrm{~\tt~R~o~}S$的关系矩阵，然后根据该矩阵写出$R\circ S$中元素即可。也就是说，令$R$ 和$S$ 的关系矩阵分别为：
$$
M_{R}=\begin{pmatrix}\langle a_1,b_1\rangle&\langle a_1,b_2\rangle&\cdots\langle a_1,b_n\rangle\\\langle a_2,b_1\rangle&\langle a_2,b_2\rangle&\cdots\langle a_2,b_n\rangle\\\vdots\\\langle a_m,b_1\rangle\langle a_m,b_2\rangle&\cdots\langle a_m,b_n\rangle\end{pmatrix};\quad M_{S}=\begin{pmatrix}\langle b_1,c_1\rangle&\langle b_1,c_2\rangle&\cdots&\langle b_1,c_t\rangle\\\langle b_2,c_1\rangle&\langle b_2,c_2\rangle&\cdots&\langle b_2,c_t\rangle\\\vdots\\\langle b_n,b_1\rangle\langle b_n,c_2\rangle&\cdots\langle b_n,c_t\rangle\end{pmatrix}
$$
则有：
$$
M_{R\circ S}=M_{R}\odot M_{S}=\left(\begin{array}{c}{{\langle a_{1},c_{1}\rangle\ \langle a_{1},c_{2}\rangle\ \cdots\ \langle a_{1},c_{t}\rangle}}\\ {{\langle a_{2}.\,c_{1}\rangle\ \langle a_{2},c_{2}\rangle\ \cdots\ \langle a_{2},c_{t}\rangle}}\\ {{\vdots}}\\ {{\langle a_{m},c_{1}\rangle\langle a_{m},c_{2}\rangle\cdots\langle a_{m},c_{t}\rangle}}\end{array}\right)
$$  
【定理5.5】设$A$、$B$、$C$ 和$D$ 是任意四个集合，$R$、$S$和$T$ 分别是从$A$ 到$B,\ B$到$C$和$C$ 到$D$ 的二元关系，$I_{A}$和$I_{B}$分别是$A$ 和$B$ 上恒等关系，则有：
$$
(1) (R\circ S)\circ T=R\circ(S\circ T);\quad(2) I_A\circ R=R\circ I_B=R
$$  
下面的定理给出了关系的集合运算与复合运算之间的关系：复合运算对并运算具有完全的分配律，而复合运算对交运算只有有半分配律。  
【定理5.6】设$A$、$B$、$C$和$D$ 是任意四个集合，$R$ 是$A$ 到$B$ 的关系，$S_{1},\ S_{2}$是从$B$ 到$C$的关系，$T$是从$C$ 到$D$ 的关系，则有：  
（1）$R\circ(S_{1}\cup S_{2})=(R\circ S_{1})\cup(R\circ S_{2});\,\,\,(2)\,\,\,R\circ(S_{1}\cap S_{2})\subseteq(R\circ S_{1})\cap(R\circ S_{2});$ （3）$(S_{1}\cup S_{2})\circ T=(S_{1}\circ T)\cup(S_{2}\circ T);\ \ (4)\ \ (S_{1}\cap S_{2})\circ T\subseteq(S_{1}\circ T)\cap(S_{2}\circ T)。$  
上述定理和例题表明，复合运算对并运算具有完全的分配律，即分配律是以集合相等的方式出现，但复合运算对交运算不具备完全分配律，只有半分配律，也就是说，分配律是以集合包含的方式出现。如果要将关系的这些运算与数的相关运算做一些类比的话，那么关系的复合运算就比较类似于数或矩阵的乘法运算，而关系的并运算就比较类似于数或矩阵的加法运算。事实上，从复合运算和并运算的关系矩阵运算特点上，就可看出它们与数乘、数加以及矩阵乘、矩阵加的类似之处。",关系的基本运算不能解决所有关系问题，而关系的复合运算通过合成机制解决更复杂的关系问题
关系的复合运算,定义,复合关系,,"日常生活和工作中很多关系问题仅用关系的集合运算不能得到有效的解决。例如：假设集合$𝐴$表示某家族的全部成员构成的集合，在$𝐴$上定义如下两个关系$R$和$𝑆$：  
$R$表示$A$上的兄弟关系，$\langle x,y\rangle\in R$,当且仅当$x$是$y$的兄弟;  
$S$表示 $A$ 上的父子关系，$\langle y,z\rangle\in S$,当且仅当$y$ 是$z$ 的父亲。  
则可通过元素$y$的中间媒介或传递作用，在$x$与$z$之间产生一个新的关系，即叔侄关系。换句话说，叔侄关系是由兄弟关系和父子关系的合成。  
![](images/8ed5b0cc3c8222133404e26aeb757d647b1fb51cdae3d0c7fbf0c3754976758e.jpg)
图5-7 叔侄关系图  
例如，假设在小说《红楼梦》中人物的兄弟关系为𝑅、父子关系为𝑆，则有：
$$
\begin{aligned}&R=\left\{\langle\text{贾宝玉},\text{贾环}\rangle,\langle\text{贾政},\textbf{贾赦}\rangle,\cdots\right\};\\&S=\left\{\langle\text{贾政},\text{贾宝玉}\rangle,\langle\text{贾政},\text{贾环}\rangle,\langle\textbf{贾赦 贾琏}\rangle,\cdots\right\}\end{aligned}
$$
如图5-7 所示，在上述$R$和$𝑆$这两个二元关系中，贾政和贾琏之间通过贾赦的中间媒介或传递作用建立了叔侄关系。一般地，将关系这种合成机制进行抽象，用数学语言进行表达，就得到如下关系复合运算的定义：  
【定义5.14】假设$A$、$B$、$C$ 是三个非空集合，$R$ 是从$A$ 到$B$ 的关系，$S$ 是从$B$ 到$C$的关系，则$R$ 与$S$ 的复合关系$R\circ S$定义为如下从$A$ 到$C$的关系：  
$$R\circ S=\{\langle x,z\rangle|x\in A\land z\in C\land(\exists y)(y\in B\land x R y\land y S z)\quad\text{(5-5)}$$  
运算“ ∘”称为复合运算。  
从上述定义可知：不是任意两个关系都能进行复合运算，当且仅当$R$ 的后域是$S$的前域时，$R$ 和$S$ 才可复合；$R\circ S$的前域是$R$ 的前域$A$，$R\circ S$的后域是$S$ 的后域$C$。  
任何一个关系都有集合、关系图和矩阵这三种表现形式，复合运算在这三种不同表现形式下分别具有相应的具体计算方法，下面分别介绍这三种复合计算方法。  
令$A=\{a_1,a_2,\cdots,a_m\},B=\{b_1,b_2,\cdots,b_n\},C=\{c_1,c_2,\cdots,c_t\},R$ 是$A$ 到$B$ 的关系，$S$ 是$B$ 到 $C$ 的关系，即有$R$$\subseteq{A}\times{B}$, $S$$\subseteq{B}\times{C}$, 则$R\circ S$可按下列方法进行计算.  
1 ．集合法    由复合运算的定义可知，对于任意的 $a_{i}\in A,c_{j}\in C$ ，若 $\langle a_{i},c_{j}\rangle\in R\circ S$ ，则 必然存在某个$b_{k}\in B$，使得$\langle a_{i},b_{k}\rangle\in R$并且$\langle b_{k},c_{j}\rangle\in S$。故对于$R$中每个给定的序偶$\langle a_{i},b_{k}\rangle$，要在$S$中寻遍第一元素为$b_{k}$的序偶$\langle b_{k},c_{j}\rangle$，若存在$\langle b_{k},c_{j}\rangle\in S$，则取$R$中$\langle a_{i},b_{k}\rangle$的第一元素，以及$S$中对应序偶$\langle b_{k},c_{j}\rangle$的第二元素，形成一个新的序偶$\langle a_{i},c_{j}\rangle$，该序偶即为$R\circ S$中的一个元素。同理可找出$R\circ S$中的所有元素。  
2. 关系图法  由复合运算的定义可知，对于分别属于关系$R$ 和$S$的两个序偶，它们之间能够复合的关键在于能够在这两个序偶之间找到一个桥梁$b_{k}$，使得$b_{k}$既是前一个序偶($R$中序偶)的第二元素，同时又是后一个序偶(S 中序偶)的第一元素。因此，在画复合关系的关系图时，首先应该在$R$ 和$S$ 这两个关系的关系图中搭起这个桥梁，然后拆掉中间的桥梁，直接联结经过该桥梁的两个结点，便可得到$R\circ S$的关系图。  
3.关系矩阵法  将$R$ 和$S$ 的关系矩阵做布尔积运算$\odot$，即可得到$\mathrm{~\tt~R~o~}S$的关系矩阵，然后根据该矩阵写出$R\circ S$中元素即可。也就是说，令$R$ 和$S$ 的关系矩阵分别为：
$$
M_{R}=\begin{pmatrix}\langle a_1,b_1\rangle&\langle a_1,b_2\rangle&\cdots\langle a_1,b_n\rangle\\\langle a_2,b_1\rangle&\langle a_2,b_2\rangle&\cdots\langle a_2,b_n\rangle\\\vdots\\\langle a_m,b_1\rangle\langle a_m,b_2\rangle&\cdots\langle a_m,b_n\rangle\end{pmatrix};\quad M_{S}=\begin{pmatrix}\langle b_1,c_1\rangle&\langle b_1,c_2\rangle&\cdots&\langle b_1,c_t\rangle\\\langle b_2,c_1\rangle&\langle b_2,c_2\rangle&\cdots&\langle b_2,c_t\rangle\\\vdots\\\langle b_n,b_1\rangle\langle b_n,c_2\rangle&\cdots\langle b_n,c_t\rangle\end{pmatrix}
$$
则有：
$$
M_{R\circ S}=M_{R}\odot M_{S}=\left(\begin{array}{c}{{\langle a_{1},c_{1}\rangle\ \langle a_{1},c_{2}\rangle\ \cdots\ \langle a_{1},c_{t}\rangle}}\\ {{\langle a_{2}.\,c_{1}\rangle\ \langle a_{2},c_{2}\rangle\ \cdots\ \langle a_{2},c_{t}\rangle}}\\ {{\vdots}}\\ {{\langle a_{m},c_{1}\rangle\langle a_{m},c_{2}\rangle\cdots\langle a_{m},c_{t}\rangle}}\end{array}\right)
$$  
【定理5.5】设$A$、$B$、$C$ 和$D$ 是任意四个集合，$R$、$S$和$T$ 分别是从$A$ 到$B,\ B$到$C$和$C$ 到$D$ 的二元关系，$I_{A}$和$I_{B}$分别是$A$ 和$B$ 上恒等关系，则有：
$$
(1) (R\circ S)\circ T=R\circ(S\circ T);\quad(2) I_A\circ R=R\circ I_B=R
$$  
下面的定理给出了关系的集合运算与复合运算之间的关系：复合运算对并运算具有完全的分配律，而复合运算对交运算只有有半分配律。  
【定理5.6】设$A$、$B$、$C$和$D$ 是任意四个集合，$R$ 是$A$ 到$B$ 的关系，$S_{1},\ S_{2}$是从$B$ 到$C$的关系，$T$是从$C$ 到$D$ 的关系，则有：  
（1）$R\circ(S_{1}\cup S_{2})=(R\circ S_{1})\cup(R\circ S_{2});\,\,\,(2)\,\,\,R\circ(S_{1}\cap S_{2})\subseteq(R\circ S_{1})\cap(R\circ S_{2});$ （3）$(S_{1}\cup S_{2})\circ T=(S_{1}\circ T)\cup(S_{2}\circ T);\ \ (4)\ \ (S_{1}\cap S_{2})\circ T\subseteq(S_{1}\circ T)\cap(S_{2}\circ T)。$  
上述定理和例题表明，复合运算对并运算具有完全的分配律，即分配律是以集合相等的方式出现，但复合运算对交运算不具备完全分配律，只有半分配律，也就是说，分配律是以集合包含的方式出现。如果要将关系的这些运算与数的相关运算做一些类比的话，那么关系的复合运算就比较类似于数或矩阵的乘法运算，而关系的并运算就比较类似于数或矩阵的加法运算。事实上，从复合运算和并运算的关系矩阵运算特点上，就可看出它们与数乘、数加以及矩阵乘、矩阵加的类似之处。",关系的复合运算定义了如何通过两个关系的合成得到一个新的复合关系
定理5.5,性质,关系的复合运算,,"日常生活和工作中很多关系问题仅用关系的集合运算不能得到有效的解决。例如：假设集合$𝐴$表示某家族的全部成员构成的集合，在$𝐴$上定义如下两个关系$R$和$𝑆$：  
$R$表示$A$上的兄弟关系，$\langle x,y\rangle\in R$,当且仅当$x$是$y$的兄弟;  
$S$表示 $A$ 上的父子关系，$\langle y,z\rangle\in S$,当且仅当$y$ 是$z$ 的父亲。  
则可通过元素$y$的中间媒介或传递作用，在$x$与$z$之间产生一个新的关系，即叔侄关系。换句话说，叔侄关系是由兄弟关系和父子关系的合成。  
![](images/8ed5b0cc3c8222133404e26aeb757d647b1fb51cdae3d0c7fbf0c3754976758e.jpg)
图5-7 叔侄关系图  
例如，假设在小说《红楼梦》中人物的兄弟关系为𝑅、父子关系为𝑆，则有：
$$
\begin{aligned}&R=\left\{\langle\text{贾宝玉},\text{贾环}\rangle,\langle\text{贾政},\textbf{贾赦}\rangle,\cdots\right\};\\&S=\left\{\langle\text{贾政},\text{贾宝玉}\rangle,\langle\text{贾政},\text{贾环}\rangle,\langle\textbf{贾赦 贾琏}\rangle,\cdots\right\}\end{aligned}
$$
如图5-7 所示，在上述$R$和$𝑆$这两个二元关系中，贾政和贾琏之间通过贾赦的中间媒介或传递作用建立了叔侄关系。一般地，将关系这种合成机制进行抽象，用数学语言进行表达，就得到如下关系复合运算的定义：  
【定义5.14】假设$A$、$B$、$C$ 是三个非空集合，$R$ 是从$A$ 到$B$ 的关系，$S$ 是从$B$ 到$C$的关系，则$R$ 与$S$ 的复合关系$R\circ S$定义为如下从$A$ 到$C$的关系：  
$$R\circ S=\{\langle x,z\rangle|x\in A\land z\in C\land(\exists y)(y\in B\land x R y\land y S z)\quad\text{(5-5)}$$  
运算“ ∘”称为复合运算。  
从上述定义可知：不是任意两个关系都能进行复合运算，当且仅当$R$ 的后域是$S$的前域时，$R$ 和$S$ 才可复合；$R\circ S$的前域是$R$ 的前域$A$，$R\circ S$的后域是$S$ 的后域$C$。  
任何一个关系都有集合、关系图和矩阵这三种表现形式，复合运算在这三种不同表现形式下分别具有相应的具体计算方法，下面分别介绍这三种复合计算方法。  
令$A=\{a_1,a_2,\cdots,a_m\},B=\{b_1,b_2,\cdots,b_n\},C=\{c_1,c_2,\cdots,c_t\},R$ 是$A$ 到$B$ 的关系，$S$ 是$B$ 到 $C$ 的关系，即有$R$$\subseteq{A}\times{B}$, $S$$\subseteq{B}\times{C}$, 则$R\circ S$可按下列方法进行计算.  
1 ．集合法    由复合运算的定义可知，对于任意的 $a_{i}\in A,c_{j}\in C$ ，若 $\langle a_{i},c_{j}\rangle\in R\circ S$ ，则 必然存在某个$b_{k}\in B$，使得$\langle a_{i},b_{k}\rangle\in R$并且$\langle b_{k},c_{j}\rangle\in S$。故对于$R$中每个给定的序偶$\langle a_{i},b_{k}\rangle$，要在$S$中寻遍第一元素为$b_{k}$的序偶$\langle b_{k},c_{j}\rangle$，若存在$\langle b_{k},c_{j}\rangle\in S$，则取$R$中$\langle a_{i},b_{k}\rangle$的第一元素，以及$S$中对应序偶$\langle b_{k},c_{j}\rangle$的第二元素，形成一个新的序偶$\langle a_{i},c_{j}\rangle$，该序偶即为$R\circ S$中的一个元素。同理可找出$R\circ S$中的所有元素。  
2. 关系图法  由复合运算的定义可知，对于分别属于关系$R$ 和$S$的两个序偶，它们之间能够复合的关键在于能够在这两个序偶之间找到一个桥梁$b_{k}$，使得$b_{k}$既是前一个序偶($R$中序偶)的第二元素，同时又是后一个序偶(S 中序偶)的第一元素。因此，在画复合关系的关系图时，首先应该在$R$ 和$S$ 这两个关系的关系图中搭起这个桥梁，然后拆掉中间的桥梁，直接联结经过该桥梁的两个结点，便可得到$R\circ S$的关系图。  
3.关系矩阵法  将$R$ 和$S$ 的关系矩阵做布尔积运算$\odot$，即可得到$\mathrm{~\tt~R~o~}S$的关系矩阵，然后根据该矩阵写出$R\circ S$中元素即可。也就是说，令$R$ 和$S$ 的关系矩阵分别为：
$$
M_{R}=\begin{pmatrix}\langle a_1,b_1\rangle&\langle a_1,b_2\rangle&\cdots\langle a_1,b_n\rangle\\\langle a_2,b_1\rangle&\langle a_2,b_2\rangle&\cdots\langle a_2,b_n\rangle\\\vdots\\\langle a_m,b_1\rangle\langle a_m,b_2\rangle&\cdots\langle a_m,b_n\rangle\end{pmatrix};\quad M_{S}=\begin{pmatrix}\langle b_1,c_1\rangle&\langle b_1,c_2\rangle&\cdots&\langle b_1,c_t\rangle\\\langle b_2,c_1\rangle&\langle b_2,c_2\rangle&\cdots&\langle b_2,c_t\rangle\\\vdots\\\langle b_n,b_1\rangle\langle b_n,c_2\rangle&\cdots\langle b_n,c_t\rangle\end{pmatrix}
$$
则有：
$$
M_{R\circ S}=M_{R}\odot M_{S}=\left(\begin{array}{c}{{\langle a_{1},c_{1}\rangle\ \langle a_{1},c_{2}\rangle\ \cdots\ \langle a_{1},c_{t}\rangle}}\\ {{\langle a_{2}.\,c_{1}\rangle\ \langle a_{2},c_{2}\rangle\ \cdots\ \langle a_{2},c_{t}\rangle}}\\ {{\vdots}}\\ {{\langle a_{m},c_{1}\rangle\langle a_{m},c_{2}\rangle\cdots\langle a_{m},c_{t}\rangle}}\end{array}\right)
$$  
【定理5.5】设$A$、$B$、$C$ 和$D$ 是任意四个集合，$R$、$S$和$T$ 分别是从$A$ 到$B,\ B$到$C$和$C$ 到$D$ 的二元关系，$I_{A}$和$I_{B}$分别是$A$ 和$B$ 上恒等关系，则有：
$$
(1) (R\circ S)\circ T=R\circ(S\circ T);\quad(2) I_A\circ R=R\circ I_B=R
$$  
下面的定理给出了关系的集合运算与复合运算之间的关系：复合运算对并运算具有完全的分配律，而复合运算对交运算只有有半分配律。  
【定理5.6】设$A$、$B$、$C$和$D$ 是任意四个集合，$R$ 是$A$ 到$B$ 的关系，$S_{1},\ S_{2}$是从$B$ 到$C$的关系，$T$是从$C$ 到$D$ 的关系，则有：  
（1）$R\circ(S_{1}\cup S_{2})=(R\circ S_{1})\cup(R\circ S_{2});\,\,\,(2)\,\,\,R\circ(S_{1}\cap S_{2})\subseteq(R\circ S_{1})\cap(R\circ S_{2});$ （3）$(S_{1}\cup S_{2})\circ T=(S_{1}\circ T)\cup(S_{2}\circ T);\ \ (4)\ \ (S_{1}\cap S_{2})\circ T\subseteq(S_{1}\circ T)\cap(S_{2}\circ T)。$  
上述定理和例题表明，复合运算对并运算具有完全的分配律，即分配律是以集合相等的方式出现，但复合运算对交运算不具备完全分配律，只有半分配律，也就是说，分配律是以集合包含的方式出现。如果要将关系的这些运算与数的相关运算做一些类比的话，那么关系的复合运算就比较类似于数或矩阵的乘法运算，而关系的并运算就比较类似于数或矩阵的加法运算。事实上，从复合运算和并运算的关系矩阵运算特点上，就可看出它们与数乘、数加以及矩阵乘、矩阵加的类似之处。",定理5.5描述了关系的复合运算的结合性和恒等关系的性质
定理5.6,性质,关系的复合运算,,"日常生活和工作中很多关系问题仅用关系的集合运算不能得到有效的解决。例如：假设集合$𝐴$表示某家族的全部成员构成的集合，在$𝐴$上定义如下两个关系$R$和$𝑆$：  
$R$表示$A$上的兄弟关系，$\langle x,y\rangle\in R$,当且仅当$x$是$y$的兄弟;  
$S$表示 $A$ 上的父子关系，$\langle y,z\rangle\in S$,当且仅当$y$ 是$z$ 的父亲。  
则可通过元素$y$的中间媒介或传递作用，在$x$与$z$之间产生一个新的关系，即叔侄关系。换句话说，叔侄关系是由兄弟关系和父子关系的合成。  
![](images/8ed5b0cc3c8222133404e26aeb757d647b1fb51cdae3d0c7fbf0c3754976758e.jpg)
图5-7 叔侄关系图  
例如，假设在小说《红楼梦》中人物的兄弟关系为𝑅、父子关系为𝑆，则有：
$$
\begin{aligned}&R=\left\{\langle\text{贾宝玉},\text{贾环}\rangle,\langle\text{贾政},\textbf{贾赦}\rangle,\cdots\right\};\\&S=\left\{\langle\text{贾政},\text{贾宝玉}\rangle,\langle\text{贾政},\text{贾环}\rangle,\langle\textbf{贾赦 贾琏}\rangle,\cdots\right\}\end{aligned}
$$
如图5-7 所示，在上述$R$和$𝑆$这两个二元关系中，贾政和贾琏之间通过贾赦的中间媒介或传递作用建立了叔侄关系。一般地，将关系这种合成机制进行抽象，用数学语言进行表达，就得到如下关系复合运算的定义：  
【定义5.14】假设$A$、$B$、$C$ 是三个非空集合，$R$ 是从$A$ 到$B$ 的关系，$S$ 是从$B$ 到$C$的关系，则$R$ 与$S$ 的复合关系$R\circ S$定义为如下从$A$ 到$C$的关系：  
$$R\circ S=\{\langle x,z\rangle|x\in A\land z\in C\land(\exists y)(y\in B\land x R y\land y S z)\quad\text{(5-5)}$$  
运算“ ∘”称为复合运算。  
从上述定义可知：不是任意两个关系都能进行复合运算，当且仅当$R$ 的后域是$S$的前域时，$R$ 和$S$ 才可复合；$R\circ S$的前域是$R$ 的前域$A$，$R\circ S$的后域是$S$ 的后域$C$。  
任何一个关系都有集合、关系图和矩阵这三种表现形式，复合运算在这三种不同表现形式下分别具有相应的具体计算方法，下面分别介绍这三种复合计算方法。  
令$A=\{a_1,a_2,\cdots,a_m\},B=\{b_1,b_2,\cdots,b_n\},C=\{c_1,c_2,\cdots,c_t\},R$ 是$A$ 到$B$ 的关系，$S$ 是$B$ 到 $C$ 的关系，即有$R$$\subseteq{A}\times{B}$, $S$$\subseteq{B}\times{C}$, 则$R\circ S$可按下列方法进行计算.  
1 ．集合法    由复合运算的定义可知，对于任意的 $a_{i}\in A,c_{j}\in C$ ，若 $\langle a_{i},c_{j}\rangle\in R\circ S$ ，则 必然存在某个$b_{k}\in B$，使得$\langle a_{i},b_{k}\rangle\in R$并且$\langle b_{k},c_{j}\rangle\in S$。故对于$R$中每个给定的序偶$\langle a_{i},b_{k}\rangle$，要在$S$中寻遍第一元素为$b_{k}$的序偶$\langle b_{k},c_{j}\rangle$，若存在$\langle b_{k},c_{j}\rangle\in S$，则取$R$中$\langle a_{i},b_{k}\rangle$的第一元素，以及$S$中对应序偶$\langle b_{k},c_{j}\rangle$的第二元素，形成一个新的序偶$\langle a_{i},c_{j}\rangle$，该序偶即为$R\circ S$中的一个元素。同理可找出$R\circ S$中的所有元素。  
2. 关系图法  由复合运算的定义可知，对于分别属于关系$R$ 和$S$的两个序偶，它们之间能够复合的关键在于能够在这两个序偶之间找到一个桥梁$b_{k}$，使得$b_{k}$既是前一个序偶($R$中序偶)的第二元素，同时又是后一个序偶(S 中序偶)的第一元素。因此，在画复合关系的关系图时，首先应该在$R$ 和$S$ 这两个关系的关系图中搭起这个桥梁，然后拆掉中间的桥梁，直接联结经过该桥梁的两个结点，便可得到$R\circ S$的关系图。  
3.关系矩阵法  将$R$ 和$S$ 的关系矩阵做布尔积运算$\odot$，即可得到$\mathrm{~\tt~R~o~}S$的关系矩阵，然后根据该矩阵写出$R\circ S$中元素即可。也就是说，令$R$ 和$S$ 的关系矩阵分别为：
$$
M_{R}=\begin{pmatrix}\langle a_1,b_1\rangle&\langle a_1,b_2\rangle&\cdots\langle a_1,b_n\rangle\\\langle a_2,b_1\rangle&\langle a_2,b_2\rangle&\cdots\langle a_2,b_n\rangle\\\vdots\\\langle a_m,b_1\rangle\langle a_m,b_2\rangle&\cdots\langle a_m,b_n\rangle\end{pmatrix};\quad M_{S}=\begin{pmatrix}\langle b_1,c_1\rangle&\langle b_1,c_2\rangle&\cdots&\langle b_1,c_t\rangle\\\langle b_2,c_1\rangle&\langle b_2,c_2\rangle&\cdots&\langle b_2,c_t\rangle\\\vdots\\\langle b_n,b_1\rangle\langle b_n,c_2\rangle&\cdots\langle b_n,c_t\rangle\end{pmatrix}
$$
则有：
$$
M_{R\circ S}=M_{R}\odot M_{S}=\left(\begin{array}{c}{{\langle a_{1},c_{1}\rangle\ \langle a_{1},c_{2}\rangle\ \cdots\ \langle a_{1},c_{t}\rangle}}\\ {{\langle a_{2}.\,c_{1}\rangle\ \langle a_{2},c_{2}\rangle\ \cdots\ \langle a_{2},c_{t}\rangle}}\\ {{\vdots}}\\ {{\langle a_{m},c_{1}\rangle\langle a_{m},c_{2}\rangle\cdots\langle a_{m},c_{t}\rangle}}\end{array}\right)
$$  
【定理5.5】设$A$、$B$、$C$ 和$D$ 是任意四个集合，$R$、$S$和$T$ 分别是从$A$ 到$B,\ B$到$C$和$C$ 到$D$ 的二元关系，$I_{A}$和$I_{B}$分别是$A$ 和$B$ 上恒等关系，则有：
$$
(1) (R\circ S)\circ T=R\circ(S\circ T);\quad(2) I_A\circ R=R\circ I_B=R
$$  
下面的定理给出了关系的集合运算与复合运算之间的关系：复合运算对并运算具有完全的分配律，而复合运算对交运算只有有半分配律。  
【定理5.6】设$A$、$B$、$C$和$D$ 是任意四个集合，$R$ 是$A$ 到$B$ 的关系，$S_{1},\ S_{2}$是从$B$ 到$C$的关系，$T$是从$C$ 到$D$ 的关系，则有：  
（1）$R\circ(S_{1}\cup S_{2})=(R\circ S_{1})\cup(R\circ S_{2});\,\,\,(2)\,\,\,R\circ(S_{1}\cap S_{2})\subseteq(R\circ S_{1})\cap(R\circ S_{2});$ （3）$(S_{1}\cup S_{2})\circ T=(S_{1}\circ T)\cup(S_{2}\circ T);\ \ (4)\ \ (S_{1}\cap S_{2})\circ T\subseteq(S_{1}\circ T)\cap(S_{2}\circ T)。$  
上述定理和例题表明，复合运算对并运算具有完全的分配律，即分配律是以集合相等的方式出现，但复合运算对交运算不具备完全分配律，只有半分配律，也就是说，分配律是以集合包含的方式出现。如果要将关系的这些运算与数的相关运算做一些类比的话，那么关系的复合运算就比较类似于数或矩阵的乘法运算，而关系的并运算就比较类似于数或矩阵的加法运算。事实上，从复合运算和并运算的关系矩阵运算特点上，就可看出它们与数乘、数加以及矩阵乘、矩阵加的类似之处。",定理5.6描述了关系的复合运算对并运算和交运算的分配律性质
幂关系,定义与性质,逆关系,,"如前所述，关系的复合运算满足结合律。也就是说，如果有多个关系进行复合运算，只要不交换它们的运算次序，不管哪个先参与合成，最后结果都一样。由此可见，对于某个集合上的一个二元关系，如果它可以不断地与自己做复合运算，那么运算结果只与该关系以及复合运算次数有关，而与复合的次序无光。由此可得如下关系方幂运算的概念：  
【定义5.15】设$R$ 是集合$A$ 上的关系，则可归纳定义$R$ 的$n$次方幂${R^{n}}$运算如下：  
$（1）R^{0}=I_{A}=\left\{\langle a,\ a\rangle\big|a\in A\right\};\quad(\,2\,)\,\ R^{1}=R;\ (\,3\,)\,\ R^{n+1}=R^{n}\circ R=R\circ R^{n}\circ R.$    方幂运算的结果也显然也是$A$ 上的二元关系，即对于任何自然数$k$，有$R^{k}\subseteq A\times A$。通常称为$R$的方幂关系或幂关系，不难证明方幂运算满足如下运算法则：
$$
R^{m}\circ R^{n}=R^{m+n};\,\,\,(R^{m})^{n}=R^{m n}
$$  
由上述例题可以看出：  
（1）幂集$R^{n}$的基数$\vert{R}^{n}\vert$并非随着$n$ 的增加而增加，而是呈递减趋势；  
（2）当$n\geq|A|$时，则$R^{n}$出现循环取值或退化为空关系。 下面的定理给出了上述结论的一个解释：  
【定理5.7】设𝐴是一个具有${n}$个元素的有限集合，$R$ 是$𝐴$上的二元关系，则必存在自然数$s$ 和$t$，使得$R^{s}=R^{t}$，$0\leq s<t\leq2^{n^{2}}$。  
上述定理表明，对于任意一个有限集合，该集合上的二元关系总共只有有限多个，而对于该集合上的二元关系，其方幂运算则可以无限地进行下去且运算结果均为该集合上的二元关系。因此，在一定次数的方幂运算之后，后续的方幂运算结果自然是以某种循环的方式出现，或者以恒等于某个特定关系的方式出现。  
【定义5.16】设$A,\ B$ 是任意两个集合，$R$ 是$A$ 到$B$ 的关系，则从$B$ 到$A$ 的关系：
$$
R^{-1}=\{\langle b,a\rangle|\langle a,b\rangle\in R\}\quad\text{(5-9)}
$$
称为$R$ 的逆关系，运算“-1”称为关系的逆运算。  
关于逆关系概念的理解，需要注意如下几个要点：（1）关系是序偶的集合，逆关系也是序偶的集合；（2）如果$R$ 是一个关系，则其逆关系$R^{-1}$和补关系$\bar{R}$都是关系，但是两者是完全不同的两个关系，千万不要混淆；（3）显然有$(R^{-1})^{-1}=R$，$\varnothing^{-1}=\varnothing$。  
【定理5.8】设$A$，$B$ 和$C$是任意三个集合，$R$，$S$ 分别是从$A$ 到$B$ 和$B$ 到$C$的二元关系，则有：$(R\circ S)^{-1}=S^{-1}\circ R^{-1}$  
可以看出，复合关系的逆关系等于它们逆关系的反复合。要注意$(R\circ S)^{-1}\neq R^{-1}\circ S^{-1}$，因为$R^{-1}$是从$B$ 到$A$ 的关系，而$S^{-1}$是从$C$ 到$B$ 的关系，因此$S^{-1}$与$R^{-1}$之间是可复合的，而$R^{-1}$与$S^{-1}$之间是不可复合的。  
下面定理给出了关系逆运算与关系集合运算之间的分配运算律：  
【定理5.9】设$R,\ S$是从集合$A$ 到集合$B$ 的关系，则有如下分配律：
$$
(R\cup S)^{-1}=R^{-1}\cup S^{-1};\;\;(R\cup S)^{-1}=R^{-1}\cup S^{-1};\;\;(R-S)^{-1}=R^{-1}-S^{-1}
$$  
对于任意给定的集合𝐴和$B$，目前所讨论的二元关系有两种基本类型，一种是集合$𝐴$到集合$ B$上的二元关系，另外一种是集合𝐴上的二元关系。事实上，这两种关系没有本质上的区别，因为若令$C=A\cup B$，则集合$𝐴$到集合$B$上的二元关系就可以看成是$C\times C$的几个子集合，或者说是$C$上的二元关系。因此，在后续内容中所说的关系，若非特别说明，均为某个集合上的关系而不是从某个集合到另外一个集合上的关系。",幂关系是关系自身的多次复合运算结果，逆关系是原关系的序偶反转。两者在定义和性质上有明显区别。
复合关系的逆关系,等价关系,逆关系,,"如前所述，关系的复合运算满足结合律。也就是说，如果有多个关系进行复合运算，只要不交换它们的运算次序，不管哪个先参与合成，最后结果都一样。由此可见，对于某个集合上的一个二元关系，如果它可以不断地与自己做复合运算，那么运算结果只与该关系以及复合运算次数有关，而与复合的次序无光。由此可得如下关系方幂运算的概念：  
【定义5.15】设$R$ 是集合$A$ 上的关系，则可归纳定义$R$ 的$n$次方幂${R^{n}}$运算如下：  
$（1）R^{0}=I_{A}=\left\{\langle a,\ a\rangle\big|a\in A\right\};\quad(\,2\,)\,\ R^{1}=R;\ (\,3\,)\,\ R^{n+1}=R^{n}\circ R=R\circ R^{n}\circ R.$    方幂运算的结果也显然也是$A$ 上的二元关系，即对于任何自然数$k$，有$R^{k}\subseteq A\times A$。通常称为$R$的方幂关系或幂关系，不难证明方幂运算满足如下运算法则：
$$
R^{m}\circ R^{n}=R^{m+n};\,\,\,(R^{m})^{n}=R^{m n}
$$  
由上述例题可以看出：  
（1）幂集$R^{n}$的基数$\vert{R}^{n}\vert$并非随着$n$ 的增加而增加，而是呈递减趋势；  
（2）当$n\geq|A|$时，则$R^{n}$出现循环取值或退化为空关系。 下面的定理给出了上述结论的一个解释：  
【定理5.7】设𝐴是一个具有${n}$个元素的有限集合，$R$ 是$𝐴$上的二元关系，则必存在自然数$s$ 和$t$，使得$R^{s}=R^{t}$，$0\leq s<t\leq2^{n^{2}}$。  
上述定理表明，对于任意一个有限集合，该集合上的二元关系总共只有有限多个，而对于该集合上的二元关系，其方幂运算则可以无限地进行下去且运算结果均为该集合上的二元关系。因此，在一定次数的方幂运算之后，后续的方幂运算结果自然是以某种循环的方式出现，或者以恒等于某个特定关系的方式出现。  
【定义5.16】设$A,\ B$ 是任意两个集合，$R$ 是$A$ 到$B$ 的关系，则从$B$ 到$A$ 的关系：
$$
R^{-1}=\{\langle b,a\rangle|\langle a,b\rangle\in R\}\quad\text{(5-9)}
$$
称为$R$ 的逆关系，运算“-1”称为关系的逆运算。  
关于逆关系概念的理解，需要注意如下几个要点：（1）关系是序偶的集合，逆关系也是序偶的集合；（2）如果$R$ 是一个关系，则其逆关系$R^{-1}$和补关系$\bar{R}$都是关系，但是两者是完全不同的两个关系，千万不要混淆；（3）显然有$(R^{-1})^{-1}=R$，$\varnothing^{-1}=\varnothing$。  
【定理5.8】设$A$，$B$ 和$C$是任意三个集合，$R$，$S$ 分别是从$A$ 到$B$ 和$B$ 到$C$的二元关系，则有：$(R\circ S)^{-1}=S^{-1}\circ R^{-1}$  
可以看出，复合关系的逆关系等于它们逆关系的反复合。要注意$(R\circ S)^{-1}\neq R^{-1}\circ S^{-1}$，因为$R^{-1}$是从$B$ 到$A$ 的关系，而$S^{-1}$是从$C$ 到$B$ 的关系，因此$S^{-1}$与$R^{-1}$之间是可复合的，而$R^{-1}$与$S^{-1}$之间是不可复合的。  
下面定理给出了关系逆运算与关系集合运算之间的分配运算律：  
【定理5.9】设$R,\ S$是从集合$A$ 到集合$B$ 的关系，则有如下分配律：
$$
(R\cup S)^{-1}=R^{-1}\cup S^{-1};\;\;(R\cup S)^{-1}=R^{-1}\cup S^{-1};\;\;(R-S)^{-1}=R^{-1}-S^{-1}
$$  
对于任意给定的集合𝐴和$B$，目前所讨论的二元关系有两种基本类型，一种是集合$𝐴$到集合$ B$上的二元关系，另外一种是集合𝐴上的二元关系。事实上，这两种关系没有本质上的区别，因为若令$C=A\cup B$，则集合$𝐴$到集合$B$上的二元关系就可以看成是$C\times C$的几个子集合，或者说是$C$上的二元关系。因此，在后续内容中所说的关系，若非特别说明，均为某个集合上的关系而不是从某个集合到另外一个集合上的关系。",复合关系的逆关系等于其逆关系的反复合，即$(R \circ S)^{-1} = S^{-1} \circ R^{-1}$。
关系逆运算与关系集合运算的分配律,运算规则,逆关系,,"如前所述，关系的复合运算满足结合律。也就是说，如果有多个关系进行复合运算，只要不交换它们的运算次序，不管哪个先参与合成，最后结果都一样。由此可见，对于某个集合上的一个二元关系，如果它可以不断地与自己做复合运算，那么运算结果只与该关系以及复合运算次数有关，而与复合的次序无光。由此可得如下关系方幂运算的概念：  
【定义5.15】设$R$ 是集合$A$ 上的关系，则可归纳定义$R$ 的$n$次方幂${R^{n}}$运算如下：  
$（1）R^{0}=I_{A}=\left\{\langle a,\ a\rangle\big|a\in A\right\};\quad(\,2\,)\,\ R^{1}=R;\ (\,3\,)\,\ R^{n+1}=R^{n}\circ R=R\circ R^{n}\circ R.$    方幂运算的结果也显然也是$A$ 上的二元关系，即对于任何自然数$k$，有$R^{k}\subseteq A\times A$。通常称为$R$的方幂关系或幂关系，不难证明方幂运算满足如下运算法则：
$$
R^{m}\circ R^{n}=R^{m+n};\,\,\,(R^{m})^{n}=R^{m n}
$$  
由上述例题可以看出：  
（1）幂集$R^{n}$的基数$\vert{R}^{n}\vert$并非随着$n$ 的增加而增加，而是呈递减趋势；  
（2）当$n\geq|A|$时，则$R^{n}$出现循环取值或退化为空关系。 下面的定理给出了上述结论的一个解释：  
【定理5.7】设𝐴是一个具有${n}$个元素的有限集合，$R$ 是$𝐴$上的二元关系，则必存在自然数$s$ 和$t$，使得$R^{s}=R^{t}$，$0\leq s<t\leq2^{n^{2}}$。  
上述定理表明，对于任意一个有限集合，该集合上的二元关系总共只有有限多个，而对于该集合上的二元关系，其方幂运算则可以无限地进行下去且运算结果均为该集合上的二元关系。因此，在一定次数的方幂运算之后，后续的方幂运算结果自然是以某种循环的方式出现，或者以恒等于某个特定关系的方式出现。  
【定义5.16】设$A,\ B$ 是任意两个集合，$R$ 是$A$ 到$B$ 的关系，则从$B$ 到$A$ 的关系：
$$
R^{-1}=\{\langle b,a\rangle|\langle a,b\rangle\in R\}\quad\text{(5-9)}
$$
称为$R$ 的逆关系，运算“-1”称为关系的逆运算。  
关于逆关系概念的理解，需要注意如下几个要点：（1）关系是序偶的集合，逆关系也是序偶的集合；（2）如果$R$ 是一个关系，则其逆关系$R^{-1}$和补关系$\bar{R}$都是关系，但是两者是完全不同的两个关系，千万不要混淆；（3）显然有$(R^{-1})^{-1}=R$，$\varnothing^{-1}=\varnothing$。  
【定理5.8】设$A$，$B$ 和$C$是任意三个集合，$R$，$S$ 分别是从$A$ 到$B$ 和$B$ 到$C$的二元关系，则有：$(R\circ S)^{-1}=S^{-1}\circ R^{-1}$  
可以看出，复合关系的逆关系等于它们逆关系的反复合。要注意$(R\circ S)^{-1}\neq R^{-1}\circ S^{-1}$，因为$R^{-1}$是从$B$ 到$A$ 的关系，而$S^{-1}$是从$C$ 到$B$ 的关系，因此$S^{-1}$与$R^{-1}$之间是可复合的，而$R^{-1}$与$S^{-1}$之间是不可复合的。  
下面定理给出了关系逆运算与关系集合运算之间的分配运算律：  
【定理5.9】设$R,\ S$是从集合$A$ 到集合$B$ 的关系，则有如下分配律：
$$
(R\cup S)^{-1}=R^{-1}\cup S^{-1};\;\;(R\cup S)^{-1}=R^{-1}\cup S^{-1};\;\;(R-S)^{-1}=R^{-1}-S^{-1}
$$  
对于任意给定的集合𝐴和$B$，目前所讨论的二元关系有两种基本类型，一种是集合$𝐴$到集合$ B$上的二元关系，另外一种是集合𝐴上的二元关系。事实上，这两种关系没有本质上的区别，因为若令$C=A\cup B$，则集合$𝐴$到集合$B$上的二元关系就可以看成是$C\times C$的几个子集合，或者说是$C$上的二元关系。因此，在后续内容中所说的关系，若非特别说明，均为某个集合上的关系而不是从某个集合到另外一个集合上的关系。",关系逆运算与关系集合运算之间存在分配律，如$(R \cup S)^{-1} = R^{-1} \cup S^{-1}$，$(R - S)^{-1} = R^{-1} - S^{-1}$。
自反性,互斥,反自反性,,现实世界中的关系错综复杂、种类繁多，这给我们使用关系的数学模型表示和解决关系问题带来一定的困难。因此，为了比较方便地研究和使用关系的数学模型，本节建立考察关系特性的若干标准并将这些标准看成是关系的基本性质。对于任意给定的一个关系，就可以使用这些标准来考察或评判该关系满足或不满足这几个标准中的哪几条，换句话说，就是考察该或评判该关系具有哪些基本性质。这样就可以依据这些标准将所有的关系划分为若干类型进行分门别类的研究。关系的这些考察标准或基本性质一共有五个，即自反性、反自反性、对称性、反对称性和传递性，本节具体介绍这些基本性质的概念及判定方法。,一个关系不可能同时具有自反性和反自反性
对称性,互斥,反对称性,,现实世界中的关系错综复杂、种类繁多，这给我们使用关系的数学模型表示和解决关系问题带来一定的困难。因此，为了比较方便地研究和使用关系的数学模型，本节建立考察关系特性的若干标准并将这些标准看成是关系的基本性质。对于任意给定的一个关系，就可以使用这些标准来考察或评判该关系满足或不满足这几个标准中的哪几条，换句话说，就是考察该或评判该关系具有哪些基本性质。这样就可以依据这些标准将所有的关系划分为若干类型进行分门别类的研究。关系的这些考察标准或基本性质一共有五个，即自反性、反自反性、对称性、反对称性和传递性，本节具体介绍这些基本性质的概念及判定方法。,一个关系不可能同时具有对称性和反对称性
自反性,独立,对称性,,现实世界中的关系错综复杂、种类繁多，这给我们使用关系的数学模型表示和解决关系问题带来一定的困难。因此，为了比较方便地研究和使用关系的数学模型，本节建立考察关系特性的若干标准并将这些标准看成是关系的基本性质。对于任意给定的一个关系，就可以使用这些标准来考察或评判该关系满足或不满足这几个标准中的哪几条，换句话说，就是考察该或评判该关系具有哪些基本性质。这样就可以依据这些标准将所有的关系划分为若干类型进行分门别类的研究。关系的这些考察标准或基本性质一共有五个，即自反性、反自反性、对称性、反对称性和传递性，本节具体介绍这些基本性质的概念及判定方法。,自反性和对称性是关系的两个独立性质，可以同时存在或不存在
自反性,独立,反对称性,,现实世界中的关系错综复杂、种类繁多，这给我们使用关系的数学模型表示和解决关系问题带来一定的困难。因此，为了比较方便地研究和使用关系的数学模型，本节建立考察关系特性的若干标准并将这些标准看成是关系的基本性质。对于任意给定的一个关系，就可以使用这些标准来考察或评判该关系满足或不满足这几个标准中的哪几条，换句话说，就是考察该或评判该关系具有哪些基本性质。这样就可以依据这些标准将所有的关系划分为若干类型进行分门别类的研究。关系的这些考察标准或基本性质一共有五个，即自反性、反自反性、对称性、反对称性和传递性，本节具体介绍这些基本性质的概念及判定方法。,自反性和反对称性是关系的两个独立性质，可以同时存在或不存在
自反性,独立,传递性,,现实世界中的关系错综复杂、种类繁多，这给我们使用关系的数学模型表示和解决关系问题带来一定的困难。因此，为了比较方便地研究和使用关系的数学模型，本节建立考察关系特性的若干标准并将这些标准看成是关系的基本性质。对于任意给定的一个关系，就可以使用这些标准来考察或评判该关系满足或不满足这几个标准中的哪几条，换句话说，就是考察该或评判该关系具有哪些基本性质。这样就可以依据这些标准将所有的关系划分为若干类型进行分门别类的研究。关系的这些考察标准或基本性质一共有五个，即自反性、反自反性、对称性、反对称性和传递性，本节具体介绍这些基本性质的概念及判定方法。,自反性和传递性是关系的两个独立性质，可以同时存在或不存在
反自反性,独立,对称性,,现实世界中的关系错综复杂、种类繁多，这给我们使用关系的数学模型表示和解决关系问题带来一定的困难。因此，为了比较方便地研究和使用关系的数学模型，本节建立考察关系特性的若干标准并将这些标准看成是关系的基本性质。对于任意给定的一个关系，就可以使用这些标准来考察或评判该关系满足或不满足这几个标准中的哪几条，换句话说，就是考察该或评判该关系具有哪些基本性质。这样就可以依据这些标准将所有的关系划分为若干类型进行分门别类的研究。关系的这些考察标准或基本性质一共有五个，即自反性、反自反性、对称性、反对称性和传递性，本节具体介绍这些基本性质的概念及判定方法。,反自反性和对称性是关系的两个独立性质，可以同时存在或不存在
反自反性,独立,反对称性,,现实世界中的关系错综复杂、种类繁多，这给我们使用关系的数学模型表示和解决关系问题带来一定的困难。因此，为了比较方便地研究和使用关系的数学模型，本节建立考察关系特性的若干标准并将这些标准看成是关系的基本性质。对于任意给定的一个关系，就可以使用这些标准来考察或评判该关系满足或不满足这几个标准中的哪几条，换句话说，就是考察该或评判该关系具有哪些基本性质。这样就可以依据这些标准将所有的关系划分为若干类型进行分门别类的研究。关系的这些考察标准或基本性质一共有五个，即自反性、反自反性、对称性、反对称性和传递性，本节具体介绍这些基本性质的概念及判定方法。,反自反性和反对称性是关系的两个独立性质，可以同时存在或不存在
反自反性,独立,传递性,,现实世界中的关系错综复杂、种类繁多，这给我们使用关系的数学模型表示和解决关系问题带来一定的困难。因此，为了比较方便地研究和使用关系的数学模型，本节建立考察关系特性的若干标准并将这些标准看成是关系的基本性质。对于任意给定的一个关系，就可以使用这些标准来考察或评判该关系满足或不满足这几个标准中的哪几条，换句话说，就是考察该或评判该关系具有哪些基本性质。这样就可以依据这些标准将所有的关系划分为若干类型进行分门别类的研究。关系的这些考察标准或基本性质一共有五个，即自反性、反自反性、对称性、反对称性和传递性，本节具体介绍这些基本性质的概念及判定方法。,反自反性和传递性是关系的两个独立性质，可以同时存在或不存在
对称性,独立,传递性,,现实世界中的关系错综复杂、种类繁多，这给我们使用关系的数学模型表示和解决关系问题带来一定的困难。因此，为了比较方便地研究和使用关系的数学模型，本节建立考察关系特性的若干标准并将这些标准看成是关系的基本性质。对于任意给定的一个关系，就可以使用这些标准来考察或评判该关系满足或不满足这几个标准中的哪几条，换句话说，就是考察该或评判该关系具有哪些基本性质。这样就可以依据这些标准将所有的关系划分为若干类型进行分门别类的研究。关系的这些考察标准或基本性质一共有五个，即自反性、反自反性、对称性、反对称性和传递性，本节具体介绍这些基本性质的概念及判定方法。,对称性和传递性是关系的两个独立性质，可以同时存在或不存在
反对称性,独立,传递性,,现实世界中的关系错综复杂、种类繁多，这给我们使用关系的数学模型表示和解决关系问题带来一定的困难。因此，为了比较方便地研究和使用关系的数学模型，本节建立考察关系特性的若干标准并将这些标准看成是关系的基本性质。对于任意给定的一个关系，就可以使用这些标准来考察或评判该关系满足或不满足这几个标准中的哪几条，换句话说，就是考察该或评判该关系具有哪些基本性质。这样就可以依据这些标准将所有的关系划分为若干类型进行分门别类的研究。关系的这些考察标准或基本性质一共有五个，即自反性、反自反性、对称性、反对称性和传递性，本节具体介绍这些基本性质的概念及判定方法。,反对称性和传递性是关系的两个独立性质，可以同时存在或不存在
自反关系,互斥,反自反关系,,"日常生活和工作中的很多关系，如同学关系、实数的相等关系、正整数的整除关系等，每个元素都与其自身之间具有这种关系，此时称这些关系具有自反性质。具体定义如下：  
【定义5.17】设$R$ 是集合$A$ 上的关系，若对$\forall x\in A$，都有$\langle x,x\rangle\in R$，则称$R$ 在$A$ 上是自反关系，或称$R$ 具有自反性。即：  
$(\forall x)(x\in A\to\langle x,x\rangle\in R)\Leftrightarrow R\text{为自反关系}\quad\text{(5-10)} $  
与之相反的是，对于有些关系，例如父子关系、实数的小于关系、夫妻关系等，每个元素都不可能与其自身之间具有这种关系，此时称这些关系具有反自反性质。具体定义如下：  
【定义5.18】设$R$ 是集合$A$ 上的关系，若对$\forall x\in A$，都有$\langle x,x\rangle\notin R$，则称$R$ 在$A$ 上是反自反关系，或称$R$ 具有反自反性。即：  
通过上述例题，不难得出如下结论：  
（1）如果关系$R$ 是自反的，那么该关系一定不是反自反的；关系$R$ 是反自反的，则该关系一定不是自反的。  
（2）存在既不是自反也不是反自反的关系；  
（3）关系$R$ 是自反的，当且仅当系图中每个结点都有一个自环；关系$R$ 是反自反的，当且仅当图中每个结点都没有自环；  
（4）关系$R$ 是自反的，当且仅当其关系矩阵的主对角线上全为1；关系$R$ 是反自反的，当且仅当其关系矩阵的主对角线上全为0。",如果关系R是自反的，那么该关系一定不是反自反的；关系R是反自反的，则该关系一定不是自反的
对称关系,互斥性,反对称关系,,"有很多关系具有一些对称的性质，例如对于同学关系，如果张三是李四的同学，那么李四必然是张三的同学，还有很多其它关系，例如两条直线之间的平行关系、兄弟关系、实数的相等关系等等，也都具有这种对称性质。关系对称性的具体定义如下：  
【定义5.19】设$R$ 是集合$A$ 上的关系，对任意$x,y\in A$，若$\langle x,y\rangle\in R$，则有$\langle y,x\rangle\in R$，则称关系$R$ 是对称关系，或称关系$R$ 具有对称性。即有：  
$(\forall x)(\forall y)(x\in A\land y\in A\land\langle x,y\rangle\in R\rightarrow\langle y,x\rangle\in R)\Leftrightarrow R$为对称关系；$\quad\text{(5-12)}$  
还有一些集合上的关系，集合中的所有元素与其自身之外任何元素之间的关系都不具有对称性，例如正整数的整除关系，对于任意两个正整数，除非这两个整数相等，否则它们之间不可能相互整除，也就是说，对于任意两个正整数$a$和$b$，如果$a|b$且$b|a$，则必有$a=b$。关系的这种性质称为反对称性，具体定义如下：  
【定义5.20】设$R$ 是集合$A$ 上的关系，若对任意$x,y\in A$，满足$\langle x,y\rangle\in R$且$\langle y,x\rangle\in R$  
则有$a=b$，则称关系$R$ 是反对称关系，或称$R$ 具有反对称性。即有：$(\forall x)(\forall y)(x\in A\land y\in A\land\langle x,y\rangle\in R\land\langle y,x\rangle\in R\to x=y)\Leftrightarrow R$为反对称关系  （5-13）【例题5.29】设$A=\{a,b,c\}$， $R_{1}$，$R_{2}$，$R_{3}$，$R_{4}$是$A$ 上的关系，其中：
$$
R_{1}=\{\langle a,a\rangle,\langle b,b\rangle,\langle c,c\rangle\};\,\,\,R_{2}=\{\langle a,a\rangle,\langle b,c\rangle,\langle c,b\rangle\}
$$  
$$
R_{3}=\{\langle a,b\rangle,\langle a,c\rangle\};\,\,\,R_{4}=\{\langle a,b\rangle,\langle b,c\rangle,\langle c,a\rangle\}
$$
判断$R_{1}$，$R_{2}$，$R_{3}$，$R_{4}$是否具有对称性或反对称性。  
通过上述例题，不难得出如下结论：  
（1）存在既不是对称也不是反对称的关系，也存在既是对称也是反对称的关系。  
（2）关系$R$ 是对称的当且仅当关系图中任何一对结点之间，要么存在方向相反的两条边，要么无任何边；关系$R$ 是反对称的当且仅当关系图中任何一对结点之间至多有一条边。  
（3）关系$R$ 是对称的当且仅当$R$的关系矩阵为对称矩阵；关系$R$ 是反对称的当且仅当$R$ 的关系矩阵为反对称矩阵，即对称的两个元素中最多有一个等于1。",对称关系和反对称关系在定义上具有互斥性，对称关系要求任意两个元素之间的关系是双向的，而反对称关系要求任意两个元素之间的关系是单向的，除非元素相等。
对称关系,共存性,反对称关系,,"有很多关系具有一些对称的性质，例如对于同学关系，如果张三是李四的同学，那么李四必然是张三的同学，还有很多其它关系，例如两条直线之间的平行关系、兄弟关系、实数的相等关系等等，也都具有这种对称性质。关系对称性的具体定义如下：  
【定义5.19】设$R$ 是集合$A$ 上的关系，对任意$x,y\in A$，若$\langle x,y\rangle\in R$，则有$\langle y,x\rangle\in R$，则称关系$R$ 是对称关系，或称关系$R$ 具有对称性。即有：  
$(\forall x)(\forall y)(x\in A\land y\in A\land\langle x,y\rangle\in R\rightarrow\langle y,x\rangle\in R)\Leftrightarrow R$为对称关系；$\quad\text{(5-12)}$  
还有一些集合上的关系，集合中的所有元素与其自身之外任何元素之间的关系都不具有对称性，例如正整数的整除关系，对于任意两个正整数，除非这两个整数相等，否则它们之间不可能相互整除，也就是说，对于任意两个正整数$a$和$b$，如果$a|b$且$b|a$，则必有$a=b$。关系的这种性质称为反对称性，具体定义如下：  
【定义5.20】设$R$ 是集合$A$ 上的关系，若对任意$x,y\in A$，满足$\langle x,y\rangle\in R$且$\langle y,x\rangle\in R$  
则有$a=b$，则称关系$R$ 是反对称关系，或称$R$ 具有反对称性。即有：$(\forall x)(\forall y)(x\in A\land y\in A\land\langle x,y\rangle\in R\land\langle y,x\rangle\in R\to x=y)\Leftrightarrow R$为反对称关系  （5-13）【例题5.29】设$A=\{a,b,c\}$， $R_{1}$，$R_{2}$，$R_{3}$，$R_{4}$是$A$ 上的关系，其中：
$$
R_{1}=\{\langle a,a\rangle,\langle b,b\rangle,\langle c,c\rangle\};\,\,\,R_{2}=\{\langle a,a\rangle,\langle b,c\rangle,\langle c,b\rangle\}
$$  
$$
R_{3}=\{\langle a,b\rangle,\langle a,c\rangle\};\,\,\,R_{4}=\{\langle a,b\rangle,\langle b,c\rangle,\langle c,a\rangle\}
$$
判断$R_{1}$，$R_{2}$，$R_{3}$，$R_{4}$是否具有对称性或反对称性。  
通过上述例题，不难得出如下结论：  
（1）存在既不是对称也不是反对称的关系，也存在既是对称也是反对称的关系。  
（2）关系$R$ 是对称的当且仅当关系图中任何一对结点之间，要么存在方向相反的两条边，要么无任何边；关系$R$ 是反对称的当且仅当关系图中任何一对结点之间至多有一条边。  
（3）关系$R$ 是对称的当且仅当$R$的关系矩阵为对称矩阵；关系$R$ 是反对称的当且仅当$R$ 的关系矩阵为反对称矩阵，即对称的两个元素中最多有一个等于1。",某些特定情况下，关系可以既是对称的也是反对称的，例如关系只包含自反元素的情况。
对称关系,图表示,反对称关系,,"有很多关系具有一些对称的性质，例如对于同学关系，如果张三是李四的同学，那么李四必然是张三的同学，还有很多其它关系，例如两条直线之间的平行关系、兄弟关系、实数的相等关系等等，也都具有这种对称性质。关系对称性的具体定义如下：  
【定义5.19】设$R$ 是集合$A$ 上的关系，对任意$x,y\in A$，若$\langle x,y\rangle\in R$，则有$\langle y,x\rangle\in R$，则称关系$R$ 是对称关系，或称关系$R$ 具有对称性。即有：  
$(\forall x)(\forall y)(x\in A\land y\in A\land\langle x,y\rangle\in R\rightarrow\langle y,x\rangle\in R)\Leftrightarrow R$为对称关系；$\quad\text{(5-12)}$  
还有一些集合上的关系，集合中的所有元素与其自身之外任何元素之间的关系都不具有对称性，例如正整数的整除关系，对于任意两个正整数，除非这两个整数相等，否则它们之间不可能相互整除，也就是说，对于任意两个正整数$a$和$b$，如果$a|b$且$b|a$，则必有$a=b$。关系的这种性质称为反对称性，具体定义如下：  
【定义5.20】设$R$ 是集合$A$ 上的关系，若对任意$x,y\in A$，满足$\langle x,y\rangle\in R$且$\langle y,x\rangle\in R$  
则有$a=b$，则称关系$R$ 是反对称关系，或称$R$ 具有反对称性。即有：$(\forall x)(\forall y)(x\in A\land y\in A\land\langle x,y\rangle\in R\land\langle y,x\rangle\in R\to x=y)\Leftrightarrow R$为反对称关系  （5-13）【例题5.29】设$A=\{a,b,c\}$， $R_{1}$，$R_{2}$，$R_{3}$，$R_{4}$是$A$ 上的关系，其中：
$$
R_{1}=\{\langle a,a\rangle,\langle b,b\rangle,\langle c,c\rangle\};\,\,\,R_{2}=\{\langle a,a\rangle,\langle b,c\rangle,\langle c,b\rangle\}
$$  
$$
R_{3}=\{\langle a,b\rangle,\langle a,c\rangle\};\,\,\,R_{4}=\{\langle a,b\rangle,\langle b,c\rangle,\langle c,a\rangle\}
$$
判断$R_{1}$，$R_{2}$，$R_{3}$，$R_{4}$是否具有对称性或反对称性。  
通过上述例题，不难得出如下结论：  
（1）存在既不是对称也不是反对称的关系，也存在既是对称也是反对称的关系。  
（2）关系$R$ 是对称的当且仅当关系图中任何一对结点之间，要么存在方向相反的两条边，要么无任何边；关系$R$ 是反对称的当且仅当关系图中任何一对结点之间至多有一条边。  
（3）关系$R$ 是对称的当且仅当$R$的关系矩阵为对称矩阵；关系$R$ 是反对称的当且仅当$R$ 的关系矩阵为反对称矩阵，即对称的两个元素中最多有一个等于1。",对称关系在关系图中表现为任何一对结点之间要么存在方向相反的两条边，要么无任何边；反对称关系在关系图中表现为任何一对结点之间至多有一条边。
对称关系,矩阵表示,反对称关系,,"有很多关系具有一些对称的性质，例如对于同学关系，如果张三是李四的同学，那么李四必然是张三的同学，还有很多其它关系，例如两条直线之间的平行关系、兄弟关系、实数的相等关系等等，也都具有这种对称性质。关系对称性的具体定义如下：  
【定义5.19】设$R$ 是集合$A$ 上的关系，对任意$x,y\in A$，若$\langle x,y\rangle\in R$，则有$\langle y,x\rangle\in R$，则称关系$R$ 是对称关系，或称关系$R$ 具有对称性。即有：  
$(\forall x)(\forall y)(x\in A\land y\in A\land\langle x,y\rangle\in R\rightarrow\langle y,x\rangle\in R)\Leftrightarrow R$为对称关系；$\quad\text{(5-12)}$  
还有一些集合上的关系，集合中的所有元素与其自身之外任何元素之间的关系都不具有对称性，例如正整数的整除关系，对于任意两个正整数，除非这两个整数相等，否则它们之间不可能相互整除，也就是说，对于任意两个正整数$a$和$b$，如果$a|b$且$b|a$，则必有$a=b$。关系的这种性质称为反对称性，具体定义如下：  
【定义5.20】设$R$ 是集合$A$ 上的关系，若对任意$x,y\in A$，满足$\langle x,y\rangle\in R$且$\langle y,x\rangle\in R$  
则有$a=b$，则称关系$R$ 是反对称关系，或称$R$ 具有反对称性。即有：$(\forall x)(\forall y)(x\in A\land y\in A\land\langle x,y\rangle\in R\land\langle y,x\rangle\in R\to x=y)\Leftrightarrow R$为反对称关系  （5-13）【例题5.29】设$A=\{a,b,c\}$， $R_{1}$，$R_{2}$，$R_{3}$，$R_{4}$是$A$ 上的关系，其中：
$$
R_{1}=\{\langle a,a\rangle,\langle b,b\rangle,\langle c,c\rangle\};\,\,\,R_{2}=\{\langle a,a\rangle,\langle b,c\rangle,\langle c,b\rangle\}
$$  
$$
R_{3}=\{\langle a,b\rangle,\langle a,c\rangle\};\,\,\,R_{4}=\{\langle a,b\rangle,\langle b,c\rangle,\langle c,a\rangle\}
$$
判断$R_{1}$，$R_{2}$，$R_{3}$，$R_{4}$是否具有对称性或反对称性。  
通过上述例题，不难得出如下结论：  
（1）存在既不是对称也不是反对称的关系，也存在既是对称也是反对称的关系。  
（2）关系$R$ 是对称的当且仅当关系图中任何一对结点之间，要么存在方向相反的两条边，要么无任何边；关系$R$ 是反对称的当且仅当关系图中任何一对结点之间至多有一条边。  
（3）关系$R$ 是对称的当且仅当$R$的关系矩阵为对称矩阵；关系$R$ 是反对称的当且仅当$R$ 的关系矩阵为反对称矩阵，即对称的两个元素中最多有一个等于1。",对称关系的关系矩阵为对称矩阵；反对称关系的关系矩阵为反对称矩阵，即对称的两个元素中最多有一个等于1。
关系的基本性质,包含,关系的传递性,,"日常工作和生活中的很多关系都具有某种传播或传递性质，例如：对于同学关系，如果  
张三四是李四的同学，李四又是王五的同学，那么张三必然是王五的同学；对于两条直线之间的平行关系，如果直线$a$ 与直线$b$ 平行，而直线$b$ 又与直线c 平行，那么必有直线$a$ 与直线$c$ 平行；对于两个整数之间的整除关系，如果整数$m$ 能够整除整数$n$，整数$n$ 又能整除$k$，那么$m$ 必然能整除整数$k$，等等。将这些不同具体关系所具有传播性质或传递性质进行抽象，得到如下关于关系传递性质的概念：  
【定义5.21】设$R$ 是集合$A$ 上的关系，对于任意$x,y,z\in A$，若从$\langle x,y\rangle\in R$且$\langle y,z\rangle\in R$这两个条件中推出$\langle x,z\rangle\in R$，则称关系$R$ 是传递关系，或称关系$R$具有传递性。即有： $(\forall x)(\forall y)(\forall z)(x\in A\land y\in A\land z\in A\land\langle x,y\rangle\in R\land\langle y,z\rangle\in R\to\langle x,z\rangle\in R)\Leftrightarrow R$为传递关系$\quad\text{(5-14) }$",关系的基本性质包含关系的传递性，传递性是关系基本性质的一种具体表现。
关系的基本性质,包含,自反性,,"前面学习了关系的五个基本性质，在关系图和关系矩阵上都能够找到表征这些性质的相关图特征和矩阵特征。因此，对于一个任意给定的二元关系，可以使用关系图或关系矩阵的相关特征判定该关系是否具备关系的哪些基本性质。从本质上看，关系是以序偶为元素的集合。下面介绍和讨论如何从集合的角度判定关系的基本性质。  
【定理5.10】设$R$ 是集合$A$ 上的二元关系，则有：  
（1）$R$ 是自反的$\iff I_{A}\subseteq R$；  （2）$R$ 是反自反的$\iff R\cap I_{A}=\emptyset$；  
（3）$R$ 是对称的$\Leftrightarrow R=R^{-1}$； （4）$R$ 是反对称的$\iff R\cap R^{-1}\subseteq I_{A}$  
（5）$R$ 是传递的$\Longleftrightarrow R\circ R\subseteq R$。  
下面定理表明，对于关系一些基本性质在某些运算下仍然能够保持，此时称关系性质在该运算下具有封闭性。例如，如果$A$ 上$d$ 两个关系都是对称的，那么这两个关系的并运算也是对称的。也就是说，关系的对称性质在关系并运算下是封闭的。  
【定理5.11】设$R$、$S$是定义在$A$ 上的二元关系，则：  
（1）若$R$、$S$是自反的，则$R^{-1}$，$R\cup S$，$R\cap S$，$R\circ S$也是自反的；  
（2）若$R$、$S$是反自反的，则$R^{-1}$，$R\cup S$，$R\cap S$也是反自反的；  
（3）若$R$、$S$是对称的，则$R^{-1}$，$R\cup S$，$R\cap S$也是对称的；  
（4）若$R$、$S$是反对称的，则$R^{-1}$，$R\cap S$也是反对称的；  
（5）若$R$、$S$是传递的，则$R^{-1}$，$R\cap S$也是传递的。",自反性是关系的基本性质之一
关系的基本性质,包含,反自反性,,"前面学习了关系的五个基本性质，在关系图和关系矩阵上都能够找到表征这些性质的相关图特征和矩阵特征。因此，对于一个任意给定的二元关系，可以使用关系图或关系矩阵的相关特征判定该关系是否具备关系的哪些基本性质。从本质上看，关系是以序偶为元素的集合。下面介绍和讨论如何从集合的角度判定关系的基本性质。  
【定理5.10】设$R$ 是集合$A$ 上的二元关系，则有：  
（1）$R$ 是自反的$\iff I_{A}\subseteq R$；  （2）$R$ 是反自反的$\iff R\cap I_{A}=\emptyset$；  
（3）$R$ 是对称的$\Leftrightarrow R=R^{-1}$； （4）$R$ 是反对称的$\iff R\cap R^{-1}\subseteq I_{A}$  
（5）$R$ 是传递的$\Longleftrightarrow R\circ R\subseteq R$。  
下面定理表明，对于关系一些基本性质在某些运算下仍然能够保持，此时称关系性质在该运算下具有封闭性。例如，如果$A$ 上$d$ 两个关系都是对称的，那么这两个关系的并运算也是对称的。也就是说，关系的对称性质在关系并运算下是封闭的。  
【定理5.11】设$R$、$S$是定义在$A$ 上的二元关系，则：  
（1）若$R$、$S$是自反的，则$R^{-1}$，$R\cup S$，$R\cap S$，$R\circ S$也是自反的；  
（2）若$R$、$S$是反自反的，则$R^{-1}$，$R\cup S$，$R\cap S$也是反自反的；  
（3）若$R$、$S$是对称的，则$R^{-1}$，$R\cup S$，$R\cap S$也是对称的；  
（4）若$R$、$S$是反对称的，则$R^{-1}$，$R\cap S$也是反对称的；  
（5）若$R$、$S$是传递的，则$R^{-1}$，$R\cap S$也是传递的。",反自反性是关系的基本性质之一
关系的基本性质,包含,对称性,,"前面学习了关系的五个基本性质，在关系图和关系矩阵上都能够找到表征这些性质的相关图特征和矩阵特征。因此，对于一个任意给定的二元关系，可以使用关系图或关系矩阵的相关特征判定该关系是否具备关系的哪些基本性质。从本质上看，关系是以序偶为元素的集合。下面介绍和讨论如何从集合的角度判定关系的基本性质。  
【定理5.10】设$R$ 是集合$A$ 上的二元关系，则有：  
（1）$R$ 是自反的$\iff I_{A}\subseteq R$；  （2）$R$ 是反自反的$\iff R\cap I_{A}=\emptyset$；  
（3）$R$ 是对称的$\Leftrightarrow R=R^{-1}$； （4）$R$ 是反对称的$\iff R\cap R^{-1}\subseteq I_{A}$  
（5）$R$ 是传递的$\Longleftrightarrow R\circ R\subseteq R$。  
下面定理表明，对于关系一些基本性质在某些运算下仍然能够保持，此时称关系性质在该运算下具有封闭性。例如，如果$A$ 上$d$ 两个关系都是对称的，那么这两个关系的并运算也是对称的。也就是说，关系的对称性质在关系并运算下是封闭的。  
【定理5.11】设$R$、$S$是定义在$A$ 上的二元关系，则：  
（1）若$R$、$S$是自反的，则$R^{-1}$，$R\cup S$，$R\cap S$，$R\circ S$也是自反的；  
（2）若$R$、$S$是反自反的，则$R^{-1}$，$R\cup S$，$R\cap S$也是反自反的；  
（3）若$R$、$S$是对称的，则$R^{-1}$，$R\cup S$，$R\cap S$也是对称的；  
（4）若$R$、$S$是反对称的，则$R^{-1}$，$R\cap S$也是反对称的；  
（5）若$R$、$S$是传递的，则$R^{-1}$，$R\cap S$也是传递的。",对称性是关系的基本性质之一
关系的基本性质,包含,反对称性,,"前面学习了关系的五个基本性质，在关系图和关系矩阵上都能够找到表征这些性质的相关图特征和矩阵特征。因此，对于一个任意给定的二元关系，可以使用关系图或关系矩阵的相关特征判定该关系是否具备关系的哪些基本性质。从本质上看，关系是以序偶为元素的集合。下面介绍和讨论如何从集合的角度判定关系的基本性质。  
【定理5.10】设$R$ 是集合$A$ 上的二元关系，则有：  
（1）$R$ 是自反的$\iff I_{A}\subseteq R$；  （2）$R$ 是反自反的$\iff R\cap I_{A}=\emptyset$；  
（3）$R$ 是对称的$\Leftrightarrow R=R^{-1}$； （4）$R$ 是反对称的$\iff R\cap R^{-1}\subseteq I_{A}$  
（5）$R$ 是传递的$\Longleftrightarrow R\circ R\subseteq R$。  
下面定理表明，对于关系一些基本性质在某些运算下仍然能够保持，此时称关系性质在该运算下具有封闭性。例如，如果$A$ 上$d$ 两个关系都是对称的，那么这两个关系的并运算也是对称的。也就是说，关系的对称性质在关系并运算下是封闭的。  
【定理5.11】设$R$、$S$是定义在$A$ 上的二元关系，则：  
（1）若$R$、$S$是自反的，则$R^{-1}$，$R\cup S$，$R\cap S$，$R\circ S$也是自反的；  
（2）若$R$、$S$是反自反的，则$R^{-1}$，$R\cup S$，$R\cap S$也是反自反的；  
（3）若$R$、$S$是对称的，则$R^{-1}$，$R\cup S$，$R\cap S$也是对称的；  
（4）若$R$、$S$是反对称的，则$R^{-1}$，$R\cap S$也是反对称的；  
（5）若$R$、$S$是传递的，则$R^{-1}$，$R\cap S$也是传递的。",反对称性是关系的基本性质之一
关系的基本性质,包含,传递性,,"前面学习了关系的五个基本性质，在关系图和关系矩阵上都能够找到表征这些性质的相关图特征和矩阵特征。因此，对于一个任意给定的二元关系，可以使用关系图或关系矩阵的相关特征判定该关系是否具备关系的哪些基本性质。从本质上看，关系是以序偶为元素的集合。下面介绍和讨论如何从集合的角度判定关系的基本性质。  
【定理5.10】设$R$ 是集合$A$ 上的二元关系，则有：  
（1）$R$ 是自反的$\iff I_{A}\subseteq R$；  （2）$R$ 是反自反的$\iff R\cap I_{A}=\emptyset$；  
（3）$R$ 是对称的$\Leftrightarrow R=R^{-1}$； （4）$R$ 是反对称的$\iff R\cap R^{-1}\subseteq I_{A}$  
（5）$R$ 是传递的$\Longleftrightarrow R\circ R\subseteq R$。  
下面定理表明，对于关系一些基本性质在某些运算下仍然能够保持，此时称关系性质在该运算下具有封闭性。例如，如果$A$ 上$d$ 两个关系都是对称的，那么这两个关系的并运算也是对称的。也就是说，关系的对称性质在关系并运算下是封闭的。  
【定理5.11】设$R$、$S$是定义在$A$ 上的二元关系，则：  
（1）若$R$、$S$是自反的，则$R^{-1}$，$R\cup S$，$R\cap S$，$R\circ S$也是自反的；  
（2）若$R$、$S$是反自反的，则$R^{-1}$，$R\cup S$，$R\cap S$也是反自反的；  
（3）若$R$、$S$是对称的，则$R^{-1}$，$R\cup S$，$R\cap S$也是对称的；  
（4）若$R$、$S$是反对称的，则$R^{-1}$，$R\cap S$也是反对称的；  
（5）若$R$、$S$是传递的，则$R^{-1}$，$R\cap S$也是传递的。",传递性是关系的基本性质之一
定理5.10,定义,自反性,,"前面学习了关系的五个基本性质，在关系图和关系矩阵上都能够找到表征这些性质的相关图特征和矩阵特征。因此，对于一个任意给定的二元关系，可以使用关系图或关系矩阵的相关特征判定该关系是否具备关系的哪些基本性质。从本质上看，关系是以序偶为元素的集合。下面介绍和讨论如何从集合的角度判定关系的基本性质。  
【定理5.10】设$R$ 是集合$A$ 上的二元关系，则有：  
（1）$R$ 是自反的$\iff I_{A}\subseteq R$；  （2）$R$ 是反自反的$\iff R\cap I_{A}=\emptyset$；  
（3）$R$ 是对称的$\Leftrightarrow R=R^{-1}$； （4）$R$ 是反对称的$\iff R\cap R^{-1}\subseteq I_{A}$  
（5）$R$ 是传递的$\Longleftrightarrow R\circ R\subseteq R$。  
下面定理表明，对于关系一些基本性质在某些运算下仍然能够保持，此时称关系性质在该运算下具有封闭性。例如，如果$A$ 上$d$ 两个关系都是对称的，那么这两个关系的并运算也是对称的。也就是说，关系的对称性质在关系并运算下是封闭的。  
【定理5.11】设$R$、$S$是定义在$A$ 上的二元关系，则：  
（1）若$R$、$S$是自反的，则$R^{-1}$，$R\cup S$，$R\cap S$，$R\circ S$也是自反的；  
（2）若$R$、$S$是反自反的，则$R^{-1}$，$R\cup S$，$R\cap S$也是反自反的；  
（3）若$R$、$S$是对称的，则$R^{-1}$，$R\cup S$，$R\cap S$也是对称的；  
（4）若$R$、$S$是反对称的，则$R^{-1}$，$R\cap S$也是反对称的；  
（5）若$R$、$S$是传递的，则$R^{-1}$，$R\cap S$也是传递的。",定理5.10定义了自反性的条件
定理5.10,定义,反自反性,,"前面学习了关系的五个基本性质，在关系图和关系矩阵上都能够找到表征这些性质的相关图特征和矩阵特征。因此，对于一个任意给定的二元关系，可以使用关系图或关系矩阵的相关特征判定该关系是否具备关系的哪些基本性质。从本质上看，关系是以序偶为元素的集合。下面介绍和讨论如何从集合的角度判定关系的基本性质。  
【定理5.10】设$R$ 是集合$A$ 上的二元关系，则有：  
（1）$R$ 是自反的$\iff I_{A}\subseteq R$；  （2）$R$ 是反自反的$\iff R\cap I_{A}=\emptyset$；  
（3）$R$ 是对称的$\Leftrightarrow R=R^{-1}$； （4）$R$ 是反对称的$\iff R\cap R^{-1}\subseteq I_{A}$  
（5）$R$ 是传递的$\Longleftrightarrow R\circ R\subseteq R$。  
下面定理表明，对于关系一些基本性质在某些运算下仍然能够保持，此时称关系性质在该运算下具有封闭性。例如，如果$A$ 上$d$ 两个关系都是对称的，那么这两个关系的并运算也是对称的。也就是说，关系的对称性质在关系并运算下是封闭的。  
【定理5.11】设$R$、$S$是定义在$A$ 上的二元关系，则：  
（1）若$R$、$S$是自反的，则$R^{-1}$，$R\cup S$，$R\cap S$，$R\circ S$也是自反的；  
（2）若$R$、$S$是反自反的，则$R^{-1}$，$R\cup S$，$R\cap S$也是反自反的；  
（3）若$R$、$S$是对称的，则$R^{-1}$，$R\cup S$，$R\cap S$也是对称的；  
（4）若$R$、$S$是反对称的，则$R^{-1}$，$R\cap S$也是反对称的；  
（5）若$R$、$S$是传递的，则$R^{-1}$，$R\cap S$也是传递的。",定理5.10定义了反自反性的条件
定理5.10,定义,对称性,,"前面学习了关系的五个基本性质，在关系图和关系矩阵上都能够找到表征这些性质的相关图特征和矩阵特征。因此，对于一个任意给定的二元关系，可以使用关系图或关系矩阵的相关特征判定该关系是否具备关系的哪些基本性质。从本质上看，关系是以序偶为元素的集合。下面介绍和讨论如何从集合的角度判定关系的基本性质。  
【定理5.10】设$R$ 是集合$A$ 上的二元关系，则有：  
（1）$R$ 是自反的$\iff I_{A}\subseteq R$；  （2）$R$ 是反自反的$\iff R\cap I_{A}=\emptyset$；  
（3）$R$ 是对称的$\Leftrightarrow R=R^{-1}$； （4）$R$ 是反对称的$\iff R\cap R^{-1}\subseteq I_{A}$  
（5）$R$ 是传递的$\Longleftrightarrow R\circ R\subseteq R$。  
下面定理表明，对于关系一些基本性质在某些运算下仍然能够保持，此时称关系性质在该运算下具有封闭性。例如，如果$A$ 上$d$ 两个关系都是对称的，那么这两个关系的并运算也是对称的。也就是说，关系的对称性质在关系并运算下是封闭的。  
【定理5.11】设$R$、$S$是定义在$A$ 上的二元关系，则：  
（1）若$R$、$S$是自反的，则$R^{-1}$，$R\cup S$，$R\cap S$，$R\circ S$也是自反的；  
（2）若$R$、$S$是反自反的，则$R^{-1}$，$R\cup S$，$R\cap S$也是反自反的；  
（3）若$R$、$S$是对称的，则$R^{-1}$，$R\cup S$，$R\cap S$也是对称的；  
（4）若$R$、$S$是反对称的，则$R^{-1}$，$R\cap S$也是反对称的；  
（5）若$R$、$S$是传递的，则$R^{-1}$，$R\cap S$也是传递的。",定理5.10定义了对称性的条件
定理5.10,定义,反对称性,,"前面学习了关系的五个基本性质，在关系图和关系矩阵上都能够找到表征这些性质的相关图特征和矩阵特征。因此，对于一个任意给定的二元关系，可以使用关系图或关系矩阵的相关特征判定该关系是否具备关系的哪些基本性质。从本质上看，关系是以序偶为元素的集合。下面介绍和讨论如何从集合的角度判定关系的基本性质。  
【定理5.10】设$R$ 是集合$A$ 上的二元关系，则有：  
（1）$R$ 是自反的$\iff I_{A}\subseteq R$；  （2）$R$ 是反自反的$\iff R\cap I_{A}=\emptyset$；  
（3）$R$ 是对称的$\Leftrightarrow R=R^{-1}$； （4）$R$ 是反对称的$\iff R\cap R^{-1}\subseteq I_{A}$  
（5）$R$ 是传递的$\Longleftrightarrow R\circ R\subseteq R$。  
下面定理表明，对于关系一些基本性质在某些运算下仍然能够保持，此时称关系性质在该运算下具有封闭性。例如，如果$A$ 上$d$ 两个关系都是对称的，那么这两个关系的并运算也是对称的。也就是说，关系的对称性质在关系并运算下是封闭的。  
【定理5.11】设$R$、$S$是定义在$A$ 上的二元关系，则：  
（1）若$R$、$S$是自反的，则$R^{-1}$，$R\cup S$，$R\cap S$，$R\circ S$也是自反的；  
（2）若$R$、$S$是反自反的，则$R^{-1}$，$R\cup S$，$R\cap S$也是反自反的；  
（3）若$R$、$S$是对称的，则$R^{-1}$，$R\cup S$，$R\cap S$也是对称的；  
（4）若$R$、$S$是反对称的，则$R^{-1}$，$R\cap S$也是反对称的；  
（5）若$R$、$S$是传递的，则$R^{-1}$，$R\cap S$也是传递的。",定理5.10定义了反对称性的条件
定理5.10,定义,传递性,,"前面学习了关系的五个基本性质，在关系图和关系矩阵上都能够找到表征这些性质的相关图特征和矩阵特征。因此，对于一个任意给定的二元关系，可以使用关系图或关系矩阵的相关特征判定该关系是否具备关系的哪些基本性质。从本质上看，关系是以序偶为元素的集合。下面介绍和讨论如何从集合的角度判定关系的基本性质。  
【定理5.10】设$R$ 是集合$A$ 上的二元关系，则有：  
（1）$R$ 是自反的$\iff I_{A}\subseteq R$；  （2）$R$ 是反自反的$\iff R\cap I_{A}=\emptyset$；  
（3）$R$ 是对称的$\Leftrightarrow R=R^{-1}$； （4）$R$ 是反对称的$\iff R\cap R^{-1}\subseteq I_{A}$  
（5）$R$ 是传递的$\Longleftrightarrow R\circ R\subseteq R$。  
下面定理表明，对于关系一些基本性质在某些运算下仍然能够保持，此时称关系性质在该运算下具有封闭性。例如，如果$A$ 上$d$ 两个关系都是对称的，那么这两个关系的并运算也是对称的。也就是说，关系的对称性质在关系并运算下是封闭的。  
【定理5.11】设$R$、$S$是定义在$A$ 上的二元关系，则：  
（1）若$R$、$S$是自反的，则$R^{-1}$，$R\cup S$，$R\cap S$，$R\circ S$也是自反的；  
（2）若$R$、$S$是反自反的，则$R^{-1}$，$R\cup S$，$R\cap S$也是反自反的；  
（3）若$R$、$S$是对称的，则$R^{-1}$，$R\cup S$，$R\cap S$也是对称的；  
（4）若$R$、$S$是反对称的，则$R^{-1}$，$R\cap S$也是反对称的；  
（5）若$R$、$S$是传递的，则$R^{-1}$，$R\cap S$也是传递的。",定理5.10定义了传递性的条件
关系性质的封闭性,示例,对称性,,"前面学习了关系的五个基本性质，在关系图和关系矩阵上都能够找到表征这些性质的相关图特征和矩阵特征。因此，对于一个任意给定的二元关系，可以使用关系图或关系矩阵的相关特征判定该关系是否具备关系的哪些基本性质。从本质上看，关系是以序偶为元素的集合。下面介绍和讨论如何从集合的角度判定关系的基本性质。  
【定理5.10】设$R$ 是集合$A$ 上的二元关系，则有：  
（1）$R$ 是自反的$\iff I_{A}\subseteq R$；  （2）$R$ 是反自反的$\iff R\cap I_{A}=\emptyset$；  
（3）$R$ 是对称的$\Leftrightarrow R=R^{-1}$； （4）$R$ 是反对称的$\iff R\cap R^{-1}\subseteq I_{A}$  
（5）$R$ 是传递的$\Longleftrightarrow R\circ R\subseteq R$。  
下面定理表明，对于关系一些基本性质在某些运算下仍然能够保持，此时称关系性质在该运算下具有封闭性。例如，如果$A$ 上$d$ 两个关系都是对称的，那么这两个关系的并运算也是对称的。也就是说，关系的对称性质在关系并运算下是封闭的。  
【定理5.11】设$R$、$S$是定义在$A$ 上的二元关系，则：  
（1）若$R$、$S$是自反的，则$R^{-1}$，$R\cup S$，$R\cap S$，$R\circ S$也是自反的；  
（2）若$R$、$S$是反自反的，则$R^{-1}$，$R\cup S$，$R\cap S$也是反自反的；  
（3）若$R$、$S$是对称的，则$R^{-1}$，$R\cup S$，$R\cap S$也是对称的；  
（4）若$R$、$S$是反对称的，则$R^{-1}$，$R\cap S$也是反对称的；  
（5）若$R$、$S$是传递的，则$R^{-1}$，$R\cap S$也是传递的。",对称性质在关系并运算下具有封闭性
定理5.11,保持,自反性,,"前面学习了关系的五个基本性质，在关系图和关系矩阵上都能够找到表征这些性质的相关图特征和矩阵特征。因此，对于一个任意给定的二元关系，可以使用关系图或关系矩阵的相关特征判定该关系是否具备关系的哪些基本性质。从本质上看，关系是以序偶为元素的集合。下面介绍和讨论如何从集合的角度判定关系的基本性质。  
【定理5.10】设$R$ 是集合$A$ 上的二元关系，则有：  
（1）$R$ 是自反的$\iff I_{A}\subseteq R$；  （2）$R$ 是反自反的$\iff R\cap I_{A}=\emptyset$；  
（3）$R$ 是对称的$\Leftrightarrow R=R^{-1}$； （4）$R$ 是反对称的$\iff R\cap R^{-1}\subseteq I_{A}$  
（5）$R$ 是传递的$\Longleftrightarrow R\circ R\subseteq R$。  
下面定理表明，对于关系一些基本性质在某些运算下仍然能够保持，此时称关系性质在该运算下具有封闭性。例如，如果$A$ 上$d$ 两个关系都是对称的，那么这两个关系的并运算也是对称的。也就是说，关系的对称性质在关系并运算下是封闭的。  
【定理5.11】设$R$、$S$是定义在$A$ 上的二元关系，则：  
（1）若$R$、$S$是自反的，则$R^{-1}$，$R\cup S$，$R\cap S$，$R\circ S$也是自反的；  
（2）若$R$、$S$是反自反的，则$R^{-1}$，$R\cup S$，$R\cap S$也是反自反的；  
（3）若$R$、$S$是对称的，则$R^{-1}$，$R\cup S$，$R\cap S$也是对称的；  
（4）若$R$、$S$是反对称的，则$R^{-1}$，$R\cap S$也是反对称的；  
（5）若$R$、$S$是传递的，则$R^{-1}$，$R\cap S$也是传递的。",定理5.11表明自反性在某些运算下保持
定理5.11,保持,反自反性,,"前面学习了关系的五个基本性质，在关系图和关系矩阵上都能够找到表征这些性质的相关图特征和矩阵特征。因此，对于一个任意给定的二元关系，可以使用关系图或关系矩阵的相关特征判定该关系是否具备关系的哪些基本性质。从本质上看，关系是以序偶为元素的集合。下面介绍和讨论如何从集合的角度判定关系的基本性质。  
【定理5.10】设$R$ 是集合$A$ 上的二元关系，则有：  
（1）$R$ 是自反的$\iff I_{A}\subseteq R$；  （2）$R$ 是反自反的$\iff R\cap I_{A}=\emptyset$；  
（3）$R$ 是对称的$\Leftrightarrow R=R^{-1}$； （4）$R$ 是反对称的$\iff R\cap R^{-1}\subseteq I_{A}$  
（5）$R$ 是传递的$\Longleftrightarrow R\circ R\subseteq R$。  
下面定理表明，对于关系一些基本性质在某些运算下仍然能够保持，此时称关系性质在该运算下具有封闭性。例如，如果$A$ 上$d$ 两个关系都是对称的，那么这两个关系的并运算也是对称的。也就是说，关系的对称性质在关系并运算下是封闭的。  
【定理5.11】设$R$、$S$是定义在$A$ 上的二元关系，则：  
（1）若$R$、$S$是自反的，则$R^{-1}$，$R\cup S$，$R\cap S$，$R\circ S$也是自反的；  
（2）若$R$、$S$是反自反的，则$R^{-1}$，$R\cup S$，$R\cap S$也是反自反的；  
（3）若$R$、$S$是对称的，则$R^{-1}$，$R\cup S$，$R\cap S$也是对称的；  
（4）若$R$、$S$是反对称的，则$R^{-1}$，$R\cap S$也是反对称的；  
（5）若$R$、$S$是传递的，则$R^{-1}$，$R\cap S$也是传递的。",定理5.11表明反自反性在某些运算下保持
定理5.11,保持,对称性,,"前面学习了关系的五个基本性质，在关系图和关系矩阵上都能够找到表征这些性质的相关图特征和矩阵特征。因此，对于一个任意给定的二元关系，可以使用关系图或关系矩阵的相关特征判定该关系是否具备关系的哪些基本性质。从本质上看，关系是以序偶为元素的集合。下面介绍和讨论如何从集合的角度判定关系的基本性质。  
【定理5.10】设$R$ 是集合$A$ 上的二元关系，则有：  
（1）$R$ 是自反的$\iff I_{A}\subseteq R$；  （2）$R$ 是反自反的$\iff R\cap I_{A}=\emptyset$；  
（3）$R$ 是对称的$\Leftrightarrow R=R^{-1}$； （4）$R$ 是反对称的$\iff R\cap R^{-1}\subseteq I_{A}$  
（5）$R$ 是传递的$\Longleftrightarrow R\circ R\subseteq R$。  
下面定理表明，对于关系一些基本性质在某些运算下仍然能够保持，此时称关系性质在该运算下具有封闭性。例如，如果$A$ 上$d$ 两个关系都是对称的，那么这两个关系的并运算也是对称的。也就是说，关系的对称性质在关系并运算下是封闭的。  
【定理5.11】设$R$、$S$是定义在$A$ 上的二元关系，则：  
（1）若$R$、$S$是自反的，则$R^{-1}$，$R\cup S$，$R\cap S$，$R\circ S$也是自反的；  
（2）若$R$、$S$是反自反的，则$R^{-1}$，$R\cup S$，$R\cap S$也是反自反的；  
（3）若$R$、$S$是对称的，则$R^{-1}$，$R\cup S$，$R\cap S$也是对称的；  
（4）若$R$、$S$是反对称的，则$R^{-1}$，$R\cap S$也是反对称的；  
（5）若$R$、$S$是传递的，则$R^{-1}$，$R\cap S$也是传递的。",定理5.11表明对称性在某些运算下保持
定理5.11,保持,反对称性,,"前面学习了关系的五个基本性质，在关系图和关系矩阵上都能够找到表征这些性质的相关图特征和矩阵特征。因此，对于一个任意给定的二元关系，可以使用关系图或关系矩阵的相关特征判定该关系是否具备关系的哪些基本性质。从本质上看，关系是以序偶为元素的集合。下面介绍和讨论如何从集合的角度判定关系的基本性质。  
【定理5.10】设$R$ 是集合$A$ 上的二元关系，则有：  
（1）$R$ 是自反的$\iff I_{A}\subseteq R$；  （2）$R$ 是反自反的$\iff R\cap I_{A}=\emptyset$；  
（3）$R$ 是对称的$\Leftrightarrow R=R^{-1}$； （4）$R$ 是反对称的$\iff R\cap R^{-1}\subseteq I_{A}$  
（5）$R$ 是传递的$\Longleftrightarrow R\circ R\subseteq R$。  
下面定理表明，对于关系一些基本性质在某些运算下仍然能够保持，此时称关系性质在该运算下具有封闭性。例如，如果$A$ 上$d$ 两个关系都是对称的，那么这两个关系的并运算也是对称的。也就是说，关系的对称性质在关系并运算下是封闭的。  
【定理5.11】设$R$、$S$是定义在$A$ 上的二元关系，则：  
（1）若$R$、$S$是自反的，则$R^{-1}$，$R\cup S$，$R\cap S$，$R\circ S$也是自反的；  
（2）若$R$、$S$是反自反的，则$R^{-1}$，$R\cup S$，$R\cap S$也是反自反的；  
（3）若$R$、$S$是对称的，则$R^{-1}$，$R\cup S$，$R\cap S$也是对称的；  
（4）若$R$、$S$是反对称的，则$R^{-1}$，$R\cap S$也是反对称的；  
（5）若$R$、$S$是传递的，则$R^{-1}$，$R\cap S$也是传递的。",定理5.11表明反对称性在某些运算下保持
定理5.11,保持,传递性,,"前面学习了关系的五个基本性质，在关系图和关系矩阵上都能够找到表征这些性质的相关图特征和矩阵特征。因此，对于一个任意给定的二元关系，可以使用关系图或关系矩阵的相关特征判定该关系是否具备关系的哪些基本性质。从本质上看，关系是以序偶为元素的集合。下面介绍和讨论如何从集合的角度判定关系的基本性质。  
【定理5.10】设$R$ 是集合$A$ 上的二元关系，则有：  
（1）$R$ 是自反的$\iff I_{A}\subseteq R$；  （2）$R$ 是反自反的$\iff R\cap I_{A}=\emptyset$；  
（3）$R$ 是对称的$\Leftrightarrow R=R^{-1}$； （4）$R$ 是反对称的$\iff R\cap R^{-1}\subseteq I_{A}$  
（5）$R$ 是传递的$\Longleftrightarrow R\circ R\subseteq R$。  
下面定理表明，对于关系一些基本性质在某些运算下仍然能够保持，此时称关系性质在该运算下具有封闭性。例如，如果$A$ 上$d$ 两个关系都是对称的，那么这两个关系的并运算也是对称的。也就是说，关系的对称性质在关系并运算下是封闭的。  
【定理5.11】设$R$、$S$是定义在$A$ 上的二元关系，则：  
（1）若$R$、$S$是自反的，则$R^{-1}$，$R\cup S$，$R\cap S$，$R\circ S$也是自反的；  
（2）若$R$、$S$是反自反的，则$R^{-1}$，$R\cup S$，$R\cap S$也是反自反的；  
（3）若$R$、$S$是对称的，则$R^{-1}$，$R\cup S$，$R\cap S$也是对称的；  
（4）若$R$、$S$是反对称的，则$R^{-1}$，$R\cap S$也是反对称的；  
（5）若$R$、$S$是传递的，则$R^{-1}$，$R\cap S$也是传递的。",定理5.11表明传递性在某些运算下保持
自反性,应用,关系性质闭包,,自反性、对称性和传递性是关系的重要性质，在对很多关系问题的求解过程中都需要用到这些性质。然而，并不是所有二元关系都具备这些性质。在关系模型求解时必须用到但现有关系不具备这些性质的时候，通常需要做一些变通，采用适当方法对现有关系进行尽可能小的调整或改变，使其具有所需的性质。给关系加上适当的性质闭包就是一种常用的变通方法，在很多场合都有着成功的应用。本节着重介绍这种加闭包的方法，具体包括关系闭包的基本概念、构造方法和基本性质。,关系性质闭包用于使关系具有自反性
对称性,应用,关系性质闭包,,自反性、对称性和传递性是关系的重要性质，在对很多关系问题的求解过程中都需要用到这些性质。然而，并不是所有二元关系都具备这些性质。在关系模型求解时必须用到但现有关系不具备这些性质的时候，通常需要做一些变通，采用适当方法对现有关系进行尽可能小的调整或改变，使其具有所需的性质。给关系加上适当的性质闭包就是一种常用的变通方法，在很多场合都有着成功的应用。本节着重介绍这种加闭包的方法，具体包括关系闭包的基本概念、构造方法和基本性质。,关系性质闭包用于使关系具有对称性
传递性,应用,关系性质闭包,,自反性、对称性和传递性是关系的重要性质，在对很多关系问题的求解过程中都需要用到这些性质。然而，并不是所有二元关系都具备这些性质。在关系模型求解时必须用到但现有关系不具备这些性质的时候，通常需要做一些变通，采用适当方法对现有关系进行尽可能小的调整或改变，使其具有所需的性质。给关系加上适当的性质闭包就是一种常用的变通方法，在很多场合都有着成功的应用。本节着重介绍这种加闭包的方法，具体包括关系闭包的基本概念、构造方法和基本性质。,关系性质闭包用于使关系具有传递性
自反闭包,是,关系闭包,,"首先，我们考察关系的自反闭包。假设$R$ 是集合$A$ 上的二元关系，如果$R$ 不满足自反性，就说明集合$A$ 中存在某个元素$a.$,使得$\langle a,a\rangle\not\in R$，此时可以将关系R 进行调整或修改，避免这种情况的发生。具体地说，就是将序偶$\langle a,a\rangle$纳入到关系$R$ 由此产生一个新的关系$R^{\prime}$。一般地，如果对于$A$ 中的每个元素${x}$，都将$\langle x,x\rangle$纳入到关系$R$，由此产生新的关系$R^{\prime}$必然满足自反性。事实上，关系$R^{\prime}$是对关系$R$ 的一种扩充，使得扩充后的关系能够满足自反性。若能证明这种扩充是满足扩充目的最小扩充，则$R^{\prime}$就是关系$R$ 的自反闭包。  
可同理考察对称闭包。假设$R$ 是集合$A$ 上的二元关系，如果$R$ 不满足对称性，就说明集合$A$ 中存在两个元素$a$和$b$使得$\langle a,b\rangle\in R$，但$\langle b,a\rangle\not\in R$。此时，只需将$\langle b,a\rangle$纳入$R$ 中就可避免这种情况发生。因此，可以对$R$ 进行适当扩充构成其对称闭包。  
可类似考虑传递闭包的基本思想，不再赘述。下面给出这三个闭包的具体定义：  
【定义5.22】设$R$ 是集合$A$ 上的关系，若存在$A$ 上的另一个关系$R^{\prime}$，满足：  
（1）$R^{\prime}$是自反的（对称的、或传递的）  
（2）对$A$ 上任何自反（对称的、或传递）关系$R^{\prime\prime}$，如果$R\subseteq R^{\prime\prime}$，那么$R^{\prime}\subseteq R^{\prime\prime}$，则称${R^{\prime}}$为$R$的自反闭包（对称闭包或传递闭包），记为$r(R)(s(R)$或$t(R))$。  
下面定理给出了自反闭包和传递闭包的构造方法：  
【定理5.12】设$R$ 是非空集合$A$ 上的关系，则有：  
$r(R)=R\cup R^{0};\,\,\,s(R)=R\cup R^{-1}$  
由上述例题可得利用关系图求关系$R$ 闭包的方法：  
（1）检查$R$ 的关系图，在没有自环的结点处加上自环，可得$r(R)$的关系图；  
（2）检查$R$ 的关系图，将每条单向边全部改成双向边，可得$s(R)$的关系图；  
（3）检查$R$ 的关系图，从每个结点出发，找到其终点，如果该结点到其终点没有边相连，就加上此边，由此可得$t(R)$的关系图。",自反闭包是关系闭包的一种，通过对关系R进行扩充使其满足自反性
对称闭包,是,关系闭包,,"首先，我们考察关系的自反闭包。假设$R$ 是集合$A$ 上的二元关系，如果$R$ 不满足自反性，就说明集合$A$ 中存在某个元素$a.$,使得$\langle a,a\rangle\not\in R$，此时可以将关系R 进行调整或修改，避免这种情况的发生。具体地说，就是将序偶$\langle a,a\rangle$纳入到关系$R$ 由此产生一个新的关系$R^{\prime}$。一般地，如果对于$A$ 中的每个元素${x}$，都将$\langle x,x\rangle$纳入到关系$R$，由此产生新的关系$R^{\prime}$必然满足自反性。事实上，关系$R^{\prime}$是对关系$R$ 的一种扩充，使得扩充后的关系能够满足自反性。若能证明这种扩充是满足扩充目的最小扩充，则$R^{\prime}$就是关系$R$ 的自反闭包。  
可同理考察对称闭包。假设$R$ 是集合$A$ 上的二元关系，如果$R$ 不满足对称性，就说明集合$A$ 中存在两个元素$a$和$b$使得$\langle a,b\rangle\in R$，但$\langle b,a\rangle\not\in R$。此时，只需将$\langle b,a\rangle$纳入$R$ 中就可避免这种情况发生。因此，可以对$R$ 进行适当扩充构成其对称闭包。  
可类似考虑传递闭包的基本思想，不再赘述。下面给出这三个闭包的具体定义：  
【定义5.22】设$R$ 是集合$A$ 上的关系，若存在$A$ 上的另一个关系$R^{\prime}$，满足：  
（1）$R^{\prime}$是自反的（对称的、或传递的）  
（2）对$A$ 上任何自反（对称的、或传递）关系$R^{\prime\prime}$，如果$R\subseteq R^{\prime\prime}$，那么$R^{\prime}\subseteq R^{\prime\prime}$，则称${R^{\prime}}$为$R$的自反闭包（对称闭包或传递闭包），记为$r(R)(s(R)$或$t(R))$。  
下面定理给出了自反闭包和传递闭包的构造方法：  
【定理5.12】设$R$ 是非空集合$A$ 上的关系，则有：  
$r(R)=R\cup R^{0};\,\,\,s(R)=R\cup R^{-1}$  
由上述例题可得利用关系图求关系$R$ 闭包的方法：  
（1）检查$R$ 的关系图，在没有自环的结点处加上自环，可得$r(R)$的关系图；  
（2）检查$R$ 的关系图，将每条单向边全部改成双向边，可得$s(R)$的关系图；  
（3）检查$R$ 的关系图，从每个结点出发，找到其终点，如果该结点到其终点没有边相连，就加上此边，由此可得$t(R)$的关系图。",对称闭包是关系闭包的一种，通过对关系R进行扩充使其满足对称性
传递闭包,是,关系闭包,,"首先，我们考察关系的自反闭包。假设$R$ 是集合$A$ 上的二元关系，如果$R$ 不满足自反性，就说明集合$A$ 中存在某个元素$a.$,使得$\langle a,a\rangle\not\in R$，此时可以将关系R 进行调整或修改，避免这种情况的发生。具体地说，就是将序偶$\langle a,a\rangle$纳入到关系$R$ 由此产生一个新的关系$R^{\prime}$。一般地，如果对于$A$ 中的每个元素${x}$，都将$\langle x,x\rangle$纳入到关系$R$，由此产生新的关系$R^{\prime}$必然满足自反性。事实上，关系$R^{\prime}$是对关系$R$ 的一种扩充，使得扩充后的关系能够满足自反性。若能证明这种扩充是满足扩充目的最小扩充，则$R^{\prime}$就是关系$R$ 的自反闭包。  
可同理考察对称闭包。假设$R$ 是集合$A$ 上的二元关系，如果$R$ 不满足对称性，就说明集合$A$ 中存在两个元素$a$和$b$使得$\langle a,b\rangle\in R$，但$\langle b,a\rangle\not\in R$。此时，只需将$\langle b,a\rangle$纳入$R$ 中就可避免这种情况发生。因此，可以对$R$ 进行适当扩充构成其对称闭包。  
可类似考虑传递闭包的基本思想，不再赘述。下面给出这三个闭包的具体定义：  
【定义5.22】设$R$ 是集合$A$ 上的关系，若存在$A$ 上的另一个关系$R^{\prime}$，满足：  
（1）$R^{\prime}$是自反的（对称的、或传递的）  
（2）对$A$ 上任何自反（对称的、或传递）关系$R^{\prime\prime}$，如果$R\subseteq R^{\prime\prime}$，那么$R^{\prime}\subseteq R^{\prime\prime}$，则称${R^{\prime}}$为$R$的自反闭包（对称闭包或传递闭包），记为$r(R)(s(R)$或$t(R))$。  
下面定理给出了自反闭包和传递闭包的构造方法：  
【定理5.12】设$R$ 是非空集合$A$ 上的关系，则有：  
$r(R)=R\cup R^{0};\,\,\,s(R)=R\cup R^{-1}$  
由上述例题可得利用关系图求关系$R$ 闭包的方法：  
（1）检查$R$ 的关系图，在没有自环的结点处加上自环，可得$r(R)$的关系图；  
（2）检查$R$ 的关系图，将每条单向边全部改成双向边，可得$s(R)$的关系图；  
（3）检查$R$ 的关系图，从每个结点出发，找到其终点，如果该结点到其终点没有边相连，就加上此边，由此可得$t(R)$的关系图。",传递闭包是关系闭包的一种，通过对关系R进行扩充使其满足传递性
定理5.12,给出,自反闭包,,"首先，我们考察关系的自反闭包。假设$R$ 是集合$A$ 上的二元关系，如果$R$ 不满足自反性，就说明集合$A$ 中存在某个元素$a.$,使得$\langle a,a\rangle\not\in R$，此时可以将关系R 进行调整或修改，避免这种情况的发生。具体地说，就是将序偶$\langle a,a\rangle$纳入到关系$R$ 由此产生一个新的关系$R^{\prime}$。一般地，如果对于$A$ 中的每个元素${x}$，都将$\langle x,x\rangle$纳入到关系$R$，由此产生新的关系$R^{\prime}$必然满足自反性。事实上，关系$R^{\prime}$是对关系$R$ 的一种扩充，使得扩充后的关系能够满足自反性。若能证明这种扩充是满足扩充目的最小扩充，则$R^{\prime}$就是关系$R$ 的自反闭包。  
可同理考察对称闭包。假设$R$ 是集合$A$ 上的二元关系，如果$R$ 不满足对称性，就说明集合$A$ 中存在两个元素$a$和$b$使得$\langle a,b\rangle\in R$，但$\langle b,a\rangle\not\in R$。此时，只需将$\langle b,a\rangle$纳入$R$ 中就可避免这种情况发生。因此，可以对$R$ 进行适当扩充构成其对称闭包。  
可类似考虑传递闭包的基本思想，不再赘述。下面给出这三个闭包的具体定义：  
【定义5.22】设$R$ 是集合$A$ 上的关系，若存在$A$ 上的另一个关系$R^{\prime}$，满足：  
（1）$R^{\prime}$是自反的（对称的、或传递的）  
（2）对$A$ 上任何自反（对称的、或传递）关系$R^{\prime\prime}$，如果$R\subseteq R^{\prime\prime}$，那么$R^{\prime}\subseteq R^{\prime\prime}$，则称${R^{\prime}}$为$R$的自反闭包（对称闭包或传递闭包），记为$r(R)(s(R)$或$t(R))$。  
下面定理给出了自反闭包和传递闭包的构造方法：  
【定理5.12】设$R$ 是非空集合$A$ 上的关系，则有：  
$r(R)=R\cup R^{0};\,\,\,s(R)=R\cup R^{-1}$  
由上述例题可得利用关系图求关系$R$ 闭包的方法：  
（1）检查$R$ 的关系图，在没有自环的结点处加上自环，可得$r(R)$的关系图；  
（2）检查$R$ 的关系图，将每条单向边全部改成双向边，可得$s(R)$的关系图；  
（3）检查$R$ 的关系图，从每个结点出发，找到其终点，如果该结点到其终点没有边相连，就加上此边，由此可得$t(R)$的关系图。",定理5.12给出了自反闭包的构造方法
定理5.12,给出,传递闭包,,"首先，我们考察关系的自反闭包。假设$R$ 是集合$A$ 上的二元关系，如果$R$ 不满足自反性，就说明集合$A$ 中存在某个元素$a.$,使得$\langle a,a\rangle\not\in R$，此时可以将关系R 进行调整或修改，避免这种情况的发生。具体地说，就是将序偶$\langle a,a\rangle$纳入到关系$R$ 由此产生一个新的关系$R^{\prime}$。一般地，如果对于$A$ 中的每个元素${x}$，都将$\langle x,x\rangle$纳入到关系$R$，由此产生新的关系$R^{\prime}$必然满足自反性。事实上，关系$R^{\prime}$是对关系$R$ 的一种扩充，使得扩充后的关系能够满足自反性。若能证明这种扩充是满足扩充目的最小扩充，则$R^{\prime}$就是关系$R$ 的自反闭包。  
可同理考察对称闭包。假设$R$ 是集合$A$ 上的二元关系，如果$R$ 不满足对称性，就说明集合$A$ 中存在两个元素$a$和$b$使得$\langle a,b\rangle\in R$，但$\langle b,a\rangle\not\in R$。此时，只需将$\langle b,a\rangle$纳入$R$ 中就可避免这种情况发生。因此，可以对$R$ 进行适当扩充构成其对称闭包。  
可类似考虑传递闭包的基本思想，不再赘述。下面给出这三个闭包的具体定义：  
【定义5.22】设$R$ 是集合$A$ 上的关系，若存在$A$ 上的另一个关系$R^{\prime}$，满足：  
（1）$R^{\prime}$是自反的（对称的、或传递的）  
（2）对$A$ 上任何自反（对称的、或传递）关系$R^{\prime\prime}$，如果$R\subseteq R^{\prime\prime}$，那么$R^{\prime}\subseteq R^{\prime\prime}$，则称${R^{\prime}}$为$R$的自反闭包（对称闭包或传递闭包），记为$r(R)(s(R)$或$t(R))$。  
下面定理给出了自反闭包和传递闭包的构造方法：  
【定理5.12】设$R$ 是非空集合$A$ 上的关系，则有：  
$r(R)=R\cup R^{0};\,\,\,s(R)=R\cup R^{-1}$  
由上述例题可得利用关系图求关系$R$ 闭包的方法：  
（1）检查$R$ 的关系图，在没有自环的结点处加上自环，可得$r(R)$的关系图；  
（2）检查$R$ 的关系图，将每条单向边全部改成双向边，可得$s(R)$的关系图；  
（3）检查$R$ 的关系图，从每个结点出发，找到其终点，如果该结点到其终点没有边相连，就加上此边，由此可得$t(R)$的关系图。",定理5.12给出了传递闭包的构造方法
传递闭包,定义,传递闭包构造定理,,"自反闭包和对称闭包的构造比较简单，一般通过枚举的方法就可以得到解决。然而，传递闭包的构造比自反闭包和对称闭包要困难一些，需要一些技巧。因此，本小节对传递闭包概念做进一步深入理解并由此给出传递闭包构造方法和技巧。  
假设𝐴是任一给定的有限非空集合，$R$ 是$A$ 上的一个二元关系，$t(R)$是$R$ 的传递闭包，显然有${\boldsymbol{R}}\subseteq\ t({\boldsymbol{R}})$。现对于任意$\langle x,z\rangle\in R^{2}$或$\langle x,z\rangle\in R\circ R$，由$R\circ R$的定义知必存在$A$ 中某个元素$y$，使得$\langle x,y\rangle\in R$且$\langle y,z\rangle\in R$，那么根据关系$t(R)$的传递性，必有$\langle x,z\rangle\in t(R)$。故有：$R^{2}\subseteq\ t(R)$，即$R^{2}$也是$t(R)$的一个子集合。  
类似地，对于任意$\langle x,z\rangle\in R^{3}$或$\langle x,z\rangle\in R^{2}\circ R$，则必存在$A$ 中某元素$y$，使得$\langle x,y\rangle\in R^{2}$且$\langle y,z\rangle\in R$，从而有$\langle x,z\rangle\in t(R)$，故有$R^{3}\subseteq\ t(R)$。以此类推，可知，对于任意自然数$k$，必有$R^{k}\subseteq\ t(R)$。故有：
$$
R\ \cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots\subseteq\ t(R)\quad\text{(5-15)}
$$
根据传递闭包$t(R)$的定义，$t(R)$是包含$ R$的传递性关系中最小的集合，要证明：
$$
t(R)\ \,\subseteq\,R\,\cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots
$$
只需证明 $R\ \cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots$ 满足传递性即可。任取两个序偶 $\langle x,y\rangle$ 和 $\langle y,z\rangle$ ，满足：
$$
\langle x,y\rangle\in R\ \cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots;\ \ \langle y,z\rangle\in R\ \cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots
$$
则分别存在自然数$t,s$，使得$\langle x,y\rangle\in R^{t}$且$\langle y,z\rangle\in R^{s}$，则根据关系复合运算的定义，有：$\langle x,z\rangle\in R^{t}\circ R^{s}$，即有：$\langle x,z\rangle\in R^{t+s}$。故有：$\langle x,z\rangle\in\!\!R\,\cup\!R^{2}\cup\!R^{3}\cup\cdots\cup\!R^{k}\cup\cdots_{\circ}$。即有：
$$
t(R)\ \,\subseteq\,R\,\cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots\quad\text{(5-16)}
$$
经过以上分析，可得到如果关于传递闭包构造定理：  
【定理5.13】设$R$ 是非空集合$A$ 上的关系，$t(R)$是$R$ 的传递闭包，$M$和$M_{t}$分别为$R$ 和$t(R)$的关系矩阵，则有：
$$
t(R)=\,R\,\cup R^{2}\cup R^{3}\cup\cdots\quad\text{(5-17)}
$$  
$$
M_{t}=M\lor M^{2}\lor M^{3}\lor\cdots\quad\text{(5-18)}
$$  
通过前面的例题可以看出，使用集合运算法计算传递闭包比较繁琐晦涩，非常容易出错，使用矩阵计算则涉及计算量很大的方幂计算。为了更加方便地构造关系的传递闭包，下面介绍一个比较高效传递闭包构造算法，即著名的沃舍尔算法。  
假设$R$ 是非空集合$A$ 上的二元关系，$t(R)$是$R$ 的传递闭包，$G$ 是$R$ 的关系图。从前面分析可知，在传递闭包$t(R)$的关系图中，若从结点$x$到结点$y$有一条边，当且仅当在$R$的关系图$G$ 中存在一条从结点$x$到结点$y$且边数大于或等于1 的链路，即在图$G$ 可以从结点$x$连通到结点$y$。因此，关于$R$的传递闭包$t(R)$实际上就是$R$的关系图$G$ 的连通关系$R^{*}$，即有：  
$R^{*}=\{\langle x,y\rangle|$在图$G$中存在一条从结点结点$x$到结点𝑦有向链路}  
现考虑 $n+1$ 个矩阵序列 $M_{0},M_{1},\cdots,M_{n}$ ，将矩阵 ${M}_{k}$ 的第 $𝑖 $行第$ 𝑗 $列的元素记为 $M_{k}[i,j]$ 。对 于$k=0,1,\cdots n$，$M_{k}[i,j]=1$当且仅当在$R$的关系图$G$ 中存在一条结点$x_{i}$到结点$x_{j}$的一条链路，并且这条链路除两个端点之外的中间结点只能经过集合$\{x_{1},x_{2},\cdots,x_{k}\}$中的结点。显然，$M_{0}$就是$R$ 的关系矩阵，而$M_{n}$就是$R$ 的传递闭包$t(R)$的关系矩阵。沃舍尔算法的核心思想就是采用递推的方法从$M_{0}$逐步计算出$M_{n}$，据此给出$t(R)$的高效构造算法。  
假设$M_{k}$已经计算完成，那么如何从$M_{k}$计算出$M_{k+1}$呢？所谓计算出$M_{k+1}$，其实就是对每组$i,j$，确定$M_{k+1}[i,j]$是否为1。根据$M_{k+1}$的定义，$M_{k+1}[i,j]=1$当且仅当在$R$的关系图$G$中存在一条结点$x_{i}$到结点$x_{j}$的一条链路，并且这条链路除两个端点之外的中间结点只能经过集合$\{x_{1},x_{2},\cdots,x_{k},x_{k+1}\}$中的结点。这种链路只有两种可能性：  
第一种是只经过$\{x_{1},x_{2},\cdots,x_{k}\}$中的结点，此时$M_{k}[i,j]=1$  
第二种可能是链路经过了结点$x_{k+1}$，此时显然仅考虑只经过结点$x_{k+1}$一次的情形，因为如果经过两次$x_{k+1}$则必然形成一个回路，将该回路删除即可。将该链路分成如下两段，即：从结点$x_{i}$到结点$x_{k+1}$，以及从结点$x_{k+1}$到结点$x_{j}$。故有$M_{k}[i,k+1]{=}1$ 且$M_{k}[k+1,j]{=}1$。  
综上所述，可由下列公式从$M_{k}$计算出$M_{k+1}$
$$
M_{k+1}[i,j]=M_{k}[i,j]\vee M_{k}[i,k+1]\wedge M_{k}[k+1,j]\quad\text{(5-19)}
$$
具体地说，对于$k=0,1,2,\cdots,n-1$，从$M_{k}$构造$M_{k+1}$的具体过程如下：  
(1)$ M_{k}[i,j]=s_{i j},\,\,\,M_{k+1}[i,j]=t_{i j}$  
（2）将$M_{k}$中的所有值为1 元素复制到$M_{k+1}$中相应位置，即若$s_{i j}=1$，则$t_{i j}=1$  ;  
（3）对于所有$i,j=1,2,\cdots,n$，若$t_{i j}=0$，则当$s_{i k+1}=s_{k+1j}=1$时，令$t_{i j}=1$ 。",传递闭包构造定理定义了传递闭包的构造方法，即t(R) = R ∪ R² ∪ R³ ∪ ...，并提供了关系矩阵的计算方法Mₜ = M ∨ M² ∨ M³ ∨ ...
传递闭包,应用,沃舍尔算法,,"自反闭包和对称闭包的构造比较简单，一般通过枚举的方法就可以得到解决。然而，传递闭包的构造比自反闭包和对称闭包要困难一些，需要一些技巧。因此，本小节对传递闭包概念做进一步深入理解并由此给出传递闭包构造方法和技巧。  
假设𝐴是任一给定的有限非空集合，$R$ 是$A$ 上的一个二元关系，$t(R)$是$R$ 的传递闭包，显然有${\boldsymbol{R}}\subseteq\ t({\boldsymbol{R}})$。现对于任意$\langle x,z\rangle\in R^{2}$或$\langle x,z\rangle\in R\circ R$，由$R\circ R$的定义知必存在$A$ 中某个元素$y$，使得$\langle x,y\rangle\in R$且$\langle y,z\rangle\in R$，那么根据关系$t(R)$的传递性，必有$\langle x,z\rangle\in t(R)$。故有：$R^{2}\subseteq\ t(R)$，即$R^{2}$也是$t(R)$的一个子集合。  
类似地，对于任意$\langle x,z\rangle\in R^{3}$或$\langle x,z\rangle\in R^{2}\circ R$，则必存在$A$ 中某元素$y$，使得$\langle x,y\rangle\in R^{2}$且$\langle y,z\rangle\in R$，从而有$\langle x,z\rangle\in t(R)$，故有$R^{3}\subseteq\ t(R)$。以此类推，可知，对于任意自然数$k$，必有$R^{k}\subseteq\ t(R)$。故有：
$$
R\ \cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots\subseteq\ t(R)\quad\text{(5-15)}
$$
根据传递闭包$t(R)$的定义，$t(R)$是包含$ R$的传递性关系中最小的集合，要证明：
$$
t(R)\ \,\subseteq\,R\,\cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots
$$
只需证明 $R\ \cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots$ 满足传递性即可。任取两个序偶 $\langle x,y\rangle$ 和 $\langle y,z\rangle$ ，满足：
$$
\langle x,y\rangle\in R\ \cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots;\ \ \langle y,z\rangle\in R\ \cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots
$$
则分别存在自然数$t,s$，使得$\langle x,y\rangle\in R^{t}$且$\langle y,z\rangle\in R^{s}$，则根据关系复合运算的定义，有：$\langle x,z\rangle\in R^{t}\circ R^{s}$，即有：$\langle x,z\rangle\in R^{t+s}$。故有：$\langle x,z\rangle\in\!\!R\,\cup\!R^{2}\cup\!R^{3}\cup\cdots\cup\!R^{k}\cup\cdots_{\circ}$。即有：
$$
t(R)\ \,\subseteq\,R\,\cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots\quad\text{(5-16)}
$$
经过以上分析，可得到如果关于传递闭包构造定理：  
【定理5.13】设$R$ 是非空集合$A$ 上的关系，$t(R)$是$R$ 的传递闭包，$M$和$M_{t}$分别为$R$ 和$t(R)$的关系矩阵，则有：
$$
t(R)=\,R\,\cup R^{2}\cup R^{3}\cup\cdots\quad\text{(5-17)}
$$  
$$
M_{t}=M\lor M^{2}\lor M^{3}\lor\cdots\quad\text{(5-18)}
$$  
通过前面的例题可以看出，使用集合运算法计算传递闭包比较繁琐晦涩，非常容易出错，使用矩阵计算则涉及计算量很大的方幂计算。为了更加方便地构造关系的传递闭包，下面介绍一个比较高效传递闭包构造算法，即著名的沃舍尔算法。  
假设$R$ 是非空集合$A$ 上的二元关系，$t(R)$是$R$ 的传递闭包，$G$ 是$R$ 的关系图。从前面分析可知，在传递闭包$t(R)$的关系图中，若从结点$x$到结点$y$有一条边，当且仅当在$R$的关系图$G$ 中存在一条从结点$x$到结点$y$且边数大于或等于1 的链路，即在图$G$ 可以从结点$x$连通到结点$y$。因此，关于$R$的传递闭包$t(R)$实际上就是$R$的关系图$G$ 的连通关系$R^{*}$，即有：  
$R^{*}=\{\langle x,y\rangle|$在图$G$中存在一条从结点结点$x$到结点𝑦有向链路}  
现考虑 $n+1$ 个矩阵序列 $M_{0},M_{1},\cdots,M_{n}$ ，将矩阵 ${M}_{k}$ 的第 $𝑖 $行第$ 𝑗 $列的元素记为 $M_{k}[i,j]$ 。对 于$k=0,1,\cdots n$，$M_{k}[i,j]=1$当且仅当在$R$的关系图$G$ 中存在一条结点$x_{i}$到结点$x_{j}$的一条链路，并且这条链路除两个端点之外的中间结点只能经过集合$\{x_{1},x_{2},\cdots,x_{k}\}$中的结点。显然，$M_{0}$就是$R$ 的关系矩阵，而$M_{n}$就是$R$ 的传递闭包$t(R)$的关系矩阵。沃舍尔算法的核心思想就是采用递推的方法从$M_{0}$逐步计算出$M_{n}$，据此给出$t(R)$的高效构造算法。  
假设$M_{k}$已经计算完成，那么如何从$M_{k}$计算出$M_{k+1}$呢？所谓计算出$M_{k+1}$，其实就是对每组$i,j$，确定$M_{k+1}[i,j]$是否为1。根据$M_{k+1}$的定义，$M_{k+1}[i,j]=1$当且仅当在$R$的关系图$G$中存在一条结点$x_{i}$到结点$x_{j}$的一条链路，并且这条链路除两个端点之外的中间结点只能经过集合$\{x_{1},x_{2},\cdots,x_{k},x_{k+1}\}$中的结点。这种链路只有两种可能性：  
第一种是只经过$\{x_{1},x_{2},\cdots,x_{k}\}$中的结点，此时$M_{k}[i,j]=1$  
第二种可能是链路经过了结点$x_{k+1}$，此时显然仅考虑只经过结点$x_{k+1}$一次的情形，因为如果经过两次$x_{k+1}$则必然形成一个回路，将该回路删除即可。将该链路分成如下两段，即：从结点$x_{i}$到结点$x_{k+1}$，以及从结点$x_{k+1}$到结点$x_{j}$。故有$M_{k}[i,k+1]{=}1$ 且$M_{k}[k+1,j]{=}1$。  
综上所述，可由下列公式从$M_{k}$计算出$M_{k+1}$
$$
M_{k+1}[i,j]=M_{k}[i,j]\vee M_{k}[i,k+1]\wedge M_{k}[k+1,j]\quad\text{(5-19)}
$$
具体地说，对于$k=0,1,2,\cdots,n-1$，从$M_{k}$构造$M_{k+1}$的具体过程如下：  
(1)$ M_{k}[i,j]=s_{i j},\,\,\,M_{k+1}[i,j]=t_{i j}$  
（2）将$M_{k}$中的所有值为1 元素复制到$M_{k+1}$中相应位置，即若$s_{i j}=1$，则$t_{i j}=1$  ;  
（3）对于所有$i,j=1,2,\cdots,n$，若$t_{i j}=0$，则当$s_{i k+1}=s_{k+1j}=1$时，令$t_{i j}=1$ 。",沃舍尔算法是一种高效构造传递闭包的算法，通过递推方法从关系矩阵M₀逐步计算出传递闭包的关系矩阵Mₙ
传递闭包构造定理,实现,沃舍尔算法,,"自反闭包和对称闭包的构造比较简单，一般通过枚举的方法就可以得到解决。然而，传递闭包的构造比自反闭包和对称闭包要困难一些，需要一些技巧。因此，本小节对传递闭包概念做进一步深入理解并由此给出传递闭包构造方法和技巧。  
假设𝐴是任一给定的有限非空集合，$R$ 是$A$ 上的一个二元关系，$t(R)$是$R$ 的传递闭包，显然有${\boldsymbol{R}}\subseteq\ t({\boldsymbol{R}})$。现对于任意$\langle x,z\rangle\in R^{2}$或$\langle x,z\rangle\in R\circ R$，由$R\circ R$的定义知必存在$A$ 中某个元素$y$，使得$\langle x,y\rangle\in R$且$\langle y,z\rangle\in R$，那么根据关系$t(R)$的传递性，必有$\langle x,z\rangle\in t(R)$。故有：$R^{2}\subseteq\ t(R)$，即$R^{2}$也是$t(R)$的一个子集合。  
类似地，对于任意$\langle x,z\rangle\in R^{3}$或$\langle x,z\rangle\in R^{2}\circ R$，则必存在$A$ 中某元素$y$，使得$\langle x,y\rangle\in R^{2}$且$\langle y,z\rangle\in R$，从而有$\langle x,z\rangle\in t(R)$，故有$R^{3}\subseteq\ t(R)$。以此类推，可知，对于任意自然数$k$，必有$R^{k}\subseteq\ t(R)$。故有：
$$
R\ \cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots\subseteq\ t(R)\quad\text{(5-15)}
$$
根据传递闭包$t(R)$的定义，$t(R)$是包含$ R$的传递性关系中最小的集合，要证明：
$$
t(R)\ \,\subseteq\,R\,\cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots
$$
只需证明 $R\ \cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots$ 满足传递性即可。任取两个序偶 $\langle x,y\rangle$ 和 $\langle y,z\rangle$ ，满足：
$$
\langle x,y\rangle\in R\ \cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots;\ \ \langle y,z\rangle\in R\ \cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots
$$
则分别存在自然数$t,s$，使得$\langle x,y\rangle\in R^{t}$且$\langle y,z\rangle\in R^{s}$，则根据关系复合运算的定义，有：$\langle x,z\rangle\in R^{t}\circ R^{s}$，即有：$\langle x,z\rangle\in R^{t+s}$。故有：$\langle x,z\rangle\in\!\!R\,\cup\!R^{2}\cup\!R^{3}\cup\cdots\cup\!R^{k}\cup\cdots_{\circ}$。即有：
$$
t(R)\ \,\subseteq\,R\,\cup R^{2}\cup R^{3}\cup\cdots\cup R^{k}\cup\cdots\quad\text{(5-16)}
$$
经过以上分析，可得到如果关于传递闭包构造定理：  
【定理5.13】设$R$ 是非空集合$A$ 上的关系，$t(R)$是$R$ 的传递闭包，$M$和$M_{t}$分别为$R$ 和$t(R)$的关系矩阵，则有：
$$
t(R)=\,R\,\cup R^{2}\cup R^{3}\cup\cdots\quad\text{(5-17)}
$$  
$$
M_{t}=M\lor M^{2}\lor M^{3}\lor\cdots\quad\text{(5-18)}
$$  
通过前面的例题可以看出，使用集合运算法计算传递闭包比较繁琐晦涩，非常容易出错，使用矩阵计算则涉及计算量很大的方幂计算。为了更加方便地构造关系的传递闭包，下面介绍一个比较高效传递闭包构造算法，即著名的沃舍尔算法。  
假设$R$ 是非空集合$A$ 上的二元关系，$t(R)$是$R$ 的传递闭包，$G$ 是$R$ 的关系图。从前面分析可知，在传递闭包$t(R)$的关系图中，若从结点$x$到结点$y$有一条边，当且仅当在$R$的关系图$G$ 中存在一条从结点$x$到结点$y$且边数大于或等于1 的链路，即在图$G$ 可以从结点$x$连通到结点$y$。因此，关于$R$的传递闭包$t(R)$实际上就是$R$的关系图$G$ 的连通关系$R^{*}$，即有：  
$R^{*}=\{\langle x,y\rangle|$在图$G$中存在一条从结点结点$x$到结点𝑦有向链路}  
现考虑 $n+1$ 个矩阵序列 $M_{0},M_{1},\cdots,M_{n}$ ，将矩阵 ${M}_{k}$ 的第 $𝑖 $行第$ 𝑗 $列的元素记为 $M_{k}[i,j]$ 。对 于$k=0,1,\cdots n$，$M_{k}[i,j]=1$当且仅当在$R$的关系图$G$ 中存在一条结点$x_{i}$到结点$x_{j}$的一条链路，并且这条链路除两个端点之外的中间结点只能经过集合$\{x_{1},x_{2},\cdots,x_{k}\}$中的结点。显然，$M_{0}$就是$R$ 的关系矩阵，而$M_{n}$就是$R$ 的传递闭包$t(R)$的关系矩阵。沃舍尔算法的核心思想就是采用递推的方法从$M_{0}$逐步计算出$M_{n}$，据此给出$t(R)$的高效构造算法。  
假设$M_{k}$已经计算完成，那么如何从$M_{k}$计算出$M_{k+1}$呢？所谓计算出$M_{k+1}$，其实就是对每组$i,j$，确定$M_{k+1}[i,j]$是否为1。根据$M_{k+1}$的定义，$M_{k+1}[i,j]=1$当且仅当在$R$的关系图$G$中存在一条结点$x_{i}$到结点$x_{j}$的一条链路，并且这条链路除两个端点之外的中间结点只能经过集合$\{x_{1},x_{2},\cdots,x_{k},x_{k+1}\}$中的结点。这种链路只有两种可能性：  
第一种是只经过$\{x_{1},x_{2},\cdots,x_{k}\}$中的结点，此时$M_{k}[i,j]=1$  
第二种可能是链路经过了结点$x_{k+1}$，此时显然仅考虑只经过结点$x_{k+1}$一次的情形，因为如果经过两次$x_{k+1}$则必然形成一个回路，将该回路删除即可。将该链路分成如下两段，即：从结点$x_{i}$到结点$x_{k+1}$，以及从结点$x_{k+1}$到结点$x_{j}$。故有$M_{k}[i,k+1]{=}1$ 且$M_{k}[k+1,j]{=}1$。  
综上所述，可由下列公式从$M_{k}$计算出$M_{k+1}$
$$
M_{k+1}[i,j]=M_{k}[i,j]\vee M_{k}[i,k+1]\wedge M_{k}[k+1,j]\quad\text{(5-19)}
$$
具体地说，对于$k=0,1,2,\cdots,n-1$，从$M_{k}$构造$M_{k+1}$的具体过程如下：  
(1)$ M_{k}[i,j]=s_{i j},\,\,\,M_{k+1}[i,j]=t_{i j}$  
（2）将$M_{k}$中的所有值为1 元素复制到$M_{k+1}$中相应位置，即若$s_{i j}=1$，则$t_{i j}=1$  ;  
（3）对于所有$i,j=1,2,\cdots,n$，若$t_{i j}=0$，则当$s_{i k+1}=s_{k+1j}=1$时，令$t_{i j}=1$ 。",沃舍尔算法实现了传递闭包构造定理中传递闭包的高效计算，通过矩阵递推方法具体构造传递闭包
关系闭包的性质,包含,自反性,,"下面讨论关系闭包的一些基本性质：  
【定理5.14】若$R$ 是$A$ 上二元关系，则有：  
（1）$R$ 是自反的，当且仅当$r(R)=R$  
（2）$R$ 是对称的，当且仅当$s(R)=R$；  
（3）$R$ 是传递的，当且仅当$t(R)=R$。  
【定理5.15】若$R$ 是$A$ 上二元关系，则有：  
（1）$R$ 是自反的，则$s(R)$和$t(R)$也是自反的；  
（2）$R$ 是对称的，则$r(R)$和$t(R)$也是对称的；  
（3）$R$ 是传递的，则$r(R)$也是传递的。  
说明：上述定理讨论了关系性质和闭包运算之间的联系；  
（1）如果关系$R$ 是具有自反性，那么经过闭包运算之后得到的关系仍然具有自反性；  
（2）如果关系$R$ 是具有对称性，那么经过闭包运算之后得到的关系仍然具有对称性；  
（3）但是对于具有传递性的关系不是如此，其自反闭包仍然具有传递性，而其对称闭包则不一一定具有传递性。例如，假设$A=\{1,\!2,\!3\}$, 则$R=\{\langle1,\!2\rangle\}$是𝐴上的传递关系，此时有$s(R)=\{\langle1,\!2\rangle,\langle2,\!1\rangle\}$。显然$s(R)$不具有传递性。  
下面定理给出了关系的闭包与集合运算之间的关系：  
【定理5.16】设$A$ 是一个非空有限集合，$R$和$𝑆$均为$A$ 上二元关系，则有：  
(1）若 $R\subseteq S$ ，则有： $r(R)\subseteq r(S);\,\,\,s(R)\subseteq s(S);\,\,\,t(R)\subseteq t(S)$ 。   (2)$r(R\cup S)=r(R)\cup r(S);\quad s(R\cup S)=s(R)\cup s(S);\quad t(R)\cup t(S)\subseteq t(R\cup S)\,。$  
对于非空集合$A$ 上的二元关系$𝑅$，由于其自反闭包$r(R)$、对称闭包$s(R)$和传递闭包$t(R)$仍然是$A$ 上的二元关系，因此可以对这些闭包进一步做不同的闭包，例如在自反闭包$r(R)$的基础上再做对称闭包或传递闭包、在对称闭包$s(R)$的基础上再做自反包或传递闭包、在传递闭包$t(R)$的基础上再做自反包或对称闭包等，由此可以得到多重闭包。下面定理给出了关于这些多重闭包的基本性质：  
【定理5.17】设$A$ 是一个含有${n}$个元素的非空集合，$R$ 是$A$ 上二元关系，则有： $(1)r s(R)=s r(R);~~~(2)r t(R)=t r(R);~~(3)~s t(R)\subseteq t s(R)$",关系闭包的性质包括自反性，即若关系R是自反的，则其闭包运算后的关系仍具有自反性
关系闭包的性质,包含,对称性,,"下面讨论关系闭包的一些基本性质：  
【定理5.14】若$R$ 是$A$ 上二元关系，则有：  
（1）$R$ 是自反的，当且仅当$r(R)=R$  
（2）$R$ 是对称的，当且仅当$s(R)=R$；  
（3）$R$ 是传递的，当且仅当$t(R)=R$。  
【定理5.15】若$R$ 是$A$ 上二元关系，则有：  
（1）$R$ 是自反的，则$s(R)$和$t(R)$也是自反的；  
（2）$R$ 是对称的，则$r(R)$和$t(R)$也是对称的；  
（3）$R$ 是传递的，则$r(R)$也是传递的。  
说明：上述定理讨论了关系性质和闭包运算之间的联系；  
（1）如果关系$R$ 是具有自反性，那么经过闭包运算之后得到的关系仍然具有自反性；  
（2）如果关系$R$ 是具有对称性，那么经过闭包运算之后得到的关系仍然具有对称性；  
（3）但是对于具有传递性的关系不是如此，其自反闭包仍然具有传递性，而其对称闭包则不一一定具有传递性。例如，假设$A=\{1,\!2,\!3\}$, 则$R=\{\langle1,\!2\rangle\}$是𝐴上的传递关系，此时有$s(R)=\{\langle1,\!2\rangle,\langle2,\!1\rangle\}$。显然$s(R)$不具有传递性。  
下面定理给出了关系的闭包与集合运算之间的关系：  
【定理5.16】设$A$ 是一个非空有限集合，$R$和$𝑆$均为$A$ 上二元关系，则有：  
(1）若 $R\subseteq S$ ，则有： $r(R)\subseteq r(S);\,\,\,s(R)\subseteq s(S);\,\,\,t(R)\subseteq t(S)$ 。   (2)$r(R\cup S)=r(R)\cup r(S);\quad s(R\cup S)=s(R)\cup s(S);\quad t(R)\cup t(S)\subseteq t(R\cup S)\,。$  
对于非空集合$A$ 上的二元关系$𝑅$，由于其自反闭包$r(R)$、对称闭包$s(R)$和传递闭包$t(R)$仍然是$A$ 上的二元关系，因此可以对这些闭包进一步做不同的闭包，例如在自反闭包$r(R)$的基础上再做对称闭包或传递闭包、在对称闭包$s(R)$的基础上再做自反包或传递闭包、在传递闭包$t(R)$的基础上再做自反包或对称闭包等，由此可以得到多重闭包。下面定理给出了关于这些多重闭包的基本性质：  
【定理5.17】设$A$ 是一个含有${n}$个元素的非空集合，$R$ 是$A$ 上二元关系，则有： $(1)r s(R)=s r(R);~~~(2)r t(R)=t r(R);~~(3)~s t(R)\subseteq t s(R)$",关系闭包的性质包括对称性，即若关系R是对称的，则其闭包运算后的关系仍具有对称性
关系闭包的性质,包含,传递性,,"下面讨论关系闭包的一些基本性质：  
【定理5.14】若$R$ 是$A$ 上二元关系，则有：  
（1）$R$ 是自反的，当且仅当$r(R)=R$  
（2）$R$ 是对称的，当且仅当$s(R)=R$；  
（3）$R$ 是传递的，当且仅当$t(R)=R$。  
【定理5.15】若$R$ 是$A$ 上二元关系，则有：  
（1）$R$ 是自反的，则$s(R)$和$t(R)$也是自反的；  
（2）$R$ 是对称的，则$r(R)$和$t(R)$也是对称的；  
（3）$R$ 是传递的，则$r(R)$也是传递的。  
说明：上述定理讨论了关系性质和闭包运算之间的联系；  
（1）如果关系$R$ 是具有自反性，那么经过闭包运算之后得到的关系仍然具有自反性；  
（2）如果关系$R$ 是具有对称性，那么经过闭包运算之后得到的关系仍然具有对称性；  
（3）但是对于具有传递性的关系不是如此，其自反闭包仍然具有传递性，而其对称闭包则不一一定具有传递性。例如，假设$A=\{1,\!2,\!3\}$, 则$R=\{\langle1,\!2\rangle\}$是𝐴上的传递关系，此时有$s(R)=\{\langle1,\!2\rangle,\langle2,\!1\rangle\}$。显然$s(R)$不具有传递性。  
下面定理给出了关系的闭包与集合运算之间的关系：  
【定理5.16】设$A$ 是一个非空有限集合，$R$和$𝑆$均为$A$ 上二元关系，则有：  
(1）若 $R\subseteq S$ ，则有： $r(R)\subseteq r(S);\,\,\,s(R)\subseteq s(S);\,\,\,t(R)\subseteq t(S)$ 。   (2)$r(R\cup S)=r(R)\cup r(S);\quad s(R\cup S)=s(R)\cup s(S);\quad t(R)\cup t(S)\subseteq t(R\cup S)\,。$  
对于非空集合$A$ 上的二元关系$𝑅$，由于其自反闭包$r(R)$、对称闭包$s(R)$和传递闭包$t(R)$仍然是$A$ 上的二元关系，因此可以对这些闭包进一步做不同的闭包，例如在自反闭包$r(R)$的基础上再做对称闭包或传递闭包、在对称闭包$s(R)$的基础上再做自反包或传递闭包、在传递闭包$t(R)$的基础上再做自反包或对称闭包等，由此可以得到多重闭包。下面定理给出了关于这些多重闭包的基本性质：  
【定理5.17】设$A$ 是一个含有${n}$个元素的非空集合，$R$ 是$A$ 上二元关系，则有： $(1)r s(R)=s r(R);~~~(2)r t(R)=t r(R);~~(3)~s t(R)\subseteq t s(R)$",关系闭包的性质包括传递性，但传递闭包的自反闭包仍具有传递性，而对称闭包不一定具有传递性
关系闭包的性质,关联,集合运算,,"下面讨论关系闭包的一些基本性质：  
【定理5.14】若$R$ 是$A$ 上二元关系，则有：  
（1）$R$ 是自反的，当且仅当$r(R)=R$  
（2）$R$ 是对称的，当且仅当$s(R)=R$；  
（3）$R$ 是传递的，当且仅当$t(R)=R$。  
【定理5.15】若$R$ 是$A$ 上二元关系，则有：  
（1）$R$ 是自反的，则$s(R)$和$t(R)$也是自反的；  
（2）$R$ 是对称的，则$r(R)$和$t(R)$也是对称的；  
（3）$R$ 是传递的，则$r(R)$也是传递的。  
说明：上述定理讨论了关系性质和闭包运算之间的联系；  
（1）如果关系$R$ 是具有自反性，那么经过闭包运算之后得到的关系仍然具有自反性；  
（2）如果关系$R$ 是具有对称性，那么经过闭包运算之后得到的关系仍然具有对称性；  
（3）但是对于具有传递性的关系不是如此，其自反闭包仍然具有传递性，而其对称闭包则不一一定具有传递性。例如，假设$A=\{1,\!2,\!3\}$, 则$R=\{\langle1,\!2\rangle\}$是𝐴上的传递关系，此时有$s(R)=\{\langle1,\!2\rangle,\langle2,\!1\rangle\}$。显然$s(R)$不具有传递性。  
下面定理给出了关系的闭包与集合运算之间的关系：  
【定理5.16】设$A$ 是一个非空有限集合，$R$和$𝑆$均为$A$ 上二元关系，则有：  
(1）若 $R\subseteq S$ ，则有： $r(R)\subseteq r(S);\,\,\,s(R)\subseteq s(S);\,\,\,t(R)\subseteq t(S)$ 。   (2)$r(R\cup S)=r(R)\cup r(S);\quad s(R\cup S)=s(R)\cup s(S);\quad t(R)\cup t(S)\subseteq t(R\cup S)\,。$  
对于非空集合$A$ 上的二元关系$𝑅$，由于其自反闭包$r(R)$、对称闭包$s(R)$和传递闭包$t(R)$仍然是$A$ 上的二元关系，因此可以对这些闭包进一步做不同的闭包，例如在自反闭包$r(R)$的基础上再做对称闭包或传递闭包、在对称闭包$s(R)$的基础上再做自反包或传递闭包、在传递闭包$t(R)$的基础上再做自反包或对称闭包等，由此可以得到多重闭包。下面定理给出了关于这些多重闭包的基本性质：  
【定理5.17】设$A$ 是一个含有${n}$个元素的非空集合，$R$ 是$A$ 上二元关系，则有： $(1)r s(R)=s r(R);~~~(2)r t(R)=t r(R);~~(3)~s t(R)\subseteq t s(R)$",关系闭包的性质与集合运算相关，包括闭包运算的包含关系和并集运算的性质
关系闭包的性质,包含,多重闭包,,"下面讨论关系闭包的一些基本性质：  
【定理5.14】若$R$ 是$A$ 上二元关系，则有：  
（1）$R$ 是自反的，当且仅当$r(R)=R$  
（2）$R$ 是对称的，当且仅当$s(R)=R$；  
（3）$R$ 是传递的，当且仅当$t(R)=R$。  
【定理5.15】若$R$ 是$A$ 上二元关系，则有：  
（1）$R$ 是自反的，则$s(R)$和$t(R)$也是自反的；  
（2）$R$ 是对称的，则$r(R)$和$t(R)$也是对称的；  
（3）$R$ 是传递的，则$r(R)$也是传递的。  
说明：上述定理讨论了关系性质和闭包运算之间的联系；  
（1）如果关系$R$ 是具有自反性，那么经过闭包运算之后得到的关系仍然具有自反性；  
（2）如果关系$R$ 是具有对称性，那么经过闭包运算之后得到的关系仍然具有对称性；  
（3）但是对于具有传递性的关系不是如此，其自反闭包仍然具有传递性，而其对称闭包则不一一定具有传递性。例如，假设$A=\{1,\!2,\!3\}$, 则$R=\{\langle1,\!2\rangle\}$是𝐴上的传递关系，此时有$s(R)=\{\langle1,\!2\rangle,\langle2,\!1\rangle\}$。显然$s(R)$不具有传递性。  
下面定理给出了关系的闭包与集合运算之间的关系：  
【定理5.16】设$A$ 是一个非空有限集合，$R$和$𝑆$均为$A$ 上二元关系，则有：  
(1）若 $R\subseteq S$ ，则有： $r(R)\subseteq r(S);\,\,\,s(R)\subseteq s(S);\,\,\,t(R)\subseteq t(S)$ 。   (2)$r(R\cup S)=r(R)\cup r(S);\quad s(R\cup S)=s(R)\cup s(S);\quad t(R)\cup t(S)\subseteq t(R\cup S)\,。$  
对于非空集合$A$ 上的二元关系$𝑅$，由于其自反闭包$r(R)$、对称闭包$s(R)$和传递闭包$t(R)$仍然是$A$ 上的二元关系，因此可以对这些闭包进一步做不同的闭包，例如在自反闭包$r(R)$的基础上再做对称闭包或传递闭包、在对称闭包$s(R)$的基础上再做自反包或传递闭包、在传递闭包$t(R)$的基础上再做自反包或对称闭包等，由此可以得到多重闭包。下面定理给出了关于这些多重闭包的基本性质：  
【定理5.17】设$A$ 是一个含有${n}$个元素的非空集合，$R$ 是$A$ 上二元关系，则有： $(1)r s(R)=s r(R);~~~(2)r t(R)=t r(R);~~(3)~s t(R)\subseteq t s(R)$",关系闭包的性质包括多重闭包的基本性质，如自反对称闭包和自反传递闭包的等价性及包含关系
关系代数模型,基于,关系数据模型,,在计算机中专门用于存储与管理数据的系统称为数据库管理系统，而存储与管理数据的基本特征的抽象表示称为数据模型。一般来讲，数据模型都可以用数学形式表示，常用的有图的形式、关系形式及逻辑形式等。其中基于关系代数与关系演算的关系数据模型是计算机科学的重大理论成果，它对数据库的发展起着关键性与基础性的作用。关系代数模型运用了关系及关系运算，实现数据库中数据结构的描述，数据操作、操作优化及规范化的表示；关系演算模型运用了谓词逻辑理论，以实现数据库中数据结构的表示、数据操作及查询优化，并通过谓词推理获取查询结果。由关系代数而建立起了关系数据库，由关系演算而建立起了知识库与演绎数据库，开创了数据库学科研究的重大方向。几十年来，基于关系数据模型的关系型数据库系统一直是主流数据库系统。,关系数据模型是基于关系代数模型的关系形式
关系演算模型,基于,关系数据模型,,在计算机中专门用于存储与管理数据的系统称为数据库管理系统，而存储与管理数据的基本特征的抽象表示称为数据模型。一般来讲，数据模型都可以用数学形式表示，常用的有图的形式、关系形式及逻辑形式等。其中基于关系代数与关系演算的关系数据模型是计算机科学的重大理论成果，它对数据库的发展起着关键性与基础性的作用。关系代数模型运用了关系及关系运算，实现数据库中数据结构的描述，数据操作、操作优化及规范化的表示；关系演算模型运用了谓词逻辑理论，以实现数据库中数据结构的表示、数据操作及查询优化，并通过谓词推理获取查询结果。由关系代数而建立起了关系数据库，由关系演算而建立起了知识库与演绎数据库，开创了数据库学科研究的重大方向。几十年来，基于关系数据模型的关系型数据库系统一直是主流数据库系统。,关系数据模型是基于关系演算模型的关系形式
关系代数模型,并列,关系演算模型,,在计算机中专门用于存储与管理数据的系统称为数据库管理系统，而存储与管理数据的基本特征的抽象表示称为数据模型。一般来讲，数据模型都可以用数学形式表示，常用的有图的形式、关系形式及逻辑形式等。其中基于关系代数与关系演算的关系数据模型是计算机科学的重大理论成果，它对数据库的发展起着关键性与基础性的作用。关系代数模型运用了关系及关系运算，实现数据库中数据结构的描述，数据操作、操作优化及规范化的表示；关系演算模型运用了谓词逻辑理论，以实现数据库中数据结构的表示、数据操作及查询优化，并通过谓词推理获取查询结果。由关系代数而建立起了关系数据库，由关系演算而建立起了知识库与演绎数据库，开创了数据库学科研究的重大方向。几十年来，基于关系数据模型的关系型数据库系统一直是主流数据库系统。,关系代数模型和关系演算模型都是关系数据模型的基础
关系代数模型,理论基础,关系数据模型,,"关系代数模型由IBM 公司E.F.Codd 于1970 年提出，并最终于1976 年研制出具有实用价值的关系模型数据库系统system R。此项成果首次实现了以理论带动系统的重要突破，从此以后关系模型数据库系统是数据库中最具优势的数据模型。  
关系数据模型是一种以二维表的方式表示数据的多元关系结构以及相关的关系操作。二维表又称表，它由表框架及表元组两部分组成。表框架由表名及若干个命名属性列构成。表中每行数据称为元组。元组由若干个分量组成，其每个分量对应表框架中的一个属性值，一个表框架可以储存若干个元组，它们构成了一个完整的二维表。例如，表5-2 和表5-3 分别为4 元关系𝑅和𝑆的二维表。  
表5-2 关系𝑅的二维表  
![](images/1bedfc7c88000b4cf5a1542d888887ac793b5a954f111138c9a373b25e404611.jpg)  
表5-3 关系S的二维表
![](images/1a8eb6a738768389cb850c5f08a9fb36d42702a5e326c1cc16a02917285ec49a.jpg)  
建立在二维表上的数据操作，包括查询、删除、插入及修改等操作。查询操作可分解成三个定位与一个操作，即表的列指定、表的行选择、两张表的合并、选择操作。删除操作的基本操作单位是元组，其功能是将指定表内的指定元组删除。它也分为定位与操作两部分，其中定位部分即是行选择，定位后即执行删除操作。插入操作的功能是在指定表中插入一至多个元组。入操作无须定位，仅对指定表执行（插入）操作即可。改操作是在表中修改指定元组的数据.它可以分解为两个操作，即先进行删除操作再进行插入操作。  
由以上分析可知，关系数据模型中的基本操作共有六种，三种定位操作与三种执行操作，即：表的列指定、表的行选择、两表的合并、选择操作、删除操作、插入操作。二维表上的六种基本操作可对应关系的五种运算，因为选择操作不涉及逻辑运算，可在关系代数中忽略。其中一些操作可以关系的集合运算与复合运算实现。具体地说：二维表的数据操作插入可用关系集合并运算实现、数据删除操作可用关系集合差运算实现、两表合并可用关系集合的笛卡尔积运算实现、多表查询运算可用关系的复合运算实现。  
例如，若将表所示关系𝑅插入表所示关系𝑆的全部数据，则如表5-4 所示，使用关系的集合并运算即可完成该项操作。  
![](images/e8307e7e667a7c55af17e1fb2237de2afa5ae8d2f96c1f87db8ab79373e5f29a.jpg)
表5-4 关系表中数据插入操作  
再如，表5-5 和5-6 为某计算机学院的课程信息表，其中Cno、Cname、Cpno、Ccredit分别表示课程编号、名称、先修课程编号和学分。若要查询表中每门课程的先修课程的先修课程，则可通过对该表所示关系进行复合运算得到表5-7。  
表5-5 课程信息表           表5-6 课程信息表               表5-7 关系表的复合  
![](images/583cda9271250a95bd1e8b2bda00f43e42da09a7fd406c4096803ced0e575304.jpg)  
关系代数在数据库系统中具体应用可参阅数据库专业教材，不再赘述。",关系代数模型为关系数据模型提供了理论基础，关系数据模型中的基本操作可以通过关系代数的集合运算与复合运算实现
关系演算模型,引入,谓词,,"关系演算作为一种数学模型也产生于二十世纪70 年代，该模型以关系理论为基础并在关系理论中引入谓词推理机制，将推理与查询融为一体，从而实现关系数据库与知识库的一体化，主要用于对操作的优化，有效提高查询效率。目前，在大数据环境下，希望能够从海量数据中总结或发现一些有价值的规律或知识，这就是一直比较热门的大数据知识发现或者数据挖掘的研究课题。关系演算作为一个具备谓词推理机制的数据模型，能够的完成知识表示与推理，实现关系数据库系统与知识库系统有效整合。因此，关系演算无论在理论还是在应用方面都具有非常重要的价值。  
对于任意给定的一个二维表，可用一个多元谓词对其进行表示。其中谓词中个体变元即是表的属性，而表中的元组就是使该谓词为真的赋值，不在表中元组则是使该谓词为假的赋值。例如，对于表5-8 所示的学生基本信息表，其中表中属性sno、sn、sd、 sa 分别表示学生对象的学号、姓名、系别和年龄信息。可用谓词S（sno，sn，sd，sa）对该表进行表示，表中元组（07001，张曼英，CS，19）、（07002，丁一明，CS，20）、（07003，王爱国，CS，18）、（07004，李强，CS，18）是该谓词公式全部成真赋值，也就是说不在表中的元组均为该谓词成假赋值。  
表5-8 学生基本信息表
![](images/6776047d5bf30473704fe88f7b291d196fd0ffae2639cdc0fd808869c2e3b6f4.jpg)  
可用谓词公司演算实现关系表的数据操作。具体地说，可用谓词公式的析取运算实现关系表中数据的插入操作、谓词公式的合取运算实现关系表中数据的删除操作、可用谓词公式的推理实现查询操作的优化，等等。例如，若需在表中插入数据（07005，史今强，MA，21），则首先需构建一个新谓词$S^{\prime}$(sno，sn，sd，sa)，该谓词成真赋值为需插入元组，然后通过谓词公式的析取运算实现对数据（07005，史今强，MA，21）的插入操作：
$$
S\big(\mathrm{{sno},\ \ s n,\ \ s d,\ \ s a}\big)\vee S^{\prime}(\mathrm{{sno},\ \ s n,\ \ s d,\ \ s a})
$$
若需在表中删除元组（07001 ，张曼英，CS，19 ），则首先需构建一个新谓词S′(sno，sn，sd，sa)，该谓词成真赋值为需删除元组，通过谓词公式的合取运算实现对数据（07001，张曼英，CS，19）的插入操作：
$$
\mathrm{S}\big(\mathrm{sno},\ \mathrm{sn},\ \mathrm{sd},\ \mathrm{sa}\big)\wedge\neg S^{\prime}(\mathrm{sno},\ \mathrm{sn},\ \mathrm{sd},\ \mathrm{sa})
$$
若需在表中查询年龄大于18 岁的学生姓名，则可用如下谓词蕴涵式实现：
$$
\exists\mathrm{sno}\exists\mathrm{sd}\exists\mathrm{sa}(\mathrm{S}\big(\mathrm{sno},~\mathrm{sn},~\mathrm{sd},~\mathrm{sa}\big)\land(\mathrm{sa}>18))\rightarrow\mathrm{S}^{\prime}(\mathrm{sn})
$$
其中前件表示查询操作要求，后件$S^{\prime}(\mathrm{sn})$则表示查询结果。关系演算在数据库及知识库系统中具体应用可参阅数据库专业教材，不再赘述。",关系演算模型引入谓词推理机制，实现推理与查询的融合
关系演算模型,应用,谓词公式,,"关系演算作为一种数学模型也产生于二十世纪70 年代，该模型以关系理论为基础并在关系理论中引入谓词推理机制，将推理与查询融为一体，从而实现关系数据库与知识库的一体化，主要用于对操作的优化，有效提高查询效率。目前，在大数据环境下，希望能够从海量数据中总结或发现一些有价值的规律或知识，这就是一直比较热门的大数据知识发现或者数据挖掘的研究课题。关系演算作为一个具备谓词推理机制的数据模型，能够的完成知识表示与推理，实现关系数据库系统与知识库系统有效整合。因此，关系演算无论在理论还是在应用方面都具有非常重要的价值。  
对于任意给定的一个二维表，可用一个多元谓词对其进行表示。其中谓词中个体变元即是表的属性，而表中的元组就是使该谓词为真的赋值，不在表中元组则是使该谓词为假的赋值。例如，对于表5-8 所示的学生基本信息表，其中表中属性sno、sn、sd、 sa 分别表示学生对象的学号、姓名、系别和年龄信息。可用谓词S（sno，sn，sd，sa）对该表进行表示，表中元组（07001，张曼英，CS，19）、（07002，丁一明，CS，20）、（07003，王爱国，CS，18）、（07004，李强，CS，18）是该谓词公式全部成真赋值，也就是说不在表中的元组均为该谓词成假赋值。  
表5-8 学生基本信息表
![](images/6776047d5bf30473704fe88f7b291d196fd0ffae2639cdc0fd808869c2e3b6f4.jpg)  
可用谓词公司演算实现关系表的数据操作。具体地说，可用谓词公式的析取运算实现关系表中数据的插入操作、谓词公式的合取运算实现关系表中数据的删除操作、可用谓词公式的推理实现查询操作的优化，等等。例如，若需在表中插入数据（07005，史今强，MA，21），则首先需构建一个新谓词$S^{\prime}$(sno，sn，sd，sa)，该谓词成真赋值为需插入元组，然后通过谓词公式的析取运算实现对数据（07005，史今强，MA，21）的插入操作：
$$
S\big(\mathrm{{sno},\ \ s n,\ \ s d,\ \ s a}\big)\vee S^{\prime}(\mathrm{{sno},\ \ s n,\ \ s d,\ \ s a})
$$
若需在表中删除元组（07001 ，张曼英，CS，19 ），则首先需构建一个新谓词S′(sno，sn，sd，sa)，该谓词成真赋值为需删除元组，通过谓词公式的合取运算实现对数据（07001，张曼英，CS，19）的插入操作：
$$
\mathrm{S}\big(\mathrm{sno},\ \mathrm{sn},\ \mathrm{sd},\ \mathrm{sa}\big)\wedge\neg S^{\prime}(\mathrm{sno},\ \mathrm{sn},\ \mathrm{sd},\ \mathrm{sa})
$$
若需在表中查询年龄大于18 岁的学生姓名，则可用如下谓词蕴涵式实现：
$$
\exists\mathrm{sno}\exists\mathrm{sd}\exists\mathrm{sa}(\mathrm{S}\big(\mathrm{sno},~\mathrm{sn},~\mathrm{sd},~\mathrm{sa}\big)\land(\mathrm{sa}>18))\rightarrow\mathrm{S}^{\prime}(\mathrm{sn})
$$
其中前件表示查询操作要求，后件$S^{\prime}(\mathrm{sn})$则表示查询结果。关系演算在数据库及知识库系统中具体应用可参阅数据库专业教材，不再赘述。",关系演算模型使用谓词公式进行数据操作，如插入、删除和查询优化
谓词,构成,谓词公式,,"关系演算作为一种数学模型也产生于二十世纪70 年代，该模型以关系理论为基础并在关系理论中引入谓词推理机制，将推理与查询融为一体，从而实现关系数据库与知识库的一体化，主要用于对操作的优化，有效提高查询效率。目前，在大数据环境下，希望能够从海量数据中总结或发现一些有价值的规律或知识，这就是一直比较热门的大数据知识发现或者数据挖掘的研究课题。关系演算作为一个具备谓词推理机制的数据模型，能够的完成知识表示与推理，实现关系数据库系统与知识库系统有效整合。因此，关系演算无论在理论还是在应用方面都具有非常重要的价值。  
对于任意给定的一个二维表，可用一个多元谓词对其进行表示。其中谓词中个体变元即是表的属性，而表中的元组就是使该谓词为真的赋值，不在表中元组则是使该谓词为假的赋值。例如，对于表5-8 所示的学生基本信息表，其中表中属性sno、sn、sd、 sa 分别表示学生对象的学号、姓名、系别和年龄信息。可用谓词S（sno，sn，sd，sa）对该表进行表示，表中元组（07001，张曼英，CS，19）、（07002，丁一明，CS，20）、（07003，王爱国，CS，18）、（07004，李强，CS，18）是该谓词公式全部成真赋值，也就是说不在表中的元组均为该谓词成假赋值。  
表5-8 学生基本信息表
![](images/6776047d5bf30473704fe88f7b291d196fd0ffae2639cdc0fd808869c2e3b6f4.jpg)  
可用谓词公司演算实现关系表的数据操作。具体地说，可用谓词公式的析取运算实现关系表中数据的插入操作、谓词公式的合取运算实现关系表中数据的删除操作、可用谓词公式的推理实现查询操作的优化，等等。例如，若需在表中插入数据（07005，史今强，MA，21），则首先需构建一个新谓词$S^{\prime}$(sno，sn，sd，sa)，该谓词成真赋值为需插入元组，然后通过谓词公式的析取运算实现对数据（07005，史今强，MA，21）的插入操作：
$$
S\big(\mathrm{{sno},\ \ s n,\ \ s d,\ \ s a}\big)\vee S^{\prime}(\mathrm{{sno},\ \ s n,\ \ s d,\ \ s a})
$$
若需在表中删除元组（07001 ，张曼英，CS，19 ），则首先需构建一个新谓词S′(sno，sn，sd，sa)，该谓词成真赋值为需删除元组，通过谓词公式的合取运算实现对数据（07001，张曼英，CS，19）的插入操作：
$$
\mathrm{S}\big(\mathrm{sno},\ \mathrm{sn},\ \mathrm{sd},\ \mathrm{sa}\big)\wedge\neg S^{\prime}(\mathrm{sno},\ \mathrm{sn},\ \mathrm{sd},\ \mathrm{sa})
$$
若需在表中查询年龄大于18 岁的学生姓名，则可用如下谓词蕴涵式实现：
$$
\exists\mathrm{sno}\exists\mathrm{sd}\exists\mathrm{sa}(\mathrm{S}\big(\mathrm{sno},~\mathrm{sn},~\mathrm{sd},~\mathrm{sa}\big)\land(\mathrm{sa}>18))\rightarrow\mathrm{S}^{\prime}(\mathrm{sn})
$$
其中前件表示查询操作要求，后件$S^{\prime}(\mathrm{sn})$则表示查询结果。关系演算在数据库及知识库系统中具体应用可参阅数据库专业教材，不再赘述。",谓词是谓词公式的基本组成部分，用于表示和操作数据
等价关系模型,满足,自反性,,前面学习了关系模型的概念及其五个基本性质。不难发现，日常生活或工作中很多关系虽然从表面上看形态各异、互不相同，但都满足一些相同的基本性质。例如集合之间的相等关系、直线之间的平行关系、多边形之间的全等关系、学生同学关系、整数之间的同余关系等等，它们都满足自反性、对称性和传递性这三条基本性质。我们自然会想到把所有满足这三条性质的关系归为一类特殊关系，并考察这类关系有什么特殊性质和特殊作用，以便在大量错综复杂的具体关系中找到一些共性特征和规律性认识。同样，还有一些关系满足另外一些基本性质，例如集合之间的包含关系、整数之间的整除关系、实数之间的大小关系、英文单词之间的字典排序关系等等，这些关系虽然表面上互不相同、各不相关，但它们都满足自反性、反对称性和传递性这三条基本性质。我们自然会将所有这类关系归为另外一类特殊关系，并考察这类关系有什么相应的特殊性质和特殊作用。通过以上分析，不难得到研究关系的一个普适性方法，就是以关系模型的五个基本性质为标准，将所有关系按它们对这些基本性质满足程度和状态的不同划分为若干特殊类型，然后分门别类地研究同类型关系的共同性质和不同类型关系之间的区别与联系，由此构建各种特殊关系模型及相关理论。显然，通过状态组合构造出的特殊关系有很多，不便一一枚举。作为代表，本章着重介绍其中三种最典型、最基本的特殊关系模型，并分别讨论它们各自的作用，即等价关系模型与元素的分类、相容关系模型与元素的聚类、偏序关系模型与元素的比较。,等价关系模型满足自反性
等价关系模型,满足,对称性,,前面学习了关系模型的概念及其五个基本性质。不难发现，日常生活或工作中很多关系虽然从表面上看形态各异、互不相同，但都满足一些相同的基本性质。例如集合之间的相等关系、直线之间的平行关系、多边形之间的全等关系、学生同学关系、整数之间的同余关系等等，它们都满足自反性、对称性和传递性这三条基本性质。我们自然会想到把所有满足这三条性质的关系归为一类特殊关系，并考察这类关系有什么特殊性质和特殊作用，以便在大量错综复杂的具体关系中找到一些共性特征和规律性认识。同样，还有一些关系满足另外一些基本性质，例如集合之间的包含关系、整数之间的整除关系、实数之间的大小关系、英文单词之间的字典排序关系等等，这些关系虽然表面上互不相同、各不相关，但它们都满足自反性、反对称性和传递性这三条基本性质。我们自然会将所有这类关系归为另外一类特殊关系，并考察这类关系有什么相应的特殊性质和特殊作用。通过以上分析，不难得到研究关系的一个普适性方法，就是以关系模型的五个基本性质为标准，将所有关系按它们对这些基本性质满足程度和状态的不同划分为若干特殊类型，然后分门别类地研究同类型关系的共同性质和不同类型关系之间的区别与联系，由此构建各种特殊关系模型及相关理论。显然，通过状态组合构造出的特殊关系有很多，不便一一枚举。作为代表，本章着重介绍其中三种最典型、最基本的特殊关系模型，并分别讨论它们各自的作用，即等价关系模型与元素的分类、相容关系模型与元素的聚类、偏序关系模型与元素的比较。,等价关系模型满足对称性
等价关系模型,满足,传递性,,前面学习了关系模型的概念及其五个基本性质。不难发现，日常生活或工作中很多关系虽然从表面上看形态各异、互不相同，但都满足一些相同的基本性质。例如集合之间的相等关系、直线之间的平行关系、多边形之间的全等关系、学生同学关系、整数之间的同余关系等等，它们都满足自反性、对称性和传递性这三条基本性质。我们自然会想到把所有满足这三条性质的关系归为一类特殊关系，并考察这类关系有什么特殊性质和特殊作用，以便在大量错综复杂的具体关系中找到一些共性特征和规律性认识。同样，还有一些关系满足另外一些基本性质，例如集合之间的包含关系、整数之间的整除关系、实数之间的大小关系、英文单词之间的字典排序关系等等，这些关系虽然表面上互不相同、各不相关，但它们都满足自反性、反对称性和传递性这三条基本性质。我们自然会将所有这类关系归为另外一类特殊关系，并考察这类关系有什么相应的特殊性质和特殊作用。通过以上分析，不难得到研究关系的一个普适性方法，就是以关系模型的五个基本性质为标准，将所有关系按它们对这些基本性质满足程度和状态的不同划分为若干特殊类型，然后分门别类地研究同类型关系的共同性质和不同类型关系之间的区别与联系，由此构建各种特殊关系模型及相关理论。显然，通过状态组合构造出的特殊关系有很多，不便一一枚举。作为代表，本章着重介绍其中三种最典型、最基本的特殊关系模型，并分别讨论它们各自的作用，即等价关系模型与元素的分类、相容关系模型与元素的聚类、偏序关系模型与元素的比较。,等价关系模型满足传递性
偏序关系模型,满足,自反性,,前面学习了关系模型的概念及其五个基本性质。不难发现，日常生活或工作中很多关系虽然从表面上看形态各异、互不相同，但都满足一些相同的基本性质。例如集合之间的相等关系、直线之间的平行关系、多边形之间的全等关系、学生同学关系、整数之间的同余关系等等，它们都满足自反性、对称性和传递性这三条基本性质。我们自然会想到把所有满足这三条性质的关系归为一类特殊关系，并考察这类关系有什么特殊性质和特殊作用，以便在大量错综复杂的具体关系中找到一些共性特征和规律性认识。同样，还有一些关系满足另外一些基本性质，例如集合之间的包含关系、整数之间的整除关系、实数之间的大小关系、英文单词之间的字典排序关系等等，这些关系虽然表面上互不相同、各不相关，但它们都满足自反性、反对称性和传递性这三条基本性质。我们自然会将所有这类关系归为另外一类特殊关系，并考察这类关系有什么相应的特殊性质和特殊作用。通过以上分析，不难得到研究关系的一个普适性方法，就是以关系模型的五个基本性质为标准，将所有关系按它们对这些基本性质满足程度和状态的不同划分为若干特殊类型，然后分门别类地研究同类型关系的共同性质和不同类型关系之间的区别与联系，由此构建各种特殊关系模型及相关理论。显然，通过状态组合构造出的特殊关系有很多，不便一一枚举。作为代表，本章着重介绍其中三种最典型、最基本的特殊关系模型，并分别讨论它们各自的作用，即等价关系模型与元素的分类、相容关系模型与元素的聚类、偏序关系模型与元素的比较。,偏序关系模型满足自反性
偏序关系模型,满足,反对称性,,前面学习了关系模型的概念及其五个基本性质。不难发现，日常生活或工作中很多关系虽然从表面上看形态各异、互不相同，但都满足一些相同的基本性质。例如集合之间的相等关系、直线之间的平行关系、多边形之间的全等关系、学生同学关系、整数之间的同余关系等等，它们都满足自反性、对称性和传递性这三条基本性质。我们自然会想到把所有满足这三条性质的关系归为一类特殊关系，并考察这类关系有什么特殊性质和特殊作用，以便在大量错综复杂的具体关系中找到一些共性特征和规律性认识。同样，还有一些关系满足另外一些基本性质，例如集合之间的包含关系、整数之间的整除关系、实数之间的大小关系、英文单词之间的字典排序关系等等，这些关系虽然表面上互不相同、各不相关，但它们都满足自反性、反对称性和传递性这三条基本性质。我们自然会将所有这类关系归为另外一类特殊关系，并考察这类关系有什么相应的特殊性质和特殊作用。通过以上分析，不难得到研究关系的一个普适性方法，就是以关系模型的五个基本性质为标准，将所有关系按它们对这些基本性质满足程度和状态的不同划分为若干特殊类型，然后分门别类地研究同类型关系的共同性质和不同类型关系之间的区别与联系，由此构建各种特殊关系模型及相关理论。显然，通过状态组合构造出的特殊关系有很多，不便一一枚举。作为代表，本章着重介绍其中三种最典型、最基本的特殊关系模型，并分别讨论它们各自的作用，即等价关系模型与元素的分类、相容关系模型与元素的聚类、偏序关系模型与元素的比较。,偏序关系模型满足反对称性
偏序关系模型,满足,传递性,,前面学习了关系模型的概念及其五个基本性质。不难发现，日常生活或工作中很多关系虽然从表面上看形态各异、互不相同，但都满足一些相同的基本性质。例如集合之间的相等关系、直线之间的平行关系、多边形之间的全等关系、学生同学关系、整数之间的同余关系等等，它们都满足自反性、对称性和传递性这三条基本性质。我们自然会想到把所有满足这三条性质的关系归为一类特殊关系，并考察这类关系有什么特殊性质和特殊作用，以便在大量错综复杂的具体关系中找到一些共性特征和规律性认识。同样，还有一些关系满足另外一些基本性质，例如集合之间的包含关系、整数之间的整除关系、实数之间的大小关系、英文单词之间的字典排序关系等等，这些关系虽然表面上互不相同、各不相关，但它们都满足自反性、反对称性和传递性这三条基本性质。我们自然会将所有这类关系归为另外一类特殊关系，并考察这类关系有什么相应的特殊性质和特殊作用。通过以上分析，不难得到研究关系的一个普适性方法，就是以关系模型的五个基本性质为标准，将所有关系按它们对这些基本性质满足程度和状态的不同划分为若干特殊类型，然后分门别类地研究同类型关系的共同性质和不同类型关系之间的区别与联系，由此构建各种特殊关系模型及相关理论。显然，通过状态组合构造出的特殊关系有很多，不便一一枚举。作为代表，本章着重介绍其中三种最典型、最基本的特殊关系模型，并分别讨论它们各自的作用，即等价关系模型与元素的分类、相容关系模型与元素的聚类、偏序关系模型与元素的比较。,偏序关系模型满足传递性
特殊关系模型,基于,自反性,,前面学习了关系模型的概念及其五个基本性质。不难发现，日常生活或工作中很多关系虽然从表面上看形态各异、互不相同，但都满足一些相同的基本性质。例如集合之间的相等关系、直线之间的平行关系、多边形之间的全等关系、学生同学关系、整数之间的同余关系等等，它们都满足自反性、对称性和传递性这三条基本性质。我们自然会想到把所有满足这三条性质的关系归为一类特殊关系，并考察这类关系有什么特殊性质和特殊作用，以便在大量错综复杂的具体关系中找到一些共性特征和规律性认识。同样，还有一些关系满足另外一些基本性质，例如集合之间的包含关系、整数之间的整除关系、实数之间的大小关系、英文单词之间的字典排序关系等等，这些关系虽然表面上互不相同、各不相关，但它们都满足自反性、反对称性和传递性这三条基本性质。我们自然会将所有这类关系归为另外一类特殊关系，并考察这类关系有什么相应的特殊性质和特殊作用。通过以上分析，不难得到研究关系的一个普适性方法，就是以关系模型的五个基本性质为标准，将所有关系按它们对这些基本性质满足程度和状态的不同划分为若干特殊类型，然后分门别类地研究同类型关系的共同性质和不同类型关系之间的区别与联系，由此构建各种特殊关系模型及相关理论。显然，通过状态组合构造出的特殊关系有很多，不便一一枚举。作为代表，本章着重介绍其中三种最典型、最基本的特殊关系模型，并分别讨论它们各自的作用，即等价关系模型与元素的分类、相容关系模型与元素的聚类、偏序关系模型与元素的比较。,特殊关系模型基于自反性等基本性质构建
特殊关系模型,基于,对称性,,前面学习了关系模型的概念及其五个基本性质。不难发现，日常生活或工作中很多关系虽然从表面上看形态各异、互不相同，但都满足一些相同的基本性质。例如集合之间的相等关系、直线之间的平行关系、多边形之间的全等关系、学生同学关系、整数之间的同余关系等等，它们都满足自反性、对称性和传递性这三条基本性质。我们自然会想到把所有满足这三条性质的关系归为一类特殊关系，并考察这类关系有什么特殊性质和特殊作用，以便在大量错综复杂的具体关系中找到一些共性特征和规律性认识。同样，还有一些关系满足另外一些基本性质，例如集合之间的包含关系、整数之间的整除关系、实数之间的大小关系、英文单词之间的字典排序关系等等，这些关系虽然表面上互不相同、各不相关，但它们都满足自反性、反对称性和传递性这三条基本性质。我们自然会将所有这类关系归为另外一类特殊关系，并考察这类关系有什么相应的特殊性质和特殊作用。通过以上分析，不难得到研究关系的一个普适性方法，就是以关系模型的五个基本性质为标准，将所有关系按它们对这些基本性质满足程度和状态的不同划分为若干特殊类型，然后分门别类地研究同类型关系的共同性质和不同类型关系之间的区别与联系，由此构建各种特殊关系模型及相关理论。显然，通过状态组合构造出的特殊关系有很多，不便一一枚举。作为代表，本章着重介绍其中三种最典型、最基本的特殊关系模型，并分别讨论它们各自的作用，即等价关系模型与元素的分类、相容关系模型与元素的聚类、偏序关系模型与元素的比较。,特殊关系模型基于对称性等基本性质构建
特殊关系模型,基于,传递性,,前面学习了关系模型的概念及其五个基本性质。不难发现，日常生活或工作中很多关系虽然从表面上看形态各异、互不相同，但都满足一些相同的基本性质。例如集合之间的相等关系、直线之间的平行关系、多边形之间的全等关系、学生同学关系、整数之间的同余关系等等，它们都满足自反性、对称性和传递性这三条基本性质。我们自然会想到把所有满足这三条性质的关系归为一类特殊关系，并考察这类关系有什么特殊性质和特殊作用，以便在大量错综复杂的具体关系中找到一些共性特征和规律性认识。同样，还有一些关系满足另外一些基本性质，例如集合之间的包含关系、整数之间的整除关系、实数之间的大小关系、英文单词之间的字典排序关系等等，这些关系虽然表面上互不相同、各不相关，但它们都满足自反性、反对称性和传递性这三条基本性质。我们自然会将所有这类关系归为另外一类特殊关系，并考察这类关系有什么相应的特殊性质和特殊作用。通过以上分析，不难得到研究关系的一个普适性方法，就是以关系模型的五个基本性质为标准，将所有关系按它们对这些基本性质满足程度和状态的不同划分为若干特殊类型，然后分门别类地研究同类型关系的共同性质和不同类型关系之间的区别与联系，由此构建各种特殊关系模型及相关理论。显然，通过状态组合构造出的特殊关系有很多，不便一一枚举。作为代表，本章着重介绍其中三种最典型、最基本的特殊关系模型，并分别讨论它们各自的作用，即等价关系模型与元素的分类、相容关系模型与元素的聚类、偏序关系模型与元素的比较。,特殊关系模型基于传递性等基本性质构建
特殊关系模型,基于,反对称性,,前面学习了关系模型的概念及其五个基本性质。不难发现，日常生活或工作中很多关系虽然从表面上看形态各异、互不相同，但都满足一些相同的基本性质。例如集合之间的相等关系、直线之间的平行关系、多边形之间的全等关系、学生同学关系、整数之间的同余关系等等，它们都满足自反性、对称性和传递性这三条基本性质。我们自然会想到把所有满足这三条性质的关系归为一类特殊关系，并考察这类关系有什么特殊性质和特殊作用，以便在大量错综复杂的具体关系中找到一些共性特征和规律性认识。同样，还有一些关系满足另外一些基本性质，例如集合之间的包含关系、整数之间的整除关系、实数之间的大小关系、英文单词之间的字典排序关系等等，这些关系虽然表面上互不相同、各不相关，但它们都满足自反性、反对称性和传递性这三条基本性质。我们自然会将所有这类关系归为另外一类特殊关系，并考察这类关系有什么相应的特殊性质和特殊作用。通过以上分析，不难得到研究关系的一个普适性方法，就是以关系模型的五个基本性质为标准，将所有关系按它们对这些基本性质满足程度和状态的不同划分为若干特殊类型，然后分门别类地研究同类型关系的共同性质和不同类型关系之间的区别与联系，由此构建各种特殊关系模型及相关理论。显然，通过状态组合构造出的特殊关系有很多，不便一一枚举。作为代表，本章着重介绍其中三种最典型、最基本的特殊关系模型，并分别讨论它们各自的作用，即等价关系模型与元素的分类、相容关系模型与元素的聚类、偏序关系模型与元素的比较。,特殊关系模型基于反对称性等基本性质构建
等价关系模型,作用,元素的分类,,前面学习了关系模型的概念及其五个基本性质。不难发现，日常生活或工作中很多关系虽然从表面上看形态各异、互不相同，但都满足一些相同的基本性质。例如集合之间的相等关系、直线之间的平行关系、多边形之间的全等关系、学生同学关系、整数之间的同余关系等等，它们都满足自反性、对称性和传递性这三条基本性质。我们自然会想到把所有满足这三条性质的关系归为一类特殊关系，并考察这类关系有什么特殊性质和特殊作用，以便在大量错综复杂的具体关系中找到一些共性特征和规律性认识。同样，还有一些关系满足另外一些基本性质，例如集合之间的包含关系、整数之间的整除关系、实数之间的大小关系、英文单词之间的字典排序关系等等，这些关系虽然表面上互不相同、各不相关，但它们都满足自反性、反对称性和传递性这三条基本性质。我们自然会将所有这类关系归为另外一类特殊关系，并考察这类关系有什么相应的特殊性质和特殊作用。通过以上分析，不难得到研究关系的一个普适性方法，就是以关系模型的五个基本性质为标准，将所有关系按它们对这些基本性质满足程度和状态的不同划分为若干特殊类型，然后分门别类地研究同类型关系的共同性质和不同类型关系之间的区别与联系，由此构建各种特殊关系模型及相关理论。显然，通过状态组合构造出的特殊关系有很多，不便一一枚举。作为代表，本章着重介绍其中三种最典型、最基本的特殊关系模型，并分别讨论它们各自的作用，即等价关系模型与元素的分类、相容关系模型与元素的聚类、偏序关系模型与元素的比较。,等价关系模型用于元素的分类
相容关系模型,作用,元素的聚类,,前面学习了关系模型的概念及其五个基本性质。不难发现，日常生活或工作中很多关系虽然从表面上看形态各异、互不相同，但都满足一些相同的基本性质。例如集合之间的相等关系、直线之间的平行关系、多边形之间的全等关系、学生同学关系、整数之间的同余关系等等，它们都满足自反性、对称性和传递性这三条基本性质。我们自然会想到把所有满足这三条性质的关系归为一类特殊关系，并考察这类关系有什么特殊性质和特殊作用，以便在大量错综复杂的具体关系中找到一些共性特征和规律性认识。同样，还有一些关系满足另外一些基本性质，例如集合之间的包含关系、整数之间的整除关系、实数之间的大小关系、英文单词之间的字典排序关系等等，这些关系虽然表面上互不相同、各不相关，但它们都满足自反性、反对称性和传递性这三条基本性质。我们自然会将所有这类关系归为另外一类特殊关系，并考察这类关系有什么相应的特殊性质和特殊作用。通过以上分析，不难得到研究关系的一个普适性方法，就是以关系模型的五个基本性质为标准，将所有关系按它们对这些基本性质满足程度和状态的不同划分为若干特殊类型，然后分门别类地研究同类型关系的共同性质和不同类型关系之间的区别与联系，由此构建各种特殊关系模型及相关理论。显然，通过状态组合构造出的特殊关系有很多，不便一一枚举。作为代表，本章着重介绍其中三种最典型、最基本的特殊关系模型，并分别讨论它们各自的作用，即等价关系模型与元素的分类、相容关系模型与元素的聚类、偏序关系模型与元素的比较。,相容关系模型用于元素的聚类
偏序关系模型,作用,元素的比较,,前面学习了关系模型的概念及其五个基本性质。不难发现，日常生活或工作中很多关系虽然从表面上看形态各异、互不相同，但都满足一些相同的基本性质。例如集合之间的相等关系、直线之间的平行关系、多边形之间的全等关系、学生同学关系、整数之间的同余关系等等，它们都满足自反性、对称性和传递性这三条基本性质。我们自然会想到把所有满足这三条性质的关系归为一类特殊关系，并考察这类关系有什么特殊性质和特殊作用，以便在大量错综复杂的具体关系中找到一些共性特征和规律性认识。同样，还有一些关系满足另外一些基本性质，例如集合之间的包含关系、整数之间的整除关系、实数之间的大小关系、英文单词之间的字典排序关系等等，这些关系虽然表面上互不相同、各不相关，但它们都满足自反性、反对称性和传递性这三条基本性质。我们自然会将所有这类关系归为另外一类特殊关系，并考察这类关系有什么相应的特殊性质和特殊作用。通过以上分析，不难得到研究关系的一个普适性方法，就是以关系模型的五个基本性质为标准，将所有关系按它们对这些基本性质满足程度和状态的不同划分为若干特殊类型，然后分门别类地研究同类型关系的共同性质和不同类型关系之间的区别与联系，由此构建各种特殊关系模型及相关理论。显然，通过状态组合构造出的特殊关系有很多，不便一一枚举。作为代表，本章着重介绍其中三种最典型、最基本的特殊关系模型，并分别讨论它们各自的作用，即等价关系模型与元素的分类、相容关系模型与元素的聚类、偏序关系模型与元素的比较。,偏序关系模型用于元素的比较
等价关系,分类,等价类,,等价关系，顾名思义就是表示相同、相等、平等、一致等含义的关系，刻画的是对象之间在某个方面的无差异性。可用等价关系将集合中元素进行分类，使得属于同一类的元素彼此之间具有等价关系，而分属不同类型的元素之间不具有等价关系。属于同一类的元素因其相互之间满足等价关系而可将它们看成是一些无差异的个体，进而将这些无差异个体抽象成一个个体或代表元，由此实现对集合的化简。目前，等价关系可以有效地实现对数据的抽象和化简，已在计算机及相关信息领域得到广泛应用。本节具体介绍等价关系的基本知识，主要包括等价关系与等价类的概念和性质、集合划分与商集的相关知识。,等价关系用于将集合中元素分类，属于同一类的元素之间具有等价关系
等价类,构成,集合划分,,等价关系，顾名思义就是表示相同、相等、平等、一致等含义的关系，刻画的是对象之间在某个方面的无差异性。可用等价关系将集合中元素进行分类，使得属于同一类的元素彼此之间具有等价关系，而分属不同类型的元素之间不具有等价关系。属于同一类的元素因其相互之间满足等价关系而可将它们看成是一些无差异的个体，进而将这些无差异个体抽象成一个个体或代表元，由此实现对集合的化简。目前，等价关系可以有效地实现对数据的抽象和化简，已在计算机及相关信息领域得到广泛应用。本节具体介绍等价关系的基本知识，主要包括等价关系与等价类的概念和性质、集合划分与商集的相关知识。,等价类构成集合的划分，每个等价类是划分的一部分
集合划分,对应,商集,,等价关系，顾名思义就是表示相同、相等、平等、一致等含义的关系，刻画的是对象之间在某个方面的无差异性。可用等价关系将集合中元素进行分类，使得属于同一类的元素彼此之间具有等价关系，而分属不同类型的元素之间不具有等价关系。属于同一类的元素因其相互之间满足等价关系而可将它们看成是一些无差异的个体，进而将这些无差异个体抽象成一个个体或代表元，由此实现对集合的化简。目前，等价关系可以有效地实现对数据的抽象和化简，已在计算机及相关信息领域得到广泛应用。本节具体介绍等价关系的基本知识，主要包括等价关系与等价类的概念和性质、集合划分与商集的相关知识。,集合的划分对应于商集，商集是集合在等价关系下的划分结果
等价关系,定义,等价类,,"如前所述，集合的相等关系、直线的平行关系、多边形的全等关系、学生同学关系、整数的同余关系等等，它们都满足自反性、对称性和传递性这三条基本性质。不难看出，这些关系均是表示相同、相等、平等、一致等含义的关系。据此得到等价关系的定义：  
【定义6.1】假设𝐴是任一给定的非空集合，$R$是$𝐴$上的一个二元关系，如果$𝑅$满足自反性、对称性和传递性，则称$𝑅$是一个等价关系。此时，对于$𝐴$中任意两个元素${x}$和$y$，如果$\langle x,y\rangle\in$$R$，则称$x$与𝑦等价，记为$x{\sim}y$。  
从定义可知：关系$R$是等价关系当且仅当$𝑅$同时具备自反性、对称性和传递性；关系$𝑅$不是等价关系当且仅当$𝑅$不具备自反性或对称性或传递性。因此，等价关系的定义是判断关等价关系的一个很好判据。  
显然， 上述每个等价类其实就相当于例题 6.4  中等价关系图的每个完全子图或等价关系矩阵的每个子矩阵块。据此给出如下等价类的一般定义：  
【定义6.2】设$R$是非空集合𝐴上的等价关系，对任意$x\in A$，称下列集合：  
$$
[x]_{R}=\{y|y\in A\land\langle x,y\rangle\in R\}
$$  
为$𝑥$关于$𝑅$的等价类，或称为由$x$生成的一个$R $等价类，并称$x$称$[x]_{R}$的生成元或代表元。  
由上述定义可知等价类有以下性质：  
（1）等价类产生的前提是关系$R$必须是等价关系；  
（2）$𝐴$中所有与$$x$$有关系$𝑅$的元素$𝑦$构成了$[x]_{R}$；  
（3）$𝐴$中任意一个元素一定对应一个由其生成的等价类；  
（4）$R$具有自反性意味着对任意$x\in A$，$[x]_{R}$非空。 （5）$R$具有对称性意味着对任意$x,y\in A$，若有 $y\in[x]_{R}$，则有$x\in[y]_{R}$  
从例6.1.2 知，模3 同余关系是一个等价关系，可求出$A=\{1,\!2,\!3,\!4,\!5,\!6,\!7\}$中每个元素的$[1]_{R}=[4]_{R}=[7]_{R}=\{1,4,7\};\,\,\,[2]_{R}=[5]_{R}=\{2,5\};\,\,\,[3]_{R}=\{6\}_{\circ}$  
综合以上分析，可以看出等价类具有下性质：  
【定理6.1】设$R$是非空集合$𝐴$上的等价关系，对于任意$x,y\in A$，成立：  
（1）$\left[x\right]_{R}\neq\emptyset$且$[x]_{R}\subseteq A$；           （2）若$\langle x,y\rangle\in R$，则$[x]_{R}=[y]_{R}$；  
（3）若$\langle x,y\rangle\not\in R$，则$[x]_{R}\cap[y]_{R}=\emptyset$； （4）$\mathsf{U}_{x\in A}[x]_{R}=A\,。$  
上述定理表明，对于非空集合$𝐴$上的等价关系$R$，可用$R$的所有等价类将集合$𝐴$划分成若干个互不相交的子集合，每个子集合就是一个等价类。接下来讨论这种划分问题。",等价类是基于等价关系定义的，对于集合中的任意元素，等价类包含所有与该元素有等价关系的元素
等价关系,描述,定理6.1,,"如前所述，集合的相等关系、直线的平行关系、多边形的全等关系、学生同学关系、整数的同余关系等等，它们都满足自反性、对称性和传递性这三条基本性质。不难看出，这些关系均是表示相同、相等、平等、一致等含义的关系。据此得到等价关系的定义：  
【定义6.1】假设𝐴是任一给定的非空集合，$R$是$𝐴$上的一个二元关系，如果$𝑅$满足自反性、对称性和传递性，则称$𝑅$是一个等价关系。此时，对于$𝐴$中任意两个元素${x}$和$y$，如果$\langle x,y\rangle\in$$R$，则称$x$与𝑦等价，记为$x{\sim}y$。  
从定义可知：关系$R$是等价关系当且仅当$𝑅$同时具备自反性、对称性和传递性；关系$𝑅$不是等价关系当且仅当$𝑅$不具备自反性或对称性或传递性。因此，等价关系的定义是判断关等价关系的一个很好判据。  
显然， 上述每个等价类其实就相当于例题 6.4  中等价关系图的每个完全子图或等价关系矩阵的每个子矩阵块。据此给出如下等价类的一般定义：  
【定义6.2】设$R$是非空集合𝐴上的等价关系，对任意$x\in A$，称下列集合：  
$$
[x]_{R}=\{y|y\in A\land\langle x,y\rangle\in R\}
$$  
为$𝑥$关于$𝑅$的等价类，或称为由$x$生成的一个$R $等价类，并称$x$称$[x]_{R}$的生成元或代表元。  
由上述定义可知等价类有以下性质：  
（1）等价类产生的前提是关系$R$必须是等价关系；  
（2）$𝐴$中所有与$$x$$有关系$𝑅$的元素$𝑦$构成了$[x]_{R}$；  
（3）$𝐴$中任意一个元素一定对应一个由其生成的等价类；  
（4）$R$具有自反性意味着对任意$x\in A$，$[x]_{R}$非空。 （5）$R$具有对称性意味着对任意$x,y\in A$，若有 $y\in[x]_{R}$，则有$x\in[y]_{R}$  
从例6.1.2 知，模3 同余关系是一个等价关系，可求出$A=\{1,\!2,\!3,\!4,\!5,\!6,\!7\}$中每个元素的$[1]_{R}=[4]_{R}=[7]_{R}=\{1,4,7\};\,\,\,[2]_{R}=[5]_{R}=\{2,5\};\,\,\,[3]_{R}=\{6\}_{\circ}$  
综合以上分析，可以看出等价类具有下性质：  
【定理6.1】设$R$是非空集合$𝐴$上的等价关系，对于任意$x,y\in A$，成立：  
（1）$\left[x\right]_{R}\neq\emptyset$且$[x]_{R}\subseteq A$；           （2）若$\langle x,y\rangle\in R$，则$[x]_{R}=[y]_{R}$；  
（3）若$\langle x,y\rangle\not\in R$，则$[x]_{R}\cap[y]_{R}=\emptyset$； （4）$\mathsf{U}_{x\in A}[x]_{R}=A\,。$  
上述定理表明，对于非空集合$𝐴$上的等价关系$R$，可用$R$的所有等价类将集合$𝐴$划分成若干个互不相交的子集合，每个子集合就是一个等价类。接下来讨论这种划分问题。",定理6.1描述了等价关系的性质，包括等价类的非空性、等价类之间的互不相交性以及等价类对集合的划分
等价类,性质,定理6.1,,"如前所述，集合的相等关系、直线的平行关系、多边形的全等关系、学生同学关系、整数的同余关系等等，它们都满足自反性、对称性和传递性这三条基本性质。不难看出，这些关系均是表示相同、相等、平等、一致等含义的关系。据此得到等价关系的定义：  
【定义6.1】假设𝐴是任一给定的非空集合，$R$是$𝐴$上的一个二元关系，如果$𝑅$满足自反性、对称性和传递性，则称$𝑅$是一个等价关系。此时，对于$𝐴$中任意两个元素${x}$和$y$，如果$\langle x,y\rangle\in$$R$，则称$x$与𝑦等价，记为$x{\sim}y$。  
从定义可知：关系$R$是等价关系当且仅当$𝑅$同时具备自反性、对称性和传递性；关系$𝑅$不是等价关系当且仅当$𝑅$不具备自反性或对称性或传递性。因此，等价关系的定义是判断关等价关系的一个很好判据。  
显然， 上述每个等价类其实就相当于例题 6.4  中等价关系图的每个完全子图或等价关系矩阵的每个子矩阵块。据此给出如下等价类的一般定义：  
【定义6.2】设$R$是非空集合𝐴上的等价关系，对任意$x\in A$，称下列集合：  
$$
[x]_{R}=\{y|y\in A\land\langle x,y\rangle\in R\}
$$  
为$𝑥$关于$𝑅$的等价类，或称为由$x$生成的一个$R $等价类，并称$x$称$[x]_{R}$的生成元或代表元。  
由上述定义可知等价类有以下性质：  
（1）等价类产生的前提是关系$R$必须是等价关系；  
（2）$𝐴$中所有与$$x$$有关系$𝑅$的元素$𝑦$构成了$[x]_{R}$；  
（3）$𝐴$中任意一个元素一定对应一个由其生成的等价类；  
（4）$R$具有自反性意味着对任意$x\in A$，$[x]_{R}$非空。 （5）$R$具有对称性意味着对任意$x,y\in A$，若有 $y\in[x]_{R}$，则有$x\in[y]_{R}$  
从例6.1.2 知，模3 同余关系是一个等价关系，可求出$A=\{1,\!2,\!3,\!4,\!5,\!6,\!7\}$中每个元素的$[1]_{R}=[4]_{R}=[7]_{R}=\{1,4,7\};\,\,\,[2]_{R}=[5]_{R}=\{2,5\};\,\,\,[3]_{R}=\{6\}_{\circ}$  
综合以上分析，可以看出等价类具有下性质：  
【定理6.1】设$R$是非空集合$𝐴$上的等价关系，对于任意$x,y\in A$，成立：  
（1）$\left[x\right]_{R}\neq\emptyset$且$[x]_{R}\subseteq A$；           （2）若$\langle x,y\rangle\in R$，则$[x]_{R}=[y]_{R}$；  
（3）若$\langle x,y\rangle\not\in R$，则$[x]_{R}\cap[y]_{R}=\emptyset$； （4）$\mathsf{U}_{x\in A}[x]_{R}=A\,。$  
上述定理表明，对于非空集合$𝐴$上的等价关系$R$，可用$R$的所有等价类将集合$𝐴$划分成若干个互不相交的子集合，每个子集合就是一个等价类。接下来讨论这种划分问题。",定理6.1详细阐述了等价类的性质，如每个等价类非空且是集合的子集，等价类之间要么相等要么互不相交，所有等价类的并集等于原集合
等价关系,构成,集合划分,,"在日常生活和工作中，我们经常将比较大的集合划分为若干比较小的集合，以便于分门别类地处理或管理，例如对于一个具有几千学生规模的学校，需将所有学生的集合划分为几十个班级，然后以每个班级为单位进行管理；再如，将中国的所有领土划分为省或直辖市等若干行政区域，这样每个中国人都可以归属到某个确定的行政区域。不难看出，对集合的一种划分其实就是实现了对集合中元素的一种分类，不同的划分构成了对集合元素的不同分类。例如，我们既可将所有人划分为男人、女人这两类，也可将所有人划分为小孩、年轻人、中年人和老年人这几类。分类是一种非常基本的问题求解策略。例如人工智能中的人脸识别、语言识别、自然语言理解、知识发现、机器博弈等很多问题都可归结为分类问题，从而将对该类问题的求解转化为对分类器的设计。设计分类器一直是科学理论与工程应用研究的热门前沿课题，例如深度学习模型中的卷积神经网络就是一个有效的分类器。下面我们从等价关系和集合划分的角度来学习集合中元素分类的基本知识。首先给出集合划分的定义：  
【定义6.3】假设$𝐴$任一非空集合，$S$是$𝐴$的非空子集$S_{i}$组成的集族$S=\{S_{1},S_{2},\cdots,S_{m}\}$，  且满足:$S_{i}\cap S_{j}=\emptyset\,\,\,{\mathrm{;}}\,\,\,S_{1}\cup S_{2}\cup\dots\cup S_{m}=\,\,\,A\,,$，则称$𝑆$是$𝐴$的一个划分, $S_{1},S_{2},\cdots,S_{m}$分别称为划分$𝑆$的一个划分块或划分类。  
设$R$是非空集合$ A$上的等价关系，则有定理6.1 知等价关系$R$的所有等价类组成的集族构成了集合$𝐴$的划分，我们称这个集族为集合$𝐴$关于$R$的商集，具体定义如下：  
【定义6.4】假设$𝐴$任一非空集合，$R$是$𝐴$上的一个等价关系，称$𝑅$的所有等价类组成的集族为集合$𝐴$关于等价关系$R$的商集，记为${A}/R$。即有：$A/R=\{[x]_{R}|x\in A\}$。  
我们知道商的概念与除法有关，比如把一块蛋糕平均分成四份，可以从不同的角度来看这件事：从算术的角度看，就是1 用4 除，得到的每份$1/4$ 就是商；集合的角度看，所谓商就是将一个大的集合分成了四个小的非空集合，这正是商集概念的含义。  
下面我们介绍两个特殊的等价关系及其商集：  
（1）非空集合𝐴上的完全关系$E_{A}$显然是$𝐴$的一个等价关系。由于对$\forall x\in A$有$[x]_{E_{A}}=A$，故$E_{A}$的商集就是以𝐴为元素的集合，即有$A/E_{A}=\{A\}$。  
（2）非空集合$𝐴$上的恒等关系$I_{A}$显然是$𝐴$的一个等价关系。由于对$\forall x\in A$有$\left[x\right]_{I_{A}}=\left\{x\right\}$，故$I_{A}$的商集就是所有以$\{x\}$为元素组成的集合，即有$A/I_{A}=\left\{\{x\}|x\in A\right\}$。  
从集合划分角度看，完全关系$E_{A}$给了集合$𝐴$的一个最粗略划分，即将整个$𝐴$作为一个划分块，而恒等关系$I_{A}$给出了$𝐴$的一个最细致划分，即分别将$𝐴$中每个元素作为一个一划分块。  
如前所述，非空集合$𝐴$上的每个等价关系$R$都会产生一个商集$A/R$，而且这个商集正好构  
成集合$𝐴$的一个划分。现在考虑一个相反的问题，非空集合$𝐴$上的任何一个划分是否能够产生一个与之相应的等价关系？下面的定理给出了肯定的回答：  
【定理6.2】 假设$\{S=\{S_{1},S_{2},\cdots,S_{m}\}$是非空集合𝐴一个划分，则如下关系  
$$
R=(S_{1}\times S_{1})\cup(S_{2}\times S_{2})\cup\cdots\cup(S_{m}\times S_{m})\quad\text{(6-2)}
$$  
是$A$上的等价关系，称之为由该划分所导出的等价关系。  
上述定理表明，对于非空集合上的任一划分，都可根据该划分构造出一个相应的等价关系，并给出了等价关系的具体构造方法。由此可知，非空集合上的划分与等价关系之间构成了一一对应的关系，即：非空集合的每一种划分都对应着该集合上的一个等价关系；反之，非空集合上每个等价关系都对应着这该集合的一个划分。因此，今后我们既可用集合划分方法解决等价关系问题，也可用等价关系方法解决集合划分问题。或者说，既可用元素分类方法解决等价关系问题，也可用等价关系方法元素分类问题。",等价关系R的所有等价类组成的集族构成了集合A的划分
等价关系,产生,商集,,"在日常生活和工作中，我们经常将比较大的集合划分为若干比较小的集合，以便于分门别类地处理或管理，例如对于一个具有几千学生规模的学校，需将所有学生的集合划分为几十个班级，然后以每个班级为单位进行管理；再如，将中国的所有领土划分为省或直辖市等若干行政区域，这样每个中国人都可以归属到某个确定的行政区域。不难看出，对集合的一种划分其实就是实现了对集合中元素的一种分类，不同的划分构成了对集合元素的不同分类。例如，我们既可将所有人划分为男人、女人这两类，也可将所有人划分为小孩、年轻人、中年人和老年人这几类。分类是一种非常基本的问题求解策略。例如人工智能中的人脸识别、语言识别、自然语言理解、知识发现、机器博弈等很多问题都可归结为分类问题，从而将对该类问题的求解转化为对分类器的设计。设计分类器一直是科学理论与工程应用研究的热门前沿课题，例如深度学习模型中的卷积神经网络就是一个有效的分类器。下面我们从等价关系和集合划分的角度来学习集合中元素分类的基本知识。首先给出集合划分的定义：  
【定义6.3】假设$𝐴$任一非空集合，$S$是$𝐴$的非空子集$S_{i}$组成的集族$S=\{S_{1},S_{2},\cdots,S_{m}\}$，  且满足:$S_{i}\cap S_{j}=\emptyset\,\,\,{\mathrm{;}}\,\,\,S_{1}\cup S_{2}\cup\dots\cup S_{m}=\,\,\,A\,,$，则称$𝑆$是$𝐴$的一个划分, $S_{1},S_{2},\cdots,S_{m}$分别称为划分$𝑆$的一个划分块或划分类。  
设$R$是非空集合$ A$上的等价关系，则有定理6.1 知等价关系$R$的所有等价类组成的集族构成了集合$𝐴$的划分，我们称这个集族为集合$𝐴$关于$R$的商集，具体定义如下：  
【定义6.4】假设$𝐴$任一非空集合，$R$是$𝐴$上的一个等价关系，称$𝑅$的所有等价类组成的集族为集合$𝐴$关于等价关系$R$的商集，记为${A}/R$。即有：$A/R=\{[x]_{R}|x\in A\}$。  
我们知道商的概念与除法有关，比如把一块蛋糕平均分成四份，可以从不同的角度来看这件事：从算术的角度看，就是1 用4 除，得到的每份$1/4$ 就是商；集合的角度看，所谓商就是将一个大的集合分成了四个小的非空集合，这正是商集概念的含义。  
下面我们介绍两个特殊的等价关系及其商集：  
（1）非空集合𝐴上的完全关系$E_{A}$显然是$𝐴$的一个等价关系。由于对$\forall x\in A$有$[x]_{E_{A}}=A$，故$E_{A}$的商集就是以𝐴为元素的集合，即有$A/E_{A}=\{A\}$。  
（2）非空集合$𝐴$上的恒等关系$I_{A}$显然是$𝐴$的一个等价关系。由于对$\forall x\in A$有$\left[x\right]_{I_{A}}=\left\{x\right\}$，故$I_{A}$的商集就是所有以$\{x\}$为元素组成的集合，即有$A/I_{A}=\left\{\{x\}|x\in A\right\}$。  
从集合划分角度看，完全关系$E_{A}$给了集合$𝐴$的一个最粗略划分，即将整个$𝐴$作为一个划分块，而恒等关系$I_{A}$给出了$𝐴$的一个最细致划分，即分别将$𝐴$中每个元素作为一个一划分块。  
如前所述，非空集合$𝐴$上的每个等价关系$R$都会产生一个商集$A/R$，而且这个商集正好构  
成集合$𝐴$的一个划分。现在考虑一个相反的问题，非空集合$𝐴$上的任何一个划分是否能够产生一个与之相应的等价关系？下面的定理给出了肯定的回答：  
【定理6.2】 假设$\{S=\{S_{1},S_{2},\cdots,S_{m}\}$是非空集合𝐴一个划分，则如下关系  
$$
R=(S_{1}\times S_{1})\cup(S_{2}\times S_{2})\cup\cdots\cup(S_{m}\times S_{m})\quad\text{(6-2)}
$$  
是$A$上的等价关系，称之为由该划分所导出的等价关系。  
上述定理表明，对于非空集合上的任一划分，都可根据该划分构造出一个相应的等价关系，并给出了等价关系的具体构造方法。由此可知，非空集合上的划分与等价关系之间构成了一一对应的关系，即：非空集合的每一种划分都对应着该集合上的一个等价关系；反之，非空集合上每个等价关系都对应着这该集合的一个划分。因此，今后我们既可用集合划分方法解决等价关系问题，也可用等价关系方法解决集合划分问题。或者说，既可用元素分类方法解决等价关系问题，也可用等价关系方法元素分类问题。",非空集合A上的每个等价关系R都会产生一个商集A/R
集合划分,导出,等价关系,,"在日常生活和工作中，我们经常将比较大的集合划分为若干比较小的集合，以便于分门别类地处理或管理，例如对于一个具有几千学生规模的学校，需将所有学生的集合划分为几十个班级，然后以每个班级为单位进行管理；再如，将中国的所有领土划分为省或直辖市等若干行政区域，这样每个中国人都可以归属到某个确定的行政区域。不难看出，对集合的一种划分其实就是实现了对集合中元素的一种分类，不同的划分构成了对集合元素的不同分类。例如，我们既可将所有人划分为男人、女人这两类，也可将所有人划分为小孩、年轻人、中年人和老年人这几类。分类是一种非常基本的问题求解策略。例如人工智能中的人脸识别、语言识别、自然语言理解、知识发现、机器博弈等很多问题都可归结为分类问题，从而将对该类问题的求解转化为对分类器的设计。设计分类器一直是科学理论与工程应用研究的热门前沿课题，例如深度学习模型中的卷积神经网络就是一个有效的分类器。下面我们从等价关系和集合划分的角度来学习集合中元素分类的基本知识。首先给出集合划分的定义：  
【定义6.3】假设$𝐴$任一非空集合，$S$是$𝐴$的非空子集$S_{i}$组成的集族$S=\{S_{1},S_{2},\cdots,S_{m}\}$，  且满足:$S_{i}\cap S_{j}=\emptyset\,\,\,{\mathrm{;}}\,\,\,S_{1}\cup S_{2}\cup\dots\cup S_{m}=\,\,\,A\,,$，则称$𝑆$是$𝐴$的一个划分, $S_{1},S_{2},\cdots,S_{m}$分别称为划分$𝑆$的一个划分块或划分类。  
设$R$是非空集合$ A$上的等价关系，则有定理6.1 知等价关系$R$的所有等价类组成的集族构成了集合$𝐴$的划分，我们称这个集族为集合$𝐴$关于$R$的商集，具体定义如下：  
【定义6.4】假设$𝐴$任一非空集合，$R$是$𝐴$上的一个等价关系，称$𝑅$的所有等价类组成的集族为集合$𝐴$关于等价关系$R$的商集，记为${A}/R$。即有：$A/R=\{[x]_{R}|x\in A\}$。  
我们知道商的概念与除法有关，比如把一块蛋糕平均分成四份，可以从不同的角度来看这件事：从算术的角度看，就是1 用4 除，得到的每份$1/4$ 就是商；集合的角度看，所谓商就是将一个大的集合分成了四个小的非空集合，这正是商集概念的含义。  
下面我们介绍两个特殊的等价关系及其商集：  
（1）非空集合𝐴上的完全关系$E_{A}$显然是$𝐴$的一个等价关系。由于对$\forall x\in A$有$[x]_{E_{A}}=A$，故$E_{A}$的商集就是以𝐴为元素的集合，即有$A/E_{A}=\{A\}$。  
（2）非空集合$𝐴$上的恒等关系$I_{A}$显然是$𝐴$的一个等价关系。由于对$\forall x\in A$有$\left[x\right]_{I_{A}}=\left\{x\right\}$，故$I_{A}$的商集就是所有以$\{x\}$为元素组成的集合，即有$A/I_{A}=\left\{\{x\}|x\in A\right\}$。  
从集合划分角度看，完全关系$E_{A}$给了集合$𝐴$的一个最粗略划分，即将整个$𝐴$作为一个划分块，而恒等关系$I_{A}$给出了$𝐴$的一个最细致划分，即分别将$𝐴$中每个元素作为一个一划分块。  
如前所述，非空集合$𝐴$上的每个等价关系$R$都会产生一个商集$A/R$，而且这个商集正好构  
成集合$𝐴$的一个划分。现在考虑一个相反的问题，非空集合$𝐴$上的任何一个划分是否能够产生一个与之相应的等价关系？下面的定理给出了肯定的回答：  
【定理6.2】 假设$\{S=\{S_{1},S_{2},\cdots,S_{m}\}$是非空集合𝐴一个划分，则如下关系  
$$
R=(S_{1}\times S_{1})\cup(S_{2}\times S_{2})\cup\cdots\cup(S_{m}\times S_{m})\quad\text{(6-2)}
$$  
是$A$上的等价关系，称之为由该划分所导出的等价关系。  
上述定理表明，对于非空集合上的任一划分，都可根据该划分构造出一个相应的等价关系，并给出了等价关系的具体构造方法。由此可知，非空集合上的划分与等价关系之间构成了一一对应的关系，即：非空集合的每一种划分都对应着该集合上的一个等价关系；反之，非空集合上每个等价关系都对应着这该集合的一个划分。因此，今后我们既可用集合划分方法解决等价关系问题，也可用等价关系方法解决集合划分问题。或者说，既可用元素分类方法解决等价关系问题，也可用等价关系方法元素分类问题。",非空集合A上的任何一个划分都能导出一个相应的等价关系
定理6.1,描述,等价关系,,"在日常生活和工作中，我们经常将比较大的集合划分为若干比较小的集合，以便于分门别类地处理或管理，例如对于一个具有几千学生规模的学校，需将所有学生的集合划分为几十个班级，然后以每个班级为单位进行管理；再如，将中国的所有领土划分为省或直辖市等若干行政区域，这样每个中国人都可以归属到某个确定的行政区域。不难看出，对集合的一种划分其实就是实现了对集合中元素的一种分类，不同的划分构成了对集合元素的不同分类。例如，我们既可将所有人划分为男人、女人这两类，也可将所有人划分为小孩、年轻人、中年人和老年人这几类。分类是一种非常基本的问题求解策略。例如人工智能中的人脸识别、语言识别、自然语言理解、知识发现、机器博弈等很多问题都可归结为分类问题，从而将对该类问题的求解转化为对分类器的设计。设计分类器一直是科学理论与工程应用研究的热门前沿课题，例如深度学习模型中的卷积神经网络就是一个有效的分类器。下面我们从等价关系和集合划分的角度来学习集合中元素分类的基本知识。首先给出集合划分的定义：  
【定义6.3】假设$𝐴$任一非空集合，$S$是$𝐴$的非空子集$S_{i}$组成的集族$S=\{S_{1},S_{2},\cdots,S_{m}\}$，  且满足:$S_{i}\cap S_{j}=\emptyset\,\,\,{\mathrm{;}}\,\,\,S_{1}\cup S_{2}\cup\dots\cup S_{m}=\,\,\,A\,,$，则称$𝑆$是$𝐴$的一个划分, $S_{1},S_{2},\cdots,S_{m}$分别称为划分$𝑆$的一个划分块或划分类。  
设$R$是非空集合$ A$上的等价关系，则有定理6.1 知等价关系$R$的所有等价类组成的集族构成了集合$𝐴$的划分，我们称这个集族为集合$𝐴$关于$R$的商集，具体定义如下：  
【定义6.4】假设$𝐴$任一非空集合，$R$是$𝐴$上的一个等价关系，称$𝑅$的所有等价类组成的集族为集合$𝐴$关于等价关系$R$的商集，记为${A}/R$。即有：$A/R=\{[x]_{R}|x\in A\}$。  
我们知道商的概念与除法有关，比如把一块蛋糕平均分成四份，可以从不同的角度来看这件事：从算术的角度看，就是1 用4 除，得到的每份$1/4$ 就是商；集合的角度看，所谓商就是将一个大的集合分成了四个小的非空集合，这正是商集概念的含义。  
下面我们介绍两个特殊的等价关系及其商集：  
（1）非空集合𝐴上的完全关系$E_{A}$显然是$𝐴$的一个等价关系。由于对$\forall x\in A$有$[x]_{E_{A}}=A$，故$E_{A}$的商集就是以𝐴为元素的集合，即有$A/E_{A}=\{A\}$。  
（2）非空集合$𝐴$上的恒等关系$I_{A}$显然是$𝐴$的一个等价关系。由于对$\forall x\in A$有$\left[x\right]_{I_{A}}=\left\{x\right\}$，故$I_{A}$的商集就是所有以$\{x\}$为元素组成的集合，即有$A/I_{A}=\left\{\{x\}|x\in A\right\}$。  
从集合划分角度看，完全关系$E_{A}$给了集合$𝐴$的一个最粗略划分，即将整个$𝐴$作为一个划分块，而恒等关系$I_{A}$给出了$𝐴$的一个最细致划分，即分别将$𝐴$中每个元素作为一个一划分块。  
如前所述，非空集合$𝐴$上的每个等价关系$R$都会产生一个商集$A/R$，而且这个商集正好构  
成集合$𝐴$的一个划分。现在考虑一个相反的问题，非空集合$𝐴$上的任何一个划分是否能够产生一个与之相应的等价关系？下面的定理给出了肯定的回答：  
【定理6.2】 假设$\{S=\{S_{1},S_{2},\cdots,S_{m}\}$是非空集合𝐴一个划分，则如下关系  
$$
R=(S_{1}\times S_{1})\cup(S_{2}\times S_{2})\cup\cdots\cup(S_{m}\times S_{m})\quad\text{(6-2)}
$$  
是$A$上的等价关系，称之为由该划分所导出的等价关系。  
上述定理表明，对于非空集合上的任一划分，都可根据该划分构造出一个相应的等价关系，并给出了等价关系的具体构造方法。由此可知，非空集合上的划分与等价关系之间构成了一一对应的关系，即：非空集合的每一种划分都对应着该集合上的一个等价关系；反之，非空集合上每个等价关系都对应着这该集合的一个划分。因此，今后我们既可用集合划分方法解决等价关系问题，也可用等价关系方法解决集合划分问题。或者说，既可用元素分类方法解决等价关系问题，也可用等价关系方法元素分类问题。",定理6.1描述了等价关系R的所有等价类组成的集族构成集合A的划分
定理6.2,描述,集合划分,,"在日常生活和工作中，我们经常将比较大的集合划分为若干比较小的集合，以便于分门别类地处理或管理，例如对于一个具有几千学生规模的学校，需将所有学生的集合划分为几十个班级，然后以每个班级为单位进行管理；再如，将中国的所有领土划分为省或直辖市等若干行政区域，这样每个中国人都可以归属到某个确定的行政区域。不难看出，对集合的一种划分其实就是实现了对集合中元素的一种分类，不同的划分构成了对集合元素的不同分类。例如，我们既可将所有人划分为男人、女人这两类，也可将所有人划分为小孩、年轻人、中年人和老年人这几类。分类是一种非常基本的问题求解策略。例如人工智能中的人脸识别、语言识别、自然语言理解、知识发现、机器博弈等很多问题都可归结为分类问题，从而将对该类问题的求解转化为对分类器的设计。设计分类器一直是科学理论与工程应用研究的热门前沿课题，例如深度学习模型中的卷积神经网络就是一个有效的分类器。下面我们从等价关系和集合划分的角度来学习集合中元素分类的基本知识。首先给出集合划分的定义：  
【定义6.3】假设$𝐴$任一非空集合，$S$是$𝐴$的非空子集$S_{i}$组成的集族$S=\{S_{1},S_{2},\cdots,S_{m}\}$，  且满足:$S_{i}\cap S_{j}=\emptyset\,\,\,{\mathrm{;}}\,\,\,S_{1}\cup S_{2}\cup\dots\cup S_{m}=\,\,\,A\,,$，则称$𝑆$是$𝐴$的一个划分, $S_{1},S_{2},\cdots,S_{m}$分别称为划分$𝑆$的一个划分块或划分类。  
设$R$是非空集合$ A$上的等价关系，则有定理6.1 知等价关系$R$的所有等价类组成的集族构成了集合$𝐴$的划分，我们称这个集族为集合$𝐴$关于$R$的商集，具体定义如下：  
【定义6.4】假设$𝐴$任一非空集合，$R$是$𝐴$上的一个等价关系，称$𝑅$的所有等价类组成的集族为集合$𝐴$关于等价关系$R$的商集，记为${A}/R$。即有：$A/R=\{[x]_{R}|x\in A\}$。  
我们知道商的概念与除法有关，比如把一块蛋糕平均分成四份，可以从不同的角度来看这件事：从算术的角度看，就是1 用4 除，得到的每份$1/4$ 就是商；集合的角度看，所谓商就是将一个大的集合分成了四个小的非空集合，这正是商集概念的含义。  
下面我们介绍两个特殊的等价关系及其商集：  
（1）非空集合𝐴上的完全关系$E_{A}$显然是$𝐴$的一个等价关系。由于对$\forall x\in A$有$[x]_{E_{A}}=A$，故$E_{A}$的商集就是以𝐴为元素的集合，即有$A/E_{A}=\{A\}$。  
（2）非空集合$𝐴$上的恒等关系$I_{A}$显然是$𝐴$的一个等价关系。由于对$\forall x\in A$有$\left[x\right]_{I_{A}}=\left\{x\right\}$，故$I_{A}$的商集就是所有以$\{x\}$为元素组成的集合，即有$A/I_{A}=\left\{\{x\}|x\in A\right\}$。  
从集合划分角度看，完全关系$E_{A}$给了集合$𝐴$的一个最粗略划分，即将整个$𝐴$作为一个划分块，而恒等关系$I_{A}$给出了$𝐴$的一个最细致划分，即分别将$𝐴$中每个元素作为一个一划分块。  
如前所述，非空集合$𝐴$上的每个等价关系$R$都会产生一个商集$A/R$，而且这个商集正好构  
成集合$𝐴$的一个划分。现在考虑一个相反的问题，非空集合$𝐴$上的任何一个划分是否能够产生一个与之相应的等价关系？下面的定理给出了肯定的回答：  
【定理6.2】 假设$\{S=\{S_{1},S_{2},\cdots,S_{m}\}$是非空集合𝐴一个划分，则如下关系  
$$
R=(S_{1}\times S_{1})\cup(S_{2}\times S_{2})\cup\cdots\cup(S_{m}\times S_{m})\quad\text{(6-2)}
$$  
是$A$上的等价关系，称之为由该划分所导出的等价关系。  
上述定理表明，对于非空集合上的任一划分，都可根据该划分构造出一个相应的等价关系，并给出了等价关系的具体构造方法。由此可知，非空集合上的划分与等价关系之间构成了一一对应的关系，即：非空集合的每一种划分都对应着该集合上的一个等价关系；反之，非空集合上每个等价关系都对应着这该集合的一个划分。因此，今后我们既可用集合划分方法解决等价关系问题，也可用等价关系方法解决集合划分问题。或者说，既可用元素分类方法解决等价关系问题，也可用等价关系方法元素分类问题。",定理6.2描述了非空集合A上的任何一个划分都能导出一个相应的等价关系
相容关系,构造,集合覆盖,,"相容关系，顾名思义就是一种能求同存异的关系，表示对象之间存在一些相同点或共性,例如国家之间的共同利益、人与人之间的共同兴趣爱好等。日常工作和生活中人与人之间的朋友关系、英文单词之间存在共同字母的关系等都可看成是相容关系。与等价关系相比，相容关系所表示对象之间的联系显然要弱一些，因为等价关系要求的是对象之间完全相同或相等。类似于等价关系可构造对集合的划分，相容关系则可构造对集合的覆盖。与划分不同的是构成集合覆盖的各个相容类之间的交集可以为非空。也就是说，集合中的同一元素可同时属于多个不同相容类。这相当于对集合中的元素进行聚类,因为在集合元素的聚类过程中，同一元素可同时聚合到多个不同的类别当中。这是元素聚类与元素分类的主要区别。聚类是有别于分类的另外一种非常重要的问题求解方法，可用于计算机数据分析相关的很多领域，例如数据挖掘和目标识别中的聚类分析等等。本节主要介绍相容关系的基本知识，主要包括相容关系与相容类的概念和性质、集合覆盖与完全覆盖的相关知识。",相容关系可以构造对集合的覆盖，且构成集合覆盖的各个相容类之间的交集可以为非空
相容关系,相当于,元素聚类,,"相容关系，顾名思义就是一种能求同存异的关系，表示对象之间存在一些相同点或共性,例如国家之间的共同利益、人与人之间的共同兴趣爱好等。日常工作和生活中人与人之间的朋友关系、英文单词之间存在共同字母的关系等都可看成是相容关系。与等价关系相比，相容关系所表示对象之间的联系显然要弱一些，因为等价关系要求的是对象之间完全相同或相等。类似于等价关系可构造对集合的划分，相容关系则可构造对集合的覆盖。与划分不同的是构成集合覆盖的各个相容类之间的交集可以为非空。也就是说，集合中的同一元素可同时属于多个不同相容类。这相当于对集合中的元素进行聚类,因为在集合元素的聚类过程中，同一元素可同时聚合到多个不同的类别当中。这是元素聚类与元素分类的主要区别。聚类是有别于分类的另外一种非常重要的问题求解方法，可用于计算机数据分析相关的很多领域，例如数据挖掘和目标识别中的聚类分析等等。本节主要介绍相容关系的基本知识，主要包括相容关系与相容类的概念和性质、集合覆盖与完全覆盖的相关知识。",相容关系对集合中的元素进行聚类，同一元素可同时属于多个不同相容类，这是元素聚类与元素分类的主要区别
元素聚类,关联,集合覆盖,,"相容关系，顾名思义就是一种能求同存异的关系，表示对象之间存在一些相同点或共性,例如国家之间的共同利益、人与人之间的共同兴趣爱好等。日常工作和生活中人与人之间的朋友关系、英文单词之间存在共同字母的关系等都可看成是相容关系。与等价关系相比，相容关系所表示对象之间的联系显然要弱一些，因为等价关系要求的是对象之间完全相同或相等。类似于等价关系可构造对集合的划分，相容关系则可构造对集合的覆盖。与划分不同的是构成集合覆盖的各个相容类之间的交集可以为非空。也就是说，集合中的同一元素可同时属于多个不同相容类。这相当于对集合中的元素进行聚类,因为在集合元素的聚类过程中，同一元素可同时聚合到多个不同的类别当中。这是元素聚类与元素分类的主要区别。聚类是有别于分类的另外一种非常重要的问题求解方法，可用于计算机数据分析相关的很多领域，例如数据挖掘和目标识别中的聚类分析等等。本节主要介绍相容关系的基本知识，主要包括相容关系与相容类的概念和性质、集合覆盖与完全覆盖的相关知识。",在集合覆盖中，同一元素可同时属于多个不同相容类，这与元素聚类过程中同一元素可聚合到多个不同类别的情况相似
相容关系,定义,相容类,,"相容关系表示的是一种求同存异的关系，对象之间有一些共同点但不完全相同。现在我们从数学的角度来考察相容关系。如前所述，人与人之间的朋友关系、英文单词之间存在共同字母的关系等都可看成是相容关系。不难发现，这些相容关系都满足自反性和对称性，但不满足传递性。由此得到如下关于相容关系的定义：  
【定义6.5】设$𝑅$为非空集合$𝐴$上的关系，若$R$满足自反性和对称性，则称$𝑅$为$𝐴$上的一个相容关系。此时，对于$𝐴$中任意两个元素$x$和𝑦，若$\langle x,y\rangle\in R$，则称$x$与𝑦相容，记为$x\approx y$。  
根据上述定义，不难发现所有的等价关系都可以看成是一种特殊的相容关系，即满足传递性的相容关系，但相容关系不一定是等价关系。  
与等价关系中等价类的概念类似，对于非空集合$𝐴$上的相容关系$R$，将𝐴中一些彼此具有相容关系$R$的元素放在一起构成𝐴的一个子集，由此得到如下相容类的概念：  
【定义6.6】设$ R$是非空集合$𝐴$上的一个相容关系，集合$C$是$𝐴$的某个子集，若对于任意的$x,y\in C$都有$\langle x,y\rangle\in R$，则称$C$是由相容关系$R$的一个相容类。  
例如，在例题6.16 中，$\{a\},\{a,e\},\{b,c\}$等都是$R$的相容类，$\{b,c\}\cup\{d\}=\{b,c,d\}$也是𝑅的相容类，但$\{a,e\}$与任何非空集合的并集都不再是$R$的相容类，此时称$\{a,e\}$为$R$的一个最大相容类，其具体定义如下：  
【定义6.7】设$R$是非空集合$𝐴$上的一个相容关系，$C$是$R$的一个相容类，若在$C$中添加$𝐴$的任何其他元素后，就不再构成相容类，则称$C$为$R$ 的一个最大相容类，记为$C_{R}$。  
例如，在例题6.16 中，$\{a,e\}$和$\{b,c,d\}$都是$R$ 的一个最大相容类。可用相容关系的简化关系图求最大相容类，具体方法如下：  
（1）图中最大完全多边形顶点构成的集合是最大相容类。  
（2）图中每个孤立结点是构成的集合分别是一个最大相容类。  
（3）如果图中某条边不是任何一个完全多边形的边，则该边的两个端点构成的集合是一个最大相容类。  
【定理6.3】设$R$是非空集合$𝐴$上的一个相容关系， $C$是$R$的一个相容类，那么必存在𝑅的一个最大相容类$C_{R}$，使得$C\subseteq C_{R}$。",相容类是由相容关系定义的，集合中的元素彼此具有相容关系
相容类,包含,最大相容类,,"相容关系表示的是一种求同存异的关系，对象之间有一些共同点但不完全相同。现在我们从数学的角度来考察相容关系。如前所述，人与人之间的朋友关系、英文单词之间存在共同字母的关系等都可看成是相容关系。不难发现，这些相容关系都满足自反性和对称性，但不满足传递性。由此得到如下关于相容关系的定义：  
【定义6.5】设$𝑅$为非空集合$𝐴$上的关系，若$R$满足自反性和对称性，则称$𝑅$为$𝐴$上的一个相容关系。此时，对于$𝐴$中任意两个元素$x$和𝑦，若$\langle x,y\rangle\in R$，则称$x$与𝑦相容，记为$x\approx y$。  
根据上述定义，不难发现所有的等价关系都可以看成是一种特殊的相容关系，即满足传递性的相容关系，但相容关系不一定是等价关系。  
与等价关系中等价类的概念类似，对于非空集合$𝐴$上的相容关系$R$，将𝐴中一些彼此具有相容关系$R$的元素放在一起构成𝐴的一个子集，由此得到如下相容类的概念：  
【定义6.6】设$ R$是非空集合$𝐴$上的一个相容关系，集合$C$是$𝐴$的某个子集，若对于任意的$x,y\in C$都有$\langle x,y\rangle\in R$，则称$C$是由相容关系$R$的一个相容类。  
例如，在例题6.16 中，$\{a\},\{a,e\},\{b,c\}$等都是$R$的相容类，$\{b,c\}\cup\{d\}=\{b,c,d\}$也是𝑅的相容类，但$\{a,e\}$与任何非空集合的并集都不再是$R$的相容类，此时称$\{a,e\}$为$R$的一个最大相容类，其具体定义如下：  
【定义6.7】设$R$是非空集合$𝐴$上的一个相容关系，$C$是$R$的一个相容类，若在$C$中添加$𝐴$的任何其他元素后，就不再构成相容类，则称$C$为$R$ 的一个最大相容类，记为$C_{R}$。  
例如，在例题6.16 中，$\{a,e\}$和$\{b,c,d\}$都是$R$ 的一个最大相容类。可用相容关系的简化关系图求最大相容类，具体方法如下：  
（1）图中最大完全多边形顶点构成的集合是最大相容类。  
（2）图中每个孤立结点是构成的集合分别是一个最大相容类。  
（3）如果图中某条边不是任何一个完全多边形的边，则该边的两个端点构成的集合是一个最大相容类。  
【定理6.3】设$R$是非空集合$𝐴$上的一个相容关系， $C$是$R$的一个相容类，那么必存在𝑅的一个最大相容类$C_{R}$，使得$C\subseteq C_{R}$。",最大相容类是相容类的一种，且不能通过添加其他元素扩展为更大的相容类
相容关系,定义,最大相容类,,"相容关系表示的是一种求同存异的关系，对象之间有一些共同点但不完全相同。现在我们从数学的角度来考察相容关系。如前所述，人与人之间的朋友关系、英文单词之间存在共同字母的关系等都可看成是相容关系。不难发现，这些相容关系都满足自反性和对称性，但不满足传递性。由此得到如下关于相容关系的定义：  
【定义6.5】设$𝑅$为非空集合$𝐴$上的关系，若$R$满足自反性和对称性，则称$𝑅$为$𝐴$上的一个相容关系。此时，对于$𝐴$中任意两个元素$x$和𝑦，若$\langle x,y\rangle\in R$，则称$x$与𝑦相容，记为$x\approx y$。  
根据上述定义，不难发现所有的等价关系都可以看成是一种特殊的相容关系，即满足传递性的相容关系，但相容关系不一定是等价关系。  
与等价关系中等价类的概念类似，对于非空集合$𝐴$上的相容关系$R$，将𝐴中一些彼此具有相容关系$R$的元素放在一起构成𝐴的一个子集，由此得到如下相容类的概念：  
【定义6.6】设$ R$是非空集合$𝐴$上的一个相容关系，集合$C$是$𝐴$的某个子集，若对于任意的$x,y\in C$都有$\langle x,y\rangle\in R$，则称$C$是由相容关系$R$的一个相容类。  
例如，在例题6.16 中，$\{a\},\{a,e\},\{b,c\}$等都是$R$的相容类，$\{b,c\}\cup\{d\}=\{b,c,d\}$也是𝑅的相容类，但$\{a,e\}$与任何非空集合的并集都不再是$R$的相容类，此时称$\{a,e\}$为$R$的一个最大相容类，其具体定义如下：  
【定义6.7】设$R$是非空集合$𝐴$上的一个相容关系，$C$是$R$的一个相容类，若在$C$中添加$𝐴$的任何其他元素后，就不再构成相容类，则称$C$为$R$ 的一个最大相容类，记为$C_{R}$。  
例如，在例题6.16 中，$\{a,e\}$和$\{b,c,d\}$都是$R$ 的一个最大相容类。可用相容关系的简化关系图求最大相容类，具体方法如下：  
（1）图中最大完全多边形顶点构成的集合是最大相容类。  
（2）图中每个孤立结点是构成的集合分别是一个最大相容类。  
（3）如果图中某条边不是任何一个完全多边形的边，则该边的两个端点构成的集合是一个最大相容类。  
【定理6.3】设$R$是非空集合$𝐴$上的一个相容关系， $C$是$R$的一个相容类，那么必存在𝑅的一个最大相容类$C_{R}$，使得$C\subseteq C_{R}$。",最大相容类是基于相容关系定义的，且在添加任何其他元素后不再构成相容类
定理6.3,蕴含,相容类,,"相容关系表示的是一种求同存异的关系，对象之间有一些共同点但不完全相同。现在我们从数学的角度来考察相容关系。如前所述，人与人之间的朋友关系、英文单词之间存在共同字母的关系等都可看成是相容关系。不难发现，这些相容关系都满足自反性和对称性，但不满足传递性。由此得到如下关于相容关系的定义：  
【定义6.5】设$𝑅$为非空集合$𝐴$上的关系，若$R$满足自反性和对称性，则称$𝑅$为$𝐴$上的一个相容关系。此时，对于$𝐴$中任意两个元素$x$和𝑦，若$\langle x,y\rangle\in R$，则称$x$与𝑦相容，记为$x\approx y$。  
根据上述定义，不难发现所有的等价关系都可以看成是一种特殊的相容关系，即满足传递性的相容关系，但相容关系不一定是等价关系。  
与等价关系中等价类的概念类似，对于非空集合$𝐴$上的相容关系$R$，将𝐴中一些彼此具有相容关系$R$的元素放在一起构成𝐴的一个子集，由此得到如下相容类的概念：  
【定义6.6】设$ R$是非空集合$𝐴$上的一个相容关系，集合$C$是$𝐴$的某个子集，若对于任意的$x,y\in C$都有$\langle x,y\rangle\in R$，则称$C$是由相容关系$R$的一个相容类。  
例如，在例题6.16 中，$\{a\},\{a,e\},\{b,c\}$等都是$R$的相容类，$\{b,c\}\cup\{d\}=\{b,c,d\}$也是𝑅的相容类，但$\{a,e\}$与任何非空集合的并集都不再是$R$的相容类，此时称$\{a,e\}$为$R$的一个最大相容类，其具体定义如下：  
【定义6.7】设$R$是非空集合$𝐴$上的一个相容关系，$C$是$R$的一个相容类，若在$C$中添加$𝐴$的任何其他元素后，就不再构成相容类，则称$C$为$R$ 的一个最大相容类，记为$C_{R}$。  
例如，在例题6.16 中，$\{a,e\}$和$\{b,c,d\}$都是$R$ 的一个最大相容类。可用相容关系的简化关系图求最大相容类，具体方法如下：  
（1）图中最大完全多边形顶点构成的集合是最大相容类。  
（2）图中每个孤立结点是构成的集合分别是一个最大相容类。  
（3）如果图中某条边不是任何一个完全多边形的边，则该边的两个端点构成的集合是一个最大相容类。  
【定理6.3】设$R$是非空集合$𝐴$上的一个相容关系， $C$是$R$的一个相容类，那么必存在𝑅的一个最大相容类$C_{R}$，使得$C\subseteq C_{R}$。",定理6.3表明，每个相容类都包含于某个最大相容类
定理6.3,证明,最大相容类,,"相容关系表示的是一种求同存异的关系，对象之间有一些共同点但不完全相同。现在我们从数学的角度来考察相容关系。如前所述，人与人之间的朋友关系、英文单词之间存在共同字母的关系等都可看成是相容关系。不难发现，这些相容关系都满足自反性和对称性，但不满足传递性。由此得到如下关于相容关系的定义：  
【定义6.5】设$𝑅$为非空集合$𝐴$上的关系，若$R$满足自反性和对称性，则称$𝑅$为$𝐴$上的一个相容关系。此时，对于$𝐴$中任意两个元素$x$和𝑦，若$\langle x,y\rangle\in R$，则称$x$与𝑦相容，记为$x\approx y$。  
根据上述定义，不难发现所有的等价关系都可以看成是一种特殊的相容关系，即满足传递性的相容关系，但相容关系不一定是等价关系。  
与等价关系中等价类的概念类似，对于非空集合$𝐴$上的相容关系$R$，将𝐴中一些彼此具有相容关系$R$的元素放在一起构成𝐴的一个子集，由此得到如下相容类的概念：  
【定义6.6】设$ R$是非空集合$𝐴$上的一个相容关系，集合$C$是$𝐴$的某个子集，若对于任意的$x,y\in C$都有$\langle x,y\rangle\in R$，则称$C$是由相容关系$R$的一个相容类。  
例如，在例题6.16 中，$\{a\},\{a,e\},\{b,c\}$等都是$R$的相容类，$\{b,c\}\cup\{d\}=\{b,c,d\}$也是𝑅的相容类，但$\{a,e\}$与任何非空集合的并集都不再是$R$的相容类，此时称$\{a,e\}$为$R$的一个最大相容类，其具体定义如下：  
【定义6.7】设$R$是非空集合$𝐴$上的一个相容关系，$C$是$R$的一个相容类，若在$C$中添加$𝐴$的任何其他元素后，就不再构成相容类，则称$C$为$R$ 的一个最大相容类，记为$C_{R}$。  
例如，在例题6.16 中，$\{a,e\}$和$\{b,c,d\}$都是$R$ 的一个最大相容类。可用相容关系的简化关系图求最大相容类，具体方法如下：  
（1）图中最大完全多边形顶点构成的集合是最大相容类。  
（2）图中每个孤立结点是构成的集合分别是一个最大相容类。  
（3）如果图中某条边不是任何一个完全多边形的边，则该边的两个端点构成的集合是一个最大相容类。  
【定理6.3】设$R$是非空集合$𝐴$上的一个相容关系， $C$是$R$的一个相容类，那么必存在𝑅的一个最大相容类$C_{R}$，使得$C\subseteq C_{R}$。",定理6.3证明了相容类的存在性，即每个相容类都存在于某个最大相容类中
相容关系,导出,集合覆盖,,"我们知道，集合上的任何一个等价关系都可以确定该集合的一个划分。那么，集合上的任何一个相容关系是否也能确定该集合的一个划分呢？答案显然是否定的。因为任何一个等价关系都是相容关系，但是相容关系不一定是等价关系。既然显然关系不一定能够对集合产生一个划分，那么它对集合能产生什么另外的效果呢？现在就来考察这个问题。  
在对集合的划分过程中，要求不同划分块之间的交集为空集，也就是说不同划分块之间不能有共同部分。现在取消这个限制，由此得到如下关于集合覆盖的概念：  
【定义6.8】假设$𝐴$任一非空集合，$Q$是$𝐴$的非空子集$Q_{i}$组成的集族$\begin{array}{r}{\boldsymbol{ Q}=\{Q_{1},Q_{2},\cdots,Q_{m}\},}\end{array}$，且满足$Q_{1}\cup Q_{2}\cup\cdots\cup Q_{m}=A$，则称$ Q$是$𝐴$的一个覆盖, $Q_{1},Q_{2},\cdots,Q_{m}$分别称为覆盖$Q$的一个 覆盖块或覆盖类。  
从上述定义可以看出，划分一定是覆盖，但覆盖不一定是划分。例如，在$A=\{1,\!2,\!3\}$的如下子集中，$A_{1},A_{2},A_{3}.$,是覆盖，$A_{1},A_{2}$,是覆盖也是划分，$A_{4}$既不是覆盖也不是划分。  
$$
A_{1}=\big\{\{1\},\{2\},\{3\}\big\},A_{2}=\big\{\{1,2\},\{3\}\big\},A_{3}=\big\{\{1,2\},\{2,3\}\big\},A_{4}=\big\{\{1\},\{3\}\big\}
$$  
设$ R$是非空集合$𝐴$上的一个相容关系，下面的定理表明，以$R$的所有最大相容类为元素构成的集合可以能够构成$𝐴$的一个覆盖，并由此到完全覆盖的概念：  
【定理6.4】设$\cdot R$是非空集合𝐴上的一个相容关系，由$R$所有最大相容类为元素构成的集合可以构成𝐴的一个覆盖，并称之为𝐴的一个完全覆盖，记为$C_{R}(A)$。  
【定理6.5】设$\boldsymbol{Q}=\{\;\boldsymbol{Q}_{1},\boldsymbol{Q}_{2},\cdots,\boldsymbol{Q}_{m}\},$为集合$𝐴$的任一覆盖，则由该覆盖确定的关系：  
$$
R=(Q_{1}\times Q_{1})\cup(Q_{2}\times Q_{2})\cup\cdots\cup(Q_{m}\times Q_{m})\quad\text{(6-3)}
$$  
是$𝐴$上的相容关系，称之为由该覆盖所导出的相容关系。  
上述定理表明了对于非空集合$𝐴$上的任意一个覆盖，都可以构造出相应的一个相容关系。但是，不同的覆盖有可能产生相同的相容关系。例如，对于集合$A=\{1,\!2,\!3,\!4,\!5\}$上的两个覆盖{{1,2,3}, {3,4}}和{{1,2}, {2,3},{1,3},{3,4}}，易知它们产生的相容关系均为：  
$$
R=\{\langle1,1\rangle,\langle1,2\rangle,\langle2,1\rangle,\langle2,2\rangle,\langle2,3\rangle,\langle3,2\rangle,\langle1,3\rangle,\langle3,1\rangle,\langle3,3\rangle,\langle4,4\rangle,\langle3,4\rangle,\langle4,3\rangle\}
$$  
因此，非空集合$𝐴$上的相容关系与$𝐴$上的覆盖之间不是一一对应的关系。但是，对于$𝐴$上任意一个给定的相容关系$R$，其所有最大相容类$C_{R}$构成的集合是唯一确定的，因而由$R$所有最大相容类$C_{R}$为元素构成的𝐴最大覆盖$C_{R}(A)$也是唯一确定的。也就是说，非空集合$𝐴$上的每  
个相容关系唯一确定$𝐴$上的一个完全覆盖。",非空集合上的任意一个覆盖可以构造出相应的一个相容关系
相容关系,确定,完全覆盖,,"我们知道，集合上的任何一个等价关系都可以确定该集合的一个划分。那么，集合上的任何一个相容关系是否也能确定该集合的一个划分呢？答案显然是否定的。因为任何一个等价关系都是相容关系，但是相容关系不一定是等价关系。既然显然关系不一定能够对集合产生一个划分，那么它对集合能产生什么另外的效果呢？现在就来考察这个问题。  
在对集合的划分过程中，要求不同划分块之间的交集为空集，也就是说不同划分块之间不能有共同部分。现在取消这个限制，由此得到如下关于集合覆盖的概念：  
【定义6.8】假设$𝐴$任一非空集合，$Q$是$𝐴$的非空子集$Q_{i}$组成的集族$\begin{array}{r}{\boldsymbol{ Q}=\{Q_{1},Q_{2},\cdots,Q_{m}\},}\end{array}$，且满足$Q_{1}\cup Q_{2}\cup\cdots\cup Q_{m}=A$，则称$ Q$是$𝐴$的一个覆盖, $Q_{1},Q_{2},\cdots,Q_{m}$分别称为覆盖$Q$的一个 覆盖块或覆盖类。  
从上述定义可以看出，划分一定是覆盖，但覆盖不一定是划分。例如，在$A=\{1,\!2,\!3\}$的如下子集中，$A_{1},A_{2},A_{3}.$,是覆盖，$A_{1},A_{2}$,是覆盖也是划分，$A_{4}$既不是覆盖也不是划分。  
$$
A_{1}=\big\{\{1\},\{2\},\{3\}\big\},A_{2}=\big\{\{1,2\},\{3\}\big\},A_{3}=\big\{\{1,2\},\{2,3\}\big\},A_{4}=\big\{\{1\},\{3\}\big\}
$$  
设$ R$是非空集合$𝐴$上的一个相容关系，下面的定理表明，以$R$的所有最大相容类为元素构成的集合可以能够构成$𝐴$的一个覆盖，并由此到完全覆盖的概念：  
【定理6.4】设$\cdot R$是非空集合𝐴上的一个相容关系，由$R$所有最大相容类为元素构成的集合可以构成𝐴的一个覆盖，并称之为𝐴的一个完全覆盖，记为$C_{R}(A)$。  
【定理6.5】设$\boldsymbol{Q}=\{\;\boldsymbol{Q}_{1},\boldsymbol{Q}_{2},\cdots,\boldsymbol{Q}_{m}\},$为集合$𝐴$的任一覆盖，则由该覆盖确定的关系：  
$$
R=(Q_{1}\times Q_{1})\cup(Q_{2}\times Q_{2})\cup\cdots\cup(Q_{m}\times Q_{m})\quad\text{(6-3)}
$$  
是$𝐴$上的相容关系，称之为由该覆盖所导出的相容关系。  
上述定理表明了对于非空集合$𝐴$上的任意一个覆盖，都可以构造出相应的一个相容关系。但是，不同的覆盖有可能产生相同的相容关系。例如，对于集合$A=\{1,\!2,\!3,\!4,\!5\}$上的两个覆盖{{1,2,3}, {3,4}}和{{1,2}, {2,3},{1,3},{3,4}}，易知它们产生的相容关系均为：  
$$
R=\{\langle1,1\rangle,\langle1,2\rangle,\langle2,1\rangle,\langle2,2\rangle,\langle2,3\rangle,\langle3,2\rangle,\langle1,3\rangle,\langle3,1\rangle,\langle3,3\rangle,\langle4,4\rangle,\langle3,4\rangle,\langle4,3\rangle\}
$$  
因此，非空集合$𝐴$上的相容关系与$𝐴$上的覆盖之间不是一一对应的关系。但是，对于$𝐴$上任意一个给定的相容关系$R$，其所有最大相容类$C_{R}$构成的集合是唯一确定的，因而由$R$所有最大相容类$C_{R}$为元素构成的𝐴最大覆盖$C_{R}(A)$也是唯一确定的。也就是说，非空集合$𝐴$上的每  
个相容关系唯一确定$𝐴$上的一个完全覆盖。",非空集合上的每个相容关系唯一确定该集合上的一个完全覆盖
定理6.4,定义,完全覆盖,,"我们知道，集合上的任何一个等价关系都可以确定该集合的一个划分。那么，集合上的任何一个相容关系是否也能确定该集合的一个划分呢？答案显然是否定的。因为任何一个等价关系都是相容关系，但是相容关系不一定是等价关系。既然显然关系不一定能够对集合产生一个划分，那么它对集合能产生什么另外的效果呢？现在就来考察这个问题。  
在对集合的划分过程中，要求不同划分块之间的交集为空集，也就是说不同划分块之间不能有共同部分。现在取消这个限制，由此得到如下关于集合覆盖的概念：  
【定义6.8】假设$𝐴$任一非空集合，$Q$是$𝐴$的非空子集$Q_{i}$组成的集族$\begin{array}{r}{\boldsymbol{ Q}=\{Q_{1},Q_{2},\cdots,Q_{m}\},}\end{array}$，且满足$Q_{1}\cup Q_{2}\cup\cdots\cup Q_{m}=A$，则称$ Q$是$𝐴$的一个覆盖, $Q_{1},Q_{2},\cdots,Q_{m}$分别称为覆盖$Q$的一个 覆盖块或覆盖类。  
从上述定义可以看出，划分一定是覆盖，但覆盖不一定是划分。例如，在$A=\{1,\!2,\!3\}$的如下子集中，$A_{1},A_{2},A_{3}.$,是覆盖，$A_{1},A_{2}$,是覆盖也是划分，$A_{4}$既不是覆盖也不是划分。  
$$
A_{1}=\big\{\{1\},\{2\},\{3\}\big\},A_{2}=\big\{\{1,2\},\{3\}\big\},A_{3}=\big\{\{1,2\},\{2,3\}\big\},A_{4}=\big\{\{1\},\{3\}\big\}
$$  
设$ R$是非空集合$𝐴$上的一个相容关系，下面的定理表明，以$R$的所有最大相容类为元素构成的集合可以能够构成$𝐴$的一个覆盖，并由此到完全覆盖的概念：  
【定理6.4】设$\cdot R$是非空集合𝐴上的一个相容关系，由$R$所有最大相容类为元素构成的集合可以构成𝐴的一个覆盖，并称之为𝐴的一个完全覆盖，记为$C_{R}(A)$。  
【定理6.5】设$\boldsymbol{Q}=\{\;\boldsymbol{Q}_{1},\boldsymbol{Q}_{2},\cdots,\boldsymbol{Q}_{m}\},$为集合$𝐴$的任一覆盖，则由该覆盖确定的关系：  
$$
R=(Q_{1}\times Q_{1})\cup(Q_{2}\times Q_{2})\cup\cdots\cup(Q_{m}\times Q_{m})\quad\text{(6-3)}
$$  
是$𝐴$上的相容关系，称之为由该覆盖所导出的相容关系。  
上述定理表明了对于非空集合$𝐴$上的任意一个覆盖，都可以构造出相应的一个相容关系。但是，不同的覆盖有可能产生相同的相容关系。例如，对于集合$A=\{1,\!2,\!3,\!4,\!5\}$上的两个覆盖{{1,2,3}, {3,4}}和{{1,2}, {2,3},{1,3},{3,4}}，易知它们产生的相容关系均为：  
$$
R=\{\langle1,1\rangle,\langle1,2\rangle,\langle2,1\rangle,\langle2,2\rangle,\langle2,3\rangle,\langle3,2\rangle,\langle1,3\rangle,\langle3,1\rangle,\langle3,3\rangle,\langle4,4\rangle,\langle3,4\rangle,\langle4,3\rangle\}
$$  
因此，非空集合$𝐴$上的相容关系与$𝐴$上的覆盖之间不是一一对应的关系。但是，对于$𝐴$上任意一个给定的相容关系$R$，其所有最大相容类$C_{R}$构成的集合是唯一确定的，因而由$R$所有最大相容类$C_{R}$为元素构成的𝐴最大覆盖$C_{R}(A)$也是唯一确定的。也就是说，非空集合$𝐴$上的每  
个相容关系唯一确定$𝐴$上的一个完全覆盖。",定理6.4定义了由相容关系的所有最大相容类构成的集合为完全覆盖
定理6.5,构造,相容关系,,"我们知道，集合上的任何一个等价关系都可以确定该集合的一个划分。那么，集合上的任何一个相容关系是否也能确定该集合的一个划分呢？答案显然是否定的。因为任何一个等价关系都是相容关系，但是相容关系不一定是等价关系。既然显然关系不一定能够对集合产生一个划分，那么它对集合能产生什么另外的效果呢？现在就来考察这个问题。  
在对集合的划分过程中，要求不同划分块之间的交集为空集，也就是说不同划分块之间不能有共同部分。现在取消这个限制，由此得到如下关于集合覆盖的概念：  
【定义6.8】假设$𝐴$任一非空集合，$Q$是$𝐴$的非空子集$Q_{i}$组成的集族$\begin{array}{r}{\boldsymbol{ Q}=\{Q_{1},Q_{2},\cdots,Q_{m}\},}\end{array}$，且满足$Q_{1}\cup Q_{2}\cup\cdots\cup Q_{m}=A$，则称$ Q$是$𝐴$的一个覆盖, $Q_{1},Q_{2},\cdots,Q_{m}$分别称为覆盖$Q$的一个 覆盖块或覆盖类。  
从上述定义可以看出，划分一定是覆盖，但覆盖不一定是划分。例如，在$A=\{1,\!2,\!3\}$的如下子集中，$A_{1},A_{2},A_{3}.$,是覆盖，$A_{1},A_{2}$,是覆盖也是划分，$A_{4}$既不是覆盖也不是划分。  
$$
A_{1}=\big\{\{1\},\{2\},\{3\}\big\},A_{2}=\big\{\{1,2\},\{3\}\big\},A_{3}=\big\{\{1,2\},\{2,3\}\big\},A_{4}=\big\{\{1\},\{3\}\big\}
$$  
设$ R$是非空集合$𝐴$上的一个相容关系，下面的定理表明，以$R$的所有最大相容类为元素构成的集合可以能够构成$𝐴$的一个覆盖，并由此到完全覆盖的概念：  
【定理6.4】设$\cdot R$是非空集合𝐴上的一个相容关系，由$R$所有最大相容类为元素构成的集合可以构成𝐴的一个覆盖，并称之为𝐴的一个完全覆盖，记为$C_{R}(A)$。  
【定理6.5】设$\boldsymbol{Q}=\{\;\boldsymbol{Q}_{1},\boldsymbol{Q}_{2},\cdots,\boldsymbol{Q}_{m}\},$为集合$𝐴$的任一覆盖，则由该覆盖确定的关系：  
$$
R=(Q_{1}\times Q_{1})\cup(Q_{2}\times Q_{2})\cup\cdots\cup(Q_{m}\times Q_{m})\quad\text{(6-3)}
$$  
是$𝐴$上的相容关系，称之为由该覆盖所导出的相容关系。  
上述定理表明了对于非空集合$𝐴$上的任意一个覆盖，都可以构造出相应的一个相容关系。但是，不同的覆盖有可能产生相同的相容关系。例如，对于集合$A=\{1,\!2,\!3,\!4,\!5\}$上的两个覆盖{{1,2,3}, {3,4}}和{{1,2}, {2,3},{1,3},{3,4}}，易知它们产生的相容关系均为：  
$$
R=\{\langle1,1\rangle,\langle1,2\rangle,\langle2,1\rangle,\langle2,2\rangle,\langle2,3\rangle,\langle3,2\rangle,\langle1,3\rangle,\langle3,1\rangle,\langle3,3\rangle,\langle4,4\rangle,\langle3,4\rangle,\langle4,3\rangle\}
$$  
因此，非空集合$𝐴$上的相容关系与$𝐴$上的覆盖之间不是一一对应的关系。但是，对于$𝐴$上任意一个给定的相容关系$R$，其所有最大相容类$C_{R}$构成的集合是唯一确定的，因而由$R$所有最大相容类$C_{R}$为元素构成的𝐴最大覆盖$C_{R}(A)$也是唯一确定的。也就是说，非空集合$𝐴$上的每  
个相容关系唯一确定$𝐴$上的一个完全覆盖。",定理6.5表明任意一个覆盖可以构造出相应的相容关系
偏序关系,属于,序关系,,前面讨论的等价关系和相容关系主要刻画对象之间的在某些方面的无差异性或存在某些共性特征。序关系刻画则是对象之间的在某些方面差异性，通过对集合中元素之间的差异性比较建立一种具有层次性的离散结构。日常生活和工作中常用的序关系有很多种，包括拟序关系、偏序关系、全序关系和良序关系等，其中的偏序关系最为典型也相对复杂，本节着重介绍偏序关系的相关知识。如果掌握了偏序关系的概念和性质，那么对拟序关系、全序关系和良序关系等其它序关系知识的学习问题就可迎刃而解。,偏序关系是序关系的一种
偏序关系,定义,偏序集,,"次序是日常生活和工作中经常遇到的一种关系，例如体育竞赛中的排名、全国高校排名、家族的长幼辈分、某单位的行政职位的级别、实数之间的大小关系、集合之间的包含关系、自然数集合上的整除关系等等，都是次序关系，刻画的是对象之间在某个方面的差异性比较关系。现在我们用数学方法来表示和处理这种序关系。  
我们知道，某集合幂集上的包含关系满足自反性、反对称性和传递性，自然数集合上的整除关系也满足自反性、反对称性和传递性。将这类关系抽象出来，可得到一种名为偏序关系的特殊关系，其具体定义如下：  
【定义6.9】设$R$非空集合$𝐴$上的一个二元关系，如果$𝑅$满足自反性、反对称性和传递性，则称 $R$是$𝐴$上的一个偏序关系,简称为偏序，记为$\preccurlyeq$，读作小于等于或先于。对于𝐴上的任意两个元素$x,y$，如果序偶$\langle x,y\rangle\in R$，则称$x$与𝑦可比且$x$前于$y$或$x$先于$ y$，记为$x\preccurlyeq y$。如果集合$𝐴$上有偏序关系$R$，则称$;A$为是一个偏序集,记为$\langle A,\preccurlyeq\rangle$。  
从上述定义可知，定义中小于等于或先于的含义并不一定是指数的大小，主要是指偏序关系中的顺序，$x$小于等于或先于$ y$的具体含义是：依照这个序关系$x$排在𝑦的前面或者$x$就是$y$。此外，定义中并没有保证$𝐴$中任意两个元素之间都必须具有这种序关系。这正是偏序的含义。所谓偏序,就是集合中的部分元素之间存在这种序关系。  
例如，集合$ A=\{2,4,6,8\}$上的整除关系为：  
$$
R=\{\ \langle2,2\rangle,\langle2,4\rangle,\langle2,6\rangle,\langle2,8\rangle,\langle4,6\rangle,\langle4,8\rangle,\langle6,6\rangle,\langle8,8\rangle\}
$$  
显然关系$R$具有自反性、反对称性和传递性，故为偏序关系。$\langle A,R\rangle$是一个偏序集。在这个偏序集中，4和8是可比的且4 先于8，而4 和6是不可比的。  
【定义6.10】设$𝑅$非空集合$𝐴$上的一个二元关系，如果$R$满足反自反性、反对称性和传递性，则称$𝑅$是$𝐴$上的一个拟序关系或半序关系,简称为拟序或半序，记为$\prec$，读作小于。对于$𝐴$上的任意两个元素$x,y$，如果序偶$\langle x,y\rangle\in R$，则称$x$与$𝑦$可比且$$x$$小于$ y$，记为$x\prec y$。如果集合$𝐴$上有偏序关系$R$，则称$𝐴$为是一个拟序集或半序集,记为$\langle A,\prec\rangle$。  
从上述定义可知，定义中小于的含义并不是指数的大小，而是指偏序关系中的顺序，$x$小于𝑦的含义是：依照这个序关系$x$排在𝑦的前面。显然，拟序关系的自反闭包就是偏序关系。因此，偏序关系是拟序关系一种扩充，拟序关系是偏序关系的一种缩减。例如，实数集上的实数小于关系就是一种拟序关系，小于等于关系则是一种偏序关系。",如果集合A上有偏序关系R，则称A为一个偏序集
拟序关系,定义,拟序集,,"次序是日常生活和工作中经常遇到的一种关系，例如体育竞赛中的排名、全国高校排名、家族的长幼辈分、某单位的行政职位的级别、实数之间的大小关系、集合之间的包含关系、自然数集合上的整除关系等等，都是次序关系，刻画的是对象之间在某个方面的差异性比较关系。现在我们用数学方法来表示和处理这种序关系。  
我们知道，某集合幂集上的包含关系满足自反性、反对称性和传递性，自然数集合上的整除关系也满足自反性、反对称性和传递性。将这类关系抽象出来，可得到一种名为偏序关系的特殊关系，其具体定义如下：  
【定义6.9】设$R$非空集合$𝐴$上的一个二元关系，如果$𝑅$满足自反性、反对称性和传递性，则称 $R$是$𝐴$上的一个偏序关系,简称为偏序，记为$\preccurlyeq$，读作小于等于或先于。对于𝐴上的任意两个元素$x,y$，如果序偶$\langle x,y\rangle\in R$，则称$x$与𝑦可比且$x$前于$y$或$x$先于$ y$，记为$x\preccurlyeq y$。如果集合$𝐴$上有偏序关系$R$，则称$;A$为是一个偏序集,记为$\langle A,\preccurlyeq\rangle$。  
从上述定义可知，定义中小于等于或先于的含义并不一定是指数的大小，主要是指偏序关系中的顺序，$x$小于等于或先于$ y$的具体含义是：依照这个序关系$x$排在𝑦的前面或者$x$就是$y$。此外，定义中并没有保证$𝐴$中任意两个元素之间都必须具有这种序关系。这正是偏序的含义。所谓偏序,就是集合中的部分元素之间存在这种序关系。  
例如，集合$ A=\{2,4,6,8\}$上的整除关系为：  
$$
R=\{\ \langle2,2\rangle,\langle2,4\rangle,\langle2,6\rangle,\langle2,8\rangle,\langle4,6\rangle,\langle4,8\rangle,\langle6,6\rangle,\langle8,8\rangle\}
$$  
显然关系$R$具有自反性、反对称性和传递性，故为偏序关系。$\langle A,R\rangle$是一个偏序集。在这个偏序集中，4和8是可比的且4 先于8，而4 和6是不可比的。  
【定义6.10】设$𝑅$非空集合$𝐴$上的一个二元关系，如果$R$满足反自反性、反对称性和传递性，则称$𝑅$是$𝐴$上的一个拟序关系或半序关系,简称为拟序或半序，记为$\prec$，读作小于。对于$𝐴$上的任意两个元素$x,y$，如果序偶$\langle x,y\rangle\in R$，则称$x$与$𝑦$可比且$$x$$小于$ y$，记为$x\prec y$。如果集合$𝐴$上有偏序关系$R$，则称$𝐴$为是一个拟序集或半序集,记为$\langle A,\prec\rangle$。  
从上述定义可知，定义中小于的含义并不是指数的大小，而是指偏序关系中的顺序，$x$小于𝑦的含义是：依照这个序关系$x$排在𝑦的前面。显然，拟序关系的自反闭包就是偏序关系。因此，偏序关系是拟序关系一种扩充，拟序关系是偏序关系的一种缩减。例如，实数集上的实数小于关系就是一种拟序关系，小于等于关系则是一种偏序关系。",如果集合A上有拟序关系R，则称A为一个拟序集
偏序关系,包含,拟序关系,,"次序是日常生活和工作中经常遇到的一种关系，例如体育竞赛中的排名、全国高校排名、家族的长幼辈分、某单位的行政职位的级别、实数之间的大小关系、集合之间的包含关系、自然数集合上的整除关系等等，都是次序关系，刻画的是对象之间在某个方面的差异性比较关系。现在我们用数学方法来表示和处理这种序关系。  
我们知道，某集合幂集上的包含关系满足自反性、反对称性和传递性，自然数集合上的整除关系也满足自反性、反对称性和传递性。将这类关系抽象出来，可得到一种名为偏序关系的特殊关系，其具体定义如下：  
【定义6.9】设$R$非空集合$𝐴$上的一个二元关系，如果$𝑅$满足自反性、反对称性和传递性，则称 $R$是$𝐴$上的一个偏序关系,简称为偏序，记为$\preccurlyeq$，读作小于等于或先于。对于𝐴上的任意两个元素$x,y$，如果序偶$\langle x,y\rangle\in R$，则称$x$与𝑦可比且$x$前于$y$或$x$先于$ y$，记为$x\preccurlyeq y$。如果集合$𝐴$上有偏序关系$R$，则称$;A$为是一个偏序集,记为$\langle A,\preccurlyeq\rangle$。  
从上述定义可知，定义中小于等于或先于的含义并不一定是指数的大小，主要是指偏序关系中的顺序，$x$小于等于或先于$ y$的具体含义是：依照这个序关系$x$排在𝑦的前面或者$x$就是$y$。此外，定义中并没有保证$𝐴$中任意两个元素之间都必须具有这种序关系。这正是偏序的含义。所谓偏序,就是集合中的部分元素之间存在这种序关系。  
例如，集合$ A=\{2,4,6,8\}$上的整除关系为：  
$$
R=\{\ \langle2,2\rangle,\langle2,4\rangle,\langle2,6\rangle,\langle2,8\rangle,\langle4,6\rangle,\langle4,8\rangle,\langle6,6\rangle,\langle8,8\rangle\}
$$  
显然关系$R$具有自反性、反对称性和传递性，故为偏序关系。$\langle A,R\rangle$是一个偏序集。在这个偏序集中，4和8是可比的且4 先于8，而4 和6是不可比的。  
【定义6.10】设$𝑅$非空集合$𝐴$上的一个二元关系，如果$R$满足反自反性、反对称性和传递性，则称$𝑅$是$𝐴$上的一个拟序关系或半序关系,简称为拟序或半序，记为$\prec$，读作小于。对于$𝐴$上的任意两个元素$x,y$，如果序偶$\langle x,y\rangle\in R$，则称$x$与$𝑦$可比且$$x$$小于$ y$，记为$x\prec y$。如果集合$𝐴$上有偏序关系$R$，则称$𝐴$为是一个拟序集或半序集,记为$\langle A,\prec\rangle$。  
从上述定义可知，定义中小于的含义并不是指数的大小，而是指偏序关系中的顺序，$x$小于𝑦的含义是：依照这个序关系$x$排在𝑦的前面。显然，拟序关系的自反闭包就是偏序关系。因此，偏序关系是拟序关系一种扩充，拟序关系是偏序关系的一种缩减。例如，实数集上的实数小于关系就是一种拟序关系，小于等于关系则是一种偏序关系。",偏序关系是拟序关系的自反闭包，偏序关系是拟序关系的一种扩充
偏序关系,包含,全序关系,,"前述集合$𝐴$上偏序关系并不保证$𝐴$上的任何两个元素之间都是可比的，也是就是说并不保证任何两个元素之间都存在序关系。然而，在很多场合我们都需要对所关心的所有对象排个次序，例如体育比赛中的种子选手排名、全国各高校的综合排名、大会嘉宾代表的入场次序等等，都需要对所有对象进行排序。现有偏序关系模型显然不能正确表示和处理这类问题。故须加强偏序关系约束条件，在偏序关系基础上引入全序关系，其具体定义如下：  
【定义6.14】对于偏序集$\langle A,\preccurlyeq\rangle$，如果$𝐴$中任意两个元素${x}$和$\boldsymbol{y}$都是可比的，即$x\preccurlyeq y$或者$y\preccurlyeq x$，则称该偏序关系为全序关系或线序关系，简称为全序或线序。并称$\langle A,\preccurlyeq\rangle$为全序集或线序集，也可称为集合$𝐴$的链。  
由上述定义可知，全序关系必定是偏序关系，偏序关系则不一定是全序关系。  
可用全序的概念定义偏序集$\langle A,\preccurlyeq\rangle$的一些特殊子集合，具体定义如下：  
【定义6.15】设$\langle A,\preccurlyeq\rangle$是一个偏序集，$B$是$𝐴$的任一子集，如果$𝐵$中任意两个元素都是可比的，则称$B$是$𝐴$的一条链，$B$中元素的个数称为该链的长度；反之，如果$B$中任意两个元素都是不可比的，则称 $B$是$𝐴$的一条反链，$B$中元素的个数称为该反链的长度。对于$𝐴$中由单个元素组成的集合，规定它既是链也是反链。  
例如，在偏序集〈{1,2,3,4,5,6,7,8,9}, |〉中，{1,2,4,8}是一条长度为4 的链，{2,4}是一条长度为2 的链，{2,3}则是一条长度为2 的反链。  
偏序集中的链表达了偏序集中部分元素之间存在全序关系，反链则表达了偏序集中部分元素相互之间不存在任何序关系。显然，链表达的是一种串行执行结构，反链表达的是一种并行执行结构。因此，可以使用偏序集中链和反链的概念优化实际问题求解的业务流程，有效提高问题求解的工作效率。  
![](images/18f7caa4d0b707d1ff49eb6f7a547c82b50926bf7ba3ab409aa786a7fcff2f4c.jpg)
图6-22 保险索赔业务流程  
例如，图6-22 是一个关于保险索赔的流程图。图中方框代表处理流程中业务，圆圈代表某种分支选择。将流程中循环抽象成一个单一的结点，如用单个结点𝑇代替流程图中业务$T_{7}$、$T_{8}$及其后的分支结点。由此得到的所有结点构成集合$𝐴$，在该集合元素之间定义如下偏序关系≼：对$\forall x,y\in A$，当且仅当$x=y$或者$𝑦$必须在$x$完成后才能开始时，成立$x\preccurlyeq y$。如此，集合$𝐴$与其上的偏序关系$\preccurlyeq$便构成一个偏序集$\langle A,\preccurlyeq\rangle$，  
图6.23 为其哈斯图。  
考虑偏序集中的链，最长链有4 条，其中2 条分别是：  
$\{T_1,T_2,T_3,S_1,T_6,,S_2,T,T_{10}\}; \{T_1,T_2,T_3,S_1,T_6,,S_2,T_9,T_{10}\}$  
长度都是8。显然，最长链的长度代表了整个流程中必须顺序执行的任务最多有多少个。如果完成每项任务的时间差距不大，那么这种最长链就反映了完成整个任务的最少时间。  
![](images/598fd43b47030dd50e3aa3bc789da0841fc0eb2b823d2c8cd7d0b88fecfb1eab.jpg)
图6-23 业务关系哈斯图  
并行执行业务是提供效率的一种有效途径。在一个偏序集中，如果能够将业务按照不相交的链进行分解，那么这些不相交的链就可在一定程度上并行执行。另一方面，如果把偏序集分解成不相交的反链，那么最长的反链长度则代表了在某个时间区间极大可并行的任务数。下面定理刻画了偏序集的分解与反链之间的关系：  
【定义6.16】设$\langle A,\preccurlyeq\rangle$为偏序集，如果$𝐴$中最长的链长度为$n$，则该偏序集可以分解为$𝑛$条不相交的反链。  
我们知道，对于一个偏序集合$\langle A,\preccurlyeq\rangle$，其任何子集${B}$上的最大值和最小值不一定存在或者不一定都存在。如果我们把偏序集合$\langle A,\preccurlyeq\rangle$的约束条件加强，要求$𝐴$的任何子集$𝐵$上的必须存在最小值，则得到如下良序关系的概念：  
【定义6.17】对于偏序集$\langle A,\preccurlyeq\rangle$，如果$𝐴$的任意一个非空子集$B$中都含有最小元素，则称该偏序关系为良序关系，简称为良序。称$\langle A,\preccurlyeq\rangle$为良序集。  
由上述定义可知，良序关系一定是偏序关系和全序关系，但偏序关系和全序关系不一定是良序关系。例如，实数集合上的小于等于关系显然是全序关系，但不是良序关系，因为开区间(0,1)没有最小值。不过有限的全序集一定是良序集。对于任何一个有限偏序集，可以通过适当排序将其改造成为一个全序集，从而使其成为良序集。",全序关系必定是偏序关系，但偏序关系不一定是全序关系
偏序关系,包含,链,,"前述集合$𝐴$上偏序关系并不保证$𝐴$上的任何两个元素之间都是可比的，也是就是说并不保证任何两个元素之间都存在序关系。然而，在很多场合我们都需要对所关心的所有对象排个次序，例如体育比赛中的种子选手排名、全国各高校的综合排名、大会嘉宾代表的入场次序等等，都需要对所有对象进行排序。现有偏序关系模型显然不能正确表示和处理这类问题。故须加强偏序关系约束条件，在偏序关系基础上引入全序关系，其具体定义如下：  
【定义6.14】对于偏序集$\langle A,\preccurlyeq\rangle$，如果$𝐴$中任意两个元素${x}$和$\boldsymbol{y}$都是可比的，即$x\preccurlyeq y$或者$y\preccurlyeq x$，则称该偏序关系为全序关系或线序关系，简称为全序或线序。并称$\langle A,\preccurlyeq\rangle$为全序集或线序集，也可称为集合$𝐴$的链。  
由上述定义可知，全序关系必定是偏序关系，偏序关系则不一定是全序关系。  
可用全序的概念定义偏序集$\langle A,\preccurlyeq\rangle$的一些特殊子集合，具体定义如下：  
【定义6.15】设$\langle A,\preccurlyeq\rangle$是一个偏序集，$B$是$𝐴$的任一子集，如果$𝐵$中任意两个元素都是可比的，则称$B$是$𝐴$的一条链，$B$中元素的个数称为该链的长度；反之，如果$B$中任意两个元素都是不可比的，则称 $B$是$𝐴$的一条反链，$B$中元素的个数称为该反链的长度。对于$𝐴$中由单个元素组成的集合，规定它既是链也是反链。  
例如，在偏序集〈{1,2,3,4,5,6,7,8,9}, |〉中，{1,2,4,8}是一条长度为4 的链，{2,4}是一条长度为2 的链，{2,3}则是一条长度为2 的反链。  
偏序集中的链表达了偏序集中部分元素之间存在全序关系，反链则表达了偏序集中部分元素相互之间不存在任何序关系。显然，链表达的是一种串行执行结构，反链表达的是一种并行执行结构。因此，可以使用偏序集中链和反链的概念优化实际问题求解的业务流程，有效提高问题求解的工作效率。  
![](images/18f7caa4d0b707d1ff49eb6f7a547c82b50926bf7ba3ab409aa786a7fcff2f4c.jpg)
图6-22 保险索赔业务流程  
例如，图6-22 是一个关于保险索赔的流程图。图中方框代表处理流程中业务，圆圈代表某种分支选择。将流程中循环抽象成一个单一的结点，如用单个结点𝑇代替流程图中业务$T_{7}$、$T_{8}$及其后的分支结点。由此得到的所有结点构成集合$𝐴$，在该集合元素之间定义如下偏序关系≼：对$\forall x,y\in A$，当且仅当$x=y$或者$𝑦$必须在$x$完成后才能开始时，成立$x\preccurlyeq y$。如此，集合$𝐴$与其上的偏序关系$\preccurlyeq$便构成一个偏序集$\langle A,\preccurlyeq\rangle$，  
图6.23 为其哈斯图。  
考虑偏序集中的链，最长链有4 条，其中2 条分别是：  
$\{T_1,T_2,T_3,S_1,T_6,,S_2,T,T_{10}\}; \{T_1,T_2,T_3,S_1,T_6,,S_2,T_9,T_{10}\}$  
长度都是8。显然，最长链的长度代表了整个流程中必须顺序执行的任务最多有多少个。如果完成每项任务的时间差距不大，那么这种最长链就反映了完成整个任务的最少时间。  
![](images/598fd43b47030dd50e3aa3bc789da0841fc0eb2b823d2c8cd7d0b88fecfb1eab.jpg)
图6-23 业务关系哈斯图  
并行执行业务是提供效率的一种有效途径。在一个偏序集中，如果能够将业务按照不相交的链进行分解，那么这些不相交的链就可在一定程度上并行执行。另一方面，如果把偏序集分解成不相交的反链，那么最长的反链长度则代表了在某个时间区间极大可并行的任务数。下面定理刻画了偏序集的分解与反链之间的关系：  
【定义6.16】设$\langle A,\preccurlyeq\rangle$为偏序集，如果$𝐴$中最长的链长度为$n$，则该偏序集可以分解为$𝑛$条不相交的反链。  
我们知道，对于一个偏序集合$\langle A,\preccurlyeq\rangle$，其任何子集${B}$上的最大值和最小值不一定存在或者不一定都存在。如果我们把偏序集合$\langle A,\preccurlyeq\rangle$的约束条件加强，要求$𝐴$的任何子集$𝐵$上的必须存在最小值，则得到如下良序关系的概念：  
【定义6.17】对于偏序集$\langle A,\preccurlyeq\rangle$，如果$𝐴$的任意一个非空子集$B$中都含有最小元素，则称该偏序关系为良序关系，简称为良序。称$\langle A,\preccurlyeq\rangle$为良序集。  
由上述定义可知，良序关系一定是偏序关系和全序关系，但偏序关系和全序关系不一定是良序关系。例如，实数集合上的小于等于关系显然是全序关系，但不是良序关系，因为开区间(0,1)没有最小值。不过有限的全序集一定是良序集。对于任何一个有限偏序集，可以通过适当排序将其改造成为一个全序集，从而使其成为良序集。",偏序集中的链表达了偏序集中部分元素之间存在全序关系
偏序关系,包含,反链,,"前述集合$𝐴$上偏序关系并不保证$𝐴$上的任何两个元素之间都是可比的，也是就是说并不保证任何两个元素之间都存在序关系。然而，在很多场合我们都需要对所关心的所有对象排个次序，例如体育比赛中的种子选手排名、全国各高校的综合排名、大会嘉宾代表的入场次序等等，都需要对所有对象进行排序。现有偏序关系模型显然不能正确表示和处理这类问题。故须加强偏序关系约束条件，在偏序关系基础上引入全序关系，其具体定义如下：  
【定义6.14】对于偏序集$\langle A,\preccurlyeq\rangle$，如果$𝐴$中任意两个元素${x}$和$\boldsymbol{y}$都是可比的，即$x\preccurlyeq y$或者$y\preccurlyeq x$，则称该偏序关系为全序关系或线序关系，简称为全序或线序。并称$\langle A,\preccurlyeq\rangle$为全序集或线序集，也可称为集合$𝐴$的链。  
由上述定义可知，全序关系必定是偏序关系，偏序关系则不一定是全序关系。  
可用全序的概念定义偏序集$\langle A,\preccurlyeq\rangle$的一些特殊子集合，具体定义如下：  
【定义6.15】设$\langle A,\preccurlyeq\rangle$是一个偏序集，$B$是$𝐴$的任一子集，如果$𝐵$中任意两个元素都是可比的，则称$B$是$𝐴$的一条链，$B$中元素的个数称为该链的长度；反之，如果$B$中任意两个元素都是不可比的，则称 $B$是$𝐴$的一条反链，$B$中元素的个数称为该反链的长度。对于$𝐴$中由单个元素组成的集合，规定它既是链也是反链。  
例如，在偏序集〈{1,2,3,4,5,6,7,8,9}, |〉中，{1,2,4,8}是一条长度为4 的链，{2,4}是一条长度为2 的链，{2,3}则是一条长度为2 的反链。  
偏序集中的链表达了偏序集中部分元素之间存在全序关系，反链则表达了偏序集中部分元素相互之间不存在任何序关系。显然，链表达的是一种串行执行结构，反链表达的是一种并行执行结构。因此，可以使用偏序集中链和反链的概念优化实际问题求解的业务流程，有效提高问题求解的工作效率。  
![](images/18f7caa4d0b707d1ff49eb6f7a547c82b50926bf7ba3ab409aa786a7fcff2f4c.jpg)
图6-22 保险索赔业务流程  
例如，图6-22 是一个关于保险索赔的流程图。图中方框代表处理流程中业务，圆圈代表某种分支选择。将流程中循环抽象成一个单一的结点，如用单个结点𝑇代替流程图中业务$T_{7}$、$T_{8}$及其后的分支结点。由此得到的所有结点构成集合$𝐴$，在该集合元素之间定义如下偏序关系≼：对$\forall x,y\in A$，当且仅当$x=y$或者$𝑦$必须在$x$完成后才能开始时，成立$x\preccurlyeq y$。如此，集合$𝐴$与其上的偏序关系$\preccurlyeq$便构成一个偏序集$\langle A,\preccurlyeq\rangle$，  
图6.23 为其哈斯图。  
考虑偏序集中的链，最长链有4 条，其中2 条分别是：  
$\{T_1,T_2,T_3,S_1,T_6,,S_2,T,T_{10}\}; \{T_1,T_2,T_3,S_1,T_6,,S_2,T_9,T_{10}\}$  
长度都是8。显然，最长链的长度代表了整个流程中必须顺序执行的任务最多有多少个。如果完成每项任务的时间差距不大，那么这种最长链就反映了完成整个任务的最少时间。  
![](images/598fd43b47030dd50e3aa3bc789da0841fc0eb2b823d2c8cd7d0b88fecfb1eab.jpg)
图6-23 业务关系哈斯图  
并行执行业务是提供效率的一种有效途径。在一个偏序集中，如果能够将业务按照不相交的链进行分解，那么这些不相交的链就可在一定程度上并行执行。另一方面，如果把偏序集分解成不相交的反链，那么最长的反链长度则代表了在某个时间区间极大可并行的任务数。下面定理刻画了偏序集的分解与反链之间的关系：  
【定义6.16】设$\langle A,\preccurlyeq\rangle$为偏序集，如果$𝐴$中最长的链长度为$n$，则该偏序集可以分解为$𝑛$条不相交的反链。  
我们知道，对于一个偏序集合$\langle A,\preccurlyeq\rangle$，其任何子集${B}$上的最大值和最小值不一定存在或者不一定都存在。如果我们把偏序集合$\langle A,\preccurlyeq\rangle$的约束条件加强，要求$𝐴$的任何子集$𝐵$上的必须存在最小值，则得到如下良序关系的概念：  
【定义6.17】对于偏序集$\langle A,\preccurlyeq\rangle$，如果$𝐴$的任意一个非空子集$B$中都含有最小元素，则称该偏序关系为良序关系，简称为良序。称$\langle A,\preccurlyeq\rangle$为良序集。  
由上述定义可知，良序关系一定是偏序关系和全序关系，但偏序关系和全序关系不一定是良序关系。例如，实数集合上的小于等于关系显然是全序关系，但不是良序关系，因为开区间(0,1)没有最小值。不过有限的全序集一定是良序集。对于任何一个有限偏序集，可以通过适当排序将其改造成为一个全序集，从而使其成为良序集。",偏序集中的反链表达了偏序集中部分元素相互之间不存在任何序关系
全序关系,等价,链,,"前述集合$𝐴$上偏序关系并不保证$𝐴$上的任何两个元素之间都是可比的，也是就是说并不保证任何两个元素之间都存在序关系。然而，在很多场合我们都需要对所关心的所有对象排个次序，例如体育比赛中的种子选手排名、全国各高校的综合排名、大会嘉宾代表的入场次序等等，都需要对所有对象进行排序。现有偏序关系模型显然不能正确表示和处理这类问题。故须加强偏序关系约束条件，在偏序关系基础上引入全序关系，其具体定义如下：  
【定义6.14】对于偏序集$\langle A,\preccurlyeq\rangle$，如果$𝐴$中任意两个元素${x}$和$\boldsymbol{y}$都是可比的，即$x\preccurlyeq y$或者$y\preccurlyeq x$，则称该偏序关系为全序关系或线序关系，简称为全序或线序。并称$\langle A,\preccurlyeq\rangle$为全序集或线序集，也可称为集合$𝐴$的链。  
由上述定义可知，全序关系必定是偏序关系，偏序关系则不一定是全序关系。  
可用全序的概念定义偏序集$\langle A,\preccurlyeq\rangle$的一些特殊子集合，具体定义如下：  
【定义6.15】设$\langle A,\preccurlyeq\rangle$是一个偏序集，$B$是$𝐴$的任一子集，如果$𝐵$中任意两个元素都是可比的，则称$B$是$𝐴$的一条链，$B$中元素的个数称为该链的长度；反之，如果$B$中任意两个元素都是不可比的，则称 $B$是$𝐴$的一条反链，$B$中元素的个数称为该反链的长度。对于$𝐴$中由单个元素组成的集合，规定它既是链也是反链。  
例如，在偏序集〈{1,2,3,4,5,6,7,8,9}, |〉中，{1,2,4,8}是一条长度为4 的链，{2,4}是一条长度为2 的链，{2,3}则是一条长度为2 的反链。  
偏序集中的链表达了偏序集中部分元素之间存在全序关系，反链则表达了偏序集中部分元素相互之间不存在任何序关系。显然，链表达的是一种串行执行结构，反链表达的是一种并行执行结构。因此，可以使用偏序集中链和反链的概念优化实际问题求解的业务流程，有效提高问题求解的工作效率。  
![](images/18f7caa4d0b707d1ff49eb6f7a547c82b50926bf7ba3ab409aa786a7fcff2f4c.jpg)
图6-22 保险索赔业务流程  
例如，图6-22 是一个关于保险索赔的流程图。图中方框代表处理流程中业务，圆圈代表某种分支选择。将流程中循环抽象成一个单一的结点，如用单个结点𝑇代替流程图中业务$T_{7}$、$T_{8}$及其后的分支结点。由此得到的所有结点构成集合$𝐴$，在该集合元素之间定义如下偏序关系≼：对$\forall x,y\in A$，当且仅当$x=y$或者$𝑦$必须在$x$完成后才能开始时，成立$x\preccurlyeq y$。如此，集合$𝐴$与其上的偏序关系$\preccurlyeq$便构成一个偏序集$\langle A,\preccurlyeq\rangle$，  
图6.23 为其哈斯图。  
考虑偏序集中的链，最长链有4 条，其中2 条分别是：  
$\{T_1,T_2,T_3,S_1,T_6,,S_2,T,T_{10}\}; \{T_1,T_2,T_3,S_1,T_6,,S_2,T_9,T_{10}\}$  
长度都是8。显然，最长链的长度代表了整个流程中必须顺序执行的任务最多有多少个。如果完成每项任务的时间差距不大，那么这种最长链就反映了完成整个任务的最少时间。  
![](images/598fd43b47030dd50e3aa3bc789da0841fc0eb2b823d2c8cd7d0b88fecfb1eab.jpg)
图6-23 业务关系哈斯图  
并行执行业务是提供效率的一种有效途径。在一个偏序集中，如果能够将业务按照不相交的链进行分解，那么这些不相交的链就可在一定程度上并行执行。另一方面，如果把偏序集分解成不相交的反链，那么最长的反链长度则代表了在某个时间区间极大可并行的任务数。下面定理刻画了偏序集的分解与反链之间的关系：  
【定义6.16】设$\langle A,\preccurlyeq\rangle$为偏序集，如果$𝐴$中最长的链长度为$n$，则该偏序集可以分解为$𝑛$条不相交的反链。  
我们知道，对于一个偏序集合$\langle A,\preccurlyeq\rangle$，其任何子集${B}$上的最大值和最小值不一定存在或者不一定都存在。如果我们把偏序集合$\langle A,\preccurlyeq\rangle$的约束条件加强，要求$𝐴$的任何子集$𝐵$上的必须存在最小值，则得到如下良序关系的概念：  
【定义6.17】对于偏序集$\langle A,\preccurlyeq\rangle$，如果$𝐴$的任意一个非空子集$B$中都含有最小元素，则称该偏序关系为良序关系，简称为良序。称$\langle A,\preccurlyeq\rangle$为良序集。  
由上述定义可知，良序关系一定是偏序关系和全序关系，但偏序关系和全序关系不一定是良序关系。例如，实数集合上的小于等于关系显然是全序关系，但不是良序关系，因为开区间(0,1)没有最小值。不过有限的全序集一定是良序集。对于任何一个有限偏序集，可以通过适当排序将其改造成为一个全序集，从而使其成为良序集。",全序集或线序集也可称为集合的链
良序关系,包含,偏序关系,,"前述集合$𝐴$上偏序关系并不保证$𝐴$上的任何两个元素之间都是可比的，也是就是说并不保证任何两个元素之间都存在序关系。然而，在很多场合我们都需要对所关心的所有对象排个次序，例如体育比赛中的种子选手排名、全国各高校的综合排名、大会嘉宾代表的入场次序等等，都需要对所有对象进行排序。现有偏序关系模型显然不能正确表示和处理这类问题。故须加强偏序关系约束条件，在偏序关系基础上引入全序关系，其具体定义如下：  
【定义6.14】对于偏序集$\langle A,\preccurlyeq\rangle$，如果$𝐴$中任意两个元素${x}$和$\boldsymbol{y}$都是可比的，即$x\preccurlyeq y$或者$y\preccurlyeq x$，则称该偏序关系为全序关系或线序关系，简称为全序或线序。并称$\langle A,\preccurlyeq\rangle$为全序集或线序集，也可称为集合$𝐴$的链。  
由上述定义可知，全序关系必定是偏序关系，偏序关系则不一定是全序关系。  
可用全序的概念定义偏序集$\langle A,\preccurlyeq\rangle$的一些特殊子集合，具体定义如下：  
【定义6.15】设$\langle A,\preccurlyeq\rangle$是一个偏序集，$B$是$𝐴$的任一子集，如果$𝐵$中任意两个元素都是可比的，则称$B$是$𝐴$的一条链，$B$中元素的个数称为该链的长度；反之，如果$B$中任意两个元素都是不可比的，则称 $B$是$𝐴$的一条反链，$B$中元素的个数称为该反链的长度。对于$𝐴$中由单个元素组成的集合，规定它既是链也是反链。  
例如，在偏序集〈{1,2,3,4,5,6,7,8,9}, |〉中，{1,2,4,8}是一条长度为4 的链，{2,4}是一条长度为2 的链，{2,3}则是一条长度为2 的反链。  
偏序集中的链表达了偏序集中部分元素之间存在全序关系，反链则表达了偏序集中部分元素相互之间不存在任何序关系。显然，链表达的是一种串行执行结构，反链表达的是一种并行执行结构。因此，可以使用偏序集中链和反链的概念优化实际问题求解的业务流程，有效提高问题求解的工作效率。  
![](images/18f7caa4d0b707d1ff49eb6f7a547c82b50926bf7ba3ab409aa786a7fcff2f4c.jpg)
图6-22 保险索赔业务流程  
例如，图6-22 是一个关于保险索赔的流程图。图中方框代表处理流程中业务，圆圈代表某种分支选择。将流程中循环抽象成一个单一的结点，如用单个结点𝑇代替流程图中业务$T_{7}$、$T_{8}$及其后的分支结点。由此得到的所有结点构成集合$𝐴$，在该集合元素之间定义如下偏序关系≼：对$\forall x,y\in A$，当且仅当$x=y$或者$𝑦$必须在$x$完成后才能开始时，成立$x\preccurlyeq y$。如此，集合$𝐴$与其上的偏序关系$\preccurlyeq$便构成一个偏序集$\langle A,\preccurlyeq\rangle$，  
图6.23 为其哈斯图。  
考虑偏序集中的链，最长链有4 条，其中2 条分别是：  
$\{T_1,T_2,T_3,S_1,T_6,,S_2,T,T_{10}\}; \{T_1,T_2,T_3,S_1,T_6,,S_2,T_9,T_{10}\}$  
长度都是8。显然，最长链的长度代表了整个流程中必须顺序执行的任务最多有多少个。如果完成每项任务的时间差距不大，那么这种最长链就反映了完成整个任务的最少时间。  
![](images/598fd43b47030dd50e3aa3bc789da0841fc0eb2b823d2c8cd7d0b88fecfb1eab.jpg)
图6-23 业务关系哈斯图  
并行执行业务是提供效率的一种有效途径。在一个偏序集中，如果能够将业务按照不相交的链进行分解，那么这些不相交的链就可在一定程度上并行执行。另一方面，如果把偏序集分解成不相交的反链，那么最长的反链长度则代表了在某个时间区间极大可并行的任务数。下面定理刻画了偏序集的分解与反链之间的关系：  
【定义6.16】设$\langle A,\preccurlyeq\rangle$为偏序集，如果$𝐴$中最长的链长度为$n$，则该偏序集可以分解为$𝑛$条不相交的反链。  
我们知道，对于一个偏序集合$\langle A,\preccurlyeq\rangle$，其任何子集${B}$上的最大值和最小值不一定存在或者不一定都存在。如果我们把偏序集合$\langle A,\preccurlyeq\rangle$的约束条件加强，要求$𝐴$的任何子集$𝐵$上的必须存在最小值，则得到如下良序关系的概念：  
【定义6.17】对于偏序集$\langle A,\preccurlyeq\rangle$，如果$𝐴$的任意一个非空子集$B$中都含有最小元素，则称该偏序关系为良序关系，简称为良序。称$\langle A,\preccurlyeq\rangle$为良序集。  
由上述定义可知，良序关系一定是偏序关系和全序关系，但偏序关系和全序关系不一定是良序关系。例如，实数集合上的小于等于关系显然是全序关系，但不是良序关系，因为开区间(0,1)没有最小值。不过有限的全序集一定是良序集。对于任何一个有限偏序集，可以通过适当排序将其改造成为一个全序集，从而使其成为良序集。",良序关系一定是偏序关系
良序关系,包含,全序关系,,"前述集合$𝐴$上偏序关系并不保证$𝐴$上的任何两个元素之间都是可比的，也是就是说并不保证任何两个元素之间都存在序关系。然而，在很多场合我们都需要对所关心的所有对象排个次序，例如体育比赛中的种子选手排名、全国各高校的综合排名、大会嘉宾代表的入场次序等等，都需要对所有对象进行排序。现有偏序关系模型显然不能正确表示和处理这类问题。故须加强偏序关系约束条件，在偏序关系基础上引入全序关系，其具体定义如下：  
【定义6.14】对于偏序集$\langle A,\preccurlyeq\rangle$，如果$𝐴$中任意两个元素${x}$和$\boldsymbol{y}$都是可比的，即$x\preccurlyeq y$或者$y\preccurlyeq x$，则称该偏序关系为全序关系或线序关系，简称为全序或线序。并称$\langle A,\preccurlyeq\rangle$为全序集或线序集，也可称为集合$𝐴$的链。  
由上述定义可知，全序关系必定是偏序关系，偏序关系则不一定是全序关系。  
可用全序的概念定义偏序集$\langle A,\preccurlyeq\rangle$的一些特殊子集合，具体定义如下：  
【定义6.15】设$\langle A,\preccurlyeq\rangle$是一个偏序集，$B$是$𝐴$的任一子集，如果$𝐵$中任意两个元素都是可比的，则称$B$是$𝐴$的一条链，$B$中元素的个数称为该链的长度；反之，如果$B$中任意两个元素都是不可比的，则称 $B$是$𝐴$的一条反链，$B$中元素的个数称为该反链的长度。对于$𝐴$中由单个元素组成的集合，规定它既是链也是反链。  
例如，在偏序集〈{1,2,3,4,5,6,7,8,9}, |〉中，{1,2,4,8}是一条长度为4 的链，{2,4}是一条长度为2 的链，{2,3}则是一条长度为2 的反链。  
偏序集中的链表达了偏序集中部分元素之间存在全序关系，反链则表达了偏序集中部分元素相互之间不存在任何序关系。显然，链表达的是一种串行执行结构，反链表达的是一种并行执行结构。因此，可以使用偏序集中链和反链的概念优化实际问题求解的业务流程，有效提高问题求解的工作效率。  
![](images/18f7caa4d0b707d1ff49eb6f7a547c82b50926bf7ba3ab409aa786a7fcff2f4c.jpg)
图6-22 保险索赔业务流程  
例如，图6-22 是一个关于保险索赔的流程图。图中方框代表处理流程中业务，圆圈代表某种分支选择。将流程中循环抽象成一个单一的结点，如用单个结点𝑇代替流程图中业务$T_{7}$、$T_{8}$及其后的分支结点。由此得到的所有结点构成集合$𝐴$，在该集合元素之间定义如下偏序关系≼：对$\forall x,y\in A$，当且仅当$x=y$或者$𝑦$必须在$x$完成后才能开始时，成立$x\preccurlyeq y$。如此，集合$𝐴$与其上的偏序关系$\preccurlyeq$便构成一个偏序集$\langle A,\preccurlyeq\rangle$，  
图6.23 为其哈斯图。  
考虑偏序集中的链，最长链有4 条，其中2 条分别是：  
$\{T_1,T_2,T_3,S_1,T_6,,S_2,T,T_{10}\}; \{T_1,T_2,T_3,S_1,T_6,,S_2,T_9,T_{10}\}$  
长度都是8。显然，最长链的长度代表了整个流程中必须顺序执行的任务最多有多少个。如果完成每项任务的时间差距不大，那么这种最长链就反映了完成整个任务的最少时间。  
![](images/598fd43b47030dd50e3aa3bc789da0841fc0eb2b823d2c8cd7d0b88fecfb1eab.jpg)
图6-23 业务关系哈斯图  
并行执行业务是提供效率的一种有效途径。在一个偏序集中，如果能够将业务按照不相交的链进行分解，那么这些不相交的链就可在一定程度上并行执行。另一方面，如果把偏序集分解成不相交的反链，那么最长的反链长度则代表了在某个时间区间极大可并行的任务数。下面定理刻画了偏序集的分解与反链之间的关系：  
【定义6.16】设$\langle A,\preccurlyeq\rangle$为偏序集，如果$𝐴$中最长的链长度为$n$，则该偏序集可以分解为$𝑛$条不相交的反链。  
我们知道，对于一个偏序集合$\langle A,\preccurlyeq\rangle$，其任何子集${B}$上的最大值和最小值不一定存在或者不一定都存在。如果我们把偏序集合$\langle A,\preccurlyeq\rangle$的约束条件加强，要求$𝐴$的任何子集$𝐵$上的必须存在最小值，则得到如下良序关系的概念：  
【定义6.17】对于偏序集$\langle A,\preccurlyeq\rangle$，如果$𝐴$的任意一个非空子集$B$中都含有最小元素，则称该偏序关系为良序关系，简称为良序。称$\langle A,\preccurlyeq\rangle$为良序集。  
由上述定义可知，良序关系一定是偏序关系和全序关系，但偏序关系和全序关系不一定是良序关系。例如，实数集合上的小于等于关系显然是全序关系，但不是良序关系，因为开区间(0,1)没有最小值。不过有限的全序集一定是良序集。对于任何一个有限偏序集，可以通过适当排序将其改造成为一个全序集，从而使其成为良序集。",良序关系一定是全序关系
上近似集合,定义,下近似集合,,"现实世界中很多对象群体的边界是很模糊或者不确定的，例如，对于“中年人”这样的群体，怎样用集合或者其它数学工具进行描述？如果将“中年人”这个群体看出是一个集合$𝑆$的话，则$𝑆$就不是经典意义下的集合，因为其成员不确定。事实上，可以使用两个经典集合来刻画$𝑆$，一个叫做$𝑆$的上近似集合${S}\uparrow$，一个叫做$𝑆$的下近似集合$ S\downarrow$，让前者$𝑆↑$尽可能的小，后者$𝑆↑$尽可能的大。当$𝑆↑$能够等同于$𝑆↓$时,$S$就是经典集合，当$𝑆↑$不能够等同于$𝑆↓$时，则称$𝑆$是粗糙集或粗集。例如，可以用$S\uparrow=\{x|25\le x\le60\}$，即用25 岁至60 岁的人的集合，表示“中年人的集合”；还可以用$S\downarrow=\{x|30\le x\le50\}$，即用30 岁至50 岁的人的集合，表示“中年人的集合”。由于无法构造适当的“中年人的集合”的上下近似$S\uparrow=S\downarrow$，因此，“中年人的集合”$𝑆$是一个粗糙集。  
那么如何用准确的数学语言来定义粗糙集呢？下面通过等价关系给出粗集准确的数学定义。设$U$是个体域（或全集），$R$是$U$上的等价关系，则可由$R$导出的$U$的一个划分，如图$6-$$24\left(a\right)$所示，每个方格表示划分的一个单元，也就是一个$ R$等价类。  
如图$6–24\left(b\right)$所示，若$𝑆$是粗糙集，则$𝑆$的上下近似分别是两个粗线条勾画出的多边形，其中$S\uparrow$由与$𝑆$交不空方格的并组成，$S\downarrow$由包含于$𝑆$的方格并组成。  
![](images/05225fe2f04f5f432dc9b2bbf25b62263d90d0d724be9df376f08ea318717259.jpg)  
通过以上分析，就可以给出粗糙集𝑆的定义：  
【定义6.18】设$U$是个体域(或全集)，$R$是$U$上的等价关系，已知$𝑆$的成员均在$U$中。令： ${\begin{array}{l l}{S\uparrow=\cup\,\{[x]_{R}|[x]_{R}\cap S\neq\emptyset\}}&{;\;\;S\downarrow=\cup\,\{[x]_{R}|[x]_{R}\subseteq S\}}\end{array}}\quad\text{(6-4)}$  
那么称$S\uparrow$为$𝑆$的上近似，$S\downarrow$为$𝑆$的下近似。当$\textit{S}\uparrow=\textit{S}$↓时，$S$即是$U$的子集；当$S\uparrow\ne\textit{S}\downarrow$时，称 $𝑆$ 是 $U$ 的粗糙子集，简称为粗糙集或粗集。  
例如，表是考生情况调查表，其中$U$为被调查对象，$R$为高考成绩$(A-$优，$B-$良，$C-$中，$D-$差)；$X$为升学情况($+$为上，$/$为未上)。可根据高考成绩和升学状况进行分类，并可分别计算出下近似集、上近似集。  
表6-3 对集合𝑈的两种划分
![](images/23b7c96f86908a1723f3af9fc2fde337caca13329476de93665a25a8e36ee553.jpg)  
![](images/1cdfc65fbfddc11bcd85c455f6521676d2bf7ff363efa7f28d82ea21a3e04ed5.jpg)  
事实上，可分别按成绩和升学对$U$进行划分：  
$U/R=\{\{1,6\},\{2\},\{3,5\},\{4\}\}=\{Y_{1},Y_{2},Y_{3},Y_{4}\};\quad U/X=\{\{2,3,5,6\},\{1,4\}\}=\{X_{1},X_{2}\}$ 分别得到粗糙集$S$的上近似和下近似集合：  
$$
S(X_{1})\uparrow=Y_{1}\cup Y_{2}\cup Y_{3}=\{1,2,3,5,6\}\;\;;\;\;\;S(X_{2})\uparrow=Y_{1}\cup Y_{4}=\{1,4,6\};
$$  
$$
S(X_{1})\downarrow=Y_{2}\cup Y_{3}=\{2,3,5\}\;\;;\;\;\;S(X_{2})\downarrow=\;\;Y_{4}=\{4\}。
$$  
粗糙集可以表示含义模糊且不太确定的概念，大大拓广了经典集合的概念和应用范围，更为重要的是，粗糙集可由经典集合借助等价关系进行定义，具有坚实的理论基础。目前，粗糙集理论在模式识别、数据挖掘等技术领域得到广泛应用。",上近似集合和下近似集合用于刻画粗糙集，上近似集合尽可能小，下近似集合尽可能大
粗集,组成,上近似集合,,"现实世界中很多对象群体的边界是很模糊或者不确定的，例如，对于“中年人”这样的群体，怎样用集合或者其它数学工具进行描述？如果将“中年人”这个群体看出是一个集合$𝑆$的话，则$𝑆$就不是经典意义下的集合，因为其成员不确定。事实上，可以使用两个经典集合来刻画$𝑆$，一个叫做$𝑆$的上近似集合${S}\uparrow$，一个叫做$𝑆$的下近似集合$ S\downarrow$，让前者$𝑆↑$尽可能的小，后者$𝑆↑$尽可能的大。当$𝑆↑$能够等同于$𝑆↓$时,$S$就是经典集合，当$𝑆↑$不能够等同于$𝑆↓$时，则称$𝑆$是粗糙集或粗集。例如，可以用$S\uparrow=\{x|25\le x\le60\}$，即用25 岁至60 岁的人的集合，表示“中年人的集合”；还可以用$S\downarrow=\{x|30\le x\le50\}$，即用30 岁至50 岁的人的集合，表示“中年人的集合”。由于无法构造适当的“中年人的集合”的上下近似$S\uparrow=S\downarrow$，因此，“中年人的集合”$𝑆$是一个粗糙集。  
那么如何用准确的数学语言来定义粗糙集呢？下面通过等价关系给出粗集准确的数学定义。设$U$是个体域（或全集），$R$是$U$上的等价关系，则可由$R$导出的$U$的一个划分，如图$6-$$24\left(a\right)$所示，每个方格表示划分的一个单元，也就是一个$ R$等价类。  
如图$6–24\left(b\right)$所示，若$𝑆$是粗糙集，则$𝑆$的上下近似分别是两个粗线条勾画出的多边形，其中$S\uparrow$由与$𝑆$交不空方格的并组成，$S\downarrow$由包含于$𝑆$的方格并组成。  
![](images/05225fe2f04f5f432dc9b2bbf25b62263d90d0d724be9df376f08ea318717259.jpg)  
通过以上分析，就可以给出粗糙集𝑆的定义：  
【定义6.18】设$U$是个体域(或全集)，$R$是$U$上的等价关系，已知$𝑆$的成员均在$U$中。令： ${\begin{array}{l l}{S\uparrow=\cup\,\{[x]_{R}|[x]_{R}\cap S\neq\emptyset\}}&{;\;\;S\downarrow=\cup\,\{[x]_{R}|[x]_{R}\subseteq S\}}\end{array}}\quad\text{(6-4)}$  
那么称$S\uparrow$为$𝑆$的上近似，$S\downarrow$为$𝑆$的下近似。当$\textit{S}\uparrow=\textit{S}$↓时，$S$即是$U$的子集；当$S\uparrow\ne\textit{S}\downarrow$时，称 $𝑆$ 是 $U$ 的粗糙子集，简称为粗糙集或粗集。  
例如，表是考生情况调查表，其中$U$为被调查对象，$R$为高考成绩$(A-$优，$B-$良，$C-$中，$D-$差)；$X$为升学情况($+$为上，$/$为未上)。可根据高考成绩和升学状况进行分类，并可分别计算出下近似集、上近似集。  
表6-3 对集合𝑈的两种划分
![](images/23b7c96f86908a1723f3af9fc2fde337caca13329476de93665a25a8e36ee553.jpg)  
![](images/1cdfc65fbfddc11bcd85c455f6521676d2bf7ff363efa7f28d82ea21a3e04ed5.jpg)  
事实上，可分别按成绩和升学对$U$进行划分：  
$U/R=\{\{1,6\},\{2\},\{3,5\},\{4\}\}=\{Y_{1},Y_{2},Y_{3},Y_{4}\};\quad U/X=\{\{2,3,5,6\},\{1,4\}\}=\{X_{1},X_{2}\}$ 分别得到粗糙集$S$的上近似和下近似集合：  
$$
S(X_{1})\uparrow=Y_{1}\cup Y_{2}\cup Y_{3}=\{1,2,3,5,6\}\;\;;\;\;\;S(X_{2})\uparrow=Y_{1}\cup Y_{4}=\{1,4,6\};
$$  
$$
S(X_{1})\downarrow=Y_{2}\cup Y_{3}=\{2,3,5\}\;\;;\;\;\;S(X_{2})\downarrow=\;\;Y_{4}=\{4\}。
$$  
粗糙集可以表示含义模糊且不太确定的概念，大大拓广了经典集合的概念和应用范围，更为重要的是，粗糙集可由经典集合借助等价关系进行定义，具有坚实的理论基础。目前，粗糙集理论在模式识别、数据挖掘等技术领域得到广泛应用。",粗集的上近似集合由与粗集交不空的等价类并组成
粗集,组成,下近似集合,,"现实世界中很多对象群体的边界是很模糊或者不确定的，例如，对于“中年人”这样的群体，怎样用集合或者其它数学工具进行描述？如果将“中年人”这个群体看出是一个集合$𝑆$的话，则$𝑆$就不是经典意义下的集合，因为其成员不确定。事实上，可以使用两个经典集合来刻画$𝑆$，一个叫做$𝑆$的上近似集合${S}\uparrow$，一个叫做$𝑆$的下近似集合$ S\downarrow$，让前者$𝑆↑$尽可能的小，后者$𝑆↑$尽可能的大。当$𝑆↑$能够等同于$𝑆↓$时,$S$就是经典集合，当$𝑆↑$不能够等同于$𝑆↓$时，则称$𝑆$是粗糙集或粗集。例如，可以用$S\uparrow=\{x|25\le x\le60\}$，即用25 岁至60 岁的人的集合，表示“中年人的集合”；还可以用$S\downarrow=\{x|30\le x\le50\}$，即用30 岁至50 岁的人的集合，表示“中年人的集合”。由于无法构造适当的“中年人的集合”的上下近似$S\uparrow=S\downarrow$，因此，“中年人的集合”$𝑆$是一个粗糙集。  
那么如何用准确的数学语言来定义粗糙集呢？下面通过等价关系给出粗集准确的数学定义。设$U$是个体域（或全集），$R$是$U$上的等价关系，则可由$R$导出的$U$的一个划分，如图$6-$$24\left(a\right)$所示，每个方格表示划分的一个单元，也就是一个$ R$等价类。  
如图$6–24\left(b\right)$所示，若$𝑆$是粗糙集，则$𝑆$的上下近似分别是两个粗线条勾画出的多边形，其中$S\uparrow$由与$𝑆$交不空方格的并组成，$S\downarrow$由包含于$𝑆$的方格并组成。  
![](images/05225fe2f04f5f432dc9b2bbf25b62263d90d0d724be9df376f08ea318717259.jpg)  
通过以上分析，就可以给出粗糙集𝑆的定义：  
【定义6.18】设$U$是个体域(或全集)，$R$是$U$上的等价关系，已知$𝑆$的成员均在$U$中。令： ${\begin{array}{l l}{S\uparrow=\cup\,\{[x]_{R}|[x]_{R}\cap S\neq\emptyset\}}&{;\;\;S\downarrow=\cup\,\{[x]_{R}|[x]_{R}\subseteq S\}}\end{array}}\quad\text{(6-4)}$  
那么称$S\uparrow$为$𝑆$的上近似，$S\downarrow$为$𝑆$的下近似。当$\textit{S}\uparrow=\textit{S}$↓时，$S$即是$U$的子集；当$S\uparrow\ne\textit{S}\downarrow$时，称 $𝑆$ 是 $U$ 的粗糙子集，简称为粗糙集或粗集。  
例如，表是考生情况调查表，其中$U$为被调查对象，$R$为高考成绩$(A-$优，$B-$良，$C-$中，$D-$差)；$X$为升学情况($+$为上，$/$为未上)。可根据高考成绩和升学状况进行分类，并可分别计算出下近似集、上近似集。  
表6-3 对集合𝑈的两种划分
![](images/23b7c96f86908a1723f3af9fc2fde337caca13329476de93665a25a8e36ee553.jpg)  
![](images/1cdfc65fbfddc11bcd85c455f6521676d2bf7ff363efa7f28d82ea21a3e04ed5.jpg)  
事实上，可分别按成绩和升学对$U$进行划分：  
$U/R=\{\{1,6\},\{2\},\{3,5\},\{4\}\}=\{Y_{1},Y_{2},Y_{3},Y_{4}\};\quad U/X=\{\{2,3,5,6\},\{1,4\}\}=\{X_{1},X_{2}\}$ 分别得到粗糙集$S$的上近似和下近似集合：  
$$
S(X_{1})\uparrow=Y_{1}\cup Y_{2}\cup Y_{3}=\{1,2,3,5,6\}\;\;;\;\;\;S(X_{2})\uparrow=Y_{1}\cup Y_{4}=\{1,4,6\};
$$  
$$
S(X_{1})\downarrow=Y_{2}\cup Y_{3}=\{2,3,5\}\;\;;\;\;\;S(X_{2})\downarrow=\;\;Y_{4}=\{4\}。
$$  
粗糙集可以表示含义模糊且不太确定的概念，大大拓广了经典集合的概念和应用范围，更为重要的是，粗糙集可由经典集合借助等价关系进行定义，具有坚实的理论基础。目前，粗糙集理论在模式识别、数据挖掘等技术领域得到广泛应用。",粗集的下近似集合由包含于粗集的等价类并组成
等价关系,定义,粗集,,"现实世界中很多对象群体的边界是很模糊或者不确定的，例如，对于“中年人”这样的群体，怎样用集合或者其它数学工具进行描述？如果将“中年人”这个群体看出是一个集合$𝑆$的话，则$𝑆$就不是经典意义下的集合，因为其成员不确定。事实上，可以使用两个经典集合来刻画$𝑆$，一个叫做$𝑆$的上近似集合${S}\uparrow$，一个叫做$𝑆$的下近似集合$ S\downarrow$，让前者$𝑆↑$尽可能的小，后者$𝑆↑$尽可能的大。当$𝑆↑$能够等同于$𝑆↓$时,$S$就是经典集合，当$𝑆↑$不能够等同于$𝑆↓$时，则称$𝑆$是粗糙集或粗集。例如，可以用$S\uparrow=\{x|25\le x\le60\}$，即用25 岁至60 岁的人的集合，表示“中年人的集合”；还可以用$S\downarrow=\{x|30\le x\le50\}$，即用30 岁至50 岁的人的集合，表示“中年人的集合”。由于无法构造适当的“中年人的集合”的上下近似$S\uparrow=S\downarrow$，因此，“中年人的集合”$𝑆$是一个粗糙集。  
那么如何用准确的数学语言来定义粗糙集呢？下面通过等价关系给出粗集准确的数学定义。设$U$是个体域（或全集），$R$是$U$上的等价关系，则可由$R$导出的$U$的一个划分，如图$6-$$24\left(a\right)$所示，每个方格表示划分的一个单元，也就是一个$ R$等价类。  
如图$6–24\left(b\right)$所示，若$𝑆$是粗糙集，则$𝑆$的上下近似分别是两个粗线条勾画出的多边形，其中$S\uparrow$由与$𝑆$交不空方格的并组成，$S\downarrow$由包含于$𝑆$的方格并组成。  
![](images/05225fe2f04f5f432dc9b2bbf25b62263d90d0d724be9df376f08ea318717259.jpg)  
通过以上分析，就可以给出粗糙集𝑆的定义：  
【定义6.18】设$U$是个体域(或全集)，$R$是$U$上的等价关系，已知$𝑆$的成员均在$U$中。令： ${\begin{array}{l l}{S\uparrow=\cup\,\{[x]_{R}|[x]_{R}\cap S\neq\emptyset\}}&{;\;\;S\downarrow=\cup\,\{[x]_{R}|[x]_{R}\subseteq S\}}\end{array}}\quad\text{(6-4)}$  
那么称$S\uparrow$为$𝑆$的上近似，$S\downarrow$为$𝑆$的下近似。当$\textit{S}\uparrow=\textit{S}$↓时，$S$即是$U$的子集；当$S\uparrow\ne\textit{S}\downarrow$时，称 $𝑆$ 是 $U$ 的粗糙子集，简称为粗糙集或粗集。  
例如，表是考生情况调查表，其中$U$为被调查对象，$R$为高考成绩$(A-$优，$B-$良，$C-$中，$D-$差)；$X$为升学情况($+$为上，$/$为未上)。可根据高考成绩和升学状况进行分类，并可分别计算出下近似集、上近似集。  
表6-3 对集合𝑈的两种划分
![](images/23b7c96f86908a1723f3af9fc2fde337caca13329476de93665a25a8e36ee553.jpg)  
![](images/1cdfc65fbfddc11bcd85c455f6521676d2bf7ff363efa7f28d82ea21a3e04ed5.jpg)  
事实上，可分别按成绩和升学对$U$进行划分：  
$U/R=\{\{1,6\},\{2\},\{3,5\},\{4\}\}=\{Y_{1},Y_{2},Y_{3},Y_{4}\};\quad U/X=\{\{2,3,5,6\},\{1,4\}\}=\{X_{1},X_{2}\}$ 分别得到粗糙集$S$的上近似和下近似集合：  
$$
S(X_{1})\uparrow=Y_{1}\cup Y_{2}\cup Y_{3}=\{1,2,3,5,6\}\;\;;\;\;\;S(X_{2})\uparrow=Y_{1}\cup Y_{4}=\{1,4,6\};
$$  
$$
S(X_{1})\downarrow=Y_{2}\cup Y_{3}=\{2,3,5\}\;\;;\;\;\;S(X_{2})\downarrow=\;\;Y_{4}=\{4\}。
$$  
粗糙集可以表示含义模糊且不太确定的概念，大大拓广了经典集合的概念和应用范围，更为重要的是，粗糙集可由经典集合借助等价关系进行定义，具有坚实的理论基础。目前，粗糙集理论在模式识别、数据挖掘等技术领域得到广泛应用。",通过等价关系可以导出个体域的划分，进而定义粗集的上下近似
粗糙集理论,扩展,经典集合,,"现实世界中很多对象群体的边界是很模糊或者不确定的，例如，对于“中年人”这样的群体，怎样用集合或者其它数学工具进行描述？如果将“中年人”这个群体看出是一个集合$𝑆$的话，则$𝑆$就不是经典意义下的集合，因为其成员不确定。事实上，可以使用两个经典集合来刻画$𝑆$，一个叫做$𝑆$的上近似集合${S}\uparrow$，一个叫做$𝑆$的下近似集合$ S\downarrow$，让前者$𝑆↑$尽可能的小，后者$𝑆↑$尽可能的大。当$𝑆↑$能够等同于$𝑆↓$时,$S$就是经典集合，当$𝑆↑$不能够等同于$𝑆↓$时，则称$𝑆$是粗糙集或粗集。例如，可以用$S\uparrow=\{x|25\le x\le60\}$，即用25 岁至60 岁的人的集合，表示“中年人的集合”；还可以用$S\downarrow=\{x|30\le x\le50\}$，即用30 岁至50 岁的人的集合，表示“中年人的集合”。由于无法构造适当的“中年人的集合”的上下近似$S\uparrow=S\downarrow$，因此，“中年人的集合”$𝑆$是一个粗糙集。  
那么如何用准确的数学语言来定义粗糙集呢？下面通过等价关系给出粗集准确的数学定义。设$U$是个体域（或全集），$R$是$U$上的等价关系，则可由$R$导出的$U$的一个划分，如图$6-$$24\left(a\right)$所示，每个方格表示划分的一个单元，也就是一个$ R$等价类。  
如图$6–24\left(b\right)$所示，若$𝑆$是粗糙集，则$𝑆$的上下近似分别是两个粗线条勾画出的多边形，其中$S\uparrow$由与$𝑆$交不空方格的并组成，$S\downarrow$由包含于$𝑆$的方格并组成。  
![](images/05225fe2f04f5f432dc9b2bbf25b62263d90d0d724be9df376f08ea318717259.jpg)  
通过以上分析，就可以给出粗糙集𝑆的定义：  
【定义6.18】设$U$是个体域(或全集)，$R$是$U$上的等价关系，已知$𝑆$的成员均在$U$中。令： ${\begin{array}{l l}{S\uparrow=\cup\,\{[x]_{R}|[x]_{R}\cap S\neq\emptyset\}}&{;\;\;S\downarrow=\cup\,\{[x]_{R}|[x]_{R}\subseteq S\}}\end{array}}\quad\text{(6-4)}$  
那么称$S\uparrow$为$𝑆$的上近似，$S\downarrow$为$𝑆$的下近似。当$\textit{S}\uparrow=\textit{S}$↓时，$S$即是$U$的子集；当$S\uparrow\ne\textit{S}\downarrow$时，称 $𝑆$ 是 $U$ 的粗糙子集，简称为粗糙集或粗集。  
例如，表是考生情况调查表，其中$U$为被调查对象，$R$为高考成绩$(A-$优，$B-$良，$C-$中，$D-$差)；$X$为升学情况($+$为上，$/$为未上)。可根据高考成绩和升学状况进行分类，并可分别计算出下近似集、上近似集。  
表6-3 对集合𝑈的两种划分
![](images/23b7c96f86908a1723f3af9fc2fde337caca13329476de93665a25a8e36ee553.jpg)  
![](images/1cdfc65fbfddc11bcd85c455f6521676d2bf7ff363efa7f28d82ea21a3e04ed5.jpg)  
事实上，可分别按成绩和升学对$U$进行划分：  
$U/R=\{\{1,6\},\{2\},\{3,5\},\{4\}\}=\{Y_{1},Y_{2},Y_{3},Y_{4}\};\quad U/X=\{\{2,3,5,6\},\{1,4\}\}=\{X_{1},X_{2}\}$ 分别得到粗糙集$S$的上近似和下近似集合：  
$$
S(X_{1})\uparrow=Y_{1}\cup Y_{2}\cup Y_{3}=\{1,2,3,5,6\}\;\;;\;\;\;S(X_{2})\uparrow=Y_{1}\cup Y_{4}=\{1,4,6\};
$$  
$$
S(X_{1})\downarrow=Y_{2}\cup Y_{3}=\{2,3,5\}\;\;;\;\;\;S(X_{2})\downarrow=\;\;Y_{4}=\{4\}。
$$  
粗糙集可以表示含义模糊且不太确定的概念，大大拓广了经典集合的概念和应用范围，更为重要的是，粗糙集可由经典集合借助等价关系进行定义，具有坚实的理论基础。目前，粗糙集理论在模式识别、数据挖掘等技术领域得到广泛应用。",粗糙集理论拓广了经典集合的概念和应用范围
粗糙集理论,基础,等价关系,,"现实世界中很多对象群体的边界是很模糊或者不确定的，例如，对于“中年人”这样的群体，怎样用集合或者其它数学工具进行描述？如果将“中年人”这个群体看出是一个集合$𝑆$的话，则$𝑆$就不是经典意义下的集合，因为其成员不确定。事实上，可以使用两个经典集合来刻画$𝑆$，一个叫做$𝑆$的上近似集合${S}\uparrow$，一个叫做$𝑆$的下近似集合$ S\downarrow$，让前者$𝑆↑$尽可能的小，后者$𝑆↑$尽可能的大。当$𝑆↑$能够等同于$𝑆↓$时,$S$就是经典集合，当$𝑆↑$不能够等同于$𝑆↓$时，则称$𝑆$是粗糙集或粗集。例如，可以用$S\uparrow=\{x|25\le x\le60\}$，即用25 岁至60 岁的人的集合，表示“中年人的集合”；还可以用$S\downarrow=\{x|30\le x\le50\}$，即用30 岁至50 岁的人的集合，表示“中年人的集合”。由于无法构造适当的“中年人的集合”的上下近似$S\uparrow=S\downarrow$，因此，“中年人的集合”$𝑆$是一个粗糙集。  
那么如何用准确的数学语言来定义粗糙集呢？下面通过等价关系给出粗集准确的数学定义。设$U$是个体域（或全集），$R$是$U$上的等价关系，则可由$R$导出的$U$的一个划分，如图$6-$$24\left(a\right)$所示，每个方格表示划分的一个单元，也就是一个$ R$等价类。  
如图$6–24\left(b\right)$所示，若$𝑆$是粗糙集，则$𝑆$的上下近似分别是两个粗线条勾画出的多边形，其中$S\uparrow$由与$𝑆$交不空方格的并组成，$S\downarrow$由包含于$𝑆$的方格并组成。  
![](images/05225fe2f04f5f432dc9b2bbf25b62263d90d0d724be9df376f08ea318717259.jpg)  
通过以上分析，就可以给出粗糙集𝑆的定义：  
【定义6.18】设$U$是个体域(或全集)，$R$是$U$上的等价关系，已知$𝑆$的成员均在$U$中。令： ${\begin{array}{l l}{S\uparrow=\cup\,\{[x]_{R}|[x]_{R}\cap S\neq\emptyset\}}&{;\;\;S\downarrow=\cup\,\{[x]_{R}|[x]_{R}\subseteq S\}}\end{array}}\quad\text{(6-4)}$  
那么称$S\uparrow$为$𝑆$的上近似，$S\downarrow$为$𝑆$的下近似。当$\textit{S}\uparrow=\textit{S}$↓时，$S$即是$U$的子集；当$S\uparrow\ne\textit{S}\downarrow$时，称 $𝑆$ 是 $U$ 的粗糙子集，简称为粗糙集或粗集。  
例如，表是考生情况调查表，其中$U$为被调查对象，$R$为高考成绩$(A-$优，$B-$良，$C-$中，$D-$差)；$X$为升学情况($+$为上，$/$为未上)。可根据高考成绩和升学状况进行分类，并可分别计算出下近似集、上近似集。  
表6-3 对集合𝑈的两种划分
![](images/23b7c96f86908a1723f3af9fc2fde337caca13329476de93665a25a8e36ee553.jpg)  
![](images/1cdfc65fbfddc11bcd85c455f6521676d2bf7ff363efa7f28d82ea21a3e04ed5.jpg)  
事实上，可分别按成绩和升学对$U$进行划分：  
$U/R=\{\{1,6\},\{2\},\{3,5\},\{4\}\}=\{Y_{1},Y_{2},Y_{3},Y_{4}\};\quad U/X=\{\{2,3,5,6\},\{1,4\}\}=\{X_{1},X_{2}\}$ 分别得到粗糙集$S$的上近似和下近似集合：  
$$
S(X_{1})\uparrow=Y_{1}\cup Y_{2}\cup Y_{3}=\{1,2,3,5,6\}\;\;;\;\;\;S(X_{2})\uparrow=Y_{1}\cup Y_{4}=\{1,4,6\};
$$  
$$
S(X_{1})\downarrow=Y_{2}\cup Y_{3}=\{2,3,5\}\;\;;\;\;\;S(X_{2})\downarrow=\;\;Y_{4}=\{4\}。
$$  
粗糙集可以表示含义模糊且不太确定的概念，大大拓广了经典集合的概念和应用范围，更为重要的是，粗糙集可由经典集合借助等价关系进行定义，具有坚实的理论基础。目前，粗糙集理论在模式识别、数据挖掘等技术领域得到广泛应用。",粗糙集理论可由经典集合借助等价关系进行定义，具有坚实的理论基础
偏序关系,应用于,0-1法记分,,"在很多需要排名次的非相互对抗场合，如歌手大赛中的参赛选手、成员的考评、电视节目中主持人大赛中参赛选手的考评等，其评断标准并不像球赛中进球、失球那样准确无误，往往由评判员们分别打分，通过分数计算名次。然而，分数有其不公平的一面。例如，甲、乙、丙三名歌手的得分分别为94 分，92 分，90 分。  
甲的分数-乙的分数$=$乙的分数-丙的分数。  
虽然这两个差相等，但并不能说明甲高出乙的水平等于乙高出丙的水平，因为这里1 分所表示的水平差距并不唯一确定，而是与评判者紧密相关。又如，对于期末考试中某班平均分语文85 分与数学60 分，该班某学生语文80 分，数学70 分，尽管$80>70$，也不能说明这名学生语文学的比数学好。因为这里分数基准点是不一致的。因此有了“标准分”和“等级记分”等科学记分方法，如 “优秀，良好，合格，不合格”四级打分法便是其中一种。  
由偏序关系的定义可知，任何排名次必是一个偏序关系，并且在很大情况下应是线性关系。因此，在上述排名场合（如歌手大赛考评等）可使用“0-1”法记分，并利用偏序关系的反对称性，在比赛过程对选手进行动态排名。下面结合具体实例介绍具体排名过程：  
设有 $A_{1},A_{2},A_{3},A_{4},A_{5},A_{6}$ 这 6  名参赛者，按其下标次序出场比赛。分别为每名评判员准 备一张如表$6–4$ 所示的表格用于对选手进行打分评判。  
表6-4 评判表
![](images/4c85af2d68ddc01acb3d234836cc3dd6fee35852bbb1e27a76917d56b5336e04.jpg)  
每个评判员的打分方法如下：当$A_{2}$参赛结束时，立即把他与$A_{1}$比较，谁更好一些，若$A_{2}$好一些，在表6-4 的$\mathsf{C}_{21}$位置填上1，若$A_{1}$好一些，则在该位置填上0；$A_{3}$参赛结束后，依次与$A_{1}$、$A_{2}$比较谁好一些，好一些为1，差一些为0，并把这两个比较出来的数依次填在${\mathsf C}_{31}$和  
${\mathsf{C}}_{32}$的位置上。如此下去，知道所有的选手参赛结束。即有：  
$$
C_{ij}=\begin{cases}1&\quad\text{当}A_i\text{比}A_j\text{好时}\\0&\quad\text{当}A_i\text{比}A_j\text{好时}\end{cases}\quad(j<i)\quad\text{(6-5)}
$$  
注意的是，当某一位选手比赛结束都要与他参赛的每一名选手比较而且给出谁好谁差的结论(是1 还是0)。也可以利用偏序关系的传递性减少比较次数。如$A_{5}$比$A_{1}$强，而此时已经有$\mathsf{C}_{31}=\mathsf{C}_{41}=0$，则必有${\mathsf{C}}_{53}={\mathsf{C}}_{54}=1$。表6-5 是某一位评判员所裁判的结果。  
表6-5   评判结果
![](images/0095a64294f10a0d76e1eae14906fdb5c9f5e6a5bc895b20e56aa4e7f6a6e039.jpg)  
如$|A_{5}$行说明$A_{5}$比$A_{1}$好，比$A_{2}$差，比$A_{3}$好，比$A_{4}$  
然后对表6-5 进行整理：首先利用偏序关系的反对称性填充表格的上角，上表虚线为对称轴，右上角各个位置(如$\mathsf C_{12}$)看它的对称位置(即$\mathsf{C}_{21}$)上的数，若其对称位置上数为$1\left(\mathbb{C}_{21}=1\right)$,则它为$0\left(\mathsf{C}_{12}=0\right)$)；若其对称位置上的数为1，则它就是0。即有：  
$$
\mathrm{C}_{ij}=\begin{cases}0&\quad\text{当C}_{ji}=1\text{时}\\1&\quad\text{当C}_{ji}=0\text{时}\end{cases}\quad(i<j)\quad\text{(6-6)}
$$  
完成后如表6-6 所示：  
表6-6 对评判结果的整理
![](images/620931865382a676e3093ac6d3295347415e7bef2cda108424f0318f6d3c3129.jpg)  
把表6-6 各行的数字加起来填入总分列中（倒数第二列），这个列中各数分别为其所在行中相应选手的得分。它们不可能有两个相等的数，否则说明评判或填表有误应作废。把这个列的各数相加填入这一列最后一格为总分和$σ$。事实上$σ$是一个固定数$σ=m(m-1)/2$其中$m$为参赛选手的人数。本例中$m=6$，故有$σ=6*(6-1)/2=15$。  
把表6-6 中各列数字加起来，填入最后一行（即总分行）的相应位置上，分别为其所在列上相应选手的失分，以虚线为对称轴和其对称位置上的得分加起来应该等于$m-1$，  
减1 是因为自己不与自己比较，总分行总分和也等于$m(m-1)/2$。表的最后一列是把各选手的得分转化为人们习惯的百分制，本例中用的是$(m-1)*$得分数$+60$，以避免出现低于60 分的情况，最后把所有评判员有效给出的各个选手成绩相应加起来求平均成绩，按平均成绩高低排名次，此时可能出现并列名次。",偏序关系应用于0-1法记分，用于动态排名
评判表,记录,0-1法记分,,"在很多需要排名次的非相互对抗场合，如歌手大赛中的参赛选手、成员的考评、电视节目中主持人大赛中参赛选手的考评等，其评断标准并不像球赛中进球、失球那样准确无误，往往由评判员们分别打分，通过分数计算名次。然而，分数有其不公平的一面。例如，甲、乙、丙三名歌手的得分分别为94 分，92 分，90 分。  
甲的分数-乙的分数$=$乙的分数-丙的分数。  
虽然这两个差相等，但并不能说明甲高出乙的水平等于乙高出丙的水平，因为这里1 分所表示的水平差距并不唯一确定，而是与评判者紧密相关。又如，对于期末考试中某班平均分语文85 分与数学60 分，该班某学生语文80 分，数学70 分，尽管$80>70$，也不能说明这名学生语文学的比数学好。因为这里分数基准点是不一致的。因此有了“标准分”和“等级记分”等科学记分方法，如 “优秀，良好，合格，不合格”四级打分法便是其中一种。  
由偏序关系的定义可知，任何排名次必是一个偏序关系，并且在很大情况下应是线性关系。因此，在上述排名场合（如歌手大赛考评等）可使用“0-1”法记分，并利用偏序关系的反对称性，在比赛过程对选手进行动态排名。下面结合具体实例介绍具体排名过程：  
设有 $A_{1},A_{2},A_{3},A_{4},A_{5},A_{6}$ 这 6  名参赛者，按其下标次序出场比赛。分别为每名评判员准 备一张如表$6–4$ 所示的表格用于对选手进行打分评判。  
表6-4 评判表
![](images/4c85af2d68ddc01acb3d234836cc3dd6fee35852bbb1e27a76917d56b5336e04.jpg)  
每个评判员的打分方法如下：当$A_{2}$参赛结束时，立即把他与$A_{1}$比较，谁更好一些，若$A_{2}$好一些，在表6-4 的$\mathsf{C}_{21}$位置填上1，若$A_{1}$好一些，则在该位置填上0；$A_{3}$参赛结束后，依次与$A_{1}$、$A_{2}$比较谁好一些，好一些为1，差一些为0，并把这两个比较出来的数依次填在${\mathsf C}_{31}$和  
${\mathsf{C}}_{32}$的位置上。如此下去，知道所有的选手参赛结束。即有：  
$$
C_{ij}=\begin{cases}1&\quad\text{当}A_i\text{比}A_j\text{好时}\\0&\quad\text{当}A_i\text{比}A_j\text{好时}\end{cases}\quad(j<i)\quad\text{(6-5)}
$$  
注意的是，当某一位选手比赛结束都要与他参赛的每一名选手比较而且给出谁好谁差的结论(是1 还是0)。也可以利用偏序关系的传递性减少比较次数。如$A_{5}$比$A_{1}$强，而此时已经有$\mathsf{C}_{31}=\mathsf{C}_{41}=0$，则必有${\mathsf{C}}_{53}={\mathsf{C}}_{54}=1$。表6-5 是某一位评判员所裁判的结果。  
表6-5   评判结果
![](images/0095a64294f10a0d76e1eae14906fdb5c9f5e6a5bc895b20e56aa4e7f6a6e039.jpg)  
如$|A_{5}$行说明$A_{5}$比$A_{1}$好，比$A_{2}$差，比$A_{3}$好，比$A_{4}$  
然后对表6-5 进行整理：首先利用偏序关系的反对称性填充表格的上角，上表虚线为对称轴，右上角各个位置(如$\mathsf C_{12}$)看它的对称位置(即$\mathsf{C}_{21}$)上的数，若其对称位置上数为$1\left(\mathbb{C}_{21}=1\right)$,则它为$0\left(\mathsf{C}_{12}=0\right)$)；若其对称位置上的数为1，则它就是0。即有：  
$$
\mathrm{C}_{ij}=\begin{cases}0&\quad\text{当C}_{ji}=1\text{时}\\1&\quad\text{当C}_{ji}=0\text{时}\end{cases}\quad(i<j)\quad\text{(6-6)}
$$  
完成后如表6-6 所示：  
表6-6 对评判结果的整理
![](images/620931865382a676e3093ac6d3295347415e7bef2cda108424f0318f6d3c3129.jpg)  
把表6-6 各行的数字加起来填入总分列中（倒数第二列），这个列中各数分别为其所在行中相应选手的得分。它们不可能有两个相等的数，否则说明评判或填表有误应作废。把这个列的各数相加填入这一列最后一格为总分和$σ$。事实上$σ$是一个固定数$σ=m(m-1)/2$其中$m$为参赛选手的人数。本例中$m=6$，故有$σ=6*(6-1)/2=15$。  
把表6-6 中各列数字加起来，填入最后一行（即总分行）的相应位置上，分别为其所在列上相应选手的失分，以虚线为对称轴和其对称位置上的得分加起来应该等于$m-1$，  
减1 是因为自己不与自己比较，总分行总分和也等于$m(m-1)/2$。表的最后一列是把各选手的得分转化为人们习惯的百分制，本例中用的是$(m-1)*$得分数$+60$，以避免出现低于60 分的情况，最后把所有评判员有效给出的各个选手成绩相应加起来求平均成绩，按平均成绩高低排名次，此时可能出现并列名次。",评判表记录0-1法记分的比较结果
总分和,计算自,评判表,,"在很多需要排名次的非相互对抗场合，如歌手大赛中的参赛选手、成员的考评、电视节目中主持人大赛中参赛选手的考评等，其评断标准并不像球赛中进球、失球那样准确无误，往往由评判员们分别打分，通过分数计算名次。然而，分数有其不公平的一面。例如，甲、乙、丙三名歌手的得分分别为94 分，92 分，90 分。  
甲的分数-乙的分数$=$乙的分数-丙的分数。  
虽然这两个差相等，但并不能说明甲高出乙的水平等于乙高出丙的水平，因为这里1 分所表示的水平差距并不唯一确定，而是与评判者紧密相关。又如，对于期末考试中某班平均分语文85 分与数学60 分，该班某学生语文80 分，数学70 分，尽管$80>70$，也不能说明这名学生语文学的比数学好。因为这里分数基准点是不一致的。因此有了“标准分”和“等级记分”等科学记分方法，如 “优秀，良好，合格，不合格”四级打分法便是其中一种。  
由偏序关系的定义可知，任何排名次必是一个偏序关系，并且在很大情况下应是线性关系。因此，在上述排名场合（如歌手大赛考评等）可使用“0-1”法记分，并利用偏序关系的反对称性，在比赛过程对选手进行动态排名。下面结合具体实例介绍具体排名过程：  
设有 $A_{1},A_{2},A_{3},A_{4},A_{5},A_{6}$ 这 6  名参赛者，按其下标次序出场比赛。分别为每名评判员准 备一张如表$6–4$ 所示的表格用于对选手进行打分评判。  
表6-4 评判表
![](images/4c85af2d68ddc01acb3d234836cc3dd6fee35852bbb1e27a76917d56b5336e04.jpg)  
每个评判员的打分方法如下：当$A_{2}$参赛结束时，立即把他与$A_{1}$比较，谁更好一些，若$A_{2}$好一些，在表6-4 的$\mathsf{C}_{21}$位置填上1，若$A_{1}$好一些，则在该位置填上0；$A_{3}$参赛结束后，依次与$A_{1}$、$A_{2}$比较谁好一些，好一些为1，差一些为0，并把这两个比较出来的数依次填在${\mathsf C}_{31}$和  
${\mathsf{C}}_{32}$的位置上。如此下去，知道所有的选手参赛结束。即有：  
$$
C_{ij}=\begin{cases}1&\quad\text{当}A_i\text{比}A_j\text{好时}\\0&\quad\text{当}A_i\text{比}A_j\text{好时}\end{cases}\quad(j<i)\quad\text{(6-5)}
$$  
注意的是，当某一位选手比赛结束都要与他参赛的每一名选手比较而且给出谁好谁差的结论(是1 还是0)。也可以利用偏序关系的传递性减少比较次数。如$A_{5}$比$A_{1}$强，而此时已经有$\mathsf{C}_{31}=\mathsf{C}_{41}=0$，则必有${\mathsf{C}}_{53}={\mathsf{C}}_{54}=1$。表6-5 是某一位评判员所裁判的结果。  
表6-5   评判结果
![](images/0095a64294f10a0d76e1eae14906fdb5c9f5e6a5bc895b20e56aa4e7f6a6e039.jpg)  
如$|A_{5}$行说明$A_{5}$比$A_{1}$好，比$A_{2}$差，比$A_{3}$好，比$A_{4}$  
然后对表6-5 进行整理：首先利用偏序关系的反对称性填充表格的上角，上表虚线为对称轴，右上角各个位置(如$\mathsf C_{12}$)看它的对称位置(即$\mathsf{C}_{21}$)上的数，若其对称位置上数为$1\left(\mathbb{C}_{21}=1\right)$,则它为$0\left(\mathsf{C}_{12}=0\right)$)；若其对称位置上的数为1，则它就是0。即有：  
$$
\mathrm{C}_{ij}=\begin{cases}0&\quad\text{当C}_{ji}=1\text{时}\\1&\quad\text{当C}_{ji}=0\text{时}\end{cases}\quad(i<j)\quad\text{(6-6)}
$$  
完成后如表6-6 所示：  
表6-6 对评判结果的整理
![](images/620931865382a676e3093ac6d3295347415e7bef2cda108424f0318f6d3c3129.jpg)  
把表6-6 各行的数字加起来填入总分列中（倒数第二列），这个列中各数分别为其所在行中相应选手的得分。它们不可能有两个相等的数，否则说明评判或填表有误应作废。把这个列的各数相加填入这一列最后一格为总分和$σ$。事实上$σ$是一个固定数$σ=m(m-1)/2$其中$m$为参赛选手的人数。本例中$m=6$，故有$σ=6*(6-1)/2=15$。  
把表6-6 中各列数字加起来，填入最后一行（即总分行）的相应位置上，分别为其所在列上相应选手的失分，以虚线为对称轴和其对称位置上的得分加起来应该等于$m-1$，  
减1 是因为自己不与自己比较，总分行总分和也等于$m(m-1)/2$。表的最后一列是把各选手的得分转化为人们习惯的百分制，本例中用的是$(m-1)*$得分数$+60$，以避免出现低于60 分的情况，最后把所有评判员有效给出的各个选手成绩相应加起来求平均成绩，按平均成绩高低排名次，此时可能出现并列名次。",总分和计算自评判表中的得分总和
标准分,科学记分方法,等级记分,,"在很多需要排名次的非相互对抗场合，如歌手大赛中的参赛选手、成员的考评、电视节目中主持人大赛中参赛选手的考评等，其评断标准并不像球赛中进球、失球那样准确无误，往往由评判员们分别打分，通过分数计算名次。然而，分数有其不公平的一面。例如，甲、乙、丙三名歌手的得分分别为94 分，92 分，90 分。  
甲的分数-乙的分数$=$乙的分数-丙的分数。  
虽然这两个差相等，但并不能说明甲高出乙的水平等于乙高出丙的水平，因为这里1 分所表示的水平差距并不唯一确定，而是与评判者紧密相关。又如，对于期末考试中某班平均分语文85 分与数学60 分，该班某学生语文80 分，数学70 分，尽管$80>70$，也不能说明这名学生语文学的比数学好。因为这里分数基准点是不一致的。因此有了“标准分”和“等级记分”等科学记分方法，如 “优秀，良好，合格，不合格”四级打分法便是其中一种。  
由偏序关系的定义可知，任何排名次必是一个偏序关系，并且在很大情况下应是线性关系。因此，在上述排名场合（如歌手大赛考评等）可使用“0-1”法记分，并利用偏序关系的反对称性，在比赛过程对选手进行动态排名。下面结合具体实例介绍具体排名过程：  
设有 $A_{1},A_{2},A_{3},A_{4},A_{5},A_{6}$ 这 6  名参赛者，按其下标次序出场比赛。分别为每名评判员准 备一张如表$6–4$ 所示的表格用于对选手进行打分评判。  
表6-4 评判表
![](images/4c85af2d68ddc01acb3d234836cc3dd6fee35852bbb1e27a76917d56b5336e04.jpg)  
每个评判员的打分方法如下：当$A_{2}$参赛结束时，立即把他与$A_{1}$比较，谁更好一些，若$A_{2}$好一些，在表6-4 的$\mathsf{C}_{21}$位置填上1，若$A_{1}$好一些，则在该位置填上0；$A_{3}$参赛结束后，依次与$A_{1}$、$A_{2}$比较谁好一些，好一些为1，差一些为0，并把这两个比较出来的数依次填在${\mathsf C}_{31}$和  
${\mathsf{C}}_{32}$的位置上。如此下去，知道所有的选手参赛结束。即有：  
$$
C_{ij}=\begin{cases}1&\quad\text{当}A_i\text{比}A_j\text{好时}\\0&\quad\text{当}A_i\text{比}A_j\text{好时}\end{cases}\quad(j<i)\quad\text{(6-5)}
$$  
注意的是，当某一位选手比赛结束都要与他参赛的每一名选手比较而且给出谁好谁差的结论(是1 还是0)。也可以利用偏序关系的传递性减少比较次数。如$A_{5}$比$A_{1}$强，而此时已经有$\mathsf{C}_{31}=\mathsf{C}_{41}=0$，则必有${\mathsf{C}}_{53}={\mathsf{C}}_{54}=1$。表6-5 是某一位评判员所裁判的结果。  
表6-5   评判结果
![](images/0095a64294f10a0d76e1eae14906fdb5c9f5e6a5bc895b20e56aa4e7f6a6e039.jpg)  
如$|A_{5}$行说明$A_{5}$比$A_{1}$好，比$A_{2}$差，比$A_{3}$好，比$A_{4}$  
然后对表6-5 进行整理：首先利用偏序关系的反对称性填充表格的上角，上表虚线为对称轴，右上角各个位置(如$\mathsf C_{12}$)看它的对称位置(即$\mathsf{C}_{21}$)上的数，若其对称位置上数为$1\left(\mathbb{C}_{21}=1\right)$,则它为$0\left(\mathsf{C}_{12}=0\right)$)；若其对称位置上的数为1，则它就是0。即有：  
$$
\mathrm{C}_{ij}=\begin{cases}0&\quad\text{当C}_{ji}=1\text{时}\\1&\quad\text{当C}_{ji}=0\text{时}\end{cases}\quad(i<j)\quad\text{(6-6)}
$$  
完成后如表6-6 所示：  
表6-6 对评判结果的整理
![](images/620931865382a676e3093ac6d3295347415e7bef2cda108424f0318f6d3c3129.jpg)  
把表6-6 各行的数字加起来填入总分列中（倒数第二列），这个列中各数分别为其所在行中相应选手的得分。它们不可能有两个相等的数，否则说明评判或填表有误应作废。把这个列的各数相加填入这一列最后一格为总分和$σ$。事实上$σ$是一个固定数$σ=m(m-1)/2$其中$m$为参赛选手的人数。本例中$m=6$，故有$σ=6*(6-1)/2=15$。  
把表6-6 中各列数字加起来，填入最后一行（即总分行）的相应位置上，分别为其所在列上相应选手的失分，以虚线为对称轴和其对称位置上的得分加起来应该等于$m-1$，  
减1 是因为自己不与自己比较，总分行总分和也等于$m(m-1)/2$。表的最后一列是把各选手的得分转化为人们习惯的百分制，本例中用的是$(m-1)*$得分数$+60$，以避免出现低于60 分的情况，最后把所有评判员有效给出的各个选手成绩相应加起来求平均成绩，按平均成绩高低排名次，此时可能出现并列名次。",标准分和等级记分都是科学记分方法
偏序关系,利用,评判表,,"在很多需要排名次的非相互对抗场合，如歌手大赛中的参赛选手、成员的考评、电视节目中主持人大赛中参赛选手的考评等，其评断标准并不像球赛中进球、失球那样准确无误，往往由评判员们分别打分，通过分数计算名次。然而，分数有其不公平的一面。例如，甲、乙、丙三名歌手的得分分别为94 分，92 分，90 分。  
甲的分数-乙的分数$=$乙的分数-丙的分数。  
虽然这两个差相等，但并不能说明甲高出乙的水平等于乙高出丙的水平，因为这里1 分所表示的水平差距并不唯一确定，而是与评判者紧密相关。又如，对于期末考试中某班平均分语文85 分与数学60 分，该班某学生语文80 分，数学70 分，尽管$80>70$，也不能说明这名学生语文学的比数学好。因为这里分数基准点是不一致的。因此有了“标准分”和“等级记分”等科学记分方法，如 “优秀，良好，合格，不合格”四级打分法便是其中一种。  
由偏序关系的定义可知，任何排名次必是一个偏序关系，并且在很大情况下应是线性关系。因此，在上述排名场合（如歌手大赛考评等）可使用“0-1”法记分，并利用偏序关系的反对称性，在比赛过程对选手进行动态排名。下面结合具体实例介绍具体排名过程：  
设有 $A_{1},A_{2},A_{3},A_{4},A_{5},A_{6}$ 这 6  名参赛者，按其下标次序出场比赛。分别为每名评判员准 备一张如表$6–4$ 所示的表格用于对选手进行打分评判。  
表6-4 评判表
![](images/4c85af2d68ddc01acb3d234836cc3dd6fee35852bbb1e27a76917d56b5336e04.jpg)  
每个评判员的打分方法如下：当$A_{2}$参赛结束时，立即把他与$A_{1}$比较，谁更好一些，若$A_{2}$好一些，在表6-4 的$\mathsf{C}_{21}$位置填上1，若$A_{1}$好一些，则在该位置填上0；$A_{3}$参赛结束后，依次与$A_{1}$、$A_{2}$比较谁好一些，好一些为1，差一些为0，并把这两个比较出来的数依次填在${\mathsf C}_{31}$和  
${\mathsf{C}}_{32}$的位置上。如此下去，知道所有的选手参赛结束。即有：  
$$
C_{ij}=\begin{cases}1&\quad\text{当}A_i\text{比}A_j\text{好时}\\0&\quad\text{当}A_i\text{比}A_j\text{好时}\end{cases}\quad(j<i)\quad\text{(6-5)}
$$  
注意的是，当某一位选手比赛结束都要与他参赛的每一名选手比较而且给出谁好谁差的结论(是1 还是0)。也可以利用偏序关系的传递性减少比较次数。如$A_{5}$比$A_{1}$强，而此时已经有$\mathsf{C}_{31}=\mathsf{C}_{41}=0$，则必有${\mathsf{C}}_{53}={\mathsf{C}}_{54}=1$。表6-5 是某一位评判员所裁判的结果。  
表6-5   评判结果
![](images/0095a64294f10a0d76e1eae14906fdb5c9f5e6a5bc895b20e56aa4e7f6a6e039.jpg)  
如$|A_{5}$行说明$A_{5}$比$A_{1}$好，比$A_{2}$差，比$A_{3}$好，比$A_{4}$  
然后对表6-5 进行整理：首先利用偏序关系的反对称性填充表格的上角，上表虚线为对称轴，右上角各个位置(如$\mathsf C_{12}$)看它的对称位置(即$\mathsf{C}_{21}$)上的数，若其对称位置上数为$1\left(\mathbb{C}_{21}=1\right)$,则它为$0\left(\mathsf{C}_{12}=0\right)$)；若其对称位置上的数为1，则它就是0。即有：  
$$
\mathrm{C}_{ij}=\begin{cases}0&\quad\text{当C}_{ji}=1\text{时}\\1&\quad\text{当C}_{ji}=0\text{时}\end{cases}\quad(i<j)\quad\text{(6-6)}
$$  
完成后如表6-6 所示：  
表6-6 对评判结果的整理
![](images/620931865382a676e3093ac6d3295347415e7bef2cda108424f0318f6d3c3129.jpg)  
把表6-6 各行的数字加起来填入总分列中（倒数第二列），这个列中各数分别为其所在行中相应选手的得分。它们不可能有两个相等的数，否则说明评判或填表有误应作废。把这个列的各数相加填入这一列最后一格为总分和$σ$。事实上$σ$是一个固定数$σ=m(m-1)/2$其中$m$为参赛选手的人数。本例中$m=6$，故有$σ=6*(6-1)/2=15$。  
把表6-6 中各列数字加起来，填入最后一行（即总分行）的相应位置上，分别为其所在列上相应选手的失分，以虚线为对称轴和其对称位置上的得分加起来应该等于$m-1$，  
减1 是因为自己不与自己比较，总分行总分和也等于$m(m-1)/2$。表的最后一列是把各选手的得分转化为人们习惯的百分制，本例中用的是$(m-1)*$得分数$+60$，以避免出现低于60 分的情况，最后把所有评判员有效给出的各个选手成绩相应加起来求平均成绩，按平均成绩高低排名次，此时可能出现并列名次。",偏序关系的反对称性用于评判表的填充
函数,包含,特征函数,,函数是一个在自然科学、工程技术，甚至在某些社会科学中被广泛应用的数学概念，无论在初等数学还是高等数学中，无论在基础课还是专业课中，大家都会经常与函数打交道，以函数为基本工具解决各种各样的数学问题和专业问题。然而，从严格意义角度给函数下个定义并不是一件容易的事情。有人会说，函数不就是一个集合到另外一个集合的映射吗？或者说，函数就是对于某个集合中的任一元素，在另外一个集合中存在唯一元素与之对应。这不就是函数的定义？如果函数是这样定义的话，那么映射或对应又怎么定义呢？这正是函数定义的困难所在。事实上，自函数概念首次被德国数学家被莱布尼茨提出以来，其定义一直没有得到很好地解决，因为没有人能够准确地回答什么叫映射或者对应。直到在集合论和关系理论出现后，人们才以关系理论为工具完美地解决了函数的定义。具体地说，函数就是一种满足单值性要求的特殊二元关系。通过关系模型定义函数，就用关系模型的特性来诠释映射或对应概念的含义。作为关系模型的一个具体应用，本章将从特殊关系的角度来介绍函数的基本知识及其应用，包括函数的基本概念、函数的基本运算，以及若干重要的特殊函数，例如特征函数、散列函数和置换函数等。,特征函数是函数的一种特殊类型
函数,包含,散列函数,,函数是一个在自然科学、工程技术，甚至在某些社会科学中被广泛应用的数学概念，无论在初等数学还是高等数学中，无论在基础课还是专业课中，大家都会经常与函数打交道，以函数为基本工具解决各种各样的数学问题和专业问题。然而，从严格意义角度给函数下个定义并不是一件容易的事情。有人会说，函数不就是一个集合到另外一个集合的映射吗？或者说，函数就是对于某个集合中的任一元素，在另外一个集合中存在唯一元素与之对应。这不就是函数的定义？如果函数是这样定义的话，那么映射或对应又怎么定义呢？这正是函数定义的困难所在。事实上，自函数概念首次被德国数学家被莱布尼茨提出以来，其定义一直没有得到很好地解决，因为没有人能够准确地回答什么叫映射或者对应。直到在集合论和关系理论出现后，人们才以关系理论为工具完美地解决了函数的定义。具体地说，函数就是一种满足单值性要求的特殊二元关系。通过关系模型定义函数，就用关系模型的特性来诠释映射或对应概念的含义。作为关系模型的一个具体应用，本章将从特殊关系的角度来介绍函数的基本知识及其应用，包括函数的基本概念、函数的基本运算，以及若干重要的特殊函数，例如特征函数、散列函数和置换函数等。,散列函数是函数的一种特殊类型
函数,包含,置换函数,,函数是一个在自然科学、工程技术，甚至在某些社会科学中被广泛应用的数学概念，无论在初等数学还是高等数学中，无论在基础课还是专业课中，大家都会经常与函数打交道，以函数为基本工具解决各种各样的数学问题和专业问题。然而，从严格意义角度给函数下个定义并不是一件容易的事情。有人会说，函数不就是一个集合到另外一个集合的映射吗？或者说，函数就是对于某个集合中的任一元素，在另外一个集合中存在唯一元素与之对应。这不就是函数的定义？如果函数是这样定义的话，那么映射或对应又怎么定义呢？这正是函数定义的困难所在。事实上，自函数概念首次被德国数学家被莱布尼茨提出以来，其定义一直没有得到很好地解决，因为没有人能够准确地回答什么叫映射或者对应。直到在集合论和关系理论出现后，人们才以关系理论为工具完美地解决了函数的定义。具体地说，函数就是一种满足单值性要求的特殊二元关系。通过关系模型定义函数，就用关系模型的特性来诠释映射或对应概念的含义。作为关系模型的一个具体应用，本章将从特殊关系的角度来介绍函数的基本知识及其应用，包括函数的基本概念、函数的基本运算，以及若干重要的特殊函数，例如特征函数、散列函数和置换函数等。,置换函数是函数的一种特殊类型
函数,定义,函数相等,,"在初等数学或高等数学中，函数的概念从变量角度提出，而且主要局限于在实数集。计算机相关领域处理的对象除了实数之外，还有很多其它对象，例如矩阵、向量、命题等等，而且主要面对的是各种可数的离散对象。为此，需要扩展初等数学或高等数学中函数概念的含义，从集合与关系的角度给函数下一个更加本质性的定义，具体如下：  
【定义7.1】设$𝐴$和$B$是任意两个非空集合，$f$是从$𝐴$到$B$的关系。若对$\forall x\in A$都存在唯一的$y\in B$，满足$\langle x,y\rangle\in f$，则称关系$f$为从$𝐴$到$B$的函数关系，简称为函数或映射,记为 $f\!:\!A\longrightarrow$  
$B$或$y=f(x)$，并称$x$为$f$的自变量或源点，$𝑦$为$ x$在$f$下的函数值或像点。集合$𝐴$称为$𝑓$的定义域，记为$dom$ $f=A$，所有像点组成的集合称为$f$的值域或$f$的像，记为$ran $$f$或$f(A)$。  
从上述定义可以看出，函数$f$是从集合$𝐴$到$B$的一种特殊二元关系，这种二元关系所包含序偶的第一元素为自变量，第二元素为因变量或函数值。函数的定义域就是关系的前域$𝐴$，要求关系中所有序偶的第一元素互不相同并且要取遍集合$𝐴$中的每个元素。作为刻画作为函数的本质单值特征，要求对于关系中的任意两个序偶，若它们的第一元素相同，则第二元素必须相同。具体地说，如果一个从集合$𝐴$到$B$二元关系$f$，那么它必须满足如下几个性质：  
(1)$\langle x,y\rangle\in f\Leftrightarrow y=f(x);\qquad\mathrm{(2)}\ \langle x,y\rangle\in f\wedge\langle x,z\rangle\in f\Rightarrow y=z;$  
（3）$|f|=|A|$； （4）$f(x)$表示一个变值，$f$代表一个集合，故$f\neq f(x)$  
如果关系$f$具备下面两种情况之一，那么$f$就不是函数关系：  
（1）存在元素$a\in A$,在$B$中没有像；（2）存在元素$a\in A$, 在$ B$中至少有两个像。  
例如，关系$\begin{array}{r}{F_{1}=\{\langle x_{1},y_{1}\rangle,\langle x_{2},y_{1}\rangle,\langle x_{3},y_{2}\rangle,\langle x_{4},y_{3}\rangle\}}\end{array}$是函数，而如下关系：
$$
F_{2}=\{\langle x_{1},y_{1}\rangle,\langle x_{2},y_{1}\rangle,\langle x_{3},y_{2}\rangle,\langle x_{1},y_{2}\rangle\}
$$  
则不是函数，因为同时有$\langle x_{1},y_{1}\rangle\in F_{2}$和$\langle x_{1},y_{2}\rangle\in F_{2}$  
由上述例题可知，函数作为一种特殊关系或特殊集合，其集合运算的结果可能不再是函数。因此，要慎用函数的集合运算。另一方面，由于函数是一种特殊子集，因此可用集合相等的概念来定义两个函数相等，具体定义如下：  
【定义7.2】设$𝐴$和$B$是任意两个非空集合，$f,g$是两个从$A$到$B$的函数关系，如果$f$和$g$相互包含，即有$f\subseteq g\wedge g\subseteq f$，则称函数$f$和函数$g$相等，记为$f=g$。换句话说，如果$dom $$f=$$dom$ $g$且对$\forall x\in\mathsf{d o m}$ $f=\mathrm{dom}$ $g$有$f(x)=g(x)$，称$f$与$g$相等。  
从上述定义可以看出，两个函数相等不仅要求它们的对应关系相等，而且要求它们的定义域也要相同，两者缺一不可。  
现考察有限集合上函数的计数问题，即算出有限集合上有多少种不同函数。设集合$ A=$$\{a_{1},a_{2},\cdots,a_{n}\}$，$B=\{b_{1},b_{2},\cdots,b_{m}\}$，则要确定一个从$𝐴$到$B$的函数$ f$，就必须对$𝐴$中每个元素$a_{i}$，在$B$中找到一个唯一确定的元素$b_{m_{i}}$与之对应。显然，对于$𝐴$中每个元素$a_{i}$都有$|B|=m$种选择$b_{m_{i}}$的方式。而集合𝐴中共有$|A|=n$个元素，故根据乘法原理，得到所有方式的组合数为$m^{n}$或$|B|^{|A|}$种。即从$A$到$B$的不同函数一共有$|B|^{|A|}$种。由此得到如下定理：  
【定理7.1】设$𝐴$和$B$是任意两个非空有限集合，则从$A$到$B$一共有$|B|^{|A|}$种不同的函数。  
根据上述定理，可得到如下函数集定义及其表示方法：  
【定义7.3】设$𝐴$和$B$是任意两个非空集合，将从$A$到$B$的一切函数构成的集合称为从$𝐴$到$B$的函数集或函数空间，记为$B^{A}$。即有： $B^{A}=\{f|f\colon\ A\to B\}.$。  
根据上述定义，当$𝐴$和$B$是非空有限集合时，显然有：$|B^{A}|=|B|^{|A|}$  
通过以上分析不难发现，当𝐴和$B$为有限集时，函数和一般关系具有以下区别：  
（1）个数差异：从$𝐴$到$B$的不同关系有$2^{|A|\times|B|}$个，从$A$到$B$的不同函数仅有$|B|^{|A|}$个。  
（2）基数不同：每个函数基数均为$|A|$即$|f|=|A|$，关系的基数却为从0 到$\vert A\vert\times\vert B\vert$  
（3）第一元素的差别：关系的第一个元素可以相同，函数的第一个元素不能相同。  
下面进一步考察函数对定义域子集的映射性质，首先给出如下子集像的相关概念：  
【定义7.4】设$𝐴$和$B$是任意给定的两个非空集合，$A_{1}$和$B_{1}$分别是$𝐴$和$B$的任意两个非空子集合，即有$A_{1}\subseteq A,B_{1}\subseteq B$。$f$是一个从$𝐴$和$B$函数，即$f\colon A\to B$。  
（1）令$f(A_{1})=\{f(x)|x\in A_{1}\}$，称$f(A_{1})$为$|A_{1}$在$f$下的像。当$A_{1}=A$时，$f(A)$为$f$的像。  
（2）令$ f^{-1}(B_{1})=\{x|x\in A\Lambda f(x)\in B_{1}\}$，称$f^{-1}(B_{1})$为$B_{1}$在$f$下的完全原像。  
在上述定义中显然有：$f(A_{1})\subseteq B$且$f^{-1}(B_{1})\subseteq A$。  
下面定理给出了子集像的集合运算性质：  
【定理7.2】设$𝐴$和$B$是任意给定的两个非空集合，$X$和$𝑌$是集合$ A$的任意两个非空子集，即有$X\subseteq A,Y\subseteq A$。$f$是一个从$A$和$B$函数，即$f\colon A\to B$。则有：  
$$
(1)f(X\cup Y)=f(X)\cup f(Y);\ \ (2)\ \,f(X\cap Y)\subseteq f(X)\cap f(Y)
$$  
上述定理的第（2）结论等号不成立。  
事实上，设$A=\{a,b,c\}$，$B=\{1,\!2,\!3\}$，$f\colon X\to Y$为：$f(a)=1$，$f(b)=f(c)=2.$令$X=\{a,b\}$，$Y=\{c\}$，则有：$A\cap B=\emptyset$，$f(A\cap B)=\emptyset$。但是：  
$$
f(A)\ \cap f(B)=\{1,2\}\cap\{2\}\neq\emptyset
$$  
故$f(A)\ \cap f(B)\ \neq f(A\cap B)$。这表明只能成立：$f(A\cap B)\subseteq f(A)\cap f(B)\,。$  
至此，我们从二元关系的角度给了函数相关概念的本质定义，并以关系模型为基本工具分析讨论了函数的若干基本性质，为函数理论奠定了一个比较坚实的数学基础。下面就从以上函数概念及基本性质为出发点进一步介绍和讨论函数的相关理论及应用。",两个函数相等的定义是它们的定义域相同且对应关系相等
函数,构成,函数集,,"在初等数学或高等数学中，函数的概念从变量角度提出，而且主要局限于在实数集。计算机相关领域处理的对象除了实数之外，还有很多其它对象，例如矩阵、向量、命题等等，而且主要面对的是各种可数的离散对象。为此，需要扩展初等数学或高等数学中函数概念的含义，从集合与关系的角度给函数下一个更加本质性的定义，具体如下：  
【定义7.1】设$𝐴$和$B$是任意两个非空集合，$f$是从$𝐴$到$B$的关系。若对$\forall x\in A$都存在唯一的$y\in B$，满足$\langle x,y\rangle\in f$，则称关系$f$为从$𝐴$到$B$的函数关系，简称为函数或映射,记为 $f\!:\!A\longrightarrow$  
$B$或$y=f(x)$，并称$x$为$f$的自变量或源点，$𝑦$为$ x$在$f$下的函数值或像点。集合$𝐴$称为$𝑓$的定义域，记为$dom$ $f=A$，所有像点组成的集合称为$f$的值域或$f$的像，记为$ran $$f$或$f(A)$。  
从上述定义可以看出，函数$f$是从集合$𝐴$到$B$的一种特殊二元关系，这种二元关系所包含序偶的第一元素为自变量，第二元素为因变量或函数值。函数的定义域就是关系的前域$𝐴$，要求关系中所有序偶的第一元素互不相同并且要取遍集合$𝐴$中的每个元素。作为刻画作为函数的本质单值特征，要求对于关系中的任意两个序偶，若它们的第一元素相同，则第二元素必须相同。具体地说，如果一个从集合$𝐴$到$B$二元关系$f$，那么它必须满足如下几个性质：  
(1)$\langle x,y\rangle\in f\Leftrightarrow y=f(x);\qquad\mathrm{(2)}\ \langle x,y\rangle\in f\wedge\langle x,z\rangle\in f\Rightarrow y=z;$  
（3）$|f|=|A|$； （4）$f(x)$表示一个变值，$f$代表一个集合，故$f\neq f(x)$  
如果关系$f$具备下面两种情况之一，那么$f$就不是函数关系：  
（1）存在元素$a\in A$,在$B$中没有像；（2）存在元素$a\in A$, 在$ B$中至少有两个像。  
例如，关系$\begin{array}{r}{F_{1}=\{\langle x_{1},y_{1}\rangle,\langle x_{2},y_{1}\rangle,\langle x_{3},y_{2}\rangle,\langle x_{4},y_{3}\rangle\}}\end{array}$是函数，而如下关系：
$$
F_{2}=\{\langle x_{1},y_{1}\rangle,\langle x_{2},y_{1}\rangle,\langle x_{3},y_{2}\rangle,\langle x_{1},y_{2}\rangle\}
$$  
则不是函数，因为同时有$\langle x_{1},y_{1}\rangle\in F_{2}$和$\langle x_{1},y_{2}\rangle\in F_{2}$  
由上述例题可知，函数作为一种特殊关系或特殊集合，其集合运算的结果可能不再是函数。因此，要慎用函数的集合运算。另一方面，由于函数是一种特殊子集，因此可用集合相等的概念来定义两个函数相等，具体定义如下：  
【定义7.2】设$𝐴$和$B$是任意两个非空集合，$f,g$是两个从$A$到$B$的函数关系，如果$f$和$g$相互包含，即有$f\subseteq g\wedge g\subseteq f$，则称函数$f$和函数$g$相等，记为$f=g$。换句话说，如果$dom $$f=$$dom$ $g$且对$\forall x\in\mathsf{d o m}$ $f=\mathrm{dom}$ $g$有$f(x)=g(x)$，称$f$与$g$相等。  
从上述定义可以看出，两个函数相等不仅要求它们的对应关系相等，而且要求它们的定义域也要相同，两者缺一不可。  
现考察有限集合上函数的计数问题，即算出有限集合上有多少种不同函数。设集合$ A=$$\{a_{1},a_{2},\cdots,a_{n}\}$，$B=\{b_{1},b_{2},\cdots,b_{m}\}$，则要确定一个从$𝐴$到$B$的函数$ f$，就必须对$𝐴$中每个元素$a_{i}$，在$B$中找到一个唯一确定的元素$b_{m_{i}}$与之对应。显然，对于$𝐴$中每个元素$a_{i}$都有$|B|=m$种选择$b_{m_{i}}$的方式。而集合𝐴中共有$|A|=n$个元素，故根据乘法原理，得到所有方式的组合数为$m^{n}$或$|B|^{|A|}$种。即从$A$到$B$的不同函数一共有$|B|^{|A|}$种。由此得到如下定理：  
【定理7.1】设$𝐴$和$B$是任意两个非空有限集合，则从$A$到$B$一共有$|B|^{|A|}$种不同的函数。  
根据上述定理，可得到如下函数集定义及其表示方法：  
【定义7.3】设$𝐴$和$B$是任意两个非空集合，将从$A$到$B$的一切函数构成的集合称为从$𝐴$到$B$的函数集或函数空间，记为$B^{A}$。即有： $B^{A}=\{f|f\colon\ A\to B\}.$。  
根据上述定义，当$𝐴$和$B$是非空有限集合时，显然有：$|B^{A}|=|B|^{|A|}$  
通过以上分析不难发现，当𝐴和$B$为有限集时，函数和一般关系具有以下区别：  
（1）个数差异：从$𝐴$到$B$的不同关系有$2^{|A|\times|B|}$个，从$A$到$B$的不同函数仅有$|B|^{|A|}$个。  
（2）基数不同：每个函数基数均为$|A|$即$|f|=|A|$，关系的基数却为从0 到$\vert A\vert\times\vert B\vert$  
（3）第一元素的差别：关系的第一个元素可以相同，函数的第一个元素不能相同。  
下面进一步考察函数对定义域子集的映射性质，首先给出如下子集像的相关概念：  
【定义7.4】设$𝐴$和$B$是任意给定的两个非空集合，$A_{1}$和$B_{1}$分别是$𝐴$和$B$的任意两个非空子集合，即有$A_{1}\subseteq A,B_{1}\subseteq B$。$f$是一个从$𝐴$和$B$函数，即$f\colon A\to B$。  
（1）令$f(A_{1})=\{f(x)|x\in A_{1}\}$，称$f(A_{1})$为$|A_{1}$在$f$下的像。当$A_{1}=A$时，$f(A)$为$f$的像。  
（2）令$ f^{-1}(B_{1})=\{x|x\in A\Lambda f(x)\in B_{1}\}$，称$f^{-1}(B_{1})$为$B_{1}$在$f$下的完全原像。  
在上述定义中显然有：$f(A_{1})\subseteq B$且$f^{-1}(B_{1})\subseteq A$。  
下面定理给出了子集像的集合运算性质：  
【定理7.2】设$𝐴$和$B$是任意给定的两个非空集合，$X$和$𝑌$是集合$ A$的任意两个非空子集，即有$X\subseteq A,Y\subseteq A$。$f$是一个从$A$和$B$函数，即$f\colon A\to B$。则有：  
$$
(1)f(X\cup Y)=f(X)\cup f(Y);\ \ (2)\ \,f(X\cap Y)\subseteq f(X)\cap f(Y)
$$  
上述定理的第（2）结论等号不成立。  
事实上，设$A=\{a,b,c\}$，$B=\{1,\!2,\!3\}$，$f\colon X\to Y$为：$f(a)=1$，$f(b)=f(c)=2.$令$X=\{a,b\}$，$Y=\{c\}$，则有：$A\cap B=\emptyset$，$f(A\cap B)=\emptyset$。但是：  
$$
f(A)\ \cap f(B)=\{1,2\}\cap\{2\}\neq\emptyset
$$  
故$f(A)\ \cap f(B)\ \neq f(A\cap B)$。这表明只能成立：$f(A\cap B)\subseteq f(A)\cap f(B)\,。$  
至此，我们从二元关系的角度给了函数相关概念的本质定义，并以关系模型为基本工具分析讨论了函数的若干基本性质，为函数理论奠定了一个比较坚实的数学基础。下面就从以上函数概念及基本性质为出发点进一步介绍和讨论函数的相关理论及应用。",从集合A到B的所有函数构成函数集B^A
函数,映射,子集像,,"在初等数学或高等数学中，函数的概念从变量角度提出，而且主要局限于在实数集。计算机相关领域处理的对象除了实数之外，还有很多其它对象，例如矩阵、向量、命题等等，而且主要面对的是各种可数的离散对象。为此，需要扩展初等数学或高等数学中函数概念的含义，从集合与关系的角度给函数下一个更加本质性的定义，具体如下：  
【定义7.1】设$𝐴$和$B$是任意两个非空集合，$f$是从$𝐴$到$B$的关系。若对$\forall x\in A$都存在唯一的$y\in B$，满足$\langle x,y\rangle\in f$，则称关系$f$为从$𝐴$到$B$的函数关系，简称为函数或映射,记为 $f\!:\!A\longrightarrow$  
$B$或$y=f(x)$，并称$x$为$f$的自变量或源点，$𝑦$为$ x$在$f$下的函数值或像点。集合$𝐴$称为$𝑓$的定义域，记为$dom$ $f=A$，所有像点组成的集合称为$f$的值域或$f$的像，记为$ran $$f$或$f(A)$。  
从上述定义可以看出，函数$f$是从集合$𝐴$到$B$的一种特殊二元关系，这种二元关系所包含序偶的第一元素为自变量，第二元素为因变量或函数值。函数的定义域就是关系的前域$𝐴$，要求关系中所有序偶的第一元素互不相同并且要取遍集合$𝐴$中的每个元素。作为刻画作为函数的本质单值特征，要求对于关系中的任意两个序偶，若它们的第一元素相同，则第二元素必须相同。具体地说，如果一个从集合$𝐴$到$B$二元关系$f$，那么它必须满足如下几个性质：  
(1)$\langle x,y\rangle\in f\Leftrightarrow y=f(x);\qquad\mathrm{(2)}\ \langle x,y\rangle\in f\wedge\langle x,z\rangle\in f\Rightarrow y=z;$  
（3）$|f|=|A|$； （4）$f(x)$表示一个变值，$f$代表一个集合，故$f\neq f(x)$  
如果关系$f$具备下面两种情况之一，那么$f$就不是函数关系：  
（1）存在元素$a\in A$,在$B$中没有像；（2）存在元素$a\in A$, 在$ B$中至少有两个像。  
例如，关系$\begin{array}{r}{F_{1}=\{\langle x_{1},y_{1}\rangle,\langle x_{2},y_{1}\rangle,\langle x_{3},y_{2}\rangle,\langle x_{4},y_{3}\rangle\}}\end{array}$是函数，而如下关系：
$$
F_{2}=\{\langle x_{1},y_{1}\rangle,\langle x_{2},y_{1}\rangle,\langle x_{3},y_{2}\rangle,\langle x_{1},y_{2}\rangle\}
$$  
则不是函数，因为同时有$\langle x_{1},y_{1}\rangle\in F_{2}$和$\langle x_{1},y_{2}\rangle\in F_{2}$  
由上述例题可知，函数作为一种特殊关系或特殊集合，其集合运算的结果可能不再是函数。因此，要慎用函数的集合运算。另一方面，由于函数是一种特殊子集，因此可用集合相等的概念来定义两个函数相等，具体定义如下：  
【定义7.2】设$𝐴$和$B$是任意两个非空集合，$f,g$是两个从$A$到$B$的函数关系，如果$f$和$g$相互包含，即有$f\subseteq g\wedge g\subseteq f$，则称函数$f$和函数$g$相等，记为$f=g$。换句话说，如果$dom $$f=$$dom$ $g$且对$\forall x\in\mathsf{d o m}$ $f=\mathrm{dom}$ $g$有$f(x)=g(x)$，称$f$与$g$相等。  
从上述定义可以看出，两个函数相等不仅要求它们的对应关系相等，而且要求它们的定义域也要相同，两者缺一不可。  
现考察有限集合上函数的计数问题，即算出有限集合上有多少种不同函数。设集合$ A=$$\{a_{1},a_{2},\cdots,a_{n}\}$，$B=\{b_{1},b_{2},\cdots,b_{m}\}$，则要确定一个从$𝐴$到$B$的函数$ f$，就必须对$𝐴$中每个元素$a_{i}$，在$B$中找到一个唯一确定的元素$b_{m_{i}}$与之对应。显然，对于$𝐴$中每个元素$a_{i}$都有$|B|=m$种选择$b_{m_{i}}$的方式。而集合𝐴中共有$|A|=n$个元素，故根据乘法原理，得到所有方式的组合数为$m^{n}$或$|B|^{|A|}$种。即从$A$到$B$的不同函数一共有$|B|^{|A|}$种。由此得到如下定理：  
【定理7.1】设$𝐴$和$B$是任意两个非空有限集合，则从$A$到$B$一共有$|B|^{|A|}$种不同的函数。  
根据上述定理，可得到如下函数集定义及其表示方法：  
【定义7.3】设$𝐴$和$B$是任意两个非空集合，将从$A$到$B$的一切函数构成的集合称为从$𝐴$到$B$的函数集或函数空间，记为$B^{A}$。即有： $B^{A}=\{f|f\colon\ A\to B\}.$。  
根据上述定义，当$𝐴$和$B$是非空有限集合时，显然有：$|B^{A}|=|B|^{|A|}$  
通过以上分析不难发现，当𝐴和$B$为有限集时，函数和一般关系具有以下区别：  
（1）个数差异：从$𝐴$到$B$的不同关系有$2^{|A|\times|B|}$个，从$A$到$B$的不同函数仅有$|B|^{|A|}$个。  
（2）基数不同：每个函数基数均为$|A|$即$|f|=|A|$，关系的基数却为从0 到$\vert A\vert\times\vert B\vert$  
（3）第一元素的差别：关系的第一个元素可以相同，函数的第一个元素不能相同。  
下面进一步考察函数对定义域子集的映射性质，首先给出如下子集像的相关概念：  
【定义7.4】设$𝐴$和$B$是任意给定的两个非空集合，$A_{1}$和$B_{1}$分别是$𝐴$和$B$的任意两个非空子集合，即有$A_{1}\subseteq A,B_{1}\subseteq B$。$f$是一个从$𝐴$和$B$函数，即$f\colon A\to B$。  
（1）令$f(A_{1})=\{f(x)|x\in A_{1}\}$，称$f(A_{1})$为$|A_{1}$在$f$下的像。当$A_{1}=A$时，$f(A)$为$f$的像。  
（2）令$ f^{-1}(B_{1})=\{x|x\in A\Lambda f(x)\in B_{1}\}$，称$f^{-1}(B_{1})$为$B_{1}$在$f$下的完全原像。  
在上述定义中显然有：$f(A_{1})\subseteq B$且$f^{-1}(B_{1})\subseteq A$。  
下面定理给出了子集像的集合运算性质：  
【定理7.2】设$𝐴$和$B$是任意给定的两个非空集合，$X$和$𝑌$是集合$ A$的任意两个非空子集，即有$X\subseteq A,Y\subseteq A$。$f$是一个从$A$和$B$函数，即$f\colon A\to B$。则有：  
$$
(1)f(X\cup Y)=f(X)\cup f(Y);\ \ (2)\ \,f(X\cap Y)\subseteq f(X)\cap f(Y)
$$  
上述定理的第（2）结论等号不成立。  
事实上，设$A=\{a,b,c\}$，$B=\{1,\!2,\!3\}$，$f\colon X\to Y$为：$f(a)=1$，$f(b)=f(c)=2.$令$X=\{a,b\}$，$Y=\{c\}$，则有：$A\cap B=\emptyset$，$f(A\cap B)=\emptyset$。但是：  
$$
f(A)\ \cap f(B)=\{1,2\}\cap\{2\}\neq\emptyset
$$  
故$f(A)\ \cap f(B)\ \neq f(A\cap B)$。这表明只能成立：$f(A\cap B)\subseteq f(A)\cap f(B)\,。$  
至此，我们从二元关系的角度给了函数相关概念的本质定义，并以关系模型为基本工具分析讨论了函数的若干基本性质，为函数理论奠定了一个比较坚实的数学基础。下面就从以上函数概念及基本性质为出发点进一步介绍和讨论函数的相关理论及应用。",函数对定义域子集的映射形成子集像
定理7.1,计数,函数,,"在初等数学或高等数学中，函数的概念从变量角度提出，而且主要局限于在实数集。计算机相关领域处理的对象除了实数之外，还有很多其它对象，例如矩阵、向量、命题等等，而且主要面对的是各种可数的离散对象。为此，需要扩展初等数学或高等数学中函数概念的含义，从集合与关系的角度给函数下一个更加本质性的定义，具体如下：  
【定义7.1】设$𝐴$和$B$是任意两个非空集合，$f$是从$𝐴$到$B$的关系。若对$\forall x\in A$都存在唯一的$y\in B$，满足$\langle x,y\rangle\in f$，则称关系$f$为从$𝐴$到$B$的函数关系，简称为函数或映射,记为 $f\!:\!A\longrightarrow$  
$B$或$y=f(x)$，并称$x$为$f$的自变量或源点，$𝑦$为$ x$在$f$下的函数值或像点。集合$𝐴$称为$𝑓$的定义域，记为$dom$ $f=A$，所有像点组成的集合称为$f$的值域或$f$的像，记为$ran $$f$或$f(A)$。  
从上述定义可以看出，函数$f$是从集合$𝐴$到$B$的一种特殊二元关系，这种二元关系所包含序偶的第一元素为自变量，第二元素为因变量或函数值。函数的定义域就是关系的前域$𝐴$，要求关系中所有序偶的第一元素互不相同并且要取遍集合$𝐴$中的每个元素。作为刻画作为函数的本质单值特征，要求对于关系中的任意两个序偶，若它们的第一元素相同，则第二元素必须相同。具体地说，如果一个从集合$𝐴$到$B$二元关系$f$，那么它必须满足如下几个性质：  
(1)$\langle x,y\rangle\in f\Leftrightarrow y=f(x);\qquad\mathrm{(2)}\ \langle x,y\rangle\in f\wedge\langle x,z\rangle\in f\Rightarrow y=z;$  
（3）$|f|=|A|$； （4）$f(x)$表示一个变值，$f$代表一个集合，故$f\neq f(x)$  
如果关系$f$具备下面两种情况之一，那么$f$就不是函数关系：  
（1）存在元素$a\in A$,在$B$中没有像；（2）存在元素$a\in A$, 在$ B$中至少有两个像。  
例如，关系$\begin{array}{r}{F_{1}=\{\langle x_{1},y_{1}\rangle,\langle x_{2},y_{1}\rangle,\langle x_{3},y_{2}\rangle,\langle x_{4},y_{3}\rangle\}}\end{array}$是函数，而如下关系：
$$
F_{2}=\{\langle x_{1},y_{1}\rangle,\langle x_{2},y_{1}\rangle,\langle x_{3},y_{2}\rangle,\langle x_{1},y_{2}\rangle\}
$$  
则不是函数，因为同时有$\langle x_{1},y_{1}\rangle\in F_{2}$和$\langle x_{1},y_{2}\rangle\in F_{2}$  
由上述例题可知，函数作为一种特殊关系或特殊集合，其集合运算的结果可能不再是函数。因此，要慎用函数的集合运算。另一方面，由于函数是一种特殊子集，因此可用集合相等的概念来定义两个函数相等，具体定义如下：  
【定义7.2】设$𝐴$和$B$是任意两个非空集合，$f,g$是两个从$A$到$B$的函数关系，如果$f$和$g$相互包含，即有$f\subseteq g\wedge g\subseteq f$，则称函数$f$和函数$g$相等，记为$f=g$。换句话说，如果$dom $$f=$$dom$ $g$且对$\forall x\in\mathsf{d o m}$ $f=\mathrm{dom}$ $g$有$f(x)=g(x)$，称$f$与$g$相等。  
从上述定义可以看出，两个函数相等不仅要求它们的对应关系相等，而且要求它们的定义域也要相同，两者缺一不可。  
现考察有限集合上函数的计数问题，即算出有限集合上有多少种不同函数。设集合$ A=$$\{a_{1},a_{2},\cdots,a_{n}\}$，$B=\{b_{1},b_{2},\cdots,b_{m}\}$，则要确定一个从$𝐴$到$B$的函数$ f$，就必须对$𝐴$中每个元素$a_{i}$，在$B$中找到一个唯一确定的元素$b_{m_{i}}$与之对应。显然，对于$𝐴$中每个元素$a_{i}$都有$|B|=m$种选择$b_{m_{i}}$的方式。而集合𝐴中共有$|A|=n$个元素，故根据乘法原理，得到所有方式的组合数为$m^{n}$或$|B|^{|A|}$种。即从$A$到$B$的不同函数一共有$|B|^{|A|}$种。由此得到如下定理：  
【定理7.1】设$𝐴$和$B$是任意两个非空有限集合，则从$A$到$B$一共有$|B|^{|A|}$种不同的函数。  
根据上述定理，可得到如下函数集定义及其表示方法：  
【定义7.3】设$𝐴$和$B$是任意两个非空集合，将从$A$到$B$的一切函数构成的集合称为从$𝐴$到$B$的函数集或函数空间，记为$B^{A}$。即有： $B^{A}=\{f|f\colon\ A\to B\}.$。  
根据上述定义，当$𝐴$和$B$是非空有限集合时，显然有：$|B^{A}|=|B|^{|A|}$  
通过以上分析不难发现，当𝐴和$B$为有限集时，函数和一般关系具有以下区别：  
（1）个数差异：从$𝐴$到$B$的不同关系有$2^{|A|\times|B|}$个，从$A$到$B$的不同函数仅有$|B|^{|A|}$个。  
（2）基数不同：每个函数基数均为$|A|$即$|f|=|A|$，关系的基数却为从0 到$\vert A\vert\times\vert B\vert$  
（3）第一元素的差别：关系的第一个元素可以相同，函数的第一个元素不能相同。  
下面进一步考察函数对定义域子集的映射性质，首先给出如下子集像的相关概念：  
【定义7.4】设$𝐴$和$B$是任意给定的两个非空集合，$A_{1}$和$B_{1}$分别是$𝐴$和$B$的任意两个非空子集合，即有$A_{1}\subseteq A,B_{1}\subseteq B$。$f$是一个从$𝐴$和$B$函数，即$f\colon A\to B$。  
（1）令$f(A_{1})=\{f(x)|x\in A_{1}\}$，称$f(A_{1})$为$|A_{1}$在$f$下的像。当$A_{1}=A$时，$f(A)$为$f$的像。  
（2）令$ f^{-1}(B_{1})=\{x|x\in A\Lambda f(x)\in B_{1}\}$，称$f^{-1}(B_{1})$为$B_{1}$在$f$下的完全原像。  
在上述定义中显然有：$f(A_{1})\subseteq B$且$f^{-1}(B_{1})\subseteq A$。  
下面定理给出了子集像的集合运算性质：  
【定理7.2】设$𝐴$和$B$是任意给定的两个非空集合，$X$和$𝑌$是集合$ A$的任意两个非空子集，即有$X\subseteq A,Y\subseteq A$。$f$是一个从$A$和$B$函数，即$f\colon A\to B$。则有：  
$$
(1)f(X\cup Y)=f(X)\cup f(Y);\ \ (2)\ \,f(X\cap Y)\subseteq f(X)\cap f(Y)
$$  
上述定理的第（2）结论等号不成立。  
事实上，设$A=\{a,b,c\}$，$B=\{1,\!2,\!3\}$，$f\colon X\to Y$为：$f(a)=1$，$f(b)=f(c)=2.$令$X=\{a,b\}$，$Y=\{c\}$，则有：$A\cap B=\emptyset$，$f(A\cap B)=\emptyset$。但是：  
$$
f(A)\ \cap f(B)=\{1,2\}\cap\{2\}\neq\emptyset
$$  
故$f(A)\ \cap f(B)\ \neq f(A\cap B)$。这表明只能成立：$f(A\cap B)\subseteq f(A)\cap f(B)\,。$  
至此，我们从二元关系的角度给了函数相关概念的本质定义，并以关系模型为基本工具分析讨论了函数的若干基本性质，为函数理论奠定了一个比较坚实的数学基础。下面就从以上函数概念及基本性质为出发点进一步介绍和讨论函数的相关理论及应用。",定理7.1描述了从集合A到B的不同函数的数量为|B|^|A|
定理7.2,性质,子集像,,"在初等数学或高等数学中，函数的概念从变量角度提出，而且主要局限于在实数集。计算机相关领域处理的对象除了实数之外，还有很多其它对象，例如矩阵、向量、命题等等，而且主要面对的是各种可数的离散对象。为此，需要扩展初等数学或高等数学中函数概念的含义，从集合与关系的角度给函数下一个更加本质性的定义，具体如下：  
【定义7.1】设$𝐴$和$B$是任意两个非空集合，$f$是从$𝐴$到$B$的关系。若对$\forall x\in A$都存在唯一的$y\in B$，满足$\langle x,y\rangle\in f$，则称关系$f$为从$𝐴$到$B$的函数关系，简称为函数或映射,记为 $f\!:\!A\longrightarrow$  
$B$或$y=f(x)$，并称$x$为$f$的自变量或源点，$𝑦$为$ x$在$f$下的函数值或像点。集合$𝐴$称为$𝑓$的定义域，记为$dom$ $f=A$，所有像点组成的集合称为$f$的值域或$f$的像，记为$ran $$f$或$f(A)$。  
从上述定义可以看出，函数$f$是从集合$𝐴$到$B$的一种特殊二元关系，这种二元关系所包含序偶的第一元素为自变量，第二元素为因变量或函数值。函数的定义域就是关系的前域$𝐴$，要求关系中所有序偶的第一元素互不相同并且要取遍集合$𝐴$中的每个元素。作为刻画作为函数的本质单值特征，要求对于关系中的任意两个序偶，若它们的第一元素相同，则第二元素必须相同。具体地说，如果一个从集合$𝐴$到$B$二元关系$f$，那么它必须满足如下几个性质：  
(1)$\langle x,y\rangle\in f\Leftrightarrow y=f(x);\qquad\mathrm{(2)}\ \langle x,y\rangle\in f\wedge\langle x,z\rangle\in f\Rightarrow y=z;$  
（3）$|f|=|A|$； （4）$f(x)$表示一个变值，$f$代表一个集合，故$f\neq f(x)$  
如果关系$f$具备下面两种情况之一，那么$f$就不是函数关系：  
（1）存在元素$a\in A$,在$B$中没有像；（2）存在元素$a\in A$, 在$ B$中至少有两个像。  
例如，关系$\begin{array}{r}{F_{1}=\{\langle x_{1},y_{1}\rangle,\langle x_{2},y_{1}\rangle,\langle x_{3},y_{2}\rangle,\langle x_{4},y_{3}\rangle\}}\end{array}$是函数，而如下关系：
$$
F_{2}=\{\langle x_{1},y_{1}\rangle,\langle x_{2},y_{1}\rangle,\langle x_{3},y_{2}\rangle,\langle x_{1},y_{2}\rangle\}
$$  
则不是函数，因为同时有$\langle x_{1},y_{1}\rangle\in F_{2}$和$\langle x_{1},y_{2}\rangle\in F_{2}$  
由上述例题可知，函数作为一种特殊关系或特殊集合，其集合运算的结果可能不再是函数。因此，要慎用函数的集合运算。另一方面，由于函数是一种特殊子集，因此可用集合相等的概念来定义两个函数相等，具体定义如下：  
【定义7.2】设$𝐴$和$B$是任意两个非空集合，$f,g$是两个从$A$到$B$的函数关系，如果$f$和$g$相互包含，即有$f\subseteq g\wedge g\subseteq f$，则称函数$f$和函数$g$相等，记为$f=g$。换句话说，如果$dom $$f=$$dom$ $g$且对$\forall x\in\mathsf{d o m}$ $f=\mathrm{dom}$ $g$有$f(x)=g(x)$，称$f$与$g$相等。  
从上述定义可以看出，两个函数相等不仅要求它们的对应关系相等，而且要求它们的定义域也要相同，两者缺一不可。  
现考察有限集合上函数的计数问题，即算出有限集合上有多少种不同函数。设集合$ A=$$\{a_{1},a_{2},\cdots,a_{n}\}$，$B=\{b_{1},b_{2},\cdots,b_{m}\}$，则要确定一个从$𝐴$到$B$的函数$ f$，就必须对$𝐴$中每个元素$a_{i}$，在$B$中找到一个唯一确定的元素$b_{m_{i}}$与之对应。显然，对于$𝐴$中每个元素$a_{i}$都有$|B|=m$种选择$b_{m_{i}}$的方式。而集合𝐴中共有$|A|=n$个元素，故根据乘法原理，得到所有方式的组合数为$m^{n}$或$|B|^{|A|}$种。即从$A$到$B$的不同函数一共有$|B|^{|A|}$种。由此得到如下定理：  
【定理7.1】设$𝐴$和$B$是任意两个非空有限集合，则从$A$到$B$一共有$|B|^{|A|}$种不同的函数。  
根据上述定理，可得到如下函数集定义及其表示方法：  
【定义7.3】设$𝐴$和$B$是任意两个非空集合，将从$A$到$B$的一切函数构成的集合称为从$𝐴$到$B$的函数集或函数空间，记为$B^{A}$。即有： $B^{A}=\{f|f\colon\ A\to B\}.$。  
根据上述定义，当$𝐴$和$B$是非空有限集合时，显然有：$|B^{A}|=|B|^{|A|}$  
通过以上分析不难发现，当𝐴和$B$为有限集时，函数和一般关系具有以下区别：  
（1）个数差异：从$𝐴$到$B$的不同关系有$2^{|A|\times|B|}$个，从$A$到$B$的不同函数仅有$|B|^{|A|}$个。  
（2）基数不同：每个函数基数均为$|A|$即$|f|=|A|$，关系的基数却为从0 到$\vert A\vert\times\vert B\vert$  
（3）第一元素的差别：关系的第一个元素可以相同，函数的第一个元素不能相同。  
下面进一步考察函数对定义域子集的映射性质，首先给出如下子集像的相关概念：  
【定义7.4】设$𝐴$和$B$是任意给定的两个非空集合，$A_{1}$和$B_{1}$分别是$𝐴$和$B$的任意两个非空子集合，即有$A_{1}\subseteq A,B_{1}\subseteq B$。$f$是一个从$𝐴$和$B$函数，即$f\colon A\to B$。  
（1）令$f(A_{1})=\{f(x)|x\in A_{1}\}$，称$f(A_{1})$为$|A_{1}$在$f$下的像。当$A_{1}=A$时，$f(A)$为$f$的像。  
（2）令$ f^{-1}(B_{1})=\{x|x\in A\Lambda f(x)\in B_{1}\}$，称$f^{-1}(B_{1})$为$B_{1}$在$f$下的完全原像。  
在上述定义中显然有：$f(A_{1})\subseteq B$且$f^{-1}(B_{1})\subseteq A$。  
下面定理给出了子集像的集合运算性质：  
【定理7.2】设$𝐴$和$B$是任意给定的两个非空集合，$X$和$𝑌$是集合$ A$的任意两个非空子集，即有$X\subseteq A,Y\subseteq A$。$f$是一个从$A$和$B$函数，即$f\colon A\to B$。则有：  
$$
(1)f(X\cup Y)=f(X)\cup f(Y);\ \ (2)\ \,f(X\cap Y)\subseteq f(X)\cap f(Y)
$$  
上述定理的第（2）结论等号不成立。  
事实上，设$A=\{a,b,c\}$，$B=\{1,\!2,\!3\}$，$f\colon X\to Y$为：$f(a)=1$，$f(b)=f(c)=2.$令$X=\{a,b\}$，$Y=\{c\}$，则有：$A\cap B=\emptyset$，$f(A\cap B)=\emptyset$。但是：  
$$
f(A)\ \cap f(B)=\{1,2\}\cap\{2\}\neq\emptyset
$$  
故$f(A)\ \cap f(B)\ \neq f(A\cap B)$。这表明只能成立：$f(A\cap B)\subseteq f(A)\cap f(B)\,。$  
至此，我们从二元关系的角度给了函数相关概念的本质定义，并以关系模型为基本工具分析讨论了函数的若干基本性质，为函数理论奠定了一个比较坚实的数学基础。下面就从以上函数概念及基本性质为出发点进一步介绍和讨论函数的相关理论及应用。",定理7.2给出了子集像的集合运算性质，包括并集和交集的关系
函数,包含,单射函数,,"从本质上讲，从集合$𝐴$到集合$B$的函数描述的是$𝐴$中元素与$𝐵$中元素之间的一种特殊对应关系，这种特殊对应关系可以是一对一的也可以是多对一的，但不能是一对多或多对多的关系。这是函数对应关系与一般对应关系的主要差别。此外，函数值域可以是$B$的某个真子集，也可以是$B$自身。根据以上讨论，就可将所有函数分成如下四种不同的基本类型，即是单射但不是满射的函数、是满射但不是单射的函数、既是单射又是满射的函数、既不是单射也不是满射的函数。本节主要讨论这四种函数，首先给出单射函数和满射函数的定义：  
【定义7.5】设$f$从集合$𝐴$到集合$ B$的函数：  
（1）若$f$的不同自变量映射到不同的像，则称$f$为为$𝐴$到$B$的单射函数,简称为单射。也就是说，对任意的$x_{1},x_{2}\in A$，如果$x_{1}\neq x_{2}$，那么$f(x_{1})\neq f(x_{2})$，则称$f$为$𝐴$到$B$的单射。  
（2）如果集合$ B$中的每个元素都有原像，则称$f$为$𝐴$到$B$的满射函数，简称为满射；也就是说，如果$f$的值域等于$B$，即有$𝑟𝑎𝑛$ $f=B$，则称${f}$为$𝐴$到$B$的满射。  
（3）若$f$是满射且是单射，则称$f$为$𝐴$到$B$的双射；若$A=B$，则称${f}$为$𝐴$上的函数；当$𝐴$上的函数$f$是双射时，则称$f$为$𝐴$上的一个变换。  
可依据上述定义判断函数$f\colon A\to B$是否为满射、单射、双射。判断满射就是检查$B$中的每个元素是否都是函数值。如果在$B$中找到不是函数值的元素，那么$f$就不是满射的。判断单射的方法就是检查不同的自变量是否对应于不同的函数值。  
由定义7.2 和例7.1.7 可看出，若$ f$是从有限集$𝐴$到有限集$B$的函数，则$f$是单射的必要条件是$|A|\leq|B|$；$f$是满射的必要条件是$|A|\geq|B|$；$f$是双射的必要条件是$|A|=|B|$。此外，当$A$ 和$B$ 是基数相同的有限集合时，还有以下结论：  
【定理7.3】设$𝐴$，$B$是有限集合且$|A|=|B|$。如果$f$是一个从$A$到$B$的单射函数，则$f$必然是从𝐴到$B$的满射函数，反之亦然。",单射函数是函数的一种特殊类型，具有一对一的对应关系
函数,包含,满射函数,,"从本质上讲，从集合$𝐴$到集合$B$的函数描述的是$𝐴$中元素与$𝐵$中元素之间的一种特殊对应关系，这种特殊对应关系可以是一对一的也可以是多对一的，但不能是一对多或多对多的关系。这是函数对应关系与一般对应关系的主要差别。此外，函数值域可以是$B$的某个真子集，也可以是$B$自身。根据以上讨论，就可将所有函数分成如下四种不同的基本类型，即是单射但不是满射的函数、是满射但不是单射的函数、既是单射又是满射的函数、既不是单射也不是满射的函数。本节主要讨论这四种函数，首先给出单射函数和满射函数的定义：  
【定义7.5】设$f$从集合$𝐴$到集合$ B$的函数：  
（1）若$f$的不同自变量映射到不同的像，则称$f$为为$𝐴$到$B$的单射函数,简称为单射。也就是说，对任意的$x_{1},x_{2}\in A$，如果$x_{1}\neq x_{2}$，那么$f(x_{1})\neq f(x_{2})$，则称$f$为$𝐴$到$B$的单射。  
（2）如果集合$ B$中的每个元素都有原像，则称$f$为$𝐴$到$B$的满射函数，简称为满射；也就是说，如果$f$的值域等于$B$，即有$𝑟𝑎𝑛$ $f=B$，则称${f}$为$𝐴$到$B$的满射。  
（3）若$f$是满射且是单射，则称$f$为$𝐴$到$B$的双射；若$A=B$，则称${f}$为$𝐴$上的函数；当$𝐴$上的函数$f$是双射时，则称$f$为$𝐴$上的一个变换。  
可依据上述定义判断函数$f\colon A\to B$是否为满射、单射、双射。判断满射就是检查$B$中的每个元素是否都是函数值。如果在$B$中找到不是函数值的元素，那么$f$就不是满射的。判断单射的方法就是检查不同的自变量是否对应于不同的函数值。  
由定义7.2 和例7.1.7 可看出，若$ f$是从有限集$𝐴$到有限集$B$的函数，则$f$是单射的必要条件是$|A|\leq|B|$；$f$是满射的必要条件是$|A|\geq|B|$；$f$是双射的必要条件是$|A|=|B|$。此外，当$A$ 和$B$ 是基数相同的有限集合时，还有以下结论：  
【定理7.3】设$𝐴$，$B$是有限集合且$|A|=|B|$。如果$f$是一个从$A$到$B$的单射函数，则$f$必然是从𝐴到$B$的满射函数，反之亦然。",满射函数是函数的一种特殊类型，其值域等于目标集合
函数,包含,双射,,"从本质上讲，从集合$𝐴$到集合$B$的函数描述的是$𝐴$中元素与$𝐵$中元素之间的一种特殊对应关系，这种特殊对应关系可以是一对一的也可以是多对一的，但不能是一对多或多对多的关系。这是函数对应关系与一般对应关系的主要差别。此外，函数值域可以是$B$的某个真子集，也可以是$B$自身。根据以上讨论，就可将所有函数分成如下四种不同的基本类型，即是单射但不是满射的函数、是满射但不是单射的函数、既是单射又是满射的函数、既不是单射也不是满射的函数。本节主要讨论这四种函数，首先给出单射函数和满射函数的定义：  
【定义7.5】设$f$从集合$𝐴$到集合$ B$的函数：  
（1）若$f$的不同自变量映射到不同的像，则称$f$为为$𝐴$到$B$的单射函数,简称为单射。也就是说，对任意的$x_{1},x_{2}\in A$，如果$x_{1}\neq x_{2}$，那么$f(x_{1})\neq f(x_{2})$，则称$f$为$𝐴$到$B$的单射。  
（2）如果集合$ B$中的每个元素都有原像，则称$f$为$𝐴$到$B$的满射函数，简称为满射；也就是说，如果$f$的值域等于$B$，即有$𝑟𝑎𝑛$ $f=B$，则称${f}$为$𝐴$到$B$的满射。  
（3）若$f$是满射且是单射，则称$f$为$𝐴$到$B$的双射；若$A=B$，则称${f}$为$𝐴$上的函数；当$𝐴$上的函数$f$是双射时，则称$f$为$𝐴$上的一个变换。  
可依据上述定义判断函数$f\colon A\to B$是否为满射、单射、双射。判断满射就是检查$B$中的每个元素是否都是函数值。如果在$B$中找到不是函数值的元素，那么$f$就不是满射的。判断单射的方法就是检查不同的自变量是否对应于不同的函数值。  
由定义7.2 和例7.1.7 可看出，若$ f$是从有限集$𝐴$到有限集$B$的函数，则$f$是单射的必要条件是$|A|\leq|B|$；$f$是满射的必要条件是$|A|\geq|B|$；$f$是双射的必要条件是$|A|=|B|$。此外，当$A$ 和$B$ 是基数相同的有限集合时，还有以下结论：  
【定理7.3】设$𝐴$，$B$是有限集合且$|A|=|B|$。如果$f$是一个从$A$到$B$的单射函数，则$f$必然是从𝐴到$B$的满射函数，反之亦然。",双射是既是单射又是满射的函数
单射函数,互斥,满射函数,,"从本质上讲，从集合$𝐴$到集合$B$的函数描述的是$𝐴$中元素与$𝐵$中元素之间的一种特殊对应关系，这种特殊对应关系可以是一对一的也可以是多对一的，但不能是一对多或多对多的关系。这是函数对应关系与一般对应关系的主要差别。此外，函数值域可以是$B$的某个真子集，也可以是$B$自身。根据以上讨论，就可将所有函数分成如下四种不同的基本类型，即是单射但不是满射的函数、是满射但不是单射的函数、既是单射又是满射的函数、既不是单射也不是满射的函数。本节主要讨论这四种函数，首先给出单射函数和满射函数的定义：  
【定义7.5】设$f$从集合$𝐴$到集合$ B$的函数：  
（1）若$f$的不同自变量映射到不同的像，则称$f$为为$𝐴$到$B$的单射函数,简称为单射。也就是说，对任意的$x_{1},x_{2}\in A$，如果$x_{1}\neq x_{2}$，那么$f(x_{1})\neq f(x_{2})$，则称$f$为$𝐴$到$B$的单射。  
（2）如果集合$ B$中的每个元素都有原像，则称$f$为$𝐴$到$B$的满射函数，简称为满射；也就是说，如果$f$的值域等于$B$，即有$𝑟𝑎𝑛$ $f=B$，则称${f}$为$𝐴$到$B$的满射。  
（3）若$f$是满射且是单射，则称$f$为$𝐴$到$B$的双射；若$A=B$，则称${f}$为$𝐴$上的函数；当$𝐴$上的函数$f$是双射时，则称$f$为$𝐴$上的一个变换。  
可依据上述定义判断函数$f\colon A\to B$是否为满射、单射、双射。判断满射就是检查$B$中的每个元素是否都是函数值。如果在$B$中找到不是函数值的元素，那么$f$就不是满射的。判断单射的方法就是检查不同的自变量是否对应于不同的函数值。  
由定义7.2 和例7.1.7 可看出，若$ f$是从有限集$𝐴$到有限集$B$的函数，则$f$是单射的必要条件是$|A|\leq|B|$；$f$是满射的必要条件是$|A|\geq|B|$；$f$是双射的必要条件是$|A|=|B|$。此外，当$A$ 和$B$ 是基数相同的有限集合时，还有以下结论：  
【定理7.3】设$𝐴$，$B$是有限集合且$|A|=|B|$。如果$f$是一个从$A$到$B$的单射函数，则$f$必然是从𝐴到$B$的满射函数，反之亦然。",单射函数和满射函数是函数的两种不同类型，可以独立存在
单射函数,组成,双射,,"从本质上讲，从集合$𝐴$到集合$B$的函数描述的是$𝐴$中元素与$𝐵$中元素之间的一种特殊对应关系，这种特殊对应关系可以是一对一的也可以是多对一的，但不能是一对多或多对多的关系。这是函数对应关系与一般对应关系的主要差别。此外，函数值域可以是$B$的某个真子集，也可以是$B$自身。根据以上讨论，就可将所有函数分成如下四种不同的基本类型，即是单射但不是满射的函数、是满射但不是单射的函数、既是单射又是满射的函数、既不是单射也不是满射的函数。本节主要讨论这四种函数，首先给出单射函数和满射函数的定义：  
【定义7.5】设$f$从集合$𝐴$到集合$ B$的函数：  
（1）若$f$的不同自变量映射到不同的像，则称$f$为为$𝐴$到$B$的单射函数,简称为单射。也就是说，对任意的$x_{1},x_{2}\in A$，如果$x_{1}\neq x_{2}$，那么$f(x_{1})\neq f(x_{2})$，则称$f$为$𝐴$到$B$的单射。  
（2）如果集合$ B$中的每个元素都有原像，则称$f$为$𝐴$到$B$的满射函数，简称为满射；也就是说，如果$f$的值域等于$B$，即有$𝑟𝑎𝑛$ $f=B$，则称${f}$为$𝐴$到$B$的满射。  
（3）若$f$是满射且是单射，则称$f$为$𝐴$到$B$的双射；若$A=B$，则称${f}$为$𝐴$上的函数；当$𝐴$上的函数$f$是双射时，则称$f$为$𝐴$上的一个变换。  
可依据上述定义判断函数$f\colon A\to B$是否为满射、单射、双射。判断满射就是检查$B$中的每个元素是否都是函数值。如果在$B$中找到不是函数值的元素，那么$f$就不是满射的。判断单射的方法就是检查不同的自变量是否对应于不同的函数值。  
由定义7.2 和例7.1.7 可看出，若$ f$是从有限集$𝐴$到有限集$B$的函数，则$f$是单射的必要条件是$|A|\leq|B|$；$f$是满射的必要条件是$|A|\geq|B|$；$f$是双射的必要条件是$|A|=|B|$。此外，当$A$ 和$B$ 是基数相同的有限集合时，还有以下结论：  
【定理7.3】设$𝐴$，$B$是有限集合且$|A|=|B|$。如果$f$是一个从$A$到$B$的单射函数，则$f$必然是从𝐴到$B$的满射函数，反之亦然。",双射函数必须同时是单射函数
满射函数,组成,双射,,"从本质上讲，从集合$𝐴$到集合$B$的函数描述的是$𝐴$中元素与$𝐵$中元素之间的一种特殊对应关系，这种特殊对应关系可以是一对一的也可以是多对一的，但不能是一对多或多对多的关系。这是函数对应关系与一般对应关系的主要差别。此外，函数值域可以是$B$的某个真子集，也可以是$B$自身。根据以上讨论，就可将所有函数分成如下四种不同的基本类型，即是单射但不是满射的函数、是满射但不是单射的函数、既是单射又是满射的函数、既不是单射也不是满射的函数。本节主要讨论这四种函数，首先给出单射函数和满射函数的定义：  
【定义7.5】设$f$从集合$𝐴$到集合$ B$的函数：  
（1）若$f$的不同自变量映射到不同的像，则称$f$为为$𝐴$到$B$的单射函数,简称为单射。也就是说，对任意的$x_{1},x_{2}\in A$，如果$x_{1}\neq x_{2}$，那么$f(x_{1})\neq f(x_{2})$，则称$f$为$𝐴$到$B$的单射。  
（2）如果集合$ B$中的每个元素都有原像，则称$f$为$𝐴$到$B$的满射函数，简称为满射；也就是说，如果$f$的值域等于$B$，即有$𝑟𝑎𝑛$ $f=B$，则称${f}$为$𝐴$到$B$的满射。  
（3）若$f$是满射且是单射，则称$f$为$𝐴$到$B$的双射；若$A=B$，则称${f}$为$𝐴$上的函数；当$𝐴$上的函数$f$是双射时，则称$f$为$𝐴$上的一个变换。  
可依据上述定义判断函数$f\colon A\to B$是否为满射、单射、双射。判断满射就是检查$B$中的每个元素是否都是函数值。如果在$B$中找到不是函数值的元素，那么$f$就不是满射的。判断单射的方法就是检查不同的自变量是否对应于不同的函数值。  
由定义7.2 和例7.1.7 可看出，若$ f$是从有限集$𝐴$到有限集$B$的函数，则$f$是单射的必要条件是$|A|\leq|B|$；$f$是满射的必要条件是$|A|\geq|B|$；$f$是双射的必要条件是$|A|=|B|$。此外，当$A$ 和$B$ 是基数相同的有限集合时，还有以下结论：  
【定理7.3】设$𝐴$，$B$是有限集合且$|A|=|B|$。如果$f$是一个从$A$到$B$的单射函数，则$f$必然是从𝐴到$B$的满射函数，反之亦然。",双射函数必须同时是满射函数
定理7.3,条件,单射函数,,"从本质上讲，从集合$𝐴$到集合$B$的函数描述的是$𝐴$中元素与$𝐵$中元素之间的一种特殊对应关系，这种特殊对应关系可以是一对一的也可以是多对一的，但不能是一对多或多对多的关系。这是函数对应关系与一般对应关系的主要差别。此外，函数值域可以是$B$的某个真子集，也可以是$B$自身。根据以上讨论，就可将所有函数分成如下四种不同的基本类型，即是单射但不是满射的函数、是满射但不是单射的函数、既是单射又是满射的函数、既不是单射也不是满射的函数。本节主要讨论这四种函数，首先给出单射函数和满射函数的定义：  
【定义7.5】设$f$从集合$𝐴$到集合$ B$的函数：  
（1）若$f$的不同自变量映射到不同的像，则称$f$为为$𝐴$到$B$的单射函数,简称为单射。也就是说，对任意的$x_{1},x_{2}\in A$，如果$x_{1}\neq x_{2}$，那么$f(x_{1})\neq f(x_{2})$，则称$f$为$𝐴$到$B$的单射。  
（2）如果集合$ B$中的每个元素都有原像，则称$f$为$𝐴$到$B$的满射函数，简称为满射；也就是说，如果$f$的值域等于$B$，即有$𝑟𝑎𝑛$ $f=B$，则称${f}$为$𝐴$到$B$的满射。  
（3）若$f$是满射且是单射，则称$f$为$𝐴$到$B$的双射；若$A=B$，则称${f}$为$𝐴$上的函数；当$𝐴$上的函数$f$是双射时，则称$f$为$𝐴$上的一个变换。  
可依据上述定义判断函数$f\colon A\to B$是否为满射、单射、双射。判断满射就是检查$B$中的每个元素是否都是函数值。如果在$B$中找到不是函数值的元素，那么$f$就不是满射的。判断单射的方法就是检查不同的自变量是否对应于不同的函数值。  
由定义7.2 和例7.1.7 可看出，若$ f$是从有限集$𝐴$到有限集$B$的函数，则$f$是单射的必要条件是$|A|\leq|B|$；$f$是满射的必要条件是$|A|\geq|B|$；$f$是双射的必要条件是$|A|=|B|$。此外，当$A$ 和$B$ 是基数相同的有限集合时，还有以下结论：  
【定理7.3】设$𝐴$，$B$是有限集合且$|A|=|B|$。如果$f$是一个从$A$到$B$的单射函数，则$f$必然是从𝐴到$B$的满射函数，反之亦然。",定理7.3表明，在有限集合中，单射函数是满射函数的必要条件
定理7.3,条件,满射函数,,"从本质上讲，从集合$𝐴$到集合$B$的函数描述的是$𝐴$中元素与$𝐵$中元素之间的一种特殊对应关系，这种特殊对应关系可以是一对一的也可以是多对一的，但不能是一对多或多对多的关系。这是函数对应关系与一般对应关系的主要差别。此外，函数值域可以是$B$的某个真子集，也可以是$B$自身。根据以上讨论，就可将所有函数分成如下四种不同的基本类型，即是单射但不是满射的函数、是满射但不是单射的函数、既是单射又是满射的函数、既不是单射也不是满射的函数。本节主要讨论这四种函数，首先给出单射函数和满射函数的定义：  
【定义7.5】设$f$从集合$𝐴$到集合$ B$的函数：  
（1）若$f$的不同自变量映射到不同的像，则称$f$为为$𝐴$到$B$的单射函数,简称为单射。也就是说，对任意的$x_{1},x_{2}\in A$，如果$x_{1}\neq x_{2}$，那么$f(x_{1})\neq f(x_{2})$，则称$f$为$𝐴$到$B$的单射。  
（2）如果集合$ B$中的每个元素都有原像，则称$f$为$𝐴$到$B$的满射函数，简称为满射；也就是说，如果$f$的值域等于$B$，即有$𝑟𝑎𝑛$ $f=B$，则称${f}$为$𝐴$到$B$的满射。  
（3）若$f$是满射且是单射，则称$f$为$𝐴$到$B$的双射；若$A=B$，则称${f}$为$𝐴$上的函数；当$𝐴$上的函数$f$是双射时，则称$f$为$𝐴$上的一个变换。  
可依据上述定义判断函数$f\colon A\to B$是否为满射、单射、双射。判断满射就是检查$B$中的每个元素是否都是函数值。如果在$B$中找到不是函数值的元素，那么$f$就不是满射的。判断单射的方法就是检查不同的自变量是否对应于不同的函数值。  
由定义7.2 和例7.1.7 可看出，若$ f$是从有限集$𝐴$到有限集$B$的函数，则$f$是单射的必要条件是$|A|\leq|B|$；$f$是满射的必要条件是$|A|\geq|B|$；$f$是双射的必要条件是$|A|=|B|$。此外，当$A$ 和$B$ 是基数相同的有限集合时，还有以下结论：  
【定理7.3】设$𝐴$，$B$是有限集合且$|A|=|B|$。如果$f$是一个从$A$到$B$的单射函数，则$f$必然是从𝐴到$B$的满射函数，反之亦然。",定理7.3表明，在有限集合中，满射函数是单射函数的必要条件
常函数,定义区别,恒等函数,,"数学中常用的特殊函数有很多，在初等数学和高等数学中都有大量的分析讨论，例如三角函数、指数函数等基本初等函数，不再一一赘述。在此，我们主要介绍在计算机科学应用中经常使用的一些函数，例如恒等函数、常函数、取整函数、布尔函数、自然映射函数等。下面给出这些常用特殊函数的定义。  
【定义7.6】设$𝐴$和$B$是任意给定的两个非空集合：  
（1）设$f\colon A\to B$，若有$c\in B$，对$\forall x\in A$都有$f(x)=c$，则称$f\colon A\to B$是常函数。  
（2）$𝐴$上的恒等函数就是$𝐴$的恒等关系$I_{A}$，对$\forall x\in A$，有$I_{A}(x)=x$。  
（3）对实数 $x$ ， $f(x)$ 取不小于 $ x$ 的最小整数，则称 $f(x)$ 为上取整函数， 记为 $f(x)=\left\lceil x\right\rceil$  
（4）对实数$x$，$f(x)$取不大于$ x$的最大整数，则称$f(x)$为下取整函数，记为$f(x)=\lfloor x\rfloor$  
（5）如果$f(x)$是从集合$𝐴$到$B=\{0,1\}$上的函数，则称$f(x)$为布尔函数。  
（6）设$R$是$𝐴$上的等价关系，$A/R$是$𝐴$在关系$R$上的商集，令$g\colon A\to A/R$，$g(x)=[x]_{R}$则称$g$是从$A$到$A/R$的自然映射。",常函数对所有输入返回相同的值，而恒等函数返回输入值本身
上取整函数,功能对比,下取整函数,,"数学中常用的特殊函数有很多，在初等数学和高等数学中都有大量的分析讨论，例如三角函数、指数函数等基本初等函数，不再一一赘述。在此，我们主要介绍在计算机科学应用中经常使用的一些函数，例如恒等函数、常函数、取整函数、布尔函数、自然映射函数等。下面给出这些常用特殊函数的定义。  
【定义7.6】设$𝐴$和$B$是任意给定的两个非空集合：  
（1）设$f\colon A\to B$，若有$c\in B$，对$\forall x\in A$都有$f(x)=c$，则称$f\colon A\to B$是常函数。  
（2）$𝐴$上的恒等函数就是$𝐴$的恒等关系$I_{A}$，对$\forall x\in A$，有$I_{A}(x)=x$。  
（3）对实数 $x$ ， $f(x)$ 取不小于 $ x$ 的最小整数，则称 $f(x)$ 为上取整函数， 记为 $f(x)=\left\lceil x\right\rceil$  
（4）对实数$x$，$f(x)$取不大于$ x$的最大整数，则称$f(x)$为下取整函数，记为$f(x)=\lfloor x\rfloor$  
（5）如果$f(x)$是从集合$𝐴$到$B=\{0,1\}$上的函数，则称$f(x)$为布尔函数。  
（6）设$R$是$𝐴$上的等价关系，$A/R$是$𝐴$在关系$R$上的商集，令$g\colon A\to A/R$，$g(x)=[x]_{R}$则称$g$是从$A$到$A/R$的自然映射。",上取整函数返回不小于输入值的最小整数，下取整函数返回不大于输入值的最大整数
布尔函数,应用领域,自然映射,,"数学中常用的特殊函数有很多，在初等数学和高等数学中都有大量的分析讨论，例如三角函数、指数函数等基本初等函数，不再一一赘述。在此，我们主要介绍在计算机科学应用中经常使用的一些函数，例如恒等函数、常函数、取整函数、布尔函数、自然映射函数等。下面给出这些常用特殊函数的定义。  
【定义7.6】设$𝐴$和$B$是任意给定的两个非空集合：  
（1）设$f\colon A\to B$，若有$c\in B$，对$\forall x\in A$都有$f(x)=c$，则称$f\colon A\to B$是常函数。  
（2）$𝐴$上的恒等函数就是$𝐴$的恒等关系$I_{A}$，对$\forall x\in A$，有$I_{A}(x)=x$。  
（3）对实数 $x$ ， $f(x)$ 取不小于 $ x$ 的最小整数，则称 $f(x)$ 为上取整函数， 记为 $f(x)=\left\lceil x\right\rceil$  
（4）对实数$x$，$f(x)$取不大于$ x$的最大整数，则称$f(x)$为下取整函数，记为$f(x)=\lfloor x\rfloor$  
（5）如果$f(x)$是从集合$𝐴$到$B=\{0,1\}$上的函数，则称$f(x)$为布尔函数。  
（6）设$R$是$𝐴$上的等价关系，$A/R$是$𝐴$在关系$R$上的商集，令$g\colon A\to A/R$，$g(x)=[x]_{R}$则称$g$是从$A$到$A/R$的自然映射。",布尔函数用于逻辑运算，自然映射用于集合的等价关系划分
函数的基本运算,包含,加,,函数的运算对于大家来说并不陌生，我们在初等数学和高等数学中都会经常使用函数运算实现问题求解。事实上，函数的运算有很多种，除了前述的加、减、乘、除等算术运算之外，还有复合运算、逆运算、积分运算、微分运算等等，这里不再一一枚举。本节主要从关系的角度介绍和考察与计算机领域密切相关的一些函数运算。如前所述，函数作为一种表示特殊二元关系的集合，其交、并、补、差运算结果不一定还是函数关系。因此，我们不再考虑函数关系的集合运算，而着重考察函数关系的复合运算、逆运算和递归运算。,加是函数的基本运算之一
函数的基本运算,包含,减,,函数的运算对于大家来说并不陌生，我们在初等数学和高等数学中都会经常使用函数运算实现问题求解。事实上，函数的运算有很多种，除了前述的加、减、乘、除等算术运算之外，还有复合运算、逆运算、积分运算、微分运算等等，这里不再一一枚举。本节主要从关系的角度介绍和考察与计算机领域密切相关的一些函数运算。如前所述，函数作为一种表示特殊二元关系的集合，其交、并、补、差运算结果不一定还是函数关系。因此，我们不再考虑函数关系的集合运算，而着重考察函数关系的复合运算、逆运算和递归运算。,减是函数的基本运算之一
函数的基本运算,包含,乘,,函数的运算对于大家来说并不陌生，我们在初等数学和高等数学中都会经常使用函数运算实现问题求解。事实上，函数的运算有很多种，除了前述的加、减、乘、除等算术运算之外，还有复合运算、逆运算、积分运算、微分运算等等，这里不再一一枚举。本节主要从关系的角度介绍和考察与计算机领域密切相关的一些函数运算。如前所述，函数作为一种表示特殊二元关系的集合，其交、并、补、差运算结果不一定还是函数关系。因此，我们不再考虑函数关系的集合运算，而着重考察函数关系的复合运算、逆运算和递归运算。,乘是函数的基本运算之一
函数的基本运算,包含,除,,函数的运算对于大家来说并不陌生，我们在初等数学和高等数学中都会经常使用函数运算实现问题求解。事实上，函数的运算有很多种，除了前述的加、减、乘、除等算术运算之外，还有复合运算、逆运算、积分运算、微分运算等等，这里不再一一枚举。本节主要从关系的角度介绍和考察与计算机领域密切相关的一些函数运算。如前所述，函数作为一种表示特殊二元关系的集合，其交、并、补、差运算结果不一定还是函数关系。因此，我们不再考虑函数关系的集合运算，而着重考察函数关系的复合运算、逆运算和递归运算。,除是函数的基本运算之一
函数的基本运算,包含,复合运算,,函数的运算对于大家来说并不陌生，我们在初等数学和高等数学中都会经常使用函数运算实现问题求解。事实上，函数的运算有很多种，除了前述的加、减、乘、除等算术运算之外，还有复合运算、逆运算、积分运算、微分运算等等，这里不再一一枚举。本节主要从关系的角度介绍和考察与计算机领域密切相关的一些函数运算。如前所述，函数作为一种表示特殊二元关系的集合，其交、并、补、差运算结果不一定还是函数关系。因此，我们不再考虑函数关系的集合运算，而着重考察函数关系的复合运算、逆运算和递归运算。,复合运算是函数的基本运算之一
函数的基本运算,包含,逆运算,,函数的运算对于大家来说并不陌生，我们在初等数学和高等数学中都会经常使用函数运算实现问题求解。事实上，函数的运算有很多种，除了前述的加、减、乘、除等算术运算之外，还有复合运算、逆运算、积分运算、微分运算等等，这里不再一一枚举。本节主要从关系的角度介绍和考察与计算机领域密切相关的一些函数运算。如前所述，函数作为一种表示特殊二元关系的集合，其交、并、补、差运算结果不一定还是函数关系。因此，我们不再考虑函数关系的集合运算，而着重考察函数关系的复合运算、逆运算和递归运算。,逆运算是函数的基本运算之一
函数的基本运算,包含,积分运算,,函数的运算对于大家来说并不陌生，我们在初等数学和高等数学中都会经常使用函数运算实现问题求解。事实上，函数的运算有很多种，除了前述的加、减、乘、除等算术运算之外，还有复合运算、逆运算、积分运算、微分运算等等，这里不再一一枚举。本节主要从关系的角度介绍和考察与计算机领域密切相关的一些函数运算。如前所述，函数作为一种表示特殊二元关系的集合，其交、并、补、差运算结果不一定还是函数关系。因此，我们不再考虑函数关系的集合运算，而着重考察函数关系的复合运算、逆运算和递归运算。,积分运算是函数的基本运算之一
函数的基本运算,包含,微分运算,,函数的运算对于大家来说并不陌生，我们在初等数学和高等数学中都会经常使用函数运算实现问题求解。事实上，函数的运算有很多种，除了前述的加、减、乘、除等算术运算之外，还有复合运算、逆运算、积分运算、微分运算等等，这里不再一一枚举。本节主要从关系的角度介绍和考察与计算机领域密切相关的一些函数运算。如前所述，函数作为一种表示特殊二元关系的集合，其交、并、补、差运算结果不一定还是函数关系。因此，我们不再考虑函数关系的集合运算，而着重考察函数关系的复合运算、逆运算和递归运算。,微分运算是函数的基本运算之一
函数的基本运算,包含,递归运算,,函数的运算对于大家来说并不陌生，我们在初等数学和高等数学中都会经常使用函数运算实现问题求解。事实上，函数的运算有很多种，除了前述的加、减、乘、除等算术运算之外，还有复合运算、逆运算、积分运算、微分运算等等，这里不再一一枚举。本节主要从关系的角度介绍和考察与计算机领域密切相关的一些函数运算。如前所述，函数作为一种表示特殊二元关系的集合，其交、并、补、差运算结果不一定还是函数关系。因此，我们不再考虑函数关系的集合运算，而着重考察函数关系的复合运算、逆运算和递归运算。,递归运算是函数的基本运算之一
函数的复合运算,定义,定理7.4,,"前面已经学习了二元关系的复合运算，函数作为一种特殊的二元关系，也可以进行复合运算，函数的复合运算其实就是函数关系的合成，下面定理保证了两个函数关系的复合后得到的关系仍然是一个函数关系，并据此得到复合函数的定义：  
【定理7.4】设$f\colon A\to B,g\colon B\to C$是两个函数，则$f$与$g$的复合关系：  
$f\circ g=\{\langle x,z\rangle|x\in A\wedge z\in C\wedge(\exists y)(y\in B\wedge xfy\wedge ygz)\}\quad\text{(7-1)}$  
是一个从$𝐴$到$C$的函数，称之为函数$f$与$g$的复合函数，记为$f\circ g\colon A\to C$。  
根据上述定理，由于两个函数的复合运算结果仍然是一个函数，故可将函数复合运算直接推广到多个函数的情形，并且多个函数复合运算结果仍是函数。由于函数复合是关系复合的一种特殊情形，故多个函数的复合同样满足结合律。此外，从上述定理可以看出：  
（1）函数$ f$与$g$可以复合的前提条件是，前一个函数$f$的值域$ran$ $f$必须是后一个函数$g$定义域$dom$ $g$的子集合，即有：$ran $$f\subseteq\operatorname{dom}\ g=B$；  
（2）复合函数$f\circ g$的定义域$\operatorname{dom}(f\circ g)$是前一个函数$ f$的定义域$dom$ $f$，值域ran$(f\circ g)$是后一个函数$$g$$的值域，即有：$\operatorname{dom}(f\circ g)=\operatorname{dom}\ f=A,\ \operatorname{ran}(f\circ g)=r a n g;$  
（3）对$\forall x\in A$，有：$f\circ g(x)=g(f(x))。$  
下面定理给出了函数单射、满射和双射性质在复合运算下的保持性：  
【定理7.5】设$f\colon A\to B,g\colon B\to C$是两个函数。  
（1）如果函数$f$和$g$都是满射，则复合函数$f\circ g$也是从$A$到$C$满射；  
（2）如果函数$f$和$g$都是单射，则复合函数$f\circ g$也是从$𝐴$到$C$单射；  
（3）如果函数$f$和$g$都是双射，则复合函数$f\circ g$也是从𝐴到$C$双射。  
需要注意的是上述定理的逆不成立，但有以下结论：  
【定理7.6】设$f\colon A\to B,g\colon B\to C$是两个函数，则有：  
（1）如果复合函数$f\circ g$是从$𝐴$到$C$满射，则函数$g$是$B$到$C$的满射；  
（2）如果复合函数$f\circ g$是从$𝐴$到$C$单射，则函数$f$是$𝐴$是$B$的单射；  
（3）如果复合函数$f\circ g$是从$A$到$C$双射，则$f$是$A$是$B$的单射，$g$是$B$到$C$的满射。",定理7.4定义了函数的复合运算，并证明了复合运算结果仍为函数
函数的复合运算,性质保持,定理7.5,,"前面已经学习了二元关系的复合运算，函数作为一种特殊的二元关系，也可以进行复合运算，函数的复合运算其实就是函数关系的合成，下面定理保证了两个函数关系的复合后得到的关系仍然是一个函数关系，并据此得到复合函数的定义：  
【定理7.4】设$f\colon A\to B,g\colon B\to C$是两个函数，则$f$与$g$的复合关系：  
$f\circ g=\{\langle x,z\rangle|x\in A\wedge z\in C\wedge(\exists y)(y\in B\wedge xfy\wedge ygz)\}\quad\text{(7-1)}$  
是一个从$𝐴$到$C$的函数，称之为函数$f$与$g$的复合函数，记为$f\circ g\colon A\to C$。  
根据上述定理，由于两个函数的复合运算结果仍然是一个函数，故可将函数复合运算直接推广到多个函数的情形，并且多个函数复合运算结果仍是函数。由于函数复合是关系复合的一种特殊情形，故多个函数的复合同样满足结合律。此外，从上述定理可以看出：  
（1）函数$ f$与$g$可以复合的前提条件是，前一个函数$f$的值域$ran$ $f$必须是后一个函数$g$定义域$dom$ $g$的子集合，即有：$ran $$f\subseteq\operatorname{dom}\ g=B$；  
（2）复合函数$f\circ g$的定义域$\operatorname{dom}(f\circ g)$是前一个函数$ f$的定义域$dom$ $f$，值域ran$(f\circ g)$是后一个函数$$g$$的值域，即有：$\operatorname{dom}(f\circ g)=\operatorname{dom}\ f=A,\ \operatorname{ran}(f\circ g)=r a n g;$  
（3）对$\forall x\in A$，有：$f\circ g(x)=g(f(x))。$  
下面定理给出了函数单射、满射和双射性质在复合运算下的保持性：  
【定理7.5】设$f\colon A\to B,g\colon B\to C$是两个函数。  
（1）如果函数$f$和$g$都是满射，则复合函数$f\circ g$也是从$A$到$C$满射；  
（2）如果函数$f$和$g$都是单射，则复合函数$f\circ g$也是从$𝐴$到$C$单射；  
（3）如果函数$f$和$g$都是双射，则复合函数$f\circ g$也是从𝐴到$C$双射。  
需要注意的是上述定理的逆不成立，但有以下结论：  
【定理7.6】设$f\colon A\to B,g\colon B\to C$是两个函数，则有：  
（1）如果复合函数$f\circ g$是从$𝐴$到$C$满射，则函数$g$是$B$到$C$的满射；  
（2）如果复合函数$f\circ g$是从$𝐴$到$C$单射，则函数$f$是$𝐴$是$B$的单射；  
（3）如果复合函数$f\circ g$是从$A$到$C$双射，则$f$是$A$是$B$的单射，$g$是$B$到$C$的满射。",定理7.5说明了函数的单射、满射和双射性质在复合运算下的保持性
函数的复合运算,逆性质,定理7.6,,"前面已经学习了二元关系的复合运算，函数作为一种特殊的二元关系，也可以进行复合运算，函数的复合运算其实就是函数关系的合成，下面定理保证了两个函数关系的复合后得到的关系仍然是一个函数关系，并据此得到复合函数的定义：  
【定理7.4】设$f\colon A\to B,g\colon B\to C$是两个函数，则$f$与$g$的复合关系：  
$f\circ g=\{\langle x,z\rangle|x\in A\wedge z\in C\wedge(\exists y)(y\in B\wedge xfy\wedge ygz)\}\quad\text{(7-1)}$  
是一个从$𝐴$到$C$的函数，称之为函数$f$与$g$的复合函数，记为$f\circ g\colon A\to C$。  
根据上述定理，由于两个函数的复合运算结果仍然是一个函数，故可将函数复合运算直接推广到多个函数的情形，并且多个函数复合运算结果仍是函数。由于函数复合是关系复合的一种特殊情形，故多个函数的复合同样满足结合律。此外，从上述定理可以看出：  
（1）函数$ f$与$g$可以复合的前提条件是，前一个函数$f$的值域$ran$ $f$必须是后一个函数$g$定义域$dom$ $g$的子集合，即有：$ran $$f\subseteq\operatorname{dom}\ g=B$；  
（2）复合函数$f\circ g$的定义域$\operatorname{dom}(f\circ g)$是前一个函数$ f$的定义域$dom$ $f$，值域ran$(f\circ g)$是后一个函数$$g$$的值域，即有：$\operatorname{dom}(f\circ g)=\operatorname{dom}\ f=A,\ \operatorname{ran}(f\circ g)=r a n g;$  
（3）对$\forall x\in A$，有：$f\circ g(x)=g(f(x))。$  
下面定理给出了函数单射、满射和双射性质在复合运算下的保持性：  
【定理7.5】设$f\colon A\to B,g\colon B\to C$是两个函数。  
（1）如果函数$f$和$g$都是满射，则复合函数$f\circ g$也是从$A$到$C$满射；  
（2）如果函数$f$和$g$都是单射，则复合函数$f\circ g$也是从$𝐴$到$C$单射；  
（3）如果函数$f$和$g$都是双射，则复合函数$f\circ g$也是从𝐴到$C$双射。  
需要注意的是上述定理的逆不成立，但有以下结论：  
【定理7.6】设$f\colon A\to B,g\colon B\to C$是两个函数，则有：  
（1）如果复合函数$f\circ g$是从$𝐴$到$C$满射，则函数$g$是$B$到$C$的满射；  
（2）如果复合函数$f\circ g$是从$𝐴$到$C$单射，则函数$f$是$𝐴$是$B$的单射；  
（3）如果复合函数$f\circ g$是从$A$到$C$双射，则$f$是$A$是$B$的单射，$g$是$B$到$C$的满射。",定理7.6给出了复合函数的满射、单射和双射性质对原函数性质的逆推结论
定理7.4,基础,定理7.5,,"前面已经学习了二元关系的复合运算，函数作为一种特殊的二元关系，也可以进行复合运算，函数的复合运算其实就是函数关系的合成，下面定理保证了两个函数关系的复合后得到的关系仍然是一个函数关系，并据此得到复合函数的定义：  
【定理7.4】设$f\colon A\to B,g\colon B\to C$是两个函数，则$f$与$g$的复合关系：  
$f\circ g=\{\langle x,z\rangle|x\in A\wedge z\in C\wedge(\exists y)(y\in B\wedge xfy\wedge ygz)\}\quad\text{(7-1)}$  
是一个从$𝐴$到$C$的函数，称之为函数$f$与$g$的复合函数，记为$f\circ g\colon A\to C$。  
根据上述定理，由于两个函数的复合运算结果仍然是一个函数，故可将函数复合运算直接推广到多个函数的情形，并且多个函数复合运算结果仍是函数。由于函数复合是关系复合的一种特殊情形，故多个函数的复合同样满足结合律。此外，从上述定理可以看出：  
（1）函数$ f$与$g$可以复合的前提条件是，前一个函数$f$的值域$ran$ $f$必须是后一个函数$g$定义域$dom$ $g$的子集合，即有：$ran $$f\subseteq\operatorname{dom}\ g=B$；  
（2）复合函数$f\circ g$的定义域$\operatorname{dom}(f\circ g)$是前一个函数$ f$的定义域$dom$ $f$，值域ran$(f\circ g)$是后一个函数$$g$$的值域，即有：$\operatorname{dom}(f\circ g)=\operatorname{dom}\ f=A,\ \operatorname{ran}(f\circ g)=r a n g;$  
（3）对$\forall x\in A$，有：$f\circ g(x)=g(f(x))。$  
下面定理给出了函数单射、满射和双射性质在复合运算下的保持性：  
【定理7.5】设$f\colon A\to B,g\colon B\to C$是两个函数。  
（1）如果函数$f$和$g$都是满射，则复合函数$f\circ g$也是从$A$到$C$满射；  
（2）如果函数$f$和$g$都是单射，则复合函数$f\circ g$也是从$𝐴$到$C$单射；  
（3）如果函数$f$和$g$都是双射，则复合函数$f\circ g$也是从𝐴到$C$双射。  
需要注意的是上述定理的逆不成立，但有以下结论：  
【定理7.6】设$f\colon A\to B,g\colon B\to C$是两个函数，则有：  
（1）如果复合函数$f\circ g$是从$𝐴$到$C$满射，则函数$g$是$B$到$C$的满射；  
（2）如果复合函数$f\circ g$是从$𝐴$到$C$单射，则函数$f$是$𝐴$是$B$的单射；  
（3）如果复合函数$f\circ g$是从$A$到$C$双射，则$f$是$A$是$B$的单射，$g$是$B$到$C$的满射。",定理7.4为定理7.5提供了函数复合运算的基础定义
定理7.4,基础,定理7.6,,"前面已经学习了二元关系的复合运算，函数作为一种特殊的二元关系，也可以进行复合运算，函数的复合运算其实就是函数关系的合成，下面定理保证了两个函数关系的复合后得到的关系仍然是一个函数关系，并据此得到复合函数的定义：  
【定理7.4】设$f\colon A\to B,g\colon B\to C$是两个函数，则$f$与$g$的复合关系：  
$f\circ g=\{\langle x,z\rangle|x\in A\wedge z\in C\wedge(\exists y)(y\in B\wedge xfy\wedge ygz)\}\quad\text{(7-1)}$  
是一个从$𝐴$到$C$的函数，称之为函数$f$与$g$的复合函数，记为$f\circ g\colon A\to C$。  
根据上述定理，由于两个函数的复合运算结果仍然是一个函数，故可将函数复合运算直接推广到多个函数的情形，并且多个函数复合运算结果仍是函数。由于函数复合是关系复合的一种特殊情形，故多个函数的复合同样满足结合律。此外，从上述定理可以看出：  
（1）函数$ f$与$g$可以复合的前提条件是，前一个函数$f$的值域$ran$ $f$必须是后一个函数$g$定义域$dom$ $g$的子集合，即有：$ran $$f\subseteq\operatorname{dom}\ g=B$；  
（2）复合函数$f\circ g$的定义域$\operatorname{dom}(f\circ g)$是前一个函数$ f$的定义域$dom$ $f$，值域ran$(f\circ g)$是后一个函数$$g$$的值域，即有：$\operatorname{dom}(f\circ g)=\operatorname{dom}\ f=A,\ \operatorname{ran}(f\circ g)=r a n g;$  
（3）对$\forall x\in A$，有：$f\circ g(x)=g(f(x))。$  
下面定理给出了函数单射、满射和双射性质在复合运算下的保持性：  
【定理7.5】设$f\colon A\to B,g\colon B\to C$是两个函数。  
（1）如果函数$f$和$g$都是满射，则复合函数$f\circ g$也是从$A$到$C$满射；  
（2）如果函数$f$和$g$都是单射，则复合函数$f\circ g$也是从$𝐴$到$C$单射；  
（3）如果函数$f$和$g$都是双射，则复合函数$f\circ g$也是从𝐴到$C$双射。  
需要注意的是上述定理的逆不成立，但有以下结论：  
【定理7.6】设$f\colon A\to B,g\colon B\to C$是两个函数，则有：  
（1）如果复合函数$f\circ g$是从$𝐴$到$C$满射，则函数$g$是$B$到$C$的满射；  
（2）如果复合函数$f\circ g$是从$𝐴$到$C$单射，则函数$f$是$𝐴$是$B$的单射；  
（3）如果复合函数$f\circ g$是从$A$到$C$双射，则$f$是$A$是$B$的单射，$g$是$B$到$C$的满射。",定理7.4为定理7.6提供了函数复合运算的基础定义
定理7.5,补充,定理7.6,,"前面已经学习了二元关系的复合运算，函数作为一种特殊的二元关系，也可以进行复合运算，函数的复合运算其实就是函数关系的合成，下面定理保证了两个函数关系的复合后得到的关系仍然是一个函数关系，并据此得到复合函数的定义：  
【定理7.4】设$f\colon A\to B,g\colon B\to C$是两个函数，则$f$与$g$的复合关系：  
$f\circ g=\{\langle x,z\rangle|x\in A\wedge z\in C\wedge(\exists y)(y\in B\wedge xfy\wedge ygz)\}\quad\text{(7-1)}$  
是一个从$𝐴$到$C$的函数，称之为函数$f$与$g$的复合函数，记为$f\circ g\colon A\to C$。  
根据上述定理，由于两个函数的复合运算结果仍然是一个函数，故可将函数复合运算直接推广到多个函数的情形，并且多个函数复合运算结果仍是函数。由于函数复合是关系复合的一种特殊情形，故多个函数的复合同样满足结合律。此外，从上述定理可以看出：  
（1）函数$ f$与$g$可以复合的前提条件是，前一个函数$f$的值域$ran$ $f$必须是后一个函数$g$定义域$dom$ $g$的子集合，即有：$ran $$f\subseteq\operatorname{dom}\ g=B$；  
（2）复合函数$f\circ g$的定义域$\operatorname{dom}(f\circ g)$是前一个函数$ f$的定义域$dom$ $f$，值域ran$(f\circ g)$是后一个函数$$g$$的值域，即有：$\operatorname{dom}(f\circ g)=\operatorname{dom}\ f=A,\ \operatorname{ran}(f\circ g)=r a n g;$  
（3）对$\forall x\in A$，有：$f\circ g(x)=g(f(x))。$  
下面定理给出了函数单射、满射和双射性质在复合运算下的保持性：  
【定理7.5】设$f\colon A\to B,g\colon B\to C$是两个函数。  
（1）如果函数$f$和$g$都是满射，则复合函数$f\circ g$也是从$A$到$C$满射；  
（2）如果函数$f$和$g$都是单射，则复合函数$f\circ g$也是从$𝐴$到$C$单射；  
（3）如果函数$f$和$g$都是双射，则复合函数$f\circ g$也是从𝐴到$C$双射。  
需要注意的是上述定理的逆不成立，但有以下结论：  
【定理7.6】设$f\colon A\to B,g\colon B\to C$是两个函数，则有：  
（1）如果复合函数$f\circ g$是从$𝐴$到$C$满射，则函数$g$是$B$到$C$的满射；  
（2）如果复合函数$f\circ g$是从$𝐴$到$C$单射，则函数$f$是$𝐴$是$B$的单射；  
（3）如果复合函数$f\circ g$是从$A$到$C$双射，则$f$是$A$是$B$的单射，$g$是$B$到$C$的满射。",定理7.6补充了定理7.5中函数性质逆推的结论
函数的逆运算,定义,逆函数,,"在一般关系$𝑅$的求逆运算中，任意关系都可进行求逆运算而得到其逆关系，但是对于任意一个函数$𝑓$来说，只能保证它的逆$f^{-1}$是一个二元关系，并不能保证$f^{-1}$一定是函数关系。因此，在求一个函数的逆运算时，必须对该函数做一些特殊的要求。  
【定义7.7】设$f\colon A\to B$的函数关系，如果其逆关系：  
$$
f^{-1}=\{\langle y,x\rangle|x\in A\land y\in B\land\langle x,y\rangle\in f\}\quad\text{(7-2)}
$$  
是一个从$B$到$𝐴$的函数关系，则函数$f$可逆，并称$f^{-1}$是函数$f$的逆函数或反函数。  
由上述定义可可知，如果函数$f$可逆，则$f^{-1}$作为一个从$B$到$𝐴$的函数，集合$ B$中每个元素都有$ f^{-1}$下的像，而根据逆关系的定义，$B$中每个元素在函数$f^{-1}$下的像其实就是该元素在函数$f$下的原像，故$f$是从$𝐴$到$B$的满射。另一方面，$f^{-1}$作为一个函数，集合$ B$中每个元素都有$A$中唯一的元素与之对应。从函数$ f$的角度看，就是$𝐴$中不同的元素对应不同的像，因此，函数$f$是单射。综上所述，函数$f$存在逆函数$f^{-1}$当且仅当$f$是双射。  
【定理7.7】设$f\colon A\to B$的双射函数，则$f$的逆函数$f^{-1}$也是从$B$到$𝐴$的双射函数。  
下面定理给出了任一双射函数与其函数反函数及恒等函数之间的关系：  
【定理7.8】设$𝑓$:$A\rightarrow B$的双射函数，则有：  
$$
(1)f^{-1}\circ f=I_{B};\mathrm{~(~2~)~}\,f\circ f^{-1}=I_{A};\mathrm{~(~3~)~}\,I_{A}\circ f=f\circ I_{B}=f。
$$  
其中$I_{A}$和$I_{B}$分别表示集合$𝐴$和集合 $B$上的恒等函数。",函数的逆运算定义了逆函数，即如果函数f的逆关系f^{-1}是从B到A的函数关系，则f可逆，f^{-1}称为f的逆函数
定理7.7,条件,逆函数,,"在一般关系$𝑅$的求逆运算中，任意关系都可进行求逆运算而得到其逆关系，但是对于任意一个函数$𝑓$来说，只能保证它的逆$f^{-1}$是一个二元关系，并不能保证$f^{-1}$一定是函数关系。因此，在求一个函数的逆运算时，必须对该函数做一些特殊的要求。  
【定义7.7】设$f\colon A\to B$的函数关系，如果其逆关系：  
$$
f^{-1}=\{\langle y,x\rangle|x\in A\land y\in B\land\langle x,y\rangle\in f\}\quad\text{(7-2)}
$$  
是一个从$B$到$𝐴$的函数关系，则函数$f$可逆，并称$f^{-1}$是函数$f$的逆函数或反函数。  
由上述定义可可知，如果函数$f$可逆，则$f^{-1}$作为一个从$B$到$𝐴$的函数，集合$ B$中每个元素都有$ f^{-1}$下的像，而根据逆关系的定义，$B$中每个元素在函数$f^{-1}$下的像其实就是该元素在函数$f$下的原像，故$f$是从$𝐴$到$B$的满射。另一方面，$f^{-1}$作为一个函数，集合$ B$中每个元素都有$A$中唯一的元素与之对应。从函数$ f$的角度看，就是$𝐴$中不同的元素对应不同的像，因此，函数$f$是单射。综上所述，函数$f$存在逆函数$f^{-1}$当且仅当$f$是双射。  
【定理7.7】设$f\colon A\to B$的双射函数，则$f$的逆函数$f^{-1}$也是从$B$到$𝐴$的双射函数。  
下面定理给出了任一双射函数与其函数反函数及恒等函数之间的关系：  
【定理7.8】设$𝑓$:$A\rightarrow B$的双射函数，则有：  
$$
(1)f^{-1}\circ f=I_{B};\mathrm{~(~2~)~}\,f\circ f^{-1}=I_{A};\mathrm{~(~3~)~}\,I_{A}\circ f=f\circ I_{B}=f。
$$  
其中$I_{A}$和$I_{B}$分别表示集合$𝐴$和集合 $B$上的恒等函数。",定理7.7表明，如果f是从A到B的双射函数，则其逆函数f^{-1}也是从B到A的双射函数
定理7.8,关系,逆函数,,"在一般关系$𝑅$的求逆运算中，任意关系都可进行求逆运算而得到其逆关系，但是对于任意一个函数$𝑓$来说，只能保证它的逆$f^{-1}$是一个二元关系，并不能保证$f^{-1}$一定是函数关系。因此，在求一个函数的逆运算时，必须对该函数做一些特殊的要求。  
【定义7.7】设$f\colon A\to B$的函数关系，如果其逆关系：  
$$
f^{-1}=\{\langle y,x\rangle|x\in A\land y\in B\land\langle x,y\rangle\in f\}\quad\text{(7-2)}
$$  
是一个从$B$到$𝐴$的函数关系，则函数$f$可逆，并称$f^{-1}$是函数$f$的逆函数或反函数。  
由上述定义可可知，如果函数$f$可逆，则$f^{-1}$作为一个从$B$到$𝐴$的函数，集合$ B$中每个元素都有$ f^{-1}$下的像，而根据逆关系的定义，$B$中每个元素在函数$f^{-1}$下的像其实就是该元素在函数$f$下的原像，故$f$是从$𝐴$到$B$的满射。另一方面，$f^{-1}$作为一个函数，集合$ B$中每个元素都有$A$中唯一的元素与之对应。从函数$ f$的角度看，就是$𝐴$中不同的元素对应不同的像，因此，函数$f$是单射。综上所述，函数$f$存在逆函数$f^{-1}$当且仅当$f$是双射。  
【定理7.7】设$f\colon A\to B$的双射函数，则$f$的逆函数$f^{-1}$也是从$B$到$𝐴$的双射函数。  
下面定理给出了任一双射函数与其函数反函数及恒等函数之间的关系：  
【定理7.8】设$𝑓$:$A\rightarrow B$的双射函数，则有：  
$$
(1)f^{-1}\circ f=I_{B};\mathrm{~(~2~)~}\,f\circ f^{-1}=I_{A};\mathrm{~(~3~)~}\,I_{A}\circ f=f\circ I_{B}=f。
$$  
其中$I_{A}$和$I_{B}$分别表示集合$𝐴$和集合 $B$上的恒等函数。",定理7.8描述了双射函数与其逆函数及恒等函数之间的关系，包括f^{-1}与f的复合等于恒等函数
函数迭代,概念关联,递归运算,,"前面从二元关系的角度讨论了函数关系的复合运算和逆运算，我们还可以将关系的幂运算引入函数关系之中。如前所述，关系的幂运算是一种特殊的复合运算，就是关系通过不断地与其自身进行复合从而产生新的关系。由于关系的复合运算满足结合律，故给定次数下的复合运算结果是唯一确定的。同样，一个函数关系也可以通过不断与其自身进行复合运算产生新的函数关系，由此可得函数迭代与递归运算的概念。  
【定义7.8】假设$𝐴$是任一给定的非空集合，$f(x)$是$A$上的某个函数，$n$个相同函数$f(x)$的复合运算称为对$f(x)$的$n$次迭代运算，运算结果记为$f^{n}(x)$，称为$f(x)$的$n$次迭代函数，并约定$f(x)$的0 次迭代函数为其自变量$x$，即有：  
$$
f^{(n)}(x)=f(f^{(n-1)}(x))\wedge f^{(0)}(x)\quad\text{(7-3)}
$$  
其中$f^{(0)}(x)=x。$  
迭代是函数的一个非常重要的运算，在很多情况下可使用函数迭代得到新的函数。例如，假设$f(x)$是自然数集上的后继函数，即有$f(x)=x+1$，则有$f^{(n)}(x)=~x+n$。还可以使用迭代方法解方程或方程组，例如牛顿迭代法、雅可比迭代法、高斯迭代法等等，有兴趣的读者可以数值分析的课程的相关内容，这里不再赘述。下面将函数迭代的概念做进一步推广，给出并讨论函数递归运算的概念。  
首先看一个引例。西萨·班·达依尔发明了国际象棋，国王问他需要什么奖赏，他说：“陛下，请您在这张棋盘的第1 个小格里赏给我一粒麦子，在第2 个小格里给2 粒，第3 个小格给4 粒，以后每一小格都比前一小格加一倍，直到摆满这64 个棋盘格”  
那么需要多少粒麦子呢？可以按如下方法计算：  
$$
f(1)=1;f(2)=2;f(3)=4;\cdots\cdots;f(n)=2*f(n-1)
$$  
最后得到：$f(64)=2^{64-1}=18446744073709551615.$是一个非常大的数字。  
上面的算式$f(n)=2*f(n-1)$表达的就是一个递归运算。该算式采用以步长为1 的逐步推进的方式，通过以$f(n-1)$为变量的某个具体表达式计算$f(n)$。  
下面给出函数递归运算的具体定义：  
【定义7.9】对于某一函数$f(x)$，其定义域是集合$𝐴$，那么若对于$𝐴$集合中的某一个值$x_{n}$，其函数值$f(x_{n})$由以$f(x_{n-1}),f(x_{n-2}),\cdots,f(x_{n-k})$变量的某个表达式确定决定，即有：  
$$
f(x_{n})=S(f(x_{n-1}),f(x_{n-2}),\cdots,f(x_{n-k}))\quad\text{(7-4)}
$$  
则称$f(x)$为一个$k$阶递归函数。  
递归函数的思想就是将复杂问题分解成若干简单且相同的子问题，将复杂的原问题转换为简单子问题的某种重复，通过简单子问题的机械重复得到复杂问题的解。  
例如，下列两个函数均为递归函数。  
（1）阶乘函数：  
$$
Fact(n)=\left\{\begin{matrix}1&&n=0\\&n*Fact(n-1)&&n>0\end{matrix}\right.
$$  
（2）2 阶的Fibonacci 数列：  
$$
Fib(n)=\begin{cases}0&\quad&n=0\\1&\quad&n=1\\&\quad&Fib(n-1)+Fib(n-2)&\quad\text{否则}\end{cases}
$$  
递归函数的上述思想非常符合计算机程序设计的思维方式。因此，递归方法是算法与程序设计的一个有效方法,使用递归方法能使程序变得简洁和清晰。  
值得注意的是，并不是任何函数都适合采用递归的形式进行计算。使用递归方式计算函  
数必须具备如下两个基本条件：  
（1）函数存在递归结束条件及结束时的值，称之为递归出口；  
（2）函数能够用递归形式表示，且递归向终止条件发展，称递归表达式为递归体。",函数迭代是通过函数自身复合运算产生新函数的过程，而递归运算则是通过函数的前若干个值来确定当前值的运算方式，两者都涉及函数的重复应用，但递归运算更强调依赖前值的关系。
集合的特征函数,转化,集合,,前面我们从二元关系与集合的角度介绍和讨论函数的相关知识，包括函数的集合定义和函数的关系运算。在本节，我们考虑相反的问题，就是如何以函数为基本工具来解决集合的相关问题。具体地说，就是通过引入集合特征函数将关于集合的表示和运算转化为函数的表示和运算，将关于集合问题的求解转化为关于函数问题的求解。,集合的特征函数用于将集合的表示和运算转化为函数的表示和运算，从而将集合问题的求解转化为函数问题的求解
特征函数,表示,集合,,"首先，解决如何使用函数来表示集合的问题。为此，给出如下特征函数的概念：  
【定义7.10】假设$U$为任一给定的集合，对于$U$的任一子集$𝐴$特征函数$\chi_{A}$定义为一个从$U$到集合{0,1}二值函数：  
$$
\chi_{A}(a)=\left\{\!\!\begin{array}{c}{{1,~~~~~~~~~~~~~~~~~~~~~~~~~a\in A~~~}}\\ {{0,~~~~~~~~~~~~~~~~~a\in U-A~~~}}\end{array}\right.\quad\quad\quad\quad\quad(7-5)
$$  
由以上定义可知，集合$U$的任意一个子集$𝐴$都有一个与之相对应的特征函数$\chi_{A}$。例如，对于集合$U=\{a,b,c\}$的子集$A=\{a\}$，则有：  
$$
\chi_{A}(a)=1\,,\,\,\,\chi_{A}(b)=0\,,\,\,\,\chi_{A}(c)\,。
$$  
此外，根据特征函数定义显然有：空集的特征函数恒为0，$U$的特征函数恒为 1.即：  
$$
(1)A=\emptyset\Leftrightarrow(\forall x\in X)(\chi_{A_{1}}(x)=0);\;\;(\;2)\;\;A=U\Leftrightarrow(\forall x\in X)(\chi_{A_{1}}(x)=1)\,\mathrm{{s}}
$$","特征函数用于表示集合的子集，通过二值函数形式将集合元素映射到{0,1}"
特征函数,对应,子集,,"首先，解决如何使用函数来表示集合的问题。为此，给出如下特征函数的概念：  
【定义7.10】假设$U$为任一给定的集合，对于$U$的任一子集$𝐴$特征函数$\chi_{A}$定义为一个从$U$到集合{0,1}二值函数：  
$$
\chi_{A}(a)=\left\{\!\!\begin{array}{c}{{1,~~~~~~~~~~~~~~~~~~~~~~~~~a\in A~~~}}\\ {{0,~~~~~~~~~~~~~~~~~a\in U-A~~~}}\end{array}\right.\quad\quad\quad\quad\quad(7-5)
$$  
由以上定义可知，集合$U$的任意一个子集$𝐴$都有一个与之相对应的特征函数$\chi_{A}$。例如，对于集合$U=\{a,b,c\}$的子集$A=\{a\}$，则有：  
$$
\chi_{A}(a)=1\,,\,\,\,\chi_{A}(b)=0\,,\,\,\,\chi_{A}(c)\,。
$$  
此外，根据特征函数定义显然有：空集的特征函数恒为0，$U$的特征函数恒为 1.即：  
$$
(1)A=\emptyset\Leftrightarrow(\forall x\in X)(\chi_{A_{1}}(x)=0);\;\;(\;2)\;\;A=U\Leftrightarrow(\forall x\in X)(\chi_{A_{1}}(x)=1)\,\mathrm{{s}}
$$",集合的任意子集都有一个与之相对应的特征函数
特征函数,恒为0,空集,,"首先，解决如何使用函数来表示集合的问题。为此，给出如下特征函数的概念：  
【定义7.10】假设$U$为任一给定的集合，对于$U$的任一子集$𝐴$特征函数$\chi_{A}$定义为一个从$U$到集合{0,1}二值函数：  
$$
\chi_{A}(a)=\left\{\!\!\begin{array}{c}{{1,~~~~~~~~~~~~~~~~~~~~~~~~~a\in A~~~}}\\ {{0,~~~~~~~~~~~~~~~~~a\in U-A~~~}}\end{array}\right.\quad\quad\quad\quad\quad(7-5)
$$  
由以上定义可知，集合$U$的任意一个子集$𝐴$都有一个与之相对应的特征函数$\chi_{A}$。例如，对于集合$U=\{a,b,c\}$的子集$A=\{a\}$，则有：  
$$
\chi_{A}(a)=1\,,\,\,\,\chi_{A}(b)=0\,,\,\,\,\chi_{A}(c)\,。
$$  
此外，根据特征函数定义显然有：空集的特征函数恒为0，$U$的特征函数恒为 1.即：  
$$
(1)A=\emptyset\Leftrightarrow(\forall x\in X)(\chi_{A_{1}}(x)=0);\;\;(\;2)\;\;A=U\Leftrightarrow(\forall x\in X)(\chi_{A_{1}}(x)=1)\,\mathrm{{s}}
$$",空集的特征函数在其定义域内恒为0
特征函数,恒为1,全集,,"首先，解决如何使用函数来表示集合的问题。为此，给出如下特征函数的概念：  
【定义7.10】假设$U$为任一给定的集合，对于$U$的任一子集$𝐴$特征函数$\chi_{A}$定义为一个从$U$到集合{0,1}二值函数：  
$$
\chi_{A}(a)=\left\{\!\!\begin{array}{c}{{1,~~~~~~~~~~~~~~~~~~~~~~~~~a\in A~~~}}\\ {{0,~~~~~~~~~~~~~~~~~a\in U-A~~~}}\end{array}\right.\quad\quad\quad\quad\quad(7-5)
$$  
由以上定义可知，集合$U$的任意一个子集$𝐴$都有一个与之相对应的特征函数$\chi_{A}$。例如，对于集合$U=\{a,b,c\}$的子集$A=\{a\}$，则有：  
$$
\chi_{A}(a)=1\,,\,\,\,\chi_{A}(b)=0\,,\,\,\,\chi_{A}(c)\,。
$$  
此外，根据特征函数定义显然有：空集的特征函数恒为0，$U$的特征函数恒为 1.即：  
$$
(1)A=\emptyset\Leftrightarrow(\forall x\in X)(\chi_{A_{1}}(x)=0);\;\;(\;2)\;\;A=U\Leftrightarrow(\forall x\in X)(\chi_{A_{1}}(x)=1)\,\mathrm{{s}}
$$",全集的特征函数在其定义域内恒为1
特征函数,转化,特征函数的运算,,"有了集合的特征函数之后，集合之间的关系就可以用其特征函数的关系表达，集合之间的运算就转化为其特征函数之间的运算。  
【定理7.9】给定全集$U$，$A\subseteq U$和$B\subseteq U$，则对所有$x\subseteq U$，成立下列关系式：$(1)\chi_{\bar{A}}(x)=1-\chi_{A}(x);~~(2)~~\chi_{A\cap B}(x)=\chi_{A}(x)\cdot\chi_{B}(x)=m i n\{\chi_{A}(x),\chi_{B}(x)\};$ $(3)\chi_{A\cup B}(x)=\chi_{A}(x)+\chi_{B}(x)-\chi_{A\cap B}(x)=m a x\{\chi_{A}(x),\chi_{B}(x)\};$ $(4)\chi_{A}(x)\leq\chi_{B}(x)\Leftrightarrow A\subseteq B;\;\;(5)\chi_{A}(x)=\chi_{B}(x)\Leftrightarrow A=B;$ $(6)\chi_{A-B}(x)=\chi_{A\cap\bar{B}}(x)=\chi_{A}(x)\cdot\chi_{\bar{B}}(x)=\chi_{A}(x)-\chi_{A\cap B}(x)\,。$",集合之间的运算可以转化为其特征函数之间的运算
有限集的置换函数,等价,双射函数,,有限集上的函数是一类很特别的函数，具有很多非常重要而有趣的性质。如前所述，有限集$𝐴$上的单射必是满射，满射也必是单射。因此，有限集$𝐴$上的函数只有两种基本类型，一 种是双射函数，另外一种则为既非单射也非满射的函数。不难看出，有限集$𝐴$上双射函数其实就是$𝐴$上所有元素的一个全排列，因此，有限集$𝐴$上双射函数也称为置换函数。本节主要讨论有限集$𝐴$上双射函数的概念与关系运算性质，包括置换函数的基本概念、置换函数的运算性质、置换函数的轮换分解。,有限集上的双射函数即为该集上的所有元素的一个全排列，因此有限集上的双射函数也称为置换函数
双射函数集,包含,置换函数,,"设$𝐴$是一个任意给定的非空有限集，由函数计数原理知，$𝐴$上所有不同双射函数个数也是有限的。因此，可将这些所有不同双射函数放在一起组成一个集合，并将该集合作为分析讨论𝐴上双射函数性质的背景或载体。为此，下面给出双射函数集的概念：  
【定义7.11】设$A=\{x_{1},x_{2},\cdots,x_{n}\}$是一个有穷集合， $𝐴$上所有的双射函数构成的集合称为𝐴上的双射函数集或可逆函数集。记为$F_{A}$。  
对于双射函数集$F_{A}$，显然有如下性质：  
$( 1) \forall f, g\in F_A\Rightarrow f\circ g\in F_A\wedge$ $g\circ f\in F_A。 ( 2)$ $\forall f, g, h\in F_A$ $\Rightarrow ( f\circ g) \circ h= f\circ ( g\circ$  
$h)$。  
(3) $\forall f\in F_{A}\Rightarrow f\circ I_{A}= I_{A}\circ f= f$。  
(4) $\forall f\in F_{A}$ $\Rightarrow f^{- 1}\in F_{A}$  
【定义7.12】设$ A=\{x_{1},x_{2},\cdots,x_{n}\}$是一个有限集合，从$𝐴$到$𝐴$的双射函数称为$𝐴$上的一个置换函数，简称为置换或排列，记为$P{\mathrel{:}}A\to A$，$A$的基数$n$称为置换的阶。  
由于置换函数表示的是有限集合上元素的全排列，故通常使用字母$P$或$\pi$作为置换函数的函数名，即有：  
$P=\begin{pmatrix}x_1&x_2&x_3&&\cdots&x_n\\P(x_1)&P(x_2)&P(x_3)&&\cdots&P(x_n)\end{pmatrix}\quad(7-7)$  
上式其中第一行是集合$ A$的元素按顺序列出，第二行元素是$A$中元素对应的函数值。显然序列$P(a_{1}),P(a_{2}),\cdots,P(a_{n})$是$𝐴$中元素的重排，恰好对应一个$ N=\{1,2,\cdots,n\}$全排列。  
显然有$F_{A}=\left\{f\middle|f\right.$是𝐴中的置换}，即可逆函数集是$𝐴$中所有置换的集合。由于 $n$元有限集中共有$n\,!$个不同的置换函数，故有$|F_{A}|=n!$，因此，有时亦将$𝐴$的可逆函数集记为𝐴！。",双射函数集是包含所有置换函数的集合
置换函数,定义,置换函数乘积运算,,"置换是一种特殊的双射函数，关于函数的求逆运算和复合运算在置换中完全适用。因此，可直接将一般函数的逆运算和复合运算作为置换函数的逆运算和复合运算。  
从上例子可知，集合$𝐴$中置换函数的逆运算和复合运算结果还是$𝐴$的一个置换。从排列的角度看，置换函数的逆运算其实就是将置换的上下两排元素进行颠倒排放，即将下面一排移到上面，同时将上面一排移到下面，然后将数对按第一个元素（上面元素）的升序排列。  
虽然可以直接将一般函数的复合运算作为置换函数的复合运算，但是从排列的角度看，直接使用置换函数的复合运算会对排列的分析带来一些不便。为此，我们对置换函数的复合运算规则稍加调整，得到如下置换函数乘积运算的概念：  
【定义7.13】设$A=\{a_{1},a_{2},\cdots,a_{n}\}$的任意两个$n$阶置换函数$\pi$和$\tau$ ：  
$\begin{gathered}\pi=\begin{pmatrix}a_1&a_2&a_3&\cdots&a_n\\\pi(a_1)&\pi(a_2)&\pi(a_3)&\cdots&\pi(a_n)\end{pmatrix}\\\tau=\begin{pmatrix}a_1&a_2&a_3&\cdots&a_n\\\tau(a_1)&\tau(a_2)&\tau(a_3)&\cdots&\tau(a_n)\end{pmatrix}\end{gathered}$  
则$\pi$和$\tau$的乘积$\pi\cdot\tau$定义为：  
$\pi\cdot\tau=\begin{pmatrix}a_1&a_2&a_3&\cdots&a_n\\\pi(\tau(a_1))&\pi(\tau(a_2))&\pi(\tau(a_3))&\cdots&\pi(\tau(a_n))\end{pmatrix}\quad\text{(7-8)}$  
在不引起混淆的情况下，通常省略乘法符号，即将$\pi\cdot\tau$简写为$\pi\tau$  
从上述定义可以看出，置换函数乘积运算与复合运算之间没有本质上的区别，只是表达形式上有所差异，具体地说，就是它们之间的运算次序正好相反，即$\pi\cdot\tau=\tau\circ\pi$。",置换函数乘积运算是对置换函数的复合运算规则的调整，定义为两个置换函数的乘积，其运算次序与复合运算相反
置换函数,包含,轮换,,"细心的读者可能会发现，前面几个置换函数例题的排列元素都只有3 个，这是主要因为置换数目的增长速度为排列元素数目的阶乘${n!}$，如果$n$比较大，则问题的规模会迅速增大而变得不可行。因此，对于有限集合$A=\{a_{1},a_{2},\cdots,a_{n}\}$上的置换，当$n$比较大时，就必须置换进行分解。现在我们考察对置换进行分解的具体方法。  
首先考察一种特殊的置换，在这种置换中的一些元素的函数映射呈现出一种循环的状态，而其余元素则的映射为恒等映射。例如，对于如下置换：  
$\begin{pmatrix}1&2&3&4&5&6&7&8\\4&3&5&2&1&6&7&8\end{pmatrix}$  
元素1 映射到4，元素4 映射到2，元素2 映射到3，元素3 映射到5，元素5 映射到1，然后循环。置换中这5 个元素1, 4, 2, 3, 5形成一个循环，而其余元素6, 7, 8则保持恒等映射，此时称这样的置换为长度为5 的轮换，记为(1, 4, 2, 3, 5),即有：  
$\begin{pmatrix}1&2&3&4&5&6&7&8\\4&3&5&2&1&6&7&8\end{pmatrix}=(1,4,2,3,5)  $  
轮换的具体定义如下：  
【定义7.14】设$A=\{a_{1},a_{2},\cdots,a_{n}\}$是任一非空有限集合，如果$𝐴$上的某个置换$P$把元素$a_{1}$变成$a_{2}$, $a_{2}$变成$a_{3},\ \cdots,a_{k-1}$变成$a_{k}$，又把$a_{k}$变成$a_{1}(k\leq n)$，但别的元素（如果有的话）都不变，则称$ P$是一个长度为$k$的轮换，简称为$\pmb{k}{-}$轮换，并将其记为$(a_{1},a_{2},\cdots,a_{k})$。其中长度为2 的轮换称为对换。  
由上述定义可知，轮换是置换另一种表达方式，它以元素变化次序为序，描述一种轮换过程$(a_{1},a_{2},\cdots,a_{k})=(a_{2},a_{3},\cdots,a_{k}a_{1})=\cdots=(a_{k},a_{1},\cdots,a_{k-1})。$例如对于轮换$(1,4, 2, 3, 5)$，有：$(1,4,2,3,5)=(\begin{array}{ccc}4,2,3,5,1)=(&2,3,5,1,4)=\cdots=(5,1,4,2,3)。\end{array}$  
值得注意的是，虽然轮换表达方式比置换更加简洁，轮换不能表达其所在置换的元素数目，需要采用其它方式说明置换的元素数目。  
现在考察轮换的运算。由于轮换是一种特殊的置换，故可像置换那样进行乘法运算。例如，对于集合$ A=\{1,2,3,4,5,6\}$上的两个轮换$(4,1,3,5)$和$(5,6,3)$，则可计算它们的乘积：  
$(4,1,3,5)\cdot(5,6,3)=\begin{pmatrix}1&2&3&4&5&&6\\3&2&5&1&4&&6\end{pmatrix}\cdot\begin{pmatrix}1&2&3&4&5&&6\\1&2&5&4&6&&3\end{pmatrix}$  
$=\begin{pmatrix}1&2&3&4&5&&6\\3&2&4&1&6&&5\end{pmatrix}$  
$\begin{aligned}(5,6,3)\cdot(4,1,3,5)&=\begin{pmatrix}1&2&3&4&5&6\\1&2&5&4&6&3\end{pmatrix}\cdot\begin{pmatrix}1&2&3&4&5&6\\3&2&5&1&4&6\end{pmatrix}.\\&=\begin{pmatrix}1&2&3&4&5&6\\5&2&6&1&4&3\end{pmatrix}\end{aligned}$  
可以看出$(4,\!1,\!3,\!5)\cdot(5,\!6,\!3)\neq(5,\!6,\!3)\cdot(4,\!1,\!3,\!5)$。因此，轮换的乘法不满足交换律。 显然，并不是每个置换都能成为轮换。例如，对于如下8 阶置换：  
$$
\tau=\begin{pmatrix}1&2&3&4&5&6&7\\3&5&6&4&2&1&7\end{pmatrix}
$$  
其不可能是轮换。但我们发现：  
$$
\tau=\begin{pmatrix}1&2&3&4&5&6&7\\3&5&6&4&2&1&7\end{pmatrix}
$$  
$$
=\bigl(\begin{matrix}1&2&3&4&5&6&7\\3&2&6&4&5&1&7\end{matrix}\bigr)\bigl(\begin{matrix}1&2&3&4&5&6&7\\1&5&3&4&2&6&7\end{matrix}\bigr)
$$  
$\quad\quad\quad\quad\quad=(\begin{matrix}1&3&6\\\end{matrix})(\begin{matrix}2&5\\\end{matrix})$  
由此可见，$\tau$虽不是轮换，但它可分解成是轮换的乘积。这为解决置换分解问题提供了一个思路。下面考虑对任意置换的轮换分解问题。首先给从下列定义：  
【定义7.15】设$\pi=(i_{1},i_{2},\cdots,i_{t})$和$\tau=(j_{1},j_{2},\cdots,j_{s})$都是轮换，如果$\pi$和$\cdot_{\tau}$不含相同的元素，则称$\pi$与$\tau$是不相交的。  
例如，集合$A=\{1,\!2,\!3,\!4,\!5,\!6\}$上的两个轮换(1,2,5)和(3,4,6)之间是不相交的，而轮换(1,2,5)和(2,4,6)之间则是相交的。  
下面给出对任意置换的轮换分解定理：  
【定理7.10】（轮换分解定理）任一$ n$元置换都可写成若干个不相交轮换的乘积。",置换函数可以包含轮换这种特殊的置换形式
轮换,应用,轮换分解定理,,"细心的读者可能会发现，前面几个置换函数例题的排列元素都只有3 个，这是主要因为置换数目的增长速度为排列元素数目的阶乘${n!}$，如果$n$比较大，则问题的规模会迅速增大而变得不可行。因此，对于有限集合$A=\{a_{1},a_{2},\cdots,a_{n}\}$上的置换，当$n$比较大时，就必须置换进行分解。现在我们考察对置换进行分解的具体方法。  
首先考察一种特殊的置换，在这种置换中的一些元素的函数映射呈现出一种循环的状态，而其余元素则的映射为恒等映射。例如，对于如下置换：  
$\begin{pmatrix}1&2&3&4&5&6&7&8\\4&3&5&2&1&6&7&8\end{pmatrix}$  
元素1 映射到4，元素4 映射到2，元素2 映射到3，元素3 映射到5，元素5 映射到1，然后循环。置换中这5 个元素1, 4, 2, 3, 5形成一个循环，而其余元素6, 7, 8则保持恒等映射，此时称这样的置换为长度为5 的轮换，记为(1, 4, 2, 3, 5),即有：  
$\begin{pmatrix}1&2&3&4&5&6&7&8\\4&3&5&2&1&6&7&8\end{pmatrix}=(1,4,2,3,5)  $  
轮换的具体定义如下：  
【定义7.14】设$A=\{a_{1},a_{2},\cdots,a_{n}\}$是任一非空有限集合，如果$𝐴$上的某个置换$P$把元素$a_{1}$变成$a_{2}$, $a_{2}$变成$a_{3},\ \cdots,a_{k-1}$变成$a_{k}$，又把$a_{k}$变成$a_{1}(k\leq n)$，但别的元素（如果有的话）都不变，则称$ P$是一个长度为$k$的轮换，简称为$\pmb{k}{-}$轮换，并将其记为$(a_{1},a_{2},\cdots,a_{k})$。其中长度为2 的轮换称为对换。  
由上述定义可知，轮换是置换另一种表达方式，它以元素变化次序为序，描述一种轮换过程$(a_{1},a_{2},\cdots,a_{k})=(a_{2},a_{3},\cdots,a_{k}a_{1})=\cdots=(a_{k},a_{1},\cdots,a_{k-1})。$例如对于轮换$(1,4, 2, 3, 5)$，有：$(1,4,2,3,5)=(\begin{array}{ccc}4,2,3,5,1)=(&2,3,5,1,4)=\cdots=(5,1,4,2,3)。\end{array}$  
值得注意的是，虽然轮换表达方式比置换更加简洁，轮换不能表达其所在置换的元素数目，需要采用其它方式说明置换的元素数目。  
现在考察轮换的运算。由于轮换是一种特殊的置换，故可像置换那样进行乘法运算。例如，对于集合$ A=\{1,2,3,4,5,6\}$上的两个轮换$(4,1,3,5)$和$(5,6,3)$，则可计算它们的乘积：  
$(4,1,3,5)\cdot(5,6,3)=\begin{pmatrix}1&2&3&4&5&&6\\3&2&5&1&4&&6\end{pmatrix}\cdot\begin{pmatrix}1&2&3&4&5&&6\\1&2&5&4&6&&3\end{pmatrix}$  
$=\begin{pmatrix}1&2&3&4&5&&6\\3&2&4&1&6&&5\end{pmatrix}$  
$\begin{aligned}(5,6,3)\cdot(4,1,3,5)&=\begin{pmatrix}1&2&3&4&5&6\\1&2&5&4&6&3\end{pmatrix}\cdot\begin{pmatrix}1&2&3&4&5&6\\3&2&5&1&4&6\end{pmatrix}.\\&=\begin{pmatrix}1&2&3&4&5&6\\5&2&6&1&4&3\end{pmatrix}\end{aligned}$  
可以看出$(4,\!1,\!3,\!5)\cdot(5,\!6,\!3)\neq(5,\!6,\!3)\cdot(4,\!1,\!3,\!5)$。因此，轮换的乘法不满足交换律。 显然，并不是每个置换都能成为轮换。例如，对于如下8 阶置换：  
$$
\tau=\begin{pmatrix}1&2&3&4&5&6&7\\3&5&6&4&2&1&7\end{pmatrix}
$$  
其不可能是轮换。但我们发现：  
$$
\tau=\begin{pmatrix}1&2&3&4&5&6&7\\3&5&6&4&2&1&7\end{pmatrix}
$$  
$$
=\bigl(\begin{matrix}1&2&3&4&5&6&7\\3&2&6&4&5&1&7\end{matrix}\bigr)\bigl(\begin{matrix}1&2&3&4&5&6&7\\1&5&3&4&2&6&7\end{matrix}\bigr)
$$  
$\quad\quad\quad\quad\quad=(\begin{matrix}1&3&6\\\end{matrix})(\begin{matrix}2&5\\\end{matrix})$  
由此可见，$\tau$虽不是轮换，但它可分解成是轮换的乘积。这为解决置换分解问题提供了一个思路。下面考虑对任意置换的轮换分解问题。首先给从下列定义：  
【定义7.15】设$\pi=(i_{1},i_{2},\cdots,i_{t})$和$\tau=(j_{1},j_{2},\cdots,j_{s})$都是轮换，如果$\pi$和$\cdot_{\tau}$不含相同的元素，则称$\pi$与$\tau$是不相交的。  
例如，集合$A=\{1,\!2,\!3,\!4,\!5,\!6\}$上的两个轮换(1,2,5)和(3,4,6)之间是不相交的，而轮换(1,2,5)和(2,4,6)之间则是相交的。  
下面给出对任意置换的轮换分解定理：  
【定理7.10】（轮换分解定理）任一$ n$元置换都可写成若干个不相交轮换的乘积。",轮换分解定理用于将任意置换分解为若干个不相交轮换的乘积
不相交轮换,组成,轮换分解定理,,"细心的读者可能会发现，前面几个置换函数例题的排列元素都只有3 个，这是主要因为置换数目的增长速度为排列元素数目的阶乘${n!}$，如果$n$比较大，则问题的规模会迅速增大而变得不可行。因此，对于有限集合$A=\{a_{1},a_{2},\cdots,a_{n}\}$上的置换，当$n$比较大时，就必须置换进行分解。现在我们考察对置换进行分解的具体方法。  
首先考察一种特殊的置换，在这种置换中的一些元素的函数映射呈现出一种循环的状态，而其余元素则的映射为恒等映射。例如，对于如下置换：  
$\begin{pmatrix}1&2&3&4&5&6&7&8\\4&3&5&2&1&6&7&8\end{pmatrix}$  
元素1 映射到4，元素4 映射到2，元素2 映射到3，元素3 映射到5，元素5 映射到1，然后循环。置换中这5 个元素1, 4, 2, 3, 5形成一个循环，而其余元素6, 7, 8则保持恒等映射，此时称这样的置换为长度为5 的轮换，记为(1, 4, 2, 3, 5),即有：  
$\begin{pmatrix}1&2&3&4&5&6&7&8\\4&3&5&2&1&6&7&8\end{pmatrix}=(1,4,2,3,5)  $  
轮换的具体定义如下：  
【定义7.14】设$A=\{a_{1},a_{2},\cdots,a_{n}\}$是任一非空有限集合，如果$𝐴$上的某个置换$P$把元素$a_{1}$变成$a_{2}$, $a_{2}$变成$a_{3},\ \cdots,a_{k-1}$变成$a_{k}$，又把$a_{k}$变成$a_{1}(k\leq n)$，但别的元素（如果有的话）都不变，则称$ P$是一个长度为$k$的轮换，简称为$\pmb{k}{-}$轮换，并将其记为$(a_{1},a_{2},\cdots,a_{k})$。其中长度为2 的轮换称为对换。  
由上述定义可知，轮换是置换另一种表达方式，它以元素变化次序为序，描述一种轮换过程$(a_{1},a_{2},\cdots,a_{k})=(a_{2},a_{3},\cdots,a_{k}a_{1})=\cdots=(a_{k},a_{1},\cdots,a_{k-1})。$例如对于轮换$(1,4, 2, 3, 5)$，有：$(1,4,2,3,5)=(\begin{array}{ccc}4,2,3,5,1)=(&2,3,5,1,4)=\cdots=(5,1,4,2,3)。\end{array}$  
值得注意的是，虽然轮换表达方式比置换更加简洁，轮换不能表达其所在置换的元素数目，需要采用其它方式说明置换的元素数目。  
现在考察轮换的运算。由于轮换是一种特殊的置换，故可像置换那样进行乘法运算。例如，对于集合$ A=\{1,2,3,4,5,6\}$上的两个轮换$(4,1,3,5)$和$(5,6,3)$，则可计算它们的乘积：  
$(4,1,3,5)\cdot(5,6,3)=\begin{pmatrix}1&2&3&4&5&&6\\3&2&5&1&4&&6\end{pmatrix}\cdot\begin{pmatrix}1&2&3&4&5&&6\\1&2&5&4&6&&3\end{pmatrix}$  
$=\begin{pmatrix}1&2&3&4&5&&6\\3&2&4&1&6&&5\end{pmatrix}$  
$\begin{aligned}(5,6,3)\cdot(4,1,3,5)&=\begin{pmatrix}1&2&3&4&5&6\\1&2&5&4&6&3\end{pmatrix}\cdot\begin{pmatrix}1&2&3&4&5&6\\3&2&5&1&4&6\end{pmatrix}.\\&=\begin{pmatrix}1&2&3&4&5&6\\5&2&6&1&4&3\end{pmatrix}\end{aligned}$  
可以看出$(4,\!1,\!3,\!5)\cdot(5,\!6,\!3)\neq(5,\!6,\!3)\cdot(4,\!1,\!3,\!5)$。因此，轮换的乘法不满足交换律。 显然，并不是每个置换都能成为轮换。例如，对于如下8 阶置换：  
$$
\tau=\begin{pmatrix}1&2&3&4&5&6&7\\3&5&6&4&2&1&7\end{pmatrix}
$$  
其不可能是轮换。但我们发现：  
$$
\tau=\begin{pmatrix}1&2&3&4&5&6&7\\3&5&6&4&2&1&7\end{pmatrix}
$$  
$$
=\bigl(\begin{matrix}1&2&3&4&5&6&7\\3&2&6&4&5&1&7\end{matrix}\bigr)\bigl(\begin{matrix}1&2&3&4&5&6&7\\1&5&3&4&2&6&7\end{matrix}\bigr)
$$  
$\quad\quad\quad\quad\quad=(\begin{matrix}1&3&6\\\end{matrix})(\begin{matrix}2&5\\\end{matrix})$  
由此可见，$\tau$虽不是轮换，但它可分解成是轮换的乘积。这为解决置换分解问题提供了一个思路。下面考虑对任意置换的轮换分解问题。首先给从下列定义：  
【定义7.15】设$\pi=(i_{1},i_{2},\cdots,i_{t})$和$\tau=(j_{1},j_{2},\cdots,j_{s})$都是轮换，如果$\pi$和$\cdot_{\tau}$不含相同的元素，则称$\pi$与$\tau$是不相交的。  
例如，集合$A=\{1,\!2,\!3,\!4,\!5,\!6\}$上的两个轮换(1,2,5)和(3,4,6)之间是不相交的，而轮换(1,2,5)和(2,4,6)之间则是相交的。  
下面给出对任意置换的轮换分解定理：  
【定理7.10】（轮换分解定理）任一$ n$元置换都可写成若干个不相交轮换的乘积。",轮换分解定理表明任意置换可以分解为不相交轮换的乘积
哈希函数,用于,哈希查找,,"在计算机系统中，数据的存放位置和时间都不能完全确定，此时需要一种有效的方法在有限的存储空间中合理存放数据并且能够实现快速定位查找。此时，如果建立一个关于存储位置和数据关键字的对应关系$f$，就能找给定值$k e y$的像$f(k e y)$。这里的对应关系$f$通常称为哈希函数，这种数据查找方法称为哈希查找。  
例如，如果要建立一张学生成绩表，最简单的方法是以学生的学号作为关键字，1 号学生的记录位置放在第一条，10 号学生的记录位置放在第10 条，以此类推。此时，如果要查看的学号为5 的学生的成绩，则只要取出第5 条记录就可以了.这样建立的表实际上就是一张简单的哈希表，其哈希函数为$f(k e y){=}\ k e y$。然而很多情况下的哈希函数并不如此简单。为了查看的方便，可能会以学生的名字作为关键字。此时，为了能够根据学生的名字直接定位出相应记录所在的位置，需要将这些名字转化为数字，构造出相应的哈希函数，下面给出两个不同的哈希函数：  
（1）考察学生名字的汉语拼音，将其中第一个字母在英语字母表中的序号作为哈希函数值。例如：“蔡军”的汉语拼音第一个字母为字母$C$，因此取03 作为其哈希值。  
（2）考察学生名字的汉语拼音，将其中第一个字母和最后一个字母在英语字母表中的序号之和作为哈希函数值。例如，“蔡军”的汉语拼音第一个字母和最后一个字母分别为$𝐶$和$N$，因此取17 作为其哈希值。  
分别应用这两个哈希函数，成绩表中部分学生名字不同的哈希函数值如表7-7 所示。  
表 7-7
![](images/a45025876fc98ab470bf113421a83e13ab1997baea6e789cdbd16990f25f7ba0.jpg)  
![](images/0f18f81e6e78fd7fb2b0f104794c8a798e21b0531706abe9d65a4f9970f2f012.jpg)  
在哈希表的构造过程中，可能会出现不同的关键字映射到同一地址的情况，即$k e y_{1}\neq$$k e y_{2}$，但$f(k e y_{1})=f(k e y_{2})$，也将这种现象称为冲突和碰撞。实际上，由于哈希函数是把任意长度的字符串映射为固定长度的字符串，冲突必然存在，只能尽可能减少。常见的构造哈希函数的方法有以下几种：  
（1）数字分析法。数字分析法适合于关键字由若干数码组成，同时各数码的分布规律事先知道的情况。具体方法是：分析关键字集合中每个关键字中的每一位数码的分布情况，找出数码分布均匀的若干位作为关键字的存储地址。例如，一个由80 个结点组成的结构，其关键字为6 位十进制数。选择哈希表长度为100，则可取关键字中的两位十进制数作为结点的存储地址。具体采用哪两位数码，需要用数字分析法对关键字中的数码分布情况进行分析。假设结点中有一部分关键字如下：  
$k e y_{1}=301514\;\;;\;\;\;k e y_{2}=303027;\;\;k e y_{3}=301103;\;\;\;k e y_{4}=308329;$ $k e y_{5}=300287;\;\;k e y_{6}=305939;\;\;k e y_{7}=300792;\;\;k e y_{8}=300463\circ878.$  
对上述关键字分析可以发现，关键字的第一位均是3，第二位均是0，分布集中，不适合作为存储地址。而第4 位和第5 位分布均匀，所以该哈希函数可以构造为取第4,5 位作为结点的存储地址。上述8 个节点的散列地址为：  
$f(k e y_{1})=51~~~~f(k e y_{2})=02~~~~f(k e y_{3})=10~~~~f(k e y_{4})=32$ $f(k e y_{5})=28\;\;\;\;\;f(k e y_{6})=93\;\;\;\;\;f(k e y_{7})=79\;\;\;\;\;f(k e y_{8})=46$  
（2）平方取中法。平方取中法是一种比较常用的构造哈希函数的方法，具体是：将关键字求平方后，取其中间的几位数字作为散列地址。由于关键字平方后的中间几位数字和组成关键字的每一位数字都有关，因此产生冲突的可能性较小，最后究竟取几位数字作为散列地址需要由散列表的长度决定。例如，若结构的存储地址范围是1\~999，则取平方值的中间三位，如表7-8 所示。  
表7-8  平方取中法
![](images/3bce2eeb41624a2b374dfdbdb4f5d0a22039c970673844c48a904ace588c42b7.jpg)  
（3）除留余数法。除留余数法取关键字被某个不大于哈希表表长$m$的数$ p$除后所得余数为哈希地址，即$f(k e y)=k e y({\bmod{\ p}})$，其中$p\leq m$。这是一种最简单也是最常用的构造哈希函数的方法。它不仅可以对关键字直接取模（mod），也可在平方取中等运算之后取模。值得注意的是，在使用除留余数法时，对$ p$的选择很重要。若$p$选的不好，容易产生同义词。由经验得知：一般情况下可以选$p$为质数或不包含小于20 的质因素的合数。  
哈希函数中会不可避免的存在冲突。因此，在建造哈希函数时不仅要设定一个“好”的哈希函数，而且要设定一种处理冲突的方法。假设哈希表地址集为$\!\sim\!(n-1)$，冲突是指由关键字得到的哈希地址为𝑗$(0\leq j\leq n-1)$的位置上已有记录，则“处理冲突”就是为该关键字的记录找到另一个“空”的哈希地址。  
在处理冲突的过程中可能得到一个地址序列$h_{i}$，其中，$h_{i}\in[0,\mathfrak{n}-1],\mathrm{i}=1,2,\cdots,\mathtt{k}$。即  
在处理哈希地址的冲突时，若得到的另一个哈希地址${\bf h}_{1}$ 仍然发生冲突，则再求下一个地址$h_{2}$，若$ h_{2}$仍然冲突，再求得$h_{3}$，依此类推，直至$h_{k}$不发生冲突为止，则$h_{k}$为记录在表中的地址。处理冲突的具体方法通常有开放定址法、再哈希法和拉链法，这里不再赘述。",哈希函数用于实现哈希查找
哈希函数,导致,冲突,,"在计算机系统中，数据的存放位置和时间都不能完全确定，此时需要一种有效的方法在有限的存储空间中合理存放数据并且能够实现快速定位查找。此时，如果建立一个关于存储位置和数据关键字的对应关系$f$，就能找给定值$k e y$的像$f(k e y)$。这里的对应关系$f$通常称为哈希函数，这种数据查找方法称为哈希查找。  
例如，如果要建立一张学生成绩表，最简单的方法是以学生的学号作为关键字，1 号学生的记录位置放在第一条，10 号学生的记录位置放在第10 条，以此类推。此时，如果要查看的学号为5 的学生的成绩，则只要取出第5 条记录就可以了.这样建立的表实际上就是一张简单的哈希表，其哈希函数为$f(k e y){=}\ k e y$。然而很多情况下的哈希函数并不如此简单。为了查看的方便，可能会以学生的名字作为关键字。此时，为了能够根据学生的名字直接定位出相应记录所在的位置，需要将这些名字转化为数字，构造出相应的哈希函数，下面给出两个不同的哈希函数：  
（1）考察学生名字的汉语拼音，将其中第一个字母在英语字母表中的序号作为哈希函数值。例如：“蔡军”的汉语拼音第一个字母为字母$C$，因此取03 作为其哈希值。  
（2）考察学生名字的汉语拼音，将其中第一个字母和最后一个字母在英语字母表中的序号之和作为哈希函数值。例如，“蔡军”的汉语拼音第一个字母和最后一个字母分别为$𝐶$和$N$，因此取17 作为其哈希值。  
分别应用这两个哈希函数，成绩表中部分学生名字不同的哈希函数值如表7-7 所示。  
表 7-7
![](images/a45025876fc98ab470bf113421a83e13ab1997baea6e789cdbd16990f25f7ba0.jpg)  
![](images/0f18f81e6e78fd7fb2b0f104794c8a798e21b0531706abe9d65a4f9970f2f012.jpg)  
在哈希表的构造过程中，可能会出现不同的关键字映射到同一地址的情况，即$k e y_{1}\neq$$k e y_{2}$，但$f(k e y_{1})=f(k e y_{2})$，也将这种现象称为冲突和碰撞。实际上，由于哈希函数是把任意长度的字符串映射为固定长度的字符串，冲突必然存在，只能尽可能减少。常见的构造哈希函数的方法有以下几种：  
（1）数字分析法。数字分析法适合于关键字由若干数码组成，同时各数码的分布规律事先知道的情况。具体方法是：分析关键字集合中每个关键字中的每一位数码的分布情况，找出数码分布均匀的若干位作为关键字的存储地址。例如，一个由80 个结点组成的结构，其关键字为6 位十进制数。选择哈希表长度为100，则可取关键字中的两位十进制数作为结点的存储地址。具体采用哪两位数码，需要用数字分析法对关键字中的数码分布情况进行分析。假设结点中有一部分关键字如下：  
$k e y_{1}=301514\;\;;\;\;\;k e y_{2}=303027;\;\;k e y_{3}=301103;\;\;\;k e y_{4}=308329;$ $k e y_{5}=300287;\;\;k e y_{6}=305939;\;\;k e y_{7}=300792;\;\;k e y_{8}=300463\circ878.$  
对上述关键字分析可以发现，关键字的第一位均是3，第二位均是0，分布集中，不适合作为存储地址。而第4 位和第5 位分布均匀，所以该哈希函数可以构造为取第4,5 位作为结点的存储地址。上述8 个节点的散列地址为：  
$f(k e y_{1})=51~~~~f(k e y_{2})=02~~~~f(k e y_{3})=10~~~~f(k e y_{4})=32$ $f(k e y_{5})=28\;\;\;\;\;f(k e y_{6})=93\;\;\;\;\;f(k e y_{7})=79\;\;\;\;\;f(k e y_{8})=46$  
（2）平方取中法。平方取中法是一种比较常用的构造哈希函数的方法，具体是：将关键字求平方后，取其中间的几位数字作为散列地址。由于关键字平方后的中间几位数字和组成关键字的每一位数字都有关，因此产生冲突的可能性较小，最后究竟取几位数字作为散列地址需要由散列表的长度决定。例如，若结构的存储地址范围是1\~999，则取平方值的中间三位，如表7-8 所示。  
表7-8  平方取中法
![](images/3bce2eeb41624a2b374dfdbdb4f5d0a22039c970673844c48a904ace588c42b7.jpg)  
（3）除留余数法。除留余数法取关键字被某个不大于哈希表表长$m$的数$ p$除后所得余数为哈希地址，即$f(k e y)=k e y({\bmod{\ p}})$，其中$p\leq m$。这是一种最简单也是最常用的构造哈希函数的方法。它不仅可以对关键字直接取模（mod），也可在平方取中等运算之后取模。值得注意的是，在使用除留余数法时，对$ p$的选择很重要。若$p$选的不好，容易产生同义词。由经验得知：一般情况下可以选$p$为质数或不包含小于20 的质因素的合数。  
哈希函数中会不可避免的存在冲突。因此，在建造哈希函数时不仅要设定一个“好”的哈希函数，而且要设定一种处理冲突的方法。假设哈希表地址集为$\!\sim\!(n-1)$，冲突是指由关键字得到的哈希地址为𝑗$(0\leq j\leq n-1)$的位置上已有记录，则“处理冲突”就是为该关键字的记录找到另一个“空”的哈希地址。  
在处理冲突的过程中可能得到一个地址序列$h_{i}$，其中，$h_{i}\in[0,\mathfrak{n}-1],\mathrm{i}=1,2,\cdots,\mathtt{k}$。即  
在处理哈希地址的冲突时，若得到的另一个哈希地址${\bf h}_{1}$ 仍然发生冲突，则再求下一个地址$h_{2}$，若$ h_{2}$仍然冲突，再求得$h_{3}$，依此类推，直至$h_{k}$不发生冲突为止，则$h_{k}$为记录在表中的地址。处理冲突的具体方法通常有开放定址法、再哈希法和拉链法，这里不再赘述。",哈希函数可能导致冲突现象
数字分析法,构造方法,哈希函数,,"在计算机系统中，数据的存放位置和时间都不能完全确定，此时需要一种有效的方法在有限的存储空间中合理存放数据并且能够实现快速定位查找。此时，如果建立一个关于存储位置和数据关键字的对应关系$f$，就能找给定值$k e y$的像$f(k e y)$。这里的对应关系$f$通常称为哈希函数，这种数据查找方法称为哈希查找。  
例如，如果要建立一张学生成绩表，最简单的方法是以学生的学号作为关键字，1 号学生的记录位置放在第一条，10 号学生的记录位置放在第10 条，以此类推。此时，如果要查看的学号为5 的学生的成绩，则只要取出第5 条记录就可以了.这样建立的表实际上就是一张简单的哈希表，其哈希函数为$f(k e y){=}\ k e y$。然而很多情况下的哈希函数并不如此简单。为了查看的方便，可能会以学生的名字作为关键字。此时，为了能够根据学生的名字直接定位出相应记录所在的位置，需要将这些名字转化为数字，构造出相应的哈希函数，下面给出两个不同的哈希函数：  
（1）考察学生名字的汉语拼音，将其中第一个字母在英语字母表中的序号作为哈希函数值。例如：“蔡军”的汉语拼音第一个字母为字母$C$，因此取03 作为其哈希值。  
（2）考察学生名字的汉语拼音，将其中第一个字母和最后一个字母在英语字母表中的序号之和作为哈希函数值。例如，“蔡军”的汉语拼音第一个字母和最后一个字母分别为$𝐶$和$N$，因此取17 作为其哈希值。  
分别应用这两个哈希函数，成绩表中部分学生名字不同的哈希函数值如表7-7 所示。  
表 7-7
![](images/a45025876fc98ab470bf113421a83e13ab1997baea6e789cdbd16990f25f7ba0.jpg)  
![](images/0f18f81e6e78fd7fb2b0f104794c8a798e21b0531706abe9d65a4f9970f2f012.jpg)  
在哈希表的构造过程中，可能会出现不同的关键字映射到同一地址的情况，即$k e y_{1}\neq$$k e y_{2}$，但$f(k e y_{1})=f(k e y_{2})$，也将这种现象称为冲突和碰撞。实际上，由于哈希函数是把任意长度的字符串映射为固定长度的字符串，冲突必然存在，只能尽可能减少。常见的构造哈希函数的方法有以下几种：  
（1）数字分析法。数字分析法适合于关键字由若干数码组成，同时各数码的分布规律事先知道的情况。具体方法是：分析关键字集合中每个关键字中的每一位数码的分布情况，找出数码分布均匀的若干位作为关键字的存储地址。例如，一个由80 个结点组成的结构，其关键字为6 位十进制数。选择哈希表长度为100，则可取关键字中的两位十进制数作为结点的存储地址。具体采用哪两位数码，需要用数字分析法对关键字中的数码分布情况进行分析。假设结点中有一部分关键字如下：  
$k e y_{1}=301514\;\;;\;\;\;k e y_{2}=303027;\;\;k e y_{3}=301103;\;\;\;k e y_{4}=308329;$ $k e y_{5}=300287;\;\;k e y_{6}=305939;\;\;k e y_{7}=300792;\;\;k e y_{8}=300463\circ878.$  
对上述关键字分析可以发现，关键字的第一位均是3，第二位均是0，分布集中，不适合作为存储地址。而第4 位和第5 位分布均匀，所以该哈希函数可以构造为取第4,5 位作为结点的存储地址。上述8 个节点的散列地址为：  
$f(k e y_{1})=51~~~~f(k e y_{2})=02~~~~f(k e y_{3})=10~~~~f(k e y_{4})=32$ $f(k e y_{5})=28\;\;\;\;\;f(k e y_{6})=93\;\;\;\;\;f(k e y_{7})=79\;\;\;\;\;f(k e y_{8})=46$  
（2）平方取中法。平方取中法是一种比较常用的构造哈希函数的方法，具体是：将关键字求平方后，取其中间的几位数字作为散列地址。由于关键字平方后的中间几位数字和组成关键字的每一位数字都有关，因此产生冲突的可能性较小，最后究竟取几位数字作为散列地址需要由散列表的长度决定。例如，若结构的存储地址范围是1\~999，则取平方值的中间三位，如表7-8 所示。  
表7-8  平方取中法
![](images/3bce2eeb41624a2b374dfdbdb4f5d0a22039c970673844c48a904ace588c42b7.jpg)  
（3）除留余数法。除留余数法取关键字被某个不大于哈希表表长$m$的数$ p$除后所得余数为哈希地址，即$f(k e y)=k e y({\bmod{\ p}})$，其中$p\leq m$。这是一种最简单也是最常用的构造哈希函数的方法。它不仅可以对关键字直接取模（mod），也可在平方取中等运算之后取模。值得注意的是，在使用除留余数法时，对$ p$的选择很重要。若$p$选的不好，容易产生同义词。由经验得知：一般情况下可以选$p$为质数或不包含小于20 的质因素的合数。  
哈希函数中会不可避免的存在冲突。因此，在建造哈希函数时不仅要设定一个“好”的哈希函数，而且要设定一种处理冲突的方法。假设哈希表地址集为$\!\sim\!(n-1)$，冲突是指由关键字得到的哈希地址为𝑗$(0\leq j\leq n-1)$的位置上已有记录，则“处理冲突”就是为该关键字的记录找到另一个“空”的哈希地址。  
在处理冲突的过程中可能得到一个地址序列$h_{i}$，其中，$h_{i}\in[0,\mathfrak{n}-1],\mathrm{i}=1,2,\cdots,\mathtt{k}$。即  
在处理哈希地址的冲突时，若得到的另一个哈希地址${\bf h}_{1}$ 仍然发生冲突，则再求下一个地址$h_{2}$，若$ h_{2}$仍然冲突，再求得$h_{3}$，依此类推，直至$h_{k}$不发生冲突为止，则$h_{k}$为记录在表中的地址。处理冲突的具体方法通常有开放定址法、再哈希法和拉链法，这里不再赘述。",数字分析法是构造哈希函数的一种方法
平方取中法,构造方法,哈希函数,,"在计算机系统中，数据的存放位置和时间都不能完全确定，此时需要一种有效的方法在有限的存储空间中合理存放数据并且能够实现快速定位查找。此时，如果建立一个关于存储位置和数据关键字的对应关系$f$，就能找给定值$k e y$的像$f(k e y)$。这里的对应关系$f$通常称为哈希函数，这种数据查找方法称为哈希查找。  
例如，如果要建立一张学生成绩表，最简单的方法是以学生的学号作为关键字，1 号学生的记录位置放在第一条，10 号学生的记录位置放在第10 条，以此类推。此时，如果要查看的学号为5 的学生的成绩，则只要取出第5 条记录就可以了.这样建立的表实际上就是一张简单的哈希表，其哈希函数为$f(k e y){=}\ k e y$。然而很多情况下的哈希函数并不如此简单。为了查看的方便，可能会以学生的名字作为关键字。此时，为了能够根据学生的名字直接定位出相应记录所在的位置，需要将这些名字转化为数字，构造出相应的哈希函数，下面给出两个不同的哈希函数：  
（1）考察学生名字的汉语拼音，将其中第一个字母在英语字母表中的序号作为哈希函数值。例如：“蔡军”的汉语拼音第一个字母为字母$C$，因此取03 作为其哈希值。  
（2）考察学生名字的汉语拼音，将其中第一个字母和最后一个字母在英语字母表中的序号之和作为哈希函数值。例如，“蔡军”的汉语拼音第一个字母和最后一个字母分别为$𝐶$和$N$，因此取17 作为其哈希值。  
分别应用这两个哈希函数，成绩表中部分学生名字不同的哈希函数值如表7-7 所示。  
表 7-7
![](images/a45025876fc98ab470bf113421a83e13ab1997baea6e789cdbd16990f25f7ba0.jpg)  
![](images/0f18f81e6e78fd7fb2b0f104794c8a798e21b0531706abe9d65a4f9970f2f012.jpg)  
在哈希表的构造过程中，可能会出现不同的关键字映射到同一地址的情况，即$k e y_{1}\neq$$k e y_{2}$，但$f(k e y_{1})=f(k e y_{2})$，也将这种现象称为冲突和碰撞。实际上，由于哈希函数是把任意长度的字符串映射为固定长度的字符串，冲突必然存在，只能尽可能减少。常见的构造哈希函数的方法有以下几种：  
（1）数字分析法。数字分析法适合于关键字由若干数码组成，同时各数码的分布规律事先知道的情况。具体方法是：分析关键字集合中每个关键字中的每一位数码的分布情况，找出数码分布均匀的若干位作为关键字的存储地址。例如，一个由80 个结点组成的结构，其关键字为6 位十进制数。选择哈希表长度为100，则可取关键字中的两位十进制数作为结点的存储地址。具体采用哪两位数码，需要用数字分析法对关键字中的数码分布情况进行分析。假设结点中有一部分关键字如下：  
$k e y_{1}=301514\;\;;\;\;\;k e y_{2}=303027;\;\;k e y_{3}=301103;\;\;\;k e y_{4}=308329;$ $k e y_{5}=300287;\;\;k e y_{6}=305939;\;\;k e y_{7}=300792;\;\;k e y_{8}=300463\circ878.$  
对上述关键字分析可以发现，关键字的第一位均是3，第二位均是0，分布集中，不适合作为存储地址。而第4 位和第5 位分布均匀，所以该哈希函数可以构造为取第4,5 位作为结点的存储地址。上述8 个节点的散列地址为：  
$f(k e y_{1})=51~~~~f(k e y_{2})=02~~~~f(k e y_{3})=10~~~~f(k e y_{4})=32$ $f(k e y_{5})=28\;\;\;\;\;f(k e y_{6})=93\;\;\;\;\;f(k e y_{7})=79\;\;\;\;\;f(k e y_{8})=46$  
（2）平方取中法。平方取中法是一种比较常用的构造哈希函数的方法，具体是：将关键字求平方后，取其中间的几位数字作为散列地址。由于关键字平方后的中间几位数字和组成关键字的每一位数字都有关，因此产生冲突的可能性较小，最后究竟取几位数字作为散列地址需要由散列表的长度决定。例如，若结构的存储地址范围是1\~999，则取平方值的中间三位，如表7-8 所示。  
表7-8  平方取中法
![](images/3bce2eeb41624a2b374dfdbdb4f5d0a22039c970673844c48a904ace588c42b7.jpg)  
（3）除留余数法。除留余数法取关键字被某个不大于哈希表表长$m$的数$ p$除后所得余数为哈希地址，即$f(k e y)=k e y({\bmod{\ p}})$，其中$p\leq m$。这是一种最简单也是最常用的构造哈希函数的方法。它不仅可以对关键字直接取模（mod），也可在平方取中等运算之后取模。值得注意的是，在使用除留余数法时，对$ p$的选择很重要。若$p$选的不好，容易产生同义词。由经验得知：一般情况下可以选$p$为质数或不包含小于20 的质因素的合数。  
哈希函数中会不可避免的存在冲突。因此，在建造哈希函数时不仅要设定一个“好”的哈希函数，而且要设定一种处理冲突的方法。假设哈希表地址集为$\!\sim\!(n-1)$，冲突是指由关键字得到的哈希地址为𝑗$(0\leq j\leq n-1)$的位置上已有记录，则“处理冲突”就是为该关键字的记录找到另一个“空”的哈希地址。  
在处理冲突的过程中可能得到一个地址序列$h_{i}$，其中，$h_{i}\in[0,\mathfrak{n}-1],\mathrm{i}=1,2,\cdots,\mathtt{k}$。即  
在处理哈希地址的冲突时，若得到的另一个哈希地址${\bf h}_{1}$ 仍然发生冲突，则再求下一个地址$h_{2}$，若$ h_{2}$仍然冲突，再求得$h_{3}$，依此类推，直至$h_{k}$不发生冲突为止，则$h_{k}$为记录在表中的地址。处理冲突的具体方法通常有开放定址法、再哈希法和拉链法，这里不再赘述。",平方取中法是构造哈希函数的一种方法
除留余数法,构造方法,哈希函数,,"在计算机系统中，数据的存放位置和时间都不能完全确定，此时需要一种有效的方法在有限的存储空间中合理存放数据并且能够实现快速定位查找。此时，如果建立一个关于存储位置和数据关键字的对应关系$f$，就能找给定值$k e y$的像$f(k e y)$。这里的对应关系$f$通常称为哈希函数，这种数据查找方法称为哈希查找。  
例如，如果要建立一张学生成绩表，最简单的方法是以学生的学号作为关键字，1 号学生的记录位置放在第一条，10 号学生的记录位置放在第10 条，以此类推。此时，如果要查看的学号为5 的学生的成绩，则只要取出第5 条记录就可以了.这样建立的表实际上就是一张简单的哈希表，其哈希函数为$f(k e y){=}\ k e y$。然而很多情况下的哈希函数并不如此简单。为了查看的方便，可能会以学生的名字作为关键字。此时，为了能够根据学生的名字直接定位出相应记录所在的位置，需要将这些名字转化为数字，构造出相应的哈希函数，下面给出两个不同的哈希函数：  
（1）考察学生名字的汉语拼音，将其中第一个字母在英语字母表中的序号作为哈希函数值。例如：“蔡军”的汉语拼音第一个字母为字母$C$，因此取03 作为其哈希值。  
（2）考察学生名字的汉语拼音，将其中第一个字母和最后一个字母在英语字母表中的序号之和作为哈希函数值。例如，“蔡军”的汉语拼音第一个字母和最后一个字母分别为$𝐶$和$N$，因此取17 作为其哈希值。  
分别应用这两个哈希函数，成绩表中部分学生名字不同的哈希函数值如表7-7 所示。  
表 7-7
![](images/a45025876fc98ab470bf113421a83e13ab1997baea6e789cdbd16990f25f7ba0.jpg)  
![](images/0f18f81e6e78fd7fb2b0f104794c8a798e21b0531706abe9d65a4f9970f2f012.jpg)  
在哈希表的构造过程中，可能会出现不同的关键字映射到同一地址的情况，即$k e y_{1}\neq$$k e y_{2}$，但$f(k e y_{1})=f(k e y_{2})$，也将这种现象称为冲突和碰撞。实际上，由于哈希函数是把任意长度的字符串映射为固定长度的字符串，冲突必然存在，只能尽可能减少。常见的构造哈希函数的方法有以下几种：  
（1）数字分析法。数字分析法适合于关键字由若干数码组成，同时各数码的分布规律事先知道的情况。具体方法是：分析关键字集合中每个关键字中的每一位数码的分布情况，找出数码分布均匀的若干位作为关键字的存储地址。例如，一个由80 个结点组成的结构，其关键字为6 位十进制数。选择哈希表长度为100，则可取关键字中的两位十进制数作为结点的存储地址。具体采用哪两位数码，需要用数字分析法对关键字中的数码分布情况进行分析。假设结点中有一部分关键字如下：  
$k e y_{1}=301514\;\;;\;\;\;k e y_{2}=303027;\;\;k e y_{3}=301103;\;\;\;k e y_{4}=308329;$ $k e y_{5}=300287;\;\;k e y_{6}=305939;\;\;k e y_{7}=300792;\;\;k e y_{8}=300463\circ878.$  
对上述关键字分析可以发现，关键字的第一位均是3，第二位均是0，分布集中，不适合作为存储地址。而第4 位和第5 位分布均匀，所以该哈希函数可以构造为取第4,5 位作为结点的存储地址。上述8 个节点的散列地址为：  
$f(k e y_{1})=51~~~~f(k e y_{2})=02~~~~f(k e y_{3})=10~~~~f(k e y_{4})=32$ $f(k e y_{5})=28\;\;\;\;\;f(k e y_{6})=93\;\;\;\;\;f(k e y_{7})=79\;\;\;\;\;f(k e y_{8})=46$  
（2）平方取中法。平方取中法是一种比较常用的构造哈希函数的方法，具体是：将关键字求平方后，取其中间的几位数字作为散列地址。由于关键字平方后的中间几位数字和组成关键字的每一位数字都有关，因此产生冲突的可能性较小，最后究竟取几位数字作为散列地址需要由散列表的长度决定。例如，若结构的存储地址范围是1\~999，则取平方值的中间三位，如表7-8 所示。  
表7-8  平方取中法
![](images/3bce2eeb41624a2b374dfdbdb4f5d0a22039c970673844c48a904ace588c42b7.jpg)  
（3）除留余数法。除留余数法取关键字被某个不大于哈希表表长$m$的数$ p$除后所得余数为哈希地址，即$f(k e y)=k e y({\bmod{\ p}})$，其中$p\leq m$。这是一种最简单也是最常用的构造哈希函数的方法。它不仅可以对关键字直接取模（mod），也可在平方取中等运算之后取模。值得注意的是，在使用除留余数法时，对$ p$的选择很重要。若$p$选的不好，容易产生同义词。由经验得知：一般情况下可以选$p$为质数或不包含小于20 的质因素的合数。  
哈希函数中会不可避免的存在冲突。因此，在建造哈希函数时不仅要设定一个“好”的哈希函数，而且要设定一种处理冲突的方法。假设哈希表地址集为$\!\sim\!(n-1)$，冲突是指由关键字得到的哈希地址为𝑗$(0\leq j\leq n-1)$的位置上已有记录，则“处理冲突”就是为该关键字的记录找到另一个“空”的哈希地址。  
在处理冲突的过程中可能得到一个地址序列$h_{i}$，其中，$h_{i}\in[0,\mathfrak{n}-1],\mathrm{i}=1,2,\cdots,\mathtt{k}$。即  
在处理哈希地址的冲突时，若得到的另一个哈希地址${\bf h}_{1}$ 仍然发生冲突，则再求下一个地址$h_{2}$，若$ h_{2}$仍然冲突，再求得$h_{3}$，依此类推，直至$h_{k}$不发生冲突为止，则$h_{k}$为记录在表中的地址。处理冲突的具体方法通常有开放定址法、再哈希法和拉链法，这里不再赘述。",除留余数法是构造哈希函数的一种方法
宽带分配问题,应用,优先级函数,,"随着互联网上语音视频业务的飞速增长，宽带成了影响服务质量的主要因素。一般来说，用户使用的宽带分成两部分：静态宽带和动态宽带。静态宽带是运营商承诺的最小宽带，已经预留给每个用户；动态宽带被所有的用户共享，根据需求进行分配。语音视频业务服务过程一般分成三步：建立连接、进行语音视频传输、结束服务。对于已经建立连接并正在进行传输的服务，运营商应该保证其所需要的宽带。而在连接阶段，如果所有客户申请的宽带总量超过运营商所提供的宽带时，则进行宽带分配。用户的优先级通常他可使用的最大宽带与已占有的宽带之比，需求量越大，被满足的宽带越小，则优先级越高。  
假设已知每一项业务所申请的宽带大小，在保证分配的宽带之和不超过网络总宽带的条件下，如何选择业务，以使得业务优先级收益（即所有业务的优先级之和）达到最大？  
可以用集合与函数对这个问题进行建模。设用户集合是$\{1,2,\cdots,n\}$，用户$𝑖$提出了$t_{i}$个宽带申请，其第$𝑗$个申请的宽带是$r(i,j)$，这里$i=1,\!2,\cdots,n,\:\:\:\mathrm{j}=1,\!2,\cdots,t_{i}.$。假设此刻运营商能提供的动态宽带总量是$B$用户$i$已使用的宽带为$C_{i j}$，可使用的最大宽带为，那么$C_{i j}\leq M_{i j}$。用户$i$的优先级函数记作$P(i,j)$，其中：$P(i,j)=C_{i j}/M_{i j}$。  
用函数$X(i,j)$表示对用户$i$的第𝑗个申请的分配结果$X(i,j)=1$表示分配$X(i,j)=0$表示不分配，那么问题的优化目标是使得下述函数，即优先级利益：  
$$
\sum_{i=1}^{n}\sum_{j=1}^{t_{i}}X(i,j)\cdot P(i,j)\quad\text{(7-9)}
$$  
达到最大，同时满足不超过总宽带的约束条件，即：  
$$
\sum_{i=1}^{n}\sum_{j=1}^{t_{i}}X(i,j)\cdot r(i,j)\leq B\quad\text{(7-10)}
$$  
这是个典型的组合优化问题，$n$个用户总计有$t_{1}+t_{2}+\cdots+t_{n}=m$个宽带请求，分别标号为${1,2,\cdots,m}$。在考虑前$n$项宽带请求$k=(1,\!2,\cdots,m)$，总宽带限制为$l(l=1,\!2,\cdots,B)$的情况下，设最佳分配的优先级收益为$v(k,l)$。  
如果此时把宽带分配给第$k$项业务（可能是第$𝑖$个用户的第$𝑗$个申请），该业务所需宽带是$r(k)$（在$r(k)=r(i,j)\leq l$的情况下），优先级收益是$P(k)=P(i,j)$。那么，剩下的宽带是$l-$$r(k)$。这些宽带将在${1,2,\cdots,k-1}$项业务中分配，所得到的优先级收益将是$v(k-1,l-r(k))$，因此总的优先级收益是$v(k-1,l-r(k)+P(k))\mathrm{v}$。相反，如果不把宽带分配给第$k$项业务，那么全部宽带𝑙将在${1,2,\cdots,k-1}$项业务中分配，总收益为$v(k-1,l)$为了使得优先级的总收益最大，只要在上述两个收益中选择最大的即可。  
上述分析可以总结成下面的递推公式，即$\forall k(0\leq k\leq m),\forall l(0\leq l\leq B)$，有  
$v(k,l)$  
![](images/ca1bba9e9c93f3e9595cc988da9323614b05bd9b58074b31eaf8aa4a7e6c05f3.jpg)  
根据这个公式：  
第一步先计算$k=1,\mathsf{l}=1,2,\cdots,B$的$v(1,l)$值，并把它们存到一个表中；  
第二步计算$k=2,\mathsf{l}=1,2,\cdots,B$的$v(2,l)$值，再把得到的值存到这个表中。  
每步计算若用到的较小的$v(k,l)$值，就到表中去取。照此做下去，直到计算出$k=m,l=$${1,2,\cdots,B}$的$v(m,l)$值为止，其中的$v(m,B)$就是最佳分配的优化函数值，即最大优先级收益。  
上述计算完成后，再根据$v(m,B)$的值逐步向前追溯，就可以找到最佳分配方案。先看$v(m,B)$是等于$v(m-1,B)$，还是等于$v\bigl(m-1,B-r(m)\bigr)+P(m)\,?$若等于前者，则没有选择第$m$项业务；若等于后者，则选择了第$m$项业务。然后根据剩下的部分是$v(m-1,B)$还是$v\big(m-1,B-r(m)\big)$来追溯第$m-1$项业务是否被选到。照此下去，直到$m$项业务都考察到，就得到问题的解。如果在计算每一项$v(k,l)$的时刻就把是否选择第$k$项业务记录下来，则就可以省略追溯过程，只需查一下全部记录，就能得到了问题的解。",宽带分配问题中，优先级函数用于计算用户优先级，以优化宽带分配策略
宽带分配问题,建模,递推公式,,"随着互联网上语音视频业务的飞速增长，宽带成了影响服务质量的主要因素。一般来说，用户使用的宽带分成两部分：静态宽带和动态宽带。静态宽带是运营商承诺的最小宽带，已经预留给每个用户；动态宽带被所有的用户共享，根据需求进行分配。语音视频业务服务过程一般分成三步：建立连接、进行语音视频传输、结束服务。对于已经建立连接并正在进行传输的服务，运营商应该保证其所需要的宽带。而在连接阶段，如果所有客户申请的宽带总量超过运营商所提供的宽带时，则进行宽带分配。用户的优先级通常他可使用的最大宽带与已占有的宽带之比，需求量越大，被满足的宽带越小，则优先级越高。  
假设已知每一项业务所申请的宽带大小，在保证分配的宽带之和不超过网络总宽带的条件下，如何选择业务，以使得业务优先级收益（即所有业务的优先级之和）达到最大？  
可以用集合与函数对这个问题进行建模。设用户集合是$\{1,2,\cdots,n\}$，用户$𝑖$提出了$t_{i}$个宽带申请，其第$𝑗$个申请的宽带是$r(i,j)$，这里$i=1,\!2,\cdots,n,\:\:\:\mathrm{j}=1,\!2,\cdots,t_{i}.$。假设此刻运营商能提供的动态宽带总量是$B$用户$i$已使用的宽带为$C_{i j}$，可使用的最大宽带为，那么$C_{i j}\leq M_{i j}$。用户$i$的优先级函数记作$P(i,j)$，其中：$P(i,j)=C_{i j}/M_{i j}$。  
用函数$X(i,j)$表示对用户$i$的第𝑗个申请的分配结果$X(i,j)=1$表示分配$X(i,j)=0$表示不分配，那么问题的优化目标是使得下述函数，即优先级利益：  
$$
\sum_{i=1}^{n}\sum_{j=1}^{t_{i}}X(i,j)\cdot P(i,j)\quad\text{(7-9)}
$$  
达到最大，同时满足不超过总宽带的约束条件，即：  
$$
\sum_{i=1}^{n}\sum_{j=1}^{t_{i}}X(i,j)\cdot r(i,j)\leq B\quad\text{(7-10)}
$$  
这是个典型的组合优化问题，$n$个用户总计有$t_{1}+t_{2}+\cdots+t_{n}=m$个宽带请求，分别标号为${1,2,\cdots,m}$。在考虑前$n$项宽带请求$k=(1,\!2,\cdots,m)$，总宽带限制为$l(l=1,\!2,\cdots,B)$的情况下，设最佳分配的优先级收益为$v(k,l)$。  
如果此时把宽带分配给第$k$项业务（可能是第$𝑖$个用户的第$𝑗$个申请），该业务所需宽带是$r(k)$（在$r(k)=r(i,j)\leq l$的情况下），优先级收益是$P(k)=P(i,j)$。那么，剩下的宽带是$l-$$r(k)$。这些宽带将在${1,2,\cdots,k-1}$项业务中分配，所得到的优先级收益将是$v(k-1,l-r(k))$，因此总的优先级收益是$v(k-1,l-r(k)+P(k))\mathrm{v}$。相反，如果不把宽带分配给第$k$项业务，那么全部宽带𝑙将在${1,2,\cdots,k-1}$项业务中分配，总收益为$v(k-1,l)$为了使得优先级的总收益最大，只要在上述两个收益中选择最大的即可。  
上述分析可以总结成下面的递推公式，即$\forall k(0\leq k\leq m),\forall l(0\leq l\leq B)$，有  
$v(k,l)$  
![](images/ca1bba9e9c93f3e9595cc988da9323614b05bd9b58074b31eaf8aa4a7e6c05f3.jpg)  
根据这个公式：  
第一步先计算$k=1,\mathsf{l}=1,2,\cdots,B$的$v(1,l)$值，并把它们存到一个表中；  
第二步计算$k=2,\mathsf{l}=1,2,\cdots,B$的$v(2,l)$值，再把得到的值存到这个表中。  
每步计算若用到的较小的$v(k,l)$值，就到表中去取。照此做下去，直到计算出$k=m,l=$${1,2,\cdots,B}$的$v(m,l)$值为止，其中的$v(m,B)$就是最佳分配的优化函数值，即最大优先级收益。  
上述计算完成后，再根据$v(m,B)$的值逐步向前追溯，就可以找到最佳分配方案。先看$v(m,B)$是等于$v(m-1,B)$，还是等于$v\bigl(m-1,B-r(m)\bigr)+P(m)\,?$若等于前者，则没有选择第$m$项业务；若等于后者，则选择了第$m$项业务。然后根据剩下的部分是$v(m-1,B)$还是$v\big(m-1,B-r(m)\big)$来追溯第$m-1$项业务是否被选到。照此下去，直到$m$项业务都考察到，就得到问题的解。如果在计算每一项$v(k,l)$的时刻就把是否选择第$k$项业务记录下来，则就可以省略追溯过程，只需查一下全部记录，就能得到了问题的解。",宽带分配问题通过递推公式进行建模，以求解最优宽带分配方案
优先级函数,结合,递推公式,,"随着互联网上语音视频业务的飞速增长，宽带成了影响服务质量的主要因素。一般来说，用户使用的宽带分成两部分：静态宽带和动态宽带。静态宽带是运营商承诺的最小宽带，已经预留给每个用户；动态宽带被所有的用户共享，根据需求进行分配。语音视频业务服务过程一般分成三步：建立连接、进行语音视频传输、结束服务。对于已经建立连接并正在进行传输的服务，运营商应该保证其所需要的宽带。而在连接阶段，如果所有客户申请的宽带总量超过运营商所提供的宽带时，则进行宽带分配。用户的优先级通常他可使用的最大宽带与已占有的宽带之比，需求量越大，被满足的宽带越小，则优先级越高。  
假设已知每一项业务所申请的宽带大小，在保证分配的宽带之和不超过网络总宽带的条件下，如何选择业务，以使得业务优先级收益（即所有业务的优先级之和）达到最大？  
可以用集合与函数对这个问题进行建模。设用户集合是$\{1,2,\cdots,n\}$，用户$𝑖$提出了$t_{i}$个宽带申请，其第$𝑗$个申请的宽带是$r(i,j)$，这里$i=1,\!2,\cdots,n,\:\:\:\mathrm{j}=1,\!2,\cdots,t_{i}.$。假设此刻运营商能提供的动态宽带总量是$B$用户$i$已使用的宽带为$C_{i j}$，可使用的最大宽带为，那么$C_{i j}\leq M_{i j}$。用户$i$的优先级函数记作$P(i,j)$，其中：$P(i,j)=C_{i j}/M_{i j}$。  
用函数$X(i,j)$表示对用户$i$的第𝑗个申请的分配结果$X(i,j)=1$表示分配$X(i,j)=0$表示不分配，那么问题的优化目标是使得下述函数，即优先级利益：  
$$
\sum_{i=1}^{n}\sum_{j=1}^{t_{i}}X(i,j)\cdot P(i,j)\quad\text{(7-9)}
$$  
达到最大，同时满足不超过总宽带的约束条件，即：  
$$
\sum_{i=1}^{n}\sum_{j=1}^{t_{i}}X(i,j)\cdot r(i,j)\leq B\quad\text{(7-10)}
$$  
这是个典型的组合优化问题，$n$个用户总计有$t_{1}+t_{2}+\cdots+t_{n}=m$个宽带请求，分别标号为${1,2,\cdots,m}$。在考虑前$n$项宽带请求$k=(1,\!2,\cdots,m)$，总宽带限制为$l(l=1,\!2,\cdots,B)$的情况下，设最佳分配的优先级收益为$v(k,l)$。  
如果此时把宽带分配给第$k$项业务（可能是第$𝑖$个用户的第$𝑗$个申请），该业务所需宽带是$r(k)$（在$r(k)=r(i,j)\leq l$的情况下），优先级收益是$P(k)=P(i,j)$。那么，剩下的宽带是$l-$$r(k)$。这些宽带将在${1,2,\cdots,k-1}$项业务中分配，所得到的优先级收益将是$v(k-1,l-r(k))$，因此总的优先级收益是$v(k-1,l-r(k)+P(k))\mathrm{v}$。相反，如果不把宽带分配给第$k$项业务，那么全部宽带𝑙将在${1,2,\cdots,k-1}$项业务中分配，总收益为$v(k-1,l)$为了使得优先级的总收益最大，只要在上述两个收益中选择最大的即可。  
上述分析可以总结成下面的递推公式，即$\forall k(0\leq k\leq m),\forall l(0\leq l\leq B)$，有  
$v(k,l)$  
![](images/ca1bba9e9c93f3e9595cc988da9323614b05bd9b58074b31eaf8aa4a7e6c05f3.jpg)  
根据这个公式：  
第一步先计算$k=1,\mathsf{l}=1,2,\cdots,B$的$v(1,l)$值，并把它们存到一个表中；  
第二步计算$k=2,\mathsf{l}=1,2,\cdots,B$的$v(2,l)$值，再把得到的值存到这个表中。  
每步计算若用到的较小的$v(k,l)$值，就到表中去取。照此做下去，直到计算出$k=m,l=$${1,2,\cdots,B}$的$v(m,l)$值为止，其中的$v(m,B)$就是最佳分配的优化函数值，即最大优先级收益。  
上述计算完成后，再根据$v(m,B)$的值逐步向前追溯，就可以找到最佳分配方案。先看$v(m,B)$是等于$v(m-1,B)$，还是等于$v\bigl(m-1,B-r(m)\bigr)+P(m)\,?$若等于前者，则没有选择第$m$项业务；若等于后者，则选择了第$m$项业务。然后根据剩下的部分是$v(m-1,B)$还是$v\big(m-1,B-r(m)\big)$来追溯第$m-1$项业务是否被选到。照此下去，直到$m$项业务都考察到，就得到问题的解。如果在计算每一项$v(k,l)$的时刻就把是否选择第$k$项业务记录下来，则就可以省略追溯过程，只需查一下全部记录，就能得到了问题的解。",优先级函数的值在递推公式中用于计算最优宽带分配的优先级收益
图论,基础理论,图模型,,"若用点表示现实世界中事物、点之间连线表示事物之间联系，则可画出一个图来形象地表达问题模型。事实上，若将思维浓缩，图是最简洁的思维轨迹；若将思维展开，图能描述最复杂的思维蓝本。因此，人类在很久以前就开始用图的方法记忆、分析和解决问题。然而，如果只停留在对一些具体图的讨论，那么人类就永远走不出经验主义的局限。幸运的是，十八世纪著名数学家欧拉创造性地将具体问题抽象为图模型，建立一套关于图的数学理论——图论，使图模型成为一种非常有效且非常有趣的数学工具，实现了形象思维与抽象思维的完美结合、理论性与实用性的完美结合。图模型作为一种特殊的二元关系，诠释了复杂的多对多关系，揭示了各结点之间错综复杂的网状拓扑结构，具有强大的知识表达能力。正是这种强大的表达能力使得图模型在解决诸多复杂问题中发挥至关重要、不可替代的作用。在计算机诞生之前，图模型主要用于解决一些游戏问题，例如迷宫问题、博弈问题、棋盘马经问题等等。随着计算机的诞生与兴起，图模型作为一种最基本的离散数学结构在计算机各个领域得到广泛应用，例如计算机网络路由问题、送快递最短路径问题、网站之间链接模型问题、工程预算关键路径问题、软件代码复杂度计算问题等等，都需要使用图论知识进行问题表示和求解。目前，图论及其算法已经成为计算机专业人员必须熟练掌握的一项基本知识。  
对于图这种基于连接策略的模型，自然会让人产生很多疑问，例如如何在计算机中实现这些图模型的表示和运算、沿着这些连接如何自动找到合适的路径从一个结点到达另外一个结点、能否自动计算出符合要求路径的个数、能否自动找到结点之间最短的连接路径、如何对图的结点或边进行自动遍历、如何通过图模型对实际问题建模等等。本章目标主要是通过系统地介绍和讨论图模型及其算法设计的基本知识，使得读者不仅能够找到上述问题的答案，而且能够较好地掌握图的基本理论及相关算法设计技术。本节首先学习图的概念与表示、图的运算与性质以及图的连通性质；然后介绍若干经典的图模型算法，包括图的遍历算法、单源和多源最短路径算法等；最后介绍图模型的应用。",图论是图模型的基础理论，使图模型成为一种有效的数学工具。
图模型,应用,图的遍历算法,,"若用点表示现实世界中事物、点之间连线表示事物之间联系，则可画出一个图来形象地表达问题模型。事实上，若将思维浓缩，图是最简洁的思维轨迹；若将思维展开，图能描述最复杂的思维蓝本。因此，人类在很久以前就开始用图的方法记忆、分析和解决问题。然而，如果只停留在对一些具体图的讨论，那么人类就永远走不出经验主义的局限。幸运的是，十八世纪著名数学家欧拉创造性地将具体问题抽象为图模型，建立一套关于图的数学理论——图论，使图模型成为一种非常有效且非常有趣的数学工具，实现了形象思维与抽象思维的完美结合、理论性与实用性的完美结合。图模型作为一种特殊的二元关系，诠释了复杂的多对多关系，揭示了各结点之间错综复杂的网状拓扑结构，具有强大的知识表达能力。正是这种强大的表达能力使得图模型在解决诸多复杂问题中发挥至关重要、不可替代的作用。在计算机诞生之前，图模型主要用于解决一些游戏问题，例如迷宫问题、博弈问题、棋盘马经问题等等。随着计算机的诞生与兴起，图模型作为一种最基本的离散数学结构在计算机各个领域得到广泛应用，例如计算机网络路由问题、送快递最短路径问题、网站之间链接模型问题、工程预算关键路径问题、软件代码复杂度计算问题等等，都需要使用图论知识进行问题表示和求解。目前，图论及其算法已经成为计算机专业人员必须熟练掌握的一项基本知识。  
对于图这种基于连接策略的模型，自然会让人产生很多疑问，例如如何在计算机中实现这些图模型的表示和运算、沿着这些连接如何自动找到合适的路径从一个结点到达另外一个结点、能否自动计算出符合要求路径的个数、能否自动找到结点之间最短的连接路径、如何对图的结点或边进行自动遍历、如何通过图模型对实际问题建模等等。本章目标主要是通过系统地介绍和讨论图模型及其算法设计的基本知识，使得读者不仅能够找到上述问题的答案，而且能够较好地掌握图的基本理论及相关算法设计技术。本节首先学习图的概念与表示、图的运算与性质以及图的连通性质；然后介绍若干经典的图模型算法，包括图的遍历算法、单源和多源最短路径算法等；最后介绍图模型的应用。",图模型需要通过图的遍历算法进行结点或边的自动遍历。
图模型,应用,单源最短路径算法,,"若用点表示现实世界中事物、点之间连线表示事物之间联系，则可画出一个图来形象地表达问题模型。事实上，若将思维浓缩，图是最简洁的思维轨迹；若将思维展开，图能描述最复杂的思维蓝本。因此，人类在很久以前就开始用图的方法记忆、分析和解决问题。然而，如果只停留在对一些具体图的讨论，那么人类就永远走不出经验主义的局限。幸运的是，十八世纪著名数学家欧拉创造性地将具体问题抽象为图模型，建立一套关于图的数学理论——图论，使图模型成为一种非常有效且非常有趣的数学工具，实现了形象思维与抽象思维的完美结合、理论性与实用性的完美结合。图模型作为一种特殊的二元关系，诠释了复杂的多对多关系，揭示了各结点之间错综复杂的网状拓扑结构，具有强大的知识表达能力。正是这种强大的表达能力使得图模型在解决诸多复杂问题中发挥至关重要、不可替代的作用。在计算机诞生之前，图模型主要用于解决一些游戏问题，例如迷宫问题、博弈问题、棋盘马经问题等等。随着计算机的诞生与兴起，图模型作为一种最基本的离散数学结构在计算机各个领域得到广泛应用，例如计算机网络路由问题、送快递最短路径问题、网站之间链接模型问题、工程预算关键路径问题、软件代码复杂度计算问题等等，都需要使用图论知识进行问题表示和求解。目前，图论及其算法已经成为计算机专业人员必须熟练掌握的一项基本知识。  
对于图这种基于连接策略的模型，自然会让人产生很多疑问，例如如何在计算机中实现这些图模型的表示和运算、沿着这些连接如何自动找到合适的路径从一个结点到达另外一个结点、能否自动计算出符合要求路径的个数、能否自动找到结点之间最短的连接路径、如何对图的结点或边进行自动遍历、如何通过图模型对实际问题建模等等。本章目标主要是通过系统地介绍和讨论图模型及其算法设计的基本知识，使得读者不仅能够找到上述问题的答案，而且能够较好地掌握图的基本理论及相关算法设计技术。本节首先学习图的概念与表示、图的运算与性质以及图的连通性质；然后介绍若干经典的图模型算法，包括图的遍历算法、单源和多源最短路径算法等；最后介绍图模型的应用。",图模型使用单源最短路径算法来找到结点之间的最短路径。
图模型,应用,多源最短路径算法,,"若用点表示现实世界中事物、点之间连线表示事物之间联系，则可画出一个图来形象地表达问题模型。事实上，若将思维浓缩，图是最简洁的思维轨迹；若将思维展开，图能描述最复杂的思维蓝本。因此，人类在很久以前就开始用图的方法记忆、分析和解决问题。然而，如果只停留在对一些具体图的讨论，那么人类就永远走不出经验主义的局限。幸运的是，十八世纪著名数学家欧拉创造性地将具体问题抽象为图模型，建立一套关于图的数学理论——图论，使图模型成为一种非常有效且非常有趣的数学工具，实现了形象思维与抽象思维的完美结合、理论性与实用性的完美结合。图模型作为一种特殊的二元关系，诠释了复杂的多对多关系，揭示了各结点之间错综复杂的网状拓扑结构，具有强大的知识表达能力。正是这种强大的表达能力使得图模型在解决诸多复杂问题中发挥至关重要、不可替代的作用。在计算机诞生之前，图模型主要用于解决一些游戏问题，例如迷宫问题、博弈问题、棋盘马经问题等等。随着计算机的诞生与兴起，图模型作为一种最基本的离散数学结构在计算机各个领域得到广泛应用，例如计算机网络路由问题、送快递最短路径问题、网站之间链接模型问题、工程预算关键路径问题、软件代码复杂度计算问题等等，都需要使用图论知识进行问题表示和求解。目前，图论及其算法已经成为计算机专业人员必须熟练掌握的一项基本知识。  
对于图这种基于连接策略的模型，自然会让人产生很多疑问，例如如何在计算机中实现这些图模型的表示和运算、沿着这些连接如何自动找到合适的路径从一个结点到达另外一个结点、能否自动计算出符合要求路径的个数、能否自动找到结点之间最短的连接路径、如何对图的结点或边进行自动遍历、如何通过图模型对实际问题建模等等。本章目标主要是通过系统地介绍和讨论图模型及其算法设计的基本知识，使得读者不仅能够找到上述问题的答案，而且能够较好地掌握图的基本理论及相关算法设计技术。本节首先学习图的概念与表示、图的运算与性质以及图的连通性质；然后介绍若干经典的图模型算法，包括图的遍历算法、单源和多源最短路径算法等；最后介绍图模型的应用。",图模型使用多源最短路径算法来处理多个源点的最短路径问题。
图论,包含,图的遍历算法,,"若用点表示现实世界中事物、点之间连线表示事物之间联系，则可画出一个图来形象地表达问题模型。事实上，若将思维浓缩，图是最简洁的思维轨迹；若将思维展开，图能描述最复杂的思维蓝本。因此，人类在很久以前就开始用图的方法记忆、分析和解决问题。然而，如果只停留在对一些具体图的讨论，那么人类就永远走不出经验主义的局限。幸运的是，十八世纪著名数学家欧拉创造性地将具体问题抽象为图模型，建立一套关于图的数学理论——图论，使图模型成为一种非常有效且非常有趣的数学工具，实现了形象思维与抽象思维的完美结合、理论性与实用性的完美结合。图模型作为一种特殊的二元关系，诠释了复杂的多对多关系，揭示了各结点之间错综复杂的网状拓扑结构，具有强大的知识表达能力。正是这种强大的表达能力使得图模型在解决诸多复杂问题中发挥至关重要、不可替代的作用。在计算机诞生之前，图模型主要用于解决一些游戏问题，例如迷宫问题、博弈问题、棋盘马经问题等等。随着计算机的诞生与兴起，图模型作为一种最基本的离散数学结构在计算机各个领域得到广泛应用，例如计算机网络路由问题、送快递最短路径问题、网站之间链接模型问题、工程预算关键路径问题、软件代码复杂度计算问题等等，都需要使用图论知识进行问题表示和求解。目前，图论及其算法已经成为计算机专业人员必须熟练掌握的一项基本知识。  
对于图这种基于连接策略的模型，自然会让人产生很多疑问，例如如何在计算机中实现这些图模型的表示和运算、沿着这些连接如何自动找到合适的路径从一个结点到达另外一个结点、能否自动计算出符合要求路径的个数、能否自动找到结点之间最短的连接路径、如何对图的结点或边进行自动遍历、如何通过图模型对实际问题建模等等。本章目标主要是通过系统地介绍和讨论图模型及其算法设计的基本知识，使得读者不仅能够找到上述问题的答案，而且能够较好地掌握图的基本理论及相关算法设计技术。本节首先学习图的概念与表示、图的运算与性质以及图的连通性质；然后介绍若干经典的图模型算法，包括图的遍历算法、单源和多源最短路径算法等；最后介绍图模型的应用。",图论包含图的遍历算法作为其基本算法之一。
图论,包含,单源最短路径算法,,"若用点表示现实世界中事物、点之间连线表示事物之间联系，则可画出一个图来形象地表达问题模型。事实上，若将思维浓缩，图是最简洁的思维轨迹；若将思维展开，图能描述最复杂的思维蓝本。因此，人类在很久以前就开始用图的方法记忆、分析和解决问题。然而，如果只停留在对一些具体图的讨论，那么人类就永远走不出经验主义的局限。幸运的是，十八世纪著名数学家欧拉创造性地将具体问题抽象为图模型，建立一套关于图的数学理论——图论，使图模型成为一种非常有效且非常有趣的数学工具，实现了形象思维与抽象思维的完美结合、理论性与实用性的完美结合。图模型作为一种特殊的二元关系，诠释了复杂的多对多关系，揭示了各结点之间错综复杂的网状拓扑结构，具有强大的知识表达能力。正是这种强大的表达能力使得图模型在解决诸多复杂问题中发挥至关重要、不可替代的作用。在计算机诞生之前，图模型主要用于解决一些游戏问题，例如迷宫问题、博弈问题、棋盘马经问题等等。随着计算机的诞生与兴起，图模型作为一种最基本的离散数学结构在计算机各个领域得到广泛应用，例如计算机网络路由问题、送快递最短路径问题、网站之间链接模型问题、工程预算关键路径问题、软件代码复杂度计算问题等等，都需要使用图论知识进行问题表示和求解。目前，图论及其算法已经成为计算机专业人员必须熟练掌握的一项基本知识。  
对于图这种基于连接策略的模型，自然会让人产生很多疑问，例如如何在计算机中实现这些图模型的表示和运算、沿着这些连接如何自动找到合适的路径从一个结点到达另外一个结点、能否自动计算出符合要求路径的个数、能否自动找到结点之间最短的连接路径、如何对图的结点或边进行自动遍历、如何通过图模型对实际问题建模等等。本章目标主要是通过系统地介绍和讨论图模型及其算法设计的基本知识，使得读者不仅能够找到上述问题的答案，而且能够较好地掌握图的基本理论及相关算法设计技术。本节首先学习图的概念与表示、图的运算与性质以及图的连通性质；然后介绍若干经典的图模型算法，包括图的遍历算法、单源和多源最短路径算法等；最后介绍图模型的应用。",图论包含单源最短路径算法作为其基本算法之一。
图论,包含,多源最短路径算法,,"若用点表示现实世界中事物、点之间连线表示事物之间联系，则可画出一个图来形象地表达问题模型。事实上，若将思维浓缩，图是最简洁的思维轨迹；若将思维展开，图能描述最复杂的思维蓝本。因此，人类在很久以前就开始用图的方法记忆、分析和解决问题。然而，如果只停留在对一些具体图的讨论，那么人类就永远走不出经验主义的局限。幸运的是，十八世纪著名数学家欧拉创造性地将具体问题抽象为图模型，建立一套关于图的数学理论——图论，使图模型成为一种非常有效且非常有趣的数学工具，实现了形象思维与抽象思维的完美结合、理论性与实用性的完美结合。图模型作为一种特殊的二元关系，诠释了复杂的多对多关系，揭示了各结点之间错综复杂的网状拓扑结构，具有强大的知识表达能力。正是这种强大的表达能力使得图模型在解决诸多复杂问题中发挥至关重要、不可替代的作用。在计算机诞生之前，图模型主要用于解决一些游戏问题，例如迷宫问题、博弈问题、棋盘马经问题等等。随着计算机的诞生与兴起，图模型作为一种最基本的离散数学结构在计算机各个领域得到广泛应用，例如计算机网络路由问题、送快递最短路径问题、网站之间链接模型问题、工程预算关键路径问题、软件代码复杂度计算问题等等，都需要使用图论知识进行问题表示和求解。目前，图论及其算法已经成为计算机专业人员必须熟练掌握的一项基本知识。  
对于图这种基于连接策略的模型，自然会让人产生很多疑问，例如如何在计算机中实现这些图模型的表示和运算、沿着这些连接如何自动找到合适的路径从一个结点到达另外一个结点、能否自动计算出符合要求路径的个数、能否自动找到结点之间最短的连接路径、如何对图的结点或边进行自动遍历、如何通过图模型对实际问题建模等等。本章目标主要是通过系统地介绍和讨论图模型及其算法设计的基本知识，使得读者不仅能够找到上述问题的答案，而且能够较好地掌握图的基本理论及相关算法设计技术。本节首先学习图的概念与表示、图的运算与性质以及图的连通性质；然后介绍若干经典的图模型算法，包括图的遍历算法、单源和多源最短路径算法等；最后介绍图模型的应用。",图论包含多源最短路径算法作为其基本算法之一。
图模型,包含,图的概念,,前述关系理论涉及一种称之为图的几何模型，如关系图、哈斯图等。这种图模型由一些点和连接两点的线组成，主要用于表示事物之间一对多、多对多的复杂关系。与传统几何模型不同，对于图模型，我们感兴趣的只是其中有多少个点以及哪些点之间有线连接，至于线的长短曲直以及点的位置都无关紧要，即只考虑点和线之间的结构信息，不考虑点和线之间的位置信息。图模型作为对离散对象及其联系的一种直观抽象表示形式，广泛用于对现实问题的建模和求解。本节主要介绍图模型的由来、基本概念以及表示方法。,图模型包含图的基本概念，用于表示事物之间的复杂关系
哥尼斯堡七桥问题,转化,一笔画问题,,"俄罗斯加里宁格勒州的首府加里宁格勒，原名为哥尼斯堡，是一个具有悠久历史的小镇。有一条名为普雷格尔的小河横穿这个小镇，并且在河中间形成两个小岛。在十八世纪的时候，人们在这条河上建有七座桥，将河中两个岛与河的两岸联结起来，建成一个如图8-1 (a)所示的公园。人们闲暇时常在这个公园里散步，有一天其中有个人突发奇想，提出一个问题：一 个步行者怎样才能不重复、不遗漏地一次走完七座桥，最后回到出发点。问题提出后，很多人对此很感兴趣，纷纷进行试验，但始终未能解决。  
![图8-1 哥尼斯堡七桥问题 ](images/ec575bdd4dc2973aa10919a05915ce2521c1b0a0f2f8089a7104e2a805855033.jpg)  
1735 年，有几名大学生写信给当时正在俄罗斯的彼得斯堡科学院任职的瑞士天才数学家欧拉，请他帮忙解决这一问题。欧拉在亲自观察了哥尼斯堡七桥，在经过为期一年的研究之后，29 岁的欧拉在1736 年提交了名为《哥尼斯堡七桥》的论文，圆满解决了这一问题。在论文中，欧拉将两个小岛和两岸构成的四块陆地分别抽象成结点，然后将连接这四块陆地的七座小桥分别抽象成连接这四个结点的边，如图8-1 (b)所示。这样遍历哥尼斯堡七桥问题就转化为遍历图8-1 (b)的七条边的问题或者说是对图8-1 (b)的一笔画问题。  
我们知道，对于任意一个结点，如果它是出发结点，那么它必然要关联一条边使得散步者能够回到这个结点，如果这个结点不是出发点，那么这个结点必须要关联偶数条边以保证散步者能够进出这个结点，因为每条边只能通过一次，进出一次这个结点需要关联两条不同的边。根据以上思路，不难得到如下三条关于一笔画结论：  
1.如果一个连通图的每个结点都关联偶数条边，那么可以任一结点为起点，用一笔画完此图并该结点为终点；  
2.如果一个连通图只有两个结点关联奇数条边，其余结点均关联偶数条边，那么该图一定可以用一笔画成，此时，关联奇数条边的两个结点分别为起点和终点；  
3.不满足前两个条件的图都不能用一笔画出，此时将关联奇数条边的结点数除以二便可得到该图需用几笔才能画成。  
现在考察哥尼斯堡七桥问题，图中每个结点均关联奇数条边，因而无解。  
欧拉解决哥尼斯堡七桥问题的思路非常巧妙，是一种全新的建模方式。在完美解决哥尼斯堡七桥问题之后，欧拉对这种模型的性质以及相关的建模方式做了深入系统的研究并由此创立了一套新的数学理论——图论。因此，欧拉被誉为图论之父。  
除欧拉之外，还有很多数学家对图论的研究做出重要成果，例如霍尔基夫基于图论的电路网络分析、麦比乌斯的四色猜想问题及解法、哈密尔顿的结点遍历问题及解法，等等。直至1936 年，匈牙利的数学家哥尼格出版了第一本图论专著《有限图与无限图的理论》，标志着图论从此成为一门相对独立完备的数学分支。",哥尼斯堡七桥问题可以转化为一笔画问题，通过抽象成图的结构来分析解决。
哥尼斯堡七桥问题,创立基础,图论,,"俄罗斯加里宁格勒州的首府加里宁格勒，原名为哥尼斯堡，是一个具有悠久历史的小镇。有一条名为普雷格尔的小河横穿这个小镇，并且在河中间形成两个小岛。在十八世纪的时候，人们在这条河上建有七座桥，将河中两个岛与河的两岸联结起来，建成一个如图8-1 (a)所示的公园。人们闲暇时常在这个公园里散步，有一天其中有个人突发奇想，提出一个问题：一 个步行者怎样才能不重复、不遗漏地一次走完七座桥，最后回到出发点。问题提出后，很多人对此很感兴趣，纷纷进行试验，但始终未能解决。  
![图8-1 哥尼斯堡七桥问题 ](images/ec575bdd4dc2973aa10919a05915ce2521c1b0a0f2f8089a7104e2a805855033.jpg)  
1735 年，有几名大学生写信给当时正在俄罗斯的彼得斯堡科学院任职的瑞士天才数学家欧拉，请他帮忙解决这一问题。欧拉在亲自观察了哥尼斯堡七桥，在经过为期一年的研究之后，29 岁的欧拉在1736 年提交了名为《哥尼斯堡七桥》的论文，圆满解决了这一问题。在论文中，欧拉将两个小岛和两岸构成的四块陆地分别抽象成结点，然后将连接这四块陆地的七座小桥分别抽象成连接这四个结点的边，如图8-1 (b)所示。这样遍历哥尼斯堡七桥问题就转化为遍历图8-1 (b)的七条边的问题或者说是对图8-1 (b)的一笔画问题。  
我们知道，对于任意一个结点，如果它是出发结点，那么它必然要关联一条边使得散步者能够回到这个结点，如果这个结点不是出发点，那么这个结点必须要关联偶数条边以保证散步者能够进出这个结点，因为每条边只能通过一次，进出一次这个结点需要关联两条不同的边。根据以上思路，不难得到如下三条关于一笔画结论：  
1.如果一个连通图的每个结点都关联偶数条边，那么可以任一结点为起点，用一笔画完此图并该结点为终点；  
2.如果一个连通图只有两个结点关联奇数条边，其余结点均关联偶数条边，那么该图一定可以用一笔画成，此时，关联奇数条边的两个结点分别为起点和终点；  
3.不满足前两个条件的图都不能用一笔画出，此时将关联奇数条边的结点数除以二便可得到该图需用几笔才能画成。  
现在考察哥尼斯堡七桥问题，图中每个结点均关联奇数条边，因而无解。  
欧拉解决哥尼斯堡七桥问题的思路非常巧妙，是一种全新的建模方式。在完美解决哥尼斯堡七桥问题之后，欧拉对这种模型的性质以及相关的建模方式做了深入系统的研究并由此创立了一套新的数学理论——图论。因此，欧拉被誉为图论之父。  
除欧拉之外，还有很多数学家对图论的研究做出重要成果，例如霍尔基夫基于图论的电路网络分析、麦比乌斯的四色猜想问题及解法、哈密尔顿的结点遍历问题及解法，等等。直至1936 年，匈牙利的数学家哥尼格出版了第一本图论专著《有限图与无限图的理论》，标志着图论从此成为一门相对独立完备的数学分支。",欧拉通过解决哥尼斯堡七桥问题，创立了图论这一新的数学理论。
一笔画问题,属于,图论,,"俄罗斯加里宁格勒州的首府加里宁格勒，原名为哥尼斯堡，是一个具有悠久历史的小镇。有一条名为普雷格尔的小河横穿这个小镇，并且在河中间形成两个小岛。在十八世纪的时候，人们在这条河上建有七座桥，将河中两个岛与河的两岸联结起来，建成一个如图8-1 (a)所示的公园。人们闲暇时常在这个公园里散步，有一天其中有个人突发奇想，提出一个问题：一 个步行者怎样才能不重复、不遗漏地一次走完七座桥，最后回到出发点。问题提出后，很多人对此很感兴趣，纷纷进行试验，但始终未能解决。  
![图8-1 哥尼斯堡七桥问题 ](images/ec575bdd4dc2973aa10919a05915ce2521c1b0a0f2f8089a7104e2a805855033.jpg)  
1735 年，有几名大学生写信给当时正在俄罗斯的彼得斯堡科学院任职的瑞士天才数学家欧拉，请他帮忙解决这一问题。欧拉在亲自观察了哥尼斯堡七桥，在经过为期一年的研究之后，29 岁的欧拉在1736 年提交了名为《哥尼斯堡七桥》的论文，圆满解决了这一问题。在论文中，欧拉将两个小岛和两岸构成的四块陆地分别抽象成结点，然后将连接这四块陆地的七座小桥分别抽象成连接这四个结点的边，如图8-1 (b)所示。这样遍历哥尼斯堡七桥问题就转化为遍历图8-1 (b)的七条边的问题或者说是对图8-1 (b)的一笔画问题。  
我们知道，对于任意一个结点，如果它是出发结点，那么它必然要关联一条边使得散步者能够回到这个结点，如果这个结点不是出发点，那么这个结点必须要关联偶数条边以保证散步者能够进出这个结点，因为每条边只能通过一次，进出一次这个结点需要关联两条不同的边。根据以上思路，不难得到如下三条关于一笔画结论：  
1.如果一个连通图的每个结点都关联偶数条边，那么可以任一结点为起点，用一笔画完此图并该结点为终点；  
2.如果一个连通图只有两个结点关联奇数条边，其余结点均关联偶数条边，那么该图一定可以用一笔画成，此时，关联奇数条边的两个结点分别为起点和终点；  
3.不满足前两个条件的图都不能用一笔画出，此时将关联奇数条边的结点数除以二便可得到该图需用几笔才能画成。  
现在考察哥尼斯堡七桥问题，图中每个结点均关联奇数条边，因而无解。  
欧拉解决哥尼斯堡七桥问题的思路非常巧妙，是一种全新的建模方式。在完美解决哥尼斯堡七桥问题之后，欧拉对这种模型的性质以及相关的建模方式做了深入系统的研究并由此创立了一套新的数学理论——图论。因此，欧拉被誉为图论之父。  
除欧拉之外，还有很多数学家对图论的研究做出重要成果，例如霍尔基夫基于图论的电路网络分析、麦比乌斯的四色猜想问题及解法、哈密尔顿的结点遍历问题及解法，等等。直至1936 年，匈牙利的数学家哥尼格出版了第一本图论专著《有限图与无限图的理论》，标志着图论从此成为一门相对独立完备的数学分支。",一笔画问题是图论中的一个重要问题，涉及图的遍历和结点边的关联性质。
图模型,组成,结点,,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)",图模型由结点和边组成
图模型,组成,边,,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)",图模型由结点和边组成
图模型,分类,无向图,,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)",图模型根据边的方向可分为无向图、有向图和混合图
图模型,分类,有向图,,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)",图模型根据边的方向可分为无向图、有向图和混合图
图模型,分类,混合图,,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)",图模型根据边的方向可分为无向图、有向图和混合图
图模型,分类,多重图,,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)",图模型根据有无平行边可分为多重图、线图和简单图
图模型,分类,线图,,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)",图模型根据有无平行边可分为多重图、线图和简单图
图模型,分类,简单图,,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)",图模型根据有无平行边可分为多重图、线图和简单图
图模型,分类,赋权图,,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)",图模型根据边或结点是否有权可分为赋权图和无权图
图模型,分类,无权图,,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)",图模型根据边或结点是否有权可分为赋权图和无权图
结点,连接,边,,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)",结点通过边进行连接
有向边,包含,始点,,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)",有向边包含始点和终点
有向边,包含,终点,,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)",有向边包含始点和终点
无向边,包含,端点,,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)",无向边包含两个端点
邻接点,关联,边,,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)",邻接点是边的端点
关联边,关联,结点,,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)",关联边是以某结点为端点的边
邻接边,共享,结点,,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)",邻接边具有公共结点
自环,相同,结点,,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)",自环的两个端点相同
孤立结点,无关联,边,,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)",孤立结点不与任何边关联
零图,组成,孤立结点,,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)",零图由孤立结点组成
平凡图,组成,孤立结点,,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)",平凡图仅含一个孤立结点
"(n,m)图",数量,结点,,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)","(n,m)图含有n个结点"
"(n,m)图",数量,边,,"在众多应用领域中，例如各种关系的表示、作业的运筹规划与调度、网络技术的研究以及计算机程序的流程分析，都会遇到这种由“结点”和“边”组成的图模型。在用图模型对具体问题建模时，通常用结点表示事物对象，用结点之间的连线表示对象之间联系。因此，这里讨论的图模型与人们通常熟知的几何图形，如三角形、梯形、椭圆等有很大不同，是指某类具体离散事物集合以及反映该集合中每对事物之间某种联系的一种离散数学结构模型。  
对于这种图模型，感兴趣的只是其中有多少个结点以及哪些点之间有边相连，至于结点位置以及边的长短曲直都无关紧要。因此，从本质上说，图模型其实就是由结点和联结结点的边组成的一种特殊二元关系模型，用于表示一组对象以及这组对象之间的某种二元关系。由此得到如下关于图模型的数学定义：  
【定义8.1】由非空有限集合 $V$和有限多重集 $E$组成的二元组 $G$=$\left< V,E\right>\\$ 称为图模型，简称为图。其中：$V$=$\{v_1,v_2,v_3,\ldots,v_n\}$ 是一个非空有限集，$V$ 中元素称为图的结点；$E$是一个有限多重集，即$E=\{n_{1}\cdot e_{1},n_{2}\cdot e_{2},\cdots,n_{m}\cdot e_{m}\}$，$E$ 中每个元素$e_{i}$均是 $V$ 中一个或两个结点组成的结点对，称为图的边。  
从上述定义及例题可以看出，图模型表示的是有限集合𝑉上的某种二元关系$E$，如果两结点之间具有这种关系，则用边进行联结，否则它们之间就无边相联。  
值得注意的是，图模型的两个结点之间可能会有多条边相连，例如，在图8-1 (b)所示图中结点𝐴与$B$之间，以及结点$B$与$C$之间均有两条边联结。因此，图的边集$\boldsymbol{\cdot}E$是一个多重集合。 不过考虑到一般都会给图中每条边标上标识符，人们还是习惯于使用普通集合表示边集。 我们遵从这个习惯，在没有特别要求的情况下，一般使用普通集合表示边集。  
例如，图8-1 (b)所示图模型一共有4 个结点和7 条边，其结点集合为$V=\left\{A,B,C,D\right\}$，边集合为𝐸= {2 ∙(A,B), 2 ∙(B, C), 1 ∙(B,D), 1 ∙(C, D), 1 ∙(A, D) }。习惯上仍将边集表示为普通集合$\ E=\{a,b,c,d,e,f,g\,\,\}$。  
【定义8.2】对于图 $G$ 中的任意一条边：如果该边是从结点 $u$出发到结点 $v$的有方向的边，则称其为有向边，用序偶$\langle u,v\rangle$ 表示，其中第一元素 $u$ 称为有向边的始点，第二元素$v$ 称为有向边的终点，$u$ 和 $v$ 也都称为有向边的端点；如果该边是连接 $u$ 和 $v$ 的无方向的边，称为无向边，用无序偶 $(u,v)$ 表示。其中 $u$ 和 $v$ 均称为无向边的端点。  
对于如图8-3 所示图 $G_{1}$，可将其表示为 $G_{1}=\langle V_{1},E_{1}\rangle$。其中：$V_{1}=\{v_{1},v_{2},v_{3},v_{4},v_{5}\},$  
$E_{1}=\{(v_{1},v_{2}),(v_{1},v_{4}),(v_{1},v_{5}),(v_{2},v_{3}),(v_{2},v_{5}),(v_{3},v_{4}),(v_{3},v_{5}),(v_{4},v_{5})\}$ 构成无序偶的两个结点分别为该无序偶所表示无向边的端点。对于如图8-3 所示图 $G_{2}$，可将其表示为 $G_{2}=\langle V_{2},E_{2}\rangle\\$ 。其中：  
$V_{2}=\{v_{1},v_{2},v_{3},v_{4}\},$ $E_{2}=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{3}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{3},v_{2}\rangle,\langle v_{3},v_{4}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$  
边集$E_{2}$中每个序偶第一元素为有向边的始点，第二元素为有向边的终点。  
为方便理解和应用图模型的结构，下面定义一些与图结构相关的基本概念：  
【定义8.3】在图 $G=\langle V,E\rangle$ 中，若两个结点 $u$ 和 $v$ 是边 $e$ 的端点，则称 $u$ 与 $v$ 互为邻接点，否则称为不邻接；以结点 $u$为端点的边，称为结点 $u$ 的关联边；具有公共结点的两条边称为邻接边；两个端点相同的边称为自环或自回路；不与任何结点相邻接的结点称为孤立结点；由孤立结点组成而没有边的图称为零图；仅含一个孤立结点而没有边的图，称为平凡图；含有   $n$ 个结点， $m$   条边的图称为   $(n,m)$   图。  
例如，图8-4 (a)所示的图$G_{1}$是一个(6,7) 图。结点 $v_{1}$ 的邻接点是 $v_{2},\;v_{3}$ 和 $v_{4}$。结点$v_{3}$ 的邻接点是 $v_{1}$ 和 $v_{2}$。边 $e_{2}$ 的邻接边是$\mathbf{\xi}.e_{1},\ e_{3}$ 和 $e_{6}$ 。边 $e_{4}$ 的邻接边是 $e_{1},e_{5}$ 和$e_{6}$ 。结点 $v_{4}$ 的关联边是边 $e_{2}$ 。图$G$中孤立结点是 $v_{5}$ ，自环有 $\boldsymbol{v}_{1}~-\boldsymbol{e}_{3}-\ \boldsymbol{v}_{1}$ 和$\boldsymbol{v}_{6}~-\boldsymbol{e}_{7}-\ \boldsymbol{v}_{6}$  
对于图8-4 (b)所示的图模型 $G_{2}$ ，该图表示了一个包含四个孤立顶点的零图。  
对于图8-4 (c)所示的图模型 $G_{3}$ ，该图表示了仅包含一个孤立顶点的平凡图。  
![图8-4 若干图模型 ](images/292fee2df737b9956da966f3ffd91d68226a236ad21812897c47f3c7a9e6d07e.jpg)  
图模型是一种复杂的离散结构，可按不同的分类标准将其分成不同类型。一般根据有无方向、有无平行边、有无权重等标准对图模型进行分类。  
（1）无向图、有向图、混合图  
根据有无方向边，可将图划分为无向图、有向图和混合图，相关定义如下：  
【定义8.4】对于任意一个给定的图模型：如果它的每条边都是无向边，则称该图为无向图；如果它的每条边都是有向边，则称该图为有向图；如果图中有些边是无向边，有些边是有向边，则称该图为混合图。  
在图8-5 所示图中，图$G_{1}$，$G_{2}$，$G_{3}$分别是无向图、有向图、混合图。  
![图8-5 按有无方向进行分类](images/eca1009ece8386da02c999e4f11ba5d5dea41fb1d476703502bd67410bba8b76.jpg)  
事实上，在没有特别或限定的情况下，也可将无向边看成是两条分别具备相反方向的有向边，相应地，可将无序偶$(u,v)$看成是两个有序偶$\langle u,v\rangle$和$\langle v,u\rangle$。因此，可将混合图转化为有向图。以后在没有特别说明的情况下，我们主要考察无向图和有向图。  
（2）多重图、线图和简单图  
根据有无平行边，可将图划分为多重图、线图和简单图，相关定义如下：  
【定义8.5】对于任意一个有向图，如果两结点间（包括结点自身间），若有同始点且同终点的多条边，则称这些边为平行边；两结点间平行边的条数称为边的重数；含有平行边的图称为多重图；非多重图称为线图；无环的线图称为简单图。  
对于图8-6 (a)所示的有向图 $G_{1}$ ，其存在平行边$e_{1},e_{2},e_{3}$，平行边的条数为3，显然图$G_{1}$为多重图。  
对于图8-6 (b)所示的有向图 $G_{2}$，该图中不存在平行边且有环，因此图 $G_{2}$为线图。对于图8-6 (c)所示的有向图 $G_{3}$，该图中既无平行边又无环，故图 $G_{3}$为简单图。  
![图8-6 按有无平行边进行分类](images/89d3ea88472f20ffd7146dc6a2c6fe8f6dfd8d19a0be140cedbc9cc69c2ea88a.jpg)  
（3）赋权图、无权图  
根据边或结点是否有权，可以将图划分为赋权图和无权图，相关定义如下：  
【定义8.6】赋权图 $G$一般可记为三重组$\langle V,E,g\rangle$ ，其中 $V$ 是结点的集合，$E$ 是边的集合，$g$ 是从 $E$ 到非负实数集合的函数（对边赋权）。相应的有无向赋权图和有向赋权图之分。非赋权图称为无权图。  
![图8-7 按有无赋权进行分类  ](images/bab4ef372c33e5ab2d3135ab87c9846e4373348a424848a22834bd1e2a603ed8.jpg)","(n,m)图含有m条边"
图模型,表示方法,集合表示法,,"如前所述，图模型其实就是一种特殊的二元关系。因此，图模型作为一种二元关系，一般来说具有三种基本的表示方法，即集合表示法、图形表示法和矩阵表示法。对于一个图模型G，若将其记为 $G=\langle V,E\rangle$ ，并枚举集合 $V$ 和 $E$ 中所有元素，则称这种表示方法为图的集合表示法。若画出$G$ 的图形，用小圆圈表示 $V$中的结点，用由 $u$ 指向 $v$ 的有向线段或曲线表示有向边 $\langle u,v\rangle$ ，无向线段或曲线表示无向边 $(\mathrm{u},\mathrm{v})$ ，则称该方法为图的图形表示法。  
![图8-8 图模型G的图形表示法 ](images/42c40d1dbd600657cf3b9d4593b6b7c38007adbf1cf3dec9952b6b75bb10d397.jpg)  
对于图8-8 所示的图$G$ ，可用集合为 $G=\langle V,E\rangle$ ，其顶点集 $V=\{v_{1},v_{2},v_{3},v_{4}\}$，其边集$E=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{2},v_{3}\rangle,\langle v_{2},v_{4}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$ 。 若用图形表示，则其本身就是图形表示。  
集合表示法比较精确，但抽象且不易理解；图形表示法形象直观，但是当图中的结点和边的数目较大时，这种表示法很不方便甚至不可行。事实上，可以通过矩阵将图模型的逻辑结构转变成可在计算机中存储和运算的形式，并可设计一定的存储结构满足计算机处理的需要。因此，计算机系统通常使用矩阵实现对图的表示和处理。本节着重介绍图的矩阵表示法，具体包括邻接矩阵表示法、关联矩阵表示法、邻接表表示法等几种类型。",图模型可以通过集合表示法进行表示，即枚举集合V和E中的所有元素。
图模型,表示方法,图形表示法,,"如前所述，图模型其实就是一种特殊的二元关系。因此，图模型作为一种二元关系，一般来说具有三种基本的表示方法，即集合表示法、图形表示法和矩阵表示法。对于一个图模型G，若将其记为 $G=\langle V,E\rangle$ ，并枚举集合 $V$ 和 $E$ 中所有元素，则称这种表示方法为图的集合表示法。若画出$G$ 的图形，用小圆圈表示 $V$中的结点，用由 $u$ 指向 $v$ 的有向线段或曲线表示有向边 $\langle u,v\rangle$ ，无向线段或曲线表示无向边 $(\mathrm{u},\mathrm{v})$ ，则称该方法为图的图形表示法。  
![图8-8 图模型G的图形表示法 ](images/42c40d1dbd600657cf3b9d4593b6b7c38007adbf1cf3dec9952b6b75bb10d397.jpg)  
对于图8-8 所示的图$G$ ，可用集合为 $G=\langle V,E\rangle$ ，其顶点集 $V=\{v_{1},v_{2},v_{3},v_{4}\}$，其边集$E=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{2},v_{3}\rangle,\langle v_{2},v_{4}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$ 。 若用图形表示，则其本身就是图形表示。  
集合表示法比较精确，但抽象且不易理解；图形表示法形象直观，但是当图中的结点和边的数目较大时，这种表示法很不方便甚至不可行。事实上，可以通过矩阵将图模型的逻辑结构转变成可在计算机中存储和运算的形式，并可设计一定的存储结构满足计算机处理的需要。因此，计算机系统通常使用矩阵实现对图的表示和处理。本节着重介绍图的矩阵表示法，具体包括邻接矩阵表示法、关联矩阵表示法、邻接表表示法等几种类型。",图模型可以通过图形表示法进行表示，用小圆圈表示结点，用有向或无向线段表示边。
图模型,表示方法,矩阵表示法,,"如前所述，图模型其实就是一种特殊的二元关系。因此，图模型作为一种二元关系，一般来说具有三种基本的表示方法，即集合表示法、图形表示法和矩阵表示法。对于一个图模型G，若将其记为 $G=\langle V,E\rangle$ ，并枚举集合 $V$ 和 $E$ 中所有元素，则称这种表示方法为图的集合表示法。若画出$G$ 的图形，用小圆圈表示 $V$中的结点，用由 $u$ 指向 $v$ 的有向线段或曲线表示有向边 $\langle u,v\rangle$ ，无向线段或曲线表示无向边 $(\mathrm{u},\mathrm{v})$ ，则称该方法为图的图形表示法。  
![图8-8 图模型G的图形表示法 ](images/42c40d1dbd600657cf3b9d4593b6b7c38007adbf1cf3dec9952b6b75bb10d397.jpg)  
对于图8-8 所示的图$G$ ，可用集合为 $G=\langle V,E\rangle$ ，其顶点集 $V=\{v_{1},v_{2},v_{3},v_{4}\}$，其边集$E=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{2},v_{3}\rangle,\langle v_{2},v_{4}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$ 。 若用图形表示，则其本身就是图形表示。  
集合表示法比较精确，但抽象且不易理解；图形表示法形象直观，但是当图中的结点和边的数目较大时，这种表示法很不方便甚至不可行。事实上，可以通过矩阵将图模型的逻辑结构转变成可在计算机中存储和运算的形式，并可设计一定的存储结构满足计算机处理的需要。因此，计算机系统通常使用矩阵实现对图的表示和处理。本节着重介绍图的矩阵表示法，具体包括邻接矩阵表示法、关联矩阵表示法、邻接表表示法等几种类型。",图模型可以通过矩阵表示法进行表示，将图的逻辑结构转化为计算机可存储和运算的形式。
集合表示法,对比,图形表示法,,"如前所述，图模型其实就是一种特殊的二元关系。因此，图模型作为一种二元关系，一般来说具有三种基本的表示方法，即集合表示法、图形表示法和矩阵表示法。对于一个图模型G，若将其记为 $G=\langle V,E\rangle$ ，并枚举集合 $V$ 和 $E$ 中所有元素，则称这种表示方法为图的集合表示法。若画出$G$ 的图形，用小圆圈表示 $V$中的结点，用由 $u$ 指向 $v$ 的有向线段或曲线表示有向边 $\langle u,v\rangle$ ，无向线段或曲线表示无向边 $(\mathrm{u},\mathrm{v})$ ，则称该方法为图的图形表示法。  
![图8-8 图模型G的图形表示法 ](images/42c40d1dbd600657cf3b9d4593b6b7c38007adbf1cf3dec9952b6b75bb10d397.jpg)  
对于图8-8 所示的图$G$ ，可用集合为 $G=\langle V,E\rangle$ ，其顶点集 $V=\{v_{1},v_{2},v_{3},v_{4}\}$，其边集$E=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{2},v_{3}\rangle,\langle v_{2},v_{4}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$ 。 若用图形表示，则其本身就是图形表示。  
集合表示法比较精确，但抽象且不易理解；图形表示法形象直观，但是当图中的结点和边的数目较大时，这种表示法很不方便甚至不可行。事实上，可以通过矩阵将图模型的逻辑结构转变成可在计算机中存储和运算的形式，并可设计一定的存储结构满足计算机处理的需要。因此，计算机系统通常使用矩阵实现对图的表示和处理。本节着重介绍图的矩阵表示法，具体包括邻接矩阵表示法、关联矩阵表示法、邻接表表示法等几种类型。",集合表示法精确但抽象，图形表示法形象直观但不适于大规模图。
集合表示法,对比,矩阵表示法,,"如前所述，图模型其实就是一种特殊的二元关系。因此，图模型作为一种二元关系，一般来说具有三种基本的表示方法，即集合表示法、图形表示法和矩阵表示法。对于一个图模型G，若将其记为 $G=\langle V,E\rangle$ ，并枚举集合 $V$ 和 $E$ 中所有元素，则称这种表示方法为图的集合表示法。若画出$G$ 的图形，用小圆圈表示 $V$中的结点，用由 $u$ 指向 $v$ 的有向线段或曲线表示有向边 $\langle u,v\rangle$ ，无向线段或曲线表示无向边 $(\mathrm{u},\mathrm{v})$ ，则称该方法为图的图形表示法。  
![图8-8 图模型G的图形表示法 ](images/42c40d1dbd600657cf3b9d4593b6b7c38007adbf1cf3dec9952b6b75bb10d397.jpg)  
对于图8-8 所示的图$G$ ，可用集合为 $G=\langle V,E\rangle$ ，其顶点集 $V=\{v_{1},v_{2},v_{3},v_{4}\}$，其边集$E=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{2},v_{3}\rangle,\langle v_{2},v_{4}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$ 。 若用图形表示，则其本身就是图形表示。  
集合表示法比较精确，但抽象且不易理解；图形表示法形象直观，但是当图中的结点和边的数目较大时，这种表示法很不方便甚至不可行。事实上，可以通过矩阵将图模型的逻辑结构转变成可在计算机中存储和运算的形式，并可设计一定的存储结构满足计算机处理的需要。因此，计算机系统通常使用矩阵实现对图的表示和处理。本节着重介绍图的矩阵表示法，具体包括邻接矩阵表示法、关联矩阵表示法、邻接表表示法等几种类型。",集合表示法精确但抽象，矩阵表示法适用于计算机存储和处理。
图形表示法,对比,矩阵表示法,,"如前所述，图模型其实就是一种特殊的二元关系。因此，图模型作为一种二元关系，一般来说具有三种基本的表示方法，即集合表示法、图形表示法和矩阵表示法。对于一个图模型G，若将其记为 $G=\langle V,E\rangle$ ，并枚举集合 $V$ 和 $E$ 中所有元素，则称这种表示方法为图的集合表示法。若画出$G$ 的图形，用小圆圈表示 $V$中的结点，用由 $u$ 指向 $v$ 的有向线段或曲线表示有向边 $\langle u,v\rangle$ ，无向线段或曲线表示无向边 $(\mathrm{u},\mathrm{v})$ ，则称该方法为图的图形表示法。  
![图8-8 图模型G的图形表示法 ](images/42c40d1dbd600657cf3b9d4593b6b7c38007adbf1cf3dec9952b6b75bb10d397.jpg)  
对于图8-8 所示的图$G$ ，可用集合为 $G=\langle V,E\rangle$ ，其顶点集 $V=\{v_{1},v_{2},v_{3},v_{4}\}$，其边集$E=\{\langle v_{1},v_{2}\rangle,\langle v_{1},v_{4}\rangle,\langle v_{2},v_{1}\rangle,\langle v_{2},v_{3}\rangle,\langle v_{2},v_{4}\rangle,\langle v_{3},v_{1}\rangle,\langle v_{4},v_{1}\rangle,\langle v_{4},v_{3}\rangle\}$ 。 若用图形表示，则其本身就是图形表示。  
集合表示法比较精确，但抽象且不易理解；图形表示法形象直观，但是当图中的结点和边的数目较大时，这种表示法很不方便甚至不可行。事实上，可以通过矩阵将图模型的逻辑结构转变成可在计算机中存储和运算的形式，并可设计一定的存储结构满足计算机处理的需要。因此，计算机系统通常使用矩阵实现对图的表示和处理。本节着重介绍图的矩阵表示法，具体包括邻接矩阵表示法、关联矩阵表示法、邻接表表示法等几种类型。",图形表示法形象直观但不适于大规模图，矩阵表示法适用于计算机存储和处理。
邻接矩阵,包含,无向图邻接矩阵,,"邻接矩阵是表示图结点间邻接关系的矩阵，即表示图模型中的各个结点之间是否有边的联结关系的关系矩阵。邻接矩阵的具体定义如下：  
【定义8.7】设$G=\langle V,E\rangle$是任一给定的图模型 ，其中结点集合$\ V=\{v_{1},v_{2},\ldots,v_{n}\}$，边集合$E=\{e_{1},e_{2},\dots,e_{m}\}$。称 $n$ 阶方阵 $A_{G}=(a_{i j})_{n\times n}$为图 $G$ 的邻接矩阵，如果矩阵元素 $a_{i j}$ 表示图中结点$v_{i}$ 和 $v_{j}$ 之间是否有边相连：若有则$a_{i j}$为边数$k$，否则$a_{i j}=0$。即有：  
$$
a_{i j}={\left\{\begin{array}{l l}{k,}&{{\mathbb{若}}(v_{i},v_{j}){\in}E{\mathbb{或}}\langle v_{i},v_{j}\rangle{\in}E}\\ {0,}&{{\mathbb{否则}}}\end{array}\right.}\quad\quad\quad\quad(i,j=1,2,3,\cdots,n)
$$ {      }  
从上述定义可以看出，如果图$G=\langle V,E\rangle$是一个线图，则其邻接矩阵为布尔矩阵。此外，需要注意的是，要确定一个图的邻接矩阵，首先必须对图中的所有结点进行编号，邻接矩阵的表示与结点编号的次序紧密相关，不同的结点编号对应于不同的邻接矩阵，结点编号次序的交换对应于邻接矩阵行列的交换。  
图8-8 所示有向图 $G$ 在 $v_{1},v_{2},v_{3},v_{4}$的结点次序下的邻接矩阵为：  
$$
\begin{gathered}v_{1}\quad v_{2}\quad v_{3}\quad v_{4}\\A_{G}=(a_{ij})_{n\times n}=\begin{matrix}v_{2}\\v_{3}\\v_{4}\end{matrix}\begin{pmatrix}0&1&0&1\\1&0&1&1\\1&0&0&0\\0&0&1&0\end{pmatrix}.\end{gathered}
$$  
事实上，无向图和有向图的关联矩阵有一些差异。例如，无向图的每条边不带方向，或理解为每条边同时具有两个方向，故其表示的二元关系具有对称性。因此，关系矩阵或者说图的关联矩阵是一个对称矩阵。对于有向图，其表示的二元关系不一定具有对称性，故其关联矩阵不一定是对称矩阵。因此，通常分别讨论无向图和有向图的邻接矩阵。",邻接矩阵包含无向图邻接矩阵，无向图邻接矩阵是邻接矩阵的一种特殊形式，具有对称性
邻接矩阵,包含,有向图邻接矩阵,,"邻接矩阵是表示图结点间邻接关系的矩阵，即表示图模型中的各个结点之间是否有边的联结关系的关系矩阵。邻接矩阵的具体定义如下：  
【定义8.7】设$G=\langle V,E\rangle$是任一给定的图模型 ，其中结点集合$\ V=\{v_{1},v_{2},\ldots,v_{n}\}$，边集合$E=\{e_{1},e_{2},\dots,e_{m}\}$。称 $n$ 阶方阵 $A_{G}=(a_{i j})_{n\times n}$为图 $G$ 的邻接矩阵，如果矩阵元素 $a_{i j}$ 表示图中结点$v_{i}$ 和 $v_{j}$ 之间是否有边相连：若有则$a_{i j}$为边数$k$，否则$a_{i j}=0$。即有：  
$$
a_{i j}={\left\{\begin{array}{l l}{k,}&{{\mathbb{若}}(v_{i},v_{j}){\in}E{\mathbb{或}}\langle v_{i},v_{j}\rangle{\in}E}\\ {0,}&{{\mathbb{否则}}}\end{array}\right.}\quad\quad\quad\quad(i,j=1,2,3,\cdots,n)
$$ {      }  
从上述定义可以看出，如果图$G=\langle V,E\rangle$是一个线图，则其邻接矩阵为布尔矩阵。此外，需要注意的是，要确定一个图的邻接矩阵，首先必须对图中的所有结点进行编号，邻接矩阵的表示与结点编号的次序紧密相关，不同的结点编号对应于不同的邻接矩阵，结点编号次序的交换对应于邻接矩阵行列的交换。  
图8-8 所示有向图 $G$ 在 $v_{1},v_{2},v_{3},v_{4}$的结点次序下的邻接矩阵为：  
$$
\begin{gathered}v_{1}\quad v_{2}\quad v_{3}\quad v_{4}\\A_{G}=(a_{ij})_{n\times n}=\begin{matrix}v_{2}\\v_{3}\\v_{4}\end{matrix}\begin{pmatrix}0&1&0&1\\1&0&1&1\\1&0&0&0\\0&0&1&0\end{pmatrix}.\end{gathered}
$$  
事实上，无向图和有向图的关联矩阵有一些差异。例如，无向图的每条边不带方向，或理解为每条边同时具有两个方向，故其表示的二元关系具有对称性。因此，关系矩阵或者说图的关联矩阵是一个对称矩阵。对于有向图，其表示的二元关系不一定具有对称性，故其关联矩阵不一定是对称矩阵。因此，通常分别讨论无向图和有向图的邻接矩阵。",邻接矩阵包含有向图邻接矩阵，有向图邻接矩阵是邻接矩阵的一种特殊形式，不一定具有对称性
无向图邻接矩阵,区别,有向图邻接矩阵,,"邻接矩阵是表示图结点间邻接关系的矩阵，即表示图模型中的各个结点之间是否有边的联结关系的关系矩阵。邻接矩阵的具体定义如下：  
【定义8.7】设$G=\langle V,E\rangle$是任一给定的图模型 ，其中结点集合$\ V=\{v_{1},v_{2},\ldots,v_{n}\}$，边集合$E=\{e_{1},e_{2},\dots,e_{m}\}$。称 $n$ 阶方阵 $A_{G}=(a_{i j})_{n\times n}$为图 $G$ 的邻接矩阵，如果矩阵元素 $a_{i j}$ 表示图中结点$v_{i}$ 和 $v_{j}$ 之间是否有边相连：若有则$a_{i j}$为边数$k$，否则$a_{i j}=0$。即有：  
$$
a_{i j}={\left\{\begin{array}{l l}{k,}&{{\mathbb{若}}(v_{i},v_{j}){\in}E{\mathbb{或}}\langle v_{i},v_{j}\rangle{\in}E}\\ {0,}&{{\mathbb{否则}}}\end{array}\right.}\quad\quad\quad\quad(i,j=1,2,3,\cdots,n)
$$ {      }  
从上述定义可以看出，如果图$G=\langle V,E\rangle$是一个线图，则其邻接矩阵为布尔矩阵。此外，需要注意的是，要确定一个图的邻接矩阵，首先必须对图中的所有结点进行编号，邻接矩阵的表示与结点编号的次序紧密相关，不同的结点编号对应于不同的邻接矩阵，结点编号次序的交换对应于邻接矩阵行列的交换。  
图8-8 所示有向图 $G$ 在 $v_{1},v_{2},v_{3},v_{4}$的结点次序下的邻接矩阵为：  
$$
\begin{gathered}v_{1}\quad v_{2}\quad v_{3}\quad v_{4}\\A_{G}=(a_{ij})_{n\times n}=\begin{matrix}v_{2}\\v_{3}\\v_{4}\end{matrix}\begin{pmatrix}0&1&0&1\\1&0&1&1\\1&0&0&0\\0&0&1&0\end{pmatrix}.\end{gathered}
$$  
事实上，无向图和有向图的关联矩阵有一些差异。例如，无向图的每条边不带方向，或理解为每条边同时具有两个方向，故其表示的二元关系具有对称性。因此，关系矩阵或者说图的关联矩阵是一个对称矩阵。对于有向图，其表示的二元关系不一定具有对称性，故其关联矩阵不一定是对称矩阵。因此，通常分别讨论无向图和有向图的邻接矩阵。",无向图邻接矩阵具有对称性，而有向图邻接矩阵不一定具有对称性
图的概念,包含,图的表示方法,,"除了邻接矩阵外，还可以用关联矩阵表示图。关联矩阵主要表示图中每个结点与每条边之间的相关关系。对于任意给定的一个图模型$G$，其关联矩阵$M(G)$中元素$m_{i j}$的含义是图中结点$v_{i}$是否关联边$e_{j}$，如果$v_{i}$不关联$e_{j}$，则$m_{i j}=0$，如果$v_{i}$关联$e_{j}$，则用某个非零数字表示$m_{i j}$，具体数字依据图模型的类型和点边关联方式确定。  
与邻接矩阵一样，要确定一个图的关联矩阵，首先应对图中的所有结点进行编号，不同的结点编号对应于不同的关联矩阵，结点编号次序的交换对应于关联矩阵中行的交换。  
首先给出无向图关联矩阵的定义：  
【定义8.8】设$G=\langle V,E\rangle$是无向图 ，其中$\ V=\{v_{1},v_{2},\ldots,v_{n}\}$，$E=\{e_{1},e_{2},\dots,e_{m}\}$ ，则将$n\times m$阶矩阵$(m_{i j})_{n\times m}$称为 $G$ 的关联矩阵，记为 $M(G)$ 。其中元素$m_{i j}$ 表示图中结点 $v_{i}$ 与边 $e_{j}$ 的关联次数，具体定义如下：
$$
m_{ij}=\begin{cases}2,v_i的自环是e_j\\[2ex]1,v_i关联e_j且e_j不是自环\\[2ex]0,v_{i}不关联e_{j}\end{cases}
(i=1,2,\cdots,n,\quad j=1,\:2,\:...,\:m)(8-2)
$$  
从上述定义可以看出，无向图的关联矩阵用数字2 表示结点与边的自环关系，因为自环须与其关联结点关联 2  次。  
下面给出有向图关联矩阵的定义：  
【定义8.9】设 $D=\langle V,E\rangle$是有向图，其中 $V=\{v_{1},v_{2},\ldots,v_{n}\}$ ，$E=\{e_{1},e_{2},\dots,e_{m}\}$ ，则将${}n\times m$阶矩阵$(m_{i j})_{n\times m}$称为有向图 $D$ 的关联矩阵，记作 $M(D)$ 。 其中元素 $m_{i j}$ 表示图中结点 $v_{i}$ 与边 $e_{j}$ 的关联情况，具体定义如下：  
$$
m_{ij}=\begin{cases}-2,&v_i\text{为其关联自环}e_j\text{的起点和终点}\\1,&v_i\text{为其关联边}e_j\text{的起点但不是终点}\\-1,&v_i\text{为其关联边}e_j\text{的终点但不是起点}\\0,&v_i\text{不关联边}e_j\end{cases}
$$  
从上述定义可以看出，有向图的关联矩阵用数字−2表示结点与边的自环关系。事实上，有时候也可以用2 表示。因为有向图的自环是有方向的，即顺时针或逆时针方向。习惯上，用正数表示逆时针方向，负数表示顺时针方向。图中的自环默认为顺时针方向，故一般用−2表示结点与边的自环关系。  
对于无向图及其关联矩阵，由于每条非自环边关联2 个结点，故矩阵中每列元素之和必为2。而对于有向图及其关联矩阵，由于每条非自环有向边关联2 个结点，且一个为起点一个为终点，故图中每个非自环边在关联矩阵中所对应列元素之和必为0。  
因此，可以通过分析关联矩阵的数据特征分析来分析图中结点与边之间的结构信息。例如，对于任意一个关联矩阵，如果某行元素全为零，当且仅当该行所对应的结点为孤立结点。 再如，如果第 $j$列与第 $k$列相同，当且仅当 $e_{j}$ 与 $e_{k}$ 是平行边，或者说重边对应的列完全相同。 后面将经常使用关联矩阵分析图模型的各种结构特征。",图的概念包含图的表示方法
图的表示方法,包含,关联矩阵表示法,,"除了邻接矩阵外，还可以用关联矩阵表示图。关联矩阵主要表示图中每个结点与每条边之间的相关关系。对于任意给定的一个图模型$G$，其关联矩阵$M(G)$中元素$m_{i j}$的含义是图中结点$v_{i}$是否关联边$e_{j}$，如果$v_{i}$不关联$e_{j}$，则$m_{i j}=0$，如果$v_{i}$关联$e_{j}$，则用某个非零数字表示$m_{i j}$，具体数字依据图模型的类型和点边关联方式确定。  
与邻接矩阵一样，要确定一个图的关联矩阵，首先应对图中的所有结点进行编号，不同的结点编号对应于不同的关联矩阵，结点编号次序的交换对应于关联矩阵中行的交换。  
首先给出无向图关联矩阵的定义：  
【定义8.8】设$G=\langle V,E\rangle$是无向图 ，其中$\ V=\{v_{1},v_{2},\ldots,v_{n}\}$，$E=\{e_{1},e_{2},\dots,e_{m}\}$ ，则将$n\times m$阶矩阵$(m_{i j})_{n\times m}$称为 $G$ 的关联矩阵，记为 $M(G)$ 。其中元素$m_{i j}$ 表示图中结点 $v_{i}$ 与边 $e_{j}$ 的关联次数，具体定义如下：
$$
m_{ij}=\begin{cases}2,v_i的自环是e_j\\[2ex]1,v_i关联e_j且e_j不是自环\\[2ex]0,v_{i}不关联e_{j}\end{cases}
(i=1,2,\cdots,n,\quad j=1,\:2,\:...,\:m)(8-2)
$$  
从上述定义可以看出，无向图的关联矩阵用数字2 表示结点与边的自环关系，因为自环须与其关联结点关联 2  次。  
下面给出有向图关联矩阵的定义：  
【定义8.9】设 $D=\langle V,E\rangle$是有向图，其中 $V=\{v_{1},v_{2},\ldots,v_{n}\}$ ，$E=\{e_{1},e_{2},\dots,e_{m}\}$ ，则将${}n\times m$阶矩阵$(m_{i j})_{n\times m}$称为有向图 $D$ 的关联矩阵，记作 $M(D)$ 。 其中元素 $m_{i j}$ 表示图中结点 $v_{i}$ 与边 $e_{j}$ 的关联情况，具体定义如下：  
$$
m_{ij}=\begin{cases}-2,&v_i\text{为其关联自环}e_j\text{的起点和终点}\\1,&v_i\text{为其关联边}e_j\text{的起点但不是终点}\\-1,&v_i\text{为其关联边}e_j\text{的终点但不是起点}\\0,&v_i\text{不关联边}e_j\end{cases}
$$  
从上述定义可以看出，有向图的关联矩阵用数字−2表示结点与边的自环关系。事实上，有时候也可以用2 表示。因为有向图的自环是有方向的，即顺时针或逆时针方向。习惯上，用正数表示逆时针方向，负数表示顺时针方向。图中的自环默认为顺时针方向，故一般用−2表示结点与边的自环关系。  
对于无向图及其关联矩阵，由于每条非自环边关联2 个结点，故矩阵中每列元素之和必为2。而对于有向图及其关联矩阵，由于每条非自环有向边关联2 个结点，且一个为起点一个为终点，故图中每个非自环边在关联矩阵中所对应列元素之和必为0。  
因此，可以通过分析关联矩阵的数据特征分析来分析图中结点与边之间的结构信息。例如，对于任意一个关联矩阵，如果某行元素全为零，当且仅当该行所对应的结点为孤立结点。 再如，如果第 $j$列与第 $k$列相同，当且仅当 $e_{j}$ 与 $e_{k}$ 是平行边，或者说重边对应的列完全相同。 后面将经常使用关联矩阵分析图模型的各种结构特征。",图的表示方法包含关联矩阵表示法
关联矩阵表示法,具体化,无向图关联矩阵,,"除了邻接矩阵外，还可以用关联矩阵表示图。关联矩阵主要表示图中每个结点与每条边之间的相关关系。对于任意给定的一个图模型$G$，其关联矩阵$M(G)$中元素$m_{i j}$的含义是图中结点$v_{i}$是否关联边$e_{j}$，如果$v_{i}$不关联$e_{j}$，则$m_{i j}=0$，如果$v_{i}$关联$e_{j}$，则用某个非零数字表示$m_{i j}$，具体数字依据图模型的类型和点边关联方式确定。  
与邻接矩阵一样，要确定一个图的关联矩阵，首先应对图中的所有结点进行编号，不同的结点编号对应于不同的关联矩阵，结点编号次序的交换对应于关联矩阵中行的交换。  
首先给出无向图关联矩阵的定义：  
【定义8.8】设$G=\langle V,E\rangle$是无向图 ，其中$\ V=\{v_{1},v_{2},\ldots,v_{n}\}$，$E=\{e_{1},e_{2},\dots,e_{m}\}$ ，则将$n\times m$阶矩阵$(m_{i j})_{n\times m}$称为 $G$ 的关联矩阵，记为 $M(G)$ 。其中元素$m_{i j}$ 表示图中结点 $v_{i}$ 与边 $e_{j}$ 的关联次数，具体定义如下：
$$
m_{ij}=\begin{cases}2,v_i的自环是e_j\\[2ex]1,v_i关联e_j且e_j不是自环\\[2ex]0,v_{i}不关联e_{j}\end{cases}
(i=1,2,\cdots,n,\quad j=1,\:2,\:...,\:m)(8-2)
$$  
从上述定义可以看出，无向图的关联矩阵用数字2 表示结点与边的自环关系，因为自环须与其关联结点关联 2  次。  
下面给出有向图关联矩阵的定义：  
【定义8.9】设 $D=\langle V,E\rangle$是有向图，其中 $V=\{v_{1},v_{2},\ldots,v_{n}\}$ ，$E=\{e_{1},e_{2},\dots,e_{m}\}$ ，则将${}n\times m$阶矩阵$(m_{i j})_{n\times m}$称为有向图 $D$ 的关联矩阵，记作 $M(D)$ 。 其中元素 $m_{i j}$ 表示图中结点 $v_{i}$ 与边 $e_{j}$ 的关联情况，具体定义如下：  
$$
m_{ij}=\begin{cases}-2,&v_i\text{为其关联自环}e_j\text{的起点和终点}\\1,&v_i\text{为其关联边}e_j\text{的起点但不是终点}\\-1,&v_i\text{为其关联边}e_j\text{的终点但不是起点}\\0,&v_i\text{不关联边}e_j\end{cases}
$$  
从上述定义可以看出，有向图的关联矩阵用数字−2表示结点与边的自环关系。事实上，有时候也可以用2 表示。因为有向图的自环是有方向的，即顺时针或逆时针方向。习惯上，用正数表示逆时针方向，负数表示顺时针方向。图中的自环默认为顺时针方向，故一般用−2表示结点与边的自环关系。  
对于无向图及其关联矩阵，由于每条非自环边关联2 个结点，故矩阵中每列元素之和必为2。而对于有向图及其关联矩阵，由于每条非自环有向边关联2 个结点，且一个为起点一个为终点，故图中每个非自环边在关联矩阵中所对应列元素之和必为0。  
因此，可以通过分析关联矩阵的数据特征分析来分析图中结点与边之间的结构信息。例如，对于任意一个关联矩阵，如果某行元素全为零，当且仅当该行所对应的结点为孤立结点。 再如，如果第 $j$列与第 $k$列相同，当且仅当 $e_{j}$ 与 $e_{k}$ 是平行边，或者说重边对应的列完全相同。 后面将经常使用关联矩阵分析图模型的各种结构特征。",关联矩阵表示法具体化为无向图关联矩阵
关联矩阵表示法,具体化,有向图关联矩阵,,"除了邻接矩阵外，还可以用关联矩阵表示图。关联矩阵主要表示图中每个结点与每条边之间的相关关系。对于任意给定的一个图模型$G$，其关联矩阵$M(G)$中元素$m_{i j}$的含义是图中结点$v_{i}$是否关联边$e_{j}$，如果$v_{i}$不关联$e_{j}$，则$m_{i j}=0$，如果$v_{i}$关联$e_{j}$，则用某个非零数字表示$m_{i j}$，具体数字依据图模型的类型和点边关联方式确定。  
与邻接矩阵一样，要确定一个图的关联矩阵，首先应对图中的所有结点进行编号，不同的结点编号对应于不同的关联矩阵，结点编号次序的交换对应于关联矩阵中行的交换。  
首先给出无向图关联矩阵的定义：  
【定义8.8】设$G=\langle V,E\rangle$是无向图 ，其中$\ V=\{v_{1},v_{2},\ldots,v_{n}\}$，$E=\{e_{1},e_{2},\dots,e_{m}\}$ ，则将$n\times m$阶矩阵$(m_{i j})_{n\times m}$称为 $G$ 的关联矩阵，记为 $M(G)$ 。其中元素$m_{i j}$ 表示图中结点 $v_{i}$ 与边 $e_{j}$ 的关联次数，具体定义如下：
$$
m_{ij}=\begin{cases}2,v_i的自环是e_j\\[2ex]1,v_i关联e_j且e_j不是自环\\[2ex]0,v_{i}不关联e_{j}\end{cases}
(i=1,2,\cdots,n,\quad j=1,\:2,\:...,\:m)(8-2)
$$  
从上述定义可以看出，无向图的关联矩阵用数字2 表示结点与边的自环关系，因为自环须与其关联结点关联 2  次。  
下面给出有向图关联矩阵的定义：  
【定义8.9】设 $D=\langle V,E\rangle$是有向图，其中 $V=\{v_{1},v_{2},\ldots,v_{n}\}$ ，$E=\{e_{1},e_{2},\dots,e_{m}\}$ ，则将${}n\times m$阶矩阵$(m_{i j})_{n\times m}$称为有向图 $D$ 的关联矩阵，记作 $M(D)$ 。 其中元素 $m_{i j}$ 表示图中结点 $v_{i}$ 与边 $e_{j}$ 的关联情况，具体定义如下：  
$$
m_{ij}=\begin{cases}-2,&v_i\text{为其关联自环}e_j\text{的起点和终点}\\1,&v_i\text{为其关联边}e_j\text{的起点但不是终点}\\-1,&v_i\text{为其关联边}e_j\text{的终点但不是起点}\\0,&v_i\text{不关联边}e_j\end{cases}
$$  
从上述定义可以看出，有向图的关联矩阵用数字−2表示结点与边的自环关系。事实上，有时候也可以用2 表示。因为有向图的自环是有方向的，即顺时针或逆时针方向。习惯上，用正数表示逆时针方向，负数表示顺时针方向。图中的自环默认为顺时针方向，故一般用−2表示结点与边的自环关系。  
对于无向图及其关联矩阵，由于每条非自环边关联2 个结点，故矩阵中每列元素之和必为2。而对于有向图及其关联矩阵，由于每条非自环有向边关联2 个结点，且一个为起点一个为终点，故图中每个非自环边在关联矩阵中所对应列元素之和必为0。  
因此，可以通过分析关联矩阵的数据特征分析来分析图中结点与边之间的结构信息。例如，对于任意一个关联矩阵，如果某行元素全为零，当且仅当该行所对应的结点为孤立结点。 再如，如果第 $j$列与第 $k$列相同，当且仅当 $e_{j}$ 与 $e_{k}$ 是平行边，或者说重边对应的列完全相同。 后面将经常使用关联矩阵分析图模型的各种结构特征。",关联矩阵表示法具体化为有向图关联矩阵
无向图关联矩阵,对比,有向图关联矩阵,,"除了邻接矩阵外，还可以用关联矩阵表示图。关联矩阵主要表示图中每个结点与每条边之间的相关关系。对于任意给定的一个图模型$G$，其关联矩阵$M(G)$中元素$m_{i j}$的含义是图中结点$v_{i}$是否关联边$e_{j}$，如果$v_{i}$不关联$e_{j}$，则$m_{i j}=0$，如果$v_{i}$关联$e_{j}$，则用某个非零数字表示$m_{i j}$，具体数字依据图模型的类型和点边关联方式确定。  
与邻接矩阵一样，要确定一个图的关联矩阵，首先应对图中的所有结点进行编号，不同的结点编号对应于不同的关联矩阵，结点编号次序的交换对应于关联矩阵中行的交换。  
首先给出无向图关联矩阵的定义：  
【定义8.8】设$G=\langle V,E\rangle$是无向图 ，其中$\ V=\{v_{1},v_{2},\ldots,v_{n}\}$，$E=\{e_{1},e_{2},\dots,e_{m}\}$ ，则将$n\times m$阶矩阵$(m_{i j})_{n\times m}$称为 $G$ 的关联矩阵，记为 $M(G)$ 。其中元素$m_{i j}$ 表示图中结点 $v_{i}$ 与边 $e_{j}$ 的关联次数，具体定义如下：
$$
m_{ij}=\begin{cases}2,v_i的自环是e_j\\[2ex]1,v_i关联e_j且e_j不是自环\\[2ex]0,v_{i}不关联e_{j}\end{cases}
(i=1,2,\cdots,n,\quad j=1,\:2,\:...,\:m)(8-2)
$$  
从上述定义可以看出，无向图的关联矩阵用数字2 表示结点与边的自环关系，因为自环须与其关联结点关联 2  次。  
下面给出有向图关联矩阵的定义：  
【定义8.9】设 $D=\langle V,E\rangle$是有向图，其中 $V=\{v_{1},v_{2},\ldots,v_{n}\}$ ，$E=\{e_{1},e_{2},\dots,e_{m}\}$ ，则将${}n\times m$阶矩阵$(m_{i j})_{n\times m}$称为有向图 $D$ 的关联矩阵，记作 $M(D)$ 。 其中元素 $m_{i j}$ 表示图中结点 $v_{i}$ 与边 $e_{j}$ 的关联情况，具体定义如下：  
$$
m_{ij}=\begin{cases}-2,&v_i\text{为其关联自环}e_j\text{的起点和终点}\\1,&v_i\text{为其关联边}e_j\text{的起点但不是终点}\\-1,&v_i\text{为其关联边}e_j\text{的终点但不是起点}\\0,&v_i\text{不关联边}e_j\end{cases}
$$  
从上述定义可以看出，有向图的关联矩阵用数字−2表示结点与边的自环关系。事实上，有时候也可以用2 表示。因为有向图的自环是有方向的，即顺时针或逆时针方向。习惯上，用正数表示逆时针方向，负数表示顺时针方向。图中的自环默认为顺时针方向，故一般用−2表示结点与边的自环关系。  
对于无向图及其关联矩阵，由于每条非自环边关联2 个结点，故矩阵中每列元素之和必为2。而对于有向图及其关联矩阵，由于每条非自环有向边关联2 个结点，且一个为起点一个为终点，故图中每个非自环边在关联矩阵中所对应列元素之和必为0。  
因此，可以通过分析关联矩阵的数据特征分析来分析图中结点与边之间的结构信息。例如，对于任意一个关联矩阵，如果某行元素全为零，当且仅当该行所对应的结点为孤立结点。 再如，如果第 $j$列与第 $k$列相同，当且仅当 $e_{j}$ 与 $e_{k}$ 是平行边，或者说重边对应的列完全相同。 后面将经常使用关联矩阵分析图模型的各种结构特征。",无向图关联矩阵与有向图关联矩阵在元素定义和性质上存在对比
图的概念,适用性,图的表示方法,,"对于一个图模型$G=\langle V,E\rangle$，当图中的边数较多时，邻接矩阵和关联矩阵都是比较有效的表示方法。然而，当图$G$中的边数较少时，邻接矩阵和关联矩阵的的表示方法就比较浪费资源。此时，可采用邻接表的方法表示图模型。  
邻接表分别对图$G=\langle V,E\rangle$中每个结点$v_{i}$建立一个单链表。对于结点$v_{i}$的单链表，该表的第一个存储单元为表头，存放结点$v_{i}$的有关信息，表中其它存储单元存放与所有结点$v_{i}$相关联边的信息。因此，每个单链表中都存放着图的某个结点及与该结点相关联的所有边，表中各个存储单元通过指针进行串接。图$G$中所有结点的单链表就构成图$G$的邻接表，该表是由单链表的表头形成的顶点表和单链表其余结点形成的边表两部分组成。",图的概念通过不同的图的表示方法来具体实现，其中邻接矩阵和关联矩阵适用于边数较多的图，而邻接表表示法适用于边数较少的图
图的表示方法,包含,邻接表表示法,,"对于一个图模型$G=\langle V,E\rangle$，当图中的边数较多时，邻接矩阵和关联矩阵都是比较有效的表示方法。然而，当图$G$中的边数较少时，邻接矩阵和关联矩阵的的表示方法就比较浪费资源。此时，可采用邻接表的方法表示图模型。  
邻接表分别对图$G=\langle V,E\rangle$中每个结点$v_{i}$建立一个单链表。对于结点$v_{i}$的单链表，该表的第一个存储单元为表头，存放结点$v_{i}$的有关信息，表中其它存储单元存放与所有结点$v_{i}$相关联边的信息。因此，每个单链表中都存放着图的某个结点及与该结点相关联的所有边，表中各个存储单元通过指针进行串接。图$G$中所有结点的单链表就构成图$G$的邻接表，该表是由单链表的表头形成的顶点表和单链表其余结点形成的边表两部分组成。",邻接表表示法是图的表示方法之一，特别适用于边数较少的图
图的概念,实现方式,邻接表表示法,,"对于一个图模型$G=\langle V,E\rangle$，当图中的边数较多时，邻接矩阵和关联矩阵都是比较有效的表示方法。然而，当图$G$中的边数较少时，邻接矩阵和关联矩阵的的表示方法就比较浪费资源。此时，可采用邻接表的方法表示图模型。  
邻接表分别对图$G=\langle V,E\rangle$中每个结点$v_{i}$建立一个单链表。对于结点$v_{i}$的单链表，该表的第一个存储单元为表头，存放结点$v_{i}$的有关信息，表中其它存储单元存放与所有结点$v_{i}$相关联边的信息。因此，每个单链表中都存放着图的某个结点及与该结点相关联的所有边，表中各个存储单元通过指针进行串接。图$G$中所有结点的单链表就构成图$G$的邻接表，该表是由单链表的表头形成的顶点表和单链表其余结点形成的边表两部分组成。",图的概念可以通过邻接表表示法来实现，具体为每个结点建立一个单链表，存放结点及其相关联边的信息
图模型集合运算,基础与补充,图模型度结构性质,,本节在前述图模型基本概念基础上介绍关于图模型处理的基本知识和方法，包括图模型的集合运算、图模型的度结构性质、图同构的概念及判定方法。对于图模型，可对其定义一些相关运算与操作产生新的图模型并据此实现对问题的分析和求解。此外，结构性质是对图模型进行理解和处理的基本依据，图中结点与边之间显然存在一些基本约束，例如一条边关联且仅关联两个结点，这些约束使得图模型在结构上必须满足一定数量关系，如握手定理，它们构成了图模型最基本的结构性质。最后，本节通过图同构映射的机制考察和处理两个图模型之间在结构上等价关系，同构的图模型具有完全相同的结构性质。,图模型集合运算是对图模型进行操作的基础，而图模型度结构性质是对图模型进行理解和处理的基本依据，两者共同构成图模型处理的基本知识和方法。
图模型度结构性质,包含,握手定理,,本节在前述图模型基本概念基础上介绍关于图模型处理的基本知识和方法，包括图模型的集合运算、图模型的度结构性质、图同构的概念及判定方法。对于图模型，可对其定义一些相关运算与操作产生新的图模型并据此实现对问题的分析和求解。此外，结构性质是对图模型进行理解和处理的基本依据，图中结点与边之间显然存在一些基本约束，例如一条边关联且仅关联两个结点，这些约束使得图模型在结构上必须满足一定数量关系，如握手定理，它们构成了图模型最基本的结构性质。最后，本节通过图同构映射的机制考察和处理两个图模型之间在结构上等价关系，同构的图模型具有完全相同的结构性质。,握手定理是图模型度结构性质的一部分，体现了图模型在结构上必须满足的数量关系。
图同构,等价关系,图模型度结构性质,,本节在前述图模型基本概念基础上介绍关于图模型处理的基本知识和方法，包括图模型的集合运算、图模型的度结构性质、图同构的概念及判定方法。对于图模型，可对其定义一些相关运算与操作产生新的图模型并据此实现对问题的分析和求解。此外，结构性质是对图模型进行理解和处理的基本依据，图中结点与边之间显然存在一些基本约束，例如一条边关联且仅关联两个结点，这些约束使得图模型在结构上必须满足一定数量关系，如握手定理，它们构成了图模型最基本的结构性质。最后，本节通过图同构映射的机制考察和处理两个图模型之间在结构上等价关系，同构的图模型具有完全相同的结构性质。,图同构通过映射机制考察和处理两个图模型之间的结构等价关系，同构的图模型具有完全相同的度结构性质。
图运算,运算对象,图,,以图作为运算对象进行的运算称为图运算。在对图的实际应用中，可以根据图模型特点和问题求解的需要来定义各种图运算以产生新的图模型。本节主要介绍图的基本运算，具体包括图的集合运算、边点修改运算以及子图与补图运算等。,图运算是以图作为运算对象的运算
图运算,定义依据,图模型,,以图作为运算对象进行的运算称为图运算。在对图的实际应用中，可以根据图模型特点和问题求解的需要来定义各种图运算以产生新的图模型。本节主要介绍图的基本运算，具体包括图的集合运算、边点修改运算以及子图与补图运算等。,图运算可以根据图模型特点和问题求解需要来定义
图运算,包含,基本运算,,以图作为运算对象进行的运算称为图运算。在对图的实际应用中，可以根据图模型特点和问题求解的需要来定义各种图运算以产生新的图模型。本节主要介绍图的基本运算，具体包括图的集合运算、边点修改运算以及子图与补图运算等。,图运算包括图的集合运算、边点修改运算以及子图与补图运算等基本运算
图的集合运算,包含,并图,,"图模型作为一种特殊的集合具有并、交、差、补、环和等集合运算，下面分别介绍这些集合运算及其相关性质。 首先给出两个图不交、不重的定义：  
【定义8.10】假设 $G_{1}=\langle V_{1},E_{1}\rangle$和 $G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，则有：  
（1）如果 $V_{1}\cap V_{2}=\varnothing$，则称 $G_{1}$ 与 $G_{2}$ 是不交的；  
（2）如果 $E_{1}\cap E_{2}=\varnothing$ ，则称 $G_{1}$ 与 $G_{2}$ 是边不交的，或者说是不重的。  
显然，对于任意两个不交的图它们必然是不重的，反之不然。  
下面给出图模型基本集合运算的定义：  
【定义 8.11 】假设   $G_{1}=\langle V_{1},E_{1}\rangle$ 和   $G_{2}=\langle V_{2},E_{2}\rangle$ 分别为不含孤立结点的图模型（它们 同为无向图或者同为有向图）。  
（1）令图 $G_{1}\cup G_{2}=\left\langle V,E\right\rangle$，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的并图，其中：$V=V_{1}\cup V_{2},\;\;E=E_{1}\cup E_{2}$  
当 $G_{1}$ 与 $G_{2}$ 不存在公共的边时，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$  的不重并。  
（2）设图 $G_{1}\cap G_{2}=\langle V,E\rangle$，称 $G_{1}\cap G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的交图，其中：$V=V_{1}\cap V_{2},\,\,\,E=E_{1}\cap E_{2}$  
$G_{1}\cap G_{2}$是由 $G_{1},G_{2}$ 中所有公共的边组成的图。  
（3）设图 $G_{1}-G_{2}=\langle V,E\rangle$，称 $G_{1}-G_{2}$ 为 $G_{1}$ 减 $G_{2}$ 的差图，其中：
$$
V=V_{1},\,\,\,E=E_{1}-E_{2}
$$  
$G_{1}-G_{2}$ 是在图 $G_{1}$ 中减去属于 $G_{2}$ 的边后所剩余的部分组成的图。  
（4）环和图 $G_{1}\oplus G_{2}$ 是由 $G_{1}$ 与 $G_{2}$ 的并图减去 $G_{1}$ 与 $G_{2}$ 的交图后得到的图。
$$
G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})
$$  
从上述定义可以看出，图模型的并、交、差、环和等集合运算其实就是普通集合运算的延伸。 需要注意的是：  
（1）若   $G_{1}=G_{2}$   ，则 $G_{1}\cup G_{2}=G_{1}\cap G_{2}=G_{1}(G_{2}),~~~~~G_{1}-G_{2}=G_{2}-G_{1}=\varnothing\,。$  
（2）$G_{1}$ 与 $G_{2}$ 不重时，$G_{1}\cap G_{2}=\varnothing$，$G_{1}-G_{2}=G_{1}$，  $G_2-G_1=G_2, G_1\oplus G_2=G_1\cup $$G_{2}$。  
（3）两个图的环和可用并、差、交给出，$G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})\,.$",图的集合运算包含并图运算
图的集合运算,包含,交图,,"图模型作为一种特殊的集合具有并、交、差、补、环和等集合运算，下面分别介绍这些集合运算及其相关性质。 首先给出两个图不交、不重的定义：  
【定义8.10】假设 $G_{1}=\langle V_{1},E_{1}\rangle$和 $G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，则有：  
（1）如果 $V_{1}\cap V_{2}=\varnothing$，则称 $G_{1}$ 与 $G_{2}$ 是不交的；  
（2）如果 $E_{1}\cap E_{2}=\varnothing$ ，则称 $G_{1}$ 与 $G_{2}$ 是边不交的，或者说是不重的。  
显然，对于任意两个不交的图它们必然是不重的，反之不然。  
下面给出图模型基本集合运算的定义：  
【定义 8.11 】假设   $G_{1}=\langle V_{1},E_{1}\rangle$ 和   $G_{2}=\langle V_{2},E_{2}\rangle$ 分别为不含孤立结点的图模型（它们 同为无向图或者同为有向图）。  
（1）令图 $G_{1}\cup G_{2}=\left\langle V,E\right\rangle$，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的并图，其中：$V=V_{1}\cup V_{2},\;\;E=E_{1}\cup E_{2}$  
当 $G_{1}$ 与 $G_{2}$ 不存在公共的边时，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$  的不重并。  
（2）设图 $G_{1}\cap G_{2}=\langle V,E\rangle$，称 $G_{1}\cap G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的交图，其中：$V=V_{1}\cap V_{2},\,\,\,E=E_{1}\cap E_{2}$  
$G_{1}\cap G_{2}$是由 $G_{1},G_{2}$ 中所有公共的边组成的图。  
（3）设图 $G_{1}-G_{2}=\langle V,E\rangle$，称 $G_{1}-G_{2}$ 为 $G_{1}$ 减 $G_{2}$ 的差图，其中：
$$
V=V_{1},\,\,\,E=E_{1}-E_{2}
$$  
$G_{1}-G_{2}$ 是在图 $G_{1}$ 中减去属于 $G_{2}$ 的边后所剩余的部分组成的图。  
（4）环和图 $G_{1}\oplus G_{2}$ 是由 $G_{1}$ 与 $G_{2}$ 的并图减去 $G_{1}$ 与 $G_{2}$ 的交图后得到的图。
$$
G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})
$$  
从上述定义可以看出，图模型的并、交、差、环和等集合运算其实就是普通集合运算的延伸。 需要注意的是：  
（1）若   $G_{1}=G_{2}$   ，则 $G_{1}\cup G_{2}=G_{1}\cap G_{2}=G_{1}(G_{2}),~~~~~G_{1}-G_{2}=G_{2}-G_{1}=\varnothing\,。$  
（2）$G_{1}$ 与 $G_{2}$ 不重时，$G_{1}\cap G_{2}=\varnothing$，$G_{1}-G_{2}=G_{1}$，  $G_2-G_1=G_2, G_1\oplus G_2=G_1\cup $$G_{2}$。  
（3）两个图的环和可用并、差、交给出，$G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})\,.$",图的集合运算包含交图运算
图的集合运算,包含,差图,,"图模型作为一种特殊的集合具有并、交、差、补、环和等集合运算，下面分别介绍这些集合运算及其相关性质。 首先给出两个图不交、不重的定义：  
【定义8.10】假设 $G_{1}=\langle V_{1},E_{1}\rangle$和 $G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，则有：  
（1）如果 $V_{1}\cap V_{2}=\varnothing$，则称 $G_{1}$ 与 $G_{2}$ 是不交的；  
（2）如果 $E_{1}\cap E_{2}=\varnothing$ ，则称 $G_{1}$ 与 $G_{2}$ 是边不交的，或者说是不重的。  
显然，对于任意两个不交的图它们必然是不重的，反之不然。  
下面给出图模型基本集合运算的定义：  
【定义 8.11 】假设   $G_{1}=\langle V_{1},E_{1}\rangle$ 和   $G_{2}=\langle V_{2},E_{2}\rangle$ 分别为不含孤立结点的图模型（它们 同为无向图或者同为有向图）。  
（1）令图 $G_{1}\cup G_{2}=\left\langle V,E\right\rangle$，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的并图，其中：$V=V_{1}\cup V_{2},\;\;E=E_{1}\cup E_{2}$  
当 $G_{1}$ 与 $G_{2}$ 不存在公共的边时，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$  的不重并。  
（2）设图 $G_{1}\cap G_{2}=\langle V,E\rangle$，称 $G_{1}\cap G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的交图，其中：$V=V_{1}\cap V_{2},\,\,\,E=E_{1}\cap E_{2}$  
$G_{1}\cap G_{2}$是由 $G_{1},G_{2}$ 中所有公共的边组成的图。  
（3）设图 $G_{1}-G_{2}=\langle V,E\rangle$，称 $G_{1}-G_{2}$ 为 $G_{1}$ 减 $G_{2}$ 的差图，其中：
$$
V=V_{1},\,\,\,E=E_{1}-E_{2}
$$  
$G_{1}-G_{2}$ 是在图 $G_{1}$ 中减去属于 $G_{2}$ 的边后所剩余的部分组成的图。  
（4）环和图 $G_{1}\oplus G_{2}$ 是由 $G_{1}$ 与 $G_{2}$ 的并图减去 $G_{1}$ 与 $G_{2}$ 的交图后得到的图。
$$
G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})
$$  
从上述定义可以看出，图模型的并、交、差、环和等集合运算其实就是普通集合运算的延伸。 需要注意的是：  
（1）若   $G_{1}=G_{2}$   ，则 $G_{1}\cup G_{2}=G_{1}\cap G_{2}=G_{1}(G_{2}),~~~~~G_{1}-G_{2}=G_{2}-G_{1}=\varnothing\,。$  
（2）$G_{1}$ 与 $G_{2}$ 不重时，$G_{1}\cap G_{2}=\varnothing$，$G_{1}-G_{2}=G_{1}$，  $G_2-G_1=G_2, G_1\oplus G_2=G_1\cup $$G_{2}$。  
（3）两个图的环和可用并、差、交给出，$G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})\,.$",图的集合运算包含差图运算
图的集合运算,包含,环和图,,"图模型作为一种特殊的集合具有并、交、差、补、环和等集合运算，下面分别介绍这些集合运算及其相关性质。 首先给出两个图不交、不重的定义：  
【定义8.10】假设 $G_{1}=\langle V_{1},E_{1}\rangle$和 $G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，则有：  
（1）如果 $V_{1}\cap V_{2}=\varnothing$，则称 $G_{1}$ 与 $G_{2}$ 是不交的；  
（2）如果 $E_{1}\cap E_{2}=\varnothing$ ，则称 $G_{1}$ 与 $G_{2}$ 是边不交的，或者说是不重的。  
显然，对于任意两个不交的图它们必然是不重的，反之不然。  
下面给出图模型基本集合运算的定义：  
【定义 8.11 】假设   $G_{1}=\langle V_{1},E_{1}\rangle$ 和   $G_{2}=\langle V_{2},E_{2}\rangle$ 分别为不含孤立结点的图模型（它们 同为无向图或者同为有向图）。  
（1）令图 $G_{1}\cup G_{2}=\left\langle V,E\right\rangle$，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的并图，其中：$V=V_{1}\cup V_{2},\;\;E=E_{1}\cup E_{2}$  
当 $G_{1}$ 与 $G_{2}$ 不存在公共的边时，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$  的不重并。  
（2）设图 $G_{1}\cap G_{2}=\langle V,E\rangle$，称 $G_{1}\cap G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的交图，其中：$V=V_{1}\cap V_{2},\,\,\,E=E_{1}\cap E_{2}$  
$G_{1}\cap G_{2}$是由 $G_{1},G_{2}$ 中所有公共的边组成的图。  
（3）设图 $G_{1}-G_{2}=\langle V,E\rangle$，称 $G_{1}-G_{2}$ 为 $G_{1}$ 减 $G_{2}$ 的差图，其中：
$$
V=V_{1},\,\,\,E=E_{1}-E_{2}
$$  
$G_{1}-G_{2}$ 是在图 $G_{1}$ 中减去属于 $G_{2}$ 的边后所剩余的部分组成的图。  
（4）环和图 $G_{1}\oplus G_{2}$ 是由 $G_{1}$ 与 $G_{2}$ 的并图减去 $G_{1}$ 与 $G_{2}$ 的交图后得到的图。
$$
G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})
$$  
从上述定义可以看出，图模型的并、交、差、环和等集合运算其实就是普通集合运算的延伸。 需要注意的是：  
（1）若   $G_{1}=G_{2}$   ，则 $G_{1}\cup G_{2}=G_{1}\cap G_{2}=G_{1}(G_{2}),~~~~~G_{1}-G_{2}=G_{2}-G_{1}=\varnothing\,。$  
（2）$G_{1}$ 与 $G_{2}$ 不重时，$G_{1}\cap G_{2}=\varnothing$，$G_{1}-G_{2}=G_{1}$，  $G_2-G_1=G_2, G_1\oplus G_2=G_1\cup $$G_{2}$。  
（3）两个图的环和可用并、差、交给出，$G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})\,.$",图的集合运算包含环和图运算
不交的图,包含,边不交的图,,"图模型作为一种特殊的集合具有并、交、差、补、环和等集合运算，下面分别介绍这些集合运算及其相关性质。 首先给出两个图不交、不重的定义：  
【定义8.10】假设 $G_{1}=\langle V_{1},E_{1}\rangle$和 $G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，则有：  
（1）如果 $V_{1}\cap V_{2}=\varnothing$，则称 $G_{1}$ 与 $G_{2}$ 是不交的；  
（2）如果 $E_{1}\cap E_{2}=\varnothing$ ，则称 $G_{1}$ 与 $G_{2}$ 是边不交的，或者说是不重的。  
显然，对于任意两个不交的图它们必然是不重的，反之不然。  
下面给出图模型基本集合运算的定义：  
【定义 8.11 】假设   $G_{1}=\langle V_{1},E_{1}\rangle$ 和   $G_{2}=\langle V_{2},E_{2}\rangle$ 分别为不含孤立结点的图模型（它们 同为无向图或者同为有向图）。  
（1）令图 $G_{1}\cup G_{2}=\left\langle V,E\right\rangle$，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的并图，其中：$V=V_{1}\cup V_{2},\;\;E=E_{1}\cup E_{2}$  
当 $G_{1}$ 与 $G_{2}$ 不存在公共的边时，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$  的不重并。  
（2）设图 $G_{1}\cap G_{2}=\langle V,E\rangle$，称 $G_{1}\cap G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的交图，其中：$V=V_{1}\cap V_{2},\,\,\,E=E_{1}\cap E_{2}$  
$G_{1}\cap G_{2}$是由 $G_{1},G_{2}$ 中所有公共的边组成的图。  
（3）设图 $G_{1}-G_{2}=\langle V,E\rangle$，称 $G_{1}-G_{2}$ 为 $G_{1}$ 减 $G_{2}$ 的差图，其中：
$$
V=V_{1},\,\,\,E=E_{1}-E_{2}
$$  
$G_{1}-G_{2}$ 是在图 $G_{1}$ 中减去属于 $G_{2}$ 的边后所剩余的部分组成的图。  
（4）环和图 $G_{1}\oplus G_{2}$ 是由 $G_{1}$ 与 $G_{2}$ 的并图减去 $G_{1}$ 与 $G_{2}$ 的交图后得到的图。
$$
G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})
$$  
从上述定义可以看出，图模型的并、交、差、环和等集合运算其实就是普通集合运算的延伸。 需要注意的是：  
（1）若   $G_{1}=G_{2}$   ，则 $G_{1}\cup G_{2}=G_{1}\cap G_{2}=G_{1}(G_{2}),~~~~~G_{1}-G_{2}=G_{2}-G_{1}=\varnothing\,。$  
（2）$G_{1}$ 与 $G_{2}$ 不重时，$G_{1}\cap G_{2}=\varnothing$，$G_{1}-G_{2}=G_{1}$，  $G_2-G_1=G_2, G_1\oplus G_2=G_1\cup $$G_{2}$。  
（3）两个图的环和可用并、差、交给出，$G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})\,.$",不交的图必然是边不交的图
并图,条件,不交的图,,"图模型作为一种特殊的集合具有并、交、差、补、环和等集合运算，下面分别介绍这些集合运算及其相关性质。 首先给出两个图不交、不重的定义：  
【定义8.10】假设 $G_{1}=\langle V_{1},E_{1}\rangle$和 $G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，则有：  
（1）如果 $V_{1}\cap V_{2}=\varnothing$，则称 $G_{1}$ 与 $G_{2}$ 是不交的；  
（2）如果 $E_{1}\cap E_{2}=\varnothing$ ，则称 $G_{1}$ 与 $G_{2}$ 是边不交的，或者说是不重的。  
显然，对于任意两个不交的图它们必然是不重的，反之不然。  
下面给出图模型基本集合运算的定义：  
【定义 8.11 】假设   $G_{1}=\langle V_{1},E_{1}\rangle$ 和   $G_{2}=\langle V_{2},E_{2}\rangle$ 分别为不含孤立结点的图模型（它们 同为无向图或者同为有向图）。  
（1）令图 $G_{1}\cup G_{2}=\left\langle V,E\right\rangle$，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的并图，其中：$V=V_{1}\cup V_{2},\;\;E=E_{1}\cup E_{2}$  
当 $G_{1}$ 与 $G_{2}$ 不存在公共的边时，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$  的不重并。  
（2）设图 $G_{1}\cap G_{2}=\langle V,E\rangle$，称 $G_{1}\cap G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的交图，其中：$V=V_{1}\cap V_{2},\,\,\,E=E_{1}\cap E_{2}$  
$G_{1}\cap G_{2}$是由 $G_{1},G_{2}$ 中所有公共的边组成的图。  
（3）设图 $G_{1}-G_{2}=\langle V,E\rangle$，称 $G_{1}-G_{2}$ 为 $G_{1}$ 减 $G_{2}$ 的差图，其中：
$$
V=V_{1},\,\,\,E=E_{1}-E_{2}
$$  
$G_{1}-G_{2}$ 是在图 $G_{1}$ 中减去属于 $G_{2}$ 的边后所剩余的部分组成的图。  
（4）环和图 $G_{1}\oplus G_{2}$ 是由 $G_{1}$ 与 $G_{2}$ 的并图减去 $G_{1}$ 与 $G_{2}$ 的交图后得到的图。
$$
G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})
$$  
从上述定义可以看出，图模型的并、交、差、环和等集合运算其实就是普通集合运算的延伸。 需要注意的是：  
（1）若   $G_{1}=G_{2}$   ，则 $G_{1}\cup G_{2}=G_{1}\cap G_{2}=G_{1}(G_{2}),~~~~~G_{1}-G_{2}=G_{2}-G_{1}=\varnothing\,。$  
（2）$G_{1}$ 与 $G_{2}$ 不重时，$G_{1}\cap G_{2}=\varnothing$，$G_{1}-G_{2}=G_{1}$，  $G_2-G_1=G_2, G_1\oplus G_2=G_1\cup $$G_{2}$。  
（3）两个图的环和可用并、差、交给出，$G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})\,.$",当两个图不交时，它们的并图称为不重并
并图,条件,边不交的图,,"图模型作为一种特殊的集合具有并、交、差、补、环和等集合运算，下面分别介绍这些集合运算及其相关性质。 首先给出两个图不交、不重的定义：  
【定义8.10】假设 $G_{1}=\langle V_{1},E_{1}\rangle$和 $G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，则有：  
（1）如果 $V_{1}\cap V_{2}=\varnothing$，则称 $G_{1}$ 与 $G_{2}$ 是不交的；  
（2）如果 $E_{1}\cap E_{2}=\varnothing$ ，则称 $G_{1}$ 与 $G_{2}$ 是边不交的，或者说是不重的。  
显然，对于任意两个不交的图它们必然是不重的，反之不然。  
下面给出图模型基本集合运算的定义：  
【定义 8.11 】假设   $G_{1}=\langle V_{1},E_{1}\rangle$ 和   $G_{2}=\langle V_{2},E_{2}\rangle$ 分别为不含孤立结点的图模型（它们 同为无向图或者同为有向图）。  
（1）令图 $G_{1}\cup G_{2}=\left\langle V,E\right\rangle$，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的并图，其中：$V=V_{1}\cup V_{2},\;\;E=E_{1}\cup E_{2}$  
当 $G_{1}$ 与 $G_{2}$ 不存在公共的边时，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$  的不重并。  
（2）设图 $G_{1}\cap G_{2}=\langle V,E\rangle$，称 $G_{1}\cap G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的交图，其中：$V=V_{1}\cap V_{2},\,\,\,E=E_{1}\cap E_{2}$  
$G_{1}\cap G_{2}$是由 $G_{1},G_{2}$ 中所有公共的边组成的图。  
（3）设图 $G_{1}-G_{2}=\langle V,E\rangle$，称 $G_{1}-G_{2}$ 为 $G_{1}$ 减 $G_{2}$ 的差图，其中：
$$
V=V_{1},\,\,\,E=E_{1}-E_{2}
$$  
$G_{1}-G_{2}$ 是在图 $G_{1}$ 中减去属于 $G_{2}$ 的边后所剩余的部分组成的图。  
（4）环和图 $G_{1}\oplus G_{2}$ 是由 $G_{1}$ 与 $G_{2}$ 的并图减去 $G_{1}$ 与 $G_{2}$ 的交图后得到的图。
$$
G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})
$$  
从上述定义可以看出，图模型的并、交、差、环和等集合运算其实就是普通集合运算的延伸。 需要注意的是：  
（1）若   $G_{1}=G_{2}$   ，则 $G_{1}\cup G_{2}=G_{1}\cap G_{2}=G_{1}(G_{2}),~~~~~G_{1}-G_{2}=G_{2}-G_{1}=\varnothing\,。$  
（2）$G_{1}$ 与 $G_{2}$ 不重时，$G_{1}\cap G_{2}=\varnothing$，$G_{1}-G_{2}=G_{1}$，  $G_2-G_1=G_2, G_1\oplus G_2=G_1\cup $$G_{2}$。  
（3）两个图的环和可用并、差、交给出，$G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})\,.$",当两个图边不交时，它们的并图称为不重并
环和图,组成,并图,,"图模型作为一种特殊的集合具有并、交、差、补、环和等集合运算，下面分别介绍这些集合运算及其相关性质。 首先给出两个图不交、不重的定义：  
【定义8.10】假设 $G_{1}=\langle V_{1},E_{1}\rangle$和 $G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，则有：  
（1）如果 $V_{1}\cap V_{2}=\varnothing$，则称 $G_{1}$ 与 $G_{2}$ 是不交的；  
（2）如果 $E_{1}\cap E_{2}=\varnothing$ ，则称 $G_{1}$ 与 $G_{2}$ 是边不交的，或者说是不重的。  
显然，对于任意两个不交的图它们必然是不重的，反之不然。  
下面给出图模型基本集合运算的定义：  
【定义 8.11 】假设   $G_{1}=\langle V_{1},E_{1}\rangle$ 和   $G_{2}=\langle V_{2},E_{2}\rangle$ 分别为不含孤立结点的图模型（它们 同为无向图或者同为有向图）。  
（1）令图 $G_{1}\cup G_{2}=\left\langle V,E\right\rangle$，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的并图，其中：$V=V_{1}\cup V_{2},\;\;E=E_{1}\cup E_{2}$  
当 $G_{1}$ 与 $G_{2}$ 不存在公共的边时，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$  的不重并。  
（2）设图 $G_{1}\cap G_{2}=\langle V,E\rangle$，称 $G_{1}\cap G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的交图，其中：$V=V_{1}\cap V_{2},\,\,\,E=E_{1}\cap E_{2}$  
$G_{1}\cap G_{2}$是由 $G_{1},G_{2}$ 中所有公共的边组成的图。  
（3）设图 $G_{1}-G_{2}=\langle V,E\rangle$，称 $G_{1}-G_{2}$ 为 $G_{1}$ 减 $G_{2}$ 的差图，其中：
$$
V=V_{1},\,\,\,E=E_{1}-E_{2}
$$  
$G_{1}-G_{2}$ 是在图 $G_{1}$ 中减去属于 $G_{2}$ 的边后所剩余的部分组成的图。  
（4）环和图 $G_{1}\oplus G_{2}$ 是由 $G_{1}$ 与 $G_{2}$ 的并图减去 $G_{1}$ 与 $G_{2}$ 的交图后得到的图。
$$
G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})
$$  
从上述定义可以看出，图模型的并、交、差、环和等集合运算其实就是普通集合运算的延伸。 需要注意的是：  
（1）若   $G_{1}=G_{2}$   ，则 $G_{1}\cup G_{2}=G_{1}\cap G_{2}=G_{1}(G_{2}),~~~~~G_{1}-G_{2}=G_{2}-G_{1}=\varnothing\,。$  
（2）$G_{1}$ 与 $G_{2}$ 不重时，$G_{1}\cap G_{2}=\varnothing$，$G_{1}-G_{2}=G_{1}$，  $G_2-G_1=G_2, G_1\oplus G_2=G_1\cup $$G_{2}$。  
（3）两个图的环和可用并、差、交给出，$G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})\,.$",环和图由并图减去交图组成
环和图,组成,交图,,"图模型作为一种特殊的集合具有并、交、差、补、环和等集合运算，下面分别介绍这些集合运算及其相关性质。 首先给出两个图不交、不重的定义：  
【定义8.10】假设 $G_{1}=\langle V_{1},E_{1}\rangle$和 $G_{2}=\langle V_{2},E_{2}\rangle$是任意给定的两个图模型，则有：  
（1）如果 $V_{1}\cap V_{2}=\varnothing$，则称 $G_{1}$ 与 $G_{2}$ 是不交的；  
（2）如果 $E_{1}\cap E_{2}=\varnothing$ ，则称 $G_{1}$ 与 $G_{2}$ 是边不交的，或者说是不重的。  
显然，对于任意两个不交的图它们必然是不重的，反之不然。  
下面给出图模型基本集合运算的定义：  
【定义 8.11 】假设   $G_{1}=\langle V_{1},E_{1}\rangle$ 和   $G_{2}=\langle V_{2},E_{2}\rangle$ 分别为不含孤立结点的图模型（它们 同为无向图或者同为有向图）。  
（1）令图 $G_{1}\cup G_{2}=\left\langle V,E\right\rangle$，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的并图，其中：$V=V_{1}\cup V_{2},\;\;E=E_{1}\cup E_{2}$  
当 $G_{1}$ 与 $G_{2}$ 不存在公共的边时，称 $G_{1}\cup G_{2}$ 为 $G_{1}$ 与 $G_{2}$  的不重并。  
（2）设图 $G_{1}\cap G_{2}=\langle V,E\rangle$，称 $G_{1}\cap G_{2}$ 为 $G_{1}$ 与 $G_{2}$ 的交图，其中：$V=V_{1}\cap V_{2},\,\,\,E=E_{1}\cap E_{2}$  
$G_{1}\cap G_{2}$是由 $G_{1},G_{2}$ 中所有公共的边组成的图。  
（3）设图 $G_{1}-G_{2}=\langle V,E\rangle$，称 $G_{1}-G_{2}$ 为 $G_{1}$ 减 $G_{2}$ 的差图，其中：
$$
V=V_{1},\,\,\,E=E_{1}-E_{2}
$$  
$G_{1}-G_{2}$ 是在图 $G_{1}$ 中减去属于 $G_{2}$ 的边后所剩余的部分组成的图。  
（4）环和图 $G_{1}\oplus G_{2}$ 是由 $G_{1}$ 与 $G_{2}$ 的并图减去 $G_{1}$ 与 $G_{2}$ 的交图后得到的图。
$$
G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})
$$  
从上述定义可以看出，图模型的并、交、差、环和等集合运算其实就是普通集合运算的延伸。 需要注意的是：  
（1）若   $G_{1}=G_{2}$   ，则 $G_{1}\cup G_{2}=G_{1}\cap G_{2}=G_{1}(G_{2}),~~~~~G_{1}-G_{2}=G_{2}-G_{1}=\varnothing\,。$  
（2）$G_{1}$ 与 $G_{2}$ 不重时，$G_{1}\cap G_{2}=\varnothing$，$G_{1}-G_{2}=G_{1}$，  $G_2-G_1=G_2, G_1\oplus G_2=G_1\cup $$G_{2}$。  
（3）两个图的环和可用并、差、交给出，$G_{1}\oplus G_{2}=(G_{1}\cup G_{2})-(G_{1}\cap G_{2})\,.$",环和图由并图减去交图组成
图的基本运算,包含,加新边运算,,"对于一个给定的图模型，有时会根据实际问题的需要对图的结构进行化简或修改，主要是添加或者删除图中的某个或某些边、将图中两个结点进行合并、删除图中的某个或某些结点等，由此得到如下四个常用的图结构修改运算或操作，即：边的添加运算（也称为加新边运算）、边的删除运算、边的收缩运算以及结点的删除运算。其具体定义如下：  
【定义8.12】设图 $G=\langle V,E\rangle$是一个任意给定的图模型（有向图或无向图），则$G=\langle V,E\rangle$的四个常用图结构修改运算定义如下：  
（1）加新边运算：设$u,v$是 图$G=\langle V,E\rangle$的任意两个结点，即 $u,v\in V$，将这两个结点构成的边$e$边添加到图 $G$ 的边集$E$中构成一个新图$G^{\prime}=\langle V,E\cup\{e\}\rangle$。  
（2）边的删除运算：设$e$是图$G=\langle V,E\rangle$的任意一条边，即 $e\in E$ ，从 $G$ 中删除边 $e$ 得到一个新图$G^{\prime}=\langle V,E-\{e\}\rangle$，记为 $G-e$ ；又$E^{\prime}$是图$G$中若干边组成的集合，即$E^{\prime}\subseteq E$从 $G$ 中删除 $\mathrm{E^{\prime}}$中所有边得到一个新图$G^{\prime}=\langle V,E-E^{\prime}\rangle$，记为 $G-E^{\prime}$ 。  
（3）边的收缩运算：设$.e$是图$G=\langle V,E\rangle$的任意一条边且该边关联的两个结点为$u,v$，从图中删除边$e$并将该边的两个端点$u,v$合并成一个新的结点$w$，使得结点$w$关联除$e$以外的$u$和$v$所关联的一切边，得到一个新图$G^{\prime}$，记为$G\backslash{\mathbf{e}}$  
（4）结点的删除运算：设$_v$是 图$G=\langle V,E\rangle$的任意一个结点，即 $v\in V$，从 $G$ 中删除 $v$及与𝑣相关联的所有边，得到一个新图$G^{\prime}$，记为 $G-v$，又设 $V^{\prime}\subseteq V$ ，从 $G$ 中删除 $V^{\prime}$中所有顶点及与这些顶点关联的所有边，得到一个新图$G^{\prime}$，记为 $G-V^{\prime}$。  
从上述定义可以看出，要删除边，则直接在图中将改变去掉即可；要删除结点，在去掉该结点的同时，还要去掉该结点关联的所有边；边的收缩实际上就是将改变的长度变为0，使其两个端点重叠，用一个新的结点𝑤代替，其它边不变，即$w$关联该边的两个端点关联的除该边外的一切边，不过，需要注意的是，边的收缩可能会产生自环或平行边；所谓加新边运算，就是在图中的两个结点之间直接拉一条边。",加新边运算是图的基本运算之一
图的基本运算,包含,边的删除运算,,"对于一个给定的图模型，有时会根据实际问题的需要对图的结构进行化简或修改，主要是添加或者删除图中的某个或某些边、将图中两个结点进行合并、删除图中的某个或某些结点等，由此得到如下四个常用的图结构修改运算或操作，即：边的添加运算（也称为加新边运算）、边的删除运算、边的收缩运算以及结点的删除运算。其具体定义如下：  
【定义8.12】设图 $G=\langle V,E\rangle$是一个任意给定的图模型（有向图或无向图），则$G=\langle V,E\rangle$的四个常用图结构修改运算定义如下：  
（1）加新边运算：设$u,v$是 图$G=\langle V,E\rangle$的任意两个结点，即 $u,v\in V$，将这两个结点构成的边$e$边添加到图 $G$ 的边集$E$中构成一个新图$G^{\prime}=\langle V,E\cup\{e\}\rangle$。  
（2）边的删除运算：设$e$是图$G=\langle V,E\rangle$的任意一条边，即 $e\in E$ ，从 $G$ 中删除边 $e$ 得到一个新图$G^{\prime}=\langle V,E-\{e\}\rangle$，记为 $G-e$ ；又$E^{\prime}$是图$G$中若干边组成的集合，即$E^{\prime}\subseteq E$从 $G$ 中删除 $\mathrm{E^{\prime}}$中所有边得到一个新图$G^{\prime}=\langle V,E-E^{\prime}\rangle$，记为 $G-E^{\prime}$ 。  
（3）边的收缩运算：设$.e$是图$G=\langle V,E\rangle$的任意一条边且该边关联的两个结点为$u,v$，从图中删除边$e$并将该边的两个端点$u,v$合并成一个新的结点$w$，使得结点$w$关联除$e$以外的$u$和$v$所关联的一切边，得到一个新图$G^{\prime}$，记为$G\backslash{\mathbf{e}}$  
（4）结点的删除运算：设$_v$是 图$G=\langle V,E\rangle$的任意一个结点，即 $v\in V$，从 $G$ 中删除 $v$及与𝑣相关联的所有边，得到一个新图$G^{\prime}$，记为 $G-v$，又设 $V^{\prime}\subseteq V$ ，从 $G$ 中删除 $V^{\prime}$中所有顶点及与这些顶点关联的所有边，得到一个新图$G^{\prime}$，记为 $G-V^{\prime}$。  
从上述定义可以看出，要删除边，则直接在图中将改变去掉即可；要删除结点，在去掉该结点的同时，还要去掉该结点关联的所有边；边的收缩实际上就是将改变的长度变为0，使其两个端点重叠，用一个新的结点𝑤代替，其它边不变，即$w$关联该边的两个端点关联的除该边外的一切边，不过，需要注意的是，边的收缩可能会产生自环或平行边；所谓加新边运算，就是在图中的两个结点之间直接拉一条边。",边的删除运算是图的基本运算之一
图的基本运算,包含,边的收缩运算,,"对于一个给定的图模型，有时会根据实际问题的需要对图的结构进行化简或修改，主要是添加或者删除图中的某个或某些边、将图中两个结点进行合并、删除图中的某个或某些结点等，由此得到如下四个常用的图结构修改运算或操作，即：边的添加运算（也称为加新边运算）、边的删除运算、边的收缩运算以及结点的删除运算。其具体定义如下：  
【定义8.12】设图 $G=\langle V,E\rangle$是一个任意给定的图模型（有向图或无向图），则$G=\langle V,E\rangle$的四个常用图结构修改运算定义如下：  
（1）加新边运算：设$u,v$是 图$G=\langle V,E\rangle$的任意两个结点，即 $u,v\in V$，将这两个结点构成的边$e$边添加到图 $G$ 的边集$E$中构成一个新图$G^{\prime}=\langle V,E\cup\{e\}\rangle$。  
（2）边的删除运算：设$e$是图$G=\langle V,E\rangle$的任意一条边，即 $e\in E$ ，从 $G$ 中删除边 $e$ 得到一个新图$G^{\prime}=\langle V,E-\{e\}\rangle$，记为 $G-e$ ；又$E^{\prime}$是图$G$中若干边组成的集合，即$E^{\prime}\subseteq E$从 $G$ 中删除 $\mathrm{E^{\prime}}$中所有边得到一个新图$G^{\prime}=\langle V,E-E^{\prime}\rangle$，记为 $G-E^{\prime}$ 。  
（3）边的收缩运算：设$.e$是图$G=\langle V,E\rangle$的任意一条边且该边关联的两个结点为$u,v$，从图中删除边$e$并将该边的两个端点$u,v$合并成一个新的结点$w$，使得结点$w$关联除$e$以外的$u$和$v$所关联的一切边，得到一个新图$G^{\prime}$，记为$G\backslash{\mathbf{e}}$  
（4）结点的删除运算：设$_v$是 图$G=\langle V,E\rangle$的任意一个结点，即 $v\in V$，从 $G$ 中删除 $v$及与𝑣相关联的所有边，得到一个新图$G^{\prime}$，记为 $G-v$，又设 $V^{\prime}\subseteq V$ ，从 $G$ 中删除 $V^{\prime}$中所有顶点及与这些顶点关联的所有边，得到一个新图$G^{\prime}$，记为 $G-V^{\prime}$。  
从上述定义可以看出，要删除边，则直接在图中将改变去掉即可；要删除结点，在去掉该结点的同时，还要去掉该结点关联的所有边；边的收缩实际上就是将改变的长度变为0，使其两个端点重叠，用一个新的结点𝑤代替，其它边不变，即$w$关联该边的两个端点关联的除该边外的一切边，不过，需要注意的是，边的收缩可能会产生自环或平行边；所谓加新边运算，就是在图中的两个结点之间直接拉一条边。",边的收缩运算是图的基本运算之一
图的基本运算,包含,结点的删除运算,,"对于一个给定的图模型，有时会根据实际问题的需要对图的结构进行化简或修改，主要是添加或者删除图中的某个或某些边、将图中两个结点进行合并、删除图中的某个或某些结点等，由此得到如下四个常用的图结构修改运算或操作，即：边的添加运算（也称为加新边运算）、边的删除运算、边的收缩运算以及结点的删除运算。其具体定义如下：  
【定义8.12】设图 $G=\langle V,E\rangle$是一个任意给定的图模型（有向图或无向图），则$G=\langle V,E\rangle$的四个常用图结构修改运算定义如下：  
（1）加新边运算：设$u,v$是 图$G=\langle V,E\rangle$的任意两个结点，即 $u,v\in V$，将这两个结点构成的边$e$边添加到图 $G$ 的边集$E$中构成一个新图$G^{\prime}=\langle V,E\cup\{e\}\rangle$。  
（2）边的删除运算：设$e$是图$G=\langle V,E\rangle$的任意一条边，即 $e\in E$ ，从 $G$ 中删除边 $e$ 得到一个新图$G^{\prime}=\langle V,E-\{e\}\rangle$，记为 $G-e$ ；又$E^{\prime}$是图$G$中若干边组成的集合，即$E^{\prime}\subseteq E$从 $G$ 中删除 $\mathrm{E^{\prime}}$中所有边得到一个新图$G^{\prime}=\langle V,E-E^{\prime}\rangle$，记为 $G-E^{\prime}$ 。  
（3）边的收缩运算：设$.e$是图$G=\langle V,E\rangle$的任意一条边且该边关联的两个结点为$u,v$，从图中删除边$e$并将该边的两个端点$u,v$合并成一个新的结点$w$，使得结点$w$关联除$e$以外的$u$和$v$所关联的一切边，得到一个新图$G^{\prime}$，记为$G\backslash{\mathbf{e}}$  
（4）结点的删除运算：设$_v$是 图$G=\langle V,E\rangle$的任意一个结点，即 $v\in V$，从 $G$ 中删除 $v$及与𝑣相关联的所有边，得到一个新图$G^{\prime}$，记为 $G-v$，又设 $V^{\prime}\subseteq V$ ，从 $G$ 中删除 $V^{\prime}$中所有顶点及与这些顶点关联的所有边，得到一个新图$G^{\prime}$，记为 $G-V^{\prime}$。  
从上述定义可以看出，要删除边，则直接在图中将改变去掉即可；要删除结点，在去掉该结点的同时，还要去掉该结点关联的所有边；边的收缩实际上就是将改变的长度变为0，使其两个端点重叠，用一个新的结点𝑤代替，其它边不变，即$w$关联该边的两个端点关联的除该边外的一切边，不过，需要注意的是，边的收缩可能会产生自环或平行边；所谓加新边运算，就是在图中的两个结点之间直接拉一条边。",结点的删除运算是图的基本运算之一
子图,包含,导出子图,,"在使用图模型对实际问题建模和求解的过程中，经常需要分析考察图的某个特定部分的结构，将图中某个或某些特定的部分提取出来作为一个图模型进行研究，由此得到如下关于图模型的子图运算的若干概念，具体如下：  
【定义8.13】设 $G=\langle V,E\rangle$，$G^{\prime}=\langle V^{\prime},E^{\prime}\rangle$是两个图（同为无向图或者有向图），则有：  
（1）若 $V^{\prime}\subseteq V$且 $E^{\prime}\subseteq E$，则称 $G^{\prime}$是 $G$ 的子图，$G$ 是 $G^{\prime}$的母图，记为 $G^{\prime}\subseteq\mathbf{G}$ 。若 $G^{\prime}\subseteq\mathbf{G}$且 $G^{\prime}\neq{\bf G}$（即$V^{\prime}\subset V$或 $E^{\prime}\subset\mathbf{E})$），则称 $G^{\prime}$ 是 $G$ 的真子图；若 $G^{\prime}\subseteq G$且 $V^{\prime}=V$，则称 $G^{\prime}$是 $G$ 的生成子图。  
（2）设$V_{1}$是𝑉的非空子集，即 $\varnothing\neq V_{1}\subseteq V$，则以 $V_{1}$ 为结点集，以两个端点均在 $V_{1}$ 中的全体边为边集的 $G$ 的子图称为由$V_{1}$导出的导出子图，记为 $G[V_{1}]$。  
（3）设$E_{1}$是$E$的非空子集，设$\varnothing\neq E_{1}\subseteq E$，以 $E_{1}$为边集，以 $E_{1}$ 中所有边关联的全部结点为结点集的 $G$ 的子图成为由 $E_{1}$导出的导出子图，记为 $G[\ E_{1}]$。  
由上述定义可以看出，生成子图与其母图具有相同的结点集合。因此，一个图的生成子图一般是该图的主体结构。对于一个复杂的图模型，一般通过采用适当的方法构造其符合要求的生成子图实现对模型的化简和对问题的求解。  
不难看出，对于任一给定非空有限结点集合，由这些结点构成的零图和完全图分别表达了两个极端构图情形，两者之间具有互补性，相当于集合论中的空集和全集。 由此可以得到图模型补运算的概念。 首先给出如下关于完全图的定义：  
【定义8.14】假设$G=\langle V,E\rangle$是一个具有$\cdot_{n}$个结点的无向简单图，如果图中任意两个结点之间都有边相联结，则称该图为$^n$阶无向完全图，简称为完全图，记为$K_{n}$；假设$G=\langle V,E\rangle$是一个具有$\cdot_{n}$个结点的有向简单图，如果图中任意两个结点之间都有方向相反的两条边相联结，则称该图为$n$阶有向完全图，在不发生混淆的情况下也记为$K_{n}$。  
由上述定义可知，对于完全图来说，其邻接矩阵除主对角线上元素均为0 之外，其余元素均为1。显然，$n$阶无向完全图的边数为$n(n-1)/2$ ，$n$阶有向完全图的边数为$\ n(n-1)$。 图8-17 给出了无向完全图$K_{3}$，$K_{4}$，$K_{5}$和有向图$K_{3}$。  
下面给出图模型补运算的定义：  
【定义8.15】设 $G=\langle V,E\rangle$ 是 $n$ 阶简单图，以 $V$ 为顶点集，以所有能使 $G$ 成为完全图 $K_{n}$ 的新加边为边集的图称为 $G$ 相对于 $K_{n}$ 的补图，简称为 $G$ 的补图，记为$\bar{G}$。  
显然，若图$G$的邻接矩阵为$A_{G}=(a_{i j})_{n\times n}$，则其补图$\bar{G}$的邻接矩阵为$A_{\bar{G}}=(\bar{a}_{i j})_{n\times n}$为：  
$$
\\\bar{a}_{i j}=f(x)=\left\{\begin{array}{r l r}&{~~~~~~~~1-a_{i j},~i\neq j}&\\ &{0,~~~~~~~~~~~~~~~~~~i=j}&\end{array}\right.
$$  
例如，对于图8-18 所示的图 $G_{1}$和图 $G_{2}$，图 $G_{1}$ 是图 $G_{2}$ 的补图，图 $G_{2}$ 也是图 $G_{1}$的补图。显然， $K_{n}$ 的补图是 $n$ 阶零图，反之亦然。  
![图8-18 补图运算 ](images/bc253e401f30298f9209681ddc8b93ec627ca9bfb8d5b9c17929af79e1390112.jpg)",导出子图是子图的一种特殊形式，通过特定结点集或边集导出
子图,特殊关系,完全图,,"在使用图模型对实际问题建模和求解的过程中，经常需要分析考察图的某个特定部分的结构，将图中某个或某些特定的部分提取出来作为一个图模型进行研究，由此得到如下关于图模型的子图运算的若干概念，具体如下：  
【定义8.13】设 $G=\langle V,E\rangle$，$G^{\prime}=\langle V^{\prime},E^{\prime}\rangle$是两个图（同为无向图或者有向图），则有：  
（1）若 $V^{\prime}\subseteq V$且 $E^{\prime}\subseteq E$，则称 $G^{\prime}$是 $G$ 的子图，$G$ 是 $G^{\prime}$的母图，记为 $G^{\prime}\subseteq\mathbf{G}$ 。若 $G^{\prime}\subseteq\mathbf{G}$且 $G^{\prime}\neq{\bf G}$（即$V^{\prime}\subset V$或 $E^{\prime}\subset\mathbf{E})$），则称 $G^{\prime}$ 是 $G$ 的真子图；若 $G^{\prime}\subseteq G$且 $V^{\prime}=V$，则称 $G^{\prime}$是 $G$ 的生成子图。  
（2）设$V_{1}$是𝑉的非空子集，即 $\varnothing\neq V_{1}\subseteq V$，则以 $V_{1}$ 为结点集，以两个端点均在 $V_{1}$ 中的全体边为边集的 $G$ 的子图称为由$V_{1}$导出的导出子图，记为 $G[V_{1}]$。  
（3）设$E_{1}$是$E$的非空子集，设$\varnothing\neq E_{1}\subseteq E$，以 $E_{1}$为边集，以 $E_{1}$ 中所有边关联的全部结点为结点集的 $G$ 的子图成为由 $E_{1}$导出的导出子图，记为 $G[\ E_{1}]$。  
由上述定义可以看出，生成子图与其母图具有相同的结点集合。因此，一个图的生成子图一般是该图的主体结构。对于一个复杂的图模型，一般通过采用适当的方法构造其符合要求的生成子图实现对模型的化简和对问题的求解。  
不难看出，对于任一给定非空有限结点集合，由这些结点构成的零图和完全图分别表达了两个极端构图情形，两者之间具有互补性，相当于集合论中的空集和全集。 由此可以得到图模型补运算的概念。 首先给出如下关于完全图的定义：  
【定义8.14】假设$G=\langle V,E\rangle$是一个具有$\cdot_{n}$个结点的无向简单图，如果图中任意两个结点之间都有边相联结，则称该图为$^n$阶无向完全图，简称为完全图，记为$K_{n}$；假设$G=\langle V,E\rangle$是一个具有$\cdot_{n}$个结点的有向简单图，如果图中任意两个结点之间都有方向相反的两条边相联结，则称该图为$n$阶有向完全图，在不发生混淆的情况下也记为$K_{n}$。  
由上述定义可知，对于完全图来说，其邻接矩阵除主对角线上元素均为0 之外，其余元素均为1。显然，$n$阶无向完全图的边数为$n(n-1)/2$ ，$n$阶有向完全图的边数为$\ n(n-1)$。 图8-17 给出了无向完全图$K_{3}$，$K_{4}$，$K_{5}$和有向图$K_{3}$。  
下面给出图模型补运算的定义：  
【定义8.15】设 $G=\langle V,E\rangle$ 是 $n$ 阶简单图，以 $V$ 为顶点集，以所有能使 $G$ 成为完全图 $K_{n}$ 的新加边为边集的图称为 $G$ 相对于 $K_{n}$ 的补图，简称为 $G$ 的补图，记为$\bar{G}$。  
显然，若图$G$的邻接矩阵为$A_{G}=(a_{i j})_{n\times n}$，则其补图$\bar{G}$的邻接矩阵为$A_{\bar{G}}=(\bar{a}_{i j})_{n\times n}$为：  
$$
\\\bar{a}_{i j}=f(x)=\left\{\begin{array}{r l r}&{~~~~~~~~1-a_{i j},~i\neq j}&\\ &{0,~~~~~~~~~~~~~~~~~~i=j}&\end{array}\right.
$$  
例如，对于图8-18 所示的图 $G_{1}$和图 $G_{2}$，图 $G_{1}$ 是图 $G_{2}$ 的补图，图 $G_{2}$ 也是图 $G_{1}$的补图。显然， $K_{n}$ 的补图是 $n$ 阶零图，反之亦然。  
![图8-18 补图运算 ](images/bc253e401f30298f9209681ddc8b93ec627ca9bfb8d5b9c17929af79e1390112.jpg)",完全图可以被视为特定条件下的子图，即包含所有可能的边
子图,互补,补图,,"在使用图模型对实际问题建模和求解的过程中，经常需要分析考察图的某个特定部分的结构，将图中某个或某些特定的部分提取出来作为一个图模型进行研究，由此得到如下关于图模型的子图运算的若干概念，具体如下：  
【定义8.13】设 $G=\langle V,E\rangle$，$G^{\prime}=\langle V^{\prime},E^{\prime}\rangle$是两个图（同为无向图或者有向图），则有：  
（1）若 $V^{\prime}\subseteq V$且 $E^{\prime}\subseteq E$，则称 $G^{\prime}$是 $G$ 的子图，$G$ 是 $G^{\prime}$的母图，记为 $G^{\prime}\subseteq\mathbf{G}$ 。若 $G^{\prime}\subseteq\mathbf{G}$且 $G^{\prime}\neq{\bf G}$（即$V^{\prime}\subset V$或 $E^{\prime}\subset\mathbf{E})$），则称 $G^{\prime}$ 是 $G$ 的真子图；若 $G^{\prime}\subseteq G$且 $V^{\prime}=V$，则称 $G^{\prime}$是 $G$ 的生成子图。  
（2）设$V_{1}$是𝑉的非空子集，即 $\varnothing\neq V_{1}\subseteq V$，则以 $V_{1}$ 为结点集，以两个端点均在 $V_{1}$ 中的全体边为边集的 $G$ 的子图称为由$V_{1}$导出的导出子图，记为 $G[V_{1}]$。  
（3）设$E_{1}$是$E$的非空子集，设$\varnothing\neq E_{1}\subseteq E$，以 $E_{1}$为边集，以 $E_{1}$ 中所有边关联的全部结点为结点集的 $G$ 的子图成为由 $E_{1}$导出的导出子图，记为 $G[\ E_{1}]$。  
由上述定义可以看出，生成子图与其母图具有相同的结点集合。因此，一个图的生成子图一般是该图的主体结构。对于一个复杂的图模型，一般通过采用适当的方法构造其符合要求的生成子图实现对模型的化简和对问题的求解。  
不难看出，对于任一给定非空有限结点集合，由这些结点构成的零图和完全图分别表达了两个极端构图情形，两者之间具有互补性，相当于集合论中的空集和全集。 由此可以得到图模型补运算的概念。 首先给出如下关于完全图的定义：  
【定义8.14】假设$G=\langle V,E\rangle$是一个具有$\cdot_{n}$个结点的无向简单图，如果图中任意两个结点之间都有边相联结，则称该图为$^n$阶无向完全图，简称为完全图，记为$K_{n}$；假设$G=\langle V,E\rangle$是一个具有$\cdot_{n}$个结点的有向简单图，如果图中任意两个结点之间都有方向相反的两条边相联结，则称该图为$n$阶有向完全图，在不发生混淆的情况下也记为$K_{n}$。  
由上述定义可知，对于完全图来说，其邻接矩阵除主对角线上元素均为0 之外，其余元素均为1。显然，$n$阶无向完全图的边数为$n(n-1)/2$ ，$n$阶有向完全图的边数为$\ n(n-1)$。 图8-17 给出了无向完全图$K_{3}$，$K_{4}$，$K_{5}$和有向图$K_{3}$。  
下面给出图模型补运算的定义：  
【定义8.15】设 $G=\langle V,E\rangle$ 是 $n$ 阶简单图，以 $V$ 为顶点集，以所有能使 $G$ 成为完全图 $K_{n}$ 的新加边为边集的图称为 $G$ 相对于 $K_{n}$ 的补图，简称为 $G$ 的补图，记为$\bar{G}$。  
显然，若图$G$的邻接矩阵为$A_{G}=(a_{i j})_{n\times n}$，则其补图$\bar{G}$的邻接矩阵为$A_{\bar{G}}=(\bar{a}_{i j})_{n\times n}$为：  
$$
\\\bar{a}_{i j}=f(x)=\left\{\begin{array}{r l r}&{~~~~~~~~1-a_{i j},~i\neq j}&\\ &{0,~~~~~~~~~~~~~~~~~~i=j}&\end{array}\right.
$$  
例如，对于图8-18 所示的图 $G_{1}$和图 $G_{2}$，图 $G_{1}$ 是图 $G_{2}$ 的补图，图 $G_{2}$ 也是图 $G_{1}$的补图。显然， $K_{n}$ 的补图是 $n$ 阶零图，反之亦然。  
![图8-18 补图运算 ](images/bc253e401f30298f9209681ddc8b93ec627ca9bfb8d5b9c17929af79e1390112.jpg)",补图与原图的子图之间存在互补关系，补图包含原图中不存在的边
导出子图,特殊关系,完全图,,"在使用图模型对实际问题建模和求解的过程中，经常需要分析考察图的某个特定部分的结构，将图中某个或某些特定的部分提取出来作为一个图模型进行研究，由此得到如下关于图模型的子图运算的若干概念，具体如下：  
【定义8.13】设 $G=\langle V,E\rangle$，$G^{\prime}=\langle V^{\prime},E^{\prime}\rangle$是两个图（同为无向图或者有向图），则有：  
（1）若 $V^{\prime}\subseteq V$且 $E^{\prime}\subseteq E$，则称 $G^{\prime}$是 $G$ 的子图，$G$ 是 $G^{\prime}$的母图，记为 $G^{\prime}\subseteq\mathbf{G}$ 。若 $G^{\prime}\subseteq\mathbf{G}$且 $G^{\prime}\neq{\bf G}$（即$V^{\prime}\subset V$或 $E^{\prime}\subset\mathbf{E})$），则称 $G^{\prime}$ 是 $G$ 的真子图；若 $G^{\prime}\subseteq G$且 $V^{\prime}=V$，则称 $G^{\prime}$是 $G$ 的生成子图。  
（2）设$V_{1}$是𝑉的非空子集，即 $\varnothing\neq V_{1}\subseteq V$，则以 $V_{1}$ 为结点集，以两个端点均在 $V_{1}$ 中的全体边为边集的 $G$ 的子图称为由$V_{1}$导出的导出子图，记为 $G[V_{1}]$。  
（3）设$E_{1}$是$E$的非空子集，设$\varnothing\neq E_{1}\subseteq E$，以 $E_{1}$为边集，以 $E_{1}$ 中所有边关联的全部结点为结点集的 $G$ 的子图成为由 $E_{1}$导出的导出子图，记为 $G[\ E_{1}]$。  
由上述定义可以看出，生成子图与其母图具有相同的结点集合。因此，一个图的生成子图一般是该图的主体结构。对于一个复杂的图模型，一般通过采用适当的方法构造其符合要求的生成子图实现对模型的化简和对问题的求解。  
不难看出，对于任一给定非空有限结点集合，由这些结点构成的零图和完全图分别表达了两个极端构图情形，两者之间具有互补性，相当于集合论中的空集和全集。 由此可以得到图模型补运算的概念。 首先给出如下关于完全图的定义：  
【定义8.14】假设$G=\langle V,E\rangle$是一个具有$\cdot_{n}$个结点的无向简单图，如果图中任意两个结点之间都有边相联结，则称该图为$^n$阶无向完全图，简称为完全图，记为$K_{n}$；假设$G=\langle V,E\rangle$是一个具有$\cdot_{n}$个结点的有向简单图，如果图中任意两个结点之间都有方向相反的两条边相联结，则称该图为$n$阶有向完全图，在不发生混淆的情况下也记为$K_{n}$。  
由上述定义可知，对于完全图来说，其邻接矩阵除主对角线上元素均为0 之外，其余元素均为1。显然，$n$阶无向完全图的边数为$n(n-1)/2$ ，$n$阶有向完全图的边数为$\ n(n-1)$。 图8-17 给出了无向完全图$K_{3}$，$K_{4}$，$K_{5}$和有向图$K_{3}$。  
下面给出图模型补运算的定义：  
【定义8.15】设 $G=\langle V,E\rangle$ 是 $n$ 阶简单图，以 $V$ 为顶点集，以所有能使 $G$ 成为完全图 $K_{n}$ 的新加边为边集的图称为 $G$ 相对于 $K_{n}$ 的补图，简称为 $G$ 的补图，记为$\bar{G}$。  
显然，若图$G$的邻接矩阵为$A_{G}=(a_{i j})_{n\times n}$，则其补图$\bar{G}$的邻接矩阵为$A_{\bar{G}}=(\bar{a}_{i j})_{n\times n}$为：  
$$
\\\bar{a}_{i j}=f(x)=\left\{\begin{array}{r l r}&{~~~~~~~~1-a_{i j},~i\neq j}&\\ &{0,~~~~~~~~~~~~~~~~~~i=j}&\end{array}\right.
$$  
例如，对于图8-18 所示的图 $G_{1}$和图 $G_{2}$，图 $G_{1}$ 是图 $G_{2}$ 的补图，图 $G_{2}$ 也是图 $G_{1}$的补图。显然， $K_{n}$ 的补图是 $n$ 阶零图，反之亦然。  
![图8-18 补图运算 ](images/bc253e401f30298f9209681ddc8b93ec627ca9bfb8d5b9c17929af79e1390112.jpg)",完全图可以被视为特定结点集导出的导出子图，其中所有结点间都有边
导出子图,互补,补图,,"在使用图模型对实际问题建模和求解的过程中，经常需要分析考察图的某个特定部分的结构，将图中某个或某些特定的部分提取出来作为一个图模型进行研究，由此得到如下关于图模型的子图运算的若干概念，具体如下：  
【定义8.13】设 $G=\langle V,E\rangle$，$G^{\prime}=\langle V^{\prime},E^{\prime}\rangle$是两个图（同为无向图或者有向图），则有：  
（1）若 $V^{\prime}\subseteq V$且 $E^{\prime}\subseteq E$，则称 $G^{\prime}$是 $G$ 的子图，$G$ 是 $G^{\prime}$的母图，记为 $G^{\prime}\subseteq\mathbf{G}$ 。若 $G^{\prime}\subseteq\mathbf{G}$且 $G^{\prime}\neq{\bf G}$（即$V^{\prime}\subset V$或 $E^{\prime}\subset\mathbf{E})$），则称 $G^{\prime}$ 是 $G$ 的真子图；若 $G^{\prime}\subseteq G$且 $V^{\prime}=V$，则称 $G^{\prime}$是 $G$ 的生成子图。  
（2）设$V_{1}$是𝑉的非空子集，即 $\varnothing\neq V_{1}\subseteq V$，则以 $V_{1}$ 为结点集，以两个端点均在 $V_{1}$ 中的全体边为边集的 $G$ 的子图称为由$V_{1}$导出的导出子图，记为 $G[V_{1}]$。  
（3）设$E_{1}$是$E$的非空子集，设$\varnothing\neq E_{1}\subseteq E$，以 $E_{1}$为边集，以 $E_{1}$ 中所有边关联的全部结点为结点集的 $G$ 的子图成为由 $E_{1}$导出的导出子图，记为 $G[\ E_{1}]$。  
由上述定义可以看出，生成子图与其母图具有相同的结点集合。因此，一个图的生成子图一般是该图的主体结构。对于一个复杂的图模型，一般通过采用适当的方法构造其符合要求的生成子图实现对模型的化简和对问题的求解。  
不难看出，对于任一给定非空有限结点集合，由这些结点构成的零图和完全图分别表达了两个极端构图情形，两者之间具有互补性，相当于集合论中的空集和全集。 由此可以得到图模型补运算的概念。 首先给出如下关于完全图的定义：  
【定义8.14】假设$G=\langle V,E\rangle$是一个具有$\cdot_{n}$个结点的无向简单图，如果图中任意两个结点之间都有边相联结，则称该图为$^n$阶无向完全图，简称为完全图，记为$K_{n}$；假设$G=\langle V,E\rangle$是一个具有$\cdot_{n}$个结点的有向简单图，如果图中任意两个结点之间都有方向相反的两条边相联结，则称该图为$n$阶有向完全图，在不发生混淆的情况下也记为$K_{n}$。  
由上述定义可知，对于完全图来说，其邻接矩阵除主对角线上元素均为0 之外，其余元素均为1。显然，$n$阶无向完全图的边数为$n(n-1)/2$ ，$n$阶有向完全图的边数为$\ n(n-1)$。 图8-17 给出了无向完全图$K_{3}$，$K_{4}$，$K_{5}$和有向图$K_{3}$。  
下面给出图模型补运算的定义：  
【定义8.15】设 $G=\langle V,E\rangle$ 是 $n$ 阶简单图，以 $V$ 为顶点集，以所有能使 $G$ 成为完全图 $K_{n}$ 的新加边为边集的图称为 $G$ 相对于 $K_{n}$ 的补图，简称为 $G$ 的补图，记为$\bar{G}$。  
显然，若图$G$的邻接矩阵为$A_{G}=(a_{i j})_{n\times n}$，则其补图$\bar{G}$的邻接矩阵为$A_{\bar{G}}=(\bar{a}_{i j})_{n\times n}$为：  
$$
\\\bar{a}_{i j}=f(x)=\left\{\begin{array}{r l r}&{~~~~~~~~1-a_{i j},~i\neq j}&\\ &{0,~~~~~~~~~~~~~~~~~~i=j}&\end{array}\right.
$$  
例如，对于图8-18 所示的图 $G_{1}$和图 $G_{2}$，图 $G_{1}$ 是图 $G_{2}$ 的补图，图 $G_{2}$ 也是图 $G_{1}$的补图。显然， $K_{n}$ 的补图是 $n$ 阶零图，反之亦然。  
![图8-18 补图运算 ](images/bc253e401f30298f9209681ddc8b93ec627ca9bfb8d5b9c17929af79e1390112.jpg)",导出子图与其补图之间具有互补性，补图包含导出子图中不存在的边
完全图,互为补图,补图,,"在使用图模型对实际问题建模和求解的过程中，经常需要分析考察图的某个特定部分的结构，将图中某个或某些特定的部分提取出来作为一个图模型进行研究，由此得到如下关于图模型的子图运算的若干概念，具体如下：  
【定义8.13】设 $G=\langle V,E\rangle$，$G^{\prime}=\langle V^{\prime},E^{\prime}\rangle$是两个图（同为无向图或者有向图），则有：  
（1）若 $V^{\prime}\subseteq V$且 $E^{\prime}\subseteq E$，则称 $G^{\prime}$是 $G$ 的子图，$G$ 是 $G^{\prime}$的母图，记为 $G^{\prime}\subseteq\mathbf{G}$ 。若 $G^{\prime}\subseteq\mathbf{G}$且 $G^{\prime}\neq{\bf G}$（即$V^{\prime}\subset V$或 $E^{\prime}\subset\mathbf{E})$），则称 $G^{\prime}$ 是 $G$ 的真子图；若 $G^{\prime}\subseteq G$且 $V^{\prime}=V$，则称 $G^{\prime}$是 $G$ 的生成子图。  
（2）设$V_{1}$是𝑉的非空子集，即 $\varnothing\neq V_{1}\subseteq V$，则以 $V_{1}$ 为结点集，以两个端点均在 $V_{1}$ 中的全体边为边集的 $G$ 的子图称为由$V_{1}$导出的导出子图，记为 $G[V_{1}]$。  
（3）设$E_{1}$是$E$的非空子集，设$\varnothing\neq E_{1}\subseteq E$，以 $E_{1}$为边集，以 $E_{1}$ 中所有边关联的全部结点为结点集的 $G$ 的子图成为由 $E_{1}$导出的导出子图，记为 $G[\ E_{1}]$。  
由上述定义可以看出，生成子图与其母图具有相同的结点集合。因此，一个图的生成子图一般是该图的主体结构。对于一个复杂的图模型，一般通过采用适当的方法构造其符合要求的生成子图实现对模型的化简和对问题的求解。  
不难看出，对于任一给定非空有限结点集合，由这些结点构成的零图和完全图分别表达了两个极端构图情形，两者之间具有互补性，相当于集合论中的空集和全集。 由此可以得到图模型补运算的概念。 首先给出如下关于完全图的定义：  
【定义8.14】假设$G=\langle V,E\rangle$是一个具有$\cdot_{n}$个结点的无向简单图，如果图中任意两个结点之间都有边相联结，则称该图为$^n$阶无向完全图，简称为完全图，记为$K_{n}$；假设$G=\langle V,E\rangle$是一个具有$\cdot_{n}$个结点的有向简单图，如果图中任意两个结点之间都有方向相反的两条边相联结，则称该图为$n$阶有向完全图，在不发生混淆的情况下也记为$K_{n}$。  
由上述定义可知，对于完全图来说，其邻接矩阵除主对角线上元素均为0 之外，其余元素均为1。显然，$n$阶无向完全图的边数为$n(n-1)/2$ ，$n$阶有向完全图的边数为$\ n(n-1)$。 图8-17 给出了无向完全图$K_{3}$，$K_{4}$，$K_{5}$和有向图$K_{3}$。  
下面给出图模型补运算的定义：  
【定义8.15】设 $G=\langle V,E\rangle$ 是 $n$ 阶简单图，以 $V$ 为顶点集，以所有能使 $G$ 成为完全图 $K_{n}$ 的新加边为边集的图称为 $G$ 相对于 $K_{n}$ 的补图，简称为 $G$ 的补图，记为$\bar{G}$。  
显然，若图$G$的邻接矩阵为$A_{G}=(a_{i j})_{n\times n}$，则其补图$\bar{G}$的邻接矩阵为$A_{\bar{G}}=(\bar{a}_{i j})_{n\times n}$为：  
$$
\\\bar{a}_{i j}=f(x)=\left\{\begin{array}{r l r}&{~~~~~~~~1-a_{i j},~i\neq j}&\\ &{0,~~~~~~~~~~~~~~~~~~i=j}&\end{array}\right.
$$  
例如，对于图8-18 所示的图 $G_{1}$和图 $G_{2}$，图 $G_{1}$ 是图 $G_{2}$ 的补图，图 $G_{2}$ 也是图 $G_{1}$的补图。显然， $K_{n}$ 的补图是 $n$ 阶零图，反之亦然。  
![图8-18 补图运算 ](images/bc253e401f30298f9209681ddc8b93ec627ca9bfb8d5b9c17929af79e1390112.jpg)",完全图与其补图互为补图，完全图的补图是零图，反之亦然
结点度,定义,无向图结点度,,"现在我们考察图模型的结构特征。从结构上看，对于任意给定的一个图模型，只要该图不是零图，总会有一些点与一些边相互联结。从生成子图的概念可以看出，图的结点构成了图模型的骨架或主体结构，因此，我们主要从结点出发考察每个结点所关联的边关联多少条边。为此，对于图中的每个结点，都定义一个数来描述该结点所关联边的个数，这就是结点度的概念，其具体定义如下：  
【定义8.16】假设图 $G=\langle V,E\rangle$是任意给定的一个无向图，对于$G$中任意一个结点 $v$ ，与该结点关联边的条数称为该结点的度数，简称为度，记为 ${\sf d e g}(v)$。图$G$中各个结点度数的最大值称为图$G$的最大度，记为$\Delta(G)$；图$G$中各个结点度数的最小值称为图$G$的最小度，记为$\delta(G)$ $\Delta(\mathrm{G})=\mathrm{max}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\};\,\,\,\delta(\mathrm{G})=\mathrm{min}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\}\,.$  
【定义8.17】设图 $G=\langle V,E\rangle$是任意给定的一个有向图，$v$是$G$中任一结点，则有：  
（1）以该结点为起点的有向边的条数，称为该结点的出度，记为$\deg^{+}(v)$；以该结点为终点的有向边的条数，称为该结点的入度，记为 $\deg^{-}(v)$。  
（2）该结点的出度与入度之和称为该结点的度，记为${\sf d e g}(v)$。 即有：  
$$
\deg(v)=\deg^{+}(v)+\deg^{-}(v)
$$  
（3）图$G$中各个结点出度与入度的最大值分别称为图$G$的最大出度和最大入度，分别记为$\Delta^{+}(\mathsf{G})$和 $\Delta^{-}(\mathsf{G})$；图$G$中各个结点出度与入度的最小值分别称为图$G$的最小出度和最小入度，分别记为$\Delta^{+}(\mathbf{G})$和 $\Delta^{-}(\mathsf{G})$，即有：  
$\Delta^{+}(\mathrm{G})=\operatorname*{max}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\Delta^{-}(\mathrm{G})=\operatorname*{max}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$ $\delta^{+}(\mathrm{G})=\operatorname*{min}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\delta^{-}(\mathrm{G})=\operatorname*{min}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$  
从上述定义可以看出，引入度结点度概念的目的主要是通过对图中每个结点所关联边数进行统计分析来考察图模型的结构特征。  
【定义8.18】对于任意一个给定的有向图或无向图  $G=\langle V,E\rangle$ ，图中度数为1 的结点称为该图的悬挂结点，图中以悬挂结点为端点的边称为该图的悬挂边。如果图$G$中各个结点的度数均相同，则称该图正则图，各结点度均为$\ k$的正则图称为$\pmb{k}$-正则图。  
下面我们考察图的邻接矩阵与图中结点度之间的关系。  
假设 $G=\langle V,E\rangle$是任意给定的一个有向图或无向图，其中$V=\{v_{1},v_{2},\ldots,v_{n}\}$，$E=$$\{e_{1},e_{2},\ldots,e_{m}\}$。 $G$的邻接矩阵为：  
$$
A=(a_{i j})_{n\times n}=\left(\!\!{\begin{array}{c c c c}{a_{11}}&{a_{12}}&{\ldots}&{a_{1n}}\\ {a_{21}}&{a_{22}}&{\ldots}&{a_{2n}}\\ {\vdots}&{\ddots}&{\vdots}\\ {a_{n1}}&{a_{n2}}&{\ldots}&{a_{n n}}\end{array}}\!\!\right)
$$  
则有如下结论：  
（1）如果$G$是无向图，那么邻接矩阵𝐴中第𝑖行元素之和表示结点$v_{i}$的度数，第𝑗列元素之和表示结点$v_{j}$的度数。即有：  
$$
\deg(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};~~~~\deg\bigl(v_{j}\bigr)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（2）若G是有向图，那么邻接矩阵$A$中第𝑖行元素之和表示结点$v_{i}$的出度，第$j$列元素之和表示结点$v_{j}$的入度。简单地说，就是竖入横出。即有：  
$$
\deg^{-}(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};\qquad\deg^{+}\!\left(v_{j}\right)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（3）对于有向图G，注意到：  
$$
\sum_{j=1}^{n}\;\deg^{-}\!\left(v_{j}\right)=\sum_{i=1}^{n}\sum_{j=1}^{n}a_{i j}=\sum_{i=1}^{n}\deg^{+}\!\left(v_{i}\right)
$$  
因此，有向图中所有入度之和等于所有出度之和，这个和其实就是图的边数$m$。因为有向图的每条边均产生且仅产生一个出度和一个入度。  
对于图8-19 所示图模型$G$及如下邻接矩阵$A_{G}$，容易验证，结点度与邻接矩阵之间的数量关系。例如，$A_{G}$中第三行元素之和为3，即$v_{3}$的出度为3。
$$
\begin{gathered}v_{1}\quad v_{2}\quad v_{3}\quad v_{4}\quad v_{5}\\A_{G}=\begin{matrix}v_{1}\\v_{2}\\v_{3}\\v_{4}\end{matrix}\begin{pmatrix}0&1&0&0&0\\0&1&1&0&0\\1&1&0&1&0\\0&0&0&0&0\\0&0&0&0&0\end{pmatrix}\end{gathered}
$$  
关于图中结点度数与边的关系，有如下著名的图论基本定理：  
【定理8.1】（握手定理）假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，则该图中结点度数的总和等于边数的二倍，即有：  
$$
\sum_{v\in V}\deg(v)=2|E|
$$  
【推论8.1】图中度数为奇数的结点个数必为偶数。  
从以上定理及例题可以看出，图模型中结点的度从一种定量的角度反映了图中结点与边之间的制约关系，在一定程度上刻画了图模型的结构特征。为了更加方便地描述图模型中各个结点的度结构信息，下面给出度序列的概念：  
【定义8.19】假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，图中每个结点的图构成的自然数序列称为$G$的度序列。也就是说，若 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，则称序列：  
$$
(\deg(v_{1})\,,\deg(v_{2})\,,\cdots,\deg(v_{n}))
$$  
为图 $G$ 的度数序列，简称为度序列。 此外，对于任意一个给定的自然数序列，如果该序列能够成为某个图的度序列，则称该序列为可图化序列。  
例如，对于图8-22 所示图 $G$ ，其度数序列为 (2,3,3,4)  
![图8-22 图 $G$ ](images/77ba680d9b589e032065b86071c3f75473dc0d06736af0deb36aa2115de43d51.jpg)  
由于图模型的度要满足握手定理等基本约束要求，而且对于不同类型的图，其度序列也会有一些相应的数据特征。因此，并不是任意的自然数序列都可以构成图模型的度序列。对于任意给定的自然数序列，需要通过分析其数据特征来判断其是否为可图化序列。若是可图化序列，则可依据该序列数据来分析其所对应图的结构特征。",无向图结点度是结点度在无向图中的具体表现形式，表示与结点关联的边数
结点度,定义,有向图结点度,,"现在我们考察图模型的结构特征。从结构上看，对于任意给定的一个图模型，只要该图不是零图，总会有一些点与一些边相互联结。从生成子图的概念可以看出，图的结点构成了图模型的骨架或主体结构，因此，我们主要从结点出发考察每个结点所关联的边关联多少条边。为此，对于图中的每个结点，都定义一个数来描述该结点所关联边的个数，这就是结点度的概念，其具体定义如下：  
【定义8.16】假设图 $G=\langle V,E\rangle$是任意给定的一个无向图，对于$G$中任意一个结点 $v$ ，与该结点关联边的条数称为该结点的度数，简称为度，记为 ${\sf d e g}(v)$。图$G$中各个结点度数的最大值称为图$G$的最大度，记为$\Delta(G)$；图$G$中各个结点度数的最小值称为图$G$的最小度，记为$\delta(G)$ $\Delta(\mathrm{G})=\mathrm{max}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\};\,\,\,\delta(\mathrm{G})=\mathrm{min}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\}\,.$  
【定义8.17】设图 $G=\langle V,E\rangle$是任意给定的一个有向图，$v$是$G$中任一结点，则有：  
（1）以该结点为起点的有向边的条数，称为该结点的出度，记为$\deg^{+}(v)$；以该结点为终点的有向边的条数，称为该结点的入度，记为 $\deg^{-}(v)$。  
（2）该结点的出度与入度之和称为该结点的度，记为${\sf d e g}(v)$。 即有：  
$$
\deg(v)=\deg^{+}(v)+\deg^{-}(v)
$$  
（3）图$G$中各个结点出度与入度的最大值分别称为图$G$的最大出度和最大入度，分别记为$\Delta^{+}(\mathsf{G})$和 $\Delta^{-}(\mathsf{G})$；图$G$中各个结点出度与入度的最小值分别称为图$G$的最小出度和最小入度，分别记为$\Delta^{+}(\mathbf{G})$和 $\Delta^{-}(\mathsf{G})$，即有：  
$\Delta^{+}(\mathrm{G})=\operatorname*{max}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\Delta^{-}(\mathrm{G})=\operatorname*{max}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$ $\delta^{+}(\mathrm{G})=\operatorname*{min}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\delta^{-}(\mathrm{G})=\operatorname*{min}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$  
从上述定义可以看出，引入度结点度概念的目的主要是通过对图中每个结点所关联边数进行统计分析来考察图模型的结构特征。  
【定义8.18】对于任意一个给定的有向图或无向图  $G=\langle V,E\rangle$ ，图中度数为1 的结点称为该图的悬挂结点，图中以悬挂结点为端点的边称为该图的悬挂边。如果图$G$中各个结点的度数均相同，则称该图正则图，各结点度均为$\ k$的正则图称为$\pmb{k}$-正则图。  
下面我们考察图的邻接矩阵与图中结点度之间的关系。  
假设 $G=\langle V,E\rangle$是任意给定的一个有向图或无向图，其中$V=\{v_{1},v_{2},\ldots,v_{n}\}$，$E=$$\{e_{1},e_{2},\ldots,e_{m}\}$。 $G$的邻接矩阵为：  
$$
A=(a_{i j})_{n\times n}=\left(\!\!{\begin{array}{c c c c}{a_{11}}&{a_{12}}&{\ldots}&{a_{1n}}\\ {a_{21}}&{a_{22}}&{\ldots}&{a_{2n}}\\ {\vdots}&{\ddots}&{\vdots}\\ {a_{n1}}&{a_{n2}}&{\ldots}&{a_{n n}}\end{array}}\!\!\right)
$$  
则有如下结论：  
（1）如果$G$是无向图，那么邻接矩阵𝐴中第𝑖行元素之和表示结点$v_{i}$的度数，第𝑗列元素之和表示结点$v_{j}$的度数。即有：  
$$
\deg(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};~~~~\deg\bigl(v_{j}\bigr)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（2）若G是有向图，那么邻接矩阵$A$中第𝑖行元素之和表示结点$v_{i}$的出度，第$j$列元素之和表示结点$v_{j}$的入度。简单地说，就是竖入横出。即有：  
$$
\deg^{-}(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};\qquad\deg^{+}\!\left(v_{j}\right)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（3）对于有向图G，注意到：  
$$
\sum_{j=1}^{n}\;\deg^{-}\!\left(v_{j}\right)=\sum_{i=1}^{n}\sum_{j=1}^{n}a_{i j}=\sum_{i=1}^{n}\deg^{+}\!\left(v_{i}\right)
$$  
因此，有向图中所有入度之和等于所有出度之和，这个和其实就是图的边数$m$。因为有向图的每条边均产生且仅产生一个出度和一个入度。  
对于图8-19 所示图模型$G$及如下邻接矩阵$A_{G}$，容易验证，结点度与邻接矩阵之间的数量关系。例如，$A_{G}$中第三行元素之和为3，即$v_{3}$的出度为3。
$$
\begin{gathered}v_{1}\quad v_{2}\quad v_{3}\quad v_{4}\quad v_{5}\\A_{G}=\begin{matrix}v_{1}\\v_{2}\\v_{3}\\v_{4}\end{matrix}\begin{pmatrix}0&1&0&0&0\\0&1&1&0&0\\1&1&0&1&0\\0&0&0&0&0\\0&0&0&0&0\end{pmatrix}\end{gathered}
$$  
关于图中结点度数与边的关系，有如下著名的图论基本定理：  
【定理8.1】（握手定理）假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，则该图中结点度数的总和等于边数的二倍，即有：  
$$
\sum_{v\in V}\deg(v)=2|E|
$$  
【推论8.1】图中度数为奇数的结点个数必为偶数。  
从以上定理及例题可以看出，图模型中结点的度从一种定量的角度反映了图中结点与边之间的制约关系，在一定程度上刻画了图模型的结构特征。为了更加方便地描述图模型中各个结点的度结构信息，下面给出度序列的概念：  
【定义8.19】假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，图中每个结点的图构成的自然数序列称为$G$的度序列。也就是说，若 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，则称序列：  
$$
(\deg(v_{1})\,,\deg(v_{2})\,,\cdots,\deg(v_{n}))
$$  
为图 $G$ 的度数序列，简称为度序列。 此外，对于任意一个给定的自然数序列，如果该序列能够成为某个图的度序列，则称该序列为可图化序列。  
例如，对于图8-22 所示图 $G$ ，其度数序列为 (2,3,3,4)  
![图8-22 图 $G$ ](images/77ba680d9b589e032065b86071c3f75473dc0d06736af0deb36aa2115de43d51.jpg)  
由于图模型的度要满足握手定理等基本约束要求，而且对于不同类型的图，其度序列也会有一些相应的数据特征。因此，并不是任意的自然数序列都可以构成图模型的度序列。对于任意给定的自然数序列，需要通过分析其数据特征来判断其是否为可图化序列。若是可图化序列，则可依据该序列数据来分析其所对应图的结构特征。",有向图结点度是结点度在有向图中的具体表现形式，表示结点的出度与入度之和
结点度,关联,悬挂结点,,"现在我们考察图模型的结构特征。从结构上看，对于任意给定的一个图模型，只要该图不是零图，总会有一些点与一些边相互联结。从生成子图的概念可以看出，图的结点构成了图模型的骨架或主体结构，因此，我们主要从结点出发考察每个结点所关联的边关联多少条边。为此，对于图中的每个结点，都定义一个数来描述该结点所关联边的个数，这就是结点度的概念，其具体定义如下：  
【定义8.16】假设图 $G=\langle V,E\rangle$是任意给定的一个无向图，对于$G$中任意一个结点 $v$ ，与该结点关联边的条数称为该结点的度数，简称为度，记为 ${\sf d e g}(v)$。图$G$中各个结点度数的最大值称为图$G$的最大度，记为$\Delta(G)$；图$G$中各个结点度数的最小值称为图$G$的最小度，记为$\delta(G)$ $\Delta(\mathrm{G})=\mathrm{max}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\};\,\,\,\delta(\mathrm{G})=\mathrm{min}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\}\,.$  
【定义8.17】设图 $G=\langle V,E\rangle$是任意给定的一个有向图，$v$是$G$中任一结点，则有：  
（1）以该结点为起点的有向边的条数，称为该结点的出度，记为$\deg^{+}(v)$；以该结点为终点的有向边的条数，称为该结点的入度，记为 $\deg^{-}(v)$。  
（2）该结点的出度与入度之和称为该结点的度，记为${\sf d e g}(v)$。 即有：  
$$
\deg(v)=\deg^{+}(v)+\deg^{-}(v)
$$  
（3）图$G$中各个结点出度与入度的最大值分别称为图$G$的最大出度和最大入度，分别记为$\Delta^{+}(\mathsf{G})$和 $\Delta^{-}(\mathsf{G})$；图$G$中各个结点出度与入度的最小值分别称为图$G$的最小出度和最小入度，分别记为$\Delta^{+}(\mathbf{G})$和 $\Delta^{-}(\mathsf{G})$，即有：  
$\Delta^{+}(\mathrm{G})=\operatorname*{max}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\Delta^{-}(\mathrm{G})=\operatorname*{max}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$ $\delta^{+}(\mathrm{G})=\operatorname*{min}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\delta^{-}(\mathrm{G})=\operatorname*{min}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$  
从上述定义可以看出，引入度结点度概念的目的主要是通过对图中每个结点所关联边数进行统计分析来考察图模型的结构特征。  
【定义8.18】对于任意一个给定的有向图或无向图  $G=\langle V,E\rangle$ ，图中度数为1 的结点称为该图的悬挂结点，图中以悬挂结点为端点的边称为该图的悬挂边。如果图$G$中各个结点的度数均相同，则称该图正则图，各结点度均为$\ k$的正则图称为$\pmb{k}$-正则图。  
下面我们考察图的邻接矩阵与图中结点度之间的关系。  
假设 $G=\langle V,E\rangle$是任意给定的一个有向图或无向图，其中$V=\{v_{1},v_{2},\ldots,v_{n}\}$，$E=$$\{e_{1},e_{2},\ldots,e_{m}\}$。 $G$的邻接矩阵为：  
$$
A=(a_{i j})_{n\times n}=\left(\!\!{\begin{array}{c c c c}{a_{11}}&{a_{12}}&{\ldots}&{a_{1n}}\\ {a_{21}}&{a_{22}}&{\ldots}&{a_{2n}}\\ {\vdots}&{\ddots}&{\vdots}\\ {a_{n1}}&{a_{n2}}&{\ldots}&{a_{n n}}\end{array}}\!\!\right)
$$  
则有如下结论：  
（1）如果$G$是无向图，那么邻接矩阵𝐴中第𝑖行元素之和表示结点$v_{i}$的度数，第𝑗列元素之和表示结点$v_{j}$的度数。即有：  
$$
\deg(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};~~~~\deg\bigl(v_{j}\bigr)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（2）若G是有向图，那么邻接矩阵$A$中第𝑖行元素之和表示结点$v_{i}$的出度，第$j$列元素之和表示结点$v_{j}$的入度。简单地说，就是竖入横出。即有：  
$$
\deg^{-}(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};\qquad\deg^{+}\!\left(v_{j}\right)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（3）对于有向图G，注意到：  
$$
\sum_{j=1}^{n}\;\deg^{-}\!\left(v_{j}\right)=\sum_{i=1}^{n}\sum_{j=1}^{n}a_{i j}=\sum_{i=1}^{n}\deg^{+}\!\left(v_{i}\right)
$$  
因此，有向图中所有入度之和等于所有出度之和，这个和其实就是图的边数$m$。因为有向图的每条边均产生且仅产生一个出度和一个入度。  
对于图8-19 所示图模型$G$及如下邻接矩阵$A_{G}$，容易验证，结点度与邻接矩阵之间的数量关系。例如，$A_{G}$中第三行元素之和为3，即$v_{3}$的出度为3。
$$
\begin{gathered}v_{1}\quad v_{2}\quad v_{3}\quad v_{4}\quad v_{5}\\A_{G}=\begin{matrix}v_{1}\\v_{2}\\v_{3}\\v_{4}\end{matrix}\begin{pmatrix}0&1&0&0&0\\0&1&1&0&0\\1&1&0&1&0\\0&0&0&0&0\\0&0&0&0&0\end{pmatrix}\end{gathered}
$$  
关于图中结点度数与边的关系，有如下著名的图论基本定理：  
【定理8.1】（握手定理）假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，则该图中结点度数的总和等于边数的二倍，即有：  
$$
\sum_{v\in V}\deg(v)=2|E|
$$  
【推论8.1】图中度数为奇数的结点个数必为偶数。  
从以上定理及例题可以看出，图模型中结点的度从一种定量的角度反映了图中结点与边之间的制约关系，在一定程度上刻画了图模型的结构特征。为了更加方便地描述图模型中各个结点的度结构信息，下面给出度序列的概念：  
【定义8.19】假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，图中每个结点的图构成的自然数序列称为$G$的度序列。也就是说，若 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，则称序列：  
$$
(\deg(v_{1})\,,\deg(v_{2})\,,\cdots,\deg(v_{n}))
$$  
为图 $G$ 的度数序列，简称为度序列。 此外，对于任意一个给定的自然数序列，如果该序列能够成为某个图的度序列，则称该序列为可图化序列。  
例如，对于图8-22 所示图 $G$ ，其度数序列为 (2,3,3,4)  
![图8-22 图 $G$ ](images/77ba680d9b589e032065b86071c3f75473dc0d06736af0deb36aa2115de43d51.jpg)  
由于图模型的度要满足握手定理等基本约束要求，而且对于不同类型的图，其度序列也会有一些相应的数据特征。因此，并不是任意的自然数序列都可以构成图模型的度序列。对于任意给定的自然数序列，需要通过分析其数据特征来判断其是否为可图化序列。若是可图化序列，则可依据该序列数据来分析其所对应图的结构特征。",悬挂结点是度数为1的结点，是结点度的一种特殊情形
结点度,关联,正则图,,"现在我们考察图模型的结构特征。从结构上看，对于任意给定的一个图模型，只要该图不是零图，总会有一些点与一些边相互联结。从生成子图的概念可以看出，图的结点构成了图模型的骨架或主体结构，因此，我们主要从结点出发考察每个结点所关联的边关联多少条边。为此，对于图中的每个结点，都定义一个数来描述该结点所关联边的个数，这就是结点度的概念，其具体定义如下：  
【定义8.16】假设图 $G=\langle V,E\rangle$是任意给定的一个无向图，对于$G$中任意一个结点 $v$ ，与该结点关联边的条数称为该结点的度数，简称为度，记为 ${\sf d e g}(v)$。图$G$中各个结点度数的最大值称为图$G$的最大度，记为$\Delta(G)$；图$G$中各个结点度数的最小值称为图$G$的最小度，记为$\delta(G)$ $\Delta(\mathrm{G})=\mathrm{max}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\};\,\,\,\delta(\mathrm{G})=\mathrm{min}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\}\,.$  
【定义8.17】设图 $G=\langle V,E\rangle$是任意给定的一个有向图，$v$是$G$中任一结点，则有：  
（1）以该结点为起点的有向边的条数，称为该结点的出度，记为$\deg^{+}(v)$；以该结点为终点的有向边的条数，称为该结点的入度，记为 $\deg^{-}(v)$。  
（2）该结点的出度与入度之和称为该结点的度，记为${\sf d e g}(v)$。 即有：  
$$
\deg(v)=\deg^{+}(v)+\deg^{-}(v)
$$  
（3）图$G$中各个结点出度与入度的最大值分别称为图$G$的最大出度和最大入度，分别记为$\Delta^{+}(\mathsf{G})$和 $\Delta^{-}(\mathsf{G})$；图$G$中各个结点出度与入度的最小值分别称为图$G$的最小出度和最小入度，分别记为$\Delta^{+}(\mathbf{G})$和 $\Delta^{-}(\mathsf{G})$，即有：  
$\Delta^{+}(\mathrm{G})=\operatorname*{max}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\Delta^{-}(\mathrm{G})=\operatorname*{max}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$ $\delta^{+}(\mathrm{G})=\operatorname*{min}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\delta^{-}(\mathrm{G})=\operatorname*{min}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$  
从上述定义可以看出，引入度结点度概念的目的主要是通过对图中每个结点所关联边数进行统计分析来考察图模型的结构特征。  
【定义8.18】对于任意一个给定的有向图或无向图  $G=\langle V,E\rangle$ ，图中度数为1 的结点称为该图的悬挂结点，图中以悬挂结点为端点的边称为该图的悬挂边。如果图$G$中各个结点的度数均相同，则称该图正则图，各结点度均为$\ k$的正则图称为$\pmb{k}$-正则图。  
下面我们考察图的邻接矩阵与图中结点度之间的关系。  
假设 $G=\langle V,E\rangle$是任意给定的一个有向图或无向图，其中$V=\{v_{1},v_{2},\ldots,v_{n}\}$，$E=$$\{e_{1},e_{2},\ldots,e_{m}\}$。 $G$的邻接矩阵为：  
$$
A=(a_{i j})_{n\times n}=\left(\!\!{\begin{array}{c c c c}{a_{11}}&{a_{12}}&{\ldots}&{a_{1n}}\\ {a_{21}}&{a_{22}}&{\ldots}&{a_{2n}}\\ {\vdots}&{\ddots}&{\vdots}\\ {a_{n1}}&{a_{n2}}&{\ldots}&{a_{n n}}\end{array}}\!\!\right)
$$  
则有如下结论：  
（1）如果$G$是无向图，那么邻接矩阵𝐴中第𝑖行元素之和表示结点$v_{i}$的度数，第𝑗列元素之和表示结点$v_{j}$的度数。即有：  
$$
\deg(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};~~~~\deg\bigl(v_{j}\bigr)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（2）若G是有向图，那么邻接矩阵$A$中第𝑖行元素之和表示结点$v_{i}$的出度，第$j$列元素之和表示结点$v_{j}$的入度。简单地说，就是竖入横出。即有：  
$$
\deg^{-}(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};\qquad\deg^{+}\!\left(v_{j}\right)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（3）对于有向图G，注意到：  
$$
\sum_{j=1}^{n}\;\deg^{-}\!\left(v_{j}\right)=\sum_{i=1}^{n}\sum_{j=1}^{n}a_{i j}=\sum_{i=1}^{n}\deg^{+}\!\left(v_{i}\right)
$$  
因此，有向图中所有入度之和等于所有出度之和，这个和其实就是图的边数$m$。因为有向图的每条边均产生且仅产生一个出度和一个入度。  
对于图8-19 所示图模型$G$及如下邻接矩阵$A_{G}$，容易验证，结点度与邻接矩阵之间的数量关系。例如，$A_{G}$中第三行元素之和为3，即$v_{3}$的出度为3。
$$
\begin{gathered}v_{1}\quad v_{2}\quad v_{3}\quad v_{4}\quad v_{5}\\A_{G}=\begin{matrix}v_{1}\\v_{2}\\v_{3}\\v_{4}\end{matrix}\begin{pmatrix}0&1&0&0&0\\0&1&1&0&0\\1&1&0&1&0\\0&0&0&0&0\\0&0&0&0&0\end{pmatrix}\end{gathered}
$$  
关于图中结点度数与边的关系，有如下著名的图论基本定理：  
【定理8.1】（握手定理）假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，则该图中结点度数的总和等于边数的二倍，即有：  
$$
\sum_{v\in V}\deg(v)=2|E|
$$  
【推论8.1】图中度数为奇数的结点个数必为偶数。  
从以上定理及例题可以看出，图模型中结点的度从一种定量的角度反映了图中结点与边之间的制约关系，在一定程度上刻画了图模型的结构特征。为了更加方便地描述图模型中各个结点的度结构信息，下面给出度序列的概念：  
【定义8.19】假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，图中每个结点的图构成的自然数序列称为$G$的度序列。也就是说，若 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，则称序列：  
$$
(\deg(v_{1})\,,\deg(v_{2})\,,\cdots,\deg(v_{n}))
$$  
为图 $G$ 的度数序列，简称为度序列。 此外，对于任意一个给定的自然数序列，如果该序列能够成为某个图的度序列，则称该序列为可图化序列。  
例如，对于图8-22 所示图 $G$ ，其度数序列为 (2,3,3,4)  
![图8-22 图 $G$ ](images/77ba680d9b589e032065b86071c3f75473dc0d06736af0deb36aa2115de43d51.jpg)  
由于图模型的度要满足握手定理等基本约束要求，而且对于不同类型的图，其度序列也会有一些相应的数据特征。因此，并不是任意的自然数序列都可以构成图模型的度序列。对于任意给定的自然数序列，需要通过分析其数据特征来判断其是否为可图化序列。若是可图化序列，则可依据该序列数据来分析其所对应图的结构特征。",正则图中所有结点的度数相同，结点度是正则图定义的基础
邻接矩阵与结点度关系,描述,结点度,,"现在我们考察图模型的结构特征。从结构上看，对于任意给定的一个图模型，只要该图不是零图，总会有一些点与一些边相互联结。从生成子图的概念可以看出，图的结点构成了图模型的骨架或主体结构，因此，我们主要从结点出发考察每个结点所关联的边关联多少条边。为此，对于图中的每个结点，都定义一个数来描述该结点所关联边的个数，这就是结点度的概念，其具体定义如下：  
【定义8.16】假设图 $G=\langle V,E\rangle$是任意给定的一个无向图，对于$G$中任意一个结点 $v$ ，与该结点关联边的条数称为该结点的度数，简称为度，记为 ${\sf d e g}(v)$。图$G$中各个结点度数的最大值称为图$G$的最大度，记为$\Delta(G)$；图$G$中各个结点度数的最小值称为图$G$的最小度，记为$\delta(G)$ $\Delta(\mathrm{G})=\mathrm{max}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\};\,\,\,\delta(\mathrm{G})=\mathrm{min}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\}\,.$  
【定义8.17】设图 $G=\langle V,E\rangle$是任意给定的一个有向图，$v$是$G$中任一结点，则有：  
（1）以该结点为起点的有向边的条数，称为该结点的出度，记为$\deg^{+}(v)$；以该结点为终点的有向边的条数，称为该结点的入度，记为 $\deg^{-}(v)$。  
（2）该结点的出度与入度之和称为该结点的度，记为${\sf d e g}(v)$。 即有：  
$$
\deg(v)=\deg^{+}(v)+\deg^{-}(v)
$$  
（3）图$G$中各个结点出度与入度的最大值分别称为图$G$的最大出度和最大入度，分别记为$\Delta^{+}(\mathsf{G})$和 $\Delta^{-}(\mathsf{G})$；图$G$中各个结点出度与入度的最小值分别称为图$G$的最小出度和最小入度，分别记为$\Delta^{+}(\mathbf{G})$和 $\Delta^{-}(\mathsf{G})$，即有：  
$\Delta^{+}(\mathrm{G})=\operatorname*{max}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\Delta^{-}(\mathrm{G})=\operatorname*{max}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$ $\delta^{+}(\mathrm{G})=\operatorname*{min}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\delta^{-}(\mathrm{G})=\operatorname*{min}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$  
从上述定义可以看出，引入度结点度概念的目的主要是通过对图中每个结点所关联边数进行统计分析来考察图模型的结构特征。  
【定义8.18】对于任意一个给定的有向图或无向图  $G=\langle V,E\rangle$ ，图中度数为1 的结点称为该图的悬挂结点，图中以悬挂结点为端点的边称为该图的悬挂边。如果图$G$中各个结点的度数均相同，则称该图正则图，各结点度均为$\ k$的正则图称为$\pmb{k}$-正则图。  
下面我们考察图的邻接矩阵与图中结点度之间的关系。  
假设 $G=\langle V,E\rangle$是任意给定的一个有向图或无向图，其中$V=\{v_{1},v_{2},\ldots,v_{n}\}$，$E=$$\{e_{1},e_{2},\ldots,e_{m}\}$。 $G$的邻接矩阵为：  
$$
A=(a_{i j})_{n\times n}=\left(\!\!{\begin{array}{c c c c}{a_{11}}&{a_{12}}&{\ldots}&{a_{1n}}\\ {a_{21}}&{a_{22}}&{\ldots}&{a_{2n}}\\ {\vdots}&{\ddots}&{\vdots}\\ {a_{n1}}&{a_{n2}}&{\ldots}&{a_{n n}}\end{array}}\!\!\right)
$$  
则有如下结论：  
（1）如果$G$是无向图，那么邻接矩阵𝐴中第𝑖行元素之和表示结点$v_{i}$的度数，第𝑗列元素之和表示结点$v_{j}$的度数。即有：  
$$
\deg(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};~~~~\deg\bigl(v_{j}\bigr)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（2）若G是有向图，那么邻接矩阵$A$中第𝑖行元素之和表示结点$v_{i}$的出度，第$j$列元素之和表示结点$v_{j}$的入度。简单地说，就是竖入横出。即有：  
$$
\deg^{-}(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};\qquad\deg^{+}\!\left(v_{j}\right)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（3）对于有向图G，注意到：  
$$
\sum_{j=1}^{n}\;\deg^{-}\!\left(v_{j}\right)=\sum_{i=1}^{n}\sum_{j=1}^{n}a_{i j}=\sum_{i=1}^{n}\deg^{+}\!\left(v_{i}\right)
$$  
因此，有向图中所有入度之和等于所有出度之和，这个和其实就是图的边数$m$。因为有向图的每条边均产生且仅产生一个出度和一个入度。  
对于图8-19 所示图模型$G$及如下邻接矩阵$A_{G}$，容易验证，结点度与邻接矩阵之间的数量关系。例如，$A_{G}$中第三行元素之和为3，即$v_{3}$的出度为3。
$$
\begin{gathered}v_{1}\quad v_{2}\quad v_{3}\quad v_{4}\quad v_{5}\\A_{G}=\begin{matrix}v_{1}\\v_{2}\\v_{3}\\v_{4}\end{matrix}\begin{pmatrix}0&1&0&0&0\\0&1&1&0&0\\1&1&0&1&0\\0&0&0&0&0\\0&0&0&0&0\end{pmatrix}\end{gathered}
$$  
关于图中结点度数与边的关系，有如下著名的图论基本定理：  
【定理8.1】（握手定理）假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，则该图中结点度数的总和等于边数的二倍，即有：  
$$
\sum_{v\in V}\deg(v)=2|E|
$$  
【推论8.1】图中度数为奇数的结点个数必为偶数。  
从以上定理及例题可以看出，图模型中结点的度从一种定量的角度反映了图中结点与边之间的制约关系，在一定程度上刻画了图模型的结构特征。为了更加方便地描述图模型中各个结点的度结构信息，下面给出度序列的概念：  
【定义8.19】假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，图中每个结点的图构成的自然数序列称为$G$的度序列。也就是说，若 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，则称序列：  
$$
(\deg(v_{1})\,,\deg(v_{2})\,,\cdots,\deg(v_{n}))
$$  
为图 $G$ 的度数序列，简称为度序列。 此外，对于任意一个给定的自然数序列，如果该序列能够成为某个图的度序列，则称该序列为可图化序列。  
例如，对于图8-22 所示图 $G$ ，其度数序列为 (2,3,3,4)  
![图8-22 图 $G$ ](images/77ba680d9b589e032065b86071c3f75473dc0d06736af0deb36aa2115de43d51.jpg)  
由于图模型的度要满足握手定理等基本约束要求，而且对于不同类型的图，其度序列也会有一些相应的数据特征。因此，并不是任意的自然数序列都可以构成图模型的度序列。对于任意给定的自然数序列，需要通过分析其数据特征来判断其是否为可图化序列。若是可图化序列，则可依据该序列数据来分析其所对应图的结构特征。",邻接矩阵中的行和列元素之和分别表示无向图和有向图中结点的度数或出度、入度
握手定理,描述,结点度,,"现在我们考察图模型的结构特征。从结构上看，对于任意给定的一个图模型，只要该图不是零图，总会有一些点与一些边相互联结。从生成子图的概念可以看出，图的结点构成了图模型的骨架或主体结构，因此，我们主要从结点出发考察每个结点所关联的边关联多少条边。为此，对于图中的每个结点，都定义一个数来描述该结点所关联边的个数，这就是结点度的概念，其具体定义如下：  
【定义8.16】假设图 $G=\langle V,E\rangle$是任意给定的一个无向图，对于$G$中任意一个结点 $v$ ，与该结点关联边的条数称为该结点的度数，简称为度，记为 ${\sf d e g}(v)$。图$G$中各个结点度数的最大值称为图$G$的最大度，记为$\Delta(G)$；图$G$中各个结点度数的最小值称为图$G$的最小度，记为$\delta(G)$ $\Delta(\mathrm{G})=\mathrm{max}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\};\,\,\,\delta(\mathrm{G})=\mathrm{min}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\}\,.$  
【定义8.17】设图 $G=\langle V,E\rangle$是任意给定的一个有向图，$v$是$G$中任一结点，则有：  
（1）以该结点为起点的有向边的条数，称为该结点的出度，记为$\deg^{+}(v)$；以该结点为终点的有向边的条数，称为该结点的入度，记为 $\deg^{-}(v)$。  
（2）该结点的出度与入度之和称为该结点的度，记为${\sf d e g}(v)$。 即有：  
$$
\deg(v)=\deg^{+}(v)+\deg^{-}(v)
$$  
（3）图$G$中各个结点出度与入度的最大值分别称为图$G$的最大出度和最大入度，分别记为$\Delta^{+}(\mathsf{G})$和 $\Delta^{-}(\mathsf{G})$；图$G$中各个结点出度与入度的最小值分别称为图$G$的最小出度和最小入度，分别记为$\Delta^{+}(\mathbf{G})$和 $\Delta^{-}(\mathsf{G})$，即有：  
$\Delta^{+}(\mathrm{G})=\operatorname*{max}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\Delta^{-}(\mathrm{G})=\operatorname*{max}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$ $\delta^{+}(\mathrm{G})=\operatorname*{min}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\delta^{-}(\mathrm{G})=\operatorname*{min}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$  
从上述定义可以看出，引入度结点度概念的目的主要是通过对图中每个结点所关联边数进行统计分析来考察图模型的结构特征。  
【定义8.18】对于任意一个给定的有向图或无向图  $G=\langle V,E\rangle$ ，图中度数为1 的结点称为该图的悬挂结点，图中以悬挂结点为端点的边称为该图的悬挂边。如果图$G$中各个结点的度数均相同，则称该图正则图，各结点度均为$\ k$的正则图称为$\pmb{k}$-正则图。  
下面我们考察图的邻接矩阵与图中结点度之间的关系。  
假设 $G=\langle V,E\rangle$是任意给定的一个有向图或无向图，其中$V=\{v_{1},v_{2},\ldots,v_{n}\}$，$E=$$\{e_{1},e_{2},\ldots,e_{m}\}$。 $G$的邻接矩阵为：  
$$
A=(a_{i j})_{n\times n}=\left(\!\!{\begin{array}{c c c c}{a_{11}}&{a_{12}}&{\ldots}&{a_{1n}}\\ {a_{21}}&{a_{22}}&{\ldots}&{a_{2n}}\\ {\vdots}&{\ddots}&{\vdots}\\ {a_{n1}}&{a_{n2}}&{\ldots}&{a_{n n}}\end{array}}\!\!\right)
$$  
则有如下结论：  
（1）如果$G$是无向图，那么邻接矩阵𝐴中第𝑖行元素之和表示结点$v_{i}$的度数，第𝑗列元素之和表示结点$v_{j}$的度数。即有：  
$$
\deg(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};~~~~\deg\bigl(v_{j}\bigr)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（2）若G是有向图，那么邻接矩阵$A$中第𝑖行元素之和表示结点$v_{i}$的出度，第$j$列元素之和表示结点$v_{j}$的入度。简单地说，就是竖入横出。即有：  
$$
\deg^{-}(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};\qquad\deg^{+}\!\left(v_{j}\right)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（3）对于有向图G，注意到：  
$$
\sum_{j=1}^{n}\;\deg^{-}\!\left(v_{j}\right)=\sum_{i=1}^{n}\sum_{j=1}^{n}a_{i j}=\sum_{i=1}^{n}\deg^{+}\!\left(v_{i}\right)
$$  
因此，有向图中所有入度之和等于所有出度之和，这个和其实就是图的边数$m$。因为有向图的每条边均产生且仅产生一个出度和一个入度。  
对于图8-19 所示图模型$G$及如下邻接矩阵$A_{G}$，容易验证，结点度与邻接矩阵之间的数量关系。例如，$A_{G}$中第三行元素之和为3，即$v_{3}$的出度为3。
$$
\begin{gathered}v_{1}\quad v_{2}\quad v_{3}\quad v_{4}\quad v_{5}\\A_{G}=\begin{matrix}v_{1}\\v_{2}\\v_{3}\\v_{4}\end{matrix}\begin{pmatrix}0&1&0&0&0\\0&1&1&0&0\\1&1&0&1&0\\0&0&0&0&0\\0&0&0&0&0\end{pmatrix}\end{gathered}
$$  
关于图中结点度数与边的关系，有如下著名的图论基本定理：  
【定理8.1】（握手定理）假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，则该图中结点度数的总和等于边数的二倍，即有：  
$$
\sum_{v\in V}\deg(v)=2|E|
$$  
【推论8.1】图中度数为奇数的结点个数必为偶数。  
从以上定理及例题可以看出，图模型中结点的度从一种定量的角度反映了图中结点与边之间的制约关系，在一定程度上刻画了图模型的结构特征。为了更加方便地描述图模型中各个结点的度结构信息，下面给出度序列的概念：  
【定义8.19】假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，图中每个结点的图构成的自然数序列称为$G$的度序列。也就是说，若 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，则称序列：  
$$
(\deg(v_{1})\,,\deg(v_{2})\,,\cdots,\deg(v_{n}))
$$  
为图 $G$ 的度数序列，简称为度序列。 此外，对于任意一个给定的自然数序列，如果该序列能够成为某个图的度序列，则称该序列为可图化序列。  
例如，对于图8-22 所示图 $G$ ，其度数序列为 (2,3,3,4)  
![图8-22 图 $G$ ](images/77ba680d9b589e032065b86071c3f75473dc0d06736af0deb36aa2115de43d51.jpg)  
由于图模型的度要满足握手定理等基本约束要求，而且对于不同类型的图，其度序列也会有一些相应的数据特征。因此，并不是任意的自然数序列都可以构成图模型的度序列。对于任意给定的自然数序列，需要通过分析其数据特征来判断其是否为可图化序列。若是可图化序列，则可依据该序列数据来分析其所对应图的结构特征。",握手定理表明图中所有结点度数之和等于边数的二倍
度序列,构成,结点度,,"现在我们考察图模型的结构特征。从结构上看，对于任意给定的一个图模型，只要该图不是零图，总会有一些点与一些边相互联结。从生成子图的概念可以看出，图的结点构成了图模型的骨架或主体结构，因此，我们主要从结点出发考察每个结点所关联的边关联多少条边。为此，对于图中的每个结点，都定义一个数来描述该结点所关联边的个数，这就是结点度的概念，其具体定义如下：  
【定义8.16】假设图 $G=\langle V,E\rangle$是任意给定的一个无向图，对于$G$中任意一个结点 $v$ ，与该结点关联边的条数称为该结点的度数，简称为度，记为 ${\sf d e g}(v)$。图$G$中各个结点度数的最大值称为图$G$的最大度，记为$\Delta(G)$；图$G$中各个结点度数的最小值称为图$G$的最小度，记为$\delta(G)$ $\Delta(\mathrm{G})=\mathrm{max}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\};\,\,\,\delta(\mathrm{G})=\mathrm{min}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\}\,.$  
【定义8.17】设图 $G=\langle V,E\rangle$是任意给定的一个有向图，$v$是$G$中任一结点，则有：  
（1）以该结点为起点的有向边的条数，称为该结点的出度，记为$\deg^{+}(v)$；以该结点为终点的有向边的条数，称为该结点的入度，记为 $\deg^{-}(v)$。  
（2）该结点的出度与入度之和称为该结点的度，记为${\sf d e g}(v)$。 即有：  
$$
\deg(v)=\deg^{+}(v)+\deg^{-}(v)
$$  
（3）图$G$中各个结点出度与入度的最大值分别称为图$G$的最大出度和最大入度，分别记为$\Delta^{+}(\mathsf{G})$和 $\Delta^{-}(\mathsf{G})$；图$G$中各个结点出度与入度的最小值分别称为图$G$的最小出度和最小入度，分别记为$\Delta^{+}(\mathbf{G})$和 $\Delta^{-}(\mathsf{G})$，即有：  
$\Delta^{+}(\mathrm{G})=\operatorname*{max}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\Delta^{-}(\mathrm{G})=\operatorname*{max}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$ $\delta^{+}(\mathrm{G})=\operatorname*{min}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\delta^{-}(\mathrm{G})=\operatorname*{min}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$  
从上述定义可以看出，引入度结点度概念的目的主要是通过对图中每个结点所关联边数进行统计分析来考察图模型的结构特征。  
【定义8.18】对于任意一个给定的有向图或无向图  $G=\langle V,E\rangle$ ，图中度数为1 的结点称为该图的悬挂结点，图中以悬挂结点为端点的边称为该图的悬挂边。如果图$G$中各个结点的度数均相同，则称该图正则图，各结点度均为$\ k$的正则图称为$\pmb{k}$-正则图。  
下面我们考察图的邻接矩阵与图中结点度之间的关系。  
假设 $G=\langle V,E\rangle$是任意给定的一个有向图或无向图，其中$V=\{v_{1},v_{2},\ldots,v_{n}\}$，$E=$$\{e_{1},e_{2},\ldots,e_{m}\}$。 $G$的邻接矩阵为：  
$$
A=(a_{i j})_{n\times n}=\left(\!\!{\begin{array}{c c c c}{a_{11}}&{a_{12}}&{\ldots}&{a_{1n}}\\ {a_{21}}&{a_{22}}&{\ldots}&{a_{2n}}\\ {\vdots}&{\ddots}&{\vdots}\\ {a_{n1}}&{a_{n2}}&{\ldots}&{a_{n n}}\end{array}}\!\!\right)
$$  
则有如下结论：  
（1）如果$G$是无向图，那么邻接矩阵𝐴中第𝑖行元素之和表示结点$v_{i}$的度数，第𝑗列元素之和表示结点$v_{j}$的度数。即有：  
$$
\deg(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};~~~~\deg\bigl(v_{j}\bigr)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（2）若G是有向图，那么邻接矩阵$A$中第𝑖行元素之和表示结点$v_{i}$的出度，第$j$列元素之和表示结点$v_{j}$的入度。简单地说，就是竖入横出。即有：  
$$
\deg^{-}(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};\qquad\deg^{+}\!\left(v_{j}\right)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（3）对于有向图G，注意到：  
$$
\sum_{j=1}^{n}\;\deg^{-}\!\left(v_{j}\right)=\sum_{i=1}^{n}\sum_{j=1}^{n}a_{i j}=\sum_{i=1}^{n}\deg^{+}\!\left(v_{i}\right)
$$  
因此，有向图中所有入度之和等于所有出度之和，这个和其实就是图的边数$m$。因为有向图的每条边均产生且仅产生一个出度和一个入度。  
对于图8-19 所示图模型$G$及如下邻接矩阵$A_{G}$，容易验证，结点度与邻接矩阵之间的数量关系。例如，$A_{G}$中第三行元素之和为3，即$v_{3}$的出度为3。
$$
\begin{gathered}v_{1}\quad v_{2}\quad v_{3}\quad v_{4}\quad v_{5}\\A_{G}=\begin{matrix}v_{1}\\v_{2}\\v_{3}\\v_{4}\end{matrix}\begin{pmatrix}0&1&0&0&0\\0&1&1&0&0\\1&1&0&1&0\\0&0&0&0&0\\0&0&0&0&0\end{pmatrix}\end{gathered}
$$  
关于图中结点度数与边的关系，有如下著名的图论基本定理：  
【定理8.1】（握手定理）假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，则该图中结点度数的总和等于边数的二倍，即有：  
$$
\sum_{v\in V}\deg(v)=2|E|
$$  
【推论8.1】图中度数为奇数的结点个数必为偶数。  
从以上定理及例题可以看出，图模型中结点的度从一种定量的角度反映了图中结点与边之间的制约关系，在一定程度上刻画了图模型的结构特征。为了更加方便地描述图模型中各个结点的度结构信息，下面给出度序列的概念：  
【定义8.19】假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，图中每个结点的图构成的自然数序列称为$G$的度序列。也就是说，若 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，则称序列：  
$$
(\deg(v_{1})\,,\deg(v_{2})\,,\cdots,\deg(v_{n}))
$$  
为图 $G$ 的度数序列，简称为度序列。 此外，对于任意一个给定的自然数序列，如果该序列能够成为某个图的度序列，则称该序列为可图化序列。  
例如，对于图8-22 所示图 $G$ ，其度数序列为 (2,3,3,4)  
![图8-22 图 $G$ ](images/77ba680d9b589e032065b86071c3f75473dc0d06736af0deb36aa2115de43d51.jpg)  
由于图模型的度要满足握手定理等基本约束要求，而且对于不同类型的图，其度序列也会有一些相应的数据特征。因此，并不是任意的自然数序列都可以构成图模型的度序列。对于任意给定的自然数序列，需要通过分析其数据特征来判断其是否为可图化序列。若是可图化序列，则可依据该序列数据来分析其所对应图的结构特征。",度序列是由图中各个结点度数构成的自然数序列
可图化序列,条件,度序列,,"现在我们考察图模型的结构特征。从结构上看，对于任意给定的一个图模型，只要该图不是零图，总会有一些点与一些边相互联结。从生成子图的概念可以看出，图的结点构成了图模型的骨架或主体结构，因此，我们主要从结点出发考察每个结点所关联的边关联多少条边。为此，对于图中的每个结点，都定义一个数来描述该结点所关联边的个数，这就是结点度的概念，其具体定义如下：  
【定义8.16】假设图 $G=\langle V,E\rangle$是任意给定的一个无向图，对于$G$中任意一个结点 $v$ ，与该结点关联边的条数称为该结点的度数，简称为度，记为 ${\sf d e g}(v)$。图$G$中各个结点度数的最大值称为图$G$的最大度，记为$\Delta(G)$；图$G$中各个结点度数的最小值称为图$G$的最小度，记为$\delta(G)$ $\Delta(\mathrm{G})=\mathrm{max}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\};\,\,\,\delta(\mathrm{G})=\mathrm{min}\{\mathrm{deg}(\mathrm{v})|v_{\in}V(G)\}\,.$  
【定义8.17】设图 $G=\langle V,E\rangle$是任意给定的一个有向图，$v$是$G$中任一结点，则有：  
（1）以该结点为起点的有向边的条数，称为该结点的出度，记为$\deg^{+}(v)$；以该结点为终点的有向边的条数，称为该结点的入度，记为 $\deg^{-}(v)$。  
（2）该结点的出度与入度之和称为该结点的度，记为${\sf d e g}(v)$。 即有：  
$$
\deg(v)=\deg^{+}(v)+\deg^{-}(v)
$$  
（3）图$G$中各个结点出度与入度的最大值分别称为图$G$的最大出度和最大入度，分别记为$\Delta^{+}(\mathsf{G})$和 $\Delta^{-}(\mathsf{G})$；图$G$中各个结点出度与入度的最小值分别称为图$G$的最小出度和最小入度，分别记为$\Delta^{+}(\mathbf{G})$和 $\Delta^{-}(\mathsf{G})$，即有：  
$\Delta^{+}(\mathrm{G})=\operatorname*{max}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\Delta^{-}(\mathrm{G})=\operatorname*{max}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$ $\delta^{+}(\mathrm{G})=\operatorname*{min}\{\deg^{+}(v)|v\!\in\!V(G)\};\,\,\,\delta^{-}(\mathrm{G})=\operatorname*{min}\{\,\,\deg^{-}(v)|v\!\in\!V(G)\}$  
从上述定义可以看出，引入度结点度概念的目的主要是通过对图中每个结点所关联边数进行统计分析来考察图模型的结构特征。  
【定义8.18】对于任意一个给定的有向图或无向图  $G=\langle V,E\rangle$ ，图中度数为1 的结点称为该图的悬挂结点，图中以悬挂结点为端点的边称为该图的悬挂边。如果图$G$中各个结点的度数均相同，则称该图正则图，各结点度均为$\ k$的正则图称为$\pmb{k}$-正则图。  
下面我们考察图的邻接矩阵与图中结点度之间的关系。  
假设 $G=\langle V,E\rangle$是任意给定的一个有向图或无向图，其中$V=\{v_{1},v_{2},\ldots,v_{n}\}$，$E=$$\{e_{1},e_{2},\ldots,e_{m}\}$。 $G$的邻接矩阵为：  
$$
A=(a_{i j})_{n\times n}=\left(\!\!{\begin{array}{c c c c}{a_{11}}&{a_{12}}&{\ldots}&{a_{1n}}\\ {a_{21}}&{a_{22}}&{\ldots}&{a_{2n}}\\ {\vdots}&{\ddots}&{\vdots}\\ {a_{n1}}&{a_{n2}}&{\ldots}&{a_{n n}}\end{array}}\!\!\right)
$$  
则有如下结论：  
（1）如果$G$是无向图，那么邻接矩阵𝐴中第𝑖行元素之和表示结点$v_{i}$的度数，第𝑗列元素之和表示结点$v_{j}$的度数。即有：  
$$
\deg(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};~~~~\deg\bigl(v_{j}\bigr)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（2）若G是有向图，那么邻接矩阵$A$中第𝑖行元素之和表示结点$v_{i}$的出度，第$j$列元素之和表示结点$v_{j}$的入度。简单地说，就是竖入横出。即有：  
$$
\deg^{-}(v_{i})=\sum_{k=1}^{n}a_{i k}+a_{i i};\qquad\deg^{+}\!\left(v_{j}\right)=\sum_{k=1}^{n}a_{k j}+a_{j j}
$$  
（3）对于有向图G，注意到：  
$$
\sum_{j=1}^{n}\;\deg^{-}\!\left(v_{j}\right)=\sum_{i=1}^{n}\sum_{j=1}^{n}a_{i j}=\sum_{i=1}^{n}\deg^{+}\!\left(v_{i}\right)
$$  
因此，有向图中所有入度之和等于所有出度之和，这个和其实就是图的边数$m$。因为有向图的每条边均产生且仅产生一个出度和一个入度。  
对于图8-19 所示图模型$G$及如下邻接矩阵$A_{G}$，容易验证，结点度与邻接矩阵之间的数量关系。例如，$A_{G}$中第三行元素之和为3，即$v_{3}$的出度为3。
$$
\begin{gathered}v_{1}\quad v_{2}\quad v_{3}\quad v_{4}\quad v_{5}\\A_{G}=\begin{matrix}v_{1}\\v_{2}\\v_{3}\\v_{4}\end{matrix}\begin{pmatrix}0&1&0&0&0\\0&1&1&0&0\\1&1&0&1&0\\0&0&0&0&0\\0&0&0&0&0\end{pmatrix}\end{gathered}
$$  
关于图中结点度数与边的关系，有如下著名的图论基本定理：  
【定理8.1】（握手定理）假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，则该图中结点度数的总和等于边数的二倍，即有：  
$$
\sum_{v\in V}\deg(v)=2|E|
$$  
【推论8.1】图中度数为奇数的结点个数必为偶数。  
从以上定理及例题可以看出，图模型中结点的度从一种定量的角度反映了图中结点与边之间的制约关系，在一定程度上刻画了图模型的结构特征。为了更加方便地描述图模型中各个结点的度结构信息，下面给出度序列的概念：  
【定义8.19】假设$G=\langle V,E\rangle$是任意给定的一个有向图或无向图，图中每个结点的图构成的自然数序列称为$G$的度序列。也就是说，若 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，则称序列：  
$$
(\deg(v_{1})\,,\deg(v_{2})\,,\cdots,\deg(v_{n}))
$$  
为图 $G$ 的度数序列，简称为度序列。 此外，对于任意一个给定的自然数序列，如果该序列能够成为某个图的度序列，则称该序列为可图化序列。  
例如，对于图8-22 所示图 $G$ ，其度数序列为 (2,3,3,4)  
![图8-22 图 $G$ ](images/77ba680d9b589e032065b86071c3f75473dc0d06736af0deb36aa2115de43d51.jpg)  
由于图模型的度要满足握手定理等基本约束要求，而且对于不同类型的图，其度序列也会有一些相应的数据特征。因此，并不是任意的自然数序列都可以构成图模型的度序列。对于任意给定的自然数序列，需要通过分析其数据特征来判断其是否为可图化序列。若是可图化序列，则可依据该序列数据来分析其所对应图的结构特征。",可图化序列是能够成为某个图度序列的自然数序列
图同构,定义,图模型,,"前面我们讨论了单个图模型的结构性质。有时候需要比较两个图在结构上的差异和相同之处。 由于在图模型的定义中，不考虑图中结点之间的位置关系和图中边的长短，因此可能会出现表面上很不相同，但是结构却完全相同的两个图模型。例如，图8-24 所示的图$G_{1}$与图$G_{2}$、图$G_{3}$与图$G_{4}$、图$G_{5}$与图$G_{6}$都是属于这种情况。  
![图8-24 图的同构关系 ](images/206afb46cb61220a5a49b4724e9f4e7fcb734a50e6d0ded3cfeece01157b3ad0.jpg)  
不难发现，对于这三对表面不同而结构相同的图模型，每对图模型之间的差异仅在于两者结点的排列次序不同，其它方面都相同。也就是说，两个图模型的结点之间存在一种双射关系，图的结构在这种双射关系下保持不变。由此得到如下同构的概念：  
【定义8.20】假设$G=\langle V,E\rangle$和$G^{\prime}=\langle V^{\prime},E^{\prime}\rangle$是任意给定的两个简单无向图或有向图，若存在双射函数 $g\colon V\to V^{\prime}$，使得：  
则称 $G$ 与 $G^{\prime}$之间具有同构关系，简称为$G$ 与 $G^{\prime}$同构，记为 $G\cong G^{\prime}$。 此时，映射$g\colon V\to$$V^{\prime}$ 称为   $G$   与   $G^{\prime}$ 之间同构映射。  
根据上述定义，图8-24 所示的图$G_{1}$与图$G_{2}$、图$G_{3}$与图$G_{4}$、图$G_{5}$与图$G_{6}$之间分别是同构关系。即有：$G_{1}\cong G_{2},\ G_{3}\cong G_{4},\ G_{5}\cong G_{6}.$。例如，图$G_{5}$与图$G_{6}$之间的同构映射为：$g(v_{1})=$$a$ $g(v_{2})=b$ $g(v_{3})=c;\;\;g(v_{4})=d;\;\;g(v_{5})=e;\;\;g(v_{6})=f;\;\;g(v_{7})=g;\;\;g(v_{8})=h$。  
两个图模型之间的同构关系显然满足自反性、对称性和传递性，因而是一种等价关系。由此可以根据图的同构关系对图进行分类，将彼此同构的图模型归为一类。例如，对于图8-25 所示的三个图模型$G_{1},\ G_{2},G_{3}$，从表面上看，三者之间差异很大，但是它们之间是彼此同构的，即有：$G_{1}\cong G_{2}\cong G_{3}$。因此，这三个图属于同一类型，或者说从同构抽象的角度看，这三个图是同一个图。读者可自己找出它们之间的同构映射。  
![图8-25 三个图相互同构 ](images/8c2408eed17c7f12b220e0e4f992d1fa39665620f97477ada9c53eea9bbe3e01.jpg)  
由以上分析讨论可知，寻找或判定图模型之间的同构关系是一件非常重要的工作。判定图同构关系的关键问题在于如何找到同构图之间的同构映射。咋看这个问题并不复杂。因为，同构图模型之间的差异仅仅在于图中结点排列次序的不同，好像可以通过枚举结点的排列次序找到同构图之间的同构映射。具体地说， 对于含有相同结点的两个图模型，通过不断调整 其中一个图模型的结点排列次序，从而改变其邻接矩阵的行列次序，如果能够使得两个图的邻接矩阵通过行列交换变得相等，则这两个图必然同构。然而，这并不是一个有效的方法，因为当图中结点数较多时，结点的排列数以阶乘的速度增长，计算量变得巨大而不可行。  
到目前为止，还没有找到判定两个图是否同构的有效方法，只能对一些简单图根据定义进行判别，具体地说，就是寻找同构图之间的不变量，例如：结点数相同、边数相同、度数相同的结点个数相同、同构映射对应点的度相同、同构映射对应点的所有邻接点分别具有相同的度，等等，不再一一枚举。不过这些不变量只是必要条件而非充分条件，因而一般首先使用这些条件判定两个图之间不同构，如果不能确定不同构，则转而使用各种方法寻找两者之间的同构映射，证明两者同构。  
值得注意的是，两个图的外观比较相似并不能说明两者一定是同构的。具体可参考如下例题中的两对图模型，它们之间的外观尽管很相似，但并不同构。",图同构是指两个图模型之间存在双射函数，使得图的结构在这种双射关系下保持不变。
图同构,包含,同构映射,,"前面我们讨论了单个图模型的结构性质。有时候需要比较两个图在结构上的差异和相同之处。 由于在图模型的定义中，不考虑图中结点之间的位置关系和图中边的长短，因此可能会出现表面上很不相同，但是结构却完全相同的两个图模型。例如，图8-24 所示的图$G_{1}$与图$G_{2}$、图$G_{3}$与图$G_{4}$、图$G_{5}$与图$G_{6}$都是属于这种情况。  
![图8-24 图的同构关系 ](images/206afb46cb61220a5a49b4724e9f4e7fcb734a50e6d0ded3cfeece01157b3ad0.jpg)  
不难发现，对于这三对表面不同而结构相同的图模型，每对图模型之间的差异仅在于两者结点的排列次序不同，其它方面都相同。也就是说，两个图模型的结点之间存在一种双射关系，图的结构在这种双射关系下保持不变。由此得到如下同构的概念：  
【定义8.20】假设$G=\langle V,E\rangle$和$G^{\prime}=\langle V^{\prime},E^{\prime}\rangle$是任意给定的两个简单无向图或有向图，若存在双射函数 $g\colon V\to V^{\prime}$，使得：  
则称 $G$ 与 $G^{\prime}$之间具有同构关系，简称为$G$ 与 $G^{\prime}$同构，记为 $G\cong G^{\prime}$。 此时，映射$g\colon V\to$$V^{\prime}$ 称为   $G$   与   $G^{\prime}$ 之间同构映射。  
根据上述定义，图8-24 所示的图$G_{1}$与图$G_{2}$、图$G_{3}$与图$G_{4}$、图$G_{5}$与图$G_{6}$之间分别是同构关系。即有：$G_{1}\cong G_{2},\ G_{3}\cong G_{4},\ G_{5}\cong G_{6}.$。例如，图$G_{5}$与图$G_{6}$之间的同构映射为：$g(v_{1})=$$a$ $g(v_{2})=b$ $g(v_{3})=c;\;\;g(v_{4})=d;\;\;g(v_{5})=e;\;\;g(v_{6})=f;\;\;g(v_{7})=g;\;\;g(v_{8})=h$。  
两个图模型之间的同构关系显然满足自反性、对称性和传递性，因而是一种等价关系。由此可以根据图的同构关系对图进行分类，将彼此同构的图模型归为一类。例如，对于图8-25 所示的三个图模型$G_{1},\ G_{2},G_{3}$，从表面上看，三者之间差异很大，但是它们之间是彼此同构的，即有：$G_{1}\cong G_{2}\cong G_{3}$。因此，这三个图属于同一类型，或者说从同构抽象的角度看，这三个图是同一个图。读者可自己找出它们之间的同构映射。  
![图8-25 三个图相互同构 ](images/8c2408eed17c7f12b220e0e4f992d1fa39665620f97477ada9c53eea9bbe3e01.jpg)  
由以上分析讨论可知，寻找或判定图模型之间的同构关系是一件非常重要的工作。判定图同构关系的关键问题在于如何找到同构图之间的同构映射。咋看这个问题并不复杂。因为，同构图模型之间的差异仅仅在于图中结点排列次序的不同，好像可以通过枚举结点的排列次序找到同构图之间的同构映射。具体地说， 对于含有相同结点的两个图模型，通过不断调整 其中一个图模型的结点排列次序，从而改变其邻接矩阵的行列次序，如果能够使得两个图的邻接矩阵通过行列交换变得相等，则这两个图必然同构。然而，这并不是一个有效的方法，因为当图中结点数较多时，结点的排列数以阶乘的速度增长，计算量变得巨大而不可行。  
到目前为止，还没有找到判定两个图是否同构的有效方法，只能对一些简单图根据定义进行判别，具体地说，就是寻找同构图之间的不变量，例如：结点数相同、边数相同、度数相同的结点个数相同、同构映射对应点的度相同、同构映射对应点的所有邻接点分别具有相同的度，等等，不再一一枚举。不过这些不变量只是必要条件而非充分条件，因而一般首先使用这些条件判定两个图之间不同构，如果不能确定不同构，则转而使用各种方法寻找两者之间的同构映射，证明两者同构。  
值得注意的是，两个图的外观比较相似并不能说明两者一定是同构的。具体可参考如下例题中的两对图模型，它们之间的外观尽管很相似，但并不同构。",图同构包含同构映射，即存在双射函数将一个图的结点映射到另一个图的结点，保持图的结构不变。
图同构,满足,等价关系,,"前面我们讨论了单个图模型的结构性质。有时候需要比较两个图在结构上的差异和相同之处。 由于在图模型的定义中，不考虑图中结点之间的位置关系和图中边的长短，因此可能会出现表面上很不相同，但是结构却完全相同的两个图模型。例如，图8-24 所示的图$G_{1}$与图$G_{2}$、图$G_{3}$与图$G_{4}$、图$G_{5}$与图$G_{6}$都是属于这种情况。  
![图8-24 图的同构关系 ](images/206afb46cb61220a5a49b4724e9f4e7fcb734a50e6d0ded3cfeece01157b3ad0.jpg)  
不难发现，对于这三对表面不同而结构相同的图模型，每对图模型之间的差异仅在于两者结点的排列次序不同，其它方面都相同。也就是说，两个图模型的结点之间存在一种双射关系，图的结构在这种双射关系下保持不变。由此得到如下同构的概念：  
【定义8.20】假设$G=\langle V,E\rangle$和$G^{\prime}=\langle V^{\prime},E^{\prime}\rangle$是任意给定的两个简单无向图或有向图，若存在双射函数 $g\colon V\to V^{\prime}$，使得：  
则称 $G$ 与 $G^{\prime}$之间具有同构关系，简称为$G$ 与 $G^{\prime}$同构，记为 $G\cong G^{\prime}$。 此时，映射$g\colon V\to$$V^{\prime}$ 称为   $G$   与   $G^{\prime}$ 之间同构映射。  
根据上述定义，图8-24 所示的图$G_{1}$与图$G_{2}$、图$G_{3}$与图$G_{4}$、图$G_{5}$与图$G_{6}$之间分别是同构关系。即有：$G_{1}\cong G_{2},\ G_{3}\cong G_{4},\ G_{5}\cong G_{6}.$。例如，图$G_{5}$与图$G_{6}$之间的同构映射为：$g(v_{1})=$$a$ $g(v_{2})=b$ $g(v_{3})=c;\;\;g(v_{4})=d;\;\;g(v_{5})=e;\;\;g(v_{6})=f;\;\;g(v_{7})=g;\;\;g(v_{8})=h$。  
两个图模型之间的同构关系显然满足自反性、对称性和传递性，因而是一种等价关系。由此可以根据图的同构关系对图进行分类，将彼此同构的图模型归为一类。例如，对于图8-25 所示的三个图模型$G_{1},\ G_{2},G_{3}$，从表面上看，三者之间差异很大，但是它们之间是彼此同构的，即有：$G_{1}\cong G_{2}\cong G_{3}$。因此，这三个图属于同一类型，或者说从同构抽象的角度看，这三个图是同一个图。读者可自己找出它们之间的同构映射。  
![图8-25 三个图相互同构 ](images/8c2408eed17c7f12b220e0e4f992d1fa39665620f97477ada9c53eea9bbe3e01.jpg)  
由以上分析讨论可知，寻找或判定图模型之间的同构关系是一件非常重要的工作。判定图同构关系的关键问题在于如何找到同构图之间的同构映射。咋看这个问题并不复杂。因为，同构图模型之间的差异仅仅在于图中结点排列次序的不同，好像可以通过枚举结点的排列次序找到同构图之间的同构映射。具体地说， 对于含有相同结点的两个图模型，通过不断调整 其中一个图模型的结点排列次序，从而改变其邻接矩阵的行列次序，如果能够使得两个图的邻接矩阵通过行列交换变得相等，则这两个图必然同构。然而，这并不是一个有效的方法，因为当图中结点数较多时，结点的排列数以阶乘的速度增长，计算量变得巨大而不可行。  
到目前为止，还没有找到判定两个图是否同构的有效方法，只能对一些简单图根据定义进行判别，具体地说，就是寻找同构图之间的不变量，例如：结点数相同、边数相同、度数相同的结点个数相同、同构映射对应点的度相同、同构映射对应点的所有邻接点分别具有相同的度，等等，不再一一枚举。不过这些不变量只是必要条件而非充分条件，因而一般首先使用这些条件判定两个图之间不同构，如果不能确定不同构，则转而使用各种方法寻找两者之间的同构映射，证明两者同构。  
值得注意的是，两个图的外观比较相似并不能说明两者一定是同构的。具体可参考如下例题中的两对图模型，它们之间的外观尽管很相似，但并不同构。",图同构满足自反性、对称性和传递性，因而是一种等价关系。
图同构,应用,图分类,,"前面我们讨论了单个图模型的结构性质。有时候需要比较两个图在结构上的差异和相同之处。 由于在图模型的定义中，不考虑图中结点之间的位置关系和图中边的长短，因此可能会出现表面上很不相同，但是结构却完全相同的两个图模型。例如，图8-24 所示的图$G_{1}$与图$G_{2}$、图$G_{3}$与图$G_{4}$、图$G_{5}$与图$G_{6}$都是属于这种情况。  
![图8-24 图的同构关系 ](images/206afb46cb61220a5a49b4724e9f4e7fcb734a50e6d0ded3cfeece01157b3ad0.jpg)  
不难发现，对于这三对表面不同而结构相同的图模型，每对图模型之间的差异仅在于两者结点的排列次序不同，其它方面都相同。也就是说，两个图模型的结点之间存在一种双射关系，图的结构在这种双射关系下保持不变。由此得到如下同构的概念：  
【定义8.20】假设$G=\langle V,E\rangle$和$G^{\prime}=\langle V^{\prime},E^{\prime}\rangle$是任意给定的两个简单无向图或有向图，若存在双射函数 $g\colon V\to V^{\prime}$，使得：  
则称 $G$ 与 $G^{\prime}$之间具有同构关系，简称为$G$ 与 $G^{\prime}$同构，记为 $G\cong G^{\prime}$。 此时，映射$g\colon V\to$$V^{\prime}$ 称为   $G$   与   $G^{\prime}$ 之间同构映射。  
根据上述定义，图8-24 所示的图$G_{1}$与图$G_{2}$、图$G_{3}$与图$G_{4}$、图$G_{5}$与图$G_{6}$之间分别是同构关系。即有：$G_{1}\cong G_{2},\ G_{3}\cong G_{4},\ G_{5}\cong G_{6}.$。例如，图$G_{5}$与图$G_{6}$之间的同构映射为：$g(v_{1})=$$a$ $g(v_{2})=b$ $g(v_{3})=c;\;\;g(v_{4})=d;\;\;g(v_{5})=e;\;\;g(v_{6})=f;\;\;g(v_{7})=g;\;\;g(v_{8})=h$。  
两个图模型之间的同构关系显然满足自反性、对称性和传递性，因而是一种等价关系。由此可以根据图的同构关系对图进行分类，将彼此同构的图模型归为一类。例如，对于图8-25 所示的三个图模型$G_{1},\ G_{2},G_{3}$，从表面上看，三者之间差异很大，但是它们之间是彼此同构的，即有：$G_{1}\cong G_{2}\cong G_{3}$。因此，这三个图属于同一类型，或者说从同构抽象的角度看，这三个图是同一个图。读者可自己找出它们之间的同构映射。  
![图8-25 三个图相互同构 ](images/8c2408eed17c7f12b220e0e4f992d1fa39665620f97477ada9c53eea9bbe3e01.jpg)  
由以上分析讨论可知，寻找或判定图模型之间的同构关系是一件非常重要的工作。判定图同构关系的关键问题在于如何找到同构图之间的同构映射。咋看这个问题并不复杂。因为，同构图模型之间的差异仅仅在于图中结点排列次序的不同，好像可以通过枚举结点的排列次序找到同构图之间的同构映射。具体地说， 对于含有相同结点的两个图模型，通过不断调整 其中一个图模型的结点排列次序，从而改变其邻接矩阵的行列次序，如果能够使得两个图的邻接矩阵通过行列交换变得相等，则这两个图必然同构。然而，这并不是一个有效的方法，因为当图中结点数较多时，结点的排列数以阶乘的速度增长，计算量变得巨大而不可行。  
到目前为止，还没有找到判定两个图是否同构的有效方法，只能对一些简单图根据定义进行判别，具体地说，就是寻找同构图之间的不变量，例如：结点数相同、边数相同、度数相同的结点个数相同、同构映射对应点的度相同、同构映射对应点的所有邻接点分别具有相同的度，等等，不再一一枚举。不过这些不变量只是必要条件而非充分条件，因而一般首先使用这些条件判定两个图之间不同构，如果不能确定不同构，则转而使用各种方法寻找两者之间的同构映射，证明两者同构。  
值得注意的是，两个图的外观比较相似并不能说明两者一定是同构的。具体可参考如下例题中的两对图模型，它们之间的外观尽管很相似，但并不同构。",可以根据图的同构关系对图进行分类，将彼此同构的图模型归为一类。
图同构,关键问题,同构判定,,"前面我们讨论了单个图模型的结构性质。有时候需要比较两个图在结构上的差异和相同之处。 由于在图模型的定义中，不考虑图中结点之间的位置关系和图中边的长短，因此可能会出现表面上很不相同，但是结构却完全相同的两个图模型。例如，图8-24 所示的图$G_{1}$与图$G_{2}$、图$G_{3}$与图$G_{4}$、图$G_{5}$与图$G_{6}$都是属于这种情况。  
![图8-24 图的同构关系 ](images/206afb46cb61220a5a49b4724e9f4e7fcb734a50e6d0ded3cfeece01157b3ad0.jpg)  
不难发现，对于这三对表面不同而结构相同的图模型，每对图模型之间的差异仅在于两者结点的排列次序不同，其它方面都相同。也就是说，两个图模型的结点之间存在一种双射关系，图的结构在这种双射关系下保持不变。由此得到如下同构的概念：  
【定义8.20】假设$G=\langle V,E\rangle$和$G^{\prime}=\langle V^{\prime},E^{\prime}\rangle$是任意给定的两个简单无向图或有向图，若存在双射函数 $g\colon V\to V^{\prime}$，使得：  
则称 $G$ 与 $G^{\prime}$之间具有同构关系，简称为$G$ 与 $G^{\prime}$同构，记为 $G\cong G^{\prime}$。 此时，映射$g\colon V\to$$V^{\prime}$ 称为   $G$   与   $G^{\prime}$ 之间同构映射。  
根据上述定义，图8-24 所示的图$G_{1}$与图$G_{2}$、图$G_{3}$与图$G_{4}$、图$G_{5}$与图$G_{6}$之间分别是同构关系。即有：$G_{1}\cong G_{2},\ G_{3}\cong G_{4},\ G_{5}\cong G_{6}.$。例如，图$G_{5}$与图$G_{6}$之间的同构映射为：$g(v_{1})=$$a$ $g(v_{2})=b$ $g(v_{3})=c;\;\;g(v_{4})=d;\;\;g(v_{5})=e;\;\;g(v_{6})=f;\;\;g(v_{7})=g;\;\;g(v_{8})=h$。  
两个图模型之间的同构关系显然满足自反性、对称性和传递性，因而是一种等价关系。由此可以根据图的同构关系对图进行分类，将彼此同构的图模型归为一类。例如，对于图8-25 所示的三个图模型$G_{1},\ G_{2},G_{3}$，从表面上看，三者之间差异很大，但是它们之间是彼此同构的，即有：$G_{1}\cong G_{2}\cong G_{3}$。因此，这三个图属于同一类型，或者说从同构抽象的角度看，这三个图是同一个图。读者可自己找出它们之间的同构映射。  
![图8-25 三个图相互同构 ](images/8c2408eed17c7f12b220e0e4f992d1fa39665620f97477ada9c53eea9bbe3e01.jpg)  
由以上分析讨论可知，寻找或判定图模型之间的同构关系是一件非常重要的工作。判定图同构关系的关键问题在于如何找到同构图之间的同构映射。咋看这个问题并不复杂。因为，同构图模型之间的差异仅仅在于图中结点排列次序的不同，好像可以通过枚举结点的排列次序找到同构图之间的同构映射。具体地说， 对于含有相同结点的两个图模型，通过不断调整 其中一个图模型的结点排列次序，从而改变其邻接矩阵的行列次序，如果能够使得两个图的邻接矩阵通过行列交换变得相等，则这两个图必然同构。然而，这并不是一个有效的方法，因为当图中结点数较多时，结点的排列数以阶乘的速度增长，计算量变得巨大而不可行。  
到目前为止，还没有找到判定两个图是否同构的有效方法，只能对一些简单图根据定义进行判别，具体地说，就是寻找同构图之间的不变量，例如：结点数相同、边数相同、度数相同的结点个数相同、同构映射对应点的度相同、同构映射对应点的所有邻接点分别具有相同的度，等等，不再一一枚举。不过这些不变量只是必要条件而非充分条件，因而一般首先使用这些条件判定两个图之间不同构，如果不能确定不同构，则转而使用各种方法寻找两者之间的同构映射，证明两者同构。  
值得注意的是，两个图的外观比较相似并不能说明两者一定是同构的。具体可参考如下例题中的两对图模型，它们之间的外观尽管很相似，但并不同构。",判定图同构关系的关键问题在于如何找到同构图之间的同构映射。
图同构,必要条件,不变量,,"前面我们讨论了单个图模型的结构性质。有时候需要比较两个图在结构上的差异和相同之处。 由于在图模型的定义中，不考虑图中结点之间的位置关系和图中边的长短，因此可能会出现表面上很不相同，但是结构却完全相同的两个图模型。例如，图8-24 所示的图$G_{1}$与图$G_{2}$、图$G_{3}$与图$G_{4}$、图$G_{5}$与图$G_{6}$都是属于这种情况。  
![图8-24 图的同构关系 ](images/206afb46cb61220a5a49b4724e9f4e7fcb734a50e6d0ded3cfeece01157b3ad0.jpg)  
不难发现，对于这三对表面不同而结构相同的图模型，每对图模型之间的差异仅在于两者结点的排列次序不同，其它方面都相同。也就是说，两个图模型的结点之间存在一种双射关系，图的结构在这种双射关系下保持不变。由此得到如下同构的概念：  
【定义8.20】假设$G=\langle V,E\rangle$和$G^{\prime}=\langle V^{\prime},E^{\prime}\rangle$是任意给定的两个简单无向图或有向图，若存在双射函数 $g\colon V\to V^{\prime}$，使得：  
则称 $G$ 与 $G^{\prime}$之间具有同构关系，简称为$G$ 与 $G^{\prime}$同构，记为 $G\cong G^{\prime}$。 此时，映射$g\colon V\to$$V^{\prime}$ 称为   $G$   与   $G^{\prime}$ 之间同构映射。  
根据上述定义，图8-24 所示的图$G_{1}$与图$G_{2}$、图$G_{3}$与图$G_{4}$、图$G_{5}$与图$G_{6}$之间分别是同构关系。即有：$G_{1}\cong G_{2},\ G_{3}\cong G_{4},\ G_{5}\cong G_{6}.$。例如，图$G_{5}$与图$G_{6}$之间的同构映射为：$g(v_{1})=$$a$ $g(v_{2})=b$ $g(v_{3})=c;\;\;g(v_{4})=d;\;\;g(v_{5})=e;\;\;g(v_{6})=f;\;\;g(v_{7})=g;\;\;g(v_{8})=h$。  
两个图模型之间的同构关系显然满足自反性、对称性和传递性，因而是一种等价关系。由此可以根据图的同构关系对图进行分类，将彼此同构的图模型归为一类。例如，对于图8-25 所示的三个图模型$G_{1},\ G_{2},G_{3}$，从表面上看，三者之间差异很大，但是它们之间是彼此同构的，即有：$G_{1}\cong G_{2}\cong G_{3}$。因此，这三个图属于同一类型，或者说从同构抽象的角度看，这三个图是同一个图。读者可自己找出它们之间的同构映射。  
![图8-25 三个图相互同构 ](images/8c2408eed17c7f12b220e0e4f992d1fa39665620f97477ada9c53eea9bbe3e01.jpg)  
由以上分析讨论可知，寻找或判定图模型之间的同构关系是一件非常重要的工作。判定图同构关系的关键问题在于如何找到同构图之间的同构映射。咋看这个问题并不复杂。因为，同构图模型之间的差异仅仅在于图中结点排列次序的不同，好像可以通过枚举结点的排列次序找到同构图之间的同构映射。具体地说， 对于含有相同结点的两个图模型，通过不断调整 其中一个图模型的结点排列次序，从而改变其邻接矩阵的行列次序，如果能够使得两个图的邻接矩阵通过行列交换变得相等，则这两个图必然同构。然而，这并不是一个有效的方法，因为当图中结点数较多时，结点的排列数以阶乘的速度增长，计算量变得巨大而不可行。  
到目前为止，还没有找到判定两个图是否同构的有效方法，只能对一些简单图根据定义进行判别，具体地说，就是寻找同构图之间的不变量，例如：结点数相同、边数相同、度数相同的结点个数相同、同构映射对应点的度相同、同构映射对应点的所有邻接点分别具有相同的度，等等，不再一一枚举。不过这些不变量只是必要条件而非充分条件，因而一般首先使用这些条件判定两个图之间不同构，如果不能确定不同构，则转而使用各种方法寻找两者之间的同构映射，证明两者同构。  
值得注意的是，两个图的外观比较相似并不能说明两者一定是同构的。具体可参考如下例题中的两对图模型，它们之间的外观尽管很相似，但并不同构。",判定图同构的必要条件包括结点数相同、边数相同、度数相同的结点个数相同等，但非充分条件。
通路,包含,回路,,"前面我们讨论的图模型结构主要是图中结点与边的性质与联系，考察结点之间是否有边联结，换句话说，就是考察图中结点与结点之间的直接联系或直接关系。事实上，在很多情况下，图中结点之间的存在一些以其它一些中间结点为传递媒介的间接联系或间接关系。 例如，在现实世界中，常常考虑这样的问题：一个旅客如何乘高铁从一个城市经过若干个城市到达另一个目的地城市。 将这类问题进行抽象就成为如图8-28 所示图模型的问题，即如何从图中的一个给定结点开始，沿着多个边和结点连续移动到另一个指定的结点。  
![图8-28 部分城市高铁连接图  ](images/696b1dc16cae3150101fa23827543d58e80eb5b132e5b733a120daf06e5316d0.jpg)  
由以上分析可知，图模型中结点之间存在着经由多个边和多个结点的间接联系。对于存在间接联系的两个结点，可以从其中的一个结点出发，沿着作为其联系媒介的多个边和多个结点之间移动，就可达到另外一个结点。显然，这些边和结点构成了联结这两个结点的一个通路。由此得到图模型中通路的相关概念，具体定义如下：  
【定义8.21】设$G=\langle V,E\rangle$ 是任意给定的一个有向图或者无向图，$\boldsymbol{T}$为图$G$ 中顶点和边的相继交替出现的序列，即$\varGamma=v_{0}e_{1}v_{1}e_{2}v_{2}\ldots e_{k}v_{k}\,$。如果对于$i=1,2,\cdots,k$，均有${v_{i-1}}$ 和 $v_{i}$ 是 $e_{i}$ 的两个端点（当 $G$ 为有向图时，要求 $v_{i-1}$ 为 $e_{i}$ 的始点，${v}_{i}$ 为 $e_{i}$ 的终点），则称 $\varGamma$为结点 $v_{0}$ 到结点 $v_{k}$ 的一条通路，$v_{0}$ 和 $v_{l}$ 分别称为该通路的始点和终点，统称为通路的端点。通路$T$ 中所含边的数目 $k$称为$ T$ 的长度。当 $v_{0}=v_{k}$ 时，称该通路称为回路。  
![图8-29 图模型的通路  ](images/1d1c6154df6373d2cdb3faac71f53b624b61d1aa104aceed6cc19294e272f07e.jpg)  
例如，对于如图8-29 (a)所示的无向图，$v_{1}e_{1}v_{2}e_{2}v_{5}e_{6}v_{3}$便是一条通路$\Gamma$，$v_{1}$ 是该通路$\Gamma$的始点$v_{3}$ 是该通路$\Gamma$的终点$v_{1}$ 和 $v_{3}$ 都称为通路$\Gamma$的端点。其中通路$\Gamma$的长度为3。 特别地，对于通路$\ v_{1}e_{1}v_{2}e_{2}v_{5}e_{6}v_{3}e_{3}v_{1}$，则是回路。  
同样，对于如图8-29 (b)所示的有向图，$v_{1}e_{3}v_{2}e_{4}v_{5}e_{8}v_{4}e_{10}v_{3}e_{6}v_{6}$便是一条通路$\Gamma$，$v_{1}$ 是该通路$\Gamma$的始点，$v_{6}$ 是该通路$\Gamma$的终点，$v_{1}$ 和 $v_{6}$ 都称为通路$\Gamma$的端点。其中通路$\Gamma$的长度为5。 特别地，对于通路$\cdot v_{5}e_{9}v_{4}e_{10}v_{3}e_{5}v_{5}$，则是回路。  
在上述定义中，回路是一种特殊的通路，即起点等于终点的通路。但是，在习惯上我们所说的通路一般都不包含回路，也就是说不是回路的通路。因此，以后除非特别说明，我们所说的通路均是指不是回路的通路。  
下面定义通路和回路的各种类型：  
【定义8.22】设$G=\langle V,E\rangle$ 是任意给定的一个有向图或者无向图，$\boldsymbol{T}$为图$G$ 中分别以$v_{0}$和$v_{k}$为起点和终点的通路，即$\varGamma=v_{0}e_{1}v_{1}e_{2}v_{2}\ldots e_{k}v_{k}$，则有：  
（1）若 $\Gamma$ 中所有边各异，则称 $\Gamma$为简单通路或简单路径；若 $$\Gamma$$ 中所有边各异且$\boldsymbol{v}_{0}=$$\boldsymbol{v}_{k}$ 时，称 $$\Gamma$$为简单回路。  
（2）若 $\Gamma$中除 $v_{0},v_{k}$ 以外的所有结点各异（从而所有边也各异），则称 $$\Gamma$$  为基本通路或者基本路径。若 $v_{0}=v_{k}$ 且除 $v_{0},v_{k}$ 以外的所有结点各异，则称 $$\Gamma$$  为基本回路或者圈。  
（3）若 $\Gamma$  中有边重复出现，则称其为复杂通路，若还有 $v_{0}=v_{k}$ ，则称其为复杂回路。  
显然，基本通路必定是简单通路，基本回路必定是简单回路，反之不然。  
![图8-30 例图8.17 图模型  ](images/dd241eacc3384b3e855e4a8d2722d1e202b87f4bc0f4c935a9dc90df2ad5dde3.jpg)  
![图8-31 例8-18 图模型](images/9bbcb6a24cd69b076108d52999957fe02f755ca4cbb4868bf787f729d7371e2f.jpg)  
类似地，不难发现邻接矩阵𝐴的 $m$次方幂$A^{m}$在图模型中表示的含义。具体地说，就是$A^{m}$中元素$a_{i j}^{(m)}$的含义就是图中从$\boldsymbol{v}_{i}$出发到$v_{j}$且长度为$m$的路径数目。由此得到如下关于图模型中路径计数的基本定理：  
【定理8.2】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或者无向线图，并且其结点集合为  
$V=\{v_{1},v_{2},\ldots,v_{n}\}$，矩阵$A=(a_{i j})_{n\times n}$是图 $G$ 的邻接矩阵，则对于$A$的$m$次幂$A^{m}=$$({a_{i j}}^{})_{n\times n},m=1,2,\cdots,n,$，其元素 ${a_{i j}}^{(m)}$ 表示从结点 $v_{i}$ 到 $v_{j}$ 且长度为 $m$ 的通路数目；  
${a_{i i}}^{(m)}$表示从结点 $v_{i}$ 到其自身长度为 $m$ 的回路数目；$\begin{array}{r}{\sum_{i=1}^{n}\sum_{j=1}^{n}{a_{i j}}^{(m)}}\end{array}$为图G中长度为 $m$ 的通路（包括回路）总数。  
根据以上分析和讨论，我们可以得出这样的结论：对于任意一个有向或者无向的线图，都根据其邻接矩阵的方幂运算获得任意两个结点在任意指定长度下的通路和回路的数目。因此，关于线图模型的通路计数问题得到了很好的解决。",回路是通路的一种特殊形式，即起点等于终点的通路。
通路,表示,邻接矩阵的方幂,,"前面我们讨论的图模型结构主要是图中结点与边的性质与联系，考察结点之间是否有边联结，换句话说，就是考察图中结点与结点之间的直接联系或直接关系。事实上，在很多情况下，图中结点之间的存在一些以其它一些中间结点为传递媒介的间接联系或间接关系。 例如，在现实世界中，常常考虑这样的问题：一个旅客如何乘高铁从一个城市经过若干个城市到达另一个目的地城市。 将这类问题进行抽象就成为如图8-28 所示图模型的问题，即如何从图中的一个给定结点开始，沿着多个边和结点连续移动到另一个指定的结点。  
![图8-28 部分城市高铁连接图  ](images/696b1dc16cae3150101fa23827543d58e80eb5b132e5b733a120daf06e5316d0.jpg)  
由以上分析可知，图模型中结点之间存在着经由多个边和多个结点的间接联系。对于存在间接联系的两个结点，可以从其中的一个结点出发，沿着作为其联系媒介的多个边和多个结点之间移动，就可达到另外一个结点。显然，这些边和结点构成了联结这两个结点的一个通路。由此得到图模型中通路的相关概念，具体定义如下：  
【定义8.21】设$G=\langle V,E\rangle$ 是任意给定的一个有向图或者无向图，$\boldsymbol{T}$为图$G$ 中顶点和边的相继交替出现的序列，即$\varGamma=v_{0}e_{1}v_{1}e_{2}v_{2}\ldots e_{k}v_{k}\,$。如果对于$i=1,2,\cdots,k$，均有${v_{i-1}}$ 和 $v_{i}$ 是 $e_{i}$ 的两个端点（当 $G$ 为有向图时，要求 $v_{i-1}$ 为 $e_{i}$ 的始点，${v}_{i}$ 为 $e_{i}$ 的终点），则称 $\varGamma$为结点 $v_{0}$ 到结点 $v_{k}$ 的一条通路，$v_{0}$ 和 $v_{l}$ 分别称为该通路的始点和终点，统称为通路的端点。通路$T$ 中所含边的数目 $k$称为$ T$ 的长度。当 $v_{0}=v_{k}$ 时，称该通路称为回路。  
![图8-29 图模型的通路  ](images/1d1c6154df6373d2cdb3faac71f53b624b61d1aa104aceed6cc19294e272f07e.jpg)  
例如，对于如图8-29 (a)所示的无向图，$v_{1}e_{1}v_{2}e_{2}v_{5}e_{6}v_{3}$便是一条通路$\Gamma$，$v_{1}$ 是该通路$\Gamma$的始点$v_{3}$ 是该通路$\Gamma$的终点$v_{1}$ 和 $v_{3}$ 都称为通路$\Gamma$的端点。其中通路$\Gamma$的长度为3。 特别地，对于通路$\ v_{1}e_{1}v_{2}e_{2}v_{5}e_{6}v_{3}e_{3}v_{1}$，则是回路。  
同样，对于如图8-29 (b)所示的有向图，$v_{1}e_{3}v_{2}e_{4}v_{5}e_{8}v_{4}e_{10}v_{3}e_{6}v_{6}$便是一条通路$\Gamma$，$v_{1}$ 是该通路$\Gamma$的始点，$v_{6}$ 是该通路$\Gamma$的终点，$v_{1}$ 和 $v_{6}$ 都称为通路$\Gamma$的端点。其中通路$\Gamma$的长度为5。 特别地，对于通路$\cdot v_{5}e_{9}v_{4}e_{10}v_{3}e_{5}v_{5}$，则是回路。  
在上述定义中，回路是一种特殊的通路，即起点等于终点的通路。但是，在习惯上我们所说的通路一般都不包含回路，也就是说不是回路的通路。因此，以后除非特别说明，我们所说的通路均是指不是回路的通路。  
下面定义通路和回路的各种类型：  
【定义8.22】设$G=\langle V,E\rangle$ 是任意给定的一个有向图或者无向图，$\boldsymbol{T}$为图$G$ 中分别以$v_{0}$和$v_{k}$为起点和终点的通路，即$\varGamma=v_{0}e_{1}v_{1}e_{2}v_{2}\ldots e_{k}v_{k}$，则有：  
（1）若 $\Gamma$ 中所有边各异，则称 $\Gamma$为简单通路或简单路径；若 $$\Gamma$$ 中所有边各异且$\boldsymbol{v}_{0}=$$\boldsymbol{v}_{k}$ 时，称 $$\Gamma$$为简单回路。  
（2）若 $\Gamma$中除 $v_{0},v_{k}$ 以外的所有结点各异（从而所有边也各异），则称 $$\Gamma$$  为基本通路或者基本路径。若 $v_{0}=v_{k}$ 且除 $v_{0},v_{k}$ 以外的所有结点各异，则称 $$\Gamma$$  为基本回路或者圈。  
（3）若 $\Gamma$  中有边重复出现，则称其为复杂通路，若还有 $v_{0}=v_{k}$ ，则称其为复杂回路。  
显然，基本通路必定是简单通路，基本回路必定是简单回路，反之不然。  
![图8-30 例图8.17 图模型  ](images/dd241eacc3384b3e855e4a8d2722d1e202b87f4bc0f4c935a9dc90df2ad5dde3.jpg)  
![图8-31 例8-18 图模型](images/9bbcb6a24cd69b076108d52999957fe02f755ca4cbb4868bf787f729d7371e2f.jpg)  
类似地，不难发现邻接矩阵𝐴的 $m$次方幂$A^{m}$在图模型中表示的含义。具体地说，就是$A^{m}$中元素$a_{i j}^{(m)}$的含义就是图中从$\boldsymbol{v}_{i}$出发到$v_{j}$且长度为$m$的路径数目。由此得到如下关于图模型中路径计数的基本定理：  
【定理8.2】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或者无向线图，并且其结点集合为  
$V=\{v_{1},v_{2},\ldots,v_{n}\}$，矩阵$A=(a_{i j})_{n\times n}$是图 $G$ 的邻接矩阵，则对于$A$的$m$次幂$A^{m}=$$({a_{i j}}^{})_{n\times n},m=1,2,\cdots,n,$，其元素 ${a_{i j}}^{(m)}$ 表示从结点 $v_{i}$ 到 $v_{j}$ 且长度为 $m$ 的通路数目；  
${a_{i i}}^{(m)}$表示从结点 $v_{i}$ 到其自身长度为 $m$ 的回路数目；$\begin{array}{r}{\sum_{i=1}^{n}\sum_{j=1}^{n}{a_{i j}}^{(m)}}\end{array}$为图G中长度为 $m$ 的通路（包括回路）总数。  
根据以上分析和讨论，我们可以得出这样的结论：对于任意一个有向或者无向的线图，都根据其邻接矩阵的方幂运算获得任意两个结点在任意指定长度下的通路和回路的数目。因此，关于线图模型的通路计数问题得到了很好的解决。",邻接矩阵的方幂中的元素表示图中从某一结点到另一结点且长度为该方幂次数的通路数目。
回路,表示,邻接矩阵的方幂,,"前面我们讨论的图模型结构主要是图中结点与边的性质与联系，考察结点之间是否有边联结，换句话说，就是考察图中结点与结点之间的直接联系或直接关系。事实上，在很多情况下，图中结点之间的存在一些以其它一些中间结点为传递媒介的间接联系或间接关系。 例如，在现实世界中，常常考虑这样的问题：一个旅客如何乘高铁从一个城市经过若干个城市到达另一个目的地城市。 将这类问题进行抽象就成为如图8-28 所示图模型的问题，即如何从图中的一个给定结点开始，沿着多个边和结点连续移动到另一个指定的结点。  
![图8-28 部分城市高铁连接图  ](images/696b1dc16cae3150101fa23827543d58e80eb5b132e5b733a120daf06e5316d0.jpg)  
由以上分析可知，图模型中结点之间存在着经由多个边和多个结点的间接联系。对于存在间接联系的两个结点，可以从其中的一个结点出发，沿着作为其联系媒介的多个边和多个结点之间移动，就可达到另外一个结点。显然，这些边和结点构成了联结这两个结点的一个通路。由此得到图模型中通路的相关概念，具体定义如下：  
【定义8.21】设$G=\langle V,E\rangle$ 是任意给定的一个有向图或者无向图，$\boldsymbol{T}$为图$G$ 中顶点和边的相继交替出现的序列，即$\varGamma=v_{0}e_{1}v_{1}e_{2}v_{2}\ldots e_{k}v_{k}\,$。如果对于$i=1,2,\cdots,k$，均有${v_{i-1}}$ 和 $v_{i}$ 是 $e_{i}$ 的两个端点（当 $G$ 为有向图时，要求 $v_{i-1}$ 为 $e_{i}$ 的始点，${v}_{i}$ 为 $e_{i}$ 的终点），则称 $\varGamma$为结点 $v_{0}$ 到结点 $v_{k}$ 的一条通路，$v_{0}$ 和 $v_{l}$ 分别称为该通路的始点和终点，统称为通路的端点。通路$T$ 中所含边的数目 $k$称为$ T$ 的长度。当 $v_{0}=v_{k}$ 时，称该通路称为回路。  
![图8-29 图模型的通路  ](images/1d1c6154df6373d2cdb3faac71f53b624b61d1aa104aceed6cc19294e272f07e.jpg)  
例如，对于如图8-29 (a)所示的无向图，$v_{1}e_{1}v_{2}e_{2}v_{5}e_{6}v_{3}$便是一条通路$\Gamma$，$v_{1}$ 是该通路$\Gamma$的始点$v_{3}$ 是该通路$\Gamma$的终点$v_{1}$ 和 $v_{3}$ 都称为通路$\Gamma$的端点。其中通路$\Gamma$的长度为3。 特别地，对于通路$\ v_{1}e_{1}v_{2}e_{2}v_{5}e_{6}v_{3}e_{3}v_{1}$，则是回路。  
同样，对于如图8-29 (b)所示的有向图，$v_{1}e_{3}v_{2}e_{4}v_{5}e_{8}v_{4}e_{10}v_{3}e_{6}v_{6}$便是一条通路$\Gamma$，$v_{1}$ 是该通路$\Gamma$的始点，$v_{6}$ 是该通路$\Gamma$的终点，$v_{1}$ 和 $v_{6}$ 都称为通路$\Gamma$的端点。其中通路$\Gamma$的长度为5。 特别地，对于通路$\cdot v_{5}e_{9}v_{4}e_{10}v_{3}e_{5}v_{5}$，则是回路。  
在上述定义中，回路是一种特殊的通路，即起点等于终点的通路。但是，在习惯上我们所说的通路一般都不包含回路，也就是说不是回路的通路。因此，以后除非特别说明，我们所说的通路均是指不是回路的通路。  
下面定义通路和回路的各种类型：  
【定义8.22】设$G=\langle V,E\rangle$ 是任意给定的一个有向图或者无向图，$\boldsymbol{T}$为图$G$ 中分别以$v_{0}$和$v_{k}$为起点和终点的通路，即$\varGamma=v_{0}e_{1}v_{1}e_{2}v_{2}\ldots e_{k}v_{k}$，则有：  
（1）若 $\Gamma$ 中所有边各异，则称 $\Gamma$为简单通路或简单路径；若 $$\Gamma$$ 中所有边各异且$\boldsymbol{v}_{0}=$$\boldsymbol{v}_{k}$ 时，称 $$\Gamma$$为简单回路。  
（2）若 $\Gamma$中除 $v_{0},v_{k}$ 以外的所有结点各异（从而所有边也各异），则称 $$\Gamma$$  为基本通路或者基本路径。若 $v_{0}=v_{k}$ 且除 $v_{0},v_{k}$ 以外的所有结点各异，则称 $$\Gamma$$  为基本回路或者圈。  
（3）若 $\Gamma$  中有边重复出现，则称其为复杂通路，若还有 $v_{0}=v_{k}$ ，则称其为复杂回路。  
显然，基本通路必定是简单通路，基本回路必定是简单回路，反之不然。  
![图8-30 例图8.17 图模型  ](images/dd241eacc3384b3e855e4a8d2722d1e202b87f4bc0f4c935a9dc90df2ad5dde3.jpg)  
![图8-31 例8-18 图模型](images/9bbcb6a24cd69b076108d52999957fe02f755ca4cbb4868bf787f729d7371e2f.jpg)  
类似地，不难发现邻接矩阵𝐴的 $m$次方幂$A^{m}$在图模型中表示的含义。具体地说，就是$A^{m}$中元素$a_{i j}^{(m)}$的含义就是图中从$\boldsymbol{v}_{i}$出发到$v_{j}$且长度为$m$的路径数目。由此得到如下关于图模型中路径计数的基本定理：  
【定理8.2】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或者无向线图，并且其结点集合为  
$V=\{v_{1},v_{2},\ldots,v_{n}\}$，矩阵$A=(a_{i j})_{n\times n}$是图 $G$ 的邻接矩阵，则对于$A$的$m$次幂$A^{m}=$$({a_{i j}}^{})_{n\times n},m=1,2,\cdots,n,$，其元素 ${a_{i j}}^{(m)}$ 表示从结点 $v_{i}$ 到 $v_{j}$ 且长度为 $m$ 的通路数目；  
${a_{i i}}^{(m)}$表示从结点 $v_{i}$ 到其自身长度为 $m$ 的回路数目；$\begin{array}{r}{\sum_{i=1}^{n}\sum_{j=1}^{n}{a_{i j}}^{(m)}}\end{array}$为图G中长度为 $m$ 的通路（包括回路）总数。  
根据以上分析和讨论，我们可以得出这样的结论：对于任意一个有向或者无向的线图，都根据其邻接矩阵的方幂运算获得任意两个结点在任意指定长度下的通路和回路的数目。因此，关于线图模型的通路计数问题得到了很好的解决。",邻接矩阵的方幂中的对角线元素表示从某一结点到其自身且长度为该方幂次数的回路数目。
通路计数定理,基于,邻接矩阵的方幂,,"前面我们讨论的图模型结构主要是图中结点与边的性质与联系，考察结点之间是否有边联结，换句话说，就是考察图中结点与结点之间的直接联系或直接关系。事实上，在很多情况下，图中结点之间的存在一些以其它一些中间结点为传递媒介的间接联系或间接关系。 例如，在现实世界中，常常考虑这样的问题：一个旅客如何乘高铁从一个城市经过若干个城市到达另一个目的地城市。 将这类问题进行抽象就成为如图8-28 所示图模型的问题，即如何从图中的一个给定结点开始，沿着多个边和结点连续移动到另一个指定的结点。  
![图8-28 部分城市高铁连接图  ](images/696b1dc16cae3150101fa23827543d58e80eb5b132e5b733a120daf06e5316d0.jpg)  
由以上分析可知，图模型中结点之间存在着经由多个边和多个结点的间接联系。对于存在间接联系的两个结点，可以从其中的一个结点出发，沿着作为其联系媒介的多个边和多个结点之间移动，就可达到另外一个结点。显然，这些边和结点构成了联结这两个结点的一个通路。由此得到图模型中通路的相关概念，具体定义如下：  
【定义8.21】设$G=\langle V,E\rangle$ 是任意给定的一个有向图或者无向图，$\boldsymbol{T}$为图$G$ 中顶点和边的相继交替出现的序列，即$\varGamma=v_{0}e_{1}v_{1}e_{2}v_{2}\ldots e_{k}v_{k}\,$。如果对于$i=1,2,\cdots,k$，均有${v_{i-1}}$ 和 $v_{i}$ 是 $e_{i}$ 的两个端点（当 $G$ 为有向图时，要求 $v_{i-1}$ 为 $e_{i}$ 的始点，${v}_{i}$ 为 $e_{i}$ 的终点），则称 $\varGamma$为结点 $v_{0}$ 到结点 $v_{k}$ 的一条通路，$v_{0}$ 和 $v_{l}$ 分别称为该通路的始点和终点，统称为通路的端点。通路$T$ 中所含边的数目 $k$称为$ T$ 的长度。当 $v_{0}=v_{k}$ 时，称该通路称为回路。  
![图8-29 图模型的通路  ](images/1d1c6154df6373d2cdb3faac71f53b624b61d1aa104aceed6cc19294e272f07e.jpg)  
例如，对于如图8-29 (a)所示的无向图，$v_{1}e_{1}v_{2}e_{2}v_{5}e_{6}v_{3}$便是一条通路$\Gamma$，$v_{1}$ 是该通路$\Gamma$的始点$v_{3}$ 是该通路$\Gamma$的终点$v_{1}$ 和 $v_{3}$ 都称为通路$\Gamma$的端点。其中通路$\Gamma$的长度为3。 特别地，对于通路$\ v_{1}e_{1}v_{2}e_{2}v_{5}e_{6}v_{3}e_{3}v_{1}$，则是回路。  
同样，对于如图8-29 (b)所示的有向图，$v_{1}e_{3}v_{2}e_{4}v_{5}e_{8}v_{4}e_{10}v_{3}e_{6}v_{6}$便是一条通路$\Gamma$，$v_{1}$ 是该通路$\Gamma$的始点，$v_{6}$ 是该通路$\Gamma$的终点，$v_{1}$ 和 $v_{6}$ 都称为通路$\Gamma$的端点。其中通路$\Gamma$的长度为5。 特别地，对于通路$\cdot v_{5}e_{9}v_{4}e_{10}v_{3}e_{5}v_{5}$，则是回路。  
在上述定义中，回路是一种特殊的通路，即起点等于终点的通路。但是，在习惯上我们所说的通路一般都不包含回路，也就是说不是回路的通路。因此，以后除非特别说明，我们所说的通路均是指不是回路的通路。  
下面定义通路和回路的各种类型：  
【定义8.22】设$G=\langle V,E\rangle$ 是任意给定的一个有向图或者无向图，$\boldsymbol{T}$为图$G$ 中分别以$v_{0}$和$v_{k}$为起点和终点的通路，即$\varGamma=v_{0}e_{1}v_{1}e_{2}v_{2}\ldots e_{k}v_{k}$，则有：  
（1）若 $\Gamma$ 中所有边各异，则称 $\Gamma$为简单通路或简单路径；若 $$\Gamma$$ 中所有边各异且$\boldsymbol{v}_{0}=$$\boldsymbol{v}_{k}$ 时，称 $$\Gamma$$为简单回路。  
（2）若 $\Gamma$中除 $v_{0},v_{k}$ 以外的所有结点各异（从而所有边也各异），则称 $$\Gamma$$  为基本通路或者基本路径。若 $v_{0}=v_{k}$ 且除 $v_{0},v_{k}$ 以外的所有结点各异，则称 $$\Gamma$$  为基本回路或者圈。  
（3）若 $\Gamma$  中有边重复出现，则称其为复杂通路，若还有 $v_{0}=v_{k}$ ，则称其为复杂回路。  
显然，基本通路必定是简单通路，基本回路必定是简单回路，反之不然。  
![图8-30 例图8.17 图模型  ](images/dd241eacc3384b3e855e4a8d2722d1e202b87f4bc0f4c935a9dc90df2ad5dde3.jpg)  
![图8-31 例8-18 图模型](images/9bbcb6a24cd69b076108d52999957fe02f755ca4cbb4868bf787f729d7371e2f.jpg)  
类似地，不难发现邻接矩阵𝐴的 $m$次方幂$A^{m}$在图模型中表示的含义。具体地说，就是$A^{m}$中元素$a_{i j}^{(m)}$的含义就是图中从$\boldsymbol{v}_{i}$出发到$v_{j}$且长度为$m$的路径数目。由此得到如下关于图模型中路径计数的基本定理：  
【定理8.2】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或者无向线图，并且其结点集合为  
$V=\{v_{1},v_{2},\ldots,v_{n}\}$，矩阵$A=(a_{i j})_{n\times n}$是图 $G$ 的邻接矩阵，则对于$A$的$m$次幂$A^{m}=$$({a_{i j}}^{})_{n\times n},m=1,2,\cdots,n,$，其元素 ${a_{i j}}^{(m)}$ 表示从结点 $v_{i}$ 到 $v_{j}$ 且长度为 $m$ 的通路数目；  
${a_{i i}}^{(m)}$表示从结点 $v_{i}$ 到其自身长度为 $m$ 的回路数目；$\begin{array}{r}{\sum_{i=1}^{n}\sum_{j=1}^{n}{a_{i j}}^{(m)}}\end{array}$为图G中长度为 $m$ 的通路（包括回路）总数。  
根据以上分析和讨论，我们可以得出这样的结论：对于任意一个有向或者无向的线图，都根据其邻接矩阵的方幂运算获得任意两个结点在任意指定长度下的通路和回路的数目。因此，关于线图模型的通路计数问题得到了很好的解决。",通路计数定理基于邻接矩阵的方幂运算，用于计算图中任意两个结点在指定长度下的通路和回路数目。
可达性,定义,短程线,,"如前所述，对于任意一个给定的线图模型，图中任意两个指定结点之间的通路可能有很多条，有的可能会长一些，有的可能会短一些，此时，一般关心的是哪条通路最短。还有一种情况，就是图中可能存在两个或者多个结点，它们之间根本没有通路相联结，例如，在图8。3。1 表示的城市高铁运输线路图中，北京和台北之间就没有通路联结，这也是一种比较重要的情形。 由此得到如下图中结点可达性及其短程线的相关概念  
【定义8.23】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，对于𝑉中的任意两个结点$v_{i},v_{j}$，如果从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$之间存在长度至少为1 的通路，则称从$v_{i}$到$v_{j}$可达，否则称从$v_{i}$到$v_{j}$不可达。 如果图$G$ 中从$v_{i}$到$v_{j}$可达，则从$v_{i}$到$v_{j}$长度最短的通路称为从$v_{i}$到$v_{j}$的短程线，该短线程的长度称从$\boldsymbol{v}_{i}$到$v_{j}$的距离，记为 $d\big(v_{i},v_{j}\big)$ 。如果从$\boldsymbol{v}_{i}$到$v_{j}$不可达，则记为 $d\bigl(v_{i},v_{j}\bigr)=\infty$ 。  
从上述定义可以看出，结点之间的可达性刻画的是图中两个结点之间的某种连通性关系。对于无向图来说，这种连通性关系显然是双向的，故若从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$ 可达，则从 $v_{j}$ 到 $v_{i}$ 可达，反之亦然；且有 $d\bigl(v_{i},v_{j}\bigr)=d\bigl(v_{j},v_{i}\bigr)$ 。对于有向图来说，这种连通性关系不一定满足对称性，故若从$v_{i}$到$v_{j}$ 可达，则不一定有从 $v_{j}$ 到 $v_{i}$ 可达，也不一定有 $d\big(v_{i},v_{j}\big)=$$d\big(v_{j},v_{i}\big)$ 。  
如前所述，图模型$G=\langle V,E\rangle$中结点之间的通路由该图所表示二元关系不断对其自身作复合运算产生，长度为$k$的通路其实就是二元关系$k$次幂运算的结果。因此，由图$G=\langle V,E\rangle$中结点之间可达性产生的二元关系其实就是图$G=\langle V,E\rangle$所表示二元关系的传递闭包。  
我们知道，对于有限集合$ V=\{v_{1},v_{2},\ldots,v_{n}\}$上的任意一个二元关系，构造其的传递闭包最多只需要进行$\cdot n$次方幂运算就可以了。也就是说，对于任意一个$n$结点的图模型，联结其中两个可达的结点最多只需要做$ n$次方幂运算，亦即对于图中任意两个可达结点，必然存在一条长度不大于$ n$的通路或回路联结这两个结点。  
以上是从二元关系及其传递闭包的角度对图中可达结点的联结通路或回路长度的分析，下面从图模型的角度对上述分析结论进行严格证明。  
【定理8.3】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中两个不同的结点$u$ 和 $v$，存在一条从$u$到 $v$通路，则必然存在一条长度不大于$:n-1$ 的基本通路。  
可类似证明如下基本回路存在性定理：  
【定理8.4】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中结点$v$，存在一条从$v$ 到 $v$回路，则必然存在一条长度不大于$^{\cdot n}$ 的基本回路。  
由以上两个定理可知，对于任意含有$ n$个结点的有向或无向线图$G=\langle V,E\rangle$，如果图从结点$u$ 到${v}$是可达的，那么必然存在从$u$ 到$v$且长度不超过$n$通路或回路。因此，根据通路或回路的计数方法，最多只需计算该图所对应邻接矩阵的$n$幂，即可判定图中任意两个结点之间是否可达。具体地说，假设𝐴是图$G=\langle V,E\rangle$的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则$B_{n}$中的元素为：  
$$
b_{i j}^{(n)}=a_{i j}^{(1)}+a_{i j}^{(2)}+\cdots+a_{i j}^{(n)}
$$  
显然，$b_{i j}^{(n)}$表示图$G$中从结点$v_{i}$到结点$v_{j}$的长度不超过$n$的通路总数，特别地，若$ i=j$，则$b_{i j}^{(n)}$为结点$v_{i}$到自身的长度不超过$n$的回路总数。因此，若$b_{i j}^{(n)}=0$，则结点$v_{i}$到$v_{j}$不可达，否则，结点$v_{i}$到$v_{j}$可达。由此得到有如下定理关于图模型的可达性定理：  
【定理8.5】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，$A=(a_{i j})_{n\times n}$为图 $G$ 的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则当$v_{i}\neq v_{j}$时，若${b_{i j}}^{(n)}>0$，则$v_{i}$到$v_{j}$可达，否则不可达，且有：  
$$
d\big(\boldsymbol{v}_{i},\boldsymbol{v}_{j}\big)==\begin{cases}\infty,&&\text{若}a_{ij}{}^{(1)},a_{ij}{}^{(2)},\cdots,a_{ij}{}^{(n)}\text{均为 0}\\\min\{a_{ij}^{(m)}|m=1,2,\cdots,n\},&&\text{否则}\end{cases}
$$  
在图模型的实际应用过程中，很多时候只需知道结点之间是否可达，而无需知道距离及通路数，由此得到如下可达性矩阵的定义：  
【定义8.24】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，则令$P=(p_{i j})_{n\times n}$是一个$n$阶矩阵，且满足：  
$p_{ij}=\begin{cases}1\:,~~~~~~结点从v_{i}到v_{j}至少存在一条长度不小于1的通路\\0\:,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~否则\end{cases}$    (8-8)  
称矩阵 $P$ 为图 $G$ 的可达性矩阵。  
从上述定义可以看出，可达性矩阵中的元素$\cdot p_{i j}$表示了从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$的可达性关系，表达了结点之间通过结点邻接关系的传递性得到可达性关系。因此，图中结点之间的可达性关系就是该图所表达邻接关系的传递闭包，可达性矩阵其实就是图邻接关系的传递闭包关系矩阵，即为可达性关系的关系矩阵。 显然，无向图的可达性矩阵为对称矩阵。  
若已知$B_{n}$ ，则只需将$B_{n}$中非零元素写成1，便可得到可达性矩阵 $P$，即有：  
$$
p_{i j}=\left\{\!\!\begin{array}{l l}{1,\qquad}&{b_{i j}^{\phantom{}(n)}\neq0}\\ {0,\qquad}&{b_{i j}^{\phantom{}(n)}=0}\end{array}\right.
$$  
由于可达性矩阵$P$是布尔矩阵，矩阵$P$中的元素$p_{i j}$只表示结点$v_{i}$到$v_{j}$是否可达，并不表示至于其通路数目及长度。因此，通过计算矩阵 $B_{n}$获得可达性矩阵$P$的方法效率较低。事实上，可类似于计算二元关系的闭包，使用邻接矩阵𝐴的布尔运算计算可达性矩阵$P$。  
【定理8.6】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，矩阵$A$和$P$分别是图$G$在该结点次序下的邻接矩阵和可达性矩阵，则有：  
$$
P=A^{(1)}\lor A^{(2)}\lor\cdots\lor A^{(k)}\lor\cdots\lor A^{(n)}
$$  
其中$A^{(k)}$表示进行矩阵$A$的$k$次布尔幂运算。",可达性定义了结点间的连通性，短程线是可达结点间长度最短的通路
可达性,等价于,传递闭包,,"如前所述，对于任意一个给定的线图模型，图中任意两个指定结点之间的通路可能有很多条，有的可能会长一些，有的可能会短一些，此时，一般关心的是哪条通路最短。还有一种情况，就是图中可能存在两个或者多个结点，它们之间根本没有通路相联结，例如，在图8。3。1 表示的城市高铁运输线路图中，北京和台北之间就没有通路联结，这也是一种比较重要的情形。 由此得到如下图中结点可达性及其短程线的相关概念  
【定义8.23】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，对于𝑉中的任意两个结点$v_{i},v_{j}$，如果从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$之间存在长度至少为1 的通路，则称从$v_{i}$到$v_{j}$可达，否则称从$v_{i}$到$v_{j}$不可达。 如果图$G$ 中从$v_{i}$到$v_{j}$可达，则从$v_{i}$到$v_{j}$长度最短的通路称为从$v_{i}$到$v_{j}$的短程线，该短线程的长度称从$\boldsymbol{v}_{i}$到$v_{j}$的距离，记为 $d\big(v_{i},v_{j}\big)$ 。如果从$\boldsymbol{v}_{i}$到$v_{j}$不可达，则记为 $d\bigl(v_{i},v_{j}\bigr)=\infty$ 。  
从上述定义可以看出，结点之间的可达性刻画的是图中两个结点之间的某种连通性关系。对于无向图来说，这种连通性关系显然是双向的，故若从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$ 可达，则从 $v_{j}$ 到 $v_{i}$ 可达，反之亦然；且有 $d\bigl(v_{i},v_{j}\bigr)=d\bigl(v_{j},v_{i}\bigr)$ 。对于有向图来说，这种连通性关系不一定满足对称性，故若从$v_{i}$到$v_{j}$ 可达，则不一定有从 $v_{j}$ 到 $v_{i}$ 可达，也不一定有 $d\big(v_{i},v_{j}\big)=$$d\big(v_{j},v_{i}\big)$ 。  
如前所述，图模型$G=\langle V,E\rangle$中结点之间的通路由该图所表示二元关系不断对其自身作复合运算产生，长度为$k$的通路其实就是二元关系$k$次幂运算的结果。因此，由图$G=\langle V,E\rangle$中结点之间可达性产生的二元关系其实就是图$G=\langle V,E\rangle$所表示二元关系的传递闭包。  
我们知道，对于有限集合$ V=\{v_{1},v_{2},\ldots,v_{n}\}$上的任意一个二元关系，构造其的传递闭包最多只需要进行$\cdot n$次方幂运算就可以了。也就是说，对于任意一个$n$结点的图模型，联结其中两个可达的结点最多只需要做$ n$次方幂运算，亦即对于图中任意两个可达结点，必然存在一条长度不大于$ n$的通路或回路联结这两个结点。  
以上是从二元关系及其传递闭包的角度对图中可达结点的联结通路或回路长度的分析，下面从图模型的角度对上述分析结论进行严格证明。  
【定理8.3】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中两个不同的结点$u$ 和 $v$，存在一条从$u$到 $v$通路，则必然存在一条长度不大于$:n-1$ 的基本通路。  
可类似证明如下基本回路存在性定理：  
【定理8.4】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中结点$v$，存在一条从$v$ 到 $v$回路，则必然存在一条长度不大于$^{\cdot n}$ 的基本回路。  
由以上两个定理可知，对于任意含有$ n$个结点的有向或无向线图$G=\langle V,E\rangle$，如果图从结点$u$ 到${v}$是可达的，那么必然存在从$u$ 到$v$且长度不超过$n$通路或回路。因此，根据通路或回路的计数方法，最多只需计算该图所对应邻接矩阵的$n$幂，即可判定图中任意两个结点之间是否可达。具体地说，假设𝐴是图$G=\langle V,E\rangle$的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则$B_{n}$中的元素为：  
$$
b_{i j}^{(n)}=a_{i j}^{(1)}+a_{i j}^{(2)}+\cdots+a_{i j}^{(n)}
$$  
显然，$b_{i j}^{(n)}$表示图$G$中从结点$v_{i}$到结点$v_{j}$的长度不超过$n$的通路总数，特别地，若$ i=j$，则$b_{i j}^{(n)}$为结点$v_{i}$到自身的长度不超过$n$的回路总数。因此，若$b_{i j}^{(n)}=0$，则结点$v_{i}$到$v_{j}$不可达，否则，结点$v_{i}$到$v_{j}$可达。由此得到有如下定理关于图模型的可达性定理：  
【定理8.5】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，$A=(a_{i j})_{n\times n}$为图 $G$ 的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则当$v_{i}\neq v_{j}$时，若${b_{i j}}^{(n)}>0$，则$v_{i}$到$v_{j}$可达，否则不可达，且有：  
$$
d\big(\boldsymbol{v}_{i},\boldsymbol{v}_{j}\big)==\begin{cases}\infty,&&\text{若}a_{ij}{}^{(1)},a_{ij}{}^{(2)},\cdots,a_{ij}{}^{(n)}\text{均为 0}\\\min\{a_{ij}^{(m)}|m=1,2,\cdots,n\},&&\text{否则}\end{cases}
$$  
在图模型的实际应用过程中，很多时候只需知道结点之间是否可达，而无需知道距离及通路数，由此得到如下可达性矩阵的定义：  
【定义8.24】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，则令$P=(p_{i j})_{n\times n}$是一个$n$阶矩阵，且满足：  
$p_{ij}=\begin{cases}1\:,~~~~~~结点从v_{i}到v_{j}至少存在一条长度不小于1的通路\\0\:,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~否则\end{cases}$    (8-8)  
称矩阵 $P$ 为图 $G$ 的可达性矩阵。  
从上述定义可以看出，可达性矩阵中的元素$\cdot p_{i j}$表示了从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$的可达性关系，表达了结点之间通过结点邻接关系的传递性得到可达性关系。因此，图中结点之间的可达性关系就是该图所表达邻接关系的传递闭包，可达性矩阵其实就是图邻接关系的传递闭包关系矩阵，即为可达性关系的关系矩阵。 显然，无向图的可达性矩阵为对称矩阵。  
若已知$B_{n}$ ，则只需将$B_{n}$中非零元素写成1，便可得到可达性矩阵 $P$，即有：  
$$
p_{i j}=\left\{\!\!\begin{array}{l l}{1,\qquad}&{b_{i j}^{\phantom{}(n)}\neq0}\\ {0,\qquad}&{b_{i j}^{\phantom{}(n)}=0}\end{array}\right.
$$  
由于可达性矩阵$P$是布尔矩阵，矩阵$P$中的元素$p_{i j}$只表示结点$v_{i}$到$v_{j}$是否可达，并不表示至于其通路数目及长度。因此，通过计算矩阵 $B_{n}$获得可达性矩阵$P$的方法效率较低。事实上，可类似于计算二元关系的闭包，使用邻接矩阵𝐴的布尔运算计算可达性矩阵$P$。  
【定理8.6】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，矩阵$A$和$P$分别是图$G$在该结点次序下的邻接矩阵和可达性矩阵，则有：  
$$
P=A^{(1)}\lor A^{(2)}\lor\cdots\lor A^{(k)}\lor\cdots\lor A^{(n)}
$$  
其中$A^{(k)}$表示进行矩阵$A$的$k$次布尔幂运算。",图中结点间的可达性关系等价于图所表示二元关系的传递闭包
基本通路,证明,定理8.3,,"如前所述，对于任意一个给定的线图模型，图中任意两个指定结点之间的通路可能有很多条，有的可能会长一些，有的可能会短一些，此时，一般关心的是哪条通路最短。还有一种情况，就是图中可能存在两个或者多个结点，它们之间根本没有通路相联结，例如，在图8。3。1 表示的城市高铁运输线路图中，北京和台北之间就没有通路联结，这也是一种比较重要的情形。 由此得到如下图中结点可达性及其短程线的相关概念  
【定义8.23】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，对于𝑉中的任意两个结点$v_{i},v_{j}$，如果从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$之间存在长度至少为1 的通路，则称从$v_{i}$到$v_{j}$可达，否则称从$v_{i}$到$v_{j}$不可达。 如果图$G$ 中从$v_{i}$到$v_{j}$可达，则从$v_{i}$到$v_{j}$长度最短的通路称为从$v_{i}$到$v_{j}$的短程线，该短线程的长度称从$\boldsymbol{v}_{i}$到$v_{j}$的距离，记为 $d\big(v_{i},v_{j}\big)$ 。如果从$\boldsymbol{v}_{i}$到$v_{j}$不可达，则记为 $d\bigl(v_{i},v_{j}\bigr)=\infty$ 。  
从上述定义可以看出，结点之间的可达性刻画的是图中两个结点之间的某种连通性关系。对于无向图来说，这种连通性关系显然是双向的，故若从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$ 可达，则从 $v_{j}$ 到 $v_{i}$ 可达，反之亦然；且有 $d\bigl(v_{i},v_{j}\bigr)=d\bigl(v_{j},v_{i}\bigr)$ 。对于有向图来说，这种连通性关系不一定满足对称性，故若从$v_{i}$到$v_{j}$ 可达，则不一定有从 $v_{j}$ 到 $v_{i}$ 可达，也不一定有 $d\big(v_{i},v_{j}\big)=$$d\big(v_{j},v_{i}\big)$ 。  
如前所述，图模型$G=\langle V,E\rangle$中结点之间的通路由该图所表示二元关系不断对其自身作复合运算产生，长度为$k$的通路其实就是二元关系$k$次幂运算的结果。因此，由图$G=\langle V,E\rangle$中结点之间可达性产生的二元关系其实就是图$G=\langle V,E\rangle$所表示二元关系的传递闭包。  
我们知道，对于有限集合$ V=\{v_{1},v_{2},\ldots,v_{n}\}$上的任意一个二元关系，构造其的传递闭包最多只需要进行$\cdot n$次方幂运算就可以了。也就是说，对于任意一个$n$结点的图模型，联结其中两个可达的结点最多只需要做$ n$次方幂运算，亦即对于图中任意两个可达结点，必然存在一条长度不大于$ n$的通路或回路联结这两个结点。  
以上是从二元关系及其传递闭包的角度对图中可达结点的联结通路或回路长度的分析，下面从图模型的角度对上述分析结论进行严格证明。  
【定理8.3】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中两个不同的结点$u$ 和 $v$，存在一条从$u$到 $v$通路，则必然存在一条长度不大于$:n-1$ 的基本通路。  
可类似证明如下基本回路存在性定理：  
【定理8.4】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中结点$v$，存在一条从$v$ 到 $v$回路，则必然存在一条长度不大于$^{\cdot n}$ 的基本回路。  
由以上两个定理可知，对于任意含有$ n$个结点的有向或无向线图$G=\langle V,E\rangle$，如果图从结点$u$ 到${v}$是可达的，那么必然存在从$u$ 到$v$且长度不超过$n$通路或回路。因此，根据通路或回路的计数方法，最多只需计算该图所对应邻接矩阵的$n$幂，即可判定图中任意两个结点之间是否可达。具体地说，假设𝐴是图$G=\langle V,E\rangle$的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则$B_{n}$中的元素为：  
$$
b_{i j}^{(n)}=a_{i j}^{(1)}+a_{i j}^{(2)}+\cdots+a_{i j}^{(n)}
$$  
显然，$b_{i j}^{(n)}$表示图$G$中从结点$v_{i}$到结点$v_{j}$的长度不超过$n$的通路总数，特别地，若$ i=j$，则$b_{i j}^{(n)}$为结点$v_{i}$到自身的长度不超过$n$的回路总数。因此，若$b_{i j}^{(n)}=0$，则结点$v_{i}$到$v_{j}$不可达，否则，结点$v_{i}$到$v_{j}$可达。由此得到有如下定理关于图模型的可达性定理：  
【定理8.5】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，$A=(a_{i j})_{n\times n}$为图 $G$ 的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则当$v_{i}\neq v_{j}$时，若${b_{i j}}^{(n)}>0$，则$v_{i}$到$v_{j}$可达，否则不可达，且有：  
$$
d\big(\boldsymbol{v}_{i},\boldsymbol{v}_{j}\big)==\begin{cases}\infty,&&\text{若}a_{ij}{}^{(1)},a_{ij}{}^{(2)},\cdots,a_{ij}{}^{(n)}\text{均为 0}\\\min\{a_{ij}^{(m)}|m=1,2,\cdots,n\},&&\text{否则}\end{cases}
$$  
在图模型的实际应用过程中，很多时候只需知道结点之间是否可达，而无需知道距离及通路数，由此得到如下可达性矩阵的定义：  
【定义8.24】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，则令$P=(p_{i j})_{n\times n}$是一个$n$阶矩阵，且满足：  
$p_{ij}=\begin{cases}1\:,~~~~~~结点从v_{i}到v_{j}至少存在一条长度不小于1的通路\\0\:,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~否则\end{cases}$    (8-8)  
称矩阵 $P$ 为图 $G$ 的可达性矩阵。  
从上述定义可以看出，可达性矩阵中的元素$\cdot p_{i j}$表示了从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$的可达性关系，表达了结点之间通过结点邻接关系的传递性得到可达性关系。因此，图中结点之间的可达性关系就是该图所表达邻接关系的传递闭包，可达性矩阵其实就是图邻接关系的传递闭包关系矩阵，即为可达性关系的关系矩阵。 显然，无向图的可达性矩阵为对称矩阵。  
若已知$B_{n}$ ，则只需将$B_{n}$中非零元素写成1，便可得到可达性矩阵 $P$，即有：  
$$
p_{i j}=\left\{\!\!\begin{array}{l l}{1,\qquad}&{b_{i j}^{\phantom{}(n)}\neq0}\\ {0,\qquad}&{b_{i j}^{\phantom{}(n)}=0}\end{array}\right.
$$  
由于可达性矩阵$P$是布尔矩阵，矩阵$P$中的元素$p_{i j}$只表示结点$v_{i}$到$v_{j}$是否可达，并不表示至于其通路数目及长度。因此，通过计算矩阵 $B_{n}$获得可达性矩阵$P$的方法效率较低。事实上，可类似于计算二元关系的闭包，使用邻接矩阵𝐴的布尔运算计算可达性矩阵$P$。  
【定理8.6】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，矩阵$A$和$P$分别是图$G$在该结点次序下的邻接矩阵和可达性矩阵，则有：  
$$
P=A^{(1)}\lor A^{(2)}\lor\cdots\lor A^{(k)}\lor\cdots\lor A^{(n)}
$$  
其中$A^{(k)}$表示进行矩阵$A$的$k$次布尔幂运算。",定理8.3证明了任意两个可达结点间存在长度不大于n-1的基本通路
基本回路,证明,定理8.4,,"如前所述，对于任意一个给定的线图模型，图中任意两个指定结点之间的通路可能有很多条，有的可能会长一些，有的可能会短一些，此时，一般关心的是哪条通路最短。还有一种情况，就是图中可能存在两个或者多个结点，它们之间根本没有通路相联结，例如，在图8。3。1 表示的城市高铁运输线路图中，北京和台北之间就没有通路联结，这也是一种比较重要的情形。 由此得到如下图中结点可达性及其短程线的相关概念  
【定义8.23】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，对于𝑉中的任意两个结点$v_{i},v_{j}$，如果从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$之间存在长度至少为1 的通路，则称从$v_{i}$到$v_{j}$可达，否则称从$v_{i}$到$v_{j}$不可达。 如果图$G$ 中从$v_{i}$到$v_{j}$可达，则从$v_{i}$到$v_{j}$长度最短的通路称为从$v_{i}$到$v_{j}$的短程线，该短线程的长度称从$\boldsymbol{v}_{i}$到$v_{j}$的距离，记为 $d\big(v_{i},v_{j}\big)$ 。如果从$\boldsymbol{v}_{i}$到$v_{j}$不可达，则记为 $d\bigl(v_{i},v_{j}\bigr)=\infty$ 。  
从上述定义可以看出，结点之间的可达性刻画的是图中两个结点之间的某种连通性关系。对于无向图来说，这种连通性关系显然是双向的，故若从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$ 可达，则从 $v_{j}$ 到 $v_{i}$ 可达，反之亦然；且有 $d\bigl(v_{i},v_{j}\bigr)=d\bigl(v_{j},v_{i}\bigr)$ 。对于有向图来说，这种连通性关系不一定满足对称性，故若从$v_{i}$到$v_{j}$ 可达，则不一定有从 $v_{j}$ 到 $v_{i}$ 可达，也不一定有 $d\big(v_{i},v_{j}\big)=$$d\big(v_{j},v_{i}\big)$ 。  
如前所述，图模型$G=\langle V,E\rangle$中结点之间的通路由该图所表示二元关系不断对其自身作复合运算产生，长度为$k$的通路其实就是二元关系$k$次幂运算的结果。因此，由图$G=\langle V,E\rangle$中结点之间可达性产生的二元关系其实就是图$G=\langle V,E\rangle$所表示二元关系的传递闭包。  
我们知道，对于有限集合$ V=\{v_{1},v_{2},\ldots,v_{n}\}$上的任意一个二元关系，构造其的传递闭包最多只需要进行$\cdot n$次方幂运算就可以了。也就是说，对于任意一个$n$结点的图模型，联结其中两个可达的结点最多只需要做$ n$次方幂运算，亦即对于图中任意两个可达结点，必然存在一条长度不大于$ n$的通路或回路联结这两个结点。  
以上是从二元关系及其传递闭包的角度对图中可达结点的联结通路或回路长度的分析，下面从图模型的角度对上述分析结论进行严格证明。  
【定理8.3】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中两个不同的结点$u$ 和 $v$，存在一条从$u$到 $v$通路，则必然存在一条长度不大于$:n-1$ 的基本通路。  
可类似证明如下基本回路存在性定理：  
【定理8.4】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中结点$v$，存在一条从$v$ 到 $v$回路，则必然存在一条长度不大于$^{\cdot n}$ 的基本回路。  
由以上两个定理可知，对于任意含有$ n$个结点的有向或无向线图$G=\langle V,E\rangle$，如果图从结点$u$ 到${v}$是可达的，那么必然存在从$u$ 到$v$且长度不超过$n$通路或回路。因此，根据通路或回路的计数方法，最多只需计算该图所对应邻接矩阵的$n$幂，即可判定图中任意两个结点之间是否可达。具体地说，假设𝐴是图$G=\langle V,E\rangle$的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则$B_{n}$中的元素为：  
$$
b_{i j}^{(n)}=a_{i j}^{(1)}+a_{i j}^{(2)}+\cdots+a_{i j}^{(n)}
$$  
显然，$b_{i j}^{(n)}$表示图$G$中从结点$v_{i}$到结点$v_{j}$的长度不超过$n$的通路总数，特别地，若$ i=j$，则$b_{i j}^{(n)}$为结点$v_{i}$到自身的长度不超过$n$的回路总数。因此，若$b_{i j}^{(n)}=0$，则结点$v_{i}$到$v_{j}$不可达，否则，结点$v_{i}$到$v_{j}$可达。由此得到有如下定理关于图模型的可达性定理：  
【定理8.5】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，$A=(a_{i j})_{n\times n}$为图 $G$ 的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则当$v_{i}\neq v_{j}$时，若${b_{i j}}^{(n)}>0$，则$v_{i}$到$v_{j}$可达，否则不可达，且有：  
$$
d\big(\boldsymbol{v}_{i},\boldsymbol{v}_{j}\big)==\begin{cases}\infty,&&\text{若}a_{ij}{}^{(1)},a_{ij}{}^{(2)},\cdots,a_{ij}{}^{(n)}\text{均为 0}\\\min\{a_{ij}^{(m)}|m=1,2,\cdots,n\},&&\text{否则}\end{cases}
$$  
在图模型的实际应用过程中，很多时候只需知道结点之间是否可达，而无需知道距离及通路数，由此得到如下可达性矩阵的定义：  
【定义8.24】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，则令$P=(p_{i j})_{n\times n}$是一个$n$阶矩阵，且满足：  
$p_{ij}=\begin{cases}1\:,~~~~~~结点从v_{i}到v_{j}至少存在一条长度不小于1的通路\\0\:,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~否则\end{cases}$    (8-8)  
称矩阵 $P$ 为图 $G$ 的可达性矩阵。  
从上述定义可以看出，可达性矩阵中的元素$\cdot p_{i j}$表示了从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$的可达性关系，表达了结点之间通过结点邻接关系的传递性得到可达性关系。因此，图中结点之间的可达性关系就是该图所表达邻接关系的传递闭包，可达性矩阵其实就是图邻接关系的传递闭包关系矩阵，即为可达性关系的关系矩阵。 显然，无向图的可达性矩阵为对称矩阵。  
若已知$B_{n}$ ，则只需将$B_{n}$中非零元素写成1，便可得到可达性矩阵 $P$，即有：  
$$
p_{i j}=\left\{\!\!\begin{array}{l l}{1,\qquad}&{b_{i j}^{\phantom{}(n)}\neq0}\\ {0,\qquad}&{b_{i j}^{\phantom{}(n)}=0}\end{array}\right.
$$  
由于可达性矩阵$P$是布尔矩阵，矩阵$P$中的元素$p_{i j}$只表示结点$v_{i}$到$v_{j}$是否可达，并不表示至于其通路数目及长度。因此，通过计算矩阵 $B_{n}$获得可达性矩阵$P$的方法效率较低。事实上，可类似于计算二元关系的闭包，使用邻接矩阵𝐴的布尔运算计算可达性矩阵$P$。  
【定理8.6】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，矩阵$A$和$P$分别是图$G$在该结点次序下的邻接矩阵和可达性矩阵，则有：  
$$
P=A^{(1)}\lor A^{(2)}\lor\cdots\lor A^{(k)}\lor\cdots\lor A^{(n)}
$$  
其中$A^{(k)}$表示进行矩阵$A$的$k$次布尔幂运算。",定理8.4证明了任意结点存在长度不大于n的基本回路
邻接矩阵,转换,可达性矩阵,,"如前所述，对于任意一个给定的线图模型，图中任意两个指定结点之间的通路可能有很多条，有的可能会长一些，有的可能会短一些，此时，一般关心的是哪条通路最短。还有一种情况，就是图中可能存在两个或者多个结点，它们之间根本没有通路相联结，例如，在图8。3。1 表示的城市高铁运输线路图中，北京和台北之间就没有通路联结，这也是一种比较重要的情形。 由此得到如下图中结点可达性及其短程线的相关概念  
【定义8.23】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，对于𝑉中的任意两个结点$v_{i},v_{j}$，如果从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$之间存在长度至少为1 的通路，则称从$v_{i}$到$v_{j}$可达，否则称从$v_{i}$到$v_{j}$不可达。 如果图$G$ 中从$v_{i}$到$v_{j}$可达，则从$v_{i}$到$v_{j}$长度最短的通路称为从$v_{i}$到$v_{j}$的短程线，该短线程的长度称从$\boldsymbol{v}_{i}$到$v_{j}$的距离，记为 $d\big(v_{i},v_{j}\big)$ 。如果从$\boldsymbol{v}_{i}$到$v_{j}$不可达，则记为 $d\bigl(v_{i},v_{j}\bigr)=\infty$ 。  
从上述定义可以看出，结点之间的可达性刻画的是图中两个结点之间的某种连通性关系。对于无向图来说，这种连通性关系显然是双向的，故若从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$ 可达，则从 $v_{j}$ 到 $v_{i}$ 可达，反之亦然；且有 $d\bigl(v_{i},v_{j}\bigr)=d\bigl(v_{j},v_{i}\bigr)$ 。对于有向图来说，这种连通性关系不一定满足对称性，故若从$v_{i}$到$v_{j}$ 可达，则不一定有从 $v_{j}$ 到 $v_{i}$ 可达，也不一定有 $d\big(v_{i},v_{j}\big)=$$d\big(v_{j},v_{i}\big)$ 。  
如前所述，图模型$G=\langle V,E\rangle$中结点之间的通路由该图所表示二元关系不断对其自身作复合运算产生，长度为$k$的通路其实就是二元关系$k$次幂运算的结果。因此，由图$G=\langle V,E\rangle$中结点之间可达性产生的二元关系其实就是图$G=\langle V,E\rangle$所表示二元关系的传递闭包。  
我们知道，对于有限集合$ V=\{v_{1},v_{2},\ldots,v_{n}\}$上的任意一个二元关系，构造其的传递闭包最多只需要进行$\cdot n$次方幂运算就可以了。也就是说，对于任意一个$n$结点的图模型，联结其中两个可达的结点最多只需要做$ n$次方幂运算，亦即对于图中任意两个可达结点，必然存在一条长度不大于$ n$的通路或回路联结这两个结点。  
以上是从二元关系及其传递闭包的角度对图中可达结点的联结通路或回路长度的分析，下面从图模型的角度对上述分析结论进行严格证明。  
【定理8.3】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中两个不同的结点$u$ 和 $v$，存在一条从$u$到 $v$通路，则必然存在一条长度不大于$:n-1$ 的基本通路。  
可类似证明如下基本回路存在性定理：  
【定理8.4】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中结点$v$，存在一条从$v$ 到 $v$回路，则必然存在一条长度不大于$^{\cdot n}$ 的基本回路。  
由以上两个定理可知，对于任意含有$ n$个结点的有向或无向线图$G=\langle V,E\rangle$，如果图从结点$u$ 到${v}$是可达的，那么必然存在从$u$ 到$v$且长度不超过$n$通路或回路。因此，根据通路或回路的计数方法，最多只需计算该图所对应邻接矩阵的$n$幂，即可判定图中任意两个结点之间是否可达。具体地说，假设𝐴是图$G=\langle V,E\rangle$的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则$B_{n}$中的元素为：  
$$
b_{i j}^{(n)}=a_{i j}^{(1)}+a_{i j}^{(2)}+\cdots+a_{i j}^{(n)}
$$  
显然，$b_{i j}^{(n)}$表示图$G$中从结点$v_{i}$到结点$v_{j}$的长度不超过$n$的通路总数，特别地，若$ i=j$，则$b_{i j}^{(n)}$为结点$v_{i}$到自身的长度不超过$n$的回路总数。因此，若$b_{i j}^{(n)}=0$，则结点$v_{i}$到$v_{j}$不可达，否则，结点$v_{i}$到$v_{j}$可达。由此得到有如下定理关于图模型的可达性定理：  
【定理8.5】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，$A=(a_{i j})_{n\times n}$为图 $G$ 的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则当$v_{i}\neq v_{j}$时，若${b_{i j}}^{(n)}>0$，则$v_{i}$到$v_{j}$可达，否则不可达，且有：  
$$
d\big(\boldsymbol{v}_{i},\boldsymbol{v}_{j}\big)==\begin{cases}\infty,&&\text{若}a_{ij}{}^{(1)},a_{ij}{}^{(2)},\cdots,a_{ij}{}^{(n)}\text{均为 0}\\\min\{a_{ij}^{(m)}|m=1,2,\cdots,n\},&&\text{否则}\end{cases}
$$  
在图模型的实际应用过程中，很多时候只需知道结点之间是否可达，而无需知道距离及通路数，由此得到如下可达性矩阵的定义：  
【定义8.24】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，则令$P=(p_{i j})_{n\times n}$是一个$n$阶矩阵，且满足：  
$p_{ij}=\begin{cases}1\:,~~~~~~结点从v_{i}到v_{j}至少存在一条长度不小于1的通路\\0\:,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~否则\end{cases}$    (8-8)  
称矩阵 $P$ 为图 $G$ 的可达性矩阵。  
从上述定义可以看出，可达性矩阵中的元素$\cdot p_{i j}$表示了从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$的可达性关系，表达了结点之间通过结点邻接关系的传递性得到可达性关系。因此，图中结点之间的可达性关系就是该图所表达邻接关系的传递闭包，可达性矩阵其实就是图邻接关系的传递闭包关系矩阵，即为可达性关系的关系矩阵。 显然，无向图的可达性矩阵为对称矩阵。  
若已知$B_{n}$ ，则只需将$B_{n}$中非零元素写成1，便可得到可达性矩阵 $P$，即有：  
$$
p_{i j}=\left\{\!\!\begin{array}{l l}{1,\qquad}&{b_{i j}^{\phantom{}(n)}\neq0}\\ {0,\qquad}&{b_{i j}^{\phantom{}(n)}=0}\end{array}\right.
$$  
由于可达性矩阵$P$是布尔矩阵，矩阵$P$中的元素$p_{i j}$只表示结点$v_{i}$到$v_{j}$是否可达，并不表示至于其通路数目及长度。因此，通过计算矩阵 $B_{n}$获得可达性矩阵$P$的方法效率较低。事实上，可类似于计算二元关系的闭包，使用邻接矩阵𝐴的布尔运算计算可达性矩阵$P$。  
【定理8.6】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，矩阵$A$和$P$分别是图$G$在该结点次序下的邻接矩阵和可达性矩阵，则有：  
$$
P=A^{(1)}\lor A^{(2)}\lor\cdots\lor A^{(k)}\lor\cdots\lor A^{(n)}
$$  
其中$A^{(k)}$表示进行矩阵$A$的$k$次布尔幂运算。",通过邻接矩阵的n次幂运算结果可以转换为可达性矩阵
可达性矩阵,计算方法,定理8.6,,"如前所述，对于任意一个给定的线图模型，图中任意两个指定结点之间的通路可能有很多条，有的可能会长一些，有的可能会短一些，此时，一般关心的是哪条通路最短。还有一种情况，就是图中可能存在两个或者多个结点，它们之间根本没有通路相联结，例如，在图8。3。1 表示的城市高铁运输线路图中，北京和台北之间就没有通路联结，这也是一种比较重要的情形。 由此得到如下图中结点可达性及其短程线的相关概念  
【定义8.23】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，对于𝑉中的任意两个结点$v_{i},v_{j}$，如果从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$之间存在长度至少为1 的通路，则称从$v_{i}$到$v_{j}$可达，否则称从$v_{i}$到$v_{j}$不可达。 如果图$G$ 中从$v_{i}$到$v_{j}$可达，则从$v_{i}$到$v_{j}$长度最短的通路称为从$v_{i}$到$v_{j}$的短程线，该短线程的长度称从$\boldsymbol{v}_{i}$到$v_{j}$的距离，记为 $d\big(v_{i},v_{j}\big)$ 。如果从$\boldsymbol{v}_{i}$到$v_{j}$不可达，则记为 $d\bigl(v_{i},v_{j}\bigr)=\infty$ 。  
从上述定义可以看出，结点之间的可达性刻画的是图中两个结点之间的某种连通性关系。对于无向图来说，这种连通性关系显然是双向的，故若从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$ 可达，则从 $v_{j}$ 到 $v_{i}$ 可达，反之亦然；且有 $d\bigl(v_{i},v_{j}\bigr)=d\bigl(v_{j},v_{i}\bigr)$ 。对于有向图来说，这种连通性关系不一定满足对称性，故若从$v_{i}$到$v_{j}$ 可达，则不一定有从 $v_{j}$ 到 $v_{i}$ 可达，也不一定有 $d\big(v_{i},v_{j}\big)=$$d\big(v_{j},v_{i}\big)$ 。  
如前所述，图模型$G=\langle V,E\rangle$中结点之间的通路由该图所表示二元关系不断对其自身作复合运算产生，长度为$k$的通路其实就是二元关系$k$次幂运算的结果。因此，由图$G=\langle V,E\rangle$中结点之间可达性产生的二元关系其实就是图$G=\langle V,E\rangle$所表示二元关系的传递闭包。  
我们知道，对于有限集合$ V=\{v_{1},v_{2},\ldots,v_{n}\}$上的任意一个二元关系，构造其的传递闭包最多只需要进行$\cdot n$次方幂运算就可以了。也就是说，对于任意一个$n$结点的图模型，联结其中两个可达的结点最多只需要做$ n$次方幂运算，亦即对于图中任意两个可达结点，必然存在一条长度不大于$ n$的通路或回路联结这两个结点。  
以上是从二元关系及其传递闭包的角度对图中可达结点的联结通路或回路长度的分析，下面从图模型的角度对上述分析结论进行严格证明。  
【定理8.3】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中两个不同的结点$u$ 和 $v$，存在一条从$u$到 $v$通路，则必然存在一条长度不大于$:n-1$ 的基本通路。  
可类似证明如下基本回路存在性定理：  
【定理8.4】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，若对于图中结点$v$，存在一条从$v$ 到 $v$回路，则必然存在一条长度不大于$^{\cdot n}$ 的基本回路。  
由以上两个定理可知，对于任意含有$ n$个结点的有向或无向线图$G=\langle V,E\rangle$，如果图从结点$u$ 到${v}$是可达的，那么必然存在从$u$ 到$v$且长度不超过$n$通路或回路。因此，根据通路或回路的计数方法，最多只需计算该图所对应邻接矩阵的$n$幂，即可判定图中任意两个结点之间是否可达。具体地说，假设𝐴是图$G=\langle V,E\rangle$的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则$B_{n}$中的元素为：  
$$
b_{i j}^{(n)}=a_{i j}^{(1)}+a_{i j}^{(2)}+\cdots+a_{i j}^{(n)}
$$  
显然，$b_{i j}^{(n)}$表示图$G$中从结点$v_{i}$到结点$v_{j}$的长度不超过$n$的通路总数，特别地，若$ i=j$，则$b_{i j}^{(n)}$为结点$v_{i}$到自身的长度不超过$n$的回路总数。因此，若$b_{i j}^{(n)}=0$，则结点$v_{i}$到$v_{j}$不可达，否则，结点$v_{i}$到$v_{j}$可达。由此得到有如下定理关于图模型的可达性定理：  
【定理8.5】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，$A=(a_{i j})_{n\times n}$为图 $G$ 的邻接矩阵，令：  
$$
B_{n}=(b_{i j}^{(n)})_{n\times n}=A+A^{2}+\cdots+A^{n}
$$  
则当$v_{i}\neq v_{j}$时，若${b_{i j}}^{(n)}>0$，则$v_{i}$到$v_{j}$可达，否则不可达，且有：  
$$
d\big(\boldsymbol{v}_{i},\boldsymbol{v}_{j}\big)==\begin{cases}\infty,&&\text{若}a_{ij}{}^{(1)},a_{ij}{}^{(2)},\cdots,a_{ij}{}^{(n)}\text{均为 0}\\\min\{a_{ij}^{(m)}|m=1,2,\cdots,n\},&&\text{否则}\end{cases}
$$  
在图模型的实际应用过程中，很多时候只需知道结点之间是否可达，而无需知道距离及通路数，由此得到如下可达性矩阵的定义：  
【定义8.24】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，则令$P=(p_{i j})_{n\times n}$是一个$n$阶矩阵，且满足：  
$p_{ij}=\begin{cases}1\:,~~~~~~结点从v_{i}到v_{j}至少存在一条长度不小于1的通路\\0\:,~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~否则\end{cases}$    (8-8)  
称矩阵 $P$ 为图 $G$ 的可达性矩阵。  
从上述定义可以看出，可达性矩阵中的元素$\cdot p_{i j}$表示了从$\boldsymbol{.}\boldsymbol{v}_{i}$到$v_{j}$的可达性关系，表达了结点之间通过结点邻接关系的传递性得到可达性关系。因此，图中结点之间的可达性关系就是该图所表达邻接关系的传递闭包，可达性矩阵其实就是图邻接关系的传递闭包关系矩阵，即为可达性关系的关系矩阵。 显然，无向图的可达性矩阵为对称矩阵。  
若已知$B_{n}$ ，则只需将$B_{n}$中非零元素写成1，便可得到可达性矩阵 $P$，即有：  
$$
p_{i j}=\left\{\!\!\begin{array}{l l}{1,\qquad}&{b_{i j}^{\phantom{}(n)}\neq0}\\ {0,\qquad}&{b_{i j}^{\phantom{}(n)}=0}\end{array}\right.
$$  
由于可达性矩阵$P$是布尔矩阵，矩阵$P$中的元素$p_{i j}$只表示结点$v_{i}$到$v_{j}$是否可达，并不表示至于其通路数目及长度。因此，通过计算矩阵 $B_{n}$获得可达性矩阵$P$的方法效率较低。事实上，可类似于计算二元关系的闭包，使用邻接矩阵𝐴的布尔运算计算可达性矩阵$P$。  
【定理8.6】假设 $G=\langle V,E\rangle$ 为任意给定的一个有向或无向线图，并且其结点集为 $V=$$\{v_{1},v_{2},\dots,v_{n}\}$，结点之间的顺序为$v_{1},v_{2},\dots,v_{n}$，矩阵$A$和$P$分别是图$G$在该结点次序下的邻接矩阵和可达性矩阵，则有：  
$$
P=A^{(1)}\lor A^{(2)}\lor\cdots\lor A^{(k)}\lor\cdots\lor A^{(n)}
$$  
其中$A^{(k)}$表示进行矩阵$A$的$k$次布尔幂运算。",定理8.6提供了通过邻接矩阵的布尔运算计算可达性矩阵的方法
图的连通性,定义,无向连通图,,"前面我们学习了图的可达性概念及其判定，其描述的是图中两个结点之间是否可以通过一条或者多条通路进行联结，并从图的局部角度分别考察两个结点之间的连通关系。现在我  
们从全局性角度考察整个图中多个结点之间的连通关系，将两个结点之间的可达性概念推广到整个图中任意两个结点之间的可达性，由此得到图的连通性和连通图的相关概念。  
在图的连通性方面，无向图和有向图之间具有很大的差异。因此，我们分别讨论无向图和有向图的连通性。本小节主要介绍和讨论无向图连通性的概念与性质。首先给出无向图连通图的相关概念，具体定义如下：  
【定义8.25】设 $G=\langle V,E\rangle$ 为任一给定的无向图，对于图中的两个结点$v_{i}$ 与 $v_{j}$，如果从$\boldsymbol{v}_{i}$到$v_{j}$是可达的，则称从 $v_{i}$ 到 $v_{j}$是连通的，表示为[ $v_{i}\ \ ,v_{j}]$。规定图中任何结点与其自身是连通的。如果无向图$G$中任何两个结点之间都是连通的，则称该图为无向连通图或连通无向图，简称为连通图；否则，称$G$ 是非连通无向图，简称为非连通图。  
显然，无向图中两个结点之间的连通性是双向的，也就是说两结点之间的连通关系满足对称性，即：若有$v_{i}$ 到 $v_{j}$可达则必有$v_{j}$ 到 $v_{i}$可达。故在无向图中，也可将从${v}_{i}$ 到 $v_{j}$的连通说成$v_{i}$ 与 $v_{j}$连通。另外，注意到平凡图有且只有一个结点，根据无向图中结点连通性的规定，它是一种特殊的连通图。  
下面的定理表明，无向图模型中结点之间的连通性关系是一个等价关系：  
【定理8.7】设 $G=\langle V,E\rangle$ 为任一给定的无向图，其结点集为 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，令$R$ 是集合$\cdot V=\{v_{1},v_{2},\ldots,v_{n}\}$上结点之间的连通关系，即有：  
$R=\{\langle u,v\rangle|u,v\in V\}$, 且从$u$到𝑣连通}       （8-10）  
则$R$是集合𝑉上的一个等价关系。  
既然无向图模型中结点之间的连通性关系$R$是一个等价关系，那么就可以使用等价关系$R$ 将无向图 $G$ 的结点集合 𝑉 划分为若干互不相同的等价类，记为   $V_{1},V_{2},\ldots,V_{k}$ 。在这些等价类 中，相互连通的结点属于同一个等价类，不连通的结点属于不同的等价类。由此得到无向图模型的连通分支的概念，具体定义如下：  
【定义8.26】设 $G=\langle V,E\rangle$ 为任一给定的无向图$R$是图$G$结点集合𝑉上的连通性关系，则以关系𝑅的每个等价类为结点集的导出子图都称为图$G$的一个连通分支，并用$p(\mathbf G)$表示图𝐺的连通分支总数。  
由上述定义可知，如果无向图$G=\langle V,E\rangle$的结点连通性关系$R$作为一个等价关系，将结点集𝑉划分为$k$个不同的等价类$V_{1},V_{2},\ldots,V_{k}$，则由它们导出的子图$G(V_{1}),G(V_{2}),\cdots,G(V_{k})$均为图$G$的连通分支。因此，可以根据无向图中结点之间的连通关系实现对图模型的一个分解。显然，若   $p(G)=1$ ，则 $G$ 是连通图。若   $p(G)>1$ ，则   $G$ 是非连通图。  
【定义8.27】对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在结点集𝑉的某个子集 $V^{\prime}\subseteq$$V$ ，使得 $p(G-V^{\prime})>p(G)$ ，且对于 $V^{\prime}$的任何真子集 $V^{\prime\prime}$，有 $p(G-V^{\prime\prime})=p(G)$，则称 $V^{\prime}$为 $G$ 的点割集。如果点割集中只有一个结点 $v$ ，则称 $v$ 为割点。  
由上述定义可知，可通过删除图中适当结点以破坏图结构的方式考察图的连通程度。图中有些结点组成的集合在图的连通性中起着非常关键的作用，删除这些结点后会使得连通图变成非连通图，使得非连通图变得更加不连通，或者增加连通分支的数目。  
显然，对图中的任意一个点割集，该集合中所有结点都是由该点割集增加连通分支时必须同时删除的结点。例如在图8-40 所示的图$G_{1}$中，集合$\{v_{4}\},\{v_{1},v_{3}\}$都是点割集，但$\{v_{1},v_{3},v_{4}\}$则不是点割集，因为要增加图$G_{1}$的连通分支，不必同时删除结点$v_{1},v_{3},v_{4}$。  
需要注意的是，由于删除割点后，割点的邻接边也需要删除，因此我们用虚线表示已删除的边或者结点。同样，对下文所要介绍的边割集也做类似处理。  
同样，可以通过删除图中适当的边以破坏图结构的方式考察图模型的连通程度，由此可以得到边割集的相关概念，具体定义如下：  
【定义8.28】 对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在边集$E$的某个子集 $E^{\prime}\subseteq$$E$ ，使得 $p(G-\ E^{\prime})>p(G)$ ，且对于 $E^{\prime}$的任何真子集 $E^{\prime\prime}$，有 $p(G-\ E^{\prime\prime})=p(G)$，则称$V^{\prime}$为 $G$ 的边割集。如果点割集中只有一个条边  $e$ ，则称 $e$为割边或桥。  
![图8-42 例题8.24 图模型  ](images/6c126be3977ab4a2c63afc18255dc22be84fa010ee39891af7c0eba551970203.jpg)  
关于点割集与边割集，需要注意以下几个要点：  
（1）完全图 $K_{n}$ 无点割集，因为从 $K_{n}$ 中删除 $k\leq n-1$个顶点后，所得图仍然是连通的。  
（2）$n$ 阶零图既无点割集也无边割集。  
（3）对于连通图 $G$，$E^{\prime}$为 $G$ 的边割集，则必有 $p(G-E^{\prime})=2$ 。 因为删除一条边最多只能增加一个连通分支。  
（4）对于连通图 $G\ \ ,V^{\prime}$为 $G$ 的点割集，则 $p(G-V^{\prime})\geq2$，而且可能 $p(G-E^{\prime})>2$因为删除一个结点可能增加多个连通分支。  
从上述例题可以看出，对于任意给定的一个无向连通图，经常会有多个点割集或边割集，而且每个集合中所含元素的个数也不一样。此时，需要重点关注的应该是那些个数最小的集合。因为这些集合刻画了图连通结构中最为薄弱的环节，反映了连通图的最低连通程度。由此得到无向图连通图的点连通度与边连通度的概念，具体定义如下：  
【定义8.29】对于任意给定的一个无向连通图 $G=\langle V,E\rangle$，令：$\kappa(G){=}m i n\{|V^{\prime}||V^{\prime}$为G 的点割集}；$\lambda(\mathbf{G})=\operatorname*{min}\{|E^{\prime}||E^{\prime}$为G 的边割集} 并称 $\kappa(G)$ 为图 $G$ 的点连通度，$\lambda(G)$ 为图 $G$ 的边连通度。  
显然，点连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少结点数，边连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少边数。  
例如，对于图8-44 所示的无向连通图$G$ ，有$\kappa(G)=2$，$\lambda(G)=3$；对于图8-45 所示的彼得森图，有$\kappa(G)=\lambda(G)=3$。  
![图8-44 图的连通度  ](images/28f9ee3f26ab71faac7e5360d73417062a5a59d8421071b9feb627483727c42a.jpg)  
![图8-45  彼得森图  ](images/80ddd389b19bdc8904c989e51a73f2c183cb8c6f73b8b9c479ee3affcb66c7c0.jpg)  
关于无向连通图的点连通度$\kappa(G)$和边连通度$\lambda(\mathrm{G})$，需要注意以下几个要点：  
（1）如果 $G$是平凡图或非连通图，则规定 $\kappa(G)=\lambda(G)=0;$  
（2）如果$G$ 是完全图 $K_{n}$ ，由于 $G$ 中无点割集，当删除 $n-1$个顶点后，$G$ 为平凡图，故 $\kappa(G)=n-1$。  
（3）如果 $G$ 中存在割点，则 $\kappa(G)=1$；如果 $G$ 中存在割边，则 $\lambda(G)=1$。对于任何无向图 $G$ ，其点连通度 $\kappa$ 、边连通度 $\lambda$ 与结点最小度 δ 之间有如下关系：  
【定理8.8】对于任一无向图$G=\langle V,E\rangle$ ，均成立下列不等式：
$$
\kappa(G)\leq\lambda(G)\leq\delta\ (G)
$$",无向连通图是图中任何两个结点之间都连通的图，是图的连通性的一种特殊情况
图的连通性,定义,非连通图,,"前面我们学习了图的可达性概念及其判定，其描述的是图中两个结点之间是否可以通过一条或者多条通路进行联结，并从图的局部角度分别考察两个结点之间的连通关系。现在我  
们从全局性角度考察整个图中多个结点之间的连通关系，将两个结点之间的可达性概念推广到整个图中任意两个结点之间的可达性，由此得到图的连通性和连通图的相关概念。  
在图的连通性方面，无向图和有向图之间具有很大的差异。因此，我们分别讨论无向图和有向图的连通性。本小节主要介绍和讨论无向图连通性的概念与性质。首先给出无向图连通图的相关概念，具体定义如下：  
【定义8.25】设 $G=\langle V,E\rangle$ 为任一给定的无向图，对于图中的两个结点$v_{i}$ 与 $v_{j}$，如果从$\boldsymbol{v}_{i}$到$v_{j}$是可达的，则称从 $v_{i}$ 到 $v_{j}$是连通的，表示为[ $v_{i}\ \ ,v_{j}]$。规定图中任何结点与其自身是连通的。如果无向图$G$中任何两个结点之间都是连通的，则称该图为无向连通图或连通无向图，简称为连通图；否则，称$G$ 是非连通无向图，简称为非连通图。  
显然，无向图中两个结点之间的连通性是双向的，也就是说两结点之间的连通关系满足对称性，即：若有$v_{i}$ 到 $v_{j}$可达则必有$v_{j}$ 到 $v_{i}$可达。故在无向图中，也可将从${v}_{i}$ 到 $v_{j}$的连通说成$v_{i}$ 与 $v_{j}$连通。另外，注意到平凡图有且只有一个结点，根据无向图中结点连通性的规定，它是一种特殊的连通图。  
下面的定理表明，无向图模型中结点之间的连通性关系是一个等价关系：  
【定理8.7】设 $G=\langle V,E\rangle$ 为任一给定的无向图，其结点集为 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，令$R$ 是集合$\cdot V=\{v_{1},v_{2},\ldots,v_{n}\}$上结点之间的连通关系，即有：  
$R=\{\langle u,v\rangle|u,v\in V\}$, 且从$u$到𝑣连通}       （8-10）  
则$R$是集合𝑉上的一个等价关系。  
既然无向图模型中结点之间的连通性关系$R$是一个等价关系，那么就可以使用等价关系$R$ 将无向图 $G$ 的结点集合 𝑉 划分为若干互不相同的等价类，记为   $V_{1},V_{2},\ldots,V_{k}$ 。在这些等价类 中，相互连通的结点属于同一个等价类，不连通的结点属于不同的等价类。由此得到无向图模型的连通分支的概念，具体定义如下：  
【定义8.26】设 $G=\langle V,E\rangle$ 为任一给定的无向图$R$是图$G$结点集合𝑉上的连通性关系，则以关系𝑅的每个等价类为结点集的导出子图都称为图$G$的一个连通分支，并用$p(\mathbf G)$表示图𝐺的连通分支总数。  
由上述定义可知，如果无向图$G=\langle V,E\rangle$的结点连通性关系$R$作为一个等价关系，将结点集𝑉划分为$k$个不同的等价类$V_{1},V_{2},\ldots,V_{k}$，则由它们导出的子图$G(V_{1}),G(V_{2}),\cdots,G(V_{k})$均为图$G$的连通分支。因此，可以根据无向图中结点之间的连通关系实现对图模型的一个分解。显然，若   $p(G)=1$ ，则 $G$ 是连通图。若   $p(G)>1$ ，则   $G$ 是非连通图。  
【定义8.27】对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在结点集𝑉的某个子集 $V^{\prime}\subseteq$$V$ ，使得 $p(G-V^{\prime})>p(G)$ ，且对于 $V^{\prime}$的任何真子集 $V^{\prime\prime}$，有 $p(G-V^{\prime\prime})=p(G)$，则称 $V^{\prime}$为 $G$ 的点割集。如果点割集中只有一个结点 $v$ ，则称 $v$ 为割点。  
由上述定义可知，可通过删除图中适当结点以破坏图结构的方式考察图的连通程度。图中有些结点组成的集合在图的连通性中起着非常关键的作用，删除这些结点后会使得连通图变成非连通图，使得非连通图变得更加不连通，或者增加连通分支的数目。  
显然，对图中的任意一个点割集，该集合中所有结点都是由该点割集增加连通分支时必须同时删除的结点。例如在图8-40 所示的图$G_{1}$中，集合$\{v_{4}\},\{v_{1},v_{3}\}$都是点割集，但$\{v_{1},v_{3},v_{4}\}$则不是点割集，因为要增加图$G_{1}$的连通分支，不必同时删除结点$v_{1},v_{3},v_{4}$。  
需要注意的是，由于删除割点后，割点的邻接边也需要删除，因此我们用虚线表示已删除的边或者结点。同样，对下文所要介绍的边割集也做类似处理。  
同样，可以通过删除图中适当的边以破坏图结构的方式考察图模型的连通程度，由此可以得到边割集的相关概念，具体定义如下：  
【定义8.28】 对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在边集$E$的某个子集 $E^{\prime}\subseteq$$E$ ，使得 $p(G-\ E^{\prime})>p(G)$ ，且对于 $E^{\prime}$的任何真子集 $E^{\prime\prime}$，有 $p(G-\ E^{\prime\prime})=p(G)$，则称$V^{\prime}$为 $G$ 的边割集。如果点割集中只有一个条边  $e$ ，则称 $e$为割边或桥。  
![图8-42 例题8.24 图模型  ](images/6c126be3977ab4a2c63afc18255dc22be84fa010ee39891af7c0eba551970203.jpg)  
关于点割集与边割集，需要注意以下几个要点：  
（1）完全图 $K_{n}$ 无点割集，因为从 $K_{n}$ 中删除 $k\leq n-1$个顶点后，所得图仍然是连通的。  
（2）$n$ 阶零图既无点割集也无边割集。  
（3）对于连通图 $G$，$E^{\prime}$为 $G$ 的边割集，则必有 $p(G-E^{\prime})=2$ 。 因为删除一条边最多只能增加一个连通分支。  
（4）对于连通图 $G\ \ ,V^{\prime}$为 $G$ 的点割集，则 $p(G-V^{\prime})\geq2$，而且可能 $p(G-E^{\prime})>2$因为删除一个结点可能增加多个连通分支。  
从上述例题可以看出，对于任意给定的一个无向连通图，经常会有多个点割集或边割集，而且每个集合中所含元素的个数也不一样。此时，需要重点关注的应该是那些个数最小的集合。因为这些集合刻画了图连通结构中最为薄弱的环节，反映了连通图的最低连通程度。由此得到无向图连通图的点连通度与边连通度的概念，具体定义如下：  
【定义8.29】对于任意给定的一个无向连通图 $G=\langle V,E\rangle$，令：$\kappa(G){=}m i n\{|V^{\prime}||V^{\prime}$为G 的点割集}；$\lambda(\mathbf{G})=\operatorname*{min}\{|E^{\prime}||E^{\prime}$为G 的边割集} 并称 $\kappa(G)$ 为图 $G$ 的点连通度，$\lambda(G)$ 为图 $G$ 的边连通度。  
显然，点连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少结点数，边连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少边数。  
例如，对于图8-44 所示的无向连通图$G$ ，有$\kappa(G)=2$，$\lambda(G)=3$；对于图8-45 所示的彼得森图，有$\kappa(G)=\lambda(G)=3$。  
![图8-44 图的连通度  ](images/28f9ee3f26ab71faac7e5360d73417062a5a59d8421071b9feb627483727c42a.jpg)  
![图8-45  彼得森图  ](images/80ddd389b19bdc8904c989e51a73f2c183cb8c6f73b8b9c479ee3affcb66c7c0.jpg)  
关于无向连通图的点连通度$\kappa(G)$和边连通度$\lambda(\mathrm{G})$，需要注意以下几个要点：  
（1）如果 $G$是平凡图或非连通图，则规定 $\kappa(G)=\lambda(G)=0;$  
（2）如果$G$ 是完全图 $K_{n}$ ，由于 $G$ 中无点割集，当删除 $n-1$个顶点后，$G$ 为平凡图，故 $\kappa(G)=n-1$。  
（3）如果 $G$ 中存在割点，则 $\kappa(G)=1$；如果 $G$ 中存在割边，则 $\lambda(G)=1$。对于任何无向图 $G$ ，其点连通度 $\kappa$ 、边连通度 $\lambda$ 与结点最小度 δ 之间有如下关系：  
【定理8.8】对于任一无向图$G=\langle V,E\rangle$ ，均成立下列不等式：
$$
\kappa(G)\leq\lambda(G)\leq\delta\ (G)
$$",非连通图是图中存在至少一对不连通结点的图，是图的连通性的一种特殊情况
无向连通图,分解,连通分支,,"前面我们学习了图的可达性概念及其判定，其描述的是图中两个结点之间是否可以通过一条或者多条通路进行联结，并从图的局部角度分别考察两个结点之间的连通关系。现在我  
们从全局性角度考察整个图中多个结点之间的连通关系，将两个结点之间的可达性概念推广到整个图中任意两个结点之间的可达性，由此得到图的连通性和连通图的相关概念。  
在图的连通性方面，无向图和有向图之间具有很大的差异。因此，我们分别讨论无向图和有向图的连通性。本小节主要介绍和讨论无向图连通性的概念与性质。首先给出无向图连通图的相关概念，具体定义如下：  
【定义8.25】设 $G=\langle V,E\rangle$ 为任一给定的无向图，对于图中的两个结点$v_{i}$ 与 $v_{j}$，如果从$\boldsymbol{v}_{i}$到$v_{j}$是可达的，则称从 $v_{i}$ 到 $v_{j}$是连通的，表示为[ $v_{i}\ \ ,v_{j}]$。规定图中任何结点与其自身是连通的。如果无向图$G$中任何两个结点之间都是连通的，则称该图为无向连通图或连通无向图，简称为连通图；否则，称$G$ 是非连通无向图，简称为非连通图。  
显然，无向图中两个结点之间的连通性是双向的，也就是说两结点之间的连通关系满足对称性，即：若有$v_{i}$ 到 $v_{j}$可达则必有$v_{j}$ 到 $v_{i}$可达。故在无向图中，也可将从${v}_{i}$ 到 $v_{j}$的连通说成$v_{i}$ 与 $v_{j}$连通。另外，注意到平凡图有且只有一个结点，根据无向图中结点连通性的规定，它是一种特殊的连通图。  
下面的定理表明，无向图模型中结点之间的连通性关系是一个等价关系：  
【定理8.7】设 $G=\langle V,E\rangle$ 为任一给定的无向图，其结点集为 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，令$R$ 是集合$\cdot V=\{v_{1},v_{2},\ldots,v_{n}\}$上结点之间的连通关系，即有：  
$R=\{\langle u,v\rangle|u,v\in V\}$, 且从$u$到𝑣连通}       （8-10）  
则$R$是集合𝑉上的一个等价关系。  
既然无向图模型中结点之间的连通性关系$R$是一个等价关系，那么就可以使用等价关系$R$ 将无向图 $G$ 的结点集合 𝑉 划分为若干互不相同的等价类，记为   $V_{1},V_{2},\ldots,V_{k}$ 。在这些等价类 中，相互连通的结点属于同一个等价类，不连通的结点属于不同的等价类。由此得到无向图模型的连通分支的概念，具体定义如下：  
【定义8.26】设 $G=\langle V,E\rangle$ 为任一给定的无向图$R$是图$G$结点集合𝑉上的连通性关系，则以关系𝑅的每个等价类为结点集的导出子图都称为图$G$的一个连通分支，并用$p(\mathbf G)$表示图𝐺的连通分支总数。  
由上述定义可知，如果无向图$G=\langle V,E\rangle$的结点连通性关系$R$作为一个等价关系，将结点集𝑉划分为$k$个不同的等价类$V_{1},V_{2},\ldots,V_{k}$，则由它们导出的子图$G(V_{1}),G(V_{2}),\cdots,G(V_{k})$均为图$G$的连通分支。因此，可以根据无向图中结点之间的连通关系实现对图模型的一个分解。显然，若   $p(G)=1$ ，则 $G$ 是连通图。若   $p(G)>1$ ，则   $G$ 是非连通图。  
【定义8.27】对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在结点集𝑉的某个子集 $V^{\prime}\subseteq$$V$ ，使得 $p(G-V^{\prime})>p(G)$ ，且对于 $V^{\prime}$的任何真子集 $V^{\prime\prime}$，有 $p(G-V^{\prime\prime})=p(G)$，则称 $V^{\prime}$为 $G$ 的点割集。如果点割集中只有一个结点 $v$ ，则称 $v$ 为割点。  
由上述定义可知，可通过删除图中适当结点以破坏图结构的方式考察图的连通程度。图中有些结点组成的集合在图的连通性中起着非常关键的作用，删除这些结点后会使得连通图变成非连通图，使得非连通图变得更加不连通，或者增加连通分支的数目。  
显然，对图中的任意一个点割集，该集合中所有结点都是由该点割集增加连通分支时必须同时删除的结点。例如在图8-40 所示的图$G_{1}$中，集合$\{v_{4}\},\{v_{1},v_{3}\}$都是点割集，但$\{v_{1},v_{3},v_{4}\}$则不是点割集，因为要增加图$G_{1}$的连通分支，不必同时删除结点$v_{1},v_{3},v_{4}$。  
需要注意的是，由于删除割点后，割点的邻接边也需要删除，因此我们用虚线表示已删除的边或者结点。同样，对下文所要介绍的边割集也做类似处理。  
同样，可以通过删除图中适当的边以破坏图结构的方式考察图模型的连通程度，由此可以得到边割集的相关概念，具体定义如下：  
【定义8.28】 对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在边集$E$的某个子集 $E^{\prime}\subseteq$$E$ ，使得 $p(G-\ E^{\prime})>p(G)$ ，且对于 $E^{\prime}$的任何真子集 $E^{\prime\prime}$，有 $p(G-\ E^{\prime\prime})=p(G)$，则称$V^{\prime}$为 $G$ 的边割集。如果点割集中只有一个条边  $e$ ，则称 $e$为割边或桥。  
![图8-42 例题8.24 图模型  ](images/6c126be3977ab4a2c63afc18255dc22be84fa010ee39891af7c0eba551970203.jpg)  
关于点割集与边割集，需要注意以下几个要点：  
（1）完全图 $K_{n}$ 无点割集，因为从 $K_{n}$ 中删除 $k\leq n-1$个顶点后，所得图仍然是连通的。  
（2）$n$ 阶零图既无点割集也无边割集。  
（3）对于连通图 $G$，$E^{\prime}$为 $G$ 的边割集，则必有 $p(G-E^{\prime})=2$ 。 因为删除一条边最多只能增加一个连通分支。  
（4）对于连通图 $G\ \ ,V^{\prime}$为 $G$ 的点割集，则 $p(G-V^{\prime})\geq2$，而且可能 $p(G-E^{\prime})>2$因为删除一个结点可能增加多个连通分支。  
从上述例题可以看出，对于任意给定的一个无向连通图，经常会有多个点割集或边割集，而且每个集合中所含元素的个数也不一样。此时，需要重点关注的应该是那些个数最小的集合。因为这些集合刻画了图连通结构中最为薄弱的环节，反映了连通图的最低连通程度。由此得到无向图连通图的点连通度与边连通度的概念，具体定义如下：  
【定义8.29】对于任意给定的一个无向连通图 $G=\langle V,E\rangle$，令：$\kappa(G){=}m i n\{|V^{\prime}||V^{\prime}$为G 的点割集}；$\lambda(\mathbf{G})=\operatorname*{min}\{|E^{\prime}||E^{\prime}$为G 的边割集} 并称 $\kappa(G)$ 为图 $G$ 的点连通度，$\lambda(G)$ 为图 $G$ 的边连通度。  
显然，点连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少结点数，边连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少边数。  
例如，对于图8-44 所示的无向连通图$G$ ，有$\kappa(G)=2$，$\lambda(G)=3$；对于图8-45 所示的彼得森图，有$\kappa(G)=\lambda(G)=3$。  
![图8-44 图的连通度  ](images/28f9ee3f26ab71faac7e5360d73417062a5a59d8421071b9feb627483727c42a.jpg)  
![图8-45  彼得森图  ](images/80ddd389b19bdc8904c989e51a73f2c183cb8c6f73b8b9c479ee3affcb66c7c0.jpg)  
关于无向连通图的点连通度$\kappa(G)$和边连通度$\lambda(\mathrm{G})$，需要注意以下几个要点：  
（1）如果 $G$是平凡图或非连通图，则规定 $\kappa(G)=\lambda(G)=0;$  
（2）如果$G$ 是完全图 $K_{n}$ ，由于 $G$ 中无点割集，当删除 $n-1$个顶点后，$G$ 为平凡图，故 $\kappa(G)=n-1$。  
（3）如果 $G$ 中存在割点，则 $\kappa(G)=1$；如果 $G$ 中存在割边，则 $\lambda(G)=1$。对于任何无向图 $G$ ，其点连通度 $\kappa$ 、边连通度 $\lambda$ 与结点最小度 δ 之间有如下关系：  
【定理8.8】对于任一无向图$G=\langle V,E\rangle$ ，均成立下列不等式：
$$
\kappa(G)\leq\lambda(G)\leq\delta\ (G)
$$",无向连通图可以分解为若干个连通分支，每个连通分支是图的一个最大连通子图
非连通图,分解,连通分支,,"前面我们学习了图的可达性概念及其判定，其描述的是图中两个结点之间是否可以通过一条或者多条通路进行联结，并从图的局部角度分别考察两个结点之间的连通关系。现在我  
们从全局性角度考察整个图中多个结点之间的连通关系，将两个结点之间的可达性概念推广到整个图中任意两个结点之间的可达性，由此得到图的连通性和连通图的相关概念。  
在图的连通性方面，无向图和有向图之间具有很大的差异。因此，我们分别讨论无向图和有向图的连通性。本小节主要介绍和讨论无向图连通性的概念与性质。首先给出无向图连通图的相关概念，具体定义如下：  
【定义8.25】设 $G=\langle V,E\rangle$ 为任一给定的无向图，对于图中的两个结点$v_{i}$ 与 $v_{j}$，如果从$\boldsymbol{v}_{i}$到$v_{j}$是可达的，则称从 $v_{i}$ 到 $v_{j}$是连通的，表示为[ $v_{i}\ \ ,v_{j}]$。规定图中任何结点与其自身是连通的。如果无向图$G$中任何两个结点之间都是连通的，则称该图为无向连通图或连通无向图，简称为连通图；否则，称$G$ 是非连通无向图，简称为非连通图。  
显然，无向图中两个结点之间的连通性是双向的，也就是说两结点之间的连通关系满足对称性，即：若有$v_{i}$ 到 $v_{j}$可达则必有$v_{j}$ 到 $v_{i}$可达。故在无向图中，也可将从${v}_{i}$ 到 $v_{j}$的连通说成$v_{i}$ 与 $v_{j}$连通。另外，注意到平凡图有且只有一个结点，根据无向图中结点连通性的规定，它是一种特殊的连通图。  
下面的定理表明，无向图模型中结点之间的连通性关系是一个等价关系：  
【定理8.7】设 $G=\langle V,E\rangle$ 为任一给定的无向图，其结点集为 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，令$R$ 是集合$\cdot V=\{v_{1},v_{2},\ldots,v_{n}\}$上结点之间的连通关系，即有：  
$R=\{\langle u,v\rangle|u,v\in V\}$, 且从$u$到𝑣连通}       （8-10）  
则$R$是集合𝑉上的一个等价关系。  
既然无向图模型中结点之间的连通性关系$R$是一个等价关系，那么就可以使用等价关系$R$ 将无向图 $G$ 的结点集合 𝑉 划分为若干互不相同的等价类，记为   $V_{1},V_{2},\ldots,V_{k}$ 。在这些等价类 中，相互连通的结点属于同一个等价类，不连通的结点属于不同的等价类。由此得到无向图模型的连通分支的概念，具体定义如下：  
【定义8.26】设 $G=\langle V,E\rangle$ 为任一给定的无向图$R$是图$G$结点集合𝑉上的连通性关系，则以关系𝑅的每个等价类为结点集的导出子图都称为图$G$的一个连通分支，并用$p(\mathbf G)$表示图𝐺的连通分支总数。  
由上述定义可知，如果无向图$G=\langle V,E\rangle$的结点连通性关系$R$作为一个等价关系，将结点集𝑉划分为$k$个不同的等价类$V_{1},V_{2},\ldots,V_{k}$，则由它们导出的子图$G(V_{1}),G(V_{2}),\cdots,G(V_{k})$均为图$G$的连通分支。因此，可以根据无向图中结点之间的连通关系实现对图模型的一个分解。显然，若   $p(G)=1$ ，则 $G$ 是连通图。若   $p(G)>1$ ，则   $G$ 是非连通图。  
【定义8.27】对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在结点集𝑉的某个子集 $V^{\prime}\subseteq$$V$ ，使得 $p(G-V^{\prime})>p(G)$ ，且对于 $V^{\prime}$的任何真子集 $V^{\prime\prime}$，有 $p(G-V^{\prime\prime})=p(G)$，则称 $V^{\prime}$为 $G$ 的点割集。如果点割集中只有一个结点 $v$ ，则称 $v$ 为割点。  
由上述定义可知，可通过删除图中适当结点以破坏图结构的方式考察图的连通程度。图中有些结点组成的集合在图的连通性中起着非常关键的作用，删除这些结点后会使得连通图变成非连通图，使得非连通图变得更加不连通，或者增加连通分支的数目。  
显然，对图中的任意一个点割集，该集合中所有结点都是由该点割集增加连通分支时必须同时删除的结点。例如在图8-40 所示的图$G_{1}$中，集合$\{v_{4}\},\{v_{1},v_{3}\}$都是点割集，但$\{v_{1},v_{3},v_{4}\}$则不是点割集，因为要增加图$G_{1}$的连通分支，不必同时删除结点$v_{1},v_{3},v_{4}$。  
需要注意的是，由于删除割点后，割点的邻接边也需要删除，因此我们用虚线表示已删除的边或者结点。同样，对下文所要介绍的边割集也做类似处理。  
同样，可以通过删除图中适当的边以破坏图结构的方式考察图模型的连通程度，由此可以得到边割集的相关概念，具体定义如下：  
【定义8.28】 对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在边集$E$的某个子集 $E^{\prime}\subseteq$$E$ ，使得 $p(G-\ E^{\prime})>p(G)$ ，且对于 $E^{\prime}$的任何真子集 $E^{\prime\prime}$，有 $p(G-\ E^{\prime\prime})=p(G)$，则称$V^{\prime}$为 $G$ 的边割集。如果点割集中只有一个条边  $e$ ，则称 $e$为割边或桥。  
![图8-42 例题8.24 图模型  ](images/6c126be3977ab4a2c63afc18255dc22be84fa010ee39891af7c0eba551970203.jpg)  
关于点割集与边割集，需要注意以下几个要点：  
（1）完全图 $K_{n}$ 无点割集，因为从 $K_{n}$ 中删除 $k\leq n-1$个顶点后，所得图仍然是连通的。  
（2）$n$ 阶零图既无点割集也无边割集。  
（3）对于连通图 $G$，$E^{\prime}$为 $G$ 的边割集，则必有 $p(G-E^{\prime})=2$ 。 因为删除一条边最多只能增加一个连通分支。  
（4）对于连通图 $G\ \ ,V^{\prime}$为 $G$ 的点割集，则 $p(G-V^{\prime})\geq2$，而且可能 $p(G-E^{\prime})>2$因为删除一个结点可能增加多个连通分支。  
从上述例题可以看出，对于任意给定的一个无向连通图，经常会有多个点割集或边割集，而且每个集合中所含元素的个数也不一样。此时，需要重点关注的应该是那些个数最小的集合。因为这些集合刻画了图连通结构中最为薄弱的环节，反映了连通图的最低连通程度。由此得到无向图连通图的点连通度与边连通度的概念，具体定义如下：  
【定义8.29】对于任意给定的一个无向连通图 $G=\langle V,E\rangle$，令：$\kappa(G){=}m i n\{|V^{\prime}||V^{\prime}$为G 的点割集}；$\lambda(\mathbf{G})=\operatorname*{min}\{|E^{\prime}||E^{\prime}$为G 的边割集} 并称 $\kappa(G)$ 为图 $G$ 的点连通度，$\lambda(G)$ 为图 $G$ 的边连通度。  
显然，点连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少结点数，边连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少边数。  
例如，对于图8-44 所示的无向连通图$G$ ，有$\kappa(G)=2$，$\lambda(G)=3$；对于图8-45 所示的彼得森图，有$\kappa(G)=\lambda(G)=3$。  
![图8-44 图的连通度  ](images/28f9ee3f26ab71faac7e5360d73417062a5a59d8421071b9feb627483727c42a.jpg)  
![图8-45  彼得森图  ](images/80ddd389b19bdc8904c989e51a73f2c183cb8c6f73b8b9c479ee3affcb66c7c0.jpg)  
关于无向连通图的点连通度$\kappa(G)$和边连通度$\lambda(\mathrm{G})$，需要注意以下几个要点：  
（1）如果 $G$是平凡图或非连通图，则规定 $\kappa(G)=\lambda(G)=0;$  
（2）如果$G$ 是完全图 $K_{n}$ ，由于 $G$ 中无点割集，当删除 $n-1$个顶点后，$G$ 为平凡图，故 $\kappa(G)=n-1$。  
（3）如果 $G$ 中存在割点，则 $\kappa(G)=1$；如果 $G$ 中存在割边，则 $\lambda(G)=1$。对于任何无向图 $G$ ，其点连通度 $\kappa$ 、边连通度 $\lambda$ 与结点最小度 δ 之间有如下关系：  
【定理8.8】对于任一无向图$G=\langle V,E\rangle$ ，均成立下列不等式：
$$
\kappa(G)\leq\lambda(G)\leq\delta\ (G)
$$",非连通图由多个连通分支组成，每个连通分支是图的一个最大连通子图
点割集,包含,割点,,"前面我们学习了图的可达性概念及其判定，其描述的是图中两个结点之间是否可以通过一条或者多条通路进行联结，并从图的局部角度分别考察两个结点之间的连通关系。现在我  
们从全局性角度考察整个图中多个结点之间的连通关系，将两个结点之间的可达性概念推广到整个图中任意两个结点之间的可达性，由此得到图的连通性和连通图的相关概念。  
在图的连通性方面，无向图和有向图之间具有很大的差异。因此，我们分别讨论无向图和有向图的连通性。本小节主要介绍和讨论无向图连通性的概念与性质。首先给出无向图连通图的相关概念，具体定义如下：  
【定义8.25】设 $G=\langle V,E\rangle$ 为任一给定的无向图，对于图中的两个结点$v_{i}$ 与 $v_{j}$，如果从$\boldsymbol{v}_{i}$到$v_{j}$是可达的，则称从 $v_{i}$ 到 $v_{j}$是连通的，表示为[ $v_{i}\ \ ,v_{j}]$。规定图中任何结点与其自身是连通的。如果无向图$G$中任何两个结点之间都是连通的，则称该图为无向连通图或连通无向图，简称为连通图；否则，称$G$ 是非连通无向图，简称为非连通图。  
显然，无向图中两个结点之间的连通性是双向的，也就是说两结点之间的连通关系满足对称性，即：若有$v_{i}$ 到 $v_{j}$可达则必有$v_{j}$ 到 $v_{i}$可达。故在无向图中，也可将从${v}_{i}$ 到 $v_{j}$的连通说成$v_{i}$ 与 $v_{j}$连通。另外，注意到平凡图有且只有一个结点，根据无向图中结点连通性的规定，它是一种特殊的连通图。  
下面的定理表明，无向图模型中结点之间的连通性关系是一个等价关系：  
【定理8.7】设 $G=\langle V,E\rangle$ 为任一给定的无向图，其结点集为 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，令$R$ 是集合$\cdot V=\{v_{1},v_{2},\ldots,v_{n}\}$上结点之间的连通关系，即有：  
$R=\{\langle u,v\rangle|u,v\in V\}$, 且从$u$到𝑣连通}       （8-10）  
则$R$是集合𝑉上的一个等价关系。  
既然无向图模型中结点之间的连通性关系$R$是一个等价关系，那么就可以使用等价关系$R$ 将无向图 $G$ 的结点集合 𝑉 划分为若干互不相同的等价类，记为   $V_{1},V_{2},\ldots,V_{k}$ 。在这些等价类 中，相互连通的结点属于同一个等价类，不连通的结点属于不同的等价类。由此得到无向图模型的连通分支的概念，具体定义如下：  
【定义8.26】设 $G=\langle V,E\rangle$ 为任一给定的无向图$R$是图$G$结点集合𝑉上的连通性关系，则以关系𝑅的每个等价类为结点集的导出子图都称为图$G$的一个连通分支，并用$p(\mathbf G)$表示图𝐺的连通分支总数。  
由上述定义可知，如果无向图$G=\langle V,E\rangle$的结点连通性关系$R$作为一个等价关系，将结点集𝑉划分为$k$个不同的等价类$V_{1},V_{2},\ldots,V_{k}$，则由它们导出的子图$G(V_{1}),G(V_{2}),\cdots,G(V_{k})$均为图$G$的连通分支。因此，可以根据无向图中结点之间的连通关系实现对图模型的一个分解。显然，若   $p(G)=1$ ，则 $G$ 是连通图。若   $p(G)>1$ ，则   $G$ 是非连通图。  
【定义8.27】对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在结点集𝑉的某个子集 $V^{\prime}\subseteq$$V$ ，使得 $p(G-V^{\prime})>p(G)$ ，且对于 $V^{\prime}$的任何真子集 $V^{\prime\prime}$，有 $p(G-V^{\prime\prime})=p(G)$，则称 $V^{\prime}$为 $G$ 的点割集。如果点割集中只有一个结点 $v$ ，则称 $v$ 为割点。  
由上述定义可知，可通过删除图中适当结点以破坏图结构的方式考察图的连通程度。图中有些结点组成的集合在图的连通性中起着非常关键的作用，删除这些结点后会使得连通图变成非连通图，使得非连通图变得更加不连通，或者增加连通分支的数目。  
显然，对图中的任意一个点割集，该集合中所有结点都是由该点割集增加连通分支时必须同时删除的结点。例如在图8-40 所示的图$G_{1}$中，集合$\{v_{4}\},\{v_{1},v_{3}\}$都是点割集，但$\{v_{1},v_{3},v_{4}\}$则不是点割集，因为要增加图$G_{1}$的连通分支，不必同时删除结点$v_{1},v_{3},v_{4}$。  
需要注意的是，由于删除割点后，割点的邻接边也需要删除，因此我们用虚线表示已删除的边或者结点。同样，对下文所要介绍的边割集也做类似处理。  
同样，可以通过删除图中适当的边以破坏图结构的方式考察图模型的连通程度，由此可以得到边割集的相关概念，具体定义如下：  
【定义8.28】 对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在边集$E$的某个子集 $E^{\prime}\subseteq$$E$ ，使得 $p(G-\ E^{\prime})>p(G)$ ，且对于 $E^{\prime}$的任何真子集 $E^{\prime\prime}$，有 $p(G-\ E^{\prime\prime})=p(G)$，则称$V^{\prime}$为 $G$ 的边割集。如果点割集中只有一个条边  $e$ ，则称 $e$为割边或桥。  
![图8-42 例题8.24 图模型  ](images/6c126be3977ab4a2c63afc18255dc22be84fa010ee39891af7c0eba551970203.jpg)  
关于点割集与边割集，需要注意以下几个要点：  
（1）完全图 $K_{n}$ 无点割集，因为从 $K_{n}$ 中删除 $k\leq n-1$个顶点后，所得图仍然是连通的。  
（2）$n$ 阶零图既无点割集也无边割集。  
（3）对于连通图 $G$，$E^{\prime}$为 $G$ 的边割集，则必有 $p(G-E^{\prime})=2$ 。 因为删除一条边最多只能增加一个连通分支。  
（4）对于连通图 $G\ \ ,V^{\prime}$为 $G$ 的点割集，则 $p(G-V^{\prime})\geq2$，而且可能 $p(G-E^{\prime})>2$因为删除一个结点可能增加多个连通分支。  
从上述例题可以看出，对于任意给定的一个无向连通图，经常会有多个点割集或边割集，而且每个集合中所含元素的个数也不一样。此时，需要重点关注的应该是那些个数最小的集合。因为这些集合刻画了图连通结构中最为薄弱的环节，反映了连通图的最低连通程度。由此得到无向图连通图的点连通度与边连通度的概念，具体定义如下：  
【定义8.29】对于任意给定的一个无向连通图 $G=\langle V,E\rangle$，令：$\kappa(G){=}m i n\{|V^{\prime}||V^{\prime}$为G 的点割集}；$\lambda(\mathbf{G})=\operatorname*{min}\{|E^{\prime}||E^{\prime}$为G 的边割集} 并称 $\kappa(G)$ 为图 $G$ 的点连通度，$\lambda(G)$ 为图 $G$ 的边连通度。  
显然，点连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少结点数，边连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少边数。  
例如，对于图8-44 所示的无向连通图$G$ ，有$\kappa(G)=2$，$\lambda(G)=3$；对于图8-45 所示的彼得森图，有$\kappa(G)=\lambda(G)=3$。  
![图8-44 图的连通度  ](images/28f9ee3f26ab71faac7e5360d73417062a5a59d8421071b9feb627483727c42a.jpg)  
![图8-45  彼得森图  ](images/80ddd389b19bdc8904c989e51a73f2c183cb8c6f73b8b9c479ee3affcb66c7c0.jpg)  
关于无向连通图的点连通度$\kappa(G)$和边连通度$\lambda(\mathrm{G})$，需要注意以下几个要点：  
（1）如果 $G$是平凡图或非连通图，则规定 $\kappa(G)=\lambda(G)=0;$  
（2）如果$G$ 是完全图 $K_{n}$ ，由于 $G$ 中无点割集，当删除 $n-1$个顶点后，$G$ 为平凡图，故 $\kappa(G)=n-1$。  
（3）如果 $G$ 中存在割点，则 $\kappa(G)=1$；如果 $G$ 中存在割边，则 $\lambda(G)=1$。对于任何无向图 $G$ ，其点连通度 $\kappa$ 、边连通度 $\lambda$ 与结点最小度 δ 之间有如下关系：  
【定理8.8】对于任一无向图$G=\langle V,E\rangle$ ，均成立下列不等式：
$$
\kappa(G)\leq\lambda(G)\leq\delta\ (G)
$$",点割集中包含的单一结点称为割点，割点是图中删除后会增加连通分支的结点
边割集,包含,割边,,"前面我们学习了图的可达性概念及其判定，其描述的是图中两个结点之间是否可以通过一条或者多条通路进行联结，并从图的局部角度分别考察两个结点之间的连通关系。现在我  
们从全局性角度考察整个图中多个结点之间的连通关系，将两个结点之间的可达性概念推广到整个图中任意两个结点之间的可达性，由此得到图的连通性和连通图的相关概念。  
在图的连通性方面，无向图和有向图之间具有很大的差异。因此，我们分别讨论无向图和有向图的连通性。本小节主要介绍和讨论无向图连通性的概念与性质。首先给出无向图连通图的相关概念，具体定义如下：  
【定义8.25】设 $G=\langle V,E\rangle$ 为任一给定的无向图，对于图中的两个结点$v_{i}$ 与 $v_{j}$，如果从$\boldsymbol{v}_{i}$到$v_{j}$是可达的，则称从 $v_{i}$ 到 $v_{j}$是连通的，表示为[ $v_{i}\ \ ,v_{j}]$。规定图中任何结点与其自身是连通的。如果无向图$G$中任何两个结点之间都是连通的，则称该图为无向连通图或连通无向图，简称为连通图；否则，称$G$ 是非连通无向图，简称为非连通图。  
显然，无向图中两个结点之间的连通性是双向的，也就是说两结点之间的连通关系满足对称性，即：若有$v_{i}$ 到 $v_{j}$可达则必有$v_{j}$ 到 $v_{i}$可达。故在无向图中，也可将从${v}_{i}$ 到 $v_{j}$的连通说成$v_{i}$ 与 $v_{j}$连通。另外，注意到平凡图有且只有一个结点，根据无向图中结点连通性的规定，它是一种特殊的连通图。  
下面的定理表明，无向图模型中结点之间的连通性关系是一个等价关系：  
【定理8.7】设 $G=\langle V,E\rangle$ 为任一给定的无向图，其结点集为 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，令$R$ 是集合$\cdot V=\{v_{1},v_{2},\ldots,v_{n}\}$上结点之间的连通关系，即有：  
$R=\{\langle u,v\rangle|u,v\in V\}$, 且从$u$到𝑣连通}       （8-10）  
则$R$是集合𝑉上的一个等价关系。  
既然无向图模型中结点之间的连通性关系$R$是一个等价关系，那么就可以使用等价关系$R$ 将无向图 $G$ 的结点集合 𝑉 划分为若干互不相同的等价类，记为   $V_{1},V_{2},\ldots,V_{k}$ 。在这些等价类 中，相互连通的结点属于同一个等价类，不连通的结点属于不同的等价类。由此得到无向图模型的连通分支的概念，具体定义如下：  
【定义8.26】设 $G=\langle V,E\rangle$ 为任一给定的无向图$R$是图$G$结点集合𝑉上的连通性关系，则以关系𝑅的每个等价类为结点集的导出子图都称为图$G$的一个连通分支，并用$p(\mathbf G)$表示图𝐺的连通分支总数。  
由上述定义可知，如果无向图$G=\langle V,E\rangle$的结点连通性关系$R$作为一个等价关系，将结点集𝑉划分为$k$个不同的等价类$V_{1},V_{2},\ldots,V_{k}$，则由它们导出的子图$G(V_{1}),G(V_{2}),\cdots,G(V_{k})$均为图$G$的连通分支。因此，可以根据无向图中结点之间的连通关系实现对图模型的一个分解。显然，若   $p(G)=1$ ，则 $G$ 是连通图。若   $p(G)>1$ ，则   $G$ 是非连通图。  
【定义8.27】对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在结点集𝑉的某个子集 $V^{\prime}\subseteq$$V$ ，使得 $p(G-V^{\prime})>p(G)$ ，且对于 $V^{\prime}$的任何真子集 $V^{\prime\prime}$，有 $p(G-V^{\prime\prime})=p(G)$，则称 $V^{\prime}$为 $G$ 的点割集。如果点割集中只有一个结点 $v$ ，则称 $v$ 为割点。  
由上述定义可知，可通过删除图中适当结点以破坏图结构的方式考察图的连通程度。图中有些结点组成的集合在图的连通性中起着非常关键的作用，删除这些结点后会使得连通图变成非连通图，使得非连通图变得更加不连通，或者增加连通分支的数目。  
显然，对图中的任意一个点割集，该集合中所有结点都是由该点割集增加连通分支时必须同时删除的结点。例如在图8-40 所示的图$G_{1}$中，集合$\{v_{4}\},\{v_{1},v_{3}\}$都是点割集，但$\{v_{1},v_{3},v_{4}\}$则不是点割集，因为要增加图$G_{1}$的连通分支，不必同时删除结点$v_{1},v_{3},v_{4}$。  
需要注意的是，由于删除割点后，割点的邻接边也需要删除，因此我们用虚线表示已删除的边或者结点。同样，对下文所要介绍的边割集也做类似处理。  
同样，可以通过删除图中适当的边以破坏图结构的方式考察图模型的连通程度，由此可以得到边割集的相关概念，具体定义如下：  
【定义8.28】 对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在边集$E$的某个子集 $E^{\prime}\subseteq$$E$ ，使得 $p(G-\ E^{\prime})>p(G)$ ，且对于 $E^{\prime}$的任何真子集 $E^{\prime\prime}$，有 $p(G-\ E^{\prime\prime})=p(G)$，则称$V^{\prime}$为 $G$ 的边割集。如果点割集中只有一个条边  $e$ ，则称 $e$为割边或桥。  
![图8-42 例题8.24 图模型  ](images/6c126be3977ab4a2c63afc18255dc22be84fa010ee39891af7c0eba551970203.jpg)  
关于点割集与边割集，需要注意以下几个要点：  
（1）完全图 $K_{n}$ 无点割集，因为从 $K_{n}$ 中删除 $k\leq n-1$个顶点后，所得图仍然是连通的。  
（2）$n$ 阶零图既无点割集也无边割集。  
（3）对于连通图 $G$，$E^{\prime}$为 $G$ 的边割集，则必有 $p(G-E^{\prime})=2$ 。 因为删除一条边最多只能增加一个连通分支。  
（4）对于连通图 $G\ \ ,V^{\prime}$为 $G$ 的点割集，则 $p(G-V^{\prime})\geq2$，而且可能 $p(G-E^{\prime})>2$因为删除一个结点可能增加多个连通分支。  
从上述例题可以看出，对于任意给定的一个无向连通图，经常会有多个点割集或边割集，而且每个集合中所含元素的个数也不一样。此时，需要重点关注的应该是那些个数最小的集合。因为这些集合刻画了图连通结构中最为薄弱的环节，反映了连通图的最低连通程度。由此得到无向图连通图的点连通度与边连通度的概念，具体定义如下：  
【定义8.29】对于任意给定的一个无向连通图 $G=\langle V,E\rangle$，令：$\kappa(G){=}m i n\{|V^{\prime}||V^{\prime}$为G 的点割集}；$\lambda(\mathbf{G})=\operatorname*{min}\{|E^{\prime}||E^{\prime}$为G 的边割集} 并称 $\kappa(G)$ 为图 $G$ 的点连通度，$\lambda(G)$ 为图 $G$ 的边连通度。  
显然，点连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少结点数，边连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少边数。  
例如，对于图8-44 所示的无向连通图$G$ ，有$\kappa(G)=2$，$\lambda(G)=3$；对于图8-45 所示的彼得森图，有$\kappa(G)=\lambda(G)=3$。  
![图8-44 图的连通度  ](images/28f9ee3f26ab71faac7e5360d73417062a5a59d8421071b9feb627483727c42a.jpg)  
![图8-45  彼得森图  ](images/80ddd389b19bdc8904c989e51a73f2c183cb8c6f73b8b9c479ee3affcb66c7c0.jpg)  
关于无向连通图的点连通度$\kappa(G)$和边连通度$\lambda(\mathrm{G})$，需要注意以下几个要点：  
（1）如果 $G$是平凡图或非连通图，则规定 $\kappa(G)=\lambda(G)=0;$  
（2）如果$G$ 是完全图 $K_{n}$ ，由于 $G$ 中无点割集，当删除 $n-1$个顶点后，$G$ 为平凡图，故 $\kappa(G)=n-1$。  
（3）如果 $G$ 中存在割点，则 $\kappa(G)=1$；如果 $G$ 中存在割边，则 $\lambda(G)=1$。对于任何无向图 $G$ ，其点连通度 $\kappa$ 、边连通度 $\lambda$ 与结点最小度 δ 之间有如下关系：  
【定理8.8】对于任一无向图$G=\langle V,E\rangle$ ，均成立下列不等式：
$$
\kappa(G)\leq\lambda(G)\leq\delta\ (G)
$$",边割集中包含的单一边称为割边，割边是图中删除后会增加连通分支的边
无向连通图,度量,点连通度,,"前面我们学习了图的可达性概念及其判定，其描述的是图中两个结点之间是否可以通过一条或者多条通路进行联结，并从图的局部角度分别考察两个结点之间的连通关系。现在我  
们从全局性角度考察整个图中多个结点之间的连通关系，将两个结点之间的可达性概念推广到整个图中任意两个结点之间的可达性，由此得到图的连通性和连通图的相关概念。  
在图的连通性方面，无向图和有向图之间具有很大的差异。因此，我们分别讨论无向图和有向图的连通性。本小节主要介绍和讨论无向图连通性的概念与性质。首先给出无向图连通图的相关概念，具体定义如下：  
【定义8.25】设 $G=\langle V,E\rangle$ 为任一给定的无向图，对于图中的两个结点$v_{i}$ 与 $v_{j}$，如果从$\boldsymbol{v}_{i}$到$v_{j}$是可达的，则称从 $v_{i}$ 到 $v_{j}$是连通的，表示为[ $v_{i}\ \ ,v_{j}]$。规定图中任何结点与其自身是连通的。如果无向图$G$中任何两个结点之间都是连通的，则称该图为无向连通图或连通无向图，简称为连通图；否则，称$G$ 是非连通无向图，简称为非连通图。  
显然，无向图中两个结点之间的连通性是双向的，也就是说两结点之间的连通关系满足对称性，即：若有$v_{i}$ 到 $v_{j}$可达则必有$v_{j}$ 到 $v_{i}$可达。故在无向图中，也可将从${v}_{i}$ 到 $v_{j}$的连通说成$v_{i}$ 与 $v_{j}$连通。另外，注意到平凡图有且只有一个结点，根据无向图中结点连通性的规定，它是一种特殊的连通图。  
下面的定理表明，无向图模型中结点之间的连通性关系是一个等价关系：  
【定理8.7】设 $G=\langle V,E\rangle$ 为任一给定的无向图，其结点集为 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，令$R$ 是集合$\cdot V=\{v_{1},v_{2},\ldots,v_{n}\}$上结点之间的连通关系，即有：  
$R=\{\langle u,v\rangle|u,v\in V\}$, 且从$u$到𝑣连通}       （8-10）  
则$R$是集合𝑉上的一个等价关系。  
既然无向图模型中结点之间的连通性关系$R$是一个等价关系，那么就可以使用等价关系$R$ 将无向图 $G$ 的结点集合 𝑉 划分为若干互不相同的等价类，记为   $V_{1},V_{2},\ldots,V_{k}$ 。在这些等价类 中，相互连通的结点属于同一个等价类，不连通的结点属于不同的等价类。由此得到无向图模型的连通分支的概念，具体定义如下：  
【定义8.26】设 $G=\langle V,E\rangle$ 为任一给定的无向图$R$是图$G$结点集合𝑉上的连通性关系，则以关系𝑅的每个等价类为结点集的导出子图都称为图$G$的一个连通分支，并用$p(\mathbf G)$表示图𝐺的连通分支总数。  
由上述定义可知，如果无向图$G=\langle V,E\rangle$的结点连通性关系$R$作为一个等价关系，将结点集𝑉划分为$k$个不同的等价类$V_{1},V_{2},\ldots,V_{k}$，则由它们导出的子图$G(V_{1}),G(V_{2}),\cdots,G(V_{k})$均为图$G$的连通分支。因此，可以根据无向图中结点之间的连通关系实现对图模型的一个分解。显然，若   $p(G)=1$ ，则 $G$ 是连通图。若   $p(G)>1$ ，则   $G$ 是非连通图。  
【定义8.27】对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在结点集𝑉的某个子集 $V^{\prime}\subseteq$$V$ ，使得 $p(G-V^{\prime})>p(G)$ ，且对于 $V^{\prime}$的任何真子集 $V^{\prime\prime}$，有 $p(G-V^{\prime\prime})=p(G)$，则称 $V^{\prime}$为 $G$ 的点割集。如果点割集中只有一个结点 $v$ ，则称 $v$ 为割点。  
由上述定义可知，可通过删除图中适当结点以破坏图结构的方式考察图的连通程度。图中有些结点组成的集合在图的连通性中起着非常关键的作用，删除这些结点后会使得连通图变成非连通图，使得非连通图变得更加不连通，或者增加连通分支的数目。  
显然，对图中的任意一个点割集，该集合中所有结点都是由该点割集增加连通分支时必须同时删除的结点。例如在图8-40 所示的图$G_{1}$中，集合$\{v_{4}\},\{v_{1},v_{3}\}$都是点割集，但$\{v_{1},v_{3},v_{4}\}$则不是点割集，因为要增加图$G_{1}$的连通分支，不必同时删除结点$v_{1},v_{3},v_{4}$。  
需要注意的是，由于删除割点后，割点的邻接边也需要删除，因此我们用虚线表示已删除的边或者结点。同样，对下文所要介绍的边割集也做类似处理。  
同样，可以通过删除图中适当的边以破坏图结构的方式考察图模型的连通程度，由此可以得到边割集的相关概念，具体定义如下：  
【定义8.28】 对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在边集$E$的某个子集 $E^{\prime}\subseteq$$E$ ，使得 $p(G-\ E^{\prime})>p(G)$ ，且对于 $E^{\prime}$的任何真子集 $E^{\prime\prime}$，有 $p(G-\ E^{\prime\prime})=p(G)$，则称$V^{\prime}$为 $G$ 的边割集。如果点割集中只有一个条边  $e$ ，则称 $e$为割边或桥。  
![图8-42 例题8.24 图模型  ](images/6c126be3977ab4a2c63afc18255dc22be84fa010ee39891af7c0eba551970203.jpg)  
关于点割集与边割集，需要注意以下几个要点：  
（1）完全图 $K_{n}$ 无点割集，因为从 $K_{n}$ 中删除 $k\leq n-1$个顶点后，所得图仍然是连通的。  
（2）$n$ 阶零图既无点割集也无边割集。  
（3）对于连通图 $G$，$E^{\prime}$为 $G$ 的边割集，则必有 $p(G-E^{\prime})=2$ 。 因为删除一条边最多只能增加一个连通分支。  
（4）对于连通图 $G\ \ ,V^{\prime}$为 $G$ 的点割集，则 $p(G-V^{\prime})\geq2$，而且可能 $p(G-E^{\prime})>2$因为删除一个结点可能增加多个连通分支。  
从上述例题可以看出，对于任意给定的一个无向连通图，经常会有多个点割集或边割集，而且每个集合中所含元素的个数也不一样。此时，需要重点关注的应该是那些个数最小的集合。因为这些集合刻画了图连通结构中最为薄弱的环节，反映了连通图的最低连通程度。由此得到无向图连通图的点连通度与边连通度的概念，具体定义如下：  
【定义8.29】对于任意给定的一个无向连通图 $G=\langle V,E\rangle$，令：$\kappa(G){=}m i n\{|V^{\prime}||V^{\prime}$为G 的点割集}；$\lambda(\mathbf{G})=\operatorname*{min}\{|E^{\prime}||E^{\prime}$为G 的边割集} 并称 $\kappa(G)$ 为图 $G$ 的点连通度，$\lambda(G)$ 为图 $G$ 的边连通度。  
显然，点连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少结点数，边连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少边数。  
例如，对于图8-44 所示的无向连通图$G$ ，有$\kappa(G)=2$，$\lambda(G)=3$；对于图8-45 所示的彼得森图，有$\kappa(G)=\lambda(G)=3$。  
![图8-44 图的连通度  ](images/28f9ee3f26ab71faac7e5360d73417062a5a59d8421071b9feb627483727c42a.jpg)  
![图8-45  彼得森图  ](images/80ddd389b19bdc8904c989e51a73f2c183cb8c6f73b8b9c479ee3affcb66c7c0.jpg)  
关于无向连通图的点连通度$\kappa(G)$和边连通度$\lambda(\mathrm{G})$，需要注意以下几个要点：  
（1）如果 $G$是平凡图或非连通图，则规定 $\kappa(G)=\lambda(G)=0;$  
（2）如果$G$ 是完全图 $K_{n}$ ，由于 $G$ 中无点割集，当删除 $n-1$个顶点后，$G$ 为平凡图，故 $\kappa(G)=n-1$。  
（3）如果 $G$ 中存在割点，则 $\kappa(G)=1$；如果 $G$ 中存在割边，则 $\lambda(G)=1$。对于任何无向图 $G$ ，其点连通度 $\kappa$ 、边连通度 $\lambda$ 与结点最小度 δ 之间有如下关系：  
【定理8.8】对于任一无向图$G=\langle V,E\rangle$ ，均成立下列不等式：
$$
\kappa(G)\leq\lambda(G)\leq\delta\ (G)
$$",点连通度是无向连通图中需要删除的最少结点数以使图变为非连通图或平凡图
无向连通图,度量,边连通度,,"前面我们学习了图的可达性概念及其判定，其描述的是图中两个结点之间是否可以通过一条或者多条通路进行联结，并从图的局部角度分别考察两个结点之间的连通关系。现在我  
们从全局性角度考察整个图中多个结点之间的连通关系，将两个结点之间的可达性概念推广到整个图中任意两个结点之间的可达性，由此得到图的连通性和连通图的相关概念。  
在图的连通性方面，无向图和有向图之间具有很大的差异。因此，我们分别讨论无向图和有向图的连通性。本小节主要介绍和讨论无向图连通性的概念与性质。首先给出无向图连通图的相关概念，具体定义如下：  
【定义8.25】设 $G=\langle V,E\rangle$ 为任一给定的无向图，对于图中的两个结点$v_{i}$ 与 $v_{j}$，如果从$\boldsymbol{v}_{i}$到$v_{j}$是可达的，则称从 $v_{i}$ 到 $v_{j}$是连通的，表示为[ $v_{i}\ \ ,v_{j}]$。规定图中任何结点与其自身是连通的。如果无向图$G$中任何两个结点之间都是连通的，则称该图为无向连通图或连通无向图，简称为连通图；否则，称$G$ 是非连通无向图，简称为非连通图。  
显然，无向图中两个结点之间的连通性是双向的，也就是说两结点之间的连通关系满足对称性，即：若有$v_{i}$ 到 $v_{j}$可达则必有$v_{j}$ 到 $v_{i}$可达。故在无向图中，也可将从${v}_{i}$ 到 $v_{j}$的连通说成$v_{i}$ 与 $v_{j}$连通。另外，注意到平凡图有且只有一个结点，根据无向图中结点连通性的规定，它是一种特殊的连通图。  
下面的定理表明，无向图模型中结点之间的连通性关系是一个等价关系：  
【定理8.7】设 $G=\langle V,E\rangle$ 为任一给定的无向图，其结点集为 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，令$R$ 是集合$\cdot V=\{v_{1},v_{2},\ldots,v_{n}\}$上结点之间的连通关系，即有：  
$R=\{\langle u,v\rangle|u,v\in V\}$, 且从$u$到𝑣连通}       （8-10）  
则$R$是集合𝑉上的一个等价关系。  
既然无向图模型中结点之间的连通性关系$R$是一个等价关系，那么就可以使用等价关系$R$ 将无向图 $G$ 的结点集合 𝑉 划分为若干互不相同的等价类，记为   $V_{1},V_{2},\ldots,V_{k}$ 。在这些等价类 中，相互连通的结点属于同一个等价类，不连通的结点属于不同的等价类。由此得到无向图模型的连通分支的概念，具体定义如下：  
【定义8.26】设 $G=\langle V,E\rangle$ 为任一给定的无向图$R$是图$G$结点集合𝑉上的连通性关系，则以关系𝑅的每个等价类为结点集的导出子图都称为图$G$的一个连通分支，并用$p(\mathbf G)$表示图𝐺的连通分支总数。  
由上述定义可知，如果无向图$G=\langle V,E\rangle$的结点连通性关系$R$作为一个等价关系，将结点集𝑉划分为$k$个不同的等价类$V_{1},V_{2},\ldots,V_{k}$，则由它们导出的子图$G(V_{1}),G(V_{2}),\cdots,G(V_{k})$均为图$G$的连通分支。因此，可以根据无向图中结点之间的连通关系实现对图模型的一个分解。显然，若   $p(G)=1$ ，则 $G$ 是连通图。若   $p(G)>1$ ，则   $G$ 是非连通图。  
【定义8.27】对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在结点集𝑉的某个子集 $V^{\prime}\subseteq$$V$ ，使得 $p(G-V^{\prime})>p(G)$ ，且对于 $V^{\prime}$的任何真子集 $V^{\prime\prime}$，有 $p(G-V^{\prime\prime})=p(G)$，则称 $V^{\prime}$为 $G$ 的点割集。如果点割集中只有一个结点 $v$ ，则称 $v$ 为割点。  
由上述定义可知，可通过删除图中适当结点以破坏图结构的方式考察图的连通程度。图中有些结点组成的集合在图的连通性中起着非常关键的作用，删除这些结点后会使得连通图变成非连通图，使得非连通图变得更加不连通，或者增加连通分支的数目。  
显然，对图中的任意一个点割集，该集合中所有结点都是由该点割集增加连通分支时必须同时删除的结点。例如在图8-40 所示的图$G_{1}$中，集合$\{v_{4}\},\{v_{1},v_{3}\}$都是点割集，但$\{v_{1},v_{3},v_{4}\}$则不是点割集，因为要增加图$G_{1}$的连通分支，不必同时删除结点$v_{1},v_{3},v_{4}$。  
需要注意的是，由于删除割点后，割点的邻接边也需要删除，因此我们用虚线表示已删除的边或者结点。同样，对下文所要介绍的边割集也做类似处理。  
同样，可以通过删除图中适当的边以破坏图结构的方式考察图模型的连通程度，由此可以得到边割集的相关概念，具体定义如下：  
【定义8.28】 对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在边集$E$的某个子集 $E^{\prime}\subseteq$$E$ ，使得 $p(G-\ E^{\prime})>p(G)$ ，且对于 $E^{\prime}$的任何真子集 $E^{\prime\prime}$，有 $p(G-\ E^{\prime\prime})=p(G)$，则称$V^{\prime}$为 $G$ 的边割集。如果点割集中只有一个条边  $e$ ，则称 $e$为割边或桥。  
![图8-42 例题8.24 图模型  ](images/6c126be3977ab4a2c63afc18255dc22be84fa010ee39891af7c0eba551970203.jpg)  
关于点割集与边割集，需要注意以下几个要点：  
（1）完全图 $K_{n}$ 无点割集，因为从 $K_{n}$ 中删除 $k\leq n-1$个顶点后，所得图仍然是连通的。  
（2）$n$ 阶零图既无点割集也无边割集。  
（3）对于连通图 $G$，$E^{\prime}$为 $G$ 的边割集，则必有 $p(G-E^{\prime})=2$ 。 因为删除一条边最多只能增加一个连通分支。  
（4）对于连通图 $G\ \ ,V^{\prime}$为 $G$ 的点割集，则 $p(G-V^{\prime})\geq2$，而且可能 $p(G-E^{\prime})>2$因为删除一个结点可能增加多个连通分支。  
从上述例题可以看出，对于任意给定的一个无向连通图，经常会有多个点割集或边割集，而且每个集合中所含元素的个数也不一样。此时，需要重点关注的应该是那些个数最小的集合。因为这些集合刻画了图连通结构中最为薄弱的环节，反映了连通图的最低连通程度。由此得到无向图连通图的点连通度与边连通度的概念，具体定义如下：  
【定义8.29】对于任意给定的一个无向连通图 $G=\langle V,E\rangle$，令：$\kappa(G){=}m i n\{|V^{\prime}||V^{\prime}$为G 的点割集}；$\lambda(\mathbf{G})=\operatorname*{min}\{|E^{\prime}||E^{\prime}$为G 的边割集} 并称 $\kappa(G)$ 为图 $G$ 的点连通度，$\lambda(G)$ 为图 $G$ 的边连通度。  
显然，点连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少结点数，边连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少边数。  
例如，对于图8-44 所示的无向连通图$G$ ，有$\kappa(G)=2$，$\lambda(G)=3$；对于图8-45 所示的彼得森图，有$\kappa(G)=\lambda(G)=3$。  
![图8-44 图的连通度  ](images/28f9ee3f26ab71faac7e5360d73417062a5a59d8421071b9feb627483727c42a.jpg)  
![图8-45  彼得森图  ](images/80ddd389b19bdc8904c989e51a73f2c183cb8c6f73b8b9c479ee3affcb66c7c0.jpg)  
关于无向连通图的点连通度$\kappa(G)$和边连通度$\lambda(\mathrm{G})$，需要注意以下几个要点：  
（1）如果 $G$是平凡图或非连通图，则规定 $\kappa(G)=\lambda(G)=0;$  
（2）如果$G$ 是完全图 $K_{n}$ ，由于 $G$ 中无点割集，当删除 $n-1$个顶点后，$G$ 为平凡图，故 $\kappa(G)=n-1$。  
（3）如果 $G$ 中存在割点，则 $\kappa(G)=1$；如果 $G$ 中存在割边，则 $\lambda(G)=1$。对于任何无向图 $G$ ，其点连通度 $\kappa$ 、边连通度 $\lambda$ 与结点最小度 δ 之间有如下关系：  
【定理8.8】对于任一无向图$G=\langle V,E\rangle$ ，均成立下列不等式：
$$
\kappa(G)\leq\lambda(G)\leq\delta\ (G)
$$",边连通度是无向连通图中需要删除的最少边数以使图变为非连通图或平凡图
定理8.7,证明,图的连通性,,"前面我们学习了图的可达性概念及其判定，其描述的是图中两个结点之间是否可以通过一条或者多条通路进行联结，并从图的局部角度分别考察两个结点之间的连通关系。现在我  
们从全局性角度考察整个图中多个结点之间的连通关系，将两个结点之间的可达性概念推广到整个图中任意两个结点之间的可达性，由此得到图的连通性和连通图的相关概念。  
在图的连通性方面，无向图和有向图之间具有很大的差异。因此，我们分别讨论无向图和有向图的连通性。本小节主要介绍和讨论无向图连通性的概念与性质。首先给出无向图连通图的相关概念，具体定义如下：  
【定义8.25】设 $G=\langle V,E\rangle$ 为任一给定的无向图，对于图中的两个结点$v_{i}$ 与 $v_{j}$，如果从$\boldsymbol{v}_{i}$到$v_{j}$是可达的，则称从 $v_{i}$ 到 $v_{j}$是连通的，表示为[ $v_{i}\ \ ,v_{j}]$。规定图中任何结点与其自身是连通的。如果无向图$G$中任何两个结点之间都是连通的，则称该图为无向连通图或连通无向图，简称为连通图；否则，称$G$ 是非连通无向图，简称为非连通图。  
显然，无向图中两个结点之间的连通性是双向的，也就是说两结点之间的连通关系满足对称性，即：若有$v_{i}$ 到 $v_{j}$可达则必有$v_{j}$ 到 $v_{i}$可达。故在无向图中，也可将从${v}_{i}$ 到 $v_{j}$的连通说成$v_{i}$ 与 $v_{j}$连通。另外，注意到平凡图有且只有一个结点，根据无向图中结点连通性的规定，它是一种特殊的连通图。  
下面的定理表明，无向图模型中结点之间的连通性关系是一个等价关系：  
【定理8.7】设 $G=\langle V,E\rangle$ 为任一给定的无向图，其结点集为 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，令$R$ 是集合$\cdot V=\{v_{1},v_{2},\ldots,v_{n}\}$上结点之间的连通关系，即有：  
$R=\{\langle u,v\rangle|u,v\in V\}$, 且从$u$到𝑣连通}       （8-10）  
则$R$是集合𝑉上的一个等价关系。  
既然无向图模型中结点之间的连通性关系$R$是一个等价关系，那么就可以使用等价关系$R$ 将无向图 $G$ 的结点集合 𝑉 划分为若干互不相同的等价类，记为   $V_{1},V_{2},\ldots,V_{k}$ 。在这些等价类 中，相互连通的结点属于同一个等价类，不连通的结点属于不同的等价类。由此得到无向图模型的连通分支的概念，具体定义如下：  
【定义8.26】设 $G=\langle V,E\rangle$ 为任一给定的无向图$R$是图$G$结点集合𝑉上的连通性关系，则以关系𝑅的每个等价类为结点集的导出子图都称为图$G$的一个连通分支，并用$p(\mathbf G)$表示图𝐺的连通分支总数。  
由上述定义可知，如果无向图$G=\langle V,E\rangle$的结点连通性关系$R$作为一个等价关系，将结点集𝑉划分为$k$个不同的等价类$V_{1},V_{2},\ldots,V_{k}$，则由它们导出的子图$G(V_{1}),G(V_{2}),\cdots,G(V_{k})$均为图$G$的连通分支。因此，可以根据无向图中结点之间的连通关系实现对图模型的一个分解。显然，若   $p(G)=1$ ，则 $G$ 是连通图。若   $p(G)>1$ ，则   $G$ 是非连通图。  
【定义8.27】对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在结点集𝑉的某个子集 $V^{\prime}\subseteq$$V$ ，使得 $p(G-V^{\prime})>p(G)$ ，且对于 $V^{\prime}$的任何真子集 $V^{\prime\prime}$，有 $p(G-V^{\prime\prime})=p(G)$，则称 $V^{\prime}$为 $G$ 的点割集。如果点割集中只有一个结点 $v$ ，则称 $v$ 为割点。  
由上述定义可知，可通过删除图中适当结点以破坏图结构的方式考察图的连通程度。图中有些结点组成的集合在图的连通性中起着非常关键的作用，删除这些结点后会使得连通图变成非连通图，使得非连通图变得更加不连通，或者增加连通分支的数目。  
显然，对图中的任意一个点割集，该集合中所有结点都是由该点割集增加连通分支时必须同时删除的结点。例如在图8-40 所示的图$G_{1}$中，集合$\{v_{4}\},\{v_{1},v_{3}\}$都是点割集，但$\{v_{1},v_{3},v_{4}\}$则不是点割集，因为要增加图$G_{1}$的连通分支，不必同时删除结点$v_{1},v_{3},v_{4}$。  
需要注意的是，由于删除割点后，割点的邻接边也需要删除，因此我们用虚线表示已删除的边或者结点。同样，对下文所要介绍的边割集也做类似处理。  
同样，可以通过删除图中适当的边以破坏图结构的方式考察图模型的连通程度，由此可以得到边割集的相关概念，具体定义如下：  
【定义8.28】 对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在边集$E$的某个子集 $E^{\prime}\subseteq$$E$ ，使得 $p(G-\ E^{\prime})>p(G)$ ，且对于 $E^{\prime}$的任何真子集 $E^{\prime\prime}$，有 $p(G-\ E^{\prime\prime})=p(G)$，则称$V^{\prime}$为 $G$ 的边割集。如果点割集中只有一个条边  $e$ ，则称 $e$为割边或桥。  
![图8-42 例题8.24 图模型  ](images/6c126be3977ab4a2c63afc18255dc22be84fa010ee39891af7c0eba551970203.jpg)  
关于点割集与边割集，需要注意以下几个要点：  
（1）完全图 $K_{n}$ 无点割集，因为从 $K_{n}$ 中删除 $k\leq n-1$个顶点后，所得图仍然是连通的。  
（2）$n$ 阶零图既无点割集也无边割集。  
（3）对于连通图 $G$，$E^{\prime}$为 $G$ 的边割集，则必有 $p(G-E^{\prime})=2$ 。 因为删除一条边最多只能增加一个连通分支。  
（4）对于连通图 $G\ \ ,V^{\prime}$为 $G$ 的点割集，则 $p(G-V^{\prime})\geq2$，而且可能 $p(G-E^{\prime})>2$因为删除一个结点可能增加多个连通分支。  
从上述例题可以看出，对于任意给定的一个无向连通图，经常会有多个点割集或边割集，而且每个集合中所含元素的个数也不一样。此时，需要重点关注的应该是那些个数最小的集合。因为这些集合刻画了图连通结构中最为薄弱的环节，反映了连通图的最低连通程度。由此得到无向图连通图的点连通度与边连通度的概念，具体定义如下：  
【定义8.29】对于任意给定的一个无向连通图 $G=\langle V,E\rangle$，令：$\kappa(G){=}m i n\{|V^{\prime}||V^{\prime}$为G 的点割集}；$\lambda(\mathbf{G})=\operatorname*{min}\{|E^{\prime}||E^{\prime}$为G 的边割集} 并称 $\kappa(G)$ 为图 $G$ 的点连通度，$\lambda(G)$ 为图 $G$ 的边连通度。  
显然，点连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少结点数，边连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少边数。  
例如，对于图8-44 所示的无向连通图$G$ ，有$\kappa(G)=2$，$\lambda(G)=3$；对于图8-45 所示的彼得森图，有$\kappa(G)=\lambda(G)=3$。  
![图8-44 图的连通度  ](images/28f9ee3f26ab71faac7e5360d73417062a5a59d8421071b9feb627483727c42a.jpg)  
![图8-45  彼得森图  ](images/80ddd389b19bdc8904c989e51a73f2c183cb8c6f73b8b9c479ee3affcb66c7c0.jpg)  
关于无向连通图的点连通度$\kappa(G)$和边连通度$\lambda(\mathrm{G})$，需要注意以下几个要点：  
（1）如果 $G$是平凡图或非连通图，则规定 $\kappa(G)=\lambda(G)=0;$  
（2）如果$G$ 是完全图 $K_{n}$ ，由于 $G$ 中无点割集，当删除 $n-1$个顶点后，$G$ 为平凡图，故 $\kappa(G)=n-1$。  
（3）如果 $G$ 中存在割点，则 $\kappa(G)=1$；如果 $G$ 中存在割边，则 $\lambda(G)=1$。对于任何无向图 $G$ ，其点连通度 $\kappa$ 、边连通度 $\lambda$ 与结点最小度 δ 之间有如下关系：  
【定理8.8】对于任一无向图$G=\langle V,E\rangle$ ，均成立下列不等式：
$$
\kappa(G)\leq\lambda(G)\leq\delta\ (G)
$$",定理8.7证明了无向图中结点之间的连通性关系是一个等价关系
定理8.8,关系,点连通度,,"前面我们学习了图的可达性概念及其判定，其描述的是图中两个结点之间是否可以通过一条或者多条通路进行联结，并从图的局部角度分别考察两个结点之间的连通关系。现在我  
们从全局性角度考察整个图中多个结点之间的连通关系，将两个结点之间的可达性概念推广到整个图中任意两个结点之间的可达性，由此得到图的连通性和连通图的相关概念。  
在图的连通性方面，无向图和有向图之间具有很大的差异。因此，我们分别讨论无向图和有向图的连通性。本小节主要介绍和讨论无向图连通性的概念与性质。首先给出无向图连通图的相关概念，具体定义如下：  
【定义8.25】设 $G=\langle V,E\rangle$ 为任一给定的无向图，对于图中的两个结点$v_{i}$ 与 $v_{j}$，如果从$\boldsymbol{v}_{i}$到$v_{j}$是可达的，则称从 $v_{i}$ 到 $v_{j}$是连通的，表示为[ $v_{i}\ \ ,v_{j}]$。规定图中任何结点与其自身是连通的。如果无向图$G$中任何两个结点之间都是连通的，则称该图为无向连通图或连通无向图，简称为连通图；否则，称$G$ 是非连通无向图，简称为非连通图。  
显然，无向图中两个结点之间的连通性是双向的，也就是说两结点之间的连通关系满足对称性，即：若有$v_{i}$ 到 $v_{j}$可达则必有$v_{j}$ 到 $v_{i}$可达。故在无向图中，也可将从${v}_{i}$ 到 $v_{j}$的连通说成$v_{i}$ 与 $v_{j}$连通。另外，注意到平凡图有且只有一个结点，根据无向图中结点连通性的规定，它是一种特殊的连通图。  
下面的定理表明，无向图模型中结点之间的连通性关系是一个等价关系：  
【定理8.7】设 $G=\langle V,E\rangle$ 为任一给定的无向图，其结点集为 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，令$R$ 是集合$\cdot V=\{v_{1},v_{2},\ldots,v_{n}\}$上结点之间的连通关系，即有：  
$R=\{\langle u,v\rangle|u,v\in V\}$, 且从$u$到𝑣连通}       （8-10）  
则$R$是集合𝑉上的一个等价关系。  
既然无向图模型中结点之间的连通性关系$R$是一个等价关系，那么就可以使用等价关系$R$ 将无向图 $G$ 的结点集合 𝑉 划分为若干互不相同的等价类，记为   $V_{1},V_{2},\ldots,V_{k}$ 。在这些等价类 中，相互连通的结点属于同一个等价类，不连通的结点属于不同的等价类。由此得到无向图模型的连通分支的概念，具体定义如下：  
【定义8.26】设 $G=\langle V,E\rangle$ 为任一给定的无向图$R$是图$G$结点集合𝑉上的连通性关系，则以关系𝑅的每个等价类为结点集的导出子图都称为图$G$的一个连通分支，并用$p(\mathbf G)$表示图𝐺的连通分支总数。  
由上述定义可知，如果无向图$G=\langle V,E\rangle$的结点连通性关系$R$作为一个等价关系，将结点集𝑉划分为$k$个不同的等价类$V_{1},V_{2},\ldots,V_{k}$，则由它们导出的子图$G(V_{1}),G(V_{2}),\cdots,G(V_{k})$均为图$G$的连通分支。因此，可以根据无向图中结点之间的连通关系实现对图模型的一个分解。显然，若   $p(G)=1$ ，则 $G$ 是连通图。若   $p(G)>1$ ，则   $G$ 是非连通图。  
【定义8.27】对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在结点集𝑉的某个子集 $V^{\prime}\subseteq$$V$ ，使得 $p(G-V^{\prime})>p(G)$ ，且对于 $V^{\prime}$的任何真子集 $V^{\prime\prime}$，有 $p(G-V^{\prime\prime})=p(G)$，则称 $V^{\prime}$为 $G$ 的点割集。如果点割集中只有一个结点 $v$ ，则称 $v$ 为割点。  
由上述定义可知，可通过删除图中适当结点以破坏图结构的方式考察图的连通程度。图中有些结点组成的集合在图的连通性中起着非常关键的作用，删除这些结点后会使得连通图变成非连通图，使得非连通图变得更加不连通，或者增加连通分支的数目。  
显然，对图中的任意一个点割集，该集合中所有结点都是由该点割集增加连通分支时必须同时删除的结点。例如在图8-40 所示的图$G_{1}$中，集合$\{v_{4}\},\{v_{1},v_{3}\}$都是点割集，但$\{v_{1},v_{3},v_{4}\}$则不是点割集，因为要增加图$G_{1}$的连通分支，不必同时删除结点$v_{1},v_{3},v_{4}$。  
需要注意的是，由于删除割点后，割点的邻接边也需要删除，因此我们用虚线表示已删除的边或者结点。同样，对下文所要介绍的边割集也做类似处理。  
同样，可以通过删除图中适当的边以破坏图结构的方式考察图模型的连通程度，由此可以得到边割集的相关概念，具体定义如下：  
【定义8.28】 对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在边集$E$的某个子集 $E^{\prime}\subseteq$$E$ ，使得 $p(G-\ E^{\prime})>p(G)$ ，且对于 $E^{\prime}$的任何真子集 $E^{\prime\prime}$，有 $p(G-\ E^{\prime\prime})=p(G)$，则称$V^{\prime}$为 $G$ 的边割集。如果点割集中只有一个条边  $e$ ，则称 $e$为割边或桥。  
![图8-42 例题8.24 图模型  ](images/6c126be3977ab4a2c63afc18255dc22be84fa010ee39891af7c0eba551970203.jpg)  
关于点割集与边割集，需要注意以下几个要点：  
（1）完全图 $K_{n}$ 无点割集，因为从 $K_{n}$ 中删除 $k\leq n-1$个顶点后，所得图仍然是连通的。  
（2）$n$ 阶零图既无点割集也无边割集。  
（3）对于连通图 $G$，$E^{\prime}$为 $G$ 的边割集，则必有 $p(G-E^{\prime})=2$ 。 因为删除一条边最多只能增加一个连通分支。  
（4）对于连通图 $G\ \ ,V^{\prime}$为 $G$ 的点割集，则 $p(G-V^{\prime})\geq2$，而且可能 $p(G-E^{\prime})>2$因为删除一个结点可能增加多个连通分支。  
从上述例题可以看出，对于任意给定的一个无向连通图，经常会有多个点割集或边割集，而且每个集合中所含元素的个数也不一样。此时，需要重点关注的应该是那些个数最小的集合。因为这些集合刻画了图连通结构中最为薄弱的环节，反映了连通图的最低连通程度。由此得到无向图连通图的点连通度与边连通度的概念，具体定义如下：  
【定义8.29】对于任意给定的一个无向连通图 $G=\langle V,E\rangle$，令：$\kappa(G){=}m i n\{|V^{\prime}||V^{\prime}$为G 的点割集}；$\lambda(\mathbf{G})=\operatorname*{min}\{|E^{\prime}||E^{\prime}$为G 的边割集} 并称 $\kappa(G)$ 为图 $G$ 的点连通度，$\lambda(G)$ 为图 $G$ 的边连通度。  
显然，点连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少结点数，边连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少边数。  
例如，对于图8-44 所示的无向连通图$G$ ，有$\kappa(G)=2$，$\lambda(G)=3$；对于图8-45 所示的彼得森图，有$\kappa(G)=\lambda(G)=3$。  
![图8-44 图的连通度  ](images/28f9ee3f26ab71faac7e5360d73417062a5a59d8421071b9feb627483727c42a.jpg)  
![图8-45  彼得森图  ](images/80ddd389b19bdc8904c989e51a73f2c183cb8c6f73b8b9c479ee3affcb66c7c0.jpg)  
关于无向连通图的点连通度$\kappa(G)$和边连通度$\lambda(\mathrm{G})$，需要注意以下几个要点：  
（1）如果 $G$是平凡图或非连通图，则规定 $\kappa(G)=\lambda(G)=0;$  
（2）如果$G$ 是完全图 $K_{n}$ ，由于 $G$ 中无点割集，当删除 $n-1$个顶点后，$G$ 为平凡图，故 $\kappa(G)=n-1$。  
（3）如果 $G$ 中存在割点，则 $\kappa(G)=1$；如果 $G$ 中存在割边，则 $\lambda(G)=1$。对于任何无向图 $G$ ，其点连通度 $\kappa$ 、边连通度 $\lambda$ 与结点最小度 δ 之间有如下关系：  
【定理8.8】对于任一无向图$G=\langle V,E\rangle$ ，均成立下列不等式：
$$
\kappa(G)\leq\lambda(G)\leq\delta\ (G)
$$",定理8.8描述了无向图中点连通度、边连通度与结点最小度之间的关系
定理8.8,关系,边连通度,,"前面我们学习了图的可达性概念及其判定，其描述的是图中两个结点之间是否可以通过一条或者多条通路进行联结，并从图的局部角度分别考察两个结点之间的连通关系。现在我  
们从全局性角度考察整个图中多个结点之间的连通关系，将两个结点之间的可达性概念推广到整个图中任意两个结点之间的可达性，由此得到图的连通性和连通图的相关概念。  
在图的连通性方面，无向图和有向图之间具有很大的差异。因此，我们分别讨论无向图和有向图的连通性。本小节主要介绍和讨论无向图连通性的概念与性质。首先给出无向图连通图的相关概念，具体定义如下：  
【定义8.25】设 $G=\langle V,E\rangle$ 为任一给定的无向图，对于图中的两个结点$v_{i}$ 与 $v_{j}$，如果从$\boldsymbol{v}_{i}$到$v_{j}$是可达的，则称从 $v_{i}$ 到 $v_{j}$是连通的，表示为[ $v_{i}\ \ ,v_{j}]$。规定图中任何结点与其自身是连通的。如果无向图$G$中任何两个结点之间都是连通的，则称该图为无向连通图或连通无向图，简称为连通图；否则，称$G$ 是非连通无向图，简称为非连通图。  
显然，无向图中两个结点之间的连通性是双向的，也就是说两结点之间的连通关系满足对称性，即：若有$v_{i}$ 到 $v_{j}$可达则必有$v_{j}$ 到 $v_{i}$可达。故在无向图中，也可将从${v}_{i}$ 到 $v_{j}$的连通说成$v_{i}$ 与 $v_{j}$连通。另外，注意到平凡图有且只有一个结点，根据无向图中结点连通性的规定，它是一种特殊的连通图。  
下面的定理表明，无向图模型中结点之间的连通性关系是一个等价关系：  
【定理8.7】设 $G=\langle V,E\rangle$ 为任一给定的无向图，其结点集为 $V=\{v_{1},v_{2},\ldots,v_{n}\}$，令$R$ 是集合$\cdot V=\{v_{1},v_{2},\ldots,v_{n}\}$上结点之间的连通关系，即有：  
$R=\{\langle u,v\rangle|u,v\in V\}$, 且从$u$到𝑣连通}       （8-10）  
则$R$是集合𝑉上的一个等价关系。  
既然无向图模型中结点之间的连通性关系$R$是一个等价关系，那么就可以使用等价关系$R$ 将无向图 $G$ 的结点集合 𝑉 划分为若干互不相同的等价类，记为   $V_{1},V_{2},\ldots,V_{k}$ 。在这些等价类 中，相互连通的结点属于同一个等价类，不连通的结点属于不同的等价类。由此得到无向图模型的连通分支的概念，具体定义如下：  
【定义8.26】设 $G=\langle V,E\rangle$ 为任一给定的无向图$R$是图$G$结点集合𝑉上的连通性关系，则以关系𝑅的每个等价类为结点集的导出子图都称为图$G$的一个连通分支，并用$p(\mathbf G)$表示图𝐺的连通分支总数。  
由上述定义可知，如果无向图$G=\langle V,E\rangle$的结点连通性关系$R$作为一个等价关系，将结点集𝑉划分为$k$个不同的等价类$V_{1},V_{2},\ldots,V_{k}$，则由它们导出的子图$G(V_{1}),G(V_{2}),\cdots,G(V_{k})$均为图$G$的连通分支。因此，可以根据无向图中结点之间的连通关系实现对图模型的一个分解。显然，若   $p(G)=1$ ，则 $G$ 是连通图。若   $p(G)>1$ ，则   $G$ 是非连通图。  
【定义8.27】对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在结点集𝑉的某个子集 $V^{\prime}\subseteq$$V$ ，使得 $p(G-V^{\prime})>p(G)$ ，且对于 $V^{\prime}$的任何真子集 $V^{\prime\prime}$，有 $p(G-V^{\prime\prime})=p(G)$，则称 $V^{\prime}$为 $G$ 的点割集。如果点割集中只有一个结点 $v$ ，则称 $v$ 为割点。  
由上述定义可知，可通过删除图中适当结点以破坏图结构的方式考察图的连通程度。图中有些结点组成的集合在图的连通性中起着非常关键的作用，删除这些结点后会使得连通图变成非连通图，使得非连通图变得更加不连通，或者增加连通分支的数目。  
显然，对图中的任意一个点割集，该集合中所有结点都是由该点割集增加连通分支时必须同时删除的结点。例如在图8-40 所示的图$G_{1}$中，集合$\{v_{4}\},\{v_{1},v_{3}\}$都是点割集，但$\{v_{1},v_{3},v_{4}\}$则不是点割集，因为要增加图$G_{1}$的连通分支，不必同时删除结点$v_{1},v_{3},v_{4}$。  
需要注意的是，由于删除割点后，割点的邻接边也需要删除，因此我们用虚线表示已删除的边或者结点。同样，对下文所要介绍的边割集也做类似处理。  
同样，可以通过删除图中适当的边以破坏图结构的方式考察图模型的连通程度，由此可以得到边割集的相关概念，具体定义如下：  
【定义8.28】 对于任意给定的一个无向图 $G=\langle V,E\rangle$，若存在边集$E$的某个子集 $E^{\prime}\subseteq$$E$ ，使得 $p(G-\ E^{\prime})>p(G)$ ，且对于 $E^{\prime}$的任何真子集 $E^{\prime\prime}$，有 $p(G-\ E^{\prime\prime})=p(G)$，则称$V^{\prime}$为 $G$ 的边割集。如果点割集中只有一个条边  $e$ ，则称 $e$为割边或桥。  
![图8-42 例题8.24 图模型  ](images/6c126be3977ab4a2c63afc18255dc22be84fa010ee39891af7c0eba551970203.jpg)  
关于点割集与边割集，需要注意以下几个要点：  
（1）完全图 $K_{n}$ 无点割集，因为从 $K_{n}$ 中删除 $k\leq n-1$个顶点后，所得图仍然是连通的。  
（2）$n$ 阶零图既无点割集也无边割集。  
（3）对于连通图 $G$，$E^{\prime}$为 $G$ 的边割集，则必有 $p(G-E^{\prime})=2$ 。 因为删除一条边最多只能增加一个连通分支。  
（4）对于连通图 $G\ \ ,V^{\prime}$为 $G$ 的点割集，则 $p(G-V^{\prime})\geq2$，而且可能 $p(G-E^{\prime})>2$因为删除一个结点可能增加多个连通分支。  
从上述例题可以看出，对于任意给定的一个无向连通图，经常会有多个点割集或边割集，而且每个集合中所含元素的个数也不一样。此时，需要重点关注的应该是那些个数最小的集合。因为这些集合刻画了图连通结构中最为薄弱的环节，反映了连通图的最低连通程度。由此得到无向图连通图的点连通度与边连通度的概念，具体定义如下：  
【定义8.29】对于任意给定的一个无向连通图 $G=\langle V,E\rangle$，令：$\kappa(G){=}m i n\{|V^{\prime}||V^{\prime}$为G 的点割集}；$\lambda(\mathbf{G})=\operatorname*{min}\{|E^{\prime}||E^{\prime}$为G 的边割集} 并称 $\kappa(G)$ 为图 $G$ 的点连通度，$\lambda(G)$ 为图 $G$ 的边连通度。  
显然，点连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少结点数，边连通度表示由 $G$ 产生一个非连通图或平凡图，需要从G中删除的最少边数。  
例如，对于图8-44 所示的无向连通图$G$ ，有$\kappa(G)=2$，$\lambda(G)=3$；对于图8-45 所示的彼得森图，有$\kappa(G)=\lambda(G)=3$。  
![图8-44 图的连通度  ](images/28f9ee3f26ab71faac7e5360d73417062a5a59d8421071b9feb627483727c42a.jpg)  
![图8-45  彼得森图  ](images/80ddd389b19bdc8904c989e51a73f2c183cb8c6f73b8b9c479ee3affcb66c7c0.jpg)  
关于无向连通图的点连通度$\kappa(G)$和边连通度$\lambda(\mathrm{G})$，需要注意以下几个要点：  
（1）如果 $G$是平凡图或非连通图，则规定 $\kappa(G)=\lambda(G)=0;$  
（2）如果$G$ 是完全图 $K_{n}$ ，由于 $G$ 中无点割集，当删除 $n-1$个顶点后，$G$ 为平凡图，故 $\kappa(G)=n-1$。  
（3）如果 $G$ 中存在割点，则 $\kappa(G)=1$；如果 $G$ 中存在割边，则 $\lambda(G)=1$。对于任何无向图 $G$ ，其点连通度 $\kappa$ 、边连通度 $\lambda$ 与结点最小度 δ 之间有如下关系：  
【定理8.8】对于任一无向图$G=\langle V,E\rangle$ ，均成立下列不等式：
$$
\kappa(G)\leq\lambda(G)\leq\delta\ (G)
$$",定理8.8描述了无向图中点连通度、边连通度与结点最小度之间的关系
有向图的连通性,包含,强连通图,,"现在讨论有向图的连通性。与无向图不同的是，有向图中的每条边都具有方向性，结点之间的可达性关系不一定满足对称性。因此，有向图的连通性质比无向图更加复杂，一般要分为强连通、单向连通和弱连通这三种基本情况讨论，其具体定义如下：  
【定义8.30】假设$G=\langle V,E\rangle$任意给定的一个有向图，则有：如果图 $G$中任意两个结点之间都是相互可达的，则称 $G$ 是强连通图；如果图 $G$ 中任意两个结点中至少有一个结点到另一个结点可达，则称 $G$ 是单向连通图，简称为单连通图；对于略去图 $G$ 中各边的方向得到的无向图 $G^{\prime}$，如果 $G^{\prime}$ 是无向连通图，则称 $G$ 是弱连通图，简称为连通图。  
从上述定义可以看出，在没有特别说明的情况下，连通的有向图一般意指为弱连通的有向图。显然，如果一个有向图 $G$ 是强连通的，那么它一定是单连通的，反之不然；如果一个有向图 $G$ 是单向连通图的，那么它一定是弱连通的，反之不然。  
例如，图8-47 所示的三个图模型$G_{1}$, $G_{2}$和$G_{3}$分别是强连通图，单连通图和弱连通图。其中$G_{1}$既是强连通图也是单连通图，$G_{2}$是单连通图也是弱连通图。  
![图8-47 强连通图、单向连通图、弱连通图  ](images/bb31206be85b6681e4bfdebf210d613d4577ab233c09b6ccf50f1f6eb3389294.jpg)  
【定理8.9】（连通性定理）有向图 $G$ 是强连通图的充要条件是存在一条经过图$G$所有结点的回路；有向图 $G$ 是单连通图的充要条件是存在一条经过图𝐺所有结点的通路。  
类似于无向图的连通分支的概念，可分别根据有向图的强连通、单向连通、弱连通概念定义相应的连通分支，得到强分图、单向分图、弱分图的概念，具体定义如下：  
【定义8.31】假设$G=\langle V,E\rangle$任意给定的一个有向图，设 $G^{\prime}$是 $G$ 的一个子图，如果$G^{\prime}$是强连通的（单向连通的、弱连通的），并且对 $\forall G^{\prime\prime}\subseteq G$，若$G^{\prime}\subset G^{\prime\prime}$，则 $G^{\prime\prime}$不是强连通的（单向连通的、弱连通的），则称 $G^{\prime}$ 为 $G$ 的强连通分支（单向连通分支、弱连通分支），简称为强分图（单分图、弱分图）。  
显然，强分图、单分图、弱分图都是 $G$ 的子图，可以用结点集合𝑉的子集导出。显然，强分图是单分图和弱分图，单分图一定是弱分图，但是为了强调它们之间的差异性，一般不再将强分图称为单分图或弱分图，也不再将单分图称为弱分图。  
从上述定义及例题不难看出，可分别通过强分图、单分图、弱分图的概念对有向图中所有结点进行分组。具体地说：  
（1）对于由强连通关系产生的强分图，由于有向图结点之间的强连通关系显然满足自反性、对称性和传递性，因此这种强连通关系是一种等价关系，从而可由此等价关系实现对图中所有结点的划分。显然，每个强分图其实就是一个等价类或者划分块，图中所有的强分图就是构成了所有的划分块。 因此，有向图的任何一个结点属于且仅属于一个强分图。  
（2）对于由弱连通关系产生的弱分图，可类似于无向图的方法进行讨论。事实上，不难看出，弱分图其实就是有向图所导出无向图中的连通分支。因此，所有的弱分图也构成了有向图中所有结点的一种划分，有向图的任何一个结点属于且仅属于一个若分图。  
（3）对于由单向连通关系产生的单分图，不难证明，有向图结点之间的单连通关系满足自反性、对称性，但不满足传递性，因而是一种相容关系。可由此相容关系实现对图中所有结点的最大覆盖。显然，每个强分图其实就是一个最大相容类，图中所有的单分图就是构成了所有的最大相容类。因此，有向图的任何一个结点至少属于一个强分图。  
类似地，可分别通过强分图、单分图、弱分图的概念对有向图中所有边进行分组。 不难发现：对于任何一个给定的有向图，它的每条边至多属于一个其强分图，至少属于一个其单分图，属于且仅属于一个其弱分图。  
例如，对于例题8.30 中的强分图、单分图和弱分图，不难看出它们均满足上述所有关于结点和边分组性质。",有向图的连通性包含强连通图这一类型
有向图的连通性,包含,单向连通图,,"现在讨论有向图的连通性。与无向图不同的是，有向图中的每条边都具有方向性，结点之间的可达性关系不一定满足对称性。因此，有向图的连通性质比无向图更加复杂，一般要分为强连通、单向连通和弱连通这三种基本情况讨论，其具体定义如下：  
【定义8.30】假设$G=\langle V,E\rangle$任意给定的一个有向图，则有：如果图 $G$中任意两个结点之间都是相互可达的，则称 $G$ 是强连通图；如果图 $G$ 中任意两个结点中至少有一个结点到另一个结点可达，则称 $G$ 是单向连通图，简称为单连通图；对于略去图 $G$ 中各边的方向得到的无向图 $G^{\prime}$，如果 $G^{\prime}$ 是无向连通图，则称 $G$ 是弱连通图，简称为连通图。  
从上述定义可以看出，在没有特别说明的情况下，连通的有向图一般意指为弱连通的有向图。显然，如果一个有向图 $G$ 是强连通的，那么它一定是单连通的，反之不然；如果一个有向图 $G$ 是单向连通图的，那么它一定是弱连通的，反之不然。  
例如，图8-47 所示的三个图模型$G_{1}$, $G_{2}$和$G_{3}$分别是强连通图，单连通图和弱连通图。其中$G_{1}$既是强连通图也是单连通图，$G_{2}$是单连通图也是弱连通图。  
![图8-47 强连通图、单向连通图、弱连通图  ](images/bb31206be85b6681e4bfdebf210d613d4577ab233c09b6ccf50f1f6eb3389294.jpg)  
【定理8.9】（连通性定理）有向图 $G$ 是强连通图的充要条件是存在一条经过图$G$所有结点的回路；有向图 $G$ 是单连通图的充要条件是存在一条经过图𝐺所有结点的通路。  
类似于无向图的连通分支的概念，可分别根据有向图的强连通、单向连通、弱连通概念定义相应的连通分支，得到强分图、单向分图、弱分图的概念，具体定义如下：  
【定义8.31】假设$G=\langle V,E\rangle$任意给定的一个有向图，设 $G^{\prime}$是 $G$ 的一个子图，如果$G^{\prime}$是强连通的（单向连通的、弱连通的），并且对 $\forall G^{\prime\prime}\subseteq G$，若$G^{\prime}\subset G^{\prime\prime}$，则 $G^{\prime\prime}$不是强连通的（单向连通的、弱连通的），则称 $G^{\prime}$ 为 $G$ 的强连通分支（单向连通分支、弱连通分支），简称为强分图（单分图、弱分图）。  
显然，强分图、单分图、弱分图都是 $G$ 的子图，可以用结点集合𝑉的子集导出。显然，强分图是单分图和弱分图，单分图一定是弱分图，但是为了强调它们之间的差异性，一般不再将强分图称为单分图或弱分图，也不再将单分图称为弱分图。  
从上述定义及例题不难看出，可分别通过强分图、单分图、弱分图的概念对有向图中所有结点进行分组。具体地说：  
（1）对于由强连通关系产生的强分图，由于有向图结点之间的强连通关系显然满足自反性、对称性和传递性，因此这种强连通关系是一种等价关系，从而可由此等价关系实现对图中所有结点的划分。显然，每个强分图其实就是一个等价类或者划分块，图中所有的强分图就是构成了所有的划分块。 因此，有向图的任何一个结点属于且仅属于一个强分图。  
（2）对于由弱连通关系产生的弱分图，可类似于无向图的方法进行讨论。事实上，不难看出，弱分图其实就是有向图所导出无向图中的连通分支。因此，所有的弱分图也构成了有向图中所有结点的一种划分，有向图的任何一个结点属于且仅属于一个若分图。  
（3）对于由单向连通关系产生的单分图，不难证明，有向图结点之间的单连通关系满足自反性、对称性，但不满足传递性，因而是一种相容关系。可由此相容关系实现对图中所有结点的最大覆盖。显然，每个强分图其实就是一个最大相容类，图中所有的单分图就是构成了所有的最大相容类。因此，有向图的任何一个结点至少属于一个强分图。  
类似地，可分别通过强分图、单分图、弱分图的概念对有向图中所有边进行分组。 不难发现：对于任何一个给定的有向图，它的每条边至多属于一个其强分图，至少属于一个其单分图，属于且仅属于一个其弱分图。  
例如，对于例题8.30 中的强分图、单分图和弱分图，不难看出它们均满足上述所有关于结点和边分组性质。",有向图的连通性包含单向连通图这一类型
有向图的连通性,包含,弱连通图,,"现在讨论有向图的连通性。与无向图不同的是，有向图中的每条边都具有方向性，结点之间的可达性关系不一定满足对称性。因此，有向图的连通性质比无向图更加复杂，一般要分为强连通、单向连通和弱连通这三种基本情况讨论，其具体定义如下：  
【定义8.30】假设$G=\langle V,E\rangle$任意给定的一个有向图，则有：如果图 $G$中任意两个结点之间都是相互可达的，则称 $G$ 是强连通图；如果图 $G$ 中任意两个结点中至少有一个结点到另一个结点可达，则称 $G$ 是单向连通图，简称为单连通图；对于略去图 $G$ 中各边的方向得到的无向图 $G^{\prime}$，如果 $G^{\prime}$ 是无向连通图，则称 $G$ 是弱连通图，简称为连通图。  
从上述定义可以看出，在没有特别说明的情况下，连通的有向图一般意指为弱连通的有向图。显然，如果一个有向图 $G$ 是强连通的，那么它一定是单连通的，反之不然；如果一个有向图 $G$ 是单向连通图的，那么它一定是弱连通的，反之不然。  
例如，图8-47 所示的三个图模型$G_{1}$, $G_{2}$和$G_{3}$分别是强连通图，单连通图和弱连通图。其中$G_{1}$既是强连通图也是单连通图，$G_{2}$是单连通图也是弱连通图。  
![图8-47 强连通图、单向连通图、弱连通图  ](images/bb31206be85b6681e4bfdebf210d613d4577ab233c09b6ccf50f1f6eb3389294.jpg)  
【定理8.9】（连通性定理）有向图 $G$ 是强连通图的充要条件是存在一条经过图$G$所有结点的回路；有向图 $G$ 是单连通图的充要条件是存在一条经过图𝐺所有结点的通路。  
类似于无向图的连通分支的概念，可分别根据有向图的强连通、单向连通、弱连通概念定义相应的连通分支，得到强分图、单向分图、弱分图的概念，具体定义如下：  
【定义8.31】假设$G=\langle V,E\rangle$任意给定的一个有向图，设 $G^{\prime}$是 $G$ 的一个子图，如果$G^{\prime}$是强连通的（单向连通的、弱连通的），并且对 $\forall G^{\prime\prime}\subseteq G$，若$G^{\prime}\subset G^{\prime\prime}$，则 $G^{\prime\prime}$不是强连通的（单向连通的、弱连通的），则称 $G^{\prime}$ 为 $G$ 的强连通分支（单向连通分支、弱连通分支），简称为强分图（单分图、弱分图）。  
显然，强分图、单分图、弱分图都是 $G$ 的子图，可以用结点集合𝑉的子集导出。显然，强分图是单分图和弱分图，单分图一定是弱分图，但是为了强调它们之间的差异性，一般不再将强分图称为单分图或弱分图，也不再将单分图称为弱分图。  
从上述定义及例题不难看出，可分别通过强分图、单分图、弱分图的概念对有向图中所有结点进行分组。具体地说：  
（1）对于由强连通关系产生的强分图，由于有向图结点之间的强连通关系显然满足自反性、对称性和传递性，因此这种强连通关系是一种等价关系，从而可由此等价关系实现对图中所有结点的划分。显然，每个强分图其实就是一个等价类或者划分块，图中所有的强分图就是构成了所有的划分块。 因此，有向图的任何一个结点属于且仅属于一个强分图。  
（2）对于由弱连通关系产生的弱分图，可类似于无向图的方法进行讨论。事实上，不难看出，弱分图其实就是有向图所导出无向图中的连通分支。因此，所有的弱分图也构成了有向图中所有结点的一种划分，有向图的任何一个结点属于且仅属于一个若分图。  
（3）对于由单向连通关系产生的单分图，不难证明，有向图结点之间的单连通关系满足自反性、对称性，但不满足传递性，因而是一种相容关系。可由此相容关系实现对图中所有结点的最大覆盖。显然，每个强分图其实就是一个最大相容类，图中所有的单分图就是构成了所有的最大相容类。因此，有向图的任何一个结点至少属于一个强分图。  
类似地，可分别通过强分图、单分图、弱分图的概念对有向图中所有边进行分组。 不难发现：对于任何一个给定的有向图，它的每条边至多属于一个其强分图，至少属于一个其单分图，属于且仅属于一个其弱分图。  
例如，对于例题8.30 中的强分图、单分图和弱分图，不难看出它们均满足上述所有关于结点和边分组性质。",有向图的连通性包含弱连通图这一类型
强连通图,蕴含,单向连通图,,"现在讨论有向图的连通性。与无向图不同的是，有向图中的每条边都具有方向性，结点之间的可达性关系不一定满足对称性。因此，有向图的连通性质比无向图更加复杂，一般要分为强连通、单向连通和弱连通这三种基本情况讨论，其具体定义如下：  
【定义8.30】假设$G=\langle V,E\rangle$任意给定的一个有向图，则有：如果图 $G$中任意两个结点之间都是相互可达的，则称 $G$ 是强连通图；如果图 $G$ 中任意两个结点中至少有一个结点到另一个结点可达，则称 $G$ 是单向连通图，简称为单连通图；对于略去图 $G$ 中各边的方向得到的无向图 $G^{\prime}$，如果 $G^{\prime}$ 是无向连通图，则称 $G$ 是弱连通图，简称为连通图。  
从上述定义可以看出，在没有特别说明的情况下，连通的有向图一般意指为弱连通的有向图。显然，如果一个有向图 $G$ 是强连通的，那么它一定是单连通的，反之不然；如果一个有向图 $G$ 是单向连通图的，那么它一定是弱连通的，反之不然。  
例如，图8-47 所示的三个图模型$G_{1}$, $G_{2}$和$G_{3}$分别是强连通图，单连通图和弱连通图。其中$G_{1}$既是强连通图也是单连通图，$G_{2}$是单连通图也是弱连通图。  
![图8-47 强连通图、单向连通图、弱连通图  ](images/bb31206be85b6681e4bfdebf210d613d4577ab233c09b6ccf50f1f6eb3389294.jpg)  
【定理8.9】（连通性定理）有向图 $G$ 是强连通图的充要条件是存在一条经过图$G$所有结点的回路；有向图 $G$ 是单连通图的充要条件是存在一条经过图𝐺所有结点的通路。  
类似于无向图的连通分支的概念，可分别根据有向图的强连通、单向连通、弱连通概念定义相应的连通分支，得到强分图、单向分图、弱分图的概念，具体定义如下：  
【定义8.31】假设$G=\langle V,E\rangle$任意给定的一个有向图，设 $G^{\prime}$是 $G$ 的一个子图，如果$G^{\prime}$是强连通的（单向连通的、弱连通的），并且对 $\forall G^{\prime\prime}\subseteq G$，若$G^{\prime}\subset G^{\prime\prime}$，则 $G^{\prime\prime}$不是强连通的（单向连通的、弱连通的），则称 $G^{\prime}$ 为 $G$ 的强连通分支（单向连通分支、弱连通分支），简称为强分图（单分图、弱分图）。  
显然，强分图、单分图、弱分图都是 $G$ 的子图，可以用结点集合𝑉的子集导出。显然，强分图是单分图和弱分图，单分图一定是弱分图，但是为了强调它们之间的差异性，一般不再将强分图称为单分图或弱分图，也不再将单分图称为弱分图。  
从上述定义及例题不难看出，可分别通过强分图、单分图、弱分图的概念对有向图中所有结点进行分组。具体地说：  
（1）对于由强连通关系产生的强分图，由于有向图结点之间的强连通关系显然满足自反性、对称性和传递性，因此这种强连通关系是一种等价关系，从而可由此等价关系实现对图中所有结点的划分。显然，每个强分图其实就是一个等价类或者划分块，图中所有的强分图就是构成了所有的划分块。 因此，有向图的任何一个结点属于且仅属于一个强分图。  
（2）对于由弱连通关系产生的弱分图，可类似于无向图的方法进行讨论。事实上，不难看出，弱分图其实就是有向图所导出无向图中的连通分支。因此，所有的弱分图也构成了有向图中所有结点的一种划分，有向图的任何一个结点属于且仅属于一个若分图。  
（3）对于由单向连通关系产生的单分图，不难证明，有向图结点之间的单连通关系满足自反性、对称性，但不满足传递性，因而是一种相容关系。可由此相容关系实现对图中所有结点的最大覆盖。显然，每个强分图其实就是一个最大相容类，图中所有的单分图就是构成了所有的最大相容类。因此，有向图的任何一个结点至少属于一个强分图。  
类似地，可分别通过强分图、单分图、弱分图的概念对有向图中所有边进行分组。 不难发现：对于任何一个给定的有向图，它的每条边至多属于一个其强分图，至少属于一个其单分图，属于且仅属于一个其弱分图。  
例如，对于例题8.30 中的强分图、单分图和弱分图，不难看出它们均满足上述所有关于结点和边分组性质。",强连通图一定是单向连通图
单向连通图,蕴含,弱连通图,,"现在讨论有向图的连通性。与无向图不同的是，有向图中的每条边都具有方向性，结点之间的可达性关系不一定满足对称性。因此，有向图的连通性质比无向图更加复杂，一般要分为强连通、单向连通和弱连通这三种基本情况讨论，其具体定义如下：  
【定义8.30】假设$G=\langle V,E\rangle$任意给定的一个有向图，则有：如果图 $G$中任意两个结点之间都是相互可达的，则称 $G$ 是强连通图；如果图 $G$ 中任意两个结点中至少有一个结点到另一个结点可达，则称 $G$ 是单向连通图，简称为单连通图；对于略去图 $G$ 中各边的方向得到的无向图 $G^{\prime}$，如果 $G^{\prime}$ 是无向连通图，则称 $G$ 是弱连通图，简称为连通图。  
从上述定义可以看出，在没有特别说明的情况下，连通的有向图一般意指为弱连通的有向图。显然，如果一个有向图 $G$ 是强连通的，那么它一定是单连通的，反之不然；如果一个有向图 $G$ 是单向连通图的，那么它一定是弱连通的，反之不然。  
例如，图8-47 所示的三个图模型$G_{1}$, $G_{2}$和$G_{3}$分别是强连通图，单连通图和弱连通图。其中$G_{1}$既是强连通图也是单连通图，$G_{2}$是单连通图也是弱连通图。  
![图8-47 强连通图、单向连通图、弱连通图  ](images/bb31206be85b6681e4bfdebf210d613d4577ab233c09b6ccf50f1f6eb3389294.jpg)  
【定理8.9】（连通性定理）有向图 $G$ 是强连通图的充要条件是存在一条经过图$G$所有结点的回路；有向图 $G$ 是单连通图的充要条件是存在一条经过图𝐺所有结点的通路。  
类似于无向图的连通分支的概念，可分别根据有向图的强连通、单向连通、弱连通概念定义相应的连通分支，得到强分图、单向分图、弱分图的概念，具体定义如下：  
【定义8.31】假设$G=\langle V,E\rangle$任意给定的一个有向图，设 $G^{\prime}$是 $G$ 的一个子图，如果$G^{\prime}$是强连通的（单向连通的、弱连通的），并且对 $\forall G^{\prime\prime}\subseteq G$，若$G^{\prime}\subset G^{\prime\prime}$，则 $G^{\prime\prime}$不是强连通的（单向连通的、弱连通的），则称 $G^{\prime}$ 为 $G$ 的强连通分支（单向连通分支、弱连通分支），简称为强分图（单分图、弱分图）。  
显然，强分图、单分图、弱分图都是 $G$ 的子图，可以用结点集合𝑉的子集导出。显然，强分图是单分图和弱分图，单分图一定是弱分图，但是为了强调它们之间的差异性，一般不再将强分图称为单分图或弱分图，也不再将单分图称为弱分图。  
从上述定义及例题不难看出，可分别通过强分图、单分图、弱分图的概念对有向图中所有结点进行分组。具体地说：  
（1）对于由强连通关系产生的强分图，由于有向图结点之间的强连通关系显然满足自反性、对称性和传递性，因此这种强连通关系是一种等价关系，从而可由此等价关系实现对图中所有结点的划分。显然，每个强分图其实就是一个等价类或者划分块，图中所有的强分图就是构成了所有的划分块。 因此，有向图的任何一个结点属于且仅属于一个强分图。  
（2）对于由弱连通关系产生的弱分图，可类似于无向图的方法进行讨论。事实上，不难看出，弱分图其实就是有向图所导出无向图中的连通分支。因此，所有的弱分图也构成了有向图中所有结点的一种划分，有向图的任何一个结点属于且仅属于一个若分图。  
（3）对于由单向连通关系产生的单分图，不难证明，有向图结点之间的单连通关系满足自反性、对称性，但不满足传递性，因而是一种相容关系。可由此相容关系实现对图中所有结点的最大覆盖。显然，每个强分图其实就是一个最大相容类，图中所有的单分图就是构成了所有的最大相容类。因此，有向图的任何一个结点至少属于一个强分图。  
类似地，可分别通过强分图、单分图、弱分图的概念对有向图中所有边进行分组。 不难发现：对于任何一个给定的有向图，它的每条边至多属于一个其强分图，至少属于一个其单分图，属于且仅属于一个其弱分图。  
例如，对于例题8.30 中的强分图、单分图和弱分图，不难看出它们均满足上述所有关于结点和边分组性质。",单向连通图一定是弱连通图
连通性定理,条件,强连通图,,"现在讨论有向图的连通性。与无向图不同的是，有向图中的每条边都具有方向性，结点之间的可达性关系不一定满足对称性。因此，有向图的连通性质比无向图更加复杂，一般要分为强连通、单向连通和弱连通这三种基本情况讨论，其具体定义如下：  
【定义8.30】假设$G=\langle V,E\rangle$任意给定的一个有向图，则有：如果图 $G$中任意两个结点之间都是相互可达的，则称 $G$ 是强连通图；如果图 $G$ 中任意两个结点中至少有一个结点到另一个结点可达，则称 $G$ 是单向连通图，简称为单连通图；对于略去图 $G$ 中各边的方向得到的无向图 $G^{\prime}$，如果 $G^{\prime}$ 是无向连通图，则称 $G$ 是弱连通图，简称为连通图。  
从上述定义可以看出，在没有特别说明的情况下，连通的有向图一般意指为弱连通的有向图。显然，如果一个有向图 $G$ 是强连通的，那么它一定是单连通的，反之不然；如果一个有向图 $G$ 是单向连通图的，那么它一定是弱连通的，反之不然。  
例如，图8-47 所示的三个图模型$G_{1}$, $G_{2}$和$G_{3}$分别是强连通图，单连通图和弱连通图。其中$G_{1}$既是强连通图也是单连通图，$G_{2}$是单连通图也是弱连通图。  
![图8-47 强连通图、单向连通图、弱连通图  ](images/bb31206be85b6681e4bfdebf210d613d4577ab233c09b6ccf50f1f6eb3389294.jpg)  
【定理8.9】（连通性定理）有向图 $G$ 是强连通图的充要条件是存在一条经过图$G$所有结点的回路；有向图 $G$ 是单连通图的充要条件是存在一条经过图𝐺所有结点的通路。  
类似于无向图的连通分支的概念，可分别根据有向图的强连通、单向连通、弱连通概念定义相应的连通分支，得到强分图、单向分图、弱分图的概念，具体定义如下：  
【定义8.31】假设$G=\langle V,E\rangle$任意给定的一个有向图，设 $G^{\prime}$是 $G$ 的一个子图，如果$G^{\prime}$是强连通的（单向连通的、弱连通的），并且对 $\forall G^{\prime\prime}\subseteq G$，若$G^{\prime}\subset G^{\prime\prime}$，则 $G^{\prime\prime}$不是强连通的（单向连通的、弱连通的），则称 $G^{\prime}$ 为 $G$ 的强连通分支（单向连通分支、弱连通分支），简称为强分图（单分图、弱分图）。  
显然，强分图、单分图、弱分图都是 $G$ 的子图，可以用结点集合𝑉的子集导出。显然，强分图是单分图和弱分图，单分图一定是弱分图，但是为了强调它们之间的差异性，一般不再将强分图称为单分图或弱分图，也不再将单分图称为弱分图。  
从上述定义及例题不难看出，可分别通过强分图、单分图、弱分图的概念对有向图中所有结点进行分组。具体地说：  
（1）对于由强连通关系产生的强分图，由于有向图结点之间的强连通关系显然满足自反性、对称性和传递性，因此这种强连通关系是一种等价关系，从而可由此等价关系实现对图中所有结点的划分。显然，每个强分图其实就是一个等价类或者划分块，图中所有的强分图就是构成了所有的划分块。 因此，有向图的任何一个结点属于且仅属于一个强分图。  
（2）对于由弱连通关系产生的弱分图，可类似于无向图的方法进行讨论。事实上，不难看出，弱分图其实就是有向图所导出无向图中的连通分支。因此，所有的弱分图也构成了有向图中所有结点的一种划分，有向图的任何一个结点属于且仅属于一个若分图。  
（3）对于由单向连通关系产生的单分图，不难证明，有向图结点之间的单连通关系满足自反性、对称性，但不满足传递性，因而是一种相容关系。可由此相容关系实现对图中所有结点的最大覆盖。显然，每个强分图其实就是一个最大相容类，图中所有的单分图就是构成了所有的最大相容类。因此，有向图的任何一个结点至少属于一个强分图。  
类似地，可分别通过强分图、单分图、弱分图的概念对有向图中所有边进行分组。 不难发现：对于任何一个给定的有向图，它的每条边至多属于一个其强分图，至少属于一个其单分图，属于且仅属于一个其弱分图。  
例如，对于例题8.30 中的强分图、单分图和弱分图，不难看出它们均满足上述所有关于结点和边分组性质。",连通性定理指出强连通图的充要条件是存在一条经过所有结点的回路
连通性定理,条件,单向连通图,,"现在讨论有向图的连通性。与无向图不同的是，有向图中的每条边都具有方向性，结点之间的可达性关系不一定满足对称性。因此，有向图的连通性质比无向图更加复杂，一般要分为强连通、单向连通和弱连通这三种基本情况讨论，其具体定义如下：  
【定义8.30】假设$G=\langle V,E\rangle$任意给定的一个有向图，则有：如果图 $G$中任意两个结点之间都是相互可达的，则称 $G$ 是强连通图；如果图 $G$ 中任意两个结点中至少有一个结点到另一个结点可达，则称 $G$ 是单向连通图，简称为单连通图；对于略去图 $G$ 中各边的方向得到的无向图 $G^{\prime}$，如果 $G^{\prime}$ 是无向连通图，则称 $G$ 是弱连通图，简称为连通图。  
从上述定义可以看出，在没有特别说明的情况下，连通的有向图一般意指为弱连通的有向图。显然，如果一个有向图 $G$ 是强连通的，那么它一定是单连通的，反之不然；如果一个有向图 $G$ 是单向连通图的，那么它一定是弱连通的，反之不然。  
例如，图8-47 所示的三个图模型$G_{1}$, $G_{2}$和$G_{3}$分别是强连通图，单连通图和弱连通图。其中$G_{1}$既是强连通图也是单连通图，$G_{2}$是单连通图也是弱连通图。  
![图8-47 强连通图、单向连通图、弱连通图  ](images/bb31206be85b6681e4bfdebf210d613d4577ab233c09b6ccf50f1f6eb3389294.jpg)  
【定理8.9】（连通性定理）有向图 $G$ 是强连通图的充要条件是存在一条经过图$G$所有结点的回路；有向图 $G$ 是单连通图的充要条件是存在一条经过图𝐺所有结点的通路。  
类似于无向图的连通分支的概念，可分别根据有向图的强连通、单向连通、弱连通概念定义相应的连通分支，得到强分图、单向分图、弱分图的概念，具体定义如下：  
【定义8.31】假设$G=\langle V,E\rangle$任意给定的一个有向图，设 $G^{\prime}$是 $G$ 的一个子图，如果$G^{\prime}$是强连通的（单向连通的、弱连通的），并且对 $\forall G^{\prime\prime}\subseteq G$，若$G^{\prime}\subset G^{\prime\prime}$，则 $G^{\prime\prime}$不是强连通的（单向连通的、弱连通的），则称 $G^{\prime}$ 为 $G$ 的强连通分支（单向连通分支、弱连通分支），简称为强分图（单分图、弱分图）。  
显然，强分图、单分图、弱分图都是 $G$ 的子图，可以用结点集合𝑉的子集导出。显然，强分图是单分图和弱分图，单分图一定是弱分图，但是为了强调它们之间的差异性，一般不再将强分图称为单分图或弱分图，也不再将单分图称为弱分图。  
从上述定义及例题不难看出，可分别通过强分图、单分图、弱分图的概念对有向图中所有结点进行分组。具体地说：  
（1）对于由强连通关系产生的强分图，由于有向图结点之间的强连通关系显然满足自反性、对称性和传递性，因此这种强连通关系是一种等价关系，从而可由此等价关系实现对图中所有结点的划分。显然，每个强分图其实就是一个等价类或者划分块，图中所有的强分图就是构成了所有的划分块。 因此，有向图的任何一个结点属于且仅属于一个强分图。  
（2）对于由弱连通关系产生的弱分图，可类似于无向图的方法进行讨论。事实上，不难看出，弱分图其实就是有向图所导出无向图中的连通分支。因此，所有的弱分图也构成了有向图中所有结点的一种划分，有向图的任何一个结点属于且仅属于一个若分图。  
（3）对于由单向连通关系产生的单分图，不难证明，有向图结点之间的单连通关系满足自反性、对称性，但不满足传递性，因而是一种相容关系。可由此相容关系实现对图中所有结点的最大覆盖。显然，每个强分图其实就是一个最大相容类，图中所有的单分图就是构成了所有的最大相容类。因此，有向图的任何一个结点至少属于一个强分图。  
类似地，可分别通过强分图、单分图、弱分图的概念对有向图中所有边进行分组。 不难发现：对于任何一个给定的有向图，它的每条边至多属于一个其强分图，至少属于一个其单分图，属于且仅属于一个其弱分图。  
例如，对于例题8.30 中的强分图、单分图和弱分图，不难看出它们均满足上述所有关于结点和边分组性质。",连通性定理指出单向连通图的充要条件是存在一条经过所有结点的通路
强分图,包含,单向分图,,"现在讨论有向图的连通性。与无向图不同的是，有向图中的每条边都具有方向性，结点之间的可达性关系不一定满足对称性。因此，有向图的连通性质比无向图更加复杂，一般要分为强连通、单向连通和弱连通这三种基本情况讨论，其具体定义如下：  
【定义8.30】假设$G=\langle V,E\rangle$任意给定的一个有向图，则有：如果图 $G$中任意两个结点之间都是相互可达的，则称 $G$ 是强连通图；如果图 $G$ 中任意两个结点中至少有一个结点到另一个结点可达，则称 $G$ 是单向连通图，简称为单连通图；对于略去图 $G$ 中各边的方向得到的无向图 $G^{\prime}$，如果 $G^{\prime}$ 是无向连通图，则称 $G$ 是弱连通图，简称为连通图。  
从上述定义可以看出，在没有特别说明的情况下，连通的有向图一般意指为弱连通的有向图。显然，如果一个有向图 $G$ 是强连通的，那么它一定是单连通的，反之不然；如果一个有向图 $G$ 是单向连通图的，那么它一定是弱连通的，反之不然。  
例如，图8-47 所示的三个图模型$G_{1}$, $G_{2}$和$G_{3}$分别是强连通图，单连通图和弱连通图。其中$G_{1}$既是强连通图也是单连通图，$G_{2}$是单连通图也是弱连通图。  
![图8-47 强连通图、单向连通图、弱连通图  ](images/bb31206be85b6681e4bfdebf210d613d4577ab233c09b6ccf50f1f6eb3389294.jpg)  
【定理8.9】（连通性定理）有向图 $G$ 是强连通图的充要条件是存在一条经过图$G$所有结点的回路；有向图 $G$ 是单连通图的充要条件是存在一条经过图𝐺所有结点的通路。  
类似于无向图的连通分支的概念，可分别根据有向图的强连通、单向连通、弱连通概念定义相应的连通分支，得到强分图、单向分图、弱分图的概念，具体定义如下：  
【定义8.31】假设$G=\langle V,E\rangle$任意给定的一个有向图，设 $G^{\prime}$是 $G$ 的一个子图，如果$G^{\prime}$是强连通的（单向连通的、弱连通的），并且对 $\forall G^{\prime\prime}\subseteq G$，若$G^{\prime}\subset G^{\prime\prime}$，则 $G^{\prime\prime}$不是强连通的（单向连通的、弱连通的），则称 $G^{\prime}$ 为 $G$ 的强连通分支（单向连通分支、弱连通分支），简称为强分图（单分图、弱分图）。  
显然，强分图、单分图、弱分图都是 $G$ 的子图，可以用结点集合𝑉的子集导出。显然，强分图是单分图和弱分图，单分图一定是弱分图，但是为了强调它们之间的差异性，一般不再将强分图称为单分图或弱分图，也不再将单分图称为弱分图。  
从上述定义及例题不难看出，可分别通过强分图、单分图、弱分图的概念对有向图中所有结点进行分组。具体地说：  
（1）对于由强连通关系产生的强分图，由于有向图结点之间的强连通关系显然满足自反性、对称性和传递性，因此这种强连通关系是一种等价关系，从而可由此等价关系实现对图中所有结点的划分。显然，每个强分图其实就是一个等价类或者划分块，图中所有的强分图就是构成了所有的划分块。 因此，有向图的任何一个结点属于且仅属于一个强分图。  
（2）对于由弱连通关系产生的弱分图，可类似于无向图的方法进行讨论。事实上，不难看出，弱分图其实就是有向图所导出无向图中的连通分支。因此，所有的弱分图也构成了有向图中所有结点的一种划分，有向图的任何一个结点属于且仅属于一个若分图。  
（3）对于由单向连通关系产生的单分图，不难证明，有向图结点之间的单连通关系满足自反性、对称性，但不满足传递性，因而是一种相容关系。可由此相容关系实现对图中所有结点的最大覆盖。显然，每个强分图其实就是一个最大相容类，图中所有的单分图就是构成了所有的最大相容类。因此，有向图的任何一个结点至少属于一个强分图。  
类似地，可分别通过强分图、单分图、弱分图的概念对有向图中所有边进行分组。 不难发现：对于任何一个给定的有向图，它的每条边至多属于一个其强分图，至少属于一个其单分图，属于且仅属于一个其弱分图。  
例如，对于例题8.30 中的强分图、单分图和弱分图，不难看出它们均满足上述所有关于结点和边分组性质。",强分图是单向分图的一种
单向分图,包含,弱分图,,"现在讨论有向图的连通性。与无向图不同的是，有向图中的每条边都具有方向性，结点之间的可达性关系不一定满足对称性。因此，有向图的连通性质比无向图更加复杂，一般要分为强连通、单向连通和弱连通这三种基本情况讨论，其具体定义如下：  
【定义8.30】假设$G=\langle V,E\rangle$任意给定的一个有向图，则有：如果图 $G$中任意两个结点之间都是相互可达的，则称 $G$ 是强连通图；如果图 $G$ 中任意两个结点中至少有一个结点到另一个结点可达，则称 $G$ 是单向连通图，简称为单连通图；对于略去图 $G$ 中各边的方向得到的无向图 $G^{\prime}$，如果 $G^{\prime}$ 是无向连通图，则称 $G$ 是弱连通图，简称为连通图。  
从上述定义可以看出，在没有特别说明的情况下，连通的有向图一般意指为弱连通的有向图。显然，如果一个有向图 $G$ 是强连通的，那么它一定是单连通的，反之不然；如果一个有向图 $G$ 是单向连通图的，那么它一定是弱连通的，反之不然。  
例如，图8-47 所示的三个图模型$G_{1}$, $G_{2}$和$G_{3}$分别是强连通图，单连通图和弱连通图。其中$G_{1}$既是强连通图也是单连通图，$G_{2}$是单连通图也是弱连通图。  
![图8-47 强连通图、单向连通图、弱连通图  ](images/bb31206be85b6681e4bfdebf210d613d4577ab233c09b6ccf50f1f6eb3389294.jpg)  
【定理8.9】（连通性定理）有向图 $G$ 是强连通图的充要条件是存在一条经过图$G$所有结点的回路；有向图 $G$ 是单连通图的充要条件是存在一条经过图𝐺所有结点的通路。  
类似于无向图的连通分支的概念，可分别根据有向图的强连通、单向连通、弱连通概念定义相应的连通分支，得到强分图、单向分图、弱分图的概念，具体定义如下：  
【定义8.31】假设$G=\langle V,E\rangle$任意给定的一个有向图，设 $G^{\prime}$是 $G$ 的一个子图，如果$G^{\prime}$是强连通的（单向连通的、弱连通的），并且对 $\forall G^{\prime\prime}\subseteq G$，若$G^{\prime}\subset G^{\prime\prime}$，则 $G^{\prime\prime}$不是强连通的（单向连通的、弱连通的），则称 $G^{\prime}$ 为 $G$ 的强连通分支（单向连通分支、弱连通分支），简称为强分图（单分图、弱分图）。  
显然，强分图、单分图、弱分图都是 $G$ 的子图，可以用结点集合𝑉的子集导出。显然，强分图是单分图和弱分图，单分图一定是弱分图，但是为了强调它们之间的差异性，一般不再将强分图称为单分图或弱分图，也不再将单分图称为弱分图。  
从上述定义及例题不难看出，可分别通过强分图、单分图、弱分图的概念对有向图中所有结点进行分组。具体地说：  
（1）对于由强连通关系产生的强分图，由于有向图结点之间的强连通关系显然满足自反性、对称性和传递性，因此这种强连通关系是一种等价关系，从而可由此等价关系实现对图中所有结点的划分。显然，每个强分图其实就是一个等价类或者划分块，图中所有的强分图就是构成了所有的划分块。 因此，有向图的任何一个结点属于且仅属于一个强分图。  
（2）对于由弱连通关系产生的弱分图，可类似于无向图的方法进行讨论。事实上，不难看出，弱分图其实就是有向图所导出无向图中的连通分支。因此，所有的弱分图也构成了有向图中所有结点的一种划分，有向图的任何一个结点属于且仅属于一个若分图。  
（3）对于由单向连通关系产生的单分图，不难证明，有向图结点之间的单连通关系满足自反性、对称性，但不满足传递性，因而是一种相容关系。可由此相容关系实现对图中所有结点的最大覆盖。显然，每个强分图其实就是一个最大相容类，图中所有的单分图就是构成了所有的最大相容类。因此，有向图的任何一个结点至少属于一个强分图。  
类似地，可分别通过强分图、单分图、弱分图的概念对有向图中所有边进行分组。 不难发现：对于任何一个给定的有向图，它的每条边至多属于一个其强分图，至少属于一个其单分图，属于且仅属于一个其弱分图。  
例如，对于例题8.30 中的强分图、单分图和弱分图，不难看出它们均满足上述所有关于结点和边分组性质。",单向分图是弱分图的一种
强分图,包含,弱分图,,"现在讨论有向图的连通性。与无向图不同的是，有向图中的每条边都具有方向性，结点之间的可达性关系不一定满足对称性。因此，有向图的连通性质比无向图更加复杂，一般要分为强连通、单向连通和弱连通这三种基本情况讨论，其具体定义如下：  
【定义8.30】假设$G=\langle V,E\rangle$任意给定的一个有向图，则有：如果图 $G$中任意两个结点之间都是相互可达的，则称 $G$ 是强连通图；如果图 $G$ 中任意两个结点中至少有一个结点到另一个结点可达，则称 $G$ 是单向连通图，简称为单连通图；对于略去图 $G$ 中各边的方向得到的无向图 $G^{\prime}$，如果 $G^{\prime}$ 是无向连通图，则称 $G$ 是弱连通图，简称为连通图。  
从上述定义可以看出，在没有特别说明的情况下，连通的有向图一般意指为弱连通的有向图。显然，如果一个有向图 $G$ 是强连通的，那么它一定是单连通的，反之不然；如果一个有向图 $G$ 是单向连通图的，那么它一定是弱连通的，反之不然。  
例如，图8-47 所示的三个图模型$G_{1}$, $G_{2}$和$G_{3}$分别是强连通图，单连通图和弱连通图。其中$G_{1}$既是强连通图也是单连通图，$G_{2}$是单连通图也是弱连通图。  
![图8-47 强连通图、单向连通图、弱连通图  ](images/bb31206be85b6681e4bfdebf210d613d4577ab233c09b6ccf50f1f6eb3389294.jpg)  
【定理8.9】（连通性定理）有向图 $G$ 是强连通图的充要条件是存在一条经过图$G$所有结点的回路；有向图 $G$ 是单连通图的充要条件是存在一条经过图𝐺所有结点的通路。  
类似于无向图的连通分支的概念，可分别根据有向图的强连通、单向连通、弱连通概念定义相应的连通分支，得到强分图、单向分图、弱分图的概念，具体定义如下：  
【定义8.31】假设$G=\langle V,E\rangle$任意给定的一个有向图，设 $G^{\prime}$是 $G$ 的一个子图，如果$G^{\prime}$是强连通的（单向连通的、弱连通的），并且对 $\forall G^{\prime\prime}\subseteq G$，若$G^{\prime}\subset G^{\prime\prime}$，则 $G^{\prime\prime}$不是强连通的（单向连通的、弱连通的），则称 $G^{\prime}$ 为 $G$ 的强连通分支（单向连通分支、弱连通分支），简称为强分图（单分图、弱分图）。  
显然，强分图、单分图、弱分图都是 $G$ 的子图，可以用结点集合𝑉的子集导出。显然，强分图是单分图和弱分图，单分图一定是弱分图，但是为了强调它们之间的差异性，一般不再将强分图称为单分图或弱分图，也不再将单分图称为弱分图。  
从上述定义及例题不难看出，可分别通过强分图、单分图、弱分图的概念对有向图中所有结点进行分组。具体地说：  
（1）对于由强连通关系产生的强分图，由于有向图结点之间的强连通关系显然满足自反性、对称性和传递性，因此这种强连通关系是一种等价关系，从而可由此等价关系实现对图中所有结点的划分。显然，每个强分图其实就是一个等价类或者划分块，图中所有的强分图就是构成了所有的划分块。 因此，有向图的任何一个结点属于且仅属于一个强分图。  
（2）对于由弱连通关系产生的弱分图，可类似于无向图的方法进行讨论。事实上，不难看出，弱分图其实就是有向图所导出无向图中的连通分支。因此，所有的弱分图也构成了有向图中所有结点的一种划分，有向图的任何一个结点属于且仅属于一个若分图。  
（3）对于由单向连通关系产生的单分图，不难证明，有向图结点之间的单连通关系满足自反性、对称性，但不满足传递性，因而是一种相容关系。可由此相容关系实现对图中所有结点的最大覆盖。显然，每个强分图其实就是一个最大相容类，图中所有的单分图就是构成了所有的最大相容类。因此，有向图的任何一个结点至少属于一个强分图。  
类似地，可分别通过强分图、单分图、弱分图的概念对有向图中所有边进行分组。 不难发现：对于任何一个给定的有向图，它的每条边至多属于一个其强分图，至少属于一个其单分图，属于且仅属于一个其弱分图。  
例如，对于例题8.30 中的强分图、单分图和弱分图，不难看出它们均满足上述所有关于结点和边分组性质。",强分图是弱分图的一种
图的遍历,包含,深度优先搜索,,"图的遍历是指从图中的任一结点出发，按照一定的搜索方式对图中的所有结点进行访问，每个结点访问一次且仅一次。图的遍历是关于图的一种最基本的操作，图的许多其他操作都是建立在图的遍历基础之上。一般来讲，根据搜索路径的不同，图的遍历算法有两种基本类型，即深度优先搜索遍历和广度优先搜索遍历。  
深度优先搜索是按照深度方向进行搜索，对于一个给定的连通图$G=\langle V,E\rangle$，首先确定一个遍历的出发点$v_{i}$ ,将其标记为已访问之后，再次选择与点$v_{i}$相邻并且尚未访问过的结点$v_{j}$作为新的遍历；同样地，标记$v_{j}$为已访问之后，再次选择与点$v_{j}$相邻并且尚未访问过的新结点$v_{k}$作为遍历点，以此类推，直到图中所有的结点全部被访问，搜索过程完成为止。  
如果在遍历过程中，遇到了与当前遍历点相邻但已访问的结点，则直接跳过该点，再次选择匹配与当前遍历点相邻的其他点，直到找到未被访问的点进行下一次的深度遍历为止，在此过程中，如果已搜索完与当前遍历点所有的邻接点都没有找到未被访问的结点，则此层遍历结束，算法返回上一层遍历点继续深度搜索，以此类推，直到搜索过程完成为止。这个过程称为连通图的深度优先搜索，简称为 DFS。  
上述算法讲述了对于连通图$G=(V,E)$的深度优先遍历过程，下面对其进行整理并拓广为非连通图的情况下的算法整理如下：  
（1）首先确定一个出发点$v_{i}$，访问并将其标记为已访问。  
（2）找出与结点$v_{i}$相邻且未被访问的邻接点$v_{j}$，访问并标记其为已访问，再以$v_{j}$作为当前遍历点继续访问与$v_{j}$相邻切未被访问的邻接点。递归重复本过程，直到当前遍历点的所有邻接点都被访问为止。  
（3）返回上一层访问过的遍历点，若此遍历点仍没有尚未被访问的邻接点，则继续返回上一层直到找到尚有未被访问的邻接点的遍历点，继续执行步骤（2），否则执行步骤（4）  
（4）若此时图中还有顶点未被访问，则继续选择图中一个未被访问的顶点作为起始点，重复上述描述过程，直至图中所有顶点均被访问过为止。  
在对图进行深度优先遍历时，按照结点的先后的被访问次序所组成的序列，称为深度优先搜索序列，简称𝑫𝑭𝑺序列。对于一个连通图，由深度优先搜索算法进行遍历得到的结点次序（𝐷𝐹𝑆序列），以及相应结点之间的边所构成的图称为深度优先生成树。对于一个非连通图，由深度优先搜索算法进行遍历得到的结点次序（𝐷𝐹𝑆序列），以及相应结点之间的边所构成的图称为深度优先生成森林。",图的遍历包含深度优先搜索作为一种基本类型
深度优先搜索,生成,深度优先搜索序列,,"图的遍历是指从图中的任一结点出发，按照一定的搜索方式对图中的所有结点进行访问，每个结点访问一次且仅一次。图的遍历是关于图的一种最基本的操作，图的许多其他操作都是建立在图的遍历基础之上。一般来讲，根据搜索路径的不同，图的遍历算法有两种基本类型，即深度优先搜索遍历和广度优先搜索遍历。  
深度优先搜索是按照深度方向进行搜索，对于一个给定的连通图$G=\langle V,E\rangle$，首先确定一个遍历的出发点$v_{i}$ ,将其标记为已访问之后，再次选择与点$v_{i}$相邻并且尚未访问过的结点$v_{j}$作为新的遍历；同样地，标记$v_{j}$为已访问之后，再次选择与点$v_{j}$相邻并且尚未访问过的新结点$v_{k}$作为遍历点，以此类推，直到图中所有的结点全部被访问，搜索过程完成为止。  
如果在遍历过程中，遇到了与当前遍历点相邻但已访问的结点，则直接跳过该点，再次选择匹配与当前遍历点相邻的其他点，直到找到未被访问的点进行下一次的深度遍历为止，在此过程中，如果已搜索完与当前遍历点所有的邻接点都没有找到未被访问的结点，则此层遍历结束，算法返回上一层遍历点继续深度搜索，以此类推，直到搜索过程完成为止。这个过程称为连通图的深度优先搜索，简称为 DFS。  
上述算法讲述了对于连通图$G=(V,E)$的深度优先遍历过程，下面对其进行整理并拓广为非连通图的情况下的算法整理如下：  
（1）首先确定一个出发点$v_{i}$，访问并将其标记为已访问。  
（2）找出与结点$v_{i}$相邻且未被访问的邻接点$v_{j}$，访问并标记其为已访问，再以$v_{j}$作为当前遍历点继续访问与$v_{j}$相邻切未被访问的邻接点。递归重复本过程，直到当前遍历点的所有邻接点都被访问为止。  
（3）返回上一层访问过的遍历点，若此遍历点仍没有尚未被访问的邻接点，则继续返回上一层直到找到尚有未被访问的邻接点的遍历点，继续执行步骤（2），否则执行步骤（4）  
（4）若此时图中还有顶点未被访问，则继续选择图中一个未被访问的顶点作为起始点，重复上述描述过程，直至图中所有顶点均被访问过为止。  
在对图进行深度优先遍历时，按照结点的先后的被访问次序所组成的序列，称为深度优先搜索序列，简称𝑫𝑭𝑺序列。对于一个连通图，由深度优先搜索算法进行遍历得到的结点次序（𝐷𝐹𝑆序列），以及相应结点之间的边所构成的图称为深度优先生成树。对于一个非连通图，由深度优先搜索算法进行遍历得到的结点次序（𝐷𝐹𝑆序列），以及相应结点之间的边所构成的图称为深度优先生成森林。",深度优先搜索生成深度优先搜索序列
深度优先搜索,生成,深度优先生成树,,"图的遍历是指从图中的任一结点出发，按照一定的搜索方式对图中的所有结点进行访问，每个结点访问一次且仅一次。图的遍历是关于图的一种最基本的操作，图的许多其他操作都是建立在图的遍历基础之上。一般来讲，根据搜索路径的不同，图的遍历算法有两种基本类型，即深度优先搜索遍历和广度优先搜索遍历。  
深度优先搜索是按照深度方向进行搜索，对于一个给定的连通图$G=\langle V,E\rangle$，首先确定一个遍历的出发点$v_{i}$ ,将其标记为已访问之后，再次选择与点$v_{i}$相邻并且尚未访问过的结点$v_{j}$作为新的遍历；同样地，标记$v_{j}$为已访问之后，再次选择与点$v_{j}$相邻并且尚未访问过的新结点$v_{k}$作为遍历点，以此类推，直到图中所有的结点全部被访问，搜索过程完成为止。  
如果在遍历过程中，遇到了与当前遍历点相邻但已访问的结点，则直接跳过该点，再次选择匹配与当前遍历点相邻的其他点，直到找到未被访问的点进行下一次的深度遍历为止，在此过程中，如果已搜索完与当前遍历点所有的邻接点都没有找到未被访问的结点，则此层遍历结束，算法返回上一层遍历点继续深度搜索，以此类推，直到搜索过程完成为止。这个过程称为连通图的深度优先搜索，简称为 DFS。  
上述算法讲述了对于连通图$G=(V,E)$的深度优先遍历过程，下面对其进行整理并拓广为非连通图的情况下的算法整理如下：  
（1）首先确定一个出发点$v_{i}$，访问并将其标记为已访问。  
（2）找出与结点$v_{i}$相邻且未被访问的邻接点$v_{j}$，访问并标记其为已访问，再以$v_{j}$作为当前遍历点继续访问与$v_{j}$相邻切未被访问的邻接点。递归重复本过程，直到当前遍历点的所有邻接点都被访问为止。  
（3）返回上一层访问过的遍历点，若此遍历点仍没有尚未被访问的邻接点，则继续返回上一层直到找到尚有未被访问的邻接点的遍历点，继续执行步骤（2），否则执行步骤（4）  
（4）若此时图中还有顶点未被访问，则继续选择图中一个未被访问的顶点作为起始点，重复上述描述过程，直至图中所有顶点均被访问过为止。  
在对图进行深度优先遍历时，按照结点的先后的被访问次序所组成的序列，称为深度优先搜索序列，简称𝑫𝑭𝑺序列。对于一个连通图，由深度优先搜索算法进行遍历得到的结点次序（𝐷𝐹𝑆序列），以及相应结点之间的边所构成的图称为深度优先生成树。对于一个非连通图，由深度优先搜索算法进行遍历得到的结点次序（𝐷𝐹𝑆序列），以及相应结点之间的边所构成的图称为深度优先生成森林。",深度优先搜索在连通图中生成深度优先生成树
深度优先搜索,生成,深度优先生成森林,,"图的遍历是指从图中的任一结点出发，按照一定的搜索方式对图中的所有结点进行访问，每个结点访问一次且仅一次。图的遍历是关于图的一种最基本的操作，图的许多其他操作都是建立在图的遍历基础之上。一般来讲，根据搜索路径的不同，图的遍历算法有两种基本类型，即深度优先搜索遍历和广度优先搜索遍历。  
深度优先搜索是按照深度方向进行搜索，对于一个给定的连通图$G=\langle V,E\rangle$，首先确定一个遍历的出发点$v_{i}$ ,将其标记为已访问之后，再次选择与点$v_{i}$相邻并且尚未访问过的结点$v_{j}$作为新的遍历；同样地，标记$v_{j}$为已访问之后，再次选择与点$v_{j}$相邻并且尚未访问过的新结点$v_{k}$作为遍历点，以此类推，直到图中所有的结点全部被访问，搜索过程完成为止。  
如果在遍历过程中，遇到了与当前遍历点相邻但已访问的结点，则直接跳过该点，再次选择匹配与当前遍历点相邻的其他点，直到找到未被访问的点进行下一次的深度遍历为止，在此过程中，如果已搜索完与当前遍历点所有的邻接点都没有找到未被访问的结点，则此层遍历结束，算法返回上一层遍历点继续深度搜索，以此类推，直到搜索过程完成为止。这个过程称为连通图的深度优先搜索，简称为 DFS。  
上述算法讲述了对于连通图$G=(V,E)$的深度优先遍历过程，下面对其进行整理并拓广为非连通图的情况下的算法整理如下：  
（1）首先确定一个出发点$v_{i}$，访问并将其标记为已访问。  
（2）找出与结点$v_{i}$相邻且未被访问的邻接点$v_{j}$，访问并标记其为已访问，再以$v_{j}$作为当前遍历点继续访问与$v_{j}$相邻切未被访问的邻接点。递归重复本过程，直到当前遍历点的所有邻接点都被访问为止。  
（3）返回上一层访问过的遍历点，若此遍历点仍没有尚未被访问的邻接点，则继续返回上一层直到找到尚有未被访问的邻接点的遍历点，继续执行步骤（2），否则执行步骤（4）  
（4）若此时图中还有顶点未被访问，则继续选择图中一个未被访问的顶点作为起始点，重复上述描述过程，直至图中所有顶点均被访问过为止。  
在对图进行深度优先遍历时，按照结点的先后的被访问次序所组成的序列，称为深度优先搜索序列，简称𝑫𝑭𝑺序列。对于一个连通图，由深度优先搜索算法进行遍历得到的结点次序（𝐷𝐹𝑆序列），以及相应结点之间的边所构成的图称为深度优先生成树。对于一个非连通图，由深度优先搜索算法进行遍历得到的结点次序（𝐷𝐹𝑆序列），以及相应结点之间的边所构成的图称为深度优先生成森林。",深度优先搜索在非连通图中生成深度优先生成森林
广度优先搜索,不同,深度优先搜索,,"广度优先搜索不同于深度优先搜索一层层地在每个遍历点处向下递归搜索的纵向搜索，而是以一种广度的思维进行横向搜索。对于一个给定的连通图$G=(V,E)$，同样地，需要先确定一个出发点，访问并将其标记为已访问之后，依次遍历其所有未被访问的邻接点 $v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$，访问之后同样进行标记，然后分别从结点$v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$开始依次遍历每个点的未被访问的点，依次类推，直到图中所有顶点都被访问为止。这个过程称为广度优先搜索，简称𝑩𝑭𝑺。  
同样地，对广度优先搜索算法进行整理并拓广为非连通图的情况下的算法如下：  
（1）首先确定一个出发点$v_{i}$，访问并将其标记为已访问。  
（2）依次访问$v_{i}$ 的每个尚未访问的邻接点$v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$  
（3）分别将这些邻接点$v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$作为遍历点，依次访问每个遍历点的尚未访问的邻接点并标记为已访问，同时要记录每个邻接点被访问的顺序，在访问完所有邻接点之后应该按照这个顺序，将这些邻接点$v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$分别作为当前遍历点进行广度优先搜索），依次类推，直到所有结点都被访问完为止。  
（4）若此时还有顶点未被访问，则继续选一个未被访问的顶点作为起始点，重复上述过程，直至所有顶点均被访问过为止  
在对图进行广度优先遍历时，按照结点的先后的被访问次序所组成的序列，称为广度优先搜索序列，简称𝑩𝑭𝑺序列。对于一个连通图，由广度优先搜索算法进行遍历得到的结点次序（𝐵𝐹𝑆序列），以及相应结点之间的边所构成的图称为广度优先生成树。对于一个非连通图，由广度优先搜索算法进行遍历得到的结点次序（𝐵𝐹𝑆序列），以及相应结点之间的边所构成的图称为广度优先生成森林。",广度优先搜索与深度优先搜索不同，前者进行横向搜索，后者进行纵向搜索
广度优先搜索,应用于,连通图,,"广度优先搜索不同于深度优先搜索一层层地在每个遍历点处向下递归搜索的纵向搜索，而是以一种广度的思维进行横向搜索。对于一个给定的连通图$G=(V,E)$，同样地，需要先确定一个出发点，访问并将其标记为已访问之后，依次遍历其所有未被访问的邻接点 $v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$，访问之后同样进行标记，然后分别从结点$v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$开始依次遍历每个点的未被访问的点，依次类推，直到图中所有顶点都被访问为止。这个过程称为广度优先搜索，简称𝑩𝑭𝑺。  
同样地，对广度优先搜索算法进行整理并拓广为非连通图的情况下的算法如下：  
（1）首先确定一个出发点$v_{i}$，访问并将其标记为已访问。  
（2）依次访问$v_{i}$ 的每个尚未访问的邻接点$v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$  
（3）分别将这些邻接点$v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$作为遍历点，依次访问每个遍历点的尚未访问的邻接点并标记为已访问，同时要记录每个邻接点被访问的顺序，在访问完所有邻接点之后应该按照这个顺序，将这些邻接点$v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$分别作为当前遍历点进行广度优先搜索），依次类推，直到所有结点都被访问完为止。  
（4）若此时还有顶点未被访问，则继续选一个未被访问的顶点作为起始点，重复上述过程，直至所有顶点均被访问过为止  
在对图进行广度优先遍历时，按照结点的先后的被访问次序所组成的序列，称为广度优先搜索序列，简称𝑩𝑭𝑺序列。对于一个连通图，由广度优先搜索算法进行遍历得到的结点次序（𝐵𝐹𝑆序列），以及相应结点之间的边所构成的图称为广度优先生成树。对于一个非连通图，由广度优先搜索算法进行遍历得到的结点次序（𝐵𝐹𝑆序列），以及相应结点之间的边所构成的图称为广度优先生成森林。",广度优先搜索应用于连通图的遍历
广度优先搜索,拓广应用于,非连通图,,"广度优先搜索不同于深度优先搜索一层层地在每个遍历点处向下递归搜索的纵向搜索，而是以一种广度的思维进行横向搜索。对于一个给定的连通图$G=(V,E)$，同样地，需要先确定一个出发点，访问并将其标记为已访问之后，依次遍历其所有未被访问的邻接点 $v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$，访问之后同样进行标记，然后分别从结点$v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$开始依次遍历每个点的未被访问的点，依次类推，直到图中所有顶点都被访问为止。这个过程称为广度优先搜索，简称𝑩𝑭𝑺。  
同样地，对广度优先搜索算法进行整理并拓广为非连通图的情况下的算法如下：  
（1）首先确定一个出发点$v_{i}$，访问并将其标记为已访问。  
（2）依次访问$v_{i}$ 的每个尚未访问的邻接点$v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$  
（3）分别将这些邻接点$v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$作为遍历点，依次访问每个遍历点的尚未访问的邻接点并标记为已访问，同时要记录每个邻接点被访问的顺序，在访问完所有邻接点之后应该按照这个顺序，将这些邻接点$v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$分别作为当前遍历点进行广度优先搜索），依次类推，直到所有结点都被访问完为止。  
（4）若此时还有顶点未被访问，则继续选一个未被访问的顶点作为起始点，重复上述过程，直至所有顶点均被访问过为止  
在对图进行广度优先遍历时，按照结点的先后的被访问次序所组成的序列，称为广度优先搜索序列，简称𝑩𝑭𝑺序列。对于一个连通图，由广度优先搜索算法进行遍历得到的结点次序（𝐵𝐹𝑆序列），以及相应结点之间的边所构成的图称为广度优先生成树。对于一个非连通图，由广度优先搜索算法进行遍历得到的结点次序（𝐵𝐹𝑆序列），以及相应结点之间的边所构成的图称为广度优先生成森林。",广度优先搜索算法可以拓广应用于非连通图的遍历
广度优先搜索,生成,广度优先搜索序列,,"广度优先搜索不同于深度优先搜索一层层地在每个遍历点处向下递归搜索的纵向搜索，而是以一种广度的思维进行横向搜索。对于一个给定的连通图$G=(V,E)$，同样地，需要先确定一个出发点，访问并将其标记为已访问之后，依次遍历其所有未被访问的邻接点 $v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$，访问之后同样进行标记，然后分别从结点$v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$开始依次遍历每个点的未被访问的点，依次类推，直到图中所有顶点都被访问为止。这个过程称为广度优先搜索，简称𝑩𝑭𝑺。  
同样地，对广度优先搜索算法进行整理并拓广为非连通图的情况下的算法如下：  
（1）首先确定一个出发点$v_{i}$，访问并将其标记为已访问。  
（2）依次访问$v_{i}$ 的每个尚未访问的邻接点$v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$  
（3）分别将这些邻接点$v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$作为遍历点，依次访问每个遍历点的尚未访问的邻接点并标记为已访问，同时要记录每个邻接点被访问的顺序，在访问完所有邻接点之后应该按照这个顺序，将这些邻接点$v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$分别作为当前遍历点进行广度优先搜索），依次类推，直到所有结点都被访问完为止。  
（4）若此时还有顶点未被访问，则继续选一个未被访问的顶点作为起始点，重复上述过程，直至所有顶点均被访问过为止  
在对图进行广度优先遍历时，按照结点的先后的被访问次序所组成的序列，称为广度优先搜索序列，简称𝑩𝑭𝑺序列。对于一个连通图，由广度优先搜索算法进行遍历得到的结点次序（𝐵𝐹𝑆序列），以及相应结点之间的边所构成的图称为广度优先生成树。对于一个非连通图，由广度优先搜索算法进行遍历得到的结点次序（𝐵𝐹𝑆序列），以及相应结点之间的边所构成的图称为广度优先生成森林。",广度优先搜索生成广度优先搜索序列
广度优先搜索,生成,广度优先生成树,,"广度优先搜索不同于深度优先搜索一层层地在每个遍历点处向下递归搜索的纵向搜索，而是以一种广度的思维进行横向搜索。对于一个给定的连通图$G=(V,E)$，同样地，需要先确定一个出发点，访问并将其标记为已访问之后，依次遍历其所有未被访问的邻接点 $v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$，访问之后同样进行标记，然后分别从结点$v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$开始依次遍历每个点的未被访问的点，依次类推，直到图中所有顶点都被访问为止。这个过程称为广度优先搜索，简称𝑩𝑭𝑺。  
同样地，对广度优先搜索算法进行整理并拓广为非连通图的情况下的算法如下：  
（1）首先确定一个出发点$v_{i}$，访问并将其标记为已访问。  
（2）依次访问$v_{i}$ 的每个尚未访问的邻接点$v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$  
（3）分别将这些邻接点$v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$作为遍历点，依次访问每个遍历点的尚未访问的邻接点并标记为已访问，同时要记录每个邻接点被访问的顺序，在访问完所有邻接点之后应该按照这个顺序，将这些邻接点$v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$分别作为当前遍历点进行广度优先搜索），依次类推，直到所有结点都被访问完为止。  
（4）若此时还有顶点未被访问，则继续选一个未被访问的顶点作为起始点，重复上述过程，直至所有顶点均被访问过为止  
在对图进行广度优先遍历时，按照结点的先后的被访问次序所组成的序列，称为广度优先搜索序列，简称𝑩𝑭𝑺序列。对于一个连通图，由广度优先搜索算法进行遍历得到的结点次序（𝐵𝐹𝑆序列），以及相应结点之间的边所构成的图称为广度优先生成树。对于一个非连通图，由广度优先搜索算法进行遍历得到的结点次序（𝐵𝐹𝑆序列），以及相应结点之间的边所构成的图称为广度优先生成森林。",对于连通图，广度优先搜索生成广度优先生成树
广度优先搜索,生成,广度优先生成森林,,"广度优先搜索不同于深度优先搜索一层层地在每个遍历点处向下递归搜索的纵向搜索，而是以一种广度的思维进行横向搜索。对于一个给定的连通图$G=(V,E)$，同样地，需要先确定一个出发点，访问并将其标记为已访问之后，依次遍历其所有未被访问的邻接点 $v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$，访问之后同样进行标记，然后分别从结点$v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$开始依次遍历每个点的未被访问的点，依次类推，直到图中所有顶点都被访问为止。这个过程称为广度优先搜索，简称𝑩𝑭𝑺。  
同样地，对广度优先搜索算法进行整理并拓广为非连通图的情况下的算法如下：  
（1）首先确定一个出发点$v_{i}$，访问并将其标记为已访问。  
（2）依次访问$v_{i}$ 的每个尚未访问的邻接点$v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$  
（3）分别将这些邻接点$v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$作为遍历点，依次访问每个遍历点的尚未访问的邻接点并标记为已访问，同时要记录每个邻接点被访问的顺序，在访问完所有邻接点之后应该按照这个顺序，将这些邻接点$v_{i},v_{i+1},v_{i+2}\ldots v_{i+k}$分别作为当前遍历点进行广度优先搜索），依次类推，直到所有结点都被访问完为止。  
（4）若此时还有顶点未被访问，则继续选一个未被访问的顶点作为起始点，重复上述过程，直至所有顶点均被访问过为止  
在对图进行广度优先遍历时，按照结点的先后的被访问次序所组成的序列，称为广度优先搜索序列，简称𝑩𝑭𝑺序列。对于一个连通图，由广度优先搜索算法进行遍历得到的结点次序（𝐵𝐹𝑆序列），以及相应结点之间的边所构成的图称为广度优先生成树。对于一个非连通图，由广度优先搜索算法进行遍历得到的结点次序（𝐵𝐹𝑆序列），以及相应结点之间的边所构成的图称为广度优先生成森林。",对于非连通图，广度优先搜索生成广度优先生成森林
最短路径,求解方法,单源最短路径算法,,"最短路径，顾名思义就是图中一个结点到另一个结点的之间最短的距离。在日常生活之中，涉及到最短路径计算问题的实际案例有很多，比如在地图上查找两地之间最短路径，为大家的出行提供方便；另外，在路由选择中，从一个路由器出发查找距离目的地最近的一条路径等。最短路径的求解主要有两种算法，一种是单源最短路径算法，即一个结点到其他所有剩余结点的最短路径，代表算法是迪杰斯特拉算法；另一种是求整个图中所有结点之间的最短距离，代表算法是沃舍尔∙弗洛伊德算法。  
因此，给定简单无向赋权图 $G=\langle V,E\rangle$ ，从顶点 $v_{1}$ 到 $v_{n}$ 的最短路径可应用迪杰斯特拉算法算法进行求解。迪杰斯特拉算法的基本思想如下：  
假定有两个集合 $A$ 和 $B$ ，$A$ 集合中存放已找到最短路径的结点$B$集合中存放的是剩余结点。初始状态下，集合 $A$ 中包含默认的源点 $v_{1}$ ，然后从集合 $B$ 中选取到结点$v_{1}$最近的那个结点，记为 $v_{2}$，将 $v_{2}$ 放入集合 $A$ 中，并对$ v_{2}$到$v_{1}$的距离进行永久性标注，然后再以 $v_{2}$ 为中介点，更新 $v_{1}$ 到其他剩余结点的最短路径临时值。然后再从集合B中选取最近的结点，并入集合 $A$ 中，并对该结点到$v_{1}$的最短路径临时值进行永久性标注，使得该临时值变成永久值，重复以上过程，直到将集合B中的所有结点全部并入集合 $A$ 中并得到永久性标注。  
迪杰斯特拉算法的数学描述如下：  
（1）初始化：$A=\{v_1\},d(v_1)=0,B=\{v_i|v_i\in V,i\neq1\}$,即 $B=V-A$,且有
$$d(v_i)=\begin{cases}\omega(v_1,v_i),~~~~~~~若(v_1,v_i)\in E\\\infty,~~~~~~~~~~~~~~~~~若(v_1,v_i)\notin E\end{cases}$$              (8-13)  
（2）找最近：在 $B$ 集合中寻找离顶点 $v_{1}$ 最近的结点。若为 $v_{k}$ ，则将 $v_{k}$ 添加到集合 $A$ 中，并在 $B$ 集合中删除 $v_{k}$ ，即 $A=A\cup\{v_{k}\}$，$B=B-\{v_{k}\}$  
（3）更新：以 $v_{k}$ 为中介点，更新 $v_{1}$ 到 $B$ 集合中剩余结点的最短路径长度。$\forall$$v_{i}\in$$B$，  
$d(v_{i})={\left\{\begin{array}{l l}{d(v_{k})+\omega(v_{k},v_{i}),~~~~~~~~~~~~~~若\dot{}d(v_{k})+\omega(v_{k},v_{i})<d(v_{i})}\\ {\qquad d(v_{i}),~~~~~~~~~~~~~~~~~~~~~~~否则}\end{array}\right.}$      （8 −14）  
（4）重复（2）和（3），直到 $B$ 集合为空为止。  
实际上，当 $v_{n}$ 归入集合 $A$ ，且正好 $A=V$，不仅求出了从 $v_{1}$ 到 $v_{n}$ 的最短路径，而且求出了从 $v_{1}$ 到所有顶点的最短路径。  
上述算法的正确性是显然的。因为每一步中，集合 $A$中的每一个元素（顶点）都是 $v_{1}$ 到该元素（顶点）的最短路径，因此只要证明上述 $d(v_{i})$ 是从 $v_{1}$ 到 $v_{i}$ 的最短路径即可。  
事实上，任何一条从 $v_{1}$ 到 $v_{i}$ 的路径，若通过集合 $B$ 中的第一个顶点是 $v_{p}$，且 $v_{p}\neq$$v_{i}$ ，显然这种路径的长度不会比 $d(v_{i})$小（因为所有边的权值为非负）。",单源最短路径算法是求解最短路径的一种方法
最短路径,代表算法,迪杰斯特拉算法,,"最短路径，顾名思义就是图中一个结点到另一个结点的之间最短的距离。在日常生活之中，涉及到最短路径计算问题的实际案例有很多，比如在地图上查找两地之间最短路径，为大家的出行提供方便；另外，在路由选择中，从一个路由器出发查找距离目的地最近的一条路径等。最短路径的求解主要有两种算法，一种是单源最短路径算法，即一个结点到其他所有剩余结点的最短路径，代表算法是迪杰斯特拉算法；另一种是求整个图中所有结点之间的最短距离，代表算法是沃舍尔∙弗洛伊德算法。  
因此，给定简单无向赋权图 $G=\langle V,E\rangle$ ，从顶点 $v_{1}$ 到 $v_{n}$ 的最短路径可应用迪杰斯特拉算法算法进行求解。迪杰斯特拉算法的基本思想如下：  
假定有两个集合 $A$ 和 $B$ ，$A$ 集合中存放已找到最短路径的结点$B$集合中存放的是剩余结点。初始状态下，集合 $A$ 中包含默认的源点 $v_{1}$ ，然后从集合 $B$ 中选取到结点$v_{1}$最近的那个结点，记为 $v_{2}$，将 $v_{2}$ 放入集合 $A$ 中，并对$ v_{2}$到$v_{1}$的距离进行永久性标注，然后再以 $v_{2}$ 为中介点，更新 $v_{1}$ 到其他剩余结点的最短路径临时值。然后再从集合B中选取最近的结点，并入集合 $A$ 中，并对该结点到$v_{1}$的最短路径临时值进行永久性标注，使得该临时值变成永久值，重复以上过程，直到将集合B中的所有结点全部并入集合 $A$ 中并得到永久性标注。  
迪杰斯特拉算法的数学描述如下：  
（1）初始化：$A=\{v_1\},d(v_1)=0,B=\{v_i|v_i\in V,i\neq1\}$,即 $B=V-A$,且有
$$d(v_i)=\begin{cases}\omega(v_1,v_i),~~~~~~~若(v_1,v_i)\in E\\\infty,~~~~~~~~~~~~~~~~~若(v_1,v_i)\notin E\end{cases}$$              (8-13)  
（2）找最近：在 $B$ 集合中寻找离顶点 $v_{1}$ 最近的结点。若为 $v_{k}$ ，则将 $v_{k}$ 添加到集合 $A$ 中，并在 $B$ 集合中删除 $v_{k}$ ，即 $A=A\cup\{v_{k}\}$，$B=B-\{v_{k}\}$  
（3）更新：以 $v_{k}$ 为中介点，更新 $v_{1}$ 到 $B$ 集合中剩余结点的最短路径长度。$\forall$$v_{i}\in$$B$，  
$d(v_{i})={\left\{\begin{array}{l l}{d(v_{k})+\omega(v_{k},v_{i}),~~~~~~~~~~~~~~若\dot{}d(v_{k})+\omega(v_{k},v_{i})<d(v_{i})}\\ {\qquad d(v_{i}),~~~~~~~~~~~~~~~~~~~~~~~否则}\end{array}\right.}$      （8 −14）  
（4）重复（2）和（3），直到 $B$ 集合为空为止。  
实际上，当 $v_{n}$ 归入集合 $A$ ，且正好 $A=V$，不仅求出了从 $v_{1}$ 到 $v_{n}$ 的最短路径，而且求出了从 $v_{1}$ 到所有顶点的最短路径。  
上述算法的正确性是显然的。因为每一步中，集合 $A$中的每一个元素（顶点）都是 $v_{1}$ 到该元素（顶点）的最短路径，因此只要证明上述 $d(v_{i})$ 是从 $v_{1}$ 到 $v_{i}$ 的最短路径即可。  
事实上，任何一条从 $v_{1}$ 到 $v_{i}$ 的路径，若通过集合 $B$ 中的第一个顶点是 $v_{p}$，且 $v_{p}\neq$$v_{i}$ ，显然这种路径的长度不会比 $d(v_{i})$小（因为所有边的权值为非负）。",迪杰斯特拉算法是单源最短路径算法的代表算法
最短路径,代表算法,沃舍尔弗洛伊德算法,,"最短路径，顾名思义就是图中一个结点到另一个结点的之间最短的距离。在日常生活之中，涉及到最短路径计算问题的实际案例有很多，比如在地图上查找两地之间最短路径，为大家的出行提供方便；另外，在路由选择中，从一个路由器出发查找距离目的地最近的一条路径等。最短路径的求解主要有两种算法，一种是单源最短路径算法，即一个结点到其他所有剩余结点的最短路径，代表算法是迪杰斯特拉算法；另一种是求整个图中所有结点之间的最短距离，代表算法是沃舍尔∙弗洛伊德算法。  
因此，给定简单无向赋权图 $G=\langle V,E\rangle$ ，从顶点 $v_{1}$ 到 $v_{n}$ 的最短路径可应用迪杰斯特拉算法算法进行求解。迪杰斯特拉算法的基本思想如下：  
假定有两个集合 $A$ 和 $B$ ，$A$ 集合中存放已找到最短路径的结点$B$集合中存放的是剩余结点。初始状态下，集合 $A$ 中包含默认的源点 $v_{1}$ ，然后从集合 $B$ 中选取到结点$v_{1}$最近的那个结点，记为 $v_{2}$，将 $v_{2}$ 放入集合 $A$ 中，并对$ v_{2}$到$v_{1}$的距离进行永久性标注，然后再以 $v_{2}$ 为中介点，更新 $v_{1}$ 到其他剩余结点的最短路径临时值。然后再从集合B中选取最近的结点，并入集合 $A$ 中，并对该结点到$v_{1}$的最短路径临时值进行永久性标注，使得该临时值变成永久值，重复以上过程，直到将集合B中的所有结点全部并入集合 $A$ 中并得到永久性标注。  
迪杰斯特拉算法的数学描述如下：  
（1）初始化：$A=\{v_1\},d(v_1)=0,B=\{v_i|v_i\in V,i\neq1\}$,即 $B=V-A$,且有
$$d(v_i)=\begin{cases}\omega(v_1,v_i),~~~~~~~若(v_1,v_i)\in E\\\infty,~~~~~~~~~~~~~~~~~若(v_1,v_i)\notin E\end{cases}$$              (8-13)  
（2）找最近：在 $B$ 集合中寻找离顶点 $v_{1}$ 最近的结点。若为 $v_{k}$ ，则将 $v_{k}$ 添加到集合 $A$ 中，并在 $B$ 集合中删除 $v_{k}$ ，即 $A=A\cup\{v_{k}\}$，$B=B-\{v_{k}\}$  
（3）更新：以 $v_{k}$ 为中介点，更新 $v_{1}$ 到 $B$ 集合中剩余结点的最短路径长度。$\forall$$v_{i}\in$$B$，  
$d(v_{i})={\left\{\begin{array}{l l}{d(v_{k})+\omega(v_{k},v_{i}),~~~~~~~~~~~~~~若\dot{}d(v_{k})+\omega(v_{k},v_{i})<d(v_{i})}\\ {\qquad d(v_{i}),~~~~~~~~~~~~~~~~~~~~~~~否则}\end{array}\right.}$      （8 −14）  
（4）重复（2）和（3），直到 $B$ 集合为空为止。  
实际上，当 $v_{n}$ 归入集合 $A$ ，且正好 $A=V$，不仅求出了从 $v_{1}$ 到 $v_{n}$ 的最短路径，而且求出了从 $v_{1}$ 到所有顶点的最短路径。  
上述算法的正确性是显然的。因为每一步中，集合 $A$中的每一个元素（顶点）都是 $v_{1}$ 到该元素（顶点）的最短路径，因此只要证明上述 $d(v_{i})$ 是从 $v_{1}$ 到 $v_{i}$ 的最短路径即可。  
事实上，任何一条从 $v_{1}$ 到 $v_{i}$ 的路径，若通过集合 $B$ 中的第一个顶点是 $v_{p}$，且 $v_{p}\neq$$v_{i}$ ，显然这种路径的长度不会比 $d(v_{i})$小（因为所有边的权值为非负）。",沃舍尔弗洛伊德算法是求解图中所有结点之间最短距离的代表算法
单源最短路径算法,具体实现,迪杰斯特拉算法,,"最短路径，顾名思义就是图中一个结点到另一个结点的之间最短的距离。在日常生活之中，涉及到最短路径计算问题的实际案例有很多，比如在地图上查找两地之间最短路径，为大家的出行提供方便；另外，在路由选择中，从一个路由器出发查找距离目的地最近的一条路径等。最短路径的求解主要有两种算法，一种是单源最短路径算法，即一个结点到其他所有剩余结点的最短路径，代表算法是迪杰斯特拉算法；另一种是求整个图中所有结点之间的最短距离，代表算法是沃舍尔∙弗洛伊德算法。  
因此，给定简单无向赋权图 $G=\langle V,E\rangle$ ，从顶点 $v_{1}$ 到 $v_{n}$ 的最短路径可应用迪杰斯特拉算法算法进行求解。迪杰斯特拉算法的基本思想如下：  
假定有两个集合 $A$ 和 $B$ ，$A$ 集合中存放已找到最短路径的结点$B$集合中存放的是剩余结点。初始状态下，集合 $A$ 中包含默认的源点 $v_{1}$ ，然后从集合 $B$ 中选取到结点$v_{1}$最近的那个结点，记为 $v_{2}$，将 $v_{2}$ 放入集合 $A$ 中，并对$ v_{2}$到$v_{1}$的距离进行永久性标注，然后再以 $v_{2}$ 为中介点，更新 $v_{1}$ 到其他剩余结点的最短路径临时值。然后再从集合B中选取最近的结点，并入集合 $A$ 中，并对该结点到$v_{1}$的最短路径临时值进行永久性标注，使得该临时值变成永久值，重复以上过程，直到将集合B中的所有结点全部并入集合 $A$ 中并得到永久性标注。  
迪杰斯特拉算法的数学描述如下：  
（1）初始化：$A=\{v_1\},d(v_1)=0,B=\{v_i|v_i\in V,i\neq1\}$,即 $B=V-A$,且有
$$d(v_i)=\begin{cases}\omega(v_1,v_i),~~~~~~~若(v_1,v_i)\in E\\\infty,~~~~~~~~~~~~~~~~~若(v_1,v_i)\notin E\end{cases}$$              (8-13)  
（2）找最近：在 $B$ 集合中寻找离顶点 $v_{1}$ 最近的结点。若为 $v_{k}$ ，则将 $v_{k}$ 添加到集合 $A$ 中，并在 $B$ 集合中删除 $v_{k}$ ，即 $A=A\cup\{v_{k}\}$，$B=B-\{v_{k}\}$  
（3）更新：以 $v_{k}$ 为中介点，更新 $v_{1}$ 到 $B$ 集合中剩余结点的最短路径长度。$\forall$$v_{i}\in$$B$，  
$d(v_{i})={\left\{\begin{array}{l l}{d(v_{k})+\omega(v_{k},v_{i}),~~~~~~~~~~~~~~若\dot{}d(v_{k})+\omega(v_{k},v_{i})<d(v_{i})}\\ {\qquad d(v_{i}),~~~~~~~~~~~~~~~~~~~~~~~否则}\end{array}\right.}$      （8 −14）  
（4）重复（2）和（3），直到 $B$ 集合为空为止。  
实际上，当 $v_{n}$ 归入集合 $A$ ，且正好 $A=V$，不仅求出了从 $v_{1}$ 到 $v_{n}$ 的最短路径，而且求出了从 $v_{1}$ 到所有顶点的最短路径。  
上述算法的正确性是显然的。因为每一步中，集合 $A$中的每一个元素（顶点）都是 $v_{1}$ 到该元素（顶点）的最短路径，因此只要证明上述 $d(v_{i})$ 是从 $v_{1}$ 到 $v_{i}$ 的最短路径即可。  
事实上，任何一条从 $v_{1}$ 到 $v_{i}$ 的路径，若通过集合 $B$ 中的第一个顶点是 $v_{p}$，且 $v_{p}\neq$$v_{i}$ ，显然这种路径的长度不会比 $d(v_{i})$小（因为所有边的权值为非负）。",迪杰斯特拉算法是单源最短路径算法的具体实现
沃舍尔∙弗洛伊德算法,求解,多源最短路径,,"迪杰斯特拉算法解决的是单源最短路径问题，只能求出单独某个源点到其它结点最短路径，然而沃舍尔∙弗洛伊德算法则是求得这个图中任意对结点之间的最短路径长度。  
沃舍尔∙弗洛伊德算法的基本思想是通过逐次增加中介结点的途径，不断优化和更新图中每对结点之间的路径长度。首先，将$v_{1}$作为中介结点，据此更新图中仅以$v_{1}$作为中介结点的路径长度以及相应的路径记录。然后在$v_{1}$的基础上，进一步引入${{v}}_{2}$作为新增的中介结点，并更新图中仅以$v_{1}v_{2}$作为中介结点的路径长度和路径记录。依次类推，在$v_{1}v_{2}v_{3}\ldots v_{k}$作为中介结点的基础上，以$v_{k}$作为新增中介结点计算并更新图中以$v_{1}v_{2}v_{3}\ldots v_{k}$为中介结点的每对结点之间路径长度和路径记录。这样当$k=n$(𝑛为结点个数)时，便可求出图中每对结点的最短路径长度及其相应的路径记录。  
从上面描述的基本思想可以知道，在整个问题解决中有两个点非常重要，一个是路径长度，一个是路径记录，为了方便叙述，我们分别定义相应的矩阵用于记录数据，$D^{(k)}(v_{i},v_{j})$表示在考虑了$v_{1}v_{2}v_{3}\ldots v_{k}$作为中介结点的基础上，结点$v_{i}$与$v_{j}$的当前最短路径长度。$R^{(k)}(v_{i},v_{j})$ 是一个包含结点元素的矩阵，表示在考虑了$v_{1}v_{2}v_{3}\ldots v_{k}$作为中介结点的基础上，结点$v_{i}$与$v_{j}$的当前最短路径长度中必经的一个中间点。  
需要注意的是，在还没有考虑中介结点的最初情况时，应该按如下方法初始化$D$和$R$矩阵元素值，对于图中任意两个相邻结点$v_{i}$和$v_{j}$，即存在一条边$(v_{i},v_{j})$，边上权值为$w(v_{i},v_{j})$，那其长度为$D^{(0)}\big(v_{i},v_{j}\big)=w(v_{i},v_{j})$，否则规定$v_{i}$与$v_{j}$存在一条假想边$(v_{i},v_{j})$，令其长度为无穷大。另外，在尚未开始算法迭代时，将$\cdot R$矩阵每行内容分别置为$v_{j}(j=1,2,3\ldots n)$。  
下面以结点$v_{i}$到$v_{j}$为代表，详细介绍具体计算过程：  
首先，将$v_{1}$作为从$v_{i}$到$v_{j}$的中介结点，进行比较路径$\left(v_{i},v_{j}\right)$和$(v_{i},v_{1},v_{j})$长度的大小，若路径$\left(v_{i},v_{j}\right)$的长度不大于$\left(v_{i},v_{1},v_{j}\right)$的长度，那么取$(v_{i},v_{j})$为从$v_{i}$到$v_{j}$的当前最短路径，即$D^{(1)}\big(v_{i},v_{j}\big)=w(v_{i},v_{j})$，此时不需要更新路径记录矩阵$R$；若是路径$\left(v_{i},v_{1},v_{j}\right)$的长度较小，则取$\left(v_{i},v_{1},v_{j}\right)$为从$v_{i}$到$v_{j}$的当前最短路径，即：  
$$
D^{(1)}\big(v_{i},v_{j}\big)=w(v_{i},v_{1})+w\big(v_{1},v_{j}\big)
$$  
并将$v_{1}$暂时作为$v_{i}$到$v_{j}$的中间点，即$R^{(1)}{\bigl(}v_{i},v_{j}{\bigr)}=v_{1}.$。需要注意的是，当前最短路径中介结点序号不大于1，即当前最短路径只可能经由中介点$v_{1}$。  
对$v_{i}$到$v_{j}$的中介结点集合，再引入结点$v_{2}$，即$v_{i}$到$v_{j}$的中介结点为${v}_{1}$和$v_{2}$。首先确定$(v_{i},\ldots,v_{2})$和$(v_{2},\ldots,v_{j})$分别是当前找到的最短路径（只可能经由中介结点$v_{1}$），则$\left(v_{i},\ldots,v_{2},\ldots,v_{j}\right)$有可能是从$v_{i}$到$v_{j}$的最短路径（只可能经由中介结点$v_{1}$和$v_{2}$）。将其与当前从$v_{i}$到$v_{j}$的最短路径$(v_{i},\ldots,v_{j})$进行比较（只可能经由中介结点$v_{1}$），从中选出从${v}_{i}$到$v_{j}$的最短路径（此时只可能经由中介结点$v_{1}$和$v_{2}$），并按照上述的原则更新相应的$D$和$R$。如此下去，直到将图中所有结点加入${v}_{i}$到$v_{j}$的中介结点集合。  
对于一般情形， $(v_{i},\ldots,v_{k})$和$(v_{k},\ldots,v_{j})$分别是从${v}_{i}$到$v_{k}$和从${{v}}_{k}$到$v_{j}$的当前最短路径(中间路径只可能经过$v_{1}v_{2}v_{3}\ldots v_{k-1})$，则将$\left(v_{i},\ldots,v_{k},\ldots,v_{j}\right)$与从$v_{i}$到$v_{j}$的当前最短路径$\left(v_{i},\ldots,v_{j}\right)$（中间路径只可能经过$v_{1}v_{2}v_{3}\ldots v_{k-1})$）进行比较，其长度较短者便是从${v}_{i}$到$v_{j}$的当前最短路径（此时引入了$v_{k}$，故中间路径可能经由$v_{1}v_{2}v_{3}\ldots v_{k})$。若$(v_{i},\ldots,v_{k})$和$(v_{k},\ldots,v_{j})$ 组合起来的路径 $\left(v_{i},\ldots,v_{k},\ldots,v_{j}\right)$ 不大于引入中介结点 $v_{k}$ 的路径长度， 则当前路径长度矩阵 $.D$ 和路径记录矩阵$R$不做任何更新。否则：$\begin{array}{r}{D^{(k)}\big(v_{i},v_{j}\big)=w(v_{i},v_{k})+w\big(v_{k},v_{j}\big),\;\;R^{(k)}\big(v_{i},v_{j}\big)=}\end{array}$$v_{k}$。  
在中介结点集合中增加所有可能的中介结点后，最后求得最短路径的必然是从${v}_{i}$到$v_{j}$的最短路径。由$v_{i}$和$v_{j}$的任意性，可求得各对结点间的最短路径。  
具体地说，沃舍尔∙弗洛伊德算法的基本步骤如下：  
（1）首先进行初始化操作。  
![](images/81a82f8a70a1c69c5768fae83738a36908b9e06f149f4c5733693401ae15cac2.jpg)  
$$
R^{(0)}\big(v_{i},v_{j}\big)=v_{j}
$$  
（2）按如下的原则，将图中的每个结点$v_{k}(k=1,\!2,\dots,n)$分别作为中介结点，更新$D$和$R$矩阵，依次获得矩阵$D^{(1)},D^{(2)},\dots,D^{(n)}$和$R^{(1)},R^{(2)},\ldots,R^{(n)}$。  
(i)若$D^{(k-1)}\big(v_{i},v_{j}\big)>D^{(k-1)}(v_{i},v_{k})+D^{(k-1)}\big(v_{k},v_{j}\big),$  则，  
$$
D^{(k)}\!\left(v_{i},v_{j}\right)\!\!=\!\!D^{(k-1)}(v_{i},v_{k})\!+\!D^{(k-1)}\!\left(v_{k},v_{j}\right)\!;\,\,\,R^{(k)}\!\left(v_{i},v_{j}\right)=v_{k}
$$  
(ii)  若 $ D^{(k-1)}\!\left(v_{i},v_{j}\right)\leq D^{(k-1)}\!\left(v_{k},v_{j}\right)\!+\!D^{(k-1)}\!\left(v_{k},v_{j}\right)$ ，则，   $D^{(k)}\!\left(v_{i},v_{j}\right)\!\!=\!\!D^{(k-1)}\!\left(v_{i},v_{j}\right)\!;\,\,\,R^{(k)}\!\left(v_{i},v_{j}\right)=R^{(k-1)}\!\left(v_{i},v_{j}\right)$  
（3）根据矩阵${ D}^{(n)}$和$R^{(n)}$，计算任意结点之间的最短路径长度和路径序列。以$v_{i}$和$v_{j}$为例计算两者的最短路径序列：若$R^{(n)}=v_{k}$，则在$v_{i}$到$v_{j}$的最短路径中必有中间结点$v_{k}$，那么根据如下规则，分别向$v_{k}$两头追溯一定可以得到$v_{i}$到$v_{j}$的最短路径：  
(i) 向点$v_{i}$方向追溯可以得到：  
$$
R^{(n)}(v_{i},v_{k})=v_{k-1},\ R(v_{i},v_{k-1})=v_{k-2},...,\ R^{(n)}(v_{i},v_{k-m})=v_{i}
$$  
(ii) 向点$v_{j}$方向追溯可以得到：  
$$
R^{(n)}\big(v_{k},v_{j}\big)=v_{k+1},\ R^{(n)}\big(v_{k+1},v_{j}\big)=v_{k+2},...,\ R^{(n)}(v_{i},v_{k+s})=v_{j}
$$  
追溯方向图，如下图8-61 所示。  
![图8-61 通过路径矩阵寻找具体的最短路径  ](images/6a3ea39179dd4fb30e351249de4e2648087eaf5e2356569531de0cb959af6180.jpg)  
由此可见，通过路径长度矩阵$D$和路径记录矩阵$R$，可以求出图中任意一对结点之间的最短路径。",沃舍尔∙弗洛伊德算法用于求解多源最短路径问题，即图中任意对结点之间的最短路径长度。
沃舍尔∙弗洛伊德算法,使用,路径长度矩阵,,"迪杰斯特拉算法解决的是单源最短路径问题，只能求出单独某个源点到其它结点最短路径，然而沃舍尔∙弗洛伊德算法则是求得这个图中任意对结点之间的最短路径长度。  
沃舍尔∙弗洛伊德算法的基本思想是通过逐次增加中介结点的途径，不断优化和更新图中每对结点之间的路径长度。首先，将$v_{1}$作为中介结点，据此更新图中仅以$v_{1}$作为中介结点的路径长度以及相应的路径记录。然后在$v_{1}$的基础上，进一步引入${{v}}_{2}$作为新增的中介结点，并更新图中仅以$v_{1}v_{2}$作为中介结点的路径长度和路径记录。依次类推，在$v_{1}v_{2}v_{3}\ldots v_{k}$作为中介结点的基础上，以$v_{k}$作为新增中介结点计算并更新图中以$v_{1}v_{2}v_{3}\ldots v_{k}$为中介结点的每对结点之间路径长度和路径记录。这样当$k=n$(𝑛为结点个数)时，便可求出图中每对结点的最短路径长度及其相应的路径记录。  
从上面描述的基本思想可以知道，在整个问题解决中有两个点非常重要，一个是路径长度，一个是路径记录，为了方便叙述，我们分别定义相应的矩阵用于记录数据，$D^{(k)}(v_{i},v_{j})$表示在考虑了$v_{1}v_{2}v_{3}\ldots v_{k}$作为中介结点的基础上，结点$v_{i}$与$v_{j}$的当前最短路径长度。$R^{(k)}(v_{i},v_{j})$ 是一个包含结点元素的矩阵，表示在考虑了$v_{1}v_{2}v_{3}\ldots v_{k}$作为中介结点的基础上，结点$v_{i}$与$v_{j}$的当前最短路径长度中必经的一个中间点。  
需要注意的是，在还没有考虑中介结点的最初情况时，应该按如下方法初始化$D$和$R$矩阵元素值，对于图中任意两个相邻结点$v_{i}$和$v_{j}$，即存在一条边$(v_{i},v_{j})$，边上权值为$w(v_{i},v_{j})$，那其长度为$D^{(0)}\big(v_{i},v_{j}\big)=w(v_{i},v_{j})$，否则规定$v_{i}$与$v_{j}$存在一条假想边$(v_{i},v_{j})$，令其长度为无穷大。另外，在尚未开始算法迭代时，将$\cdot R$矩阵每行内容分别置为$v_{j}(j=1,2,3\ldots n)$。  
下面以结点$v_{i}$到$v_{j}$为代表，详细介绍具体计算过程：  
首先，将$v_{1}$作为从$v_{i}$到$v_{j}$的中介结点，进行比较路径$\left(v_{i},v_{j}\right)$和$(v_{i},v_{1},v_{j})$长度的大小，若路径$\left(v_{i},v_{j}\right)$的长度不大于$\left(v_{i},v_{1},v_{j}\right)$的长度，那么取$(v_{i},v_{j})$为从$v_{i}$到$v_{j}$的当前最短路径，即$D^{(1)}\big(v_{i},v_{j}\big)=w(v_{i},v_{j})$，此时不需要更新路径记录矩阵$R$；若是路径$\left(v_{i},v_{1},v_{j}\right)$的长度较小，则取$\left(v_{i},v_{1},v_{j}\right)$为从$v_{i}$到$v_{j}$的当前最短路径，即：  
$$
D^{(1)}\big(v_{i},v_{j}\big)=w(v_{i},v_{1})+w\big(v_{1},v_{j}\big)
$$  
并将$v_{1}$暂时作为$v_{i}$到$v_{j}$的中间点，即$R^{(1)}{\bigl(}v_{i},v_{j}{\bigr)}=v_{1}.$。需要注意的是，当前最短路径中介结点序号不大于1，即当前最短路径只可能经由中介点$v_{1}$。  
对$v_{i}$到$v_{j}$的中介结点集合，再引入结点$v_{2}$，即$v_{i}$到$v_{j}$的中介结点为${v}_{1}$和$v_{2}$。首先确定$(v_{i},\ldots,v_{2})$和$(v_{2},\ldots,v_{j})$分别是当前找到的最短路径（只可能经由中介结点$v_{1}$），则$\left(v_{i},\ldots,v_{2},\ldots,v_{j}\right)$有可能是从$v_{i}$到$v_{j}$的最短路径（只可能经由中介结点$v_{1}$和$v_{2}$）。将其与当前从$v_{i}$到$v_{j}$的最短路径$(v_{i},\ldots,v_{j})$进行比较（只可能经由中介结点$v_{1}$），从中选出从${v}_{i}$到$v_{j}$的最短路径（此时只可能经由中介结点$v_{1}$和$v_{2}$），并按照上述的原则更新相应的$D$和$R$。如此下去，直到将图中所有结点加入${v}_{i}$到$v_{j}$的中介结点集合。  
对于一般情形， $(v_{i},\ldots,v_{k})$和$(v_{k},\ldots,v_{j})$分别是从${v}_{i}$到$v_{k}$和从${{v}}_{k}$到$v_{j}$的当前最短路径(中间路径只可能经过$v_{1}v_{2}v_{3}\ldots v_{k-1})$，则将$\left(v_{i},\ldots,v_{k},\ldots,v_{j}\right)$与从$v_{i}$到$v_{j}$的当前最短路径$\left(v_{i},\ldots,v_{j}\right)$（中间路径只可能经过$v_{1}v_{2}v_{3}\ldots v_{k-1})$）进行比较，其长度较短者便是从${v}_{i}$到$v_{j}$的当前最短路径（此时引入了$v_{k}$，故中间路径可能经由$v_{1}v_{2}v_{3}\ldots v_{k})$。若$(v_{i},\ldots,v_{k})$和$(v_{k},\ldots,v_{j})$ 组合起来的路径 $\left(v_{i},\ldots,v_{k},\ldots,v_{j}\right)$ 不大于引入中介结点 $v_{k}$ 的路径长度， 则当前路径长度矩阵 $.D$ 和路径记录矩阵$R$不做任何更新。否则：$\begin{array}{r}{D^{(k)}\big(v_{i},v_{j}\big)=w(v_{i},v_{k})+w\big(v_{k},v_{j}\big),\;\;R^{(k)}\big(v_{i},v_{j}\big)=}\end{array}$$v_{k}$。  
在中介结点集合中增加所有可能的中介结点后，最后求得最短路径的必然是从${v}_{i}$到$v_{j}$的最短路径。由$v_{i}$和$v_{j}$的任意性，可求得各对结点间的最短路径。  
具体地说，沃舍尔∙弗洛伊德算法的基本步骤如下：  
（1）首先进行初始化操作。  
![](images/81a82f8a70a1c69c5768fae83738a36908b9e06f149f4c5733693401ae15cac2.jpg)  
$$
R^{(0)}\big(v_{i},v_{j}\big)=v_{j}
$$  
（2）按如下的原则，将图中的每个结点$v_{k}(k=1,\!2,\dots,n)$分别作为中介结点，更新$D$和$R$矩阵，依次获得矩阵$D^{(1)},D^{(2)},\dots,D^{(n)}$和$R^{(1)},R^{(2)},\ldots,R^{(n)}$。  
(i)若$D^{(k-1)}\big(v_{i},v_{j}\big)>D^{(k-1)}(v_{i},v_{k})+D^{(k-1)}\big(v_{k},v_{j}\big),$  则，  
$$
D^{(k)}\!\left(v_{i},v_{j}\right)\!\!=\!\!D^{(k-1)}(v_{i},v_{k})\!+\!D^{(k-1)}\!\left(v_{k},v_{j}\right)\!;\,\,\,R^{(k)}\!\left(v_{i},v_{j}\right)=v_{k}
$$  
(ii)  若 $ D^{(k-1)}\!\left(v_{i},v_{j}\right)\leq D^{(k-1)}\!\left(v_{k},v_{j}\right)\!+\!D^{(k-1)}\!\left(v_{k},v_{j}\right)$ ，则，   $D^{(k)}\!\left(v_{i},v_{j}\right)\!\!=\!\!D^{(k-1)}\!\left(v_{i},v_{j}\right)\!;\,\,\,R^{(k)}\!\left(v_{i},v_{j}\right)=R^{(k-1)}\!\left(v_{i},v_{j}\right)$  
（3）根据矩阵${ D}^{(n)}$和$R^{(n)}$，计算任意结点之间的最短路径长度和路径序列。以$v_{i}$和$v_{j}$为例计算两者的最短路径序列：若$R^{(n)}=v_{k}$，则在$v_{i}$到$v_{j}$的最短路径中必有中间结点$v_{k}$，那么根据如下规则，分别向$v_{k}$两头追溯一定可以得到$v_{i}$到$v_{j}$的最短路径：  
(i) 向点$v_{i}$方向追溯可以得到：  
$$
R^{(n)}(v_{i},v_{k})=v_{k-1},\ R(v_{i},v_{k-1})=v_{k-2},...,\ R^{(n)}(v_{i},v_{k-m})=v_{i}
$$  
(ii) 向点$v_{j}$方向追溯可以得到：  
$$
R^{(n)}\big(v_{k},v_{j}\big)=v_{k+1},\ R^{(n)}\big(v_{k+1},v_{j}\big)=v_{k+2},...,\ R^{(n)}(v_{i},v_{k+s})=v_{j}
$$  
追溯方向图，如下图8-61 所示。  
![图8-61 通过路径矩阵寻找具体的最短路径  ](images/6a3ea39179dd4fb30e351249de4e2648087eaf5e2356569531de0cb959af6180.jpg)  
由此可见，通过路径长度矩阵$D$和路径记录矩阵$R$，可以求出图中任意一对结点之间的最短路径。",沃舍尔∙弗洛伊德算法使用路径长度矩阵记录和更新每对结点之间的当前最短路径长度。
沃舍尔∙弗洛伊德算法,使用,路径记录矩阵,,"迪杰斯特拉算法解决的是单源最短路径问题，只能求出单独某个源点到其它结点最短路径，然而沃舍尔∙弗洛伊德算法则是求得这个图中任意对结点之间的最短路径长度。  
沃舍尔∙弗洛伊德算法的基本思想是通过逐次增加中介结点的途径，不断优化和更新图中每对结点之间的路径长度。首先，将$v_{1}$作为中介结点，据此更新图中仅以$v_{1}$作为中介结点的路径长度以及相应的路径记录。然后在$v_{1}$的基础上，进一步引入${{v}}_{2}$作为新增的中介结点，并更新图中仅以$v_{1}v_{2}$作为中介结点的路径长度和路径记录。依次类推，在$v_{1}v_{2}v_{3}\ldots v_{k}$作为中介结点的基础上，以$v_{k}$作为新增中介结点计算并更新图中以$v_{1}v_{2}v_{3}\ldots v_{k}$为中介结点的每对结点之间路径长度和路径记录。这样当$k=n$(𝑛为结点个数)时，便可求出图中每对结点的最短路径长度及其相应的路径记录。  
从上面描述的基本思想可以知道，在整个问题解决中有两个点非常重要，一个是路径长度，一个是路径记录，为了方便叙述，我们分别定义相应的矩阵用于记录数据，$D^{(k)}(v_{i},v_{j})$表示在考虑了$v_{1}v_{2}v_{3}\ldots v_{k}$作为中介结点的基础上，结点$v_{i}$与$v_{j}$的当前最短路径长度。$R^{(k)}(v_{i},v_{j})$ 是一个包含结点元素的矩阵，表示在考虑了$v_{1}v_{2}v_{3}\ldots v_{k}$作为中介结点的基础上，结点$v_{i}$与$v_{j}$的当前最短路径长度中必经的一个中间点。  
需要注意的是，在还没有考虑中介结点的最初情况时，应该按如下方法初始化$D$和$R$矩阵元素值，对于图中任意两个相邻结点$v_{i}$和$v_{j}$，即存在一条边$(v_{i},v_{j})$，边上权值为$w(v_{i},v_{j})$，那其长度为$D^{(0)}\big(v_{i},v_{j}\big)=w(v_{i},v_{j})$，否则规定$v_{i}$与$v_{j}$存在一条假想边$(v_{i},v_{j})$，令其长度为无穷大。另外，在尚未开始算法迭代时，将$\cdot R$矩阵每行内容分别置为$v_{j}(j=1,2,3\ldots n)$。  
下面以结点$v_{i}$到$v_{j}$为代表，详细介绍具体计算过程：  
首先，将$v_{1}$作为从$v_{i}$到$v_{j}$的中介结点，进行比较路径$\left(v_{i},v_{j}\right)$和$(v_{i},v_{1},v_{j})$长度的大小，若路径$\left(v_{i},v_{j}\right)$的长度不大于$\left(v_{i},v_{1},v_{j}\right)$的长度，那么取$(v_{i},v_{j})$为从$v_{i}$到$v_{j}$的当前最短路径，即$D^{(1)}\big(v_{i},v_{j}\big)=w(v_{i},v_{j})$，此时不需要更新路径记录矩阵$R$；若是路径$\left(v_{i},v_{1},v_{j}\right)$的长度较小，则取$\left(v_{i},v_{1},v_{j}\right)$为从$v_{i}$到$v_{j}$的当前最短路径，即：  
$$
D^{(1)}\big(v_{i},v_{j}\big)=w(v_{i},v_{1})+w\big(v_{1},v_{j}\big)
$$  
并将$v_{1}$暂时作为$v_{i}$到$v_{j}$的中间点，即$R^{(1)}{\bigl(}v_{i},v_{j}{\bigr)}=v_{1}.$。需要注意的是，当前最短路径中介结点序号不大于1，即当前最短路径只可能经由中介点$v_{1}$。  
对$v_{i}$到$v_{j}$的中介结点集合，再引入结点$v_{2}$，即$v_{i}$到$v_{j}$的中介结点为${v}_{1}$和$v_{2}$。首先确定$(v_{i},\ldots,v_{2})$和$(v_{2},\ldots,v_{j})$分别是当前找到的最短路径（只可能经由中介结点$v_{1}$），则$\left(v_{i},\ldots,v_{2},\ldots,v_{j}\right)$有可能是从$v_{i}$到$v_{j}$的最短路径（只可能经由中介结点$v_{1}$和$v_{2}$）。将其与当前从$v_{i}$到$v_{j}$的最短路径$(v_{i},\ldots,v_{j})$进行比较（只可能经由中介结点$v_{1}$），从中选出从${v}_{i}$到$v_{j}$的最短路径（此时只可能经由中介结点$v_{1}$和$v_{2}$），并按照上述的原则更新相应的$D$和$R$。如此下去，直到将图中所有结点加入${v}_{i}$到$v_{j}$的中介结点集合。  
对于一般情形， $(v_{i},\ldots,v_{k})$和$(v_{k},\ldots,v_{j})$分别是从${v}_{i}$到$v_{k}$和从${{v}}_{k}$到$v_{j}$的当前最短路径(中间路径只可能经过$v_{1}v_{2}v_{3}\ldots v_{k-1})$，则将$\left(v_{i},\ldots,v_{k},\ldots,v_{j}\right)$与从$v_{i}$到$v_{j}$的当前最短路径$\left(v_{i},\ldots,v_{j}\right)$（中间路径只可能经过$v_{1}v_{2}v_{3}\ldots v_{k-1})$）进行比较，其长度较短者便是从${v}_{i}$到$v_{j}$的当前最短路径（此时引入了$v_{k}$，故中间路径可能经由$v_{1}v_{2}v_{3}\ldots v_{k})$。若$(v_{i},\ldots,v_{k})$和$(v_{k},\ldots,v_{j})$ 组合起来的路径 $\left(v_{i},\ldots,v_{k},\ldots,v_{j}\right)$ 不大于引入中介结点 $v_{k}$ 的路径长度， 则当前路径长度矩阵 $.D$ 和路径记录矩阵$R$不做任何更新。否则：$\begin{array}{r}{D^{(k)}\big(v_{i},v_{j}\big)=w(v_{i},v_{k})+w\big(v_{k},v_{j}\big),\;\;R^{(k)}\big(v_{i},v_{j}\big)=}\end{array}$$v_{k}$。  
在中介结点集合中增加所有可能的中介结点后，最后求得最短路径的必然是从${v}_{i}$到$v_{j}$的最短路径。由$v_{i}$和$v_{j}$的任意性，可求得各对结点间的最短路径。  
具体地说，沃舍尔∙弗洛伊德算法的基本步骤如下：  
（1）首先进行初始化操作。  
![](images/81a82f8a70a1c69c5768fae83738a36908b9e06f149f4c5733693401ae15cac2.jpg)  
$$
R^{(0)}\big(v_{i},v_{j}\big)=v_{j}
$$  
（2）按如下的原则，将图中的每个结点$v_{k}(k=1,\!2,\dots,n)$分别作为中介结点，更新$D$和$R$矩阵，依次获得矩阵$D^{(1)},D^{(2)},\dots,D^{(n)}$和$R^{(1)},R^{(2)},\ldots,R^{(n)}$。  
(i)若$D^{(k-1)}\big(v_{i},v_{j}\big)>D^{(k-1)}(v_{i},v_{k})+D^{(k-1)}\big(v_{k},v_{j}\big),$  则，  
$$
D^{(k)}\!\left(v_{i},v_{j}\right)\!\!=\!\!D^{(k-1)}(v_{i},v_{k})\!+\!D^{(k-1)}\!\left(v_{k},v_{j}\right)\!;\,\,\,R^{(k)}\!\left(v_{i},v_{j}\right)=v_{k}
$$  
(ii)  若 $ D^{(k-1)}\!\left(v_{i},v_{j}\right)\leq D^{(k-1)}\!\left(v_{k},v_{j}\right)\!+\!D^{(k-1)}\!\left(v_{k},v_{j}\right)$ ，则，   $D^{(k)}\!\left(v_{i},v_{j}\right)\!\!=\!\!D^{(k-1)}\!\left(v_{i},v_{j}\right)\!;\,\,\,R^{(k)}\!\left(v_{i},v_{j}\right)=R^{(k-1)}\!\left(v_{i},v_{j}\right)$  
（3）根据矩阵${ D}^{(n)}$和$R^{(n)}$，计算任意结点之间的最短路径长度和路径序列。以$v_{i}$和$v_{j}$为例计算两者的最短路径序列：若$R^{(n)}=v_{k}$，则在$v_{i}$到$v_{j}$的最短路径中必有中间结点$v_{k}$，那么根据如下规则，分别向$v_{k}$两头追溯一定可以得到$v_{i}$到$v_{j}$的最短路径：  
(i) 向点$v_{i}$方向追溯可以得到：  
$$
R^{(n)}(v_{i},v_{k})=v_{k-1},\ R(v_{i},v_{k-1})=v_{k-2},...,\ R^{(n)}(v_{i},v_{k-m})=v_{i}
$$  
(ii) 向点$v_{j}$方向追溯可以得到：  
$$
R^{(n)}\big(v_{k},v_{j}\big)=v_{k+1},\ R^{(n)}\big(v_{k+1},v_{j}\big)=v_{k+2},...,\ R^{(n)}(v_{i},v_{k+s})=v_{j}
$$  
追溯方向图，如下图8-61 所示。  
![图8-61 通过路径矩阵寻找具体的最短路径  ](images/6a3ea39179dd4fb30e351249de4e2648087eaf5e2356569531de0cb959af6180.jpg)  
由此可见，通过路径长度矩阵$D$和路径记录矩阵$R$，可以求出图中任意一对结点之间的最短路径。",沃舍尔∙弗洛伊德算法使用路径记录矩阵记录每对结点之间最短路径中的必经中间点。
路径长度矩阵,配合,路径记录矩阵,,"迪杰斯特拉算法解决的是单源最短路径问题，只能求出单独某个源点到其它结点最短路径，然而沃舍尔∙弗洛伊德算法则是求得这个图中任意对结点之间的最短路径长度。  
沃舍尔∙弗洛伊德算法的基本思想是通过逐次增加中介结点的途径，不断优化和更新图中每对结点之间的路径长度。首先，将$v_{1}$作为中介结点，据此更新图中仅以$v_{1}$作为中介结点的路径长度以及相应的路径记录。然后在$v_{1}$的基础上，进一步引入${{v}}_{2}$作为新增的中介结点，并更新图中仅以$v_{1}v_{2}$作为中介结点的路径长度和路径记录。依次类推，在$v_{1}v_{2}v_{3}\ldots v_{k}$作为中介结点的基础上，以$v_{k}$作为新增中介结点计算并更新图中以$v_{1}v_{2}v_{3}\ldots v_{k}$为中介结点的每对结点之间路径长度和路径记录。这样当$k=n$(𝑛为结点个数)时，便可求出图中每对结点的最短路径长度及其相应的路径记录。  
从上面描述的基本思想可以知道，在整个问题解决中有两个点非常重要，一个是路径长度，一个是路径记录，为了方便叙述，我们分别定义相应的矩阵用于记录数据，$D^{(k)}(v_{i},v_{j})$表示在考虑了$v_{1}v_{2}v_{3}\ldots v_{k}$作为中介结点的基础上，结点$v_{i}$与$v_{j}$的当前最短路径长度。$R^{(k)}(v_{i},v_{j})$ 是一个包含结点元素的矩阵，表示在考虑了$v_{1}v_{2}v_{3}\ldots v_{k}$作为中介结点的基础上，结点$v_{i}$与$v_{j}$的当前最短路径长度中必经的一个中间点。  
需要注意的是，在还没有考虑中介结点的最初情况时，应该按如下方法初始化$D$和$R$矩阵元素值，对于图中任意两个相邻结点$v_{i}$和$v_{j}$，即存在一条边$(v_{i},v_{j})$，边上权值为$w(v_{i},v_{j})$，那其长度为$D^{(0)}\big(v_{i},v_{j}\big)=w(v_{i},v_{j})$，否则规定$v_{i}$与$v_{j}$存在一条假想边$(v_{i},v_{j})$，令其长度为无穷大。另外，在尚未开始算法迭代时，将$\cdot R$矩阵每行内容分别置为$v_{j}(j=1,2,3\ldots n)$。  
下面以结点$v_{i}$到$v_{j}$为代表，详细介绍具体计算过程：  
首先，将$v_{1}$作为从$v_{i}$到$v_{j}$的中介结点，进行比较路径$\left(v_{i},v_{j}\right)$和$(v_{i},v_{1},v_{j})$长度的大小，若路径$\left(v_{i},v_{j}\right)$的长度不大于$\left(v_{i},v_{1},v_{j}\right)$的长度，那么取$(v_{i},v_{j})$为从$v_{i}$到$v_{j}$的当前最短路径，即$D^{(1)}\big(v_{i},v_{j}\big)=w(v_{i},v_{j})$，此时不需要更新路径记录矩阵$R$；若是路径$\left(v_{i},v_{1},v_{j}\right)$的长度较小，则取$\left(v_{i},v_{1},v_{j}\right)$为从$v_{i}$到$v_{j}$的当前最短路径，即：  
$$
D^{(1)}\big(v_{i},v_{j}\big)=w(v_{i},v_{1})+w\big(v_{1},v_{j}\big)
$$  
并将$v_{1}$暂时作为$v_{i}$到$v_{j}$的中间点，即$R^{(1)}{\bigl(}v_{i},v_{j}{\bigr)}=v_{1}.$。需要注意的是，当前最短路径中介结点序号不大于1，即当前最短路径只可能经由中介点$v_{1}$。  
对$v_{i}$到$v_{j}$的中介结点集合，再引入结点$v_{2}$，即$v_{i}$到$v_{j}$的中介结点为${v}_{1}$和$v_{2}$。首先确定$(v_{i},\ldots,v_{2})$和$(v_{2},\ldots,v_{j})$分别是当前找到的最短路径（只可能经由中介结点$v_{1}$），则$\left(v_{i},\ldots,v_{2},\ldots,v_{j}\right)$有可能是从$v_{i}$到$v_{j}$的最短路径（只可能经由中介结点$v_{1}$和$v_{2}$）。将其与当前从$v_{i}$到$v_{j}$的最短路径$(v_{i},\ldots,v_{j})$进行比较（只可能经由中介结点$v_{1}$），从中选出从${v}_{i}$到$v_{j}$的最短路径（此时只可能经由中介结点$v_{1}$和$v_{2}$），并按照上述的原则更新相应的$D$和$R$。如此下去，直到将图中所有结点加入${v}_{i}$到$v_{j}$的中介结点集合。  
对于一般情形， $(v_{i},\ldots,v_{k})$和$(v_{k},\ldots,v_{j})$分别是从${v}_{i}$到$v_{k}$和从${{v}}_{k}$到$v_{j}$的当前最短路径(中间路径只可能经过$v_{1}v_{2}v_{3}\ldots v_{k-1})$，则将$\left(v_{i},\ldots,v_{k},\ldots,v_{j}\right)$与从$v_{i}$到$v_{j}$的当前最短路径$\left(v_{i},\ldots,v_{j}\right)$（中间路径只可能经过$v_{1}v_{2}v_{3}\ldots v_{k-1})$）进行比较，其长度较短者便是从${v}_{i}$到$v_{j}$的当前最短路径（此时引入了$v_{k}$，故中间路径可能经由$v_{1}v_{2}v_{3}\ldots v_{k})$。若$(v_{i},\ldots,v_{k})$和$(v_{k},\ldots,v_{j})$ 组合起来的路径 $\left(v_{i},\ldots,v_{k},\ldots,v_{j}\right)$ 不大于引入中介结点 $v_{k}$ 的路径长度， 则当前路径长度矩阵 $.D$ 和路径记录矩阵$R$不做任何更新。否则：$\begin{array}{r}{D^{(k)}\big(v_{i},v_{j}\big)=w(v_{i},v_{k})+w\big(v_{k},v_{j}\big),\;\;R^{(k)}\big(v_{i},v_{j}\big)=}\end{array}$$v_{k}$。  
在中介结点集合中增加所有可能的中介结点后，最后求得最短路径的必然是从${v}_{i}$到$v_{j}$的最短路径。由$v_{i}$和$v_{j}$的任意性，可求得各对结点间的最短路径。  
具体地说，沃舍尔∙弗洛伊德算法的基本步骤如下：  
（1）首先进行初始化操作。  
![](images/81a82f8a70a1c69c5768fae83738a36908b9e06f149f4c5733693401ae15cac2.jpg)  
$$
R^{(0)}\big(v_{i},v_{j}\big)=v_{j}
$$  
（2）按如下的原则，将图中的每个结点$v_{k}(k=1,\!2,\dots,n)$分别作为中介结点，更新$D$和$R$矩阵，依次获得矩阵$D^{(1)},D^{(2)},\dots,D^{(n)}$和$R^{(1)},R^{(2)},\ldots,R^{(n)}$。  
(i)若$D^{(k-1)}\big(v_{i},v_{j}\big)>D^{(k-1)}(v_{i},v_{k})+D^{(k-1)}\big(v_{k},v_{j}\big),$  则，  
$$
D^{(k)}\!\left(v_{i},v_{j}\right)\!\!=\!\!D^{(k-1)}(v_{i},v_{k})\!+\!D^{(k-1)}\!\left(v_{k},v_{j}\right)\!;\,\,\,R^{(k)}\!\left(v_{i},v_{j}\right)=v_{k}
$$  
(ii)  若 $ D^{(k-1)}\!\left(v_{i},v_{j}\right)\leq D^{(k-1)}\!\left(v_{k},v_{j}\right)\!+\!D^{(k-1)}\!\left(v_{k},v_{j}\right)$ ，则，   $D^{(k)}\!\left(v_{i},v_{j}\right)\!\!=\!\!D^{(k-1)}\!\left(v_{i},v_{j}\right)\!;\,\,\,R^{(k)}\!\left(v_{i},v_{j}\right)=R^{(k-1)}\!\left(v_{i},v_{j}\right)$  
（3）根据矩阵${ D}^{(n)}$和$R^{(n)}$，计算任意结点之间的最短路径长度和路径序列。以$v_{i}$和$v_{j}$为例计算两者的最短路径序列：若$R^{(n)}=v_{k}$，则在$v_{i}$到$v_{j}$的最短路径中必有中间结点$v_{k}$，那么根据如下规则，分别向$v_{k}$两头追溯一定可以得到$v_{i}$到$v_{j}$的最短路径：  
(i) 向点$v_{i}$方向追溯可以得到：  
$$
R^{(n)}(v_{i},v_{k})=v_{k-1},\ R(v_{i},v_{k-1})=v_{k-2},...,\ R^{(n)}(v_{i},v_{k-m})=v_{i}
$$  
(ii) 向点$v_{j}$方向追溯可以得到：  
$$
R^{(n)}\big(v_{k},v_{j}\big)=v_{k+1},\ R^{(n)}\big(v_{k+1},v_{j}\big)=v_{k+2},...,\ R^{(n)}(v_{i},v_{k+s})=v_{j}
$$  
追溯方向图，如下图8-61 所示。  
![图8-61 通过路径矩阵寻找具体的最短路径  ](images/6a3ea39179dd4fb30e351249de4e2648087eaf5e2356569531de0cb959af6180.jpg)  
由此可见，通过路径长度矩阵$D$和路径记录矩阵$R$，可以求出图中任意一对结点之间的最短路径。",路径长度矩阵和路径记录矩阵配合使用，共同记录和更新结点间的最短路径长度及其必经中间点。
图模型,结合,形象思维,,图模型实现了形象思维与抽象思维的完美结合，是一种非常有效的数学模型和工具，在解决如计算机网络路由问题、送快递的最短路径问题、网站之间的链接模型问题、工程预算的关键路径问题、软件代码复杂度计算问题等诸多复杂问题中发挥至关重要、不可替代的作用。本节通过若干具体实例介绍图模型的应用技术。,图模型实现了形象思维与抽象思维的完美结合
图模型,结合,抽象思维,,图模型实现了形象思维与抽象思维的完美结合，是一种非常有效的数学模型和工具，在解决如计算机网络路由问题、送快递的最短路径问题、网站之间的链接模型问题、工程预算的关键路径问题、软件代码复杂度计算问题等诸多复杂问题中发挥至关重要、不可替代的作用。本节通过若干具体实例介绍图模型的应用技术。,图模型实现了形象思维与抽象思维的完美结合
图模型,是,数学模型,,图模型实现了形象思维与抽象思维的完美结合，是一种非常有效的数学模型和工具，在解决如计算机网络路由问题、送快递的最短路径问题、网站之间的链接模型问题、工程预算的关键路径问题、软件代码复杂度计算问题等诸多复杂问题中发挥至关重要、不可替代的作用。本节通过若干具体实例介绍图模型的应用技术。,图模型是一种非常有效的数学模型和工具
图模型,是,工具,,图模型实现了形象思维与抽象思维的完美结合，是一种非常有效的数学模型和工具，在解决如计算机网络路由问题、送快递的最短路径问题、网站之间的链接模型问题、工程预算的关键路径问题、软件代码复杂度计算问题等诸多复杂问题中发挥至关重要、不可替代的作用。本节通过若干具体实例介绍图模型的应用技术。,图模型是一种非常有效的数学模型和工具
图模型,解决,计算机网络路由问题,,图模型实现了形象思维与抽象思维的完美结合，是一种非常有效的数学模型和工具，在解决如计算机网络路由问题、送快递的最短路径问题、网站之间的链接模型问题、工程预算的关键路径问题、软件代码复杂度计算问题等诸多复杂问题中发挥至关重要、不可替代的作用。本节通过若干具体实例介绍图模型的应用技术。,图模型在解决计算机网络路由问题中发挥至关重要、不可替代的作用
图模型,解决,送快递的最短路径问题,,图模型实现了形象思维与抽象思维的完美结合，是一种非常有效的数学模型和工具，在解决如计算机网络路由问题、送快递的最短路径问题、网站之间的链接模型问题、工程预算的关键路径问题、软件代码复杂度计算问题等诸多复杂问题中发挥至关重要、不可替代的作用。本节通过若干具体实例介绍图模型的应用技术。,图模型在解决送快递的最短路径问题中发挥至关重要、不可替代的作用
图模型,解决,网站之间的链接模型问题,,图模型实现了形象思维与抽象思维的完美结合，是一种非常有效的数学模型和工具，在解决如计算机网络路由问题、送快递的最短路径问题、网站之间的链接模型问题、工程预算的关键路径问题、软件代码复杂度计算问题等诸多复杂问题中发挥至关重要、不可替代的作用。本节通过若干具体实例介绍图模型的应用技术。,图模型在解决网站之间的链接模型问题中发挥至关重要、不可替代的作用
图模型,解决,工程预算的关键路径问题,,图模型实现了形象思维与抽象思维的完美结合，是一种非常有效的数学模型和工具，在解决如计算机网络路由问题、送快递的最短路径问题、网站之间的链接模型问题、工程预算的关键路径问题、软件代码复杂度计算问题等诸多复杂问题中发挥至关重要、不可替代的作用。本节通过若干具体实例介绍图模型的应用技术。,图模型在解决工程预算的关键路径问题中发挥至关重要、不可替代的作用
图模型,解决,软件代码复杂度计算问题,,图模型实现了形象思维与抽象思维的完美结合，是一种非常有效的数学模型和工具，在解决如计算机网络路由问题、送快递的最短路径问题、网站之间的链接模型问题、工程预算的关键路径问题、软件代码复杂度计算问题等诸多复杂问题中发挥至关重要、不可替代的作用。本节通过若干具体实例介绍图模型的应用技术。,图模型在解决软件代码复杂度计算问题中发挥至关重要、不可替代的作用
图模型,介绍,应用技术,,图模型实现了形象思维与抽象思维的完美结合，是一种非常有效的数学模型和工具，在解决如计算机网络路由问题、送快递的最短路径问题、网站之间的链接模型问题、工程预算的关键路径问题、软件代码复杂度计算问题等诸多复杂问题中发挥至关重要、不可替代的作用。本节通过若干具体实例介绍图模型的应用技术。,本节通过若干具体实例介绍图模型的应用技术
交通灯相位问题,等价于,图的着色问题,,"现实生活中，为了避免不同方向交通流之间的相互冲突，可以通过在时间上给各个方向交通流分配相应的通行权。例如，为了放行东西向的直行车流且同时避免南北向的直行、左转车流与其发生冲突，可以通过启亮东西向的绿色直行箭头灯将路口的通行权赋予东西向的直行车流，启亮南北向的红灯消除南北向直行、左转车流对东西向直行车流通行的影响。  
对于一组互不冲突的交通流同时获得通行权所对应的信号显示状态，我们将其称之为信号相位，简称为相位。可以看出，交通灯信号相位是根据交叉口通行权在一个周期内的更迭来划分的。一个红绿灯信号控制方案在一个周期内有几个信号相位。图8-65 所示就是一个采用4 相位信号控制的控制方案。一个路口采用几相位的信号控制应由该路口的实际交通流状况决定，十字路口通常采用2 到4 个相位。如果相位数设计的太少，则不能有效的分配好路口通行权，路口很容易出现交通混乱，交通安全下降；如果相位数设计的太多，虽然路口的交通次序与安全性得到了改善，但由于相位之间进行转换时都会损失一部分通行时间，过多的相位数会导致路口的通行能力下降，延长司机在路口的等待时间。  
因此合理地设置交通灯相位数目，对于改善道路交通状况，有着非常重要的现实意义。那么如何去设置交通灯相位数目呢？其实交通灯相位问题，可以看成是图的着色问题，因而运用图论相关知识，可以有效地解决这一问题。关于图的着色问题，本书第十章-特殊图部分将会详细介绍，本小节不在赘述。另外，图的着色问题在实际生活中应用十分广泛，比如空调管道设计问题、考试安排问题、排课表问题等，有兴趣的读者可以作进一步了解。  
![图8-65  交通灯相位 ](images/0ec4bd3e4d43385c2caf5ee668ee55d5cf1941926e063b0c9b7c9bdaa556d346.jpg)",交通灯相位问题可以看成是图的着色问题，运用图论相关知识可以有效地解决交通灯相位问题
PERT图,包含,关键路径,,"生活中有着多种多样的工程，而每一项工程往往都是由多种不同的活动相互组合而成，这些活动中，有的可以并行执行，而有的活动却必须要等到前面的准备活动都做好之后才能开始进行。例如，在一个软件开发项目中，包括以下几个阶段：需求分析，系统设计，模块代码编写，单元测试，软件维护。其中代码编写和单元测试可以同时进行，但是代码编写却一定要在需求分析和系统设计完成之后才行，需求分析和系统设计构成了代码编写的准备工作。既然存在这样的现象，那么在一项很复杂的工程中，如何合理的安排活动的进行，能够使得整个工程完成时间最早呢？其实，这就是关键路径问题。在求解关键路径问题之前，我们有必要先了解下PERT 图的相关概念。  
PERT 图是一个有向连通图$G=\langle V,E\rangle$，且  
（1）每条边表示一个作业（工序），边的非负实数权表示完成该作业所需的时间；  
（2）每个顶点表示以该顶点为起点的作业开始，也表示以该顶点为终点的作业结束；  
（3）作业开始条件：某条有向边$e=\langle v,u\rangle$所代表的作业可以开始 当且仅当 以v为终点的有向边所代表的作业全部完成；  
（4）G没有有向回路，也没有环；  
（5）G中有且仅有一个顶点的入度为0，称该顶点为源点；同时G中有且禁言一个顶点的出度为0，称该顶点为汇点。  
对于给定的PERT 图$G=\langle V,E\rangle$，我们主要关心其关键路径，以及每个作业的最早开始时间和最晚开始时间。关于PERT 图，有如下定义：  
（1）关键路径：G中从源点到汇点最长带权路径路径称为关键路径。关键路径的长度T为完成整个任务（即包括所有作业）所必需的最少时间。  
（2）关键作业：关键路径上的边所代表的作业称为关键作业。  
（3）最早启动时间：对于某个作业${e}=\left<v_{i},-\right>$，源点到该作业起点$v_{i}$的最长路径长度$\pi_{i}$称为该作业的最早启动时间。  
（4）最晚启动时间：设$v_{i}$到汇点${v}_{n}$的最长路径长度为$\pi_{i}^{\prime}$，则该作业可最晚于$\mathsf{\Delta}\mathsf{T}_{i}=\mathsf{T}-$$\uppi_{i}^{\prime}$时间启动而不影响整个任务完成的预期时间T，$\uptau_{i}$称为该作业的最晚启动时间。  
显然，作业${e}=\langle v_{i},-\rangle$是关键作业当且仅当$\pi_{i}=\uptau_{i}$，因为这时e是处于源点到汇点最长带权路径上。故可通过求每个作业的最早启动时间和最晚启动时间而得到PERT 图的关键路径。那么如何求解作业的最早启动时间和最晚启动时间呢？下面给出了求解方法：  
设PERT 图$G=\langle V,E\rangle$的顶点编号$v_{1},v_{2},\dots,v_{n}$，使得边$e=\langle v_{i},v_{j}\rangle\in E$蕴含$i<j$  
令$\pi_{1}=0$，$\pi_{j}=m a x\{\pi_{m}+w(v_{m},v_{j})|1\leq m<j\}$，则$\pi_{i}(1\leq i\leq n)$是作业$e=\langle v_{i},v_{j}\rangle$的最早启动时间。这里$w(v_{m},v_{j})$定义为：  
$w(v_m,v_j)=\begin{cases}\text{边}\langle v_m,v_j\rangle\text{的非负实数权,~~~~~~~~若}\langle v_m,v_j\rangle\in E;\\-\infty,&\text{否则}\end{cases}\text{(8-18)}$  
令$\tau_{n}=\pi_{n}$，$\tau_{k}=m a x\{\tau_{k},\tau_{k}-w(v_{k},v_{m})|k<m\leq n\}$，则$\tau_{i}(1\leq i\leq n)$是作业$e=$$\langle v_{i},v_{j}\rangle$的最晚启动时间。  
由于某顶点的最早启动时间（最晚启动时间）就是所有以该顶点为起点的作业的最早启动时间（最晚启动时间）。因此求解关键路径，可以通过计算每个顶点的最早启动时间和最晚启动时间来确定。  
另外，为了更方便的判断顶点$v_{i}$是否为关键路径上的顶点，在此定义$v_{i}$的缓冲时间$S_{i}=$$\tau_{i}-\pi_{i}$。在关键路径上，各顶点的缓冲时间𝑆均为0，任何关键作业如果耽误了时间𝑡，整个工程就耽误了时间𝑡。下面给出求解关键路径的具体例子。",PERT图中从源点到汇点的最长带权路径称为关键路径
关键路径,组成,关键作业,,"生活中有着多种多样的工程，而每一项工程往往都是由多种不同的活动相互组合而成，这些活动中，有的可以并行执行，而有的活动却必须要等到前面的准备活动都做好之后才能开始进行。例如，在一个软件开发项目中，包括以下几个阶段：需求分析，系统设计，模块代码编写，单元测试，软件维护。其中代码编写和单元测试可以同时进行，但是代码编写却一定要在需求分析和系统设计完成之后才行，需求分析和系统设计构成了代码编写的准备工作。既然存在这样的现象，那么在一项很复杂的工程中，如何合理的安排活动的进行，能够使得整个工程完成时间最早呢？其实，这就是关键路径问题。在求解关键路径问题之前，我们有必要先了解下PERT 图的相关概念。  
PERT 图是一个有向连通图$G=\langle V,E\rangle$，且  
（1）每条边表示一个作业（工序），边的非负实数权表示完成该作业所需的时间；  
（2）每个顶点表示以该顶点为起点的作业开始，也表示以该顶点为终点的作业结束；  
（3）作业开始条件：某条有向边$e=\langle v,u\rangle$所代表的作业可以开始 当且仅当 以v为终点的有向边所代表的作业全部完成；  
（4）G没有有向回路，也没有环；  
（5）G中有且仅有一个顶点的入度为0，称该顶点为源点；同时G中有且禁言一个顶点的出度为0，称该顶点为汇点。  
对于给定的PERT 图$G=\langle V,E\rangle$，我们主要关心其关键路径，以及每个作业的最早开始时间和最晚开始时间。关于PERT 图，有如下定义：  
（1）关键路径：G中从源点到汇点最长带权路径路径称为关键路径。关键路径的长度T为完成整个任务（即包括所有作业）所必需的最少时间。  
（2）关键作业：关键路径上的边所代表的作业称为关键作业。  
（3）最早启动时间：对于某个作业${e}=\left<v_{i},-\right>$，源点到该作业起点$v_{i}$的最长路径长度$\pi_{i}$称为该作业的最早启动时间。  
（4）最晚启动时间：设$v_{i}$到汇点${v}_{n}$的最长路径长度为$\pi_{i}^{\prime}$，则该作业可最晚于$\mathsf{\Delta}\mathsf{T}_{i}=\mathsf{T}-$$\uppi_{i}^{\prime}$时间启动而不影响整个任务完成的预期时间T，$\uptau_{i}$称为该作业的最晚启动时间。  
显然，作业${e}=\langle v_{i},-\rangle$是关键作业当且仅当$\pi_{i}=\uptau_{i}$，因为这时e是处于源点到汇点最长带权路径上。故可通过求每个作业的最早启动时间和最晚启动时间而得到PERT 图的关键路径。那么如何求解作业的最早启动时间和最晚启动时间呢？下面给出了求解方法：  
设PERT 图$G=\langle V,E\rangle$的顶点编号$v_{1},v_{2},\dots,v_{n}$，使得边$e=\langle v_{i},v_{j}\rangle\in E$蕴含$i<j$  
令$\pi_{1}=0$，$\pi_{j}=m a x\{\pi_{m}+w(v_{m},v_{j})|1\leq m<j\}$，则$\pi_{i}(1\leq i\leq n)$是作业$e=\langle v_{i},v_{j}\rangle$的最早启动时间。这里$w(v_{m},v_{j})$定义为：  
$w(v_m,v_j)=\begin{cases}\text{边}\langle v_m,v_j\rangle\text{的非负实数权,~~~~~~~~若}\langle v_m,v_j\rangle\in E;\\-\infty,&\text{否则}\end{cases}\text{(8-18)}$  
令$\tau_{n}=\pi_{n}$，$\tau_{k}=m a x\{\tau_{k},\tau_{k}-w(v_{k},v_{m})|k<m\leq n\}$，则$\tau_{i}(1\leq i\leq n)$是作业$e=$$\langle v_{i},v_{j}\rangle$的最晚启动时间。  
由于某顶点的最早启动时间（最晚启动时间）就是所有以该顶点为起点的作业的最早启动时间（最晚启动时间）。因此求解关键路径，可以通过计算每个顶点的最早启动时间和最晚启动时间来确定。  
另外，为了更方便的判断顶点$v_{i}$是否为关键路径上的顶点，在此定义$v_{i}$的缓冲时间$S_{i}=$$\tau_{i}-\pi_{i}$。在关键路径上，各顶点的缓冲时间𝑆均为0，任何关键作业如果耽误了时间𝑡，整个工程就耽误了时间𝑡。下面给出求解关键路径的具体例子。",关键路径上的边所代表的作业称为关键作业
PERT图,定义,最早启动时间,,"生活中有着多种多样的工程，而每一项工程往往都是由多种不同的活动相互组合而成，这些活动中，有的可以并行执行，而有的活动却必须要等到前面的准备活动都做好之后才能开始进行。例如，在一个软件开发项目中，包括以下几个阶段：需求分析，系统设计，模块代码编写，单元测试，软件维护。其中代码编写和单元测试可以同时进行，但是代码编写却一定要在需求分析和系统设计完成之后才行，需求分析和系统设计构成了代码编写的准备工作。既然存在这样的现象，那么在一项很复杂的工程中，如何合理的安排活动的进行，能够使得整个工程完成时间最早呢？其实，这就是关键路径问题。在求解关键路径问题之前，我们有必要先了解下PERT 图的相关概念。  
PERT 图是一个有向连通图$G=\langle V,E\rangle$，且  
（1）每条边表示一个作业（工序），边的非负实数权表示完成该作业所需的时间；  
（2）每个顶点表示以该顶点为起点的作业开始，也表示以该顶点为终点的作业结束；  
（3）作业开始条件：某条有向边$e=\langle v,u\rangle$所代表的作业可以开始 当且仅当 以v为终点的有向边所代表的作业全部完成；  
（4）G没有有向回路，也没有环；  
（5）G中有且仅有一个顶点的入度为0，称该顶点为源点；同时G中有且禁言一个顶点的出度为0，称该顶点为汇点。  
对于给定的PERT 图$G=\langle V,E\rangle$，我们主要关心其关键路径，以及每个作业的最早开始时间和最晚开始时间。关于PERT 图，有如下定义：  
（1）关键路径：G中从源点到汇点最长带权路径路径称为关键路径。关键路径的长度T为完成整个任务（即包括所有作业）所必需的最少时间。  
（2）关键作业：关键路径上的边所代表的作业称为关键作业。  
（3）最早启动时间：对于某个作业${e}=\left<v_{i},-\right>$，源点到该作业起点$v_{i}$的最长路径长度$\pi_{i}$称为该作业的最早启动时间。  
（4）最晚启动时间：设$v_{i}$到汇点${v}_{n}$的最长路径长度为$\pi_{i}^{\prime}$，则该作业可最晚于$\mathsf{\Delta}\mathsf{T}_{i}=\mathsf{T}-$$\uppi_{i}^{\prime}$时间启动而不影响整个任务完成的预期时间T，$\uptau_{i}$称为该作业的最晚启动时间。  
显然，作业${e}=\langle v_{i},-\rangle$是关键作业当且仅当$\pi_{i}=\uptau_{i}$，因为这时e是处于源点到汇点最长带权路径上。故可通过求每个作业的最早启动时间和最晚启动时间而得到PERT 图的关键路径。那么如何求解作业的最早启动时间和最晚启动时间呢？下面给出了求解方法：  
设PERT 图$G=\langle V,E\rangle$的顶点编号$v_{1},v_{2},\dots,v_{n}$，使得边$e=\langle v_{i},v_{j}\rangle\in E$蕴含$i<j$  
令$\pi_{1}=0$，$\pi_{j}=m a x\{\pi_{m}+w(v_{m},v_{j})|1\leq m<j\}$，则$\pi_{i}(1\leq i\leq n)$是作业$e=\langle v_{i},v_{j}\rangle$的最早启动时间。这里$w(v_{m},v_{j})$定义为：  
$w(v_m,v_j)=\begin{cases}\text{边}\langle v_m,v_j\rangle\text{的非负实数权,~~~~~~~~若}\langle v_m,v_j\rangle\in E;\\-\infty,&\text{否则}\end{cases}\text{(8-18)}$  
令$\tau_{n}=\pi_{n}$，$\tau_{k}=m a x\{\tau_{k},\tau_{k}-w(v_{k},v_{m})|k<m\leq n\}$，则$\tau_{i}(1\leq i\leq n)$是作业$e=$$\langle v_{i},v_{j}\rangle$的最晚启动时间。  
由于某顶点的最早启动时间（最晚启动时间）就是所有以该顶点为起点的作业的最早启动时间（最晚启动时间）。因此求解关键路径，可以通过计算每个顶点的最早启动时间和最晚启动时间来确定。  
另外，为了更方便的判断顶点$v_{i}$是否为关键路径上的顶点，在此定义$v_{i}$的缓冲时间$S_{i}=$$\tau_{i}-\pi_{i}$。在关键路径上，各顶点的缓冲时间𝑆均为0，任何关键作业如果耽误了时间𝑡，整个工程就耽误了时间𝑡。下面给出求解关键路径的具体例子。",PERT图中某个作业的最早启动时间是源点到该作业起点的最长路径长度
PERT图,定义,最晚启动时间,,"生活中有着多种多样的工程，而每一项工程往往都是由多种不同的活动相互组合而成，这些活动中，有的可以并行执行，而有的活动却必须要等到前面的准备活动都做好之后才能开始进行。例如，在一个软件开发项目中，包括以下几个阶段：需求分析，系统设计，模块代码编写，单元测试，软件维护。其中代码编写和单元测试可以同时进行，但是代码编写却一定要在需求分析和系统设计完成之后才行，需求分析和系统设计构成了代码编写的准备工作。既然存在这样的现象，那么在一项很复杂的工程中，如何合理的安排活动的进行，能够使得整个工程完成时间最早呢？其实，这就是关键路径问题。在求解关键路径问题之前，我们有必要先了解下PERT 图的相关概念。  
PERT 图是一个有向连通图$G=\langle V,E\rangle$，且  
（1）每条边表示一个作业（工序），边的非负实数权表示完成该作业所需的时间；  
（2）每个顶点表示以该顶点为起点的作业开始，也表示以该顶点为终点的作业结束；  
（3）作业开始条件：某条有向边$e=\langle v,u\rangle$所代表的作业可以开始 当且仅当 以v为终点的有向边所代表的作业全部完成；  
（4）G没有有向回路，也没有环；  
（5）G中有且仅有一个顶点的入度为0，称该顶点为源点；同时G中有且禁言一个顶点的出度为0，称该顶点为汇点。  
对于给定的PERT 图$G=\langle V,E\rangle$，我们主要关心其关键路径，以及每个作业的最早开始时间和最晚开始时间。关于PERT 图，有如下定义：  
（1）关键路径：G中从源点到汇点最长带权路径路径称为关键路径。关键路径的长度T为完成整个任务（即包括所有作业）所必需的最少时间。  
（2）关键作业：关键路径上的边所代表的作业称为关键作业。  
（3）最早启动时间：对于某个作业${e}=\left<v_{i},-\right>$，源点到该作业起点$v_{i}$的最长路径长度$\pi_{i}$称为该作业的最早启动时间。  
（4）最晚启动时间：设$v_{i}$到汇点${v}_{n}$的最长路径长度为$\pi_{i}^{\prime}$，则该作业可最晚于$\mathsf{\Delta}\mathsf{T}_{i}=\mathsf{T}-$$\uppi_{i}^{\prime}$时间启动而不影响整个任务完成的预期时间T，$\uptau_{i}$称为该作业的最晚启动时间。  
显然，作业${e}=\langle v_{i},-\rangle$是关键作业当且仅当$\pi_{i}=\uptau_{i}$，因为这时e是处于源点到汇点最长带权路径上。故可通过求每个作业的最早启动时间和最晚启动时间而得到PERT 图的关键路径。那么如何求解作业的最早启动时间和最晚启动时间呢？下面给出了求解方法：  
设PERT 图$G=\langle V,E\rangle$的顶点编号$v_{1},v_{2},\dots,v_{n}$，使得边$e=\langle v_{i},v_{j}\rangle\in E$蕴含$i<j$  
令$\pi_{1}=0$，$\pi_{j}=m a x\{\pi_{m}+w(v_{m},v_{j})|1\leq m<j\}$，则$\pi_{i}(1\leq i\leq n)$是作业$e=\langle v_{i},v_{j}\rangle$的最早启动时间。这里$w(v_{m},v_{j})$定义为：  
$w(v_m,v_j)=\begin{cases}\text{边}\langle v_m,v_j\rangle\text{的非负实数权,~~~~~~~~若}\langle v_m,v_j\rangle\in E;\\-\infty,&\text{否则}\end{cases}\text{(8-18)}$  
令$\tau_{n}=\pi_{n}$，$\tau_{k}=m a x\{\tau_{k},\tau_{k}-w(v_{k},v_{m})|k<m\leq n\}$，则$\tau_{i}(1\leq i\leq n)$是作业$e=$$\langle v_{i},v_{j}\rangle$的最晚启动时间。  
由于某顶点的最早启动时间（最晚启动时间）就是所有以该顶点为起点的作业的最早启动时间（最晚启动时间）。因此求解关键路径，可以通过计算每个顶点的最早启动时间和最晚启动时间来确定。  
另外，为了更方便的判断顶点$v_{i}$是否为关键路径上的顶点，在此定义$v_{i}$的缓冲时间$S_{i}=$$\tau_{i}-\pi_{i}$。在关键路径上，各顶点的缓冲时间𝑆均为0，任何关键作业如果耽误了时间𝑡，整个工程就耽误了时间𝑡。下面给出求解关键路径的具体例子。",PERT图中某个作业的最晚启动时间是该作业可最晚启动而不影响整个任务完成的时间
最早启动时间,关联,最晚启动时间,,"生活中有着多种多样的工程，而每一项工程往往都是由多种不同的活动相互组合而成，这些活动中，有的可以并行执行，而有的活动却必须要等到前面的准备活动都做好之后才能开始进行。例如，在一个软件开发项目中，包括以下几个阶段：需求分析，系统设计，模块代码编写，单元测试，软件维护。其中代码编写和单元测试可以同时进行，但是代码编写却一定要在需求分析和系统设计完成之后才行，需求分析和系统设计构成了代码编写的准备工作。既然存在这样的现象，那么在一项很复杂的工程中，如何合理的安排活动的进行，能够使得整个工程完成时间最早呢？其实，这就是关键路径问题。在求解关键路径问题之前，我们有必要先了解下PERT 图的相关概念。  
PERT 图是一个有向连通图$G=\langle V,E\rangle$，且  
（1）每条边表示一个作业（工序），边的非负实数权表示完成该作业所需的时间；  
（2）每个顶点表示以该顶点为起点的作业开始，也表示以该顶点为终点的作业结束；  
（3）作业开始条件：某条有向边$e=\langle v,u\rangle$所代表的作业可以开始 当且仅当 以v为终点的有向边所代表的作业全部完成；  
（4）G没有有向回路，也没有环；  
（5）G中有且仅有一个顶点的入度为0，称该顶点为源点；同时G中有且禁言一个顶点的出度为0，称该顶点为汇点。  
对于给定的PERT 图$G=\langle V,E\rangle$，我们主要关心其关键路径，以及每个作业的最早开始时间和最晚开始时间。关于PERT 图，有如下定义：  
（1）关键路径：G中从源点到汇点最长带权路径路径称为关键路径。关键路径的长度T为完成整个任务（即包括所有作业）所必需的最少时间。  
（2）关键作业：关键路径上的边所代表的作业称为关键作业。  
（3）最早启动时间：对于某个作业${e}=\left<v_{i},-\right>$，源点到该作业起点$v_{i}$的最长路径长度$\pi_{i}$称为该作业的最早启动时间。  
（4）最晚启动时间：设$v_{i}$到汇点${v}_{n}$的最长路径长度为$\pi_{i}^{\prime}$，则该作业可最晚于$\mathsf{\Delta}\mathsf{T}_{i}=\mathsf{T}-$$\uppi_{i}^{\prime}$时间启动而不影响整个任务完成的预期时间T，$\uptau_{i}$称为该作业的最晚启动时间。  
显然，作业${e}=\langle v_{i},-\rangle$是关键作业当且仅当$\pi_{i}=\uptau_{i}$，因为这时e是处于源点到汇点最长带权路径上。故可通过求每个作业的最早启动时间和最晚启动时间而得到PERT 图的关键路径。那么如何求解作业的最早启动时间和最晚启动时间呢？下面给出了求解方法：  
设PERT 图$G=\langle V,E\rangle$的顶点编号$v_{1},v_{2},\dots,v_{n}$，使得边$e=\langle v_{i},v_{j}\rangle\in E$蕴含$i<j$  
令$\pi_{1}=0$，$\pi_{j}=m a x\{\pi_{m}+w(v_{m},v_{j})|1\leq m<j\}$，则$\pi_{i}(1\leq i\leq n)$是作业$e=\langle v_{i},v_{j}\rangle$的最早启动时间。这里$w(v_{m},v_{j})$定义为：  
$w(v_m,v_j)=\begin{cases}\text{边}\langle v_m,v_j\rangle\text{的非负实数权,~~~~~~~~若}\langle v_m,v_j\rangle\in E;\\-\infty,&\text{否则}\end{cases}\text{(8-18)}$  
令$\tau_{n}=\pi_{n}$，$\tau_{k}=m a x\{\tau_{k},\tau_{k}-w(v_{k},v_{m})|k<m\leq n\}$，则$\tau_{i}(1\leq i\leq n)$是作业$e=$$\langle v_{i},v_{j}\rangle$的最晚启动时间。  
由于某顶点的最早启动时间（最晚启动时间）就是所有以该顶点为起点的作业的最早启动时间（最晚启动时间）。因此求解关键路径，可以通过计算每个顶点的最早启动时间和最晚启动时间来确定。  
另外，为了更方便的判断顶点$v_{i}$是否为关键路径上的顶点，在此定义$v_{i}$的缓冲时间$S_{i}=$$\tau_{i}-\pi_{i}$。在关键路径上，各顶点的缓冲时间𝑆均为0，任何关键作业如果耽误了时间𝑡，整个工程就耽误了时间𝑡。下面给出求解关键路径的具体例子。",通过比较最早启动时间和最晚启动时间可以确定关键作业
关键作业,关联,缓冲时间,,"生活中有着多种多样的工程，而每一项工程往往都是由多种不同的活动相互组合而成，这些活动中，有的可以并行执行，而有的活动却必须要等到前面的准备活动都做好之后才能开始进行。例如，在一个软件开发项目中，包括以下几个阶段：需求分析，系统设计，模块代码编写，单元测试，软件维护。其中代码编写和单元测试可以同时进行，但是代码编写却一定要在需求分析和系统设计完成之后才行，需求分析和系统设计构成了代码编写的准备工作。既然存在这样的现象，那么在一项很复杂的工程中，如何合理的安排活动的进行，能够使得整个工程完成时间最早呢？其实，这就是关键路径问题。在求解关键路径问题之前，我们有必要先了解下PERT 图的相关概念。  
PERT 图是一个有向连通图$G=\langle V,E\rangle$，且  
（1）每条边表示一个作业（工序），边的非负实数权表示完成该作业所需的时间；  
（2）每个顶点表示以该顶点为起点的作业开始，也表示以该顶点为终点的作业结束；  
（3）作业开始条件：某条有向边$e=\langle v,u\rangle$所代表的作业可以开始 当且仅当 以v为终点的有向边所代表的作业全部完成；  
（4）G没有有向回路，也没有环；  
（5）G中有且仅有一个顶点的入度为0，称该顶点为源点；同时G中有且禁言一个顶点的出度为0，称该顶点为汇点。  
对于给定的PERT 图$G=\langle V,E\rangle$，我们主要关心其关键路径，以及每个作业的最早开始时间和最晚开始时间。关于PERT 图，有如下定义：  
（1）关键路径：G中从源点到汇点最长带权路径路径称为关键路径。关键路径的长度T为完成整个任务（即包括所有作业）所必需的最少时间。  
（2）关键作业：关键路径上的边所代表的作业称为关键作业。  
（3）最早启动时间：对于某个作业${e}=\left<v_{i},-\right>$，源点到该作业起点$v_{i}$的最长路径长度$\pi_{i}$称为该作业的最早启动时间。  
（4）最晚启动时间：设$v_{i}$到汇点${v}_{n}$的最长路径长度为$\pi_{i}^{\prime}$，则该作业可最晚于$\mathsf{\Delta}\mathsf{T}_{i}=\mathsf{T}-$$\uppi_{i}^{\prime}$时间启动而不影响整个任务完成的预期时间T，$\uptau_{i}$称为该作业的最晚启动时间。  
显然，作业${e}=\langle v_{i},-\rangle$是关键作业当且仅当$\pi_{i}=\uptau_{i}$，因为这时e是处于源点到汇点最长带权路径上。故可通过求每个作业的最早启动时间和最晚启动时间而得到PERT 图的关键路径。那么如何求解作业的最早启动时间和最晚启动时间呢？下面给出了求解方法：  
设PERT 图$G=\langle V,E\rangle$的顶点编号$v_{1},v_{2},\dots,v_{n}$，使得边$e=\langle v_{i},v_{j}\rangle\in E$蕴含$i<j$  
令$\pi_{1}=0$，$\pi_{j}=m a x\{\pi_{m}+w(v_{m},v_{j})|1\leq m<j\}$，则$\pi_{i}(1\leq i\leq n)$是作业$e=\langle v_{i},v_{j}\rangle$的最早启动时间。这里$w(v_{m},v_{j})$定义为：  
$w(v_m,v_j)=\begin{cases}\text{边}\langle v_m,v_j\rangle\text{的非负实数权,~~~~~~~~若}\langle v_m,v_j\rangle\in E;\\-\infty,&\text{否则}\end{cases}\text{(8-18)}$  
令$\tau_{n}=\pi_{n}$，$\tau_{k}=m a x\{\tau_{k},\tau_{k}-w(v_{k},v_{m})|k<m\leq n\}$，则$\tau_{i}(1\leq i\leq n)$是作业$e=$$\langle v_{i},v_{j}\rangle$的最晚启动时间。  
由于某顶点的最早启动时间（最晚启动时间）就是所有以该顶点为起点的作业的最早启动时间（最晚启动时间）。因此求解关键路径，可以通过计算每个顶点的最早启动时间和最晚启动时间来确定。  
另外，为了更方便的判断顶点$v_{i}$是否为关键路径上的顶点，在此定义$v_{i}$的缓冲时间$S_{i}=$$\tau_{i}-\pi_{i}$。在关键路径上，各顶点的缓冲时间𝑆均为0，任何关键作业如果耽误了时间𝑡，整个工程就耽误了时间𝑡。下面给出求解关键路径的具体例子。",关键作业的缓冲时间为0，任何关键作业的延误都会导致整个工程的延误
机器学习,包含,浅层学习,,"1959 年，美国塞缪尔教授设计了一个具有学习能力的下棋程序。它可在不断对弈中改善自己的棋艺。4 年后，该程序战胜了设计者本人。又过3 年，该程序战胜了美国常胜冠军。由此可以看出机器学习的能力，特别是当下谷歌设计的AlphaGo 程序与围棋大师李世石的围棋大战，更是体现了机器学习的威力。所谓机器学习，就是数学模型或求解算法中具有似于人类的学习机制，能够从实际问题中采集适当样本数据，根据样本数据自动算出参数值，并随着样本数据的变化自动调整参数取值，使得数学模型和求解算法具有良好的普适性和自适应性。按机器学习的模型结构层次来分，机器学习经历了两次浪潮，分别是浅层学习和深度学习。近年来，机器学习的概念异常火爆，各种机器学习算法层出不穷。本小节简要介绍图模型在浅层学习和深度学习中的与应用。  
![图8-73 BP 网络结构](images/3e28bfeab67aaebdd2a54ed46ef1bb594380bb5384ccdde94e5e1d5ae51f9049.jpg)  
![图8-74 支持向量机结构](images/0d16cdb37dc68fb29e3b36be467fd837d3d52e2ccd7acbba9de1c8c373e6974d.jpg)  
无论是浅层学习还是深度学习的模型结构都是基于图模型。  图8-73 所示的图模型是20 世纪80 年代末期提出BP 神经网络模型，图8-74 所示的图模型是20 世纪90 年代中期提出支持向量机模型。 这些都是机器学习中的经典图模型用于浅层的机器学习。 正是这些图模型的建立给机器学习带来了希望，掀起了基于统计模型机器学习热潮。人们使用这类权图模型从大量训练样本中学习统计规律，然后根据学到的规律对未知事件进行预测。  
![图8-75 简单函数对复杂函数的逼近 ](images/fbe962cff1ffa6a7bb0339da768141046705e07e74feba559a3752dfe9c241b2.jpg)  
![图8-76 多层模型表示复杂函数  ](images/272fe3358ea6997e106f1355c74465d9d8b3888427cf64765b441f271abcfeac.jpg)  
然而，进入21 世纪，浅层学习研究的发展遇到瓶颈。从而，人们创立了深度学习的相关概念和理论，并借助分布式云计算的大数据平台，在机器学习领域取得了突破性进展。深度学习通过一种深层非线性网络结构，组合低层特征形成更加抽象的高层表示属性类别或特征，实现由简单函数向复杂函数的有效逼近，以发现数据的分布式特征表示。其具有强大的从少数样本中集中学习数据集本质特征的能力。图8-75 表示一个通过简单函数逼近复杂函数的实例。  
简单地说，深度学习就是对拥有深层结构的模型进行训练。所谓深层结构，是相对于前述的浅层结构而言的，两者的差异主要在于拥有的非线性运算单元的层数不同。深层结构是指非线性转换单元的层数大于或等于两层的模型，而使用多层模型的优势即可以使用较少的参数表示复杂的函数。使用多层模型表示复杂函数的例子如图8-76 所示。  
![图8-77 含多隐含层的深度学习模型图  ](images/a696f4639cd9bb8eadcb3b542d30322c2127fff383c01a8ce40760e85d44b787.jpg)  
![图8-78 自动编码器(AE)结构示意图  ](images/d437ba8ccbf4e13b83ff799a9ddec1778e03cc7629e09224d02fe81a54b359de.jpg)  
深度学习在模型中构建多层隐含层，并通过大量样本训练模型参数，获得更有用的特征，从而有效提升分类或预测的准确性。相比较传统的浅层结构，深度学习更强调了模型结构的深度，通常有5 至6 层隐含层，有的模型结构甚至包含10 层以上隐含层。此外，深度学习明确突出了特征学习的重要性。深度学习实现多层堆叠，每一层的输出作为下一层的输入，高层的特征是低层特征的组合，从低层到高层的特征表示越来越抽象，越来越能表现语义或者意图。而抽象层面越高，存在的可能猜测就越少，就越利于分类。换句话说，深度学习通过逐层特征变换，将样本在原始特征空间表示逐层变换到新的特征空间，从而使分类或预测的效果更加准确。图8-77 表示一个含多隐含层的深度学习模型。事实上，由如图8-78 所示自动编码器组合或其简单变形的模型也可看成是深度结构，例如堆叠自动编码器，稀疏自动编码器等。  
深度学习是机器学习发展的产物。与传统的机器学习方法相比，深度学习优势明显，目前在图像识别、语音识别、自然语言理解等领域得到广泛的应用。",机器学习包含浅层学习作为其模型结构层次之一
机器学习,包含,深度学习,,"1959 年，美国塞缪尔教授设计了一个具有学习能力的下棋程序。它可在不断对弈中改善自己的棋艺。4 年后，该程序战胜了设计者本人。又过3 年，该程序战胜了美国常胜冠军。由此可以看出机器学习的能力，特别是当下谷歌设计的AlphaGo 程序与围棋大师李世石的围棋大战，更是体现了机器学习的威力。所谓机器学习，就是数学模型或求解算法中具有似于人类的学习机制，能够从实际问题中采集适当样本数据，根据样本数据自动算出参数值，并随着样本数据的变化自动调整参数取值，使得数学模型和求解算法具有良好的普适性和自适应性。按机器学习的模型结构层次来分，机器学习经历了两次浪潮，分别是浅层学习和深度学习。近年来，机器学习的概念异常火爆，各种机器学习算法层出不穷。本小节简要介绍图模型在浅层学习和深度学习中的与应用。  
![图8-73 BP 网络结构](images/3e28bfeab67aaebdd2a54ed46ef1bb594380bb5384ccdde94e5e1d5ae51f9049.jpg)  
![图8-74 支持向量机结构](images/0d16cdb37dc68fb29e3b36be467fd837d3d52e2ccd7acbba9de1c8c373e6974d.jpg)  
无论是浅层学习还是深度学习的模型结构都是基于图模型。  图8-73 所示的图模型是20 世纪80 年代末期提出BP 神经网络模型，图8-74 所示的图模型是20 世纪90 年代中期提出支持向量机模型。 这些都是机器学习中的经典图模型用于浅层的机器学习。 正是这些图模型的建立给机器学习带来了希望，掀起了基于统计模型机器学习热潮。人们使用这类权图模型从大量训练样本中学习统计规律，然后根据学到的规律对未知事件进行预测。  
![图8-75 简单函数对复杂函数的逼近 ](images/fbe962cff1ffa6a7bb0339da768141046705e07e74feba559a3752dfe9c241b2.jpg)  
![图8-76 多层模型表示复杂函数  ](images/272fe3358ea6997e106f1355c74465d9d8b3888427cf64765b441f271abcfeac.jpg)  
然而，进入21 世纪，浅层学习研究的发展遇到瓶颈。从而，人们创立了深度学习的相关概念和理论，并借助分布式云计算的大数据平台，在机器学习领域取得了突破性进展。深度学习通过一种深层非线性网络结构，组合低层特征形成更加抽象的高层表示属性类别或特征，实现由简单函数向复杂函数的有效逼近，以发现数据的分布式特征表示。其具有强大的从少数样本中集中学习数据集本质特征的能力。图8-75 表示一个通过简单函数逼近复杂函数的实例。  
简单地说，深度学习就是对拥有深层结构的模型进行训练。所谓深层结构，是相对于前述的浅层结构而言的，两者的差异主要在于拥有的非线性运算单元的层数不同。深层结构是指非线性转换单元的层数大于或等于两层的模型，而使用多层模型的优势即可以使用较少的参数表示复杂的函数。使用多层模型表示复杂函数的例子如图8-76 所示。  
![图8-77 含多隐含层的深度学习模型图  ](images/a696f4639cd9bb8eadcb3b542d30322c2127fff383c01a8ce40760e85d44b787.jpg)  
![图8-78 自动编码器(AE)结构示意图  ](images/d437ba8ccbf4e13b83ff799a9ddec1778e03cc7629e09224d02fe81a54b359de.jpg)  
深度学习在模型中构建多层隐含层，并通过大量样本训练模型参数，获得更有用的特征，从而有效提升分类或预测的准确性。相比较传统的浅层结构，深度学习更强调了模型结构的深度，通常有5 至6 层隐含层，有的模型结构甚至包含10 层以上隐含层。此外，深度学习明确突出了特征学习的重要性。深度学习实现多层堆叠，每一层的输出作为下一层的输入，高层的特征是低层特征的组合，从低层到高层的特征表示越来越抽象，越来越能表现语义或者意图。而抽象层面越高，存在的可能猜测就越少，就越利于分类。换句话说，深度学习通过逐层特征变换，将样本在原始特征空间表示逐层变换到新的特征空间，从而使分类或预测的效果更加准确。图8-77 表示一个含多隐含层的深度学习模型。事实上，由如图8-78 所示自动编码器组合或其简单变形的模型也可看成是深度结构，例如堆叠自动编码器，稀疏自动编码器等。  
深度学习是机器学习发展的产物。与传统的机器学习方法相比，深度学习优势明显，目前在图像识别、语音识别、自然语言理解等领域得到广泛的应用。",机器学习包含深度学习作为其模型结构层次之一
浅层学习,基于,图模型,,"1959 年，美国塞缪尔教授设计了一个具有学习能力的下棋程序。它可在不断对弈中改善自己的棋艺。4 年后，该程序战胜了设计者本人。又过3 年，该程序战胜了美国常胜冠军。由此可以看出机器学习的能力，特别是当下谷歌设计的AlphaGo 程序与围棋大师李世石的围棋大战，更是体现了机器学习的威力。所谓机器学习，就是数学模型或求解算法中具有似于人类的学习机制，能够从实际问题中采集适当样本数据，根据样本数据自动算出参数值，并随着样本数据的变化自动调整参数取值，使得数学模型和求解算法具有良好的普适性和自适应性。按机器学习的模型结构层次来分，机器学习经历了两次浪潮，分别是浅层学习和深度学习。近年来，机器学习的概念异常火爆，各种机器学习算法层出不穷。本小节简要介绍图模型在浅层学习和深度学习中的与应用。  
![图8-73 BP 网络结构](images/3e28bfeab67aaebdd2a54ed46ef1bb594380bb5384ccdde94e5e1d5ae51f9049.jpg)  
![图8-74 支持向量机结构](images/0d16cdb37dc68fb29e3b36be467fd837d3d52e2ccd7acbba9de1c8c373e6974d.jpg)  
无论是浅层学习还是深度学习的模型结构都是基于图模型。  图8-73 所示的图模型是20 世纪80 年代末期提出BP 神经网络模型，图8-74 所示的图模型是20 世纪90 年代中期提出支持向量机模型。 这些都是机器学习中的经典图模型用于浅层的机器学习。 正是这些图模型的建立给机器学习带来了希望，掀起了基于统计模型机器学习热潮。人们使用这类权图模型从大量训练样本中学习统计规律，然后根据学到的规律对未知事件进行预测。  
![图8-75 简单函数对复杂函数的逼近 ](images/fbe962cff1ffa6a7bb0339da768141046705e07e74feba559a3752dfe9c241b2.jpg)  
![图8-76 多层模型表示复杂函数  ](images/272fe3358ea6997e106f1355c74465d9d8b3888427cf64765b441f271abcfeac.jpg)  
然而，进入21 世纪，浅层学习研究的发展遇到瓶颈。从而，人们创立了深度学习的相关概念和理论，并借助分布式云计算的大数据平台，在机器学习领域取得了突破性进展。深度学习通过一种深层非线性网络结构，组合低层特征形成更加抽象的高层表示属性类别或特征，实现由简单函数向复杂函数的有效逼近，以发现数据的分布式特征表示。其具有强大的从少数样本中集中学习数据集本质特征的能力。图8-75 表示一个通过简单函数逼近复杂函数的实例。  
简单地说，深度学习就是对拥有深层结构的模型进行训练。所谓深层结构，是相对于前述的浅层结构而言的，两者的差异主要在于拥有的非线性运算单元的层数不同。深层结构是指非线性转换单元的层数大于或等于两层的模型，而使用多层模型的优势即可以使用较少的参数表示复杂的函数。使用多层模型表示复杂函数的例子如图8-76 所示。  
![图8-77 含多隐含层的深度学习模型图  ](images/a696f4639cd9bb8eadcb3b542d30322c2127fff383c01a8ce40760e85d44b787.jpg)  
![图8-78 自动编码器(AE)结构示意图  ](images/d437ba8ccbf4e13b83ff799a9ddec1778e03cc7629e09224d02fe81a54b359de.jpg)  
深度学习在模型中构建多层隐含层，并通过大量样本训练模型参数，获得更有用的特征，从而有效提升分类或预测的准确性。相比较传统的浅层结构，深度学习更强调了模型结构的深度，通常有5 至6 层隐含层，有的模型结构甚至包含10 层以上隐含层。此外，深度学习明确突出了特征学习的重要性。深度学习实现多层堆叠，每一层的输出作为下一层的输入，高层的特征是低层特征的组合，从低层到高层的特征表示越来越抽象，越来越能表现语义或者意图。而抽象层面越高，存在的可能猜测就越少，就越利于分类。换句话说，深度学习通过逐层特征变换，将样本在原始特征空间表示逐层变换到新的特征空间，从而使分类或预测的效果更加准确。图8-77 表示一个含多隐含层的深度学习模型。事实上，由如图8-78 所示自动编码器组合或其简单变形的模型也可看成是深度结构，例如堆叠自动编码器，稀疏自动编码器等。  
深度学习是机器学习发展的产物。与传统的机器学习方法相比，深度学习优势明显，目前在图像识别、语音识别、自然语言理解等领域得到广泛的应用。",浅层学习的模型结构基于图模型
深度学习,基于,图模型,,"1959 年，美国塞缪尔教授设计了一个具有学习能力的下棋程序。它可在不断对弈中改善自己的棋艺。4 年后，该程序战胜了设计者本人。又过3 年，该程序战胜了美国常胜冠军。由此可以看出机器学习的能力，特别是当下谷歌设计的AlphaGo 程序与围棋大师李世石的围棋大战，更是体现了机器学习的威力。所谓机器学习，就是数学模型或求解算法中具有似于人类的学习机制，能够从实际问题中采集适当样本数据，根据样本数据自动算出参数值，并随着样本数据的变化自动调整参数取值，使得数学模型和求解算法具有良好的普适性和自适应性。按机器学习的模型结构层次来分，机器学习经历了两次浪潮，分别是浅层学习和深度学习。近年来，机器学习的概念异常火爆，各种机器学习算法层出不穷。本小节简要介绍图模型在浅层学习和深度学习中的与应用。  
![图8-73 BP 网络结构](images/3e28bfeab67aaebdd2a54ed46ef1bb594380bb5384ccdde94e5e1d5ae51f9049.jpg)  
![图8-74 支持向量机结构](images/0d16cdb37dc68fb29e3b36be467fd837d3d52e2ccd7acbba9de1c8c373e6974d.jpg)  
无论是浅层学习还是深度学习的模型结构都是基于图模型。  图8-73 所示的图模型是20 世纪80 年代末期提出BP 神经网络模型，图8-74 所示的图模型是20 世纪90 年代中期提出支持向量机模型。 这些都是机器学习中的经典图模型用于浅层的机器学习。 正是这些图模型的建立给机器学习带来了希望，掀起了基于统计模型机器学习热潮。人们使用这类权图模型从大量训练样本中学习统计规律，然后根据学到的规律对未知事件进行预测。  
![图8-75 简单函数对复杂函数的逼近 ](images/fbe962cff1ffa6a7bb0339da768141046705e07e74feba559a3752dfe9c241b2.jpg)  
![图8-76 多层模型表示复杂函数  ](images/272fe3358ea6997e106f1355c74465d9d8b3888427cf64765b441f271abcfeac.jpg)  
然而，进入21 世纪，浅层学习研究的发展遇到瓶颈。从而，人们创立了深度学习的相关概念和理论，并借助分布式云计算的大数据平台，在机器学习领域取得了突破性进展。深度学习通过一种深层非线性网络结构，组合低层特征形成更加抽象的高层表示属性类别或特征，实现由简单函数向复杂函数的有效逼近，以发现数据的分布式特征表示。其具有强大的从少数样本中集中学习数据集本质特征的能力。图8-75 表示一个通过简单函数逼近复杂函数的实例。  
简单地说，深度学习就是对拥有深层结构的模型进行训练。所谓深层结构，是相对于前述的浅层结构而言的，两者的差异主要在于拥有的非线性运算单元的层数不同。深层结构是指非线性转换单元的层数大于或等于两层的模型，而使用多层模型的优势即可以使用较少的参数表示复杂的函数。使用多层模型表示复杂函数的例子如图8-76 所示。  
![图8-77 含多隐含层的深度学习模型图  ](images/a696f4639cd9bb8eadcb3b542d30322c2127fff383c01a8ce40760e85d44b787.jpg)  
![图8-78 自动编码器(AE)结构示意图  ](images/d437ba8ccbf4e13b83ff799a9ddec1778e03cc7629e09224d02fe81a54b359de.jpg)  
深度学习在模型中构建多层隐含层，并通过大量样本训练模型参数，获得更有用的特征，从而有效提升分类或预测的准确性。相比较传统的浅层结构，深度学习更强调了模型结构的深度，通常有5 至6 层隐含层，有的模型结构甚至包含10 层以上隐含层。此外，深度学习明确突出了特征学习的重要性。深度学习实现多层堆叠，每一层的输出作为下一层的输入，高层的特征是低层特征的组合，从低层到高层的特征表示越来越抽象，越来越能表现语义或者意图。而抽象层面越高，存在的可能猜测就越少，就越利于分类。换句话说，深度学习通过逐层特征变换，将样本在原始特征空间表示逐层变换到新的特征空间，从而使分类或预测的效果更加准确。图8-77 表示一个含多隐含层的深度学习模型。事实上，由如图8-78 所示自动编码器组合或其简单变形的模型也可看成是深度结构，例如堆叠自动编码器，稀疏自动编码器等。  
深度学习是机器学习发展的产物。与传统的机器学习方法相比，深度学习优势明显，目前在图像识别、语音识别、自然语言理解等领域得到广泛的应用。",深度学习的模型结构基于图模型
图模型,包含,BP神经网络模型,,"1959 年，美国塞缪尔教授设计了一个具有学习能力的下棋程序。它可在不断对弈中改善自己的棋艺。4 年后，该程序战胜了设计者本人。又过3 年，该程序战胜了美国常胜冠军。由此可以看出机器学习的能力，特别是当下谷歌设计的AlphaGo 程序与围棋大师李世石的围棋大战，更是体现了机器学习的威力。所谓机器学习，就是数学模型或求解算法中具有似于人类的学习机制，能够从实际问题中采集适当样本数据，根据样本数据自动算出参数值，并随着样本数据的变化自动调整参数取值，使得数学模型和求解算法具有良好的普适性和自适应性。按机器学习的模型结构层次来分，机器学习经历了两次浪潮，分别是浅层学习和深度学习。近年来，机器学习的概念异常火爆，各种机器学习算法层出不穷。本小节简要介绍图模型在浅层学习和深度学习中的与应用。  
![图8-73 BP 网络结构](images/3e28bfeab67aaebdd2a54ed46ef1bb594380bb5384ccdde94e5e1d5ae51f9049.jpg)  
![图8-74 支持向量机结构](images/0d16cdb37dc68fb29e3b36be467fd837d3d52e2ccd7acbba9de1c8c373e6974d.jpg)  
无论是浅层学习还是深度学习的模型结构都是基于图模型。  图8-73 所示的图模型是20 世纪80 年代末期提出BP 神经网络模型，图8-74 所示的图模型是20 世纪90 年代中期提出支持向量机模型。 这些都是机器学习中的经典图模型用于浅层的机器学习。 正是这些图模型的建立给机器学习带来了希望，掀起了基于统计模型机器学习热潮。人们使用这类权图模型从大量训练样本中学习统计规律，然后根据学到的规律对未知事件进行预测。  
![图8-75 简单函数对复杂函数的逼近 ](images/fbe962cff1ffa6a7bb0339da768141046705e07e74feba559a3752dfe9c241b2.jpg)  
![图8-76 多层模型表示复杂函数  ](images/272fe3358ea6997e106f1355c74465d9d8b3888427cf64765b441f271abcfeac.jpg)  
然而，进入21 世纪，浅层学习研究的发展遇到瓶颈。从而，人们创立了深度学习的相关概念和理论，并借助分布式云计算的大数据平台，在机器学习领域取得了突破性进展。深度学习通过一种深层非线性网络结构，组合低层特征形成更加抽象的高层表示属性类别或特征，实现由简单函数向复杂函数的有效逼近，以发现数据的分布式特征表示。其具有强大的从少数样本中集中学习数据集本质特征的能力。图8-75 表示一个通过简单函数逼近复杂函数的实例。  
简单地说，深度学习就是对拥有深层结构的模型进行训练。所谓深层结构，是相对于前述的浅层结构而言的，两者的差异主要在于拥有的非线性运算单元的层数不同。深层结构是指非线性转换单元的层数大于或等于两层的模型，而使用多层模型的优势即可以使用较少的参数表示复杂的函数。使用多层模型表示复杂函数的例子如图8-76 所示。  
![图8-77 含多隐含层的深度学习模型图  ](images/a696f4639cd9bb8eadcb3b542d30322c2127fff383c01a8ce40760e85d44b787.jpg)  
![图8-78 自动编码器(AE)结构示意图  ](images/d437ba8ccbf4e13b83ff799a9ddec1778e03cc7629e09224d02fe81a54b359de.jpg)  
深度学习在模型中构建多层隐含层，并通过大量样本训练模型参数，获得更有用的特征，从而有效提升分类或预测的准确性。相比较传统的浅层结构，深度学习更强调了模型结构的深度，通常有5 至6 层隐含层，有的模型结构甚至包含10 层以上隐含层。此外，深度学习明确突出了特征学习的重要性。深度学习实现多层堆叠，每一层的输出作为下一层的输入，高层的特征是低层特征的组合，从低层到高层的特征表示越来越抽象，越来越能表现语义或者意图。而抽象层面越高，存在的可能猜测就越少，就越利于分类。换句话说，深度学习通过逐层特征变换，将样本在原始特征空间表示逐层变换到新的特征空间，从而使分类或预测的效果更加准确。图8-77 表示一个含多隐含层的深度学习模型。事实上，由如图8-78 所示自动编码器组合或其简单变形的模型也可看成是深度结构，例如堆叠自动编码器，稀疏自动编码器等。  
深度学习是机器学习发展的产物。与传统的机器学习方法相比，深度学习优势明显，目前在图像识别、语音识别、自然语言理解等领域得到广泛的应用。",图模型包含BP神经网络模型作为其经典模型之一
图模型,包含,支持向量机模型,,"1959 年，美国塞缪尔教授设计了一个具有学习能力的下棋程序。它可在不断对弈中改善自己的棋艺。4 年后，该程序战胜了设计者本人。又过3 年，该程序战胜了美国常胜冠军。由此可以看出机器学习的能力，特别是当下谷歌设计的AlphaGo 程序与围棋大师李世石的围棋大战，更是体现了机器学习的威力。所谓机器学习，就是数学模型或求解算法中具有似于人类的学习机制，能够从实际问题中采集适当样本数据，根据样本数据自动算出参数值，并随着样本数据的变化自动调整参数取值，使得数学模型和求解算法具有良好的普适性和自适应性。按机器学习的模型结构层次来分，机器学习经历了两次浪潮，分别是浅层学习和深度学习。近年来，机器学习的概念异常火爆，各种机器学习算法层出不穷。本小节简要介绍图模型在浅层学习和深度学习中的与应用。  
![图8-73 BP 网络结构](images/3e28bfeab67aaebdd2a54ed46ef1bb594380bb5384ccdde94e5e1d5ae51f9049.jpg)  
![图8-74 支持向量机结构](images/0d16cdb37dc68fb29e3b36be467fd837d3d52e2ccd7acbba9de1c8c373e6974d.jpg)  
无论是浅层学习还是深度学习的模型结构都是基于图模型。  图8-73 所示的图模型是20 世纪80 年代末期提出BP 神经网络模型，图8-74 所示的图模型是20 世纪90 年代中期提出支持向量机模型。 这些都是机器学习中的经典图模型用于浅层的机器学习。 正是这些图模型的建立给机器学习带来了希望，掀起了基于统计模型机器学习热潮。人们使用这类权图模型从大量训练样本中学习统计规律，然后根据学到的规律对未知事件进行预测。  
![图8-75 简单函数对复杂函数的逼近 ](images/fbe962cff1ffa6a7bb0339da768141046705e07e74feba559a3752dfe9c241b2.jpg)  
![图8-76 多层模型表示复杂函数  ](images/272fe3358ea6997e106f1355c74465d9d8b3888427cf64765b441f271abcfeac.jpg)  
然而，进入21 世纪，浅层学习研究的发展遇到瓶颈。从而，人们创立了深度学习的相关概念和理论，并借助分布式云计算的大数据平台，在机器学习领域取得了突破性进展。深度学习通过一种深层非线性网络结构，组合低层特征形成更加抽象的高层表示属性类别或特征，实现由简单函数向复杂函数的有效逼近，以发现数据的分布式特征表示。其具有强大的从少数样本中集中学习数据集本质特征的能力。图8-75 表示一个通过简单函数逼近复杂函数的实例。  
简单地说，深度学习就是对拥有深层结构的模型进行训练。所谓深层结构，是相对于前述的浅层结构而言的，两者的差异主要在于拥有的非线性运算单元的层数不同。深层结构是指非线性转换单元的层数大于或等于两层的模型，而使用多层模型的优势即可以使用较少的参数表示复杂的函数。使用多层模型表示复杂函数的例子如图8-76 所示。  
![图8-77 含多隐含层的深度学习模型图  ](images/a696f4639cd9bb8eadcb3b542d30322c2127fff383c01a8ce40760e85d44b787.jpg)  
![图8-78 自动编码器(AE)结构示意图  ](images/d437ba8ccbf4e13b83ff799a9ddec1778e03cc7629e09224d02fe81a54b359de.jpg)  
深度学习在模型中构建多层隐含层，并通过大量样本训练模型参数，获得更有用的特征，从而有效提升分类或预测的准确性。相比较传统的浅层结构，深度学习更强调了模型结构的深度，通常有5 至6 层隐含层，有的模型结构甚至包含10 层以上隐含层。此外，深度学习明确突出了特征学习的重要性。深度学习实现多层堆叠，每一层的输出作为下一层的输入，高层的特征是低层特征的组合，从低层到高层的特征表示越来越抽象，越来越能表现语义或者意图。而抽象层面越高，存在的可能猜测就越少，就越利于分类。换句话说，深度学习通过逐层特征变换，将样本在原始特征空间表示逐层变换到新的特征空间，从而使分类或预测的效果更加准确。图8-77 表示一个含多隐含层的深度学习模型。事实上，由如图8-78 所示自动编码器组合或其简单变形的模型也可看成是深度结构，例如堆叠自动编码器，稀疏自动编码器等。  
深度学习是机器学习发展的产物。与传统的机器学习方法相比，深度学习优势明显，目前在图像识别、语音识别、自然语言理解等领域得到广泛的应用。",图模型包含支持向量机模型作为其经典模型之一
浅层学习,使用,BP神经网络模型,,"1959 年，美国塞缪尔教授设计了一个具有学习能力的下棋程序。它可在不断对弈中改善自己的棋艺。4 年后，该程序战胜了设计者本人。又过3 年，该程序战胜了美国常胜冠军。由此可以看出机器学习的能力，特别是当下谷歌设计的AlphaGo 程序与围棋大师李世石的围棋大战，更是体现了机器学习的威力。所谓机器学习，就是数学模型或求解算法中具有似于人类的学习机制，能够从实际问题中采集适当样本数据，根据样本数据自动算出参数值，并随着样本数据的变化自动调整参数取值，使得数学模型和求解算法具有良好的普适性和自适应性。按机器学习的模型结构层次来分，机器学习经历了两次浪潮，分别是浅层学习和深度学习。近年来，机器学习的概念异常火爆，各种机器学习算法层出不穷。本小节简要介绍图模型在浅层学习和深度学习中的与应用。  
![图8-73 BP 网络结构](images/3e28bfeab67aaebdd2a54ed46ef1bb594380bb5384ccdde94e5e1d5ae51f9049.jpg)  
![图8-74 支持向量机结构](images/0d16cdb37dc68fb29e3b36be467fd837d3d52e2ccd7acbba9de1c8c373e6974d.jpg)  
无论是浅层学习还是深度学习的模型结构都是基于图模型。  图8-73 所示的图模型是20 世纪80 年代末期提出BP 神经网络模型，图8-74 所示的图模型是20 世纪90 年代中期提出支持向量机模型。 这些都是机器学习中的经典图模型用于浅层的机器学习。 正是这些图模型的建立给机器学习带来了希望，掀起了基于统计模型机器学习热潮。人们使用这类权图模型从大量训练样本中学习统计规律，然后根据学到的规律对未知事件进行预测。  
![图8-75 简单函数对复杂函数的逼近 ](images/fbe962cff1ffa6a7bb0339da768141046705e07e74feba559a3752dfe9c241b2.jpg)  
![图8-76 多层模型表示复杂函数  ](images/272fe3358ea6997e106f1355c74465d9d8b3888427cf64765b441f271abcfeac.jpg)  
然而，进入21 世纪，浅层学习研究的发展遇到瓶颈。从而，人们创立了深度学习的相关概念和理论，并借助分布式云计算的大数据平台，在机器学习领域取得了突破性进展。深度学习通过一种深层非线性网络结构，组合低层特征形成更加抽象的高层表示属性类别或特征，实现由简单函数向复杂函数的有效逼近，以发现数据的分布式特征表示。其具有强大的从少数样本中集中学习数据集本质特征的能力。图8-75 表示一个通过简单函数逼近复杂函数的实例。  
简单地说，深度学习就是对拥有深层结构的模型进行训练。所谓深层结构，是相对于前述的浅层结构而言的，两者的差异主要在于拥有的非线性运算单元的层数不同。深层结构是指非线性转换单元的层数大于或等于两层的模型，而使用多层模型的优势即可以使用较少的参数表示复杂的函数。使用多层模型表示复杂函数的例子如图8-76 所示。  
![图8-77 含多隐含层的深度学习模型图  ](images/a696f4639cd9bb8eadcb3b542d30322c2127fff383c01a8ce40760e85d44b787.jpg)  
![图8-78 自动编码器(AE)结构示意图  ](images/d437ba8ccbf4e13b83ff799a9ddec1778e03cc7629e09224d02fe81a54b359de.jpg)  
深度学习在模型中构建多层隐含层，并通过大量样本训练模型参数，获得更有用的特征，从而有效提升分类或预测的准确性。相比较传统的浅层结构，深度学习更强调了模型结构的深度，通常有5 至6 层隐含层，有的模型结构甚至包含10 层以上隐含层。此外，深度学习明确突出了特征学习的重要性。深度学习实现多层堆叠，每一层的输出作为下一层的输入，高层的特征是低层特征的组合，从低层到高层的特征表示越来越抽象，越来越能表现语义或者意图。而抽象层面越高，存在的可能猜测就越少，就越利于分类。换句话说，深度学习通过逐层特征变换，将样本在原始特征空间表示逐层变换到新的特征空间，从而使分类或预测的效果更加准确。图8-77 表示一个含多隐含层的深度学习模型。事实上，由如图8-78 所示自动编码器组合或其简单变形的模型也可看成是深度结构，例如堆叠自动编码器，稀疏自动编码器等。  
深度学习是机器学习发展的产物。与传统的机器学习方法相比，深度学习优势明显，目前在图像识别、语音识别、自然语言理解等领域得到广泛的应用。",浅层学习使用BP神经网络模型进行机器学习
浅层学习,使用,支持向量机模型,,"1959 年，美国塞缪尔教授设计了一个具有学习能力的下棋程序。它可在不断对弈中改善自己的棋艺。4 年后，该程序战胜了设计者本人。又过3 年，该程序战胜了美国常胜冠军。由此可以看出机器学习的能力，特别是当下谷歌设计的AlphaGo 程序与围棋大师李世石的围棋大战，更是体现了机器学习的威力。所谓机器学习，就是数学模型或求解算法中具有似于人类的学习机制，能够从实际问题中采集适当样本数据，根据样本数据自动算出参数值，并随着样本数据的变化自动调整参数取值，使得数学模型和求解算法具有良好的普适性和自适应性。按机器学习的模型结构层次来分，机器学习经历了两次浪潮，分别是浅层学习和深度学习。近年来，机器学习的概念异常火爆，各种机器学习算法层出不穷。本小节简要介绍图模型在浅层学习和深度学习中的与应用。  
![图8-73 BP 网络结构](images/3e28bfeab67aaebdd2a54ed46ef1bb594380bb5384ccdde94e5e1d5ae51f9049.jpg)  
![图8-74 支持向量机结构](images/0d16cdb37dc68fb29e3b36be467fd837d3d52e2ccd7acbba9de1c8c373e6974d.jpg)  
无论是浅层学习还是深度学习的模型结构都是基于图模型。  图8-73 所示的图模型是20 世纪80 年代末期提出BP 神经网络模型，图8-74 所示的图模型是20 世纪90 年代中期提出支持向量机模型。 这些都是机器学习中的经典图模型用于浅层的机器学习。 正是这些图模型的建立给机器学习带来了希望，掀起了基于统计模型机器学习热潮。人们使用这类权图模型从大量训练样本中学习统计规律，然后根据学到的规律对未知事件进行预测。  
![图8-75 简单函数对复杂函数的逼近 ](images/fbe962cff1ffa6a7bb0339da768141046705e07e74feba559a3752dfe9c241b2.jpg)  
![图8-76 多层模型表示复杂函数  ](images/272fe3358ea6997e106f1355c74465d9d8b3888427cf64765b441f271abcfeac.jpg)  
然而，进入21 世纪，浅层学习研究的发展遇到瓶颈。从而，人们创立了深度学习的相关概念和理论，并借助分布式云计算的大数据平台，在机器学习领域取得了突破性进展。深度学习通过一种深层非线性网络结构，组合低层特征形成更加抽象的高层表示属性类别或特征，实现由简单函数向复杂函数的有效逼近，以发现数据的分布式特征表示。其具有强大的从少数样本中集中学习数据集本质特征的能力。图8-75 表示一个通过简单函数逼近复杂函数的实例。  
简单地说，深度学习就是对拥有深层结构的模型进行训练。所谓深层结构，是相对于前述的浅层结构而言的，两者的差异主要在于拥有的非线性运算单元的层数不同。深层结构是指非线性转换单元的层数大于或等于两层的模型，而使用多层模型的优势即可以使用较少的参数表示复杂的函数。使用多层模型表示复杂函数的例子如图8-76 所示。  
![图8-77 含多隐含层的深度学习模型图  ](images/a696f4639cd9bb8eadcb3b542d30322c2127fff383c01a8ce40760e85d44b787.jpg)  
![图8-78 自动编码器(AE)结构示意图  ](images/d437ba8ccbf4e13b83ff799a9ddec1778e03cc7629e09224d02fe81a54b359de.jpg)  
深度学习在模型中构建多层隐含层，并通过大量样本训练模型参数，获得更有用的特征，从而有效提升分类或预测的准确性。相比较传统的浅层结构，深度学习更强调了模型结构的深度，通常有5 至6 层隐含层，有的模型结构甚至包含10 层以上隐含层。此外，深度学习明确突出了特征学习的重要性。深度学习实现多层堆叠，每一层的输出作为下一层的输入，高层的特征是低层特征的组合，从低层到高层的特征表示越来越抽象，越来越能表现语义或者意图。而抽象层面越高，存在的可能猜测就越少，就越利于分类。换句话说，深度学习通过逐层特征变换，将样本在原始特征空间表示逐层变换到新的特征空间，从而使分类或预测的效果更加准确。图8-77 表示一个含多隐含层的深度学习模型。事实上，由如图8-78 所示自动编码器组合或其简单变形的模型也可看成是深度结构，例如堆叠自动编码器，稀疏自动编码器等。  
深度学习是机器学习发展的产物。与传统的机器学习方法相比，深度学习优势明显，目前在图像识别、语音识别、自然语言理解等领域得到广泛的应用。",浅层学习使用支持向量机模型进行机器学习
深度学习,发展自,浅层学习,,"1959 年，美国塞缪尔教授设计了一个具有学习能力的下棋程序。它可在不断对弈中改善自己的棋艺。4 年后，该程序战胜了设计者本人。又过3 年，该程序战胜了美国常胜冠军。由此可以看出机器学习的能力，特别是当下谷歌设计的AlphaGo 程序与围棋大师李世石的围棋大战，更是体现了机器学习的威力。所谓机器学习，就是数学模型或求解算法中具有似于人类的学习机制，能够从实际问题中采集适当样本数据，根据样本数据自动算出参数值，并随着样本数据的变化自动调整参数取值，使得数学模型和求解算法具有良好的普适性和自适应性。按机器学习的模型结构层次来分，机器学习经历了两次浪潮，分别是浅层学习和深度学习。近年来，机器学习的概念异常火爆，各种机器学习算法层出不穷。本小节简要介绍图模型在浅层学习和深度学习中的与应用。  
![图8-73 BP 网络结构](images/3e28bfeab67aaebdd2a54ed46ef1bb594380bb5384ccdde94e5e1d5ae51f9049.jpg)  
![图8-74 支持向量机结构](images/0d16cdb37dc68fb29e3b36be467fd837d3d52e2ccd7acbba9de1c8c373e6974d.jpg)  
无论是浅层学习还是深度学习的模型结构都是基于图模型。  图8-73 所示的图模型是20 世纪80 年代末期提出BP 神经网络模型，图8-74 所示的图模型是20 世纪90 年代中期提出支持向量机模型。 这些都是机器学习中的经典图模型用于浅层的机器学习。 正是这些图模型的建立给机器学习带来了希望，掀起了基于统计模型机器学习热潮。人们使用这类权图模型从大量训练样本中学习统计规律，然后根据学到的规律对未知事件进行预测。  
![图8-75 简单函数对复杂函数的逼近 ](images/fbe962cff1ffa6a7bb0339da768141046705e07e74feba559a3752dfe9c241b2.jpg)  
![图8-76 多层模型表示复杂函数  ](images/272fe3358ea6997e106f1355c74465d9d8b3888427cf64765b441f271abcfeac.jpg)  
然而，进入21 世纪，浅层学习研究的发展遇到瓶颈。从而，人们创立了深度学习的相关概念和理论，并借助分布式云计算的大数据平台，在机器学习领域取得了突破性进展。深度学习通过一种深层非线性网络结构，组合低层特征形成更加抽象的高层表示属性类别或特征，实现由简单函数向复杂函数的有效逼近，以发现数据的分布式特征表示。其具有强大的从少数样本中集中学习数据集本质特征的能力。图8-75 表示一个通过简单函数逼近复杂函数的实例。  
简单地说，深度学习就是对拥有深层结构的模型进行训练。所谓深层结构，是相对于前述的浅层结构而言的，两者的差异主要在于拥有的非线性运算单元的层数不同。深层结构是指非线性转换单元的层数大于或等于两层的模型，而使用多层模型的优势即可以使用较少的参数表示复杂的函数。使用多层模型表示复杂函数的例子如图8-76 所示。  
![图8-77 含多隐含层的深度学习模型图  ](images/a696f4639cd9bb8eadcb3b542d30322c2127fff383c01a8ce40760e85d44b787.jpg)  
![图8-78 自动编码器(AE)结构示意图  ](images/d437ba8ccbf4e13b83ff799a9ddec1778e03cc7629e09224d02fe81a54b359de.jpg)  
深度学习在模型中构建多层隐含层，并通过大量样本训练模型参数，获得更有用的特征，从而有效提升分类或预测的准确性。相比较传统的浅层结构，深度学习更强调了模型结构的深度，通常有5 至6 层隐含层，有的模型结构甚至包含10 层以上隐含层。此外，深度学习明确突出了特征学习的重要性。深度学习实现多层堆叠，每一层的输出作为下一层的输入，高层的特征是低层特征的组合，从低层到高层的特征表示越来越抽象，越来越能表现语义或者意图。而抽象层面越高，存在的可能猜测就越少，就越利于分类。换句话说，深度学习通过逐层特征变换，将样本在原始特征空间表示逐层变换到新的特征空间，从而使分类或预测的效果更加准确。图8-77 表示一个含多隐含层的深度学习模型。事实上，由如图8-78 所示自动编码器组合或其简单变形的模型也可看成是深度结构，例如堆叠自动编码器，稀疏自动编码器等。  
深度学习是机器学习发展的产物。与传统的机器学习方法相比，深度学习优势明显，目前在图像识别、语音识别、自然语言理解等领域得到广泛的应用。",深度学习是浅层学习研究遇到瓶颈后发展起来的
树模型,包含,生成树,,"树是大家非常熟悉的一类植物。通过对树的观察，不难发现自然界中的树总是有根、枝和叶，且具有这样一些特点：从根上可以长出枝来，从树杈上可以长出枝或叶，叶梢不长在一起，根、枝、叶之间总是畅通的，但它们之间不能构成圈。从结构上看，树是所有连通无向图中边数最少的图模型，同时也是所有无环无向图中边数最多的图模型。我们不得不惊叹大自然的神奇，竟然创造出如此高效而又和谐的离散结构。对自然界中树的这种特殊离散结构进行抽象，就可得到一种特殊的图模型，即树模型。在所有的图模型中，树模型是一种最简洁的连通无环结构，其中各结点之间有着最直接、最必要的联结关系。这种最简洁的连通结构决定了树在图模型知识体系中占有特别重要的地位。目前，树作为一种特殊图模型已被广泛应用于计算机各个领域，例如操作系统采用树结构来组织文件数据，编译程序采用树表示源程序的语法结构，在数据库系统中树被用来组织信息等等。  
本章主要介绍树模型基本理论及其算法设计的基本知识，首先介绍树模型的基本概念与性质、生成树与最小生成树等关于树模型的基本理论，然后具体讨论根树的概念与算法，包括树的递归遍历算法、森林与树的转换算法、最优树的构造与编码算法等，并在此基础上进一步学习若干典型特殊树模型及其基本算法，包括平衡树、红黑树、$B$树等，最后给出树模型的若干应用实例，包括决策树、博弈树等。",生成树是树模型的一种基本理论
树模型,包含,最小生成树,,"树是大家非常熟悉的一类植物。通过对树的观察，不难发现自然界中的树总是有根、枝和叶，且具有这样一些特点：从根上可以长出枝来，从树杈上可以长出枝或叶，叶梢不长在一起，根、枝、叶之间总是畅通的，但它们之间不能构成圈。从结构上看，树是所有连通无向图中边数最少的图模型，同时也是所有无环无向图中边数最多的图模型。我们不得不惊叹大自然的神奇，竟然创造出如此高效而又和谐的离散结构。对自然界中树的这种特殊离散结构进行抽象，就可得到一种特殊的图模型，即树模型。在所有的图模型中，树模型是一种最简洁的连通无环结构，其中各结点之间有着最直接、最必要的联结关系。这种最简洁的连通结构决定了树在图模型知识体系中占有特别重要的地位。目前，树作为一种特殊图模型已被广泛应用于计算机各个领域，例如操作系统采用树结构来组织文件数据，编译程序采用树表示源程序的语法结构，在数据库系统中树被用来组织信息等等。  
本章主要介绍树模型基本理论及其算法设计的基本知识，首先介绍树模型的基本概念与性质、生成树与最小生成树等关于树模型的基本理论，然后具体讨论根树的概念与算法，包括树的递归遍历算法、森林与树的转换算法、最优树的构造与编码算法等，并在此基础上进一步学习若干典型特殊树模型及其基本算法，包括平衡树、红黑树、$B$树等，最后给出树模型的若干应用实例，包括决策树、博弈树等。",最小生成树是树模型的一种基本理论
树模型,包含,根树,,"树是大家非常熟悉的一类植物。通过对树的观察，不难发现自然界中的树总是有根、枝和叶，且具有这样一些特点：从根上可以长出枝来，从树杈上可以长出枝或叶，叶梢不长在一起，根、枝、叶之间总是畅通的，但它们之间不能构成圈。从结构上看，树是所有连通无向图中边数最少的图模型，同时也是所有无环无向图中边数最多的图模型。我们不得不惊叹大自然的神奇，竟然创造出如此高效而又和谐的离散结构。对自然界中树的这种特殊离散结构进行抽象，就可得到一种特殊的图模型，即树模型。在所有的图模型中，树模型是一种最简洁的连通无环结构，其中各结点之间有着最直接、最必要的联结关系。这种最简洁的连通结构决定了树在图模型知识体系中占有特别重要的地位。目前，树作为一种特殊图模型已被广泛应用于计算机各个领域，例如操作系统采用树结构来组织文件数据，编译程序采用树表示源程序的语法结构，在数据库系统中树被用来组织信息等等。  
本章主要介绍树模型基本理论及其算法设计的基本知识，首先介绍树模型的基本概念与性质、生成树与最小生成树等关于树模型的基本理论，然后具体讨论根树的概念与算法，包括树的递归遍历算法、森林与树的转换算法、最优树的构造与编码算法等，并在此基础上进一步学习若干典型特殊树模型及其基本算法，包括平衡树、红黑树、$B$树等，最后给出树模型的若干应用实例，包括决策树、博弈树等。",根树是树模型的一种特殊类型，涉及相关算法
树模型,包含,平衡树,,"树是大家非常熟悉的一类植物。通过对树的观察，不难发现自然界中的树总是有根、枝和叶，且具有这样一些特点：从根上可以长出枝来，从树杈上可以长出枝或叶，叶梢不长在一起，根、枝、叶之间总是畅通的，但它们之间不能构成圈。从结构上看，树是所有连通无向图中边数最少的图模型，同时也是所有无环无向图中边数最多的图模型。我们不得不惊叹大自然的神奇，竟然创造出如此高效而又和谐的离散结构。对自然界中树的这种特殊离散结构进行抽象，就可得到一种特殊的图模型，即树模型。在所有的图模型中，树模型是一种最简洁的连通无环结构，其中各结点之间有着最直接、最必要的联结关系。这种最简洁的连通结构决定了树在图模型知识体系中占有特别重要的地位。目前，树作为一种特殊图模型已被广泛应用于计算机各个领域，例如操作系统采用树结构来组织文件数据，编译程序采用树表示源程序的语法结构，在数据库系统中树被用来组织信息等等。  
本章主要介绍树模型基本理论及其算法设计的基本知识，首先介绍树模型的基本概念与性质、生成树与最小生成树等关于树模型的基本理论，然后具体讨论根树的概念与算法，包括树的递归遍历算法、森林与树的转换算法、最优树的构造与编码算法等，并在此基础上进一步学习若干典型特殊树模型及其基本算法，包括平衡树、红黑树、$B$树等，最后给出树模型的若干应用实例，包括决策树、博弈树等。",平衡树是树模型的一种典型特殊类型
树模型,包含,红黑树,,"树是大家非常熟悉的一类植物。通过对树的观察，不难发现自然界中的树总是有根、枝和叶，且具有这样一些特点：从根上可以长出枝来，从树杈上可以长出枝或叶，叶梢不长在一起，根、枝、叶之间总是畅通的，但它们之间不能构成圈。从结构上看，树是所有连通无向图中边数最少的图模型，同时也是所有无环无向图中边数最多的图模型。我们不得不惊叹大自然的神奇，竟然创造出如此高效而又和谐的离散结构。对自然界中树的这种特殊离散结构进行抽象，就可得到一种特殊的图模型，即树模型。在所有的图模型中，树模型是一种最简洁的连通无环结构，其中各结点之间有着最直接、最必要的联结关系。这种最简洁的连通结构决定了树在图模型知识体系中占有特别重要的地位。目前，树作为一种特殊图模型已被广泛应用于计算机各个领域，例如操作系统采用树结构来组织文件数据，编译程序采用树表示源程序的语法结构，在数据库系统中树被用来组织信息等等。  
本章主要介绍树模型基本理论及其算法设计的基本知识，首先介绍树模型的基本概念与性质、生成树与最小生成树等关于树模型的基本理论，然后具体讨论根树的概念与算法，包括树的递归遍历算法、森林与树的转换算法、最优树的构造与编码算法等，并在此基础上进一步学习若干典型特殊树模型及其基本算法，包括平衡树、红黑树、$B$树等，最后给出树模型的若干应用实例，包括决策树、博弈树等。",红黑树是树模型的一种典型特殊类型
树模型,包含,B树,,"树是大家非常熟悉的一类植物。通过对树的观察，不难发现自然界中的树总是有根、枝和叶，且具有这样一些特点：从根上可以长出枝来，从树杈上可以长出枝或叶，叶梢不长在一起，根、枝、叶之间总是畅通的，但它们之间不能构成圈。从结构上看，树是所有连通无向图中边数最少的图模型，同时也是所有无环无向图中边数最多的图模型。我们不得不惊叹大自然的神奇，竟然创造出如此高效而又和谐的离散结构。对自然界中树的这种特殊离散结构进行抽象，就可得到一种特殊的图模型，即树模型。在所有的图模型中，树模型是一种最简洁的连通无环结构，其中各结点之间有着最直接、最必要的联结关系。这种最简洁的连通结构决定了树在图模型知识体系中占有特别重要的地位。目前，树作为一种特殊图模型已被广泛应用于计算机各个领域，例如操作系统采用树结构来组织文件数据，编译程序采用树表示源程序的语法结构，在数据库系统中树被用来组织信息等等。  
本章主要介绍树模型基本理论及其算法设计的基本知识，首先介绍树模型的基本概念与性质、生成树与最小生成树等关于树模型的基本理论，然后具体讨论根树的概念与算法，包括树的递归遍历算法、森林与树的转换算法、最优树的构造与编码算法等，并在此基础上进一步学习若干典型特殊树模型及其基本算法，包括平衡树、红黑树、$B$树等，最后给出树模型的若干应用实例，包括决策树、博弈树等。",B树是树模型的一种典型特殊类型
树模型,应用,决策树,,"树是大家非常熟悉的一类植物。通过对树的观察，不难发现自然界中的树总是有根、枝和叶，且具有这样一些特点：从根上可以长出枝来，从树杈上可以长出枝或叶，叶梢不长在一起，根、枝、叶之间总是畅通的，但它们之间不能构成圈。从结构上看，树是所有连通无向图中边数最少的图模型，同时也是所有无环无向图中边数最多的图模型。我们不得不惊叹大自然的神奇，竟然创造出如此高效而又和谐的离散结构。对自然界中树的这种特殊离散结构进行抽象，就可得到一种特殊的图模型，即树模型。在所有的图模型中，树模型是一种最简洁的连通无环结构，其中各结点之间有着最直接、最必要的联结关系。这种最简洁的连通结构决定了树在图模型知识体系中占有特别重要的地位。目前，树作为一种特殊图模型已被广泛应用于计算机各个领域，例如操作系统采用树结构来组织文件数据，编译程序采用树表示源程序的语法结构，在数据库系统中树被用来组织信息等等。  
本章主要介绍树模型基本理论及其算法设计的基本知识，首先介绍树模型的基本概念与性质、生成树与最小生成树等关于树模型的基本理论，然后具体讨论根树的概念与算法，包括树的递归遍历算法、森林与树的转换算法、最优树的构造与编码算法等，并在此基础上进一步学习若干典型特殊树模型及其基本算法，包括平衡树、红黑树、$B$树等，最后给出树模型的若干应用实例，包括决策树、博弈树等。",决策树是树模型的一种应用实例
树模型,应用,博弈树,,"树是大家非常熟悉的一类植物。通过对树的观察，不难发现自然界中的树总是有根、枝和叶，且具有这样一些特点：从根上可以长出枝来，从树杈上可以长出枝或叶，叶梢不长在一起，根、枝、叶之间总是畅通的，但它们之间不能构成圈。从结构上看，树是所有连通无向图中边数最少的图模型，同时也是所有无环无向图中边数最多的图模型。我们不得不惊叹大自然的神奇，竟然创造出如此高效而又和谐的离散结构。对自然界中树的这种特殊离散结构进行抽象，就可得到一种特殊的图模型，即树模型。在所有的图模型中，树模型是一种最简洁的连通无环结构，其中各结点之间有着最直接、最必要的联结关系。这种最简洁的连通结构决定了树在图模型知识体系中占有特别重要的地位。目前，树作为一种特殊图模型已被广泛应用于计算机各个领域，例如操作系统采用树结构来组织文件数据，编译程序采用树表示源程序的语法结构，在数据库系统中树被用来组织信息等等。  
本章主要介绍树模型基本理论及其算法设计的基本知识，首先介绍树模型的基本概念与性质、生成树与最小生成树等关于树模型的基本理论，然后具体讨论根树的概念与算法，包括树的递归遍历算法、森林与树的转换算法、最优树的构造与编码算法等，并在此基础上进一步学习若干典型特殊树模型及其基本算法，包括平衡树、红黑树、$B$树等，最后给出树模型的若干应用实例，包括决策树、博弈树等。",博弈树是树模型的一种应用实例
无向树,转化,根树,,我们知道图模型主要分为有向图和无向图两大类，树作为一类特殊的图模型，自然也就有有向树与无向树之分。不过，如果从树的根结点看过去，树模型从根结点到叶子结点的层次结构本身就蕴含着一种方向。因此，一般不再关心树中各个边的方向差异而专注树结构的层次方向。换句话说，对于有向树，必须将其转化为一种特殊的无向树即根树进行讨论。基于以上原因，若无特别说明，我们通常所说的树模型均指无向树模型。,有向树必须转化为一种特殊的无向树即根树进行讨论
无向树,包含,森林,,"我们知道，自然界中任何一棵树都一个连通的整体，其根、枝、叶之间总相互畅通以保证养分能够顺利到达树的各个部分。此外，从树的结构上看，树的根、枝、叶之间没有任何回路。将树的上述两个基本特征进行抽象，就可得到树的本质结构特征：树模型其实就是一种无环的连通无向图。由此得到如下关于树的定义：  
【定义9.1】连通无回路的无向图称为树。树中悬挂结点称为树叶结点，简称为叶结点或叶，其它结点称为分支点或内点。平凡图称为空树。所有连通分支均为树的无向图称为森林，单个的树模型本身可看成是一个森林。  
【定理9.1】假设${G}=\left\langle{V},{E}\right\rangle$是任意给定的一个无向图模型，且 $\vert V\vert=n,\vert E\vert=m$，则下述各个命题相互等值：  
（1）$G$连通而不含回路（即$G$是树）；  
（2）$G$中无回路且$m=n-1$；  
（3）$G$是连通的且$m=n-1$；  
（4）$G$中无回路，但在$G$中任意增加一条新边，就会得到唯一一条基本回路；  
（5）当$n\geq2$时，$G$是连通的，但删除$G$中的任一条边后，便不连通；  （6）当$n\geq2$时，$G$中每一对结点之间都有唯一的一条基本通路。  
下面定理9.2 给出了关于树模型叶结点的一个基本性质：  
【定理 9.2】 任意非平凡树$T(n,m)$都至少有两片叶。【分析】 利用握手定理和$m=n-1$即可证明。",单个的无向树可以看成是一个森林
无向树,定义,定理9.1,,"我们知道，自然界中任何一棵树都一个连通的整体，其根、枝、叶之间总相互畅通以保证养分能够顺利到达树的各个部分。此外，从树的结构上看，树的根、枝、叶之间没有任何回路。将树的上述两个基本特征进行抽象，就可得到树的本质结构特征：树模型其实就是一种无环的连通无向图。由此得到如下关于树的定义：  
【定义9.1】连通无回路的无向图称为树。树中悬挂结点称为树叶结点，简称为叶结点或叶，其它结点称为分支点或内点。平凡图称为空树。所有连通分支均为树的无向图称为森林，单个的树模型本身可看成是一个森林。  
【定理9.1】假设${G}=\left\langle{V},{E}\right\rangle$是任意给定的一个无向图模型，且 $\vert V\vert=n,\vert E\vert=m$，则下述各个命题相互等值：  
（1）$G$连通而不含回路（即$G$是树）；  
（2）$G$中无回路且$m=n-1$；  
（3）$G$是连通的且$m=n-1$；  
（4）$G$中无回路，但在$G$中任意增加一条新边，就会得到唯一一条基本回路；  
（5）当$n\geq2$时，$G$是连通的，但删除$G$中的任一条边后，便不连通；  （6）当$n\geq2$时，$G$中每一对结点之间都有唯一的一条基本通路。  
下面定理9.2 给出了关于树模型叶结点的一个基本性质：  
【定理 9.2】 任意非平凡树$T(n,m)$都至少有两片叶。【分析】 利用握手定理和$m=n-1$即可证明。",定理9.1给出了无向树的等价定义
无向树,性质,定理9.2,,"我们知道，自然界中任何一棵树都一个连通的整体，其根、枝、叶之间总相互畅通以保证养分能够顺利到达树的各个部分。此外，从树的结构上看，树的根、枝、叶之间没有任何回路。将树的上述两个基本特征进行抽象，就可得到树的本质结构特征：树模型其实就是一种无环的连通无向图。由此得到如下关于树的定义：  
【定义9.1】连通无回路的无向图称为树。树中悬挂结点称为树叶结点，简称为叶结点或叶，其它结点称为分支点或内点。平凡图称为空树。所有连通分支均为树的无向图称为森林，单个的树模型本身可看成是一个森林。  
【定理9.1】假设${G}=\left\langle{V},{E}\right\rangle$是任意给定的一个无向图模型，且 $\vert V\vert=n,\vert E\vert=m$，则下述各个命题相互等值：  
（1）$G$连通而不含回路（即$G$是树）；  
（2）$G$中无回路且$m=n-1$；  
（3）$G$是连通的且$m=n-1$；  
（4）$G$中无回路，但在$G$中任意增加一条新边，就会得到唯一一条基本回路；  
（5）当$n\geq2$时，$G$是连通的，但删除$G$中的任一条边后，便不连通；  （6）当$n\geq2$时，$G$中每一对结点之间都有唯一的一条基本通路。  
下面定理9.2 给出了关于树模型叶结点的一个基本性质：  
【定理 9.2】 任意非平凡树$T(n,m)$都至少有两片叶。【分析】 利用握手定理和$m=n-1$即可证明。",定理9.2描述了无向树中叶结点的基本性质
森林,相关,定理9.1,,"我们知道，自然界中任何一棵树都一个连通的整体，其根、枝、叶之间总相互畅通以保证养分能够顺利到达树的各个部分。此外，从树的结构上看，树的根、枝、叶之间没有任何回路。将树的上述两个基本特征进行抽象，就可得到树的本质结构特征：树模型其实就是一种无环的连通无向图。由此得到如下关于树的定义：  
【定义9.1】连通无回路的无向图称为树。树中悬挂结点称为树叶结点，简称为叶结点或叶，其它结点称为分支点或内点。平凡图称为空树。所有连通分支均为树的无向图称为森林，单个的树模型本身可看成是一个森林。  
【定理9.1】假设${G}=\left\langle{V},{E}\right\rangle$是任意给定的一个无向图模型，且 $\vert V\vert=n,\vert E\vert=m$，则下述各个命题相互等值：  
（1）$G$连通而不含回路（即$G$是树）；  
（2）$G$中无回路且$m=n-1$；  
（3）$G$是连通的且$m=n-1$；  
（4）$G$中无回路，但在$G$中任意增加一条新边，就会得到唯一一条基本回路；  
（5）当$n\geq2$时，$G$是连通的，但删除$G$中的任一条边后，便不连通；  （6）当$n\geq2$时，$G$中每一对结点之间都有唯一的一条基本通路。  
下面定理9.2 给出了关于树模型叶结点的一个基本性质：  
【定理 9.2】 任意非平凡树$T(n,m)$都至少有两片叶。【分析】 利用握手定理和$m=n-1$即可证明。",森林由多个满足定理9.1定义的无向树组成
定理9.1,补充,定理9.2,,"我们知道，自然界中任何一棵树都一个连通的整体，其根、枝、叶之间总相互畅通以保证养分能够顺利到达树的各个部分。此外，从树的结构上看，树的根、枝、叶之间没有任何回路。将树的上述两个基本特征进行抽象，就可得到树的本质结构特征：树模型其实就是一种无环的连通无向图。由此得到如下关于树的定义：  
【定义9.1】连通无回路的无向图称为树。树中悬挂结点称为树叶结点，简称为叶结点或叶，其它结点称为分支点或内点。平凡图称为空树。所有连通分支均为树的无向图称为森林，单个的树模型本身可看成是一个森林。  
【定理9.1】假设${G}=\left\langle{V},{E}\right\rangle$是任意给定的一个无向图模型，且 $\vert V\vert=n,\vert E\vert=m$，则下述各个命题相互等值：  
（1）$G$连通而不含回路（即$G$是树）；  
（2）$G$中无回路且$m=n-1$；  
（3）$G$是连通的且$m=n-1$；  
（4）$G$中无回路，但在$G$中任意增加一条新边，就会得到唯一一条基本回路；  
（5）当$n\geq2$时，$G$是连通的，但删除$G$中的任一条边后，便不连通；  （6）当$n\geq2$时，$G$中每一对结点之间都有唯一的一条基本通路。  
下面定理9.2 给出了关于树模型叶结点的一个基本性质：  
【定理 9.2】 任意非平凡树$T(n,m)$都至少有两片叶。【分析】 利用握手定理和$m=n-1$即可证明。",定理9.1和定理9.2共同描述了无向树的结构和性质
无向图的生成树,构造方法,破圈法,,"如前所述，树模型是大自然赐予的一种最简洁最高效的连通无向图，任意两个结点之间有且仅有一条路径联结。因此，在对一般连通无向图进行化简的时候，经常会删除图的一些边将其转化为树结构的生成子图。这种生成子图称为无向图的生成树，其定义如下：  
【定义9.2】假设$G=\langle V,E\rangle$是任意给定的一个无向图模型，若$G$的某个生成子图是树，则称该树为$G$的一个生成树，记为$T_{G}$。生成树$T_{G}$中的每条边均称为树枝；$G$中不在$T_{G}$中的每条边均称为弦；$T_{G}$的所有弦的集合称为生成树的补。  
例如，对于图9-3(a)所示的图$G_{1}$无向图，$G_{2}$和$G_{3}$为该图的两棵不同构的生成树。对于图9-3(b)所示生成树$G_{2}$，边$\mathtt{e}_{2},\mathtt{e}_{3},\mathtt{e}_{4},\mathtt{e}_{5}$ 是其树枝，而$\mathsf{e}_{1},\,\mathsf{e}_{6}$ 是其弦；对于图9-3(c)所示的生成树$G_{3}$，$\mathsf{e}_{1},\mathsf{e}_{2},\mathsf{e}_{4},\mathsf{e}_{5}$ 是其树枝，而$\mathsf{e}_{3},\,\mathsf{e}_{6}$ 是其弦。  
![图9-3 连通无向图及其生成树  ](images/3447e9802eaf794918ba03e412f68817eae23f2621102647ed094020348d10e0.jpg)  
显然，对于一个无向连通图$G$，如果$G$本身就是树，则其生成树就是它自己，因而是唯一的。但是，如果$G$不是树，则其生成树就不是唯一的。下面的定理9.3 保证了无向连通图模型生成树的存在性，为无向连通图的化简提供了坚实的基础：  
【定理9.3】假设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$存在其生成树$T_{G}=\langle V_{T}\,,\,\,\,E_{T}\rangle$的充分必要条件是$G$是连通的。  
事实上，上述定理证明过程给出了构造生成树的一种具体算法，通常称之为破圈法。该算法的关键是判断图$G$中是否有回路。若有回路，则删除回路中的一条边，直到图中无回路为止。假设图$G$中有${n}$个结点和$m$条边，则由生成树结点与边的关系知，要构造该图的生成树，必需删除$m-n+1$条边。  
此外，由于含$_n$个结点和$m$条边无向连通图$G=(n,m)$一定存在生成树，且生成树中必有$n$个顶点，$n-1$条树枝和$m-n+1$条弦。因此，在$G$中选择不构成任何回路的$n-1$条边就一定可以得到$G$的一个生成树。这种构造生成树的方法，通常称为避圈法。  
![图9-4 构造生成树的破圈法与避圈法  ](images/6583966484122e279921cd749c7234aa541872b9fc25864834c494c7d9d17e62.jpg)  
破圈法和避圈法需要找出回路或验证不存在回路，计算量通常较大。由于在对一般连通无向图进行广度遍历搜索的时候，会自然形成一个无回路的连通生成子图，即该图生成树。因此，可以通过广度优先遍历算法构造生成树。该算法无需判断回路，因而具有较高的计算效率，比较适合计算机处理。对于连通图$G=\langle V,E\rangle$，该算法的具体过程如下：  
（1）任选$s\in V$，将$s$标记为0，令$L=\{s\},\;V=V-\{s\},k=0$；  
（2）如果$v=\varnothing$，则转（4），否则令$\cdot k=k+1$；  
（3）依次对$L$中的所有标记为$k-1$的结点$v$，如果它与𝑉中的结点𝑤相连接，则将𝑤标记为$k$，指定$v$为$w$的前驱，令$L=L\cup\{w\}$，转（2）；  
（4）$E_{G}=\big\{(v,w)\big|w\in L-\{s\},v\big\}$𝑤的前驱}结束。",破圈法是一种通过删除图中回路中的边来构造无向图生成树的算法
无向图的生成树,构造方法,避圈法,,"如前所述，树模型是大自然赐予的一种最简洁最高效的连通无向图，任意两个结点之间有且仅有一条路径联结。因此，在对一般连通无向图进行化简的时候，经常会删除图的一些边将其转化为树结构的生成子图。这种生成子图称为无向图的生成树，其定义如下：  
【定义9.2】假设$G=\langle V,E\rangle$是任意给定的一个无向图模型，若$G$的某个生成子图是树，则称该树为$G$的一个生成树，记为$T_{G}$。生成树$T_{G}$中的每条边均称为树枝；$G$中不在$T_{G}$中的每条边均称为弦；$T_{G}$的所有弦的集合称为生成树的补。  
例如，对于图9-3(a)所示的图$G_{1}$无向图，$G_{2}$和$G_{3}$为该图的两棵不同构的生成树。对于图9-3(b)所示生成树$G_{2}$，边$\mathtt{e}_{2},\mathtt{e}_{3},\mathtt{e}_{4},\mathtt{e}_{5}$ 是其树枝，而$\mathsf{e}_{1},\,\mathsf{e}_{6}$ 是其弦；对于图9-3(c)所示的生成树$G_{3}$，$\mathsf{e}_{1},\mathsf{e}_{2},\mathsf{e}_{4},\mathsf{e}_{5}$ 是其树枝，而$\mathsf{e}_{3},\,\mathsf{e}_{6}$ 是其弦。  
![图9-3 连通无向图及其生成树  ](images/3447e9802eaf794918ba03e412f68817eae23f2621102647ed094020348d10e0.jpg)  
显然，对于一个无向连通图$G$，如果$G$本身就是树，则其生成树就是它自己，因而是唯一的。但是，如果$G$不是树，则其生成树就不是唯一的。下面的定理9.3 保证了无向连通图模型生成树的存在性，为无向连通图的化简提供了坚实的基础：  
【定理9.3】假设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$存在其生成树$T_{G}=\langle V_{T}\,,\,\,\,E_{T}\rangle$的充分必要条件是$G$是连通的。  
事实上，上述定理证明过程给出了构造生成树的一种具体算法，通常称之为破圈法。该算法的关键是判断图$G$中是否有回路。若有回路，则删除回路中的一条边，直到图中无回路为止。假设图$G$中有${n}$个结点和$m$条边，则由生成树结点与边的关系知，要构造该图的生成树，必需删除$m-n+1$条边。  
此外，由于含$_n$个结点和$m$条边无向连通图$G=(n,m)$一定存在生成树，且生成树中必有$n$个顶点，$n-1$条树枝和$m-n+1$条弦。因此，在$G$中选择不构成任何回路的$n-1$条边就一定可以得到$G$的一个生成树。这种构造生成树的方法，通常称为避圈法。  
![图9-4 构造生成树的破圈法与避圈法  ](images/6583966484122e279921cd749c7234aa541872b9fc25864834c494c7d9d17e62.jpg)  
破圈法和避圈法需要找出回路或验证不存在回路，计算量通常较大。由于在对一般连通无向图进行广度遍历搜索的时候，会自然形成一个无回路的连通生成子图，即该图生成树。因此，可以通过广度优先遍历算法构造生成树。该算法无需判断回路，因而具有较高的计算效率，比较适合计算机处理。对于连通图$G=\langle V,E\rangle$，该算法的具体过程如下：  
（1）任选$s\in V$，将$s$标记为0，令$L=\{s\},\;V=V-\{s\},k=0$；  
（2）如果$v=\varnothing$，则转（4），否则令$\cdot k=k+1$；  
（3）依次对$L$中的所有标记为$k-1$的结点$v$，如果它与𝑉中的结点𝑤相连接，则将𝑤标记为$k$，指定$v$为$w$的前驱，令$L=L\cup\{w\}$，转（2）；  
（4）$E_{G}=\big\{(v,w)\big|w\in L-\{s\},v\big\}$𝑤的前驱}结束。",避圈法是一种通过选择不构成任何回路的边来构造无向图生成树的算法
无向图的生成树,构造方法,广度优先遍历算法,,"如前所述，树模型是大自然赐予的一种最简洁最高效的连通无向图，任意两个结点之间有且仅有一条路径联结。因此，在对一般连通无向图进行化简的时候，经常会删除图的一些边将其转化为树结构的生成子图。这种生成子图称为无向图的生成树，其定义如下：  
【定义9.2】假设$G=\langle V,E\rangle$是任意给定的一个无向图模型，若$G$的某个生成子图是树，则称该树为$G$的一个生成树，记为$T_{G}$。生成树$T_{G}$中的每条边均称为树枝；$G$中不在$T_{G}$中的每条边均称为弦；$T_{G}$的所有弦的集合称为生成树的补。  
例如，对于图9-3(a)所示的图$G_{1}$无向图，$G_{2}$和$G_{3}$为该图的两棵不同构的生成树。对于图9-3(b)所示生成树$G_{2}$，边$\mathtt{e}_{2},\mathtt{e}_{3},\mathtt{e}_{4},\mathtt{e}_{5}$ 是其树枝，而$\mathsf{e}_{1},\,\mathsf{e}_{6}$ 是其弦；对于图9-3(c)所示的生成树$G_{3}$，$\mathsf{e}_{1},\mathsf{e}_{2},\mathsf{e}_{4},\mathsf{e}_{5}$ 是其树枝，而$\mathsf{e}_{3},\,\mathsf{e}_{6}$ 是其弦。  
![图9-3 连通无向图及其生成树  ](images/3447e9802eaf794918ba03e412f68817eae23f2621102647ed094020348d10e0.jpg)  
显然，对于一个无向连通图$G$，如果$G$本身就是树，则其生成树就是它自己，因而是唯一的。但是，如果$G$不是树，则其生成树就不是唯一的。下面的定理9.3 保证了无向连通图模型生成树的存在性，为无向连通图的化简提供了坚实的基础：  
【定理9.3】假设 $G=\langle V,E\rangle$是任意给定的一个无向图模型，则$G=\langle V,E\rangle$存在其生成树$T_{G}=\langle V_{T}\,,\,\,\,E_{T}\rangle$的充分必要条件是$G$是连通的。  
事实上，上述定理证明过程给出了构造生成树的一种具体算法，通常称之为破圈法。该算法的关键是判断图$G$中是否有回路。若有回路，则删除回路中的一条边，直到图中无回路为止。假设图$G$中有${n}$个结点和$m$条边，则由生成树结点与边的关系知，要构造该图的生成树，必需删除$m-n+1$条边。  
此外，由于含$_n$个结点和$m$条边无向连通图$G=(n,m)$一定存在生成树，且生成树中必有$n$个顶点，$n-1$条树枝和$m-n+1$条弦。因此，在$G$中选择不构成任何回路的$n-1$条边就一定可以得到$G$的一个生成树。这种构造生成树的方法，通常称为避圈法。  
![图9-4 构造生成树的破圈法与避圈法  ](images/6583966484122e279921cd749c7234aa541872b9fc25864834c494c7d9d17e62.jpg)  
破圈法和避圈法需要找出回路或验证不存在回路，计算量通常较大。由于在对一般连通无向图进行广度遍历搜索的时候，会自然形成一个无回路的连通生成子图，即该图生成树。因此，可以通过广度优先遍历算法构造生成树。该算法无需判断回路，因而具有较高的计算效率，比较适合计算机处理。对于连通图$G=\langle V,E\rangle$，该算法的具体过程如下：  
（1）任选$s\in V$，将$s$标记为0，令$L=\{s\},\;V=V-\{s\},k=0$；  
（2）如果$v=\varnothing$，则转（4），否则令$\cdot k=k+1$；  
（3）依次对$L$中的所有标记为$k-1$的结点$v$，如果它与𝑉中的结点𝑤相连接，则将𝑤标记为$k$，指定$v$为$w$的前驱，令$L=L\cup\{w\}$，转（2）；  
（4）$E_{G}=\big\{(v,w)\big|w\in L-\{s\},v\big\}$𝑤的前驱}结束。",广度优先遍历算法通过遍历图形成无回路的连通生成子图来构造无向图生成树
最小生成树,构造方法,普莱姆算法,,"为了更好地了解理解最小生成树的概念，我们首先考察一个具体应用实例：对于图9-7所示的带权图𝐺表示在某地6 个小区结点之间修建能源管道的费用预算情况(单位为万元)，图中每条边的权表示在该边两个端点之间修建管道的费用预算，问题是如何在保证这6 个小区连通的前提下使用最少的管道修建费用。  
![图 9-7   带权无向连通图及其最小生成树  ](images/69b981817af345f5a438b8a88bfbbbd31ee6159c07c4129830a99641d06e89d2.jpg)  
显然，如果所修建的所有管道能够构成$G$的一个生成树，就能满足小区之间的连通性要求。但是，图$G$有多个不同的生成树，并且对于不同的生成树，其边也不完全相同，从而修建的总费用会有一些差异。因此，通常希望能够找到一个修建总费用达到最小的生成树，即各树枝权的总和为最小的生成树，由此得到如下最小生成树的概念：  
【定义9.3】设假设$G=\langle V,E,W\rangle$是任意给定的一个连通无向赋权图模型，𝑇是𝐺的一棵生成树，𝑇的每个树枝所赋权值之和称为𝑇的权，记为$\omega(T)$。图$G$中具有最小权的生成树称为$G$的最小生成树。  
例如，图9-7(b)所示的带权树就是图9-7(a)所示带权图的最小生成树。因此，在保证小区连通前提下管道修建费用最少为$10+10+7+6+5=38$(万元)。  
需要注意的是，由于一个无向图的生成树不唯一。因此，一般不能保证一个赋权图的最小生成树一定是唯一的。但生成树的最小权一定是唯一的，对于不同的最小生成树，它们的权肯定彼此相等并且都等于最小权。  
下面介绍连通无向赋权图的最小生成树构造方法。求赋权图最小生成树的方法很多，其中最常见的主要是普莱姆算法和克鲁斯卡尔算法。  
普莱姆算法基于贪心策略，从图中任意一个结点开始，每次选择增加一条权最小的边构成一棵新树，基本思路就是每次在所有一端已经入选一端未入选的边中，选择权值最小的边加入且不构成回路。算法的具体过程如下：  
（1）从$G$中任意选取一个结点$v_{1}$，置$V_{T}=\{v_{1}\}$，$E_{T}=\varnothing$，$k=1$ 。  
（2）在$V-V_{T}$中选取与某个$v_{i}\in V_{T}$邻接的结点$v_{j}$，使得边$(v_{i},\ v_{j})$的权最小，置$V_{T}=$${T}\cup\{v_{j}\},\;\;E_{T}=E_{T}\cup\{(v_{i}\,,\;\,v_{j})\},\;\;k=k+1.$  
（3）重复步骤(2)，直到$k=|V|$。  
在普莱姆算法的步骤(2)中，若满足条件的最小权边不止一条，则可从中选择一条。由此会产生不同的最小生成树。  
对于图9-7 所示带权图使用普莱姆算法构造其最小生成树的具体过程如图9-8 所示：  
![图9-8 普莱姆算法构造最小生成树](images/8a0f2320ecde8e2695b2e2cead9370c247645fefffa9f77fa84c367a18def480.jpg)  
由于普莱姆算法基于贪心策略， 每次循环只考虑本次选择的最优结果， 而不考虑下次如 何选择，是一种局部最优算法。因此，必须证明算法的正确性。下面定理9.4 证明了普莱姆算法的正确性，保证了该算法可通过不断计算局部最优值获得整体最优值。  
【定理9.4】假设$G=\langle V,E,W\rangle$是任一给定的连通无向赋权图，则由普莱姆算法构造的任何生成树$T=G\{e_{1},e_{2},\ldots,e_{n-1}\}$都是$G$的最小生成树，其中$n$为$G$的结点数。  
![图9-9 普莱姆算法构造最小生成树  ](images/75143a931b95de54e246d3f0ca5e18faed40466b8fb351a6ce6667aea6eaa5e2.jpg)  
![图9-9 普莱姆算法构造最小生成树  ](images/56147ba86dfc989b0cbc43dab1318a7a4a9458fc90e3612e58f3bc1a780819cd.jpg)  
【定理9.5】假设$G=\langle V,E,W\rangle$是任一给定的连通无向赋权图，则由克鲁斯卡尔算法构造的任何生成树$T=G\{e_{1},e_{2},\ldots,e_{n-1}\}$都是$G$的最小生成树，其中$n$为𝐺的结点数。",普莱姆算法是一种基于贪心策略的算法，用于构造连通无向赋权图的最小生成树。
最小生成树,构造方法,克鲁斯卡尔算法,,"为了更好地了解理解最小生成树的概念，我们首先考察一个具体应用实例：对于图9-7所示的带权图𝐺表示在某地6 个小区结点之间修建能源管道的费用预算情况(单位为万元)，图中每条边的权表示在该边两个端点之间修建管道的费用预算，问题是如何在保证这6 个小区连通的前提下使用最少的管道修建费用。  
![图 9-7   带权无向连通图及其最小生成树  ](images/69b981817af345f5a438b8a88bfbbbd31ee6159c07c4129830a99641d06e89d2.jpg)  
显然，如果所修建的所有管道能够构成$G$的一个生成树，就能满足小区之间的连通性要求。但是，图$G$有多个不同的生成树，并且对于不同的生成树，其边也不完全相同，从而修建的总费用会有一些差异。因此，通常希望能够找到一个修建总费用达到最小的生成树，即各树枝权的总和为最小的生成树，由此得到如下最小生成树的概念：  
【定义9.3】设假设$G=\langle V,E,W\rangle$是任意给定的一个连通无向赋权图模型，𝑇是𝐺的一棵生成树，𝑇的每个树枝所赋权值之和称为𝑇的权，记为$\omega(T)$。图$G$中具有最小权的生成树称为$G$的最小生成树。  
例如，图9-7(b)所示的带权树就是图9-7(a)所示带权图的最小生成树。因此，在保证小区连通前提下管道修建费用最少为$10+10+7+6+5=38$(万元)。  
需要注意的是，由于一个无向图的生成树不唯一。因此，一般不能保证一个赋权图的最小生成树一定是唯一的。但生成树的最小权一定是唯一的，对于不同的最小生成树，它们的权肯定彼此相等并且都等于最小权。  
下面介绍连通无向赋权图的最小生成树构造方法。求赋权图最小生成树的方法很多，其中最常见的主要是普莱姆算法和克鲁斯卡尔算法。  
普莱姆算法基于贪心策略，从图中任意一个结点开始，每次选择增加一条权最小的边构成一棵新树，基本思路就是每次在所有一端已经入选一端未入选的边中，选择权值最小的边加入且不构成回路。算法的具体过程如下：  
（1）从$G$中任意选取一个结点$v_{1}$，置$V_{T}=\{v_{1}\}$，$E_{T}=\varnothing$，$k=1$ 。  
（2）在$V-V_{T}$中选取与某个$v_{i}\in V_{T}$邻接的结点$v_{j}$，使得边$(v_{i},\ v_{j})$的权最小，置$V_{T}=$${T}\cup\{v_{j}\},\;\;E_{T}=E_{T}\cup\{(v_{i}\,,\;\,v_{j})\},\;\;k=k+1.$  
（3）重复步骤(2)，直到$k=|V|$。  
在普莱姆算法的步骤(2)中，若满足条件的最小权边不止一条，则可从中选择一条。由此会产生不同的最小生成树。  
对于图9-7 所示带权图使用普莱姆算法构造其最小生成树的具体过程如图9-8 所示：  
![图9-8 普莱姆算法构造最小生成树](images/8a0f2320ecde8e2695b2e2cead9370c247645fefffa9f77fa84c367a18def480.jpg)  
由于普莱姆算法基于贪心策略， 每次循环只考虑本次选择的最优结果， 而不考虑下次如 何选择，是一种局部最优算法。因此，必须证明算法的正确性。下面定理9.4 证明了普莱姆算法的正确性，保证了该算法可通过不断计算局部最优值获得整体最优值。  
【定理9.4】假设$G=\langle V,E,W\rangle$是任一给定的连通无向赋权图，则由普莱姆算法构造的任何生成树$T=G\{e_{1},e_{2},\ldots,e_{n-1}\}$都是$G$的最小生成树，其中$n$为$G$的结点数。  
![图9-9 普莱姆算法构造最小生成树  ](images/75143a931b95de54e246d3f0ca5e18faed40466b8fb351a6ce6667aea6eaa5e2.jpg)  
![图9-9 普莱姆算法构造最小生成树  ](images/56147ba86dfc989b0cbc43dab1318a7a4a9458fc90e3612e58f3bc1a780819cd.jpg)  
【定理9.5】假设$G=\langle V,E,W\rangle$是任一给定的连通无向赋权图，则由克鲁斯卡尔算法构造的任何生成树$T=G\{e_{1},e_{2},\ldots,e_{n-1}\}$都是$G$的最小生成树，其中$n$为𝐺的结点数。",克鲁斯卡尔算法是一种用于构造连通无向赋权图的最小生成树的算法。
普莱姆算法,并列关系,克鲁斯卡尔算法,,"为了更好地了解理解最小生成树的概念，我们首先考察一个具体应用实例：对于图9-7所示的带权图𝐺表示在某地6 个小区结点之间修建能源管道的费用预算情况(单位为万元)，图中每条边的权表示在该边两个端点之间修建管道的费用预算，问题是如何在保证这6 个小区连通的前提下使用最少的管道修建费用。  
![图 9-7   带权无向连通图及其最小生成树  ](images/69b981817af345f5a438b8a88bfbbbd31ee6159c07c4129830a99641d06e89d2.jpg)  
显然，如果所修建的所有管道能够构成$G$的一个生成树，就能满足小区之间的连通性要求。但是，图$G$有多个不同的生成树，并且对于不同的生成树，其边也不完全相同，从而修建的总费用会有一些差异。因此，通常希望能够找到一个修建总费用达到最小的生成树，即各树枝权的总和为最小的生成树，由此得到如下最小生成树的概念：  
【定义9.3】设假设$G=\langle V,E,W\rangle$是任意给定的一个连通无向赋权图模型，𝑇是𝐺的一棵生成树，𝑇的每个树枝所赋权值之和称为𝑇的权，记为$\omega(T)$。图$G$中具有最小权的生成树称为$G$的最小生成树。  
例如，图9-7(b)所示的带权树就是图9-7(a)所示带权图的最小生成树。因此，在保证小区连通前提下管道修建费用最少为$10+10+7+6+5=38$(万元)。  
需要注意的是，由于一个无向图的生成树不唯一。因此，一般不能保证一个赋权图的最小生成树一定是唯一的。但生成树的最小权一定是唯一的，对于不同的最小生成树，它们的权肯定彼此相等并且都等于最小权。  
下面介绍连通无向赋权图的最小生成树构造方法。求赋权图最小生成树的方法很多，其中最常见的主要是普莱姆算法和克鲁斯卡尔算法。  
普莱姆算法基于贪心策略，从图中任意一个结点开始，每次选择增加一条权最小的边构成一棵新树，基本思路就是每次在所有一端已经入选一端未入选的边中，选择权值最小的边加入且不构成回路。算法的具体过程如下：  
（1）从$G$中任意选取一个结点$v_{1}$，置$V_{T}=\{v_{1}\}$，$E_{T}=\varnothing$，$k=1$ 。  
（2）在$V-V_{T}$中选取与某个$v_{i}\in V_{T}$邻接的结点$v_{j}$，使得边$(v_{i},\ v_{j})$的权最小，置$V_{T}=$${T}\cup\{v_{j}\},\;\;E_{T}=E_{T}\cup\{(v_{i}\,,\;\,v_{j})\},\;\;k=k+1.$  
（3）重复步骤(2)，直到$k=|V|$。  
在普莱姆算法的步骤(2)中，若满足条件的最小权边不止一条，则可从中选择一条。由此会产生不同的最小生成树。  
对于图9-7 所示带权图使用普莱姆算法构造其最小生成树的具体过程如图9-8 所示：  
![图9-8 普莱姆算法构造最小生成树](images/8a0f2320ecde8e2695b2e2cead9370c247645fefffa9f77fa84c367a18def480.jpg)  
由于普莱姆算法基于贪心策略， 每次循环只考虑本次选择的最优结果， 而不考虑下次如 何选择，是一种局部最优算法。因此，必须证明算法的正确性。下面定理9.4 证明了普莱姆算法的正确性，保证了该算法可通过不断计算局部最优值获得整体最优值。  
【定理9.4】假设$G=\langle V,E,W\rangle$是任一给定的连通无向赋权图，则由普莱姆算法构造的任何生成树$T=G\{e_{1},e_{2},\ldots,e_{n-1}\}$都是$G$的最小生成树，其中$n$为$G$的结点数。  
![图9-9 普莱姆算法构造最小生成树  ](images/75143a931b95de54e246d3f0ca5e18faed40466b8fb351a6ce6667aea6eaa5e2.jpg)  
![图9-9 普莱姆算法构造最小生成树  ](images/56147ba86dfc989b0cbc43dab1318a7a4a9458fc90e3612e58f3bc1a780819cd.jpg)  
【定理9.5】假设$G=\langle V,E,W\rangle$是任一给定的连通无向赋权图，则由克鲁斯卡尔算法构造的任何生成树$T=G\{e_{1},e_{2},\ldots,e_{n-1}\}$都是$G$的最小生成树，其中$n$为𝐺的结点数。",普莱姆算法和克鲁斯卡尔算法都是常见的构造连通无向赋权图最小生成树的算法。
根树,特殊化,无向树模型,,前面学习了无向树模型的基本知识。细心的读者可能已经发现，作为连通无环图的一般无向树模型并没有完全反映出自然界树模型的基本特征。例如，自然界中的树有树根、树枝和树叶，而前述无向树模型并没有很好地反映树的这些层次结构特征。为此，本节在无向树模型基础上进一步引入树根、树枝和树叶等概念，刻画无向树模型的层次结构，建立一种名为根树的特殊无向树模型，并讨论根树模型的基本性质、基本算法与应用。,根树是在无向树模型基础上引入树根、树枝和树叶等概念的特殊无向树模型
有向树,包含,根树,,"我们知道无向树是一种由无向图构成的特殊图模型.那么如何定义和处理由有向图构成的有向树模型呢？现在就来讨论这个问题，首先给出如下有向树模型的定义：  
【定义9.4】对于任意一个给定的有向图，如果略去其所有有向边的方向而得到的无向图是一棵树，则该有向图称为一棵有向树。  
![图 9-12 有向树与非有向树  ](images/2fdb86589dcfaa78bb54f5eaf1ee2b9affe960919c61d426d8acd7eff5e51d45.jpg)  
例如，对于图9-12 所示若干有向图，略去其所有边的方向，则由图9-12(a)、（b）得到的无向图都是树，而由图9-12（c）得到的无向图有回路，由图9-12（d）得到的无向图为森林。因此，图9-12（a）、（b）均是有向树，图9-12（c）、（d）均不是有向树。  
从上述定义及例题可以看出，有向树模型的连通性与无环性是由其伴随的无向图模型决定的，或者说是略去边的方向而直接将有向树看成是无向树.这与一般有向图模型的概念和处理方式有很大差异.因此，如果在树模型的框架下讨论有向树中某条或某几条边在方向上的差异，则没有太大意义，甚至有时还会引起概念上的混淆。  
事实上，自然界中的树模型本身就蕴含着一种方向，这种方向体现在由树根、树枝和树叶结点所构成的层次结构当中，由树根、树枝和树叶结点之间在属性上的差异来刻画边的方向性，不过这种边的方向不是个别边的方向而是所有边的整体方向，即从根到叶的方向或从叶到根的方向。对自然界中树模型的上述特征进行抽象，得到如下根树的概念：  
【定义9.5】对于一棵非平凡的有向树，如果恰有一个结点的入度为0，其余所有结点的入度均为1，则称之为根树或外向树.入度为0 的结点称为根结点,简称为根；出度为0 的结点称为叶结点，简称为叶；入度为1，出度大于0 的称为内结点，简称为内点；又将内点和根统称为分支结点，简称为分支点。在根树中，从根到任一结点的通路长度，称为该结点的层数；所有结点的层数最大值称为根树的高。  
通常使用倒置法表示根树，即把根画在最上方，叶画在最下方，有向边的方向均指向下方。例如，图9-13（a）中的有向树就是一棵根树，其中$v_{1}$为根，$v_{5},v_{6},v_{8},v_{9},v_{10},v_{12},v_{13}$为叶，$v_{2},v_{3},v_{4},v_{7},v_{11}$为内点。其中，$v_{1}$处在第0 层，层数为0；$v_{2},v_{3},v_{4}$同处在第一层，层数为1；$v_{5},v_{6},v_{7},v_{8},v_{9}$同处在第二层，层数为2；$v_{10},v_{11},v_{12}$同处在第三层，层数为3；$v_{13}$处在第四层，层数为4；这棵树的高度为4。  
![图9-13 根树的方向与方向省略  ](images/f923bd763ba9a19de150bb3a9be8189594c2d07589f0b79f2493ff5c6c70768a.jpg)  
从根树的定义及上述例题不难发现，根树作为一种特殊的有向树其所有边均是朝着一个方向，即是从根结点到叶结点的方向，如图9-13（a）所示。既然如此就可以对这种特殊的有向图进行化简，即省略根树中所有边的方向将其转化为无向树，如图9-13（b）所示.由此可知，根树其实是一种具有根、枝、叶等层次结构的特殊无向树。  
![图9-14 根树的层次结构  ](images/d86c7aab6ba7ea9d62cfd7298cb652c45b9ae862b8d84a5cb286853843255862.jpg)  
如图9-14 所示，根树是一种由子树不断嵌套而产生的一种层次结构模型，故还可用如下递归的方式定义根树：  
【定义9.6】树是一个$n(n>0)$元有限集，集合中所有数据元素具有如下层次关系：当$n=0$ 时，集合为空集，称之为空树；当$n>0$ 时，集合中有且只有一个特定的结点，称之为树模型的根；当$n>1$ 时，除根以外的其余结点可分为$m(m>0)$个互不相交的有限集$T_{1},T_{2},\cdots,T_{m}$，其中每个集合本身又是一棵树，并称$T_{1},T_{2},\cdots,T_{m}$称为根的子树。  
例如，图9-15 表示一个具体的树模型结构。该树有10 个结点，其中𝐴是根结点，其余结点被分为 3  个互不相交的子集： $T_{1}=\{B,E,F\},T_{2}=\{C,G\},T_{3}=\{D,H,I,J\}$ ； $T_{1}$ ， $T_{2}$ ， $T_{3}$ 都 是 𝐴 的子树，它们本身也分别是一棵树。  
![](images/64aed744b0075ece5ec5a03893d3b845267949822e6760ad07e255b850f44d71.jpg)  
也可用家族关系表示根树中各节点间的关系。  
【定义9.7】在根树中，若从结点$v_{i}$到$v_{j}$可达，则称$v_{i}$是$v_{j}$的祖先，$v_{j}$是$v_{i}$的后代；又若 $\langle v_{i},v_{j}\rangle$是根树中的有向边，则称$v_{i}$是$v_{j}$的父亲，$v_{j}$是$v_{i}$的儿子；如果两个结点是同一个结点的儿子，则称这两个结点是兄弟。  
例如，对于图9-16 所表示的树，结点𝐴 的出度为3，结点$B$的出度为2，结点𝑀的出度为0；结点$A$的孩子为$(B,C,D)$，结点$B$的孩子为$(E,F)$；结点𝐴的层次为1，结点𝑀的层次为4 ； 叶结点有 $(K,L,F,G,M,I,J)$ ， 分枝结点有 $(A,B,C,D,E,H)$ ； 结点 𝐼 的双亲为 $D$ ， 结点 𝐿 的双亲 为$E$；结点$B,C,D$为兄弟，结点$K$，$L$为兄弟；树的高度为4；结点𝐴是结点$F$、$G$的祖先，结点$B$，$C$是结点𝐴的子孙。  
有时还会在根树的同层次的兄弟结点之间规定具体的大小排序，一般是从左到右进行排序，有时也可以用边的次序代替结点的次序。  
在根树的实际应用中，例如对目标的排序与查找等，需要经常对其中间结点的分支数进行度量、设计和分析，为此给出如下关于$\cdot k$元根树或$k$叉根树的概念：  
【定义9.8】 在根树𝑇中，若每个分支点至多有${k}$个儿子，则称𝑇为𝒌元树或𝒌叉树；若每个分支点都恰有${k}$个儿子，则称𝑇为完全$ k$元树或完全$ k$叉树；若$k$元树𝑇的兄弟结点之间有序，则称𝑇为𝒌元有序树或$k$叉有序树；若完全$ k$元树𝑇的兄弟结点之间有序，则称𝑇为有序完全𝒌元树或有序完全$k$叉树。在根树$T$中，任一结点$v$及其所有后代导出的子图$𝑇′$称为$𝑇$的以$v$为根的子树.当然$T^{\prime}$也可以有自己的子树.有序二元树的每个结点$𝑣$至多有两个儿子，分别称为 $𝑣$ 的左儿子和右儿子，至多有两棵子树，分别称为 $𝑣$ 的左子树和右子树。  
注意：以$v$为根的子树包含$𝑣$，而$𝑣$的左右子树则不包含$𝑣$  
【定理9.6】在$k$元完全树中，若叶为𝑡，分支点数为 $i$，则下式成立：  
$(k-1)\times i=t-1~~~~~~~~~~~~~~\quad(9-1)$",根树是一种特殊的有向树，具有唯一的根结点和层次结构
根树,特化,k元根树,,"我们知道无向树是一种由无向图构成的特殊图模型.那么如何定义和处理由有向图构成的有向树模型呢？现在就来讨论这个问题，首先给出如下有向树模型的定义：  
【定义9.4】对于任意一个给定的有向图，如果略去其所有有向边的方向而得到的无向图是一棵树，则该有向图称为一棵有向树。  
![图 9-12 有向树与非有向树  ](images/2fdb86589dcfaa78bb54f5eaf1ee2b9affe960919c61d426d8acd7eff5e51d45.jpg)  
例如，对于图9-12 所示若干有向图，略去其所有边的方向，则由图9-12(a)、（b）得到的无向图都是树，而由图9-12（c）得到的无向图有回路，由图9-12（d）得到的无向图为森林。因此，图9-12（a）、（b）均是有向树，图9-12（c）、（d）均不是有向树。  
从上述定义及例题可以看出，有向树模型的连通性与无环性是由其伴随的无向图模型决定的，或者说是略去边的方向而直接将有向树看成是无向树.这与一般有向图模型的概念和处理方式有很大差异.因此，如果在树模型的框架下讨论有向树中某条或某几条边在方向上的差异，则没有太大意义，甚至有时还会引起概念上的混淆。  
事实上，自然界中的树模型本身就蕴含着一种方向，这种方向体现在由树根、树枝和树叶结点所构成的层次结构当中，由树根、树枝和树叶结点之间在属性上的差异来刻画边的方向性，不过这种边的方向不是个别边的方向而是所有边的整体方向，即从根到叶的方向或从叶到根的方向。对自然界中树模型的上述特征进行抽象，得到如下根树的概念：  
【定义9.5】对于一棵非平凡的有向树，如果恰有一个结点的入度为0，其余所有结点的入度均为1，则称之为根树或外向树.入度为0 的结点称为根结点,简称为根；出度为0 的结点称为叶结点，简称为叶；入度为1，出度大于0 的称为内结点，简称为内点；又将内点和根统称为分支结点，简称为分支点。在根树中，从根到任一结点的通路长度，称为该结点的层数；所有结点的层数最大值称为根树的高。  
通常使用倒置法表示根树，即把根画在最上方，叶画在最下方，有向边的方向均指向下方。例如，图9-13（a）中的有向树就是一棵根树，其中$v_{1}$为根，$v_{5},v_{6},v_{8},v_{9},v_{10},v_{12},v_{13}$为叶，$v_{2},v_{3},v_{4},v_{7},v_{11}$为内点。其中，$v_{1}$处在第0 层，层数为0；$v_{2},v_{3},v_{4}$同处在第一层，层数为1；$v_{5},v_{6},v_{7},v_{8},v_{9}$同处在第二层，层数为2；$v_{10},v_{11},v_{12}$同处在第三层，层数为3；$v_{13}$处在第四层，层数为4；这棵树的高度为4。  
![图9-13 根树的方向与方向省略  ](images/f923bd763ba9a19de150bb3a9be8189594c2d07589f0b79f2493ff5c6c70768a.jpg)  
从根树的定义及上述例题不难发现，根树作为一种特殊的有向树其所有边均是朝着一个方向，即是从根结点到叶结点的方向，如图9-13（a）所示。既然如此就可以对这种特殊的有向图进行化简，即省略根树中所有边的方向将其转化为无向树，如图9-13（b）所示.由此可知，根树其实是一种具有根、枝、叶等层次结构的特殊无向树。  
![图9-14 根树的层次结构  ](images/d86c7aab6ba7ea9d62cfd7298cb652c45b9ae862b8d84a5cb286853843255862.jpg)  
如图9-14 所示，根树是一种由子树不断嵌套而产生的一种层次结构模型，故还可用如下递归的方式定义根树：  
【定义9.6】树是一个$n(n>0)$元有限集，集合中所有数据元素具有如下层次关系：当$n=0$ 时，集合为空集，称之为空树；当$n>0$ 时，集合中有且只有一个特定的结点，称之为树模型的根；当$n>1$ 时，除根以外的其余结点可分为$m(m>0)$个互不相交的有限集$T_{1},T_{2},\cdots,T_{m}$，其中每个集合本身又是一棵树，并称$T_{1},T_{2},\cdots,T_{m}$称为根的子树。  
例如，图9-15 表示一个具体的树模型结构。该树有10 个结点，其中𝐴是根结点，其余结点被分为 3  个互不相交的子集： $T_{1}=\{B,E,F\},T_{2}=\{C,G\},T_{3}=\{D,H,I,J\}$ ； $T_{1}$ ， $T_{2}$ ， $T_{3}$ 都 是 𝐴 的子树，它们本身也分别是一棵树。  
![](images/64aed744b0075ece5ec5a03893d3b845267949822e6760ad07e255b850f44d71.jpg)  
也可用家族关系表示根树中各节点间的关系。  
【定义9.7】在根树中，若从结点$v_{i}$到$v_{j}$可达，则称$v_{i}$是$v_{j}$的祖先，$v_{j}$是$v_{i}$的后代；又若 $\langle v_{i},v_{j}\rangle$是根树中的有向边，则称$v_{i}$是$v_{j}$的父亲，$v_{j}$是$v_{i}$的儿子；如果两个结点是同一个结点的儿子，则称这两个结点是兄弟。  
例如，对于图9-16 所表示的树，结点𝐴 的出度为3，结点$B$的出度为2，结点𝑀的出度为0；结点$A$的孩子为$(B,C,D)$，结点$B$的孩子为$(E,F)$；结点𝐴的层次为1，结点𝑀的层次为4 ； 叶结点有 $(K,L,F,G,M,I,J)$ ， 分枝结点有 $(A,B,C,D,E,H)$ ； 结点 𝐼 的双亲为 $D$ ， 结点 𝐿 的双亲 为$E$；结点$B,C,D$为兄弟，结点$K$，$L$为兄弟；树的高度为4；结点𝐴是结点$F$、$G$的祖先，结点$B$，$C$是结点𝐴的子孙。  
有时还会在根树的同层次的兄弟结点之间规定具体的大小排序，一般是从左到右进行排序，有时也可以用边的次序代替结点的次序。  
在根树的实际应用中，例如对目标的排序与查找等，需要经常对其中间结点的分支数进行度量、设计和分析，为此给出如下关于$\cdot k$元根树或$k$叉根树的概念：  
【定义9.8】 在根树𝑇中，若每个分支点至多有${k}$个儿子，则称𝑇为𝒌元树或𝒌叉树；若每个分支点都恰有${k}$个儿子，则称𝑇为完全$ k$元树或完全$ k$叉树；若$k$元树𝑇的兄弟结点之间有序，则称𝑇为𝒌元有序树或$k$叉有序树；若完全$ k$元树𝑇的兄弟结点之间有序，则称𝑇为有序完全𝒌元树或有序完全$k$叉树。在根树$T$中，任一结点$v$及其所有后代导出的子图$𝑇′$称为$𝑇$的以$v$为根的子树.当然$T^{\prime}$也可以有自己的子树.有序二元树的每个结点$𝑣$至多有两个儿子，分别称为 $𝑣$ 的左儿子和右儿子，至多有两棵子树，分别称为 $𝑣$ 的左子树和右子树。  
注意：以$v$为根的子树包含$𝑣$，而$𝑣$的左右子树则不包含$𝑣$  
【定理9.6】在$k$元完全树中，若叶为𝑡，分支点数为 $i$，则下式成立：  
$(k-1)\times i=t-1~~~~~~~~~~~~~~\quad(9-1)$",k元根树是根树的一种，其中每个分支点至多有k个儿子
k元根树,应用,定理9.6,,"我们知道无向树是一种由无向图构成的特殊图模型.那么如何定义和处理由有向图构成的有向树模型呢？现在就来讨论这个问题，首先给出如下有向树模型的定义：  
【定义9.4】对于任意一个给定的有向图，如果略去其所有有向边的方向而得到的无向图是一棵树，则该有向图称为一棵有向树。  
![图 9-12 有向树与非有向树  ](images/2fdb86589dcfaa78bb54f5eaf1ee2b9affe960919c61d426d8acd7eff5e51d45.jpg)  
例如，对于图9-12 所示若干有向图，略去其所有边的方向，则由图9-12(a)、（b）得到的无向图都是树，而由图9-12（c）得到的无向图有回路，由图9-12（d）得到的无向图为森林。因此，图9-12（a）、（b）均是有向树，图9-12（c）、（d）均不是有向树。  
从上述定义及例题可以看出，有向树模型的连通性与无环性是由其伴随的无向图模型决定的，或者说是略去边的方向而直接将有向树看成是无向树.这与一般有向图模型的概念和处理方式有很大差异.因此，如果在树模型的框架下讨论有向树中某条或某几条边在方向上的差异，则没有太大意义，甚至有时还会引起概念上的混淆。  
事实上，自然界中的树模型本身就蕴含着一种方向，这种方向体现在由树根、树枝和树叶结点所构成的层次结构当中，由树根、树枝和树叶结点之间在属性上的差异来刻画边的方向性，不过这种边的方向不是个别边的方向而是所有边的整体方向，即从根到叶的方向或从叶到根的方向。对自然界中树模型的上述特征进行抽象，得到如下根树的概念：  
【定义9.5】对于一棵非平凡的有向树，如果恰有一个结点的入度为0，其余所有结点的入度均为1，则称之为根树或外向树.入度为0 的结点称为根结点,简称为根；出度为0 的结点称为叶结点，简称为叶；入度为1，出度大于0 的称为内结点，简称为内点；又将内点和根统称为分支结点，简称为分支点。在根树中，从根到任一结点的通路长度，称为该结点的层数；所有结点的层数最大值称为根树的高。  
通常使用倒置法表示根树，即把根画在最上方，叶画在最下方，有向边的方向均指向下方。例如，图9-13（a）中的有向树就是一棵根树，其中$v_{1}$为根，$v_{5},v_{6},v_{8},v_{9},v_{10},v_{12},v_{13}$为叶，$v_{2},v_{3},v_{4},v_{7},v_{11}$为内点。其中，$v_{1}$处在第0 层，层数为0；$v_{2},v_{3},v_{4}$同处在第一层，层数为1；$v_{5},v_{6},v_{7},v_{8},v_{9}$同处在第二层，层数为2；$v_{10},v_{11},v_{12}$同处在第三层，层数为3；$v_{13}$处在第四层，层数为4；这棵树的高度为4。  
![图9-13 根树的方向与方向省略  ](images/f923bd763ba9a19de150bb3a9be8189594c2d07589f0b79f2493ff5c6c70768a.jpg)  
从根树的定义及上述例题不难发现，根树作为一种特殊的有向树其所有边均是朝着一个方向，即是从根结点到叶结点的方向，如图9-13（a）所示。既然如此就可以对这种特殊的有向图进行化简，即省略根树中所有边的方向将其转化为无向树，如图9-13（b）所示.由此可知，根树其实是一种具有根、枝、叶等层次结构的特殊无向树。  
![图9-14 根树的层次结构  ](images/d86c7aab6ba7ea9d62cfd7298cb652c45b9ae862b8d84a5cb286853843255862.jpg)  
如图9-14 所示，根树是一种由子树不断嵌套而产生的一种层次结构模型，故还可用如下递归的方式定义根树：  
【定义9.6】树是一个$n(n>0)$元有限集，集合中所有数据元素具有如下层次关系：当$n=0$ 时，集合为空集，称之为空树；当$n>0$ 时，集合中有且只有一个特定的结点，称之为树模型的根；当$n>1$ 时，除根以外的其余结点可分为$m(m>0)$个互不相交的有限集$T_{1},T_{2},\cdots,T_{m}$，其中每个集合本身又是一棵树，并称$T_{1},T_{2},\cdots,T_{m}$称为根的子树。  
例如，图9-15 表示一个具体的树模型结构。该树有10 个结点，其中𝐴是根结点，其余结点被分为 3  个互不相交的子集： $T_{1}=\{B,E,F\},T_{2}=\{C,G\},T_{3}=\{D,H,I,J\}$ ； $T_{1}$ ， $T_{2}$ ， $T_{3}$ 都 是 𝐴 的子树，它们本身也分别是一棵树。  
![](images/64aed744b0075ece5ec5a03893d3b845267949822e6760ad07e255b850f44d71.jpg)  
也可用家族关系表示根树中各节点间的关系。  
【定义9.7】在根树中，若从结点$v_{i}$到$v_{j}$可达，则称$v_{i}$是$v_{j}$的祖先，$v_{j}$是$v_{i}$的后代；又若 $\langle v_{i},v_{j}\rangle$是根树中的有向边，则称$v_{i}$是$v_{j}$的父亲，$v_{j}$是$v_{i}$的儿子；如果两个结点是同一个结点的儿子，则称这两个结点是兄弟。  
例如，对于图9-16 所表示的树，结点𝐴 的出度为3，结点$B$的出度为2，结点𝑀的出度为0；结点$A$的孩子为$(B,C,D)$，结点$B$的孩子为$(E,F)$；结点𝐴的层次为1，结点𝑀的层次为4 ； 叶结点有 $(K,L,F,G,M,I,J)$ ， 分枝结点有 $(A,B,C,D,E,H)$ ； 结点 𝐼 的双亲为 $D$ ， 结点 𝐿 的双亲 为$E$；结点$B,C,D$为兄弟，结点$K$，$L$为兄弟；树的高度为4；结点𝐴是结点$F$、$G$的祖先，结点$B$，$C$是结点𝐴的子孙。  
有时还会在根树的同层次的兄弟结点之间规定具体的大小排序，一般是从左到右进行排序，有时也可以用边的次序代替结点的次序。  
在根树的实际应用中，例如对目标的排序与查找等，需要经常对其中间结点的分支数进行度量、设计和分析，为此给出如下关于$\cdot k$元根树或$k$叉根树的概念：  
【定义9.8】 在根树𝑇中，若每个分支点至多有${k}$个儿子，则称𝑇为𝒌元树或𝒌叉树；若每个分支点都恰有${k}$个儿子，则称𝑇为完全$ k$元树或完全$ k$叉树；若$k$元树𝑇的兄弟结点之间有序，则称𝑇为𝒌元有序树或$k$叉有序树；若完全$ k$元树𝑇的兄弟结点之间有序，则称𝑇为有序完全𝒌元树或有序完全$k$叉树。在根树$T$中，任一结点$v$及其所有后代导出的子图$𝑇′$称为$𝑇$的以$v$为根的子树.当然$T^{\prime}$也可以有自己的子树.有序二元树的每个结点$𝑣$至多有两个儿子，分别称为 $𝑣$ 的左儿子和右儿子，至多有两棵子树，分别称为 $𝑣$ 的左子树和右子树。  
注意：以$v$为根的子树包含$𝑣$，而$𝑣$的左右子树则不包含$𝑣$  
【定理9.6】在$k$元完全树中，若叶为𝑡，分支点数为 $i$，则下式成立：  
$(k-1)\times i=t-1~~~~~~~~~~~~~~\quad(9-1)$",定理9.6描述了k元完全树中叶和分支点数的关系
根树遍历,包含,先根遍历算法,,"对于根树，一个十分重要的问题是要找到一些方法能系统地访问树的结点，使得每个结点恰好访问一次，这就是根树的遍历问题。由于二元树在计算机中最易处理且任意根树都可转化为二元树，因此在$k$元树中，应用得最广泛的是二元树。下面先介绍二元树的三种常用的遍历方法，然后介绍如何将任意根树转化为二元树。  
二元树的遍历算法主要有先根遍历算法、中根遍历算法和后根次序遍历算法，这三种算法都是采用递归的方式进行：  
先根遍历算法，顾名思义就是首先递归访问根结点；然后递归访问根的左子树，最后，就递归访问根的右子树；中根遍历算法，首先递归访问根的左子树；然后递归访问根结点；最后递归访问根的右子树；后根遍历算法，首先递归访问根的左子树；然后递归访问根的右子树；最后递归访问根结点。",先根遍历算法是根树遍历的一种方法
根树遍历,包含,中根遍历算法,,"对于根树，一个十分重要的问题是要找到一些方法能系统地访问树的结点，使得每个结点恰好访问一次，这就是根树的遍历问题。由于二元树在计算机中最易处理且任意根树都可转化为二元树，因此在$k$元树中，应用得最广泛的是二元树。下面先介绍二元树的三种常用的遍历方法，然后介绍如何将任意根树转化为二元树。  
二元树的遍历算法主要有先根遍历算法、中根遍历算法和后根次序遍历算法，这三种算法都是采用递归的方式进行：  
先根遍历算法，顾名思义就是首先递归访问根结点；然后递归访问根的左子树，最后，就递归访问根的右子树；中根遍历算法，首先递归访问根的左子树；然后递归访问根结点；最后递归访问根的右子树；后根遍历算法，首先递归访问根的左子树；然后递归访问根的右子树；最后递归访问根结点。",中根遍历算法是根树遍历的一种方法
根树遍历,包含,后根遍历算法,,"对于根树，一个十分重要的问题是要找到一些方法能系统地访问树的结点，使得每个结点恰好访问一次，这就是根树的遍历问题。由于二元树在计算机中最易处理且任意根树都可转化为二元树，因此在$k$元树中，应用得最广泛的是二元树。下面先介绍二元树的三种常用的遍历方法，然后介绍如何将任意根树转化为二元树。  
二元树的遍历算法主要有先根遍历算法、中根遍历算法和后根次序遍历算法，这三种算法都是采用递归的方式进行：  
先根遍历算法，顾名思义就是首先递归访问根结点；然后递归访问根的左子树，最后，就递归访问根的右子树；中根遍历算法，首先递归访问根的左子树；然后递归访问根结点；最后递归访问根的右子树；后根遍历算法，首先递归访问根的左子树；然后递归访问根的右子树；最后递归访问根结点。",后根遍历算法是根树遍历的一种方法
先根遍历算法,并列,中根遍历算法,,"对于根树，一个十分重要的问题是要找到一些方法能系统地访问树的结点，使得每个结点恰好访问一次，这就是根树的遍历问题。由于二元树在计算机中最易处理且任意根树都可转化为二元树，因此在$k$元树中，应用得最广泛的是二元树。下面先介绍二元树的三种常用的遍历方法，然后介绍如何将任意根树转化为二元树。  
二元树的遍历算法主要有先根遍历算法、中根遍历算法和后根次序遍历算法，这三种算法都是采用递归的方式进行：  
先根遍历算法，顾名思义就是首先递归访问根结点；然后递归访问根的左子树，最后，就递归访问根的右子树；中根遍历算法，首先递归访问根的左子树；然后递归访问根结点；最后递归访问根的右子树；后根遍历算法，首先递归访问根的左子树；然后递归访问根的右子树；最后递归访问根结点。",先根遍历算法和中根遍历算法都是根树遍历的常用方法
先根遍历算法,并列,后根遍历算法,,"对于根树，一个十分重要的问题是要找到一些方法能系统地访问树的结点，使得每个结点恰好访问一次，这就是根树的遍历问题。由于二元树在计算机中最易处理且任意根树都可转化为二元树，因此在$k$元树中，应用得最广泛的是二元树。下面先介绍二元树的三种常用的遍历方法，然后介绍如何将任意根树转化为二元树。  
二元树的遍历算法主要有先根遍历算法、中根遍历算法和后根次序遍历算法，这三种算法都是采用递归的方式进行：  
先根遍历算法，顾名思义就是首先递归访问根结点；然后递归访问根的左子树，最后，就递归访问根的右子树；中根遍历算法，首先递归访问根的左子树；然后递归访问根结点；最后递归访问根的右子树；后根遍历算法，首先递归访问根的左子树；然后递归访问根的右子树；最后递归访问根结点。",先根遍历算法和后根遍历算法都是根树遍历的常用方法
中根遍历算法,并列,后根遍历算法,,"对于根树，一个十分重要的问题是要找到一些方法能系统地访问树的结点，使得每个结点恰好访问一次，这就是根树的遍历问题。由于二元树在计算机中最易处理且任意根树都可转化为二元树，因此在$k$元树中，应用得最广泛的是二元树。下面先介绍二元树的三种常用的遍历方法，然后介绍如何将任意根树转化为二元树。  
二元树的遍历算法主要有先根遍历算法、中根遍历算法和后根次序遍历算法，这三种算法都是采用递归的方式进行：  
先根遍历算法，顾名思义就是首先递归访问根结点；然后递归访问根的左子树，最后，就递归访问根的右子树；中根遍历算法，首先递归访问根的左子树；然后递归访问根结点；最后递归访问根的右子树；后根遍历算法，首先递归访问根的左子树；然后递归访问根的右子树；最后递归访问根结点。",中根遍历算法和后根遍历算法都是根树遍历的常用方法
前缀码,生成,最优树,,"在计算机及通信技术中，常用二进制编码来表示符号，称之为码字。例如，可用00、01、10、11 分别表示字母A、B、C、D。如果字母A、B、C、D 出现的频率是一样的，则传输100 个字母会使用200 个二进制位。但实际上字母出现的频率很不一样，比如A 出现的频率为$60\%$，B 出现的频率为$25\%$，C 出现的频率为$10\%$，D 出现的频率为$5\%$。能否用不等长的二进制序列表示字母A、B、C、D，使传输的信息的二进制位尽可能少呢？  
事实上，可用000 表示字母D，用001 表示字母C，01 表示B，1 表示A。此时，传输100 个字母所用的二进制位为：  
$$
3\times5+3\times10+2\times25+1\times60=155
$$  
这种表示比用等长的二进制序列表示法好，节省了二进制位。  
在编码时还要考虑一个问题，就是二进制序列的分词问题。例如，如果用1 表示A，用00 表示B，用001 表示C，用000 表示D 时，那么在接收到信息001000 时，则无法辨别它是CD 还是BAD。因此，在使用二进制序列表示A、B、C、D 等字母时，需要一些特定的编码策略以避免出现类似容易混淆的情况。为此引入如下前缀及前缀码的概念：  
【定义9.9】设$a_{1}a_{2}\cdots a_{n-1}a_{n}$是长度为$n$的符号串，则称其子串$a_{1},a_{1}a_{2},a_{1}a_{2}a_{3},\cdots\,,$,$a_{1}a_{2}\cdots a_{n-1}$分别为$a_{1}a_{2}\cdots a_{n-1}a_{n}$的长度为1，2，⋯，$n-1$的前缀。  
【定义9.10】设$A=\{b_{1},b_{2},\cdots,b_{m}\}$是一个符号串集合，若对任意$b_{i}$，$b_{j}\in A$，$b_{i}\neq$$b_{j}$，$b_{i}$不是$.b_{j}$的前缀，$b_{j}$也不是$b_{i}$的前缀，则称𝐴为前缀码。若在符号串$b_{i}\bigl(i=1,2,\cdots,\ \mathsf{m}\bigr)$中，只出现0 和1 两个符号，则称𝐴为二元前缀码,在不引起混淆时简称为前缀码。  
例如{1，01，001，000}是前缀码，而{1，11，001，0011}不是前缀码。那么如何产生前缀码呢？事实上，可用一棵二元树来产生一个二元前缀码：  
给定一棵有𝑡片叶二元树𝑇。设$v$是𝑇的任一分支点，则$v$至少一个儿子至多两个儿子。若𝑣有两个儿子，则在由𝑣引出的两条边上，左边的标0，右边的标1；若$v$只有一个儿子，在$v$引出的边上可标0 也可标1。设${v}_{i}$为𝑇的任意一片叶，从树根到$v_{i}$的通路上各边的标号组成的符号串放在$v_{i}$处，$t$片叶处的𝑡个符号串组成的集合为一个二元前缀码。  
由上述做法可知，$v_{i}$中符号串的前缀码均在${v}_{i}$所在通路上，因而所得集合为0 和1 组成前缀码。显然，若𝑇存在带一个儿子的分支点，则𝑇产生不唯一的前缀码， 𝑇若为二元完全树，则𝑇产生唯一的前缀码。例如，图9-26 所示二元树产生的前缀码为：  
![](images/0e364ce62d589d6e701c3aee01259a3ff2b2c5a6aebc38eaf711e5ecde762552.jpg)  
![](images/c850aef1e068c66827fea6f4c98a09846df47e5a769a3618a27f7a6bb63e479e.jpg)  
【定义9.11】设有一棵二元树𝑇，若对其所以的𝑡片叶赋以权值$w_{1},w_{2},\cdots,w_{t}$，则称之为赋权二元树；若权为$w_{i}$的叶的层数为$L(w_{i})$，则称：  
$$
w(T)=\sum_{i=1}^{t}w_{i}\times L(w_{i})
$$  
为该赋权二元树 𝑇 的权；   $w(T)$ 最小的二元树称为最优树。  
下面的定理9.7 给出了构造最优树的一个基本思路：  
【定理9.7】假设𝑇是一棵带有权值为$|w_{1}\leq w_{2}\leq\cdots\leq w_{t}$二元最优树。其中权$w_{1}$和$w_{2}$所对应叶结点必定是兄弟，并且如果将其父结点由分支结点改为带权$w_{1}+w_{2}$的叶结点，则由此得到的一棵新树$T^{\prime}$也是一棵最优树。  
根据上述定理，美国计算机科学家霍夫曼在1952 年提出一种构造最优树的算法，通常称之为霍夫曼算法。对于任意给定的权值 $w_{1}\leq w_{2}\leq\cdots\leq w_{t}$，算法的基本思路是：要画一棵带有$t$个权的最优树，则可依据定理9.7 将问题转化为要画一棵带有𝑡−1个权的最优树，依次类推.具体做法是：首先找出两个最小的权值设为$w_{1}$和$w_{2}$，然后对𝑡−1个权$w_{1}+$$w_{2},w_{3},\cdots,w_{t}$求作最优树，并将这棵最优树中权$w_{1}+w_{2}$对应的叶结点分叉出两个儿子，依次类推，直到只有一个权值的最优树的情形.具体算法过程如下：  
（1）初始：令${\cal{S}}=\{w_{1},w_{2},\cdots,\}$ ;  
（2）从𝑆中取出两个最小的权$w_{i}$和$w_{j}$，画结点$v_{i}$，带权$w_{i}$，画结点$v_{j}$，带权$w_{j}$。画$v_{i}$和$v_{j}$的父亲$v$，连接$v_{i}$和$v$，$v_{j}$和$v$，令$v$带权$.w_{i}+w_{j}$；  
（3）令$S=\left(S-\left\{w_{i},w_{j}\right\}\right)\cup\{w_{i}+w_{j}\};$  
（4）判断𝑆是否只含一个元素。若是，则停止，否则转（2）。  
从上述算法过程可以看出，霍夫曼算法采用递推的方式构造最优树，核心思想是逐步从从带权为$w_{1}+w_{2},w_{3},\cdots,w_{t}$的最优树${T^{\prime}}$中得到带权为$w_{1}$，$w_{2}$，⋯，$w_{t}$的最优树。  
下面结合具体实例介绍最优树的具体构造过程：",前缀码可以通过一棵二元树生成，特别是通过最优树生成的二元前缀码具有唯一性
霍夫曼算法,构造,最优树,,"在计算机及通信技术中，常用二进制编码来表示符号，称之为码字。例如，可用00、01、10、11 分别表示字母A、B、C、D。如果字母A、B、C、D 出现的频率是一样的，则传输100 个字母会使用200 个二进制位。但实际上字母出现的频率很不一样，比如A 出现的频率为$60\%$，B 出现的频率为$25\%$，C 出现的频率为$10\%$，D 出现的频率为$5\%$。能否用不等长的二进制序列表示字母A、B、C、D，使传输的信息的二进制位尽可能少呢？  
事实上，可用000 表示字母D，用001 表示字母C，01 表示B，1 表示A。此时，传输100 个字母所用的二进制位为：  
$$
3\times5+3\times10+2\times25+1\times60=155
$$  
这种表示比用等长的二进制序列表示法好，节省了二进制位。  
在编码时还要考虑一个问题，就是二进制序列的分词问题。例如，如果用1 表示A，用00 表示B，用001 表示C，用000 表示D 时，那么在接收到信息001000 时，则无法辨别它是CD 还是BAD。因此，在使用二进制序列表示A、B、C、D 等字母时，需要一些特定的编码策略以避免出现类似容易混淆的情况。为此引入如下前缀及前缀码的概念：  
【定义9.9】设$a_{1}a_{2}\cdots a_{n-1}a_{n}$是长度为$n$的符号串，则称其子串$a_{1},a_{1}a_{2},a_{1}a_{2}a_{3},\cdots\,,$,$a_{1}a_{2}\cdots a_{n-1}$分别为$a_{1}a_{2}\cdots a_{n-1}a_{n}$的长度为1，2，⋯，$n-1$的前缀。  
【定义9.10】设$A=\{b_{1},b_{2},\cdots,b_{m}\}$是一个符号串集合，若对任意$b_{i}$，$b_{j}\in A$，$b_{i}\neq$$b_{j}$，$b_{i}$不是$.b_{j}$的前缀，$b_{j}$也不是$b_{i}$的前缀，则称𝐴为前缀码。若在符号串$b_{i}\bigl(i=1,2,\cdots,\ \mathsf{m}\bigr)$中，只出现0 和1 两个符号，则称𝐴为二元前缀码,在不引起混淆时简称为前缀码。  
例如{1，01，001，000}是前缀码，而{1，11，001，0011}不是前缀码。那么如何产生前缀码呢？事实上，可用一棵二元树来产生一个二元前缀码：  
给定一棵有𝑡片叶二元树𝑇。设$v$是𝑇的任一分支点，则$v$至少一个儿子至多两个儿子。若𝑣有两个儿子，则在由𝑣引出的两条边上，左边的标0，右边的标1；若$v$只有一个儿子，在$v$引出的边上可标0 也可标1。设${v}_{i}$为𝑇的任意一片叶，从树根到$v_{i}$的通路上各边的标号组成的符号串放在$v_{i}$处，$t$片叶处的𝑡个符号串组成的集合为一个二元前缀码。  
由上述做法可知，$v_{i}$中符号串的前缀码均在${v}_{i}$所在通路上，因而所得集合为0 和1 组成前缀码。显然，若𝑇存在带一个儿子的分支点，则𝑇产生不唯一的前缀码， 𝑇若为二元完全树，则𝑇产生唯一的前缀码。例如，图9-26 所示二元树产生的前缀码为：  
![](images/0e364ce62d589d6e701c3aee01259a3ff2b2c5a6aebc38eaf711e5ecde762552.jpg)  
![](images/c850aef1e068c66827fea6f4c98a09846df47e5a769a3618a27f7a6bb63e479e.jpg)  
【定义9.11】设有一棵二元树𝑇，若对其所以的𝑡片叶赋以权值$w_{1},w_{2},\cdots,w_{t}$，则称之为赋权二元树；若权为$w_{i}$的叶的层数为$L(w_{i})$，则称：  
$$
w(T)=\sum_{i=1}^{t}w_{i}\times L(w_{i})
$$  
为该赋权二元树 𝑇 的权；   $w(T)$ 最小的二元树称为最优树。  
下面的定理9.7 给出了构造最优树的一个基本思路：  
【定理9.7】假设𝑇是一棵带有权值为$|w_{1}\leq w_{2}\leq\cdots\leq w_{t}$二元最优树。其中权$w_{1}$和$w_{2}$所对应叶结点必定是兄弟，并且如果将其父结点由分支结点改为带权$w_{1}+w_{2}$的叶结点，则由此得到的一棵新树$T^{\prime}$也是一棵最优树。  
根据上述定理，美国计算机科学家霍夫曼在1952 年提出一种构造最优树的算法，通常称之为霍夫曼算法。对于任意给定的权值 $w_{1}\leq w_{2}\leq\cdots\leq w_{t}$，算法的基本思路是：要画一棵带有$t$个权的最优树，则可依据定理9.7 将问题转化为要画一棵带有𝑡−1个权的最优树，依次类推.具体做法是：首先找出两个最小的权值设为$w_{1}$和$w_{2}$，然后对𝑡−1个权$w_{1}+$$w_{2},w_{3},\cdots,w_{t}$求作最优树，并将这棵最优树中权$w_{1}+w_{2}$对应的叶结点分叉出两个儿子，依次类推，直到只有一个权值的最优树的情形.具体算法过程如下：  
（1）初始：令${\cal{S}}=\{w_{1},w_{2},\cdots,\}$ ;  
（2）从𝑆中取出两个最小的权$w_{i}$和$w_{j}$，画结点$v_{i}$，带权$w_{i}$，画结点$v_{j}$，带权$w_{j}$。画$v_{i}$和$v_{j}$的父亲$v$，连接$v_{i}$和$v$，$v_{j}$和$v$，令$v$带权$.w_{i}+w_{j}$；  
（3）令$S=\left(S-\left\{w_{i},w_{j}\right\}\right)\cup\{w_{i}+w_{j}\};$  
（4）判断𝑆是否只含一个元素。若是，则停止，否则转（2）。  
从上述算法过程可以看出，霍夫曼算法采用递推的方式构造最优树，核心思想是逐步从从带权为$w_{1}+w_{2},w_{3},\cdots,w_{t}$的最优树${T^{\prime}}$中得到带权为$w_{1}$，$w_{2}$，⋯，$w_{t}$的最优树。  
下面结合具体实例介绍最优树的具体构造过程：",霍夫曼算法用于构造最优树，通过递推方式逐步生成带权最优树
定理9.7,基础,最优树,,"在计算机及通信技术中，常用二进制编码来表示符号，称之为码字。例如，可用00、01、10、11 分别表示字母A、B、C、D。如果字母A、B、C、D 出现的频率是一样的，则传输100 个字母会使用200 个二进制位。但实际上字母出现的频率很不一样，比如A 出现的频率为$60\%$，B 出现的频率为$25\%$，C 出现的频率为$10\%$，D 出现的频率为$5\%$。能否用不等长的二进制序列表示字母A、B、C、D，使传输的信息的二进制位尽可能少呢？  
事实上，可用000 表示字母D，用001 表示字母C，01 表示B，1 表示A。此时，传输100 个字母所用的二进制位为：  
$$
3\times5+3\times10+2\times25+1\times60=155
$$  
这种表示比用等长的二进制序列表示法好，节省了二进制位。  
在编码时还要考虑一个问题，就是二进制序列的分词问题。例如，如果用1 表示A，用00 表示B，用001 表示C，用000 表示D 时，那么在接收到信息001000 时，则无法辨别它是CD 还是BAD。因此，在使用二进制序列表示A、B、C、D 等字母时，需要一些特定的编码策略以避免出现类似容易混淆的情况。为此引入如下前缀及前缀码的概念：  
【定义9.9】设$a_{1}a_{2}\cdots a_{n-1}a_{n}$是长度为$n$的符号串，则称其子串$a_{1},a_{1}a_{2},a_{1}a_{2}a_{3},\cdots\,,$,$a_{1}a_{2}\cdots a_{n-1}$分别为$a_{1}a_{2}\cdots a_{n-1}a_{n}$的长度为1，2，⋯，$n-1$的前缀。  
【定义9.10】设$A=\{b_{1},b_{2},\cdots,b_{m}\}$是一个符号串集合，若对任意$b_{i}$，$b_{j}\in A$，$b_{i}\neq$$b_{j}$，$b_{i}$不是$.b_{j}$的前缀，$b_{j}$也不是$b_{i}$的前缀，则称𝐴为前缀码。若在符号串$b_{i}\bigl(i=1,2,\cdots,\ \mathsf{m}\bigr)$中，只出现0 和1 两个符号，则称𝐴为二元前缀码,在不引起混淆时简称为前缀码。  
例如{1，01，001，000}是前缀码，而{1，11，001，0011}不是前缀码。那么如何产生前缀码呢？事实上，可用一棵二元树来产生一个二元前缀码：  
给定一棵有𝑡片叶二元树𝑇。设$v$是𝑇的任一分支点，则$v$至少一个儿子至多两个儿子。若𝑣有两个儿子，则在由𝑣引出的两条边上，左边的标0，右边的标1；若$v$只有一个儿子，在$v$引出的边上可标0 也可标1。设${v}_{i}$为𝑇的任意一片叶，从树根到$v_{i}$的通路上各边的标号组成的符号串放在$v_{i}$处，$t$片叶处的𝑡个符号串组成的集合为一个二元前缀码。  
由上述做法可知，$v_{i}$中符号串的前缀码均在${v}_{i}$所在通路上，因而所得集合为0 和1 组成前缀码。显然，若𝑇存在带一个儿子的分支点，则𝑇产生不唯一的前缀码， 𝑇若为二元完全树，则𝑇产生唯一的前缀码。例如，图9-26 所示二元树产生的前缀码为：  
![](images/0e364ce62d589d6e701c3aee01259a3ff2b2c5a6aebc38eaf711e5ecde762552.jpg)  
![](images/c850aef1e068c66827fea6f4c98a09846df47e5a769a3618a27f7a6bb63e479e.jpg)  
【定义9.11】设有一棵二元树𝑇，若对其所以的𝑡片叶赋以权值$w_{1},w_{2},\cdots,w_{t}$，则称之为赋权二元树；若权为$w_{i}$的叶的层数为$L(w_{i})$，则称：  
$$
w(T)=\sum_{i=1}^{t}w_{i}\times L(w_{i})
$$  
为该赋权二元树 𝑇 的权；   $w(T)$ 最小的二元树称为最优树。  
下面的定理9.7 给出了构造最优树的一个基本思路：  
【定理9.7】假设𝑇是一棵带有权值为$|w_{1}\leq w_{2}\leq\cdots\leq w_{t}$二元最优树。其中权$w_{1}$和$w_{2}$所对应叶结点必定是兄弟，并且如果将其父结点由分支结点改为带权$w_{1}+w_{2}$的叶结点，则由此得到的一棵新树$T^{\prime}$也是一棵最优树。  
根据上述定理，美国计算机科学家霍夫曼在1952 年提出一种构造最优树的算法，通常称之为霍夫曼算法。对于任意给定的权值 $w_{1}\leq w_{2}\leq\cdots\leq w_{t}$，算法的基本思路是：要画一棵带有$t$个权的最优树，则可依据定理9.7 将问题转化为要画一棵带有𝑡−1个权的最优树，依次类推.具体做法是：首先找出两个最小的权值设为$w_{1}$和$w_{2}$，然后对𝑡−1个权$w_{1}+$$w_{2},w_{3},\cdots,w_{t}$求作最优树，并将这棵最优树中权$w_{1}+w_{2}$对应的叶结点分叉出两个儿子，依次类推，直到只有一个权值的最优树的情形.具体算法过程如下：  
（1）初始：令${\cal{S}}=\{w_{1},w_{2},\cdots,\}$ ;  
（2）从𝑆中取出两个最小的权$w_{i}$和$w_{j}$，画结点$v_{i}$，带权$w_{i}$，画结点$v_{j}$，带权$w_{j}$。画$v_{i}$和$v_{j}$的父亲$v$，连接$v_{i}$和$v$，$v_{j}$和$v$，令$v$带权$.w_{i}+w_{j}$；  
（3）令$S=\left(S-\left\{w_{i},w_{j}\right\}\right)\cup\{w_{i}+w_{j}\};$  
（4）判断𝑆是否只含一个元素。若是，则停止，否则转（2）。  
从上述算法过程可以看出，霍夫曼算法采用递推的方式构造最优树，核心思想是逐步从从带权为$w_{1}+w_{2},w_{3},\cdots,w_{t}$的最优树${T^{\prime}}$中得到带权为$w_{1}$，$w_{2}$，⋯，$w_{t}$的最优树。  
下面结合具体实例介绍最优树的具体构造过程：",定理9.7提供了构造最优树的基本思路，是霍夫曼算法的理论基础
霍夫曼算法,依据,定理9.7,,"在计算机及通信技术中，常用二进制编码来表示符号，称之为码字。例如，可用00、01、10、11 分别表示字母A、B、C、D。如果字母A、B、C、D 出现的频率是一样的，则传输100 个字母会使用200 个二进制位。但实际上字母出现的频率很不一样，比如A 出现的频率为$60\%$，B 出现的频率为$25\%$，C 出现的频率为$10\%$，D 出现的频率为$5\%$。能否用不等长的二进制序列表示字母A、B、C、D，使传输的信息的二进制位尽可能少呢？  
事实上，可用000 表示字母D，用001 表示字母C，01 表示B，1 表示A。此时，传输100 个字母所用的二进制位为：  
$$
3\times5+3\times10+2\times25+1\times60=155
$$  
这种表示比用等长的二进制序列表示法好，节省了二进制位。  
在编码时还要考虑一个问题，就是二进制序列的分词问题。例如，如果用1 表示A，用00 表示B，用001 表示C，用000 表示D 时，那么在接收到信息001000 时，则无法辨别它是CD 还是BAD。因此，在使用二进制序列表示A、B、C、D 等字母时，需要一些特定的编码策略以避免出现类似容易混淆的情况。为此引入如下前缀及前缀码的概念：  
【定义9.9】设$a_{1}a_{2}\cdots a_{n-1}a_{n}$是长度为$n$的符号串，则称其子串$a_{1},a_{1}a_{2},a_{1}a_{2}a_{3},\cdots\,,$,$a_{1}a_{2}\cdots a_{n-1}$分别为$a_{1}a_{2}\cdots a_{n-1}a_{n}$的长度为1，2，⋯，$n-1$的前缀。  
【定义9.10】设$A=\{b_{1},b_{2},\cdots,b_{m}\}$是一个符号串集合，若对任意$b_{i}$，$b_{j}\in A$，$b_{i}\neq$$b_{j}$，$b_{i}$不是$.b_{j}$的前缀，$b_{j}$也不是$b_{i}$的前缀，则称𝐴为前缀码。若在符号串$b_{i}\bigl(i=1,2,\cdots,\ \mathsf{m}\bigr)$中，只出现0 和1 两个符号，则称𝐴为二元前缀码,在不引起混淆时简称为前缀码。  
例如{1，01，001，000}是前缀码，而{1，11，001，0011}不是前缀码。那么如何产生前缀码呢？事实上，可用一棵二元树来产生一个二元前缀码：  
给定一棵有𝑡片叶二元树𝑇。设$v$是𝑇的任一分支点，则$v$至少一个儿子至多两个儿子。若𝑣有两个儿子，则在由𝑣引出的两条边上，左边的标0，右边的标1；若$v$只有一个儿子，在$v$引出的边上可标0 也可标1。设${v}_{i}$为𝑇的任意一片叶，从树根到$v_{i}$的通路上各边的标号组成的符号串放在$v_{i}$处，$t$片叶处的𝑡个符号串组成的集合为一个二元前缀码。  
由上述做法可知，$v_{i}$中符号串的前缀码均在${v}_{i}$所在通路上，因而所得集合为0 和1 组成前缀码。显然，若𝑇存在带一个儿子的分支点，则𝑇产生不唯一的前缀码， 𝑇若为二元完全树，则𝑇产生唯一的前缀码。例如，图9-26 所示二元树产生的前缀码为：  
![](images/0e364ce62d589d6e701c3aee01259a3ff2b2c5a6aebc38eaf711e5ecde762552.jpg)  
![](images/c850aef1e068c66827fea6f4c98a09846df47e5a769a3618a27f7a6bb63e479e.jpg)  
【定义9.11】设有一棵二元树𝑇，若对其所以的𝑡片叶赋以权值$w_{1},w_{2},\cdots,w_{t}$，则称之为赋权二元树；若权为$w_{i}$的叶的层数为$L(w_{i})$，则称：  
$$
w(T)=\sum_{i=1}^{t}w_{i}\times L(w_{i})
$$  
为该赋权二元树 𝑇 的权；   $w(T)$ 最小的二元树称为最优树。  
下面的定理9.7 给出了构造最优树的一个基本思路：  
【定理9.7】假设𝑇是一棵带有权值为$|w_{1}\leq w_{2}\leq\cdots\leq w_{t}$二元最优树。其中权$w_{1}$和$w_{2}$所对应叶结点必定是兄弟，并且如果将其父结点由分支结点改为带权$w_{1}+w_{2}$的叶结点，则由此得到的一棵新树$T^{\prime}$也是一棵最优树。  
根据上述定理，美国计算机科学家霍夫曼在1952 年提出一种构造最优树的算法，通常称之为霍夫曼算法。对于任意给定的权值 $w_{1}\leq w_{2}\leq\cdots\leq w_{t}$，算法的基本思路是：要画一棵带有$t$个权的最优树，则可依据定理9.7 将问题转化为要画一棵带有𝑡−1个权的最优树，依次类推.具体做法是：首先找出两个最小的权值设为$w_{1}$和$w_{2}$，然后对𝑡−1个权$w_{1}+$$w_{2},w_{3},\cdots,w_{t}$求作最优树，并将这棵最优树中权$w_{1}+w_{2}$对应的叶结点分叉出两个儿子，依次类推，直到只有一个权值的最优树的情形.具体算法过程如下：  
（1）初始：令${\cal{S}}=\{w_{1},w_{2},\cdots,\}$ ;  
（2）从𝑆中取出两个最小的权$w_{i}$和$w_{j}$，画结点$v_{i}$，带权$w_{i}$，画结点$v_{j}$，带权$w_{j}$。画$v_{i}$和$v_{j}$的父亲$v$，连接$v_{i}$和$v$，$v_{j}$和$v$，令$v$带权$.w_{i}+w_{j}$；  
（3）令$S=\left(S-\left\{w_{i},w_{j}\right\}\right)\cup\{w_{i}+w_{j}\};$  
（4）判断𝑆是否只含一个元素。若是，则停止，否则转（2）。  
从上述算法过程可以看出，霍夫曼算法采用递推的方式构造最优树，核心思想是逐步从从带权为$w_{1}+w_{2},w_{3},\cdots,w_{t}$的最优树${T^{\prime}}$中得到带权为$w_{1}$，$w_{2}$，⋯，$w_{t}$的最优树。  
下面结合具体实例介绍最优树的具体构造过程：",霍夫曼算法依据定理9.7进行最优树的构造
根树,包含,平衡树模型,,根树是一类非常重要的树模型，能够对很多复杂的数据信息进行表示和处理，广泛应用于程序设计、数据结构、算法设计与分析、操作系统等多门后续课程。根树的种类很多，可以针对不同类型的问题或数据建立相应类型的根树模型。本节着重介绍三种最为典型的特殊根树模型，即平衡树模型、红黑树模型和𝐵树模型，并分析和讨论这些模型的插入、删除、更改、旋转等基本算法，旨在为后续相关专业课程的学习打下良好的基础。,平衡树模型是根树的一种特殊类型
根树,包含,红黑树模型,,根树是一类非常重要的树模型，能够对很多复杂的数据信息进行表示和处理，广泛应用于程序设计、数据结构、算法设计与分析、操作系统等多门后续课程。根树的种类很多，可以针对不同类型的问题或数据建立相应类型的根树模型。本节着重介绍三种最为典型的特殊根树模型，即平衡树模型、红黑树模型和𝐵树模型，并分析和讨论这些模型的插入、删除、更改、旋转等基本算法，旨在为后续相关专业课程的学习打下良好的基础。,红黑树模型是根树的一种特殊类型
根树,包含,B树模型,,根树是一类非常重要的树模型，能够对很多复杂的数据信息进行表示和处理，广泛应用于程序设计、数据结构、算法设计与分析、操作系统等多门后续课程。根树的种类很多，可以针对不同类型的问题或数据建立相应类型的根树模型。本节着重介绍三种最为典型的特殊根树模型，即平衡树模型、红黑树模型和𝐵树模型，并分析和讨论这些模型的插入、删除、更改、旋转等基本算法，旨在为后续相关专业课程的学习打下良好的基础。,B树模型是根树的一种特殊类型
平衡树模型,应用,插入算法,,根树是一类非常重要的树模型，能够对很多复杂的数据信息进行表示和处理，广泛应用于程序设计、数据结构、算法设计与分析、操作系统等多门后续课程。根树的种类很多，可以针对不同类型的问题或数据建立相应类型的根树模型。本节着重介绍三种最为典型的特殊根树模型，即平衡树模型、红黑树模型和𝐵树模型，并分析和讨论这些模型的插入、删除、更改、旋转等基本算法，旨在为后续相关专业课程的学习打下良好的基础。,平衡树模型应用插入算法
平衡树模型,应用,删除算法,,根树是一类非常重要的树模型，能够对很多复杂的数据信息进行表示和处理，广泛应用于程序设计、数据结构、算法设计与分析、操作系统等多门后续课程。根树的种类很多，可以针对不同类型的问题或数据建立相应类型的根树模型。本节着重介绍三种最为典型的特殊根树模型，即平衡树模型、红黑树模型和𝐵树模型，并分析和讨论这些模型的插入、删除、更改、旋转等基本算法，旨在为后续相关专业课程的学习打下良好的基础。,平衡树模型应用删除算法
平衡树模型,应用,更改算法,,根树是一类非常重要的树模型，能够对很多复杂的数据信息进行表示和处理，广泛应用于程序设计、数据结构、算法设计与分析、操作系统等多门后续课程。根树的种类很多，可以针对不同类型的问题或数据建立相应类型的根树模型。本节着重介绍三种最为典型的特殊根树模型，即平衡树模型、红黑树模型和𝐵树模型，并分析和讨论这些模型的插入、删除、更改、旋转等基本算法，旨在为后续相关专业课程的学习打下良好的基础。,平衡树模型应用更改算法
平衡树模型,应用,旋转算法,,根树是一类非常重要的树模型，能够对很多复杂的数据信息进行表示和处理，广泛应用于程序设计、数据结构、算法设计与分析、操作系统等多门后续课程。根树的种类很多，可以针对不同类型的问题或数据建立相应类型的根树模型。本节着重介绍三种最为典型的特殊根树模型，即平衡树模型、红黑树模型和𝐵树模型，并分析和讨论这些模型的插入、删除、更改、旋转等基本算法，旨在为后续相关专业课程的学习打下良好的基础。,平衡树模型应用旋转算法
红黑树模型,应用,插入算法,,根树是一类非常重要的树模型，能够对很多复杂的数据信息进行表示和处理，广泛应用于程序设计、数据结构、算法设计与分析、操作系统等多门后续课程。根树的种类很多，可以针对不同类型的问题或数据建立相应类型的根树模型。本节着重介绍三种最为典型的特殊根树模型，即平衡树模型、红黑树模型和𝐵树模型，并分析和讨论这些模型的插入、删除、更改、旋转等基本算法，旨在为后续相关专业课程的学习打下良好的基础。,红黑树模型应用插入算法
红黑树模型,应用,删除算法,,根树是一类非常重要的树模型，能够对很多复杂的数据信息进行表示和处理，广泛应用于程序设计、数据结构、算法设计与分析、操作系统等多门后续课程。根树的种类很多，可以针对不同类型的问题或数据建立相应类型的根树模型。本节着重介绍三种最为典型的特殊根树模型，即平衡树模型、红黑树模型和𝐵树模型，并分析和讨论这些模型的插入、删除、更改、旋转等基本算法，旨在为后续相关专业课程的学习打下良好的基础。,红黑树模型应用删除算法
红黑树模型,应用,更改算法,,根树是一类非常重要的树模型，能够对很多复杂的数据信息进行表示和处理，广泛应用于程序设计、数据结构、算法设计与分析、操作系统等多门后续课程。根树的种类很多，可以针对不同类型的问题或数据建立相应类型的根树模型。本节着重介绍三种最为典型的特殊根树模型，即平衡树模型、红黑树模型和𝐵树模型，并分析和讨论这些模型的插入、删除、更改、旋转等基本算法，旨在为后续相关专业课程的学习打下良好的基础。,红黑树模型应用更改算法
红黑树模型,应用,旋转算法,,根树是一类非常重要的树模型，能够对很多复杂的数据信息进行表示和处理，广泛应用于程序设计、数据结构、算法设计与分析、操作系统等多门后续课程。根树的种类很多，可以针对不同类型的问题或数据建立相应类型的根树模型。本节着重介绍三种最为典型的特殊根树模型，即平衡树模型、红黑树模型和𝐵树模型，并分析和讨论这些模型的插入、删除、更改、旋转等基本算法，旨在为后续相关专业课程的学习打下良好的基础。,红黑树模型应用旋转算法
B树模型,应用,插入算法,,根树是一类非常重要的树模型，能够对很多复杂的数据信息进行表示和处理，广泛应用于程序设计、数据结构、算法设计与分析、操作系统等多门后续课程。根树的种类很多，可以针对不同类型的问题或数据建立相应类型的根树模型。本节着重介绍三种最为典型的特殊根树模型，即平衡树模型、红黑树模型和𝐵树模型，并分析和讨论这些模型的插入、删除、更改、旋转等基本算法，旨在为后续相关专业课程的学习打下良好的基础。,B树模型应用插入算法
B树模型,应用,删除算法,,根树是一类非常重要的树模型，能够对很多复杂的数据信息进行表示和处理，广泛应用于程序设计、数据结构、算法设计与分析、操作系统等多门后续课程。根树的种类很多，可以针对不同类型的问题或数据建立相应类型的根树模型。本节着重介绍三种最为典型的特殊根树模型，即平衡树模型、红黑树模型和𝐵树模型，并分析和讨论这些模型的插入、删除、更改、旋转等基本算法，旨在为后续相关专业课程的学习打下良好的基础。,B树模型应用删除算法
B树模型,应用,更改算法,,根树是一类非常重要的树模型，能够对很多复杂的数据信息进行表示和处理，广泛应用于程序设计、数据结构、算法设计与分析、操作系统等多门后续课程。根树的种类很多，可以针对不同类型的问题或数据建立相应类型的根树模型。本节着重介绍三种最为典型的特殊根树模型，即平衡树模型、红黑树模型和𝐵树模型，并分析和讨论这些模型的插入、删除、更改、旋转等基本算法，旨在为后续相关专业课程的学习打下良好的基础。,B树模型应用更改算法
B树模型,应用,旋转算法,,根树是一类非常重要的树模型，能够对很多复杂的数据信息进行表示和处理，广泛应用于程序设计、数据结构、算法设计与分析、操作系统等多门后续课程。根树的种类很多，可以针对不同类型的问题或数据建立相应类型的根树模型。本节着重介绍三种最为典型的特殊根树模型，即平衡树模型、红黑树模型和𝐵树模型，并分析和讨论这些模型的插入、删除、更改、旋转等基本算法，旨在为后续相关专业课程的学习打下良好的基础。,B树模型应用旋转算法
平衡二叉树,定义,平衡因子,,"对于二叉树的一些基本操作，比如插入、删除和查找等，其算法时间复杂度都与树的高度有关。因此，适当控制树高是一个非常关键的问题。显然，控制树高的一个有效措施就是尽量保持树的左右子树高度大致平衡，由此产生平衡二叉树的概念。  
平衡二叉树是一种特殊的二叉树，要求树中任何结点的两棵子树高度差不能超过1，如果插入或者删除一个结点使得高度之差大于1，就要进行结点之间的旋转操作，将二叉树重新维持在一个平衡状态。  
平衡二叉树是一种非常重要的树模型，因为它可以保证一些在树上的基本操作具有较好的最坏情况性能，这使它在信息查找等很多场合有着十分重要的作用。后面将会详细介绍平衡二叉树的若干特例，如红黑树、$B$树等。  
平衡二叉树的操作主要有查找、插入和删除结点等。其中插入和删除结点操作可能需要通过一次或多次旋转操作来重新平衡该树，使其满足平衡二叉树的要求。下面简要介绍有关平衡二叉树的一些基本概念和操作。  
树模型中某结点左子树的高度减去该结点右子树的高度，所形成的差值称为该结点的平衡因子，即$\mathrm{Balance~Fector(BF)=}$左子树的高度-右子树的高度。  
平衡二叉树的平衡因子为-1，0 或1。设计平衡二叉树操作算法的关键在于如何使得平衡二叉树保持平衡。以下四种情况下的插入操作可能会导致原有平衡二叉树发生不平衡:  
（1）LL：若某一节点的平衡因子为1，当在其左子树的左子树上插入一个新结点时会导致该结点的平衡因子由1 变为2。  
（2）RR：若某一节点的平衡因子为-1，当在其右子树的右子树上插入一个新结点时会导致该结点的平衡因子由-1 变为-2。  
（3）LR：若某一节点的平衡因子为1，当在其左子树的右子树上插入一个新结点时会导致该结点的平衡因子由1 变为2。  
（4）RL：若某一节点的平衡因子为-1，当在其右子树的左子树上插入一个新结点时会导致该结点的平衡因子由-1 变为-2。  
平衡二叉树有四种基本的旋转方式，分别为：左旋转，右旋转，先左后右旋转，先右后左旋转。针对上述四种情况可能导致的不平衡，可通过旋转的方式使得平衡二叉树恢复平衡，具体做法如下（箭头中数字为子树的高度，结点旁边的数字为其平衡因子）：  
![图 $9{-}30~\mathrm{LL}$  情况旋转](images/ca76734b4d3583b5c59b3d750c1c21778ffd2f87170aec4bd9132947c230f2d0.jpg)  
![图9-31RR 情况旋转 ](images/de09284418b14138ebb993596ee227f73dfbd205bc84b4dc9b8dc270f608bf3d.jpg)  
（1）LL 型调整：插入操作，当三个结点处于一条直线，并均是左结点时(导致LL 情况)需要以中间结点为旋转轴向右侧(顺时针)旋转一次。如图9-30 所示。具体步骤如下：  
步骤一：将 $𝐴$ 的左子树 $B$ 提升为新二叉树的根  
步骤二：将原来的 $𝐴$ 连同其右子树 ${\mathbf{}}A_{R}$ 向下旋转，使其成为 𝐵 的右子树  
步骤三：将$B$的原右子树${B_{R}}$作为左子树连接到𝐴上  
（2）RR 型调整：插入操作，当三个结点处于一条直线，并均是右结点时(导致RR 情况)需要以中间的结点为旋转轴向左侧(逆时针)旋转一次。如图9-31 所示。具体步骤如下：  
步骤一：将 $𝐴$ 的右子树 $B$ 提升为新二叉树的根  
步骤二：将原来的 $𝐴 $连同其左子树 ${}^{;}A_{L}$ 向下旋转，使其成为 $𝐵$ 的左子树  
步骤三：将$\cdot B$的原左子树$B_{L}$作为左子树连接到𝐴上  
（3）LR 型调整：插入操作，当三结点不在一直线且均是左结点时，需以插入结点为旋转轴向左侧(逆时针)旋转一次，然后向右侧(顺时针)旋转一次，即先做RR 操作再做一次LL 操作（在LR 情况，需要先将$B$左旋转，再将𝐴右旋转），如图9-32 所示。具体步骤如下：  
首先执行RR 旋转：  
步骤一：将 $B$ 的右子树 $C$ 提升为新二叉树的“根”  
步骤二：将原来的 $B$ 连同其左子树 ${'}B_{L}$ 向下旋转，使其成为 𝐶 的左子树  
步骤三：将$C$的原左子树$C_{L}$作为右子树连接到$B$上  
然后再执行LL 旋转：  
步骤四：将$𝐴 $的左子树 $C$ 提升为新二叉树的根  
步骤五：将原来的 $𝐴$ 连同其右子树 ${\mathbf{}}A_{R}$ 向下旋转，使其成为 $𝐶$ 的右子树  
步骤六：将𝐶的原右子树$C_{R}$作为左子树连接到𝐴上  
![图9-32 平衡二叉树插入操作LR 情况旋转](images/86ffa77dc86336b0d7814938270d287104a964c00ad6b86a183a77c341a73ccd.jpg)
![图9-33  RL 情况旋转 ](images/73d2aa49589db07f2f0cd8ac54b27db44de079203d670420e8cc6330c886ef14.jpg)  
（4）RL 型调整：插入操作，当三结点不在一直线且均是右结点时，需以插入结点为旋转轴向右侧(顺时针)旋转一次，然后向左侧(逆时针)旋转一次，即先做LL 操作再做一次RR 操作（在RL 情况，需先将$B$右旋转，再将𝐴左旋转）。如图9-33 所示。具体步骤如下：  
首先执行LL 旋转  
步骤一：将 $B$ 的左子树 $C$ 提升为新二叉树的“根”  
步骤二：将原来的 $B$ 连同其右子树 $B_{R}$ 向下旋转，使其成为 $𝐶$ 的右子树  
步骤三：将$𝐶$的原右子树$C_{R}$作为左子树连接到$B$上  
然后再执行 RR  旋转  
步骤四：将 $𝐴$ 的右子树 $C$ 提升为新二叉树的根  
步骤五：将原来的 $𝐴$ 连同其左子树 ${}^{;}A_{L}$ 向下旋转，使其成为 $𝐶$ 的左子树  
步骤六：将$𝐶$的原左子树$C_{L}$作为右子树连接到$𝐴$上 在上述四种旋转基础上，就可对平衡二叉树进行插入和删除操作，具体如下：  
（1）插入操作：插入完成后需要从插入的结点开始维护一个到根结点的路径，每经过一个结点都要维持树的平衡，需要根据高度差的特点采取不同的旋转策略进行调整，使整棵树恢复成为平衡树。  
（2）删除操作：首先定位要删除的结点，删除完成后，要从删除结点的父亲开始向上维护树的平衡一直到根结点，然后采取不同的旋转策略调整，使整棵树恢复成为平衡树。",平衡二叉树中某结点左子树的高度减去该结点右子树的高度，所形成的差值称为该结点的平衡因子
平衡二叉树,依赖,旋转操作,,"对于二叉树的一些基本操作，比如插入、删除和查找等，其算法时间复杂度都与树的高度有关。因此，适当控制树高是一个非常关键的问题。显然，控制树高的一个有效措施就是尽量保持树的左右子树高度大致平衡，由此产生平衡二叉树的概念。  
平衡二叉树是一种特殊的二叉树，要求树中任何结点的两棵子树高度差不能超过1，如果插入或者删除一个结点使得高度之差大于1，就要进行结点之间的旋转操作，将二叉树重新维持在一个平衡状态。  
平衡二叉树是一种非常重要的树模型，因为它可以保证一些在树上的基本操作具有较好的最坏情况性能，这使它在信息查找等很多场合有着十分重要的作用。后面将会详细介绍平衡二叉树的若干特例，如红黑树、$B$树等。  
平衡二叉树的操作主要有查找、插入和删除结点等。其中插入和删除结点操作可能需要通过一次或多次旋转操作来重新平衡该树，使其满足平衡二叉树的要求。下面简要介绍有关平衡二叉树的一些基本概念和操作。  
树模型中某结点左子树的高度减去该结点右子树的高度，所形成的差值称为该结点的平衡因子，即$\mathrm{Balance~Fector(BF)=}$左子树的高度-右子树的高度。  
平衡二叉树的平衡因子为-1，0 或1。设计平衡二叉树操作算法的关键在于如何使得平衡二叉树保持平衡。以下四种情况下的插入操作可能会导致原有平衡二叉树发生不平衡:  
（1）LL：若某一节点的平衡因子为1，当在其左子树的左子树上插入一个新结点时会导致该结点的平衡因子由1 变为2。  
（2）RR：若某一节点的平衡因子为-1，当在其右子树的右子树上插入一个新结点时会导致该结点的平衡因子由-1 变为-2。  
（3）LR：若某一节点的平衡因子为1，当在其左子树的右子树上插入一个新结点时会导致该结点的平衡因子由1 变为2。  
（4）RL：若某一节点的平衡因子为-1，当在其右子树的左子树上插入一个新结点时会导致该结点的平衡因子由-1 变为-2。  
平衡二叉树有四种基本的旋转方式，分别为：左旋转，右旋转，先左后右旋转，先右后左旋转。针对上述四种情况可能导致的不平衡，可通过旋转的方式使得平衡二叉树恢复平衡，具体做法如下（箭头中数字为子树的高度，结点旁边的数字为其平衡因子）：  
![图 $9{-}30~\mathrm{LL}$  情况旋转](images/ca76734b4d3583b5c59b3d750c1c21778ffd2f87170aec4bd9132947c230f2d0.jpg)  
![图9-31RR 情况旋转 ](images/de09284418b14138ebb993596ee227f73dfbd205bc84b4dc9b8dc270f608bf3d.jpg)  
（1）LL 型调整：插入操作，当三个结点处于一条直线，并均是左结点时(导致LL 情况)需要以中间结点为旋转轴向右侧(顺时针)旋转一次。如图9-30 所示。具体步骤如下：  
步骤一：将 $𝐴$ 的左子树 $B$ 提升为新二叉树的根  
步骤二：将原来的 $𝐴$ 连同其右子树 ${\mathbf{}}A_{R}$ 向下旋转，使其成为 𝐵 的右子树  
步骤三：将$B$的原右子树${B_{R}}$作为左子树连接到𝐴上  
（2）RR 型调整：插入操作，当三个结点处于一条直线，并均是右结点时(导致RR 情况)需要以中间的结点为旋转轴向左侧(逆时针)旋转一次。如图9-31 所示。具体步骤如下：  
步骤一：将 $𝐴$ 的右子树 $B$ 提升为新二叉树的根  
步骤二：将原来的 $𝐴 $连同其左子树 ${}^{;}A_{L}$ 向下旋转，使其成为 $𝐵$ 的左子树  
步骤三：将$\cdot B$的原左子树$B_{L}$作为左子树连接到𝐴上  
（3）LR 型调整：插入操作，当三结点不在一直线且均是左结点时，需以插入结点为旋转轴向左侧(逆时针)旋转一次，然后向右侧(顺时针)旋转一次，即先做RR 操作再做一次LL 操作（在LR 情况，需要先将$B$左旋转，再将𝐴右旋转），如图9-32 所示。具体步骤如下：  
首先执行RR 旋转：  
步骤一：将 $B$ 的右子树 $C$ 提升为新二叉树的“根”  
步骤二：将原来的 $B$ 连同其左子树 ${'}B_{L}$ 向下旋转，使其成为 𝐶 的左子树  
步骤三：将$C$的原左子树$C_{L}$作为右子树连接到$B$上  
然后再执行LL 旋转：  
步骤四：将$𝐴 $的左子树 $C$ 提升为新二叉树的根  
步骤五：将原来的 $𝐴$ 连同其右子树 ${\mathbf{}}A_{R}$ 向下旋转，使其成为 $𝐶$ 的右子树  
步骤六：将𝐶的原右子树$C_{R}$作为左子树连接到𝐴上  
![图9-32 平衡二叉树插入操作LR 情况旋转](images/86ffa77dc86336b0d7814938270d287104a964c00ad6b86a183a77c341a73ccd.jpg)
![图9-33  RL 情况旋转 ](images/73d2aa49589db07f2f0cd8ac54b27db44de079203d670420e8cc6330c886ef14.jpg)  
（4）RL 型调整：插入操作，当三结点不在一直线且均是右结点时，需以插入结点为旋转轴向右侧(顺时针)旋转一次，然后向左侧(逆时针)旋转一次，即先做LL 操作再做一次RR 操作（在RL 情况，需先将$B$右旋转，再将𝐴左旋转）。如图9-33 所示。具体步骤如下：  
首先执行LL 旋转  
步骤一：将 $B$ 的左子树 $C$ 提升为新二叉树的“根”  
步骤二：将原来的 $B$ 连同其右子树 $B_{R}$ 向下旋转，使其成为 $𝐶$ 的右子树  
步骤三：将$𝐶$的原右子树$C_{R}$作为左子树连接到$B$上  
然后再执行 RR  旋转  
步骤四：将 $𝐴$ 的右子树 $C$ 提升为新二叉树的根  
步骤五：将原来的 $𝐴$ 连同其左子树 ${}^{;}A_{L}$ 向下旋转，使其成为 $𝐶$ 的左子树  
步骤六：将$𝐶$的原左子树$C_{L}$作为右子树连接到$𝐴$上 在上述四种旋转基础上，就可对平衡二叉树进行插入和删除操作，具体如下：  
（1）插入操作：插入完成后需要从插入的结点开始维护一个到根结点的路径，每经过一个结点都要维持树的平衡，需要根据高度差的特点采取不同的旋转策略进行调整，使整棵树恢复成为平衡树。  
（2）删除操作：首先定位要删除的结点，删除完成后，要从删除结点的父亲开始向上维护树的平衡一直到根结点，然后采取不同的旋转策略调整，使整棵树恢复成为平衡树。",插入或删除结点导致平衡二叉树不平衡时，需要进行旋转操作以重新维持平衡
平衡二叉树,影响,插入操作,,"对于二叉树的一些基本操作，比如插入、删除和查找等，其算法时间复杂度都与树的高度有关。因此，适当控制树高是一个非常关键的问题。显然，控制树高的一个有效措施就是尽量保持树的左右子树高度大致平衡，由此产生平衡二叉树的概念。  
平衡二叉树是一种特殊的二叉树，要求树中任何结点的两棵子树高度差不能超过1，如果插入或者删除一个结点使得高度之差大于1，就要进行结点之间的旋转操作，将二叉树重新维持在一个平衡状态。  
平衡二叉树是一种非常重要的树模型，因为它可以保证一些在树上的基本操作具有较好的最坏情况性能，这使它在信息查找等很多场合有着十分重要的作用。后面将会详细介绍平衡二叉树的若干特例，如红黑树、$B$树等。  
平衡二叉树的操作主要有查找、插入和删除结点等。其中插入和删除结点操作可能需要通过一次或多次旋转操作来重新平衡该树，使其满足平衡二叉树的要求。下面简要介绍有关平衡二叉树的一些基本概念和操作。  
树模型中某结点左子树的高度减去该结点右子树的高度，所形成的差值称为该结点的平衡因子，即$\mathrm{Balance~Fector(BF)=}$左子树的高度-右子树的高度。  
平衡二叉树的平衡因子为-1，0 或1。设计平衡二叉树操作算法的关键在于如何使得平衡二叉树保持平衡。以下四种情况下的插入操作可能会导致原有平衡二叉树发生不平衡:  
（1）LL：若某一节点的平衡因子为1，当在其左子树的左子树上插入一个新结点时会导致该结点的平衡因子由1 变为2。  
（2）RR：若某一节点的平衡因子为-1，当在其右子树的右子树上插入一个新结点时会导致该结点的平衡因子由-1 变为-2。  
（3）LR：若某一节点的平衡因子为1，当在其左子树的右子树上插入一个新结点时会导致该结点的平衡因子由1 变为2。  
（4）RL：若某一节点的平衡因子为-1，当在其右子树的左子树上插入一个新结点时会导致该结点的平衡因子由-1 变为-2。  
平衡二叉树有四种基本的旋转方式，分别为：左旋转，右旋转，先左后右旋转，先右后左旋转。针对上述四种情况可能导致的不平衡，可通过旋转的方式使得平衡二叉树恢复平衡，具体做法如下（箭头中数字为子树的高度，结点旁边的数字为其平衡因子）：  
![图 $9{-}30~\mathrm{LL}$  情况旋转](images/ca76734b4d3583b5c59b3d750c1c21778ffd2f87170aec4bd9132947c230f2d0.jpg)  
![图9-31RR 情况旋转 ](images/de09284418b14138ebb993596ee227f73dfbd205bc84b4dc9b8dc270f608bf3d.jpg)  
（1）LL 型调整：插入操作，当三个结点处于一条直线，并均是左结点时(导致LL 情况)需要以中间结点为旋转轴向右侧(顺时针)旋转一次。如图9-30 所示。具体步骤如下：  
步骤一：将 $𝐴$ 的左子树 $B$ 提升为新二叉树的根  
步骤二：将原来的 $𝐴$ 连同其右子树 ${\mathbf{}}A_{R}$ 向下旋转，使其成为 𝐵 的右子树  
步骤三：将$B$的原右子树${B_{R}}$作为左子树连接到𝐴上  
（2）RR 型调整：插入操作，当三个结点处于一条直线，并均是右结点时(导致RR 情况)需要以中间的结点为旋转轴向左侧(逆时针)旋转一次。如图9-31 所示。具体步骤如下：  
步骤一：将 $𝐴$ 的右子树 $B$ 提升为新二叉树的根  
步骤二：将原来的 $𝐴 $连同其左子树 ${}^{;}A_{L}$ 向下旋转，使其成为 $𝐵$ 的左子树  
步骤三：将$\cdot B$的原左子树$B_{L}$作为左子树连接到𝐴上  
（3）LR 型调整：插入操作，当三结点不在一直线且均是左结点时，需以插入结点为旋转轴向左侧(逆时针)旋转一次，然后向右侧(顺时针)旋转一次，即先做RR 操作再做一次LL 操作（在LR 情况，需要先将$B$左旋转，再将𝐴右旋转），如图9-32 所示。具体步骤如下：  
首先执行RR 旋转：  
步骤一：将 $B$ 的右子树 $C$ 提升为新二叉树的“根”  
步骤二：将原来的 $B$ 连同其左子树 ${'}B_{L}$ 向下旋转，使其成为 𝐶 的左子树  
步骤三：将$C$的原左子树$C_{L}$作为右子树连接到$B$上  
然后再执行LL 旋转：  
步骤四：将$𝐴 $的左子树 $C$ 提升为新二叉树的根  
步骤五：将原来的 $𝐴$ 连同其右子树 ${\mathbf{}}A_{R}$ 向下旋转，使其成为 $𝐶$ 的右子树  
步骤六：将𝐶的原右子树$C_{R}$作为左子树连接到𝐴上  
![图9-32 平衡二叉树插入操作LR 情况旋转](images/86ffa77dc86336b0d7814938270d287104a964c00ad6b86a183a77c341a73ccd.jpg)
![图9-33  RL 情况旋转 ](images/73d2aa49589db07f2f0cd8ac54b27db44de079203d670420e8cc6330c886ef14.jpg)  
（4）RL 型调整：插入操作，当三结点不在一直线且均是右结点时，需以插入结点为旋转轴向右侧(顺时针)旋转一次，然后向左侧(逆时针)旋转一次，即先做LL 操作再做一次RR 操作（在RL 情况，需先将$B$右旋转，再将𝐴左旋转）。如图9-33 所示。具体步骤如下：  
首先执行LL 旋转  
步骤一：将 $B$ 的左子树 $C$ 提升为新二叉树的“根”  
步骤二：将原来的 $B$ 连同其右子树 $B_{R}$ 向下旋转，使其成为 $𝐶$ 的右子树  
步骤三：将$𝐶$的原右子树$C_{R}$作为左子树连接到$B$上  
然后再执行 RR  旋转  
步骤四：将 $𝐴$ 的右子树 $C$ 提升为新二叉树的根  
步骤五：将原来的 $𝐴$ 连同其左子树 ${}^{;}A_{L}$ 向下旋转，使其成为 $𝐶$ 的左子树  
步骤六：将$𝐶$的原左子树$C_{L}$作为右子树连接到$𝐴$上 在上述四种旋转基础上，就可对平衡二叉树进行插入和删除操作，具体如下：  
（1）插入操作：插入完成后需要从插入的结点开始维护一个到根结点的路径，每经过一个结点都要维持树的平衡，需要根据高度差的特点采取不同的旋转策略进行调整，使整棵树恢复成为平衡树。  
（2）删除操作：首先定位要删除的结点，删除完成后，要从删除结点的父亲开始向上维护树的平衡一直到根结点，然后采取不同的旋转策略调整，使整棵树恢复成为平衡树。",插入操作可能导致平衡二叉树不平衡，需要通过旋转操作进行调整
平衡二叉树,影响,删除操作,,"对于二叉树的一些基本操作，比如插入、删除和查找等，其算法时间复杂度都与树的高度有关。因此，适当控制树高是一个非常关键的问题。显然，控制树高的一个有效措施就是尽量保持树的左右子树高度大致平衡，由此产生平衡二叉树的概念。  
平衡二叉树是一种特殊的二叉树，要求树中任何结点的两棵子树高度差不能超过1，如果插入或者删除一个结点使得高度之差大于1，就要进行结点之间的旋转操作，将二叉树重新维持在一个平衡状态。  
平衡二叉树是一种非常重要的树模型，因为它可以保证一些在树上的基本操作具有较好的最坏情况性能，这使它在信息查找等很多场合有着十分重要的作用。后面将会详细介绍平衡二叉树的若干特例，如红黑树、$B$树等。  
平衡二叉树的操作主要有查找、插入和删除结点等。其中插入和删除结点操作可能需要通过一次或多次旋转操作来重新平衡该树，使其满足平衡二叉树的要求。下面简要介绍有关平衡二叉树的一些基本概念和操作。  
树模型中某结点左子树的高度减去该结点右子树的高度，所形成的差值称为该结点的平衡因子，即$\mathrm{Balance~Fector(BF)=}$左子树的高度-右子树的高度。  
平衡二叉树的平衡因子为-1，0 或1。设计平衡二叉树操作算法的关键在于如何使得平衡二叉树保持平衡。以下四种情况下的插入操作可能会导致原有平衡二叉树发生不平衡:  
（1）LL：若某一节点的平衡因子为1，当在其左子树的左子树上插入一个新结点时会导致该结点的平衡因子由1 变为2。  
（2）RR：若某一节点的平衡因子为-1，当在其右子树的右子树上插入一个新结点时会导致该结点的平衡因子由-1 变为-2。  
（3）LR：若某一节点的平衡因子为1，当在其左子树的右子树上插入一个新结点时会导致该结点的平衡因子由1 变为2。  
（4）RL：若某一节点的平衡因子为-1，当在其右子树的左子树上插入一个新结点时会导致该结点的平衡因子由-1 变为-2。  
平衡二叉树有四种基本的旋转方式，分别为：左旋转，右旋转，先左后右旋转，先右后左旋转。针对上述四种情况可能导致的不平衡，可通过旋转的方式使得平衡二叉树恢复平衡，具体做法如下（箭头中数字为子树的高度，结点旁边的数字为其平衡因子）：  
![图 $9{-}30~\mathrm{LL}$  情况旋转](images/ca76734b4d3583b5c59b3d750c1c21778ffd2f87170aec4bd9132947c230f2d0.jpg)  
![图9-31RR 情况旋转 ](images/de09284418b14138ebb993596ee227f73dfbd205bc84b4dc9b8dc270f608bf3d.jpg)  
（1）LL 型调整：插入操作，当三个结点处于一条直线，并均是左结点时(导致LL 情况)需要以中间结点为旋转轴向右侧(顺时针)旋转一次。如图9-30 所示。具体步骤如下：  
步骤一：将 $𝐴$ 的左子树 $B$ 提升为新二叉树的根  
步骤二：将原来的 $𝐴$ 连同其右子树 ${\mathbf{}}A_{R}$ 向下旋转，使其成为 𝐵 的右子树  
步骤三：将$B$的原右子树${B_{R}}$作为左子树连接到𝐴上  
（2）RR 型调整：插入操作，当三个结点处于一条直线，并均是右结点时(导致RR 情况)需要以中间的结点为旋转轴向左侧(逆时针)旋转一次。如图9-31 所示。具体步骤如下：  
步骤一：将 $𝐴$ 的右子树 $B$ 提升为新二叉树的根  
步骤二：将原来的 $𝐴 $连同其左子树 ${}^{;}A_{L}$ 向下旋转，使其成为 $𝐵$ 的左子树  
步骤三：将$\cdot B$的原左子树$B_{L}$作为左子树连接到𝐴上  
（3）LR 型调整：插入操作，当三结点不在一直线且均是左结点时，需以插入结点为旋转轴向左侧(逆时针)旋转一次，然后向右侧(顺时针)旋转一次，即先做RR 操作再做一次LL 操作（在LR 情况，需要先将$B$左旋转，再将𝐴右旋转），如图9-32 所示。具体步骤如下：  
首先执行RR 旋转：  
步骤一：将 $B$ 的右子树 $C$ 提升为新二叉树的“根”  
步骤二：将原来的 $B$ 连同其左子树 ${'}B_{L}$ 向下旋转，使其成为 𝐶 的左子树  
步骤三：将$C$的原左子树$C_{L}$作为右子树连接到$B$上  
然后再执行LL 旋转：  
步骤四：将$𝐴 $的左子树 $C$ 提升为新二叉树的根  
步骤五：将原来的 $𝐴$ 连同其右子树 ${\mathbf{}}A_{R}$ 向下旋转，使其成为 $𝐶$ 的右子树  
步骤六：将𝐶的原右子树$C_{R}$作为左子树连接到𝐴上  
![图9-32 平衡二叉树插入操作LR 情况旋转](images/86ffa77dc86336b0d7814938270d287104a964c00ad6b86a183a77c341a73ccd.jpg)
![图9-33  RL 情况旋转 ](images/73d2aa49589db07f2f0cd8ac54b27db44de079203d670420e8cc6330c886ef14.jpg)  
（4）RL 型调整：插入操作，当三结点不在一直线且均是右结点时，需以插入结点为旋转轴向右侧(顺时针)旋转一次，然后向左侧(逆时针)旋转一次，即先做LL 操作再做一次RR 操作（在RL 情况，需先将$B$右旋转，再将𝐴左旋转）。如图9-33 所示。具体步骤如下：  
首先执行LL 旋转  
步骤一：将 $B$ 的左子树 $C$ 提升为新二叉树的“根”  
步骤二：将原来的 $B$ 连同其右子树 $B_{R}$ 向下旋转，使其成为 $𝐶$ 的右子树  
步骤三：将$𝐶$的原右子树$C_{R}$作为左子树连接到$B$上  
然后再执行 RR  旋转  
步骤四：将 $𝐴$ 的右子树 $C$ 提升为新二叉树的根  
步骤五：将原来的 $𝐴$ 连同其左子树 ${}^{;}A_{L}$ 向下旋转，使其成为 $𝐶$ 的左子树  
步骤六：将$𝐶$的原左子树$C_{L}$作为右子树连接到$𝐴$上 在上述四种旋转基础上，就可对平衡二叉树进行插入和删除操作，具体如下：  
（1）插入操作：插入完成后需要从插入的结点开始维护一个到根结点的路径，每经过一个结点都要维持树的平衡，需要根据高度差的特点采取不同的旋转策略进行调整，使整棵树恢复成为平衡树。  
（2）删除操作：首先定位要删除的结点，删除完成后，要从删除结点的父亲开始向上维护树的平衡一直到根结点，然后采取不同的旋转策略调整，使整棵树恢复成为平衡树。",删除操作可能导致平衡二叉树不平衡，需要通过旋转操作进行调整
旋转操作,应对,插入操作,,"对于二叉树的一些基本操作，比如插入、删除和查找等，其算法时间复杂度都与树的高度有关。因此，适当控制树高是一个非常关键的问题。显然，控制树高的一个有效措施就是尽量保持树的左右子树高度大致平衡，由此产生平衡二叉树的概念。  
平衡二叉树是一种特殊的二叉树，要求树中任何结点的两棵子树高度差不能超过1，如果插入或者删除一个结点使得高度之差大于1，就要进行结点之间的旋转操作，将二叉树重新维持在一个平衡状态。  
平衡二叉树是一种非常重要的树模型，因为它可以保证一些在树上的基本操作具有较好的最坏情况性能，这使它在信息查找等很多场合有着十分重要的作用。后面将会详细介绍平衡二叉树的若干特例，如红黑树、$B$树等。  
平衡二叉树的操作主要有查找、插入和删除结点等。其中插入和删除结点操作可能需要通过一次或多次旋转操作来重新平衡该树，使其满足平衡二叉树的要求。下面简要介绍有关平衡二叉树的一些基本概念和操作。  
树模型中某结点左子树的高度减去该结点右子树的高度，所形成的差值称为该结点的平衡因子，即$\mathrm{Balance~Fector(BF)=}$左子树的高度-右子树的高度。  
平衡二叉树的平衡因子为-1，0 或1。设计平衡二叉树操作算法的关键在于如何使得平衡二叉树保持平衡。以下四种情况下的插入操作可能会导致原有平衡二叉树发生不平衡:  
（1）LL：若某一节点的平衡因子为1，当在其左子树的左子树上插入一个新结点时会导致该结点的平衡因子由1 变为2。  
（2）RR：若某一节点的平衡因子为-1，当在其右子树的右子树上插入一个新结点时会导致该结点的平衡因子由-1 变为-2。  
（3）LR：若某一节点的平衡因子为1，当在其左子树的右子树上插入一个新结点时会导致该结点的平衡因子由1 变为2。  
（4）RL：若某一节点的平衡因子为-1，当在其右子树的左子树上插入一个新结点时会导致该结点的平衡因子由-1 变为-2。  
平衡二叉树有四种基本的旋转方式，分别为：左旋转，右旋转，先左后右旋转，先右后左旋转。针对上述四种情况可能导致的不平衡，可通过旋转的方式使得平衡二叉树恢复平衡，具体做法如下（箭头中数字为子树的高度，结点旁边的数字为其平衡因子）：  
![图 $9{-}30~\mathrm{LL}$  情况旋转](images/ca76734b4d3583b5c59b3d750c1c21778ffd2f87170aec4bd9132947c230f2d0.jpg)  
![图9-31RR 情况旋转 ](images/de09284418b14138ebb993596ee227f73dfbd205bc84b4dc9b8dc270f608bf3d.jpg)  
（1）LL 型调整：插入操作，当三个结点处于一条直线，并均是左结点时(导致LL 情况)需要以中间结点为旋转轴向右侧(顺时针)旋转一次。如图9-30 所示。具体步骤如下：  
步骤一：将 $𝐴$ 的左子树 $B$ 提升为新二叉树的根  
步骤二：将原来的 $𝐴$ 连同其右子树 ${\mathbf{}}A_{R}$ 向下旋转，使其成为 𝐵 的右子树  
步骤三：将$B$的原右子树${B_{R}}$作为左子树连接到𝐴上  
（2）RR 型调整：插入操作，当三个结点处于一条直线，并均是右结点时(导致RR 情况)需要以中间的结点为旋转轴向左侧(逆时针)旋转一次。如图9-31 所示。具体步骤如下：  
步骤一：将 $𝐴$ 的右子树 $B$ 提升为新二叉树的根  
步骤二：将原来的 $𝐴 $连同其左子树 ${}^{;}A_{L}$ 向下旋转，使其成为 $𝐵$ 的左子树  
步骤三：将$\cdot B$的原左子树$B_{L}$作为左子树连接到𝐴上  
（3）LR 型调整：插入操作，当三结点不在一直线且均是左结点时，需以插入结点为旋转轴向左侧(逆时针)旋转一次，然后向右侧(顺时针)旋转一次，即先做RR 操作再做一次LL 操作（在LR 情况，需要先将$B$左旋转，再将𝐴右旋转），如图9-32 所示。具体步骤如下：  
首先执行RR 旋转：  
步骤一：将 $B$ 的右子树 $C$ 提升为新二叉树的“根”  
步骤二：将原来的 $B$ 连同其左子树 ${'}B_{L}$ 向下旋转，使其成为 𝐶 的左子树  
步骤三：将$C$的原左子树$C_{L}$作为右子树连接到$B$上  
然后再执行LL 旋转：  
步骤四：将$𝐴 $的左子树 $C$ 提升为新二叉树的根  
步骤五：将原来的 $𝐴$ 连同其右子树 ${\mathbf{}}A_{R}$ 向下旋转，使其成为 $𝐶$ 的右子树  
步骤六：将𝐶的原右子树$C_{R}$作为左子树连接到𝐴上  
![图9-32 平衡二叉树插入操作LR 情况旋转](images/86ffa77dc86336b0d7814938270d287104a964c00ad6b86a183a77c341a73ccd.jpg)
![图9-33  RL 情况旋转 ](images/73d2aa49589db07f2f0cd8ac54b27db44de079203d670420e8cc6330c886ef14.jpg)  
（4）RL 型调整：插入操作，当三结点不在一直线且均是右结点时，需以插入结点为旋转轴向右侧(顺时针)旋转一次，然后向左侧(逆时针)旋转一次，即先做LL 操作再做一次RR 操作（在RL 情况，需先将$B$右旋转，再将𝐴左旋转）。如图9-33 所示。具体步骤如下：  
首先执行LL 旋转  
步骤一：将 $B$ 的左子树 $C$ 提升为新二叉树的“根”  
步骤二：将原来的 $B$ 连同其右子树 $B_{R}$ 向下旋转，使其成为 $𝐶$ 的右子树  
步骤三：将$𝐶$的原右子树$C_{R}$作为左子树连接到$B$上  
然后再执行 RR  旋转  
步骤四：将 $𝐴$ 的右子树 $C$ 提升为新二叉树的根  
步骤五：将原来的 $𝐴$ 连同其左子树 ${}^{;}A_{L}$ 向下旋转，使其成为 $𝐶$ 的左子树  
步骤六：将$𝐶$的原左子树$C_{L}$作为右子树连接到$𝐴$上 在上述四种旋转基础上，就可对平衡二叉树进行插入和删除操作，具体如下：  
（1）插入操作：插入完成后需要从插入的结点开始维护一个到根结点的路径，每经过一个结点都要维持树的平衡，需要根据高度差的特点采取不同的旋转策略进行调整，使整棵树恢复成为平衡树。  
（2）删除操作：首先定位要删除的结点，删除完成后，要从删除结点的父亲开始向上维护树的平衡一直到根结点，然后采取不同的旋转策略调整，使整棵树恢复成为平衡树。",插入操作导致不平衡时，通过旋转操作恢复平衡二叉树的平衡
旋转操作,应对,删除操作,,"对于二叉树的一些基本操作，比如插入、删除和查找等，其算法时间复杂度都与树的高度有关。因此，适当控制树高是一个非常关键的问题。显然，控制树高的一个有效措施就是尽量保持树的左右子树高度大致平衡，由此产生平衡二叉树的概念。  
平衡二叉树是一种特殊的二叉树，要求树中任何结点的两棵子树高度差不能超过1，如果插入或者删除一个结点使得高度之差大于1，就要进行结点之间的旋转操作，将二叉树重新维持在一个平衡状态。  
平衡二叉树是一种非常重要的树模型，因为它可以保证一些在树上的基本操作具有较好的最坏情况性能，这使它在信息查找等很多场合有着十分重要的作用。后面将会详细介绍平衡二叉树的若干特例，如红黑树、$B$树等。  
平衡二叉树的操作主要有查找、插入和删除结点等。其中插入和删除结点操作可能需要通过一次或多次旋转操作来重新平衡该树，使其满足平衡二叉树的要求。下面简要介绍有关平衡二叉树的一些基本概念和操作。  
树模型中某结点左子树的高度减去该结点右子树的高度，所形成的差值称为该结点的平衡因子，即$\mathrm{Balance~Fector(BF)=}$左子树的高度-右子树的高度。  
平衡二叉树的平衡因子为-1，0 或1。设计平衡二叉树操作算法的关键在于如何使得平衡二叉树保持平衡。以下四种情况下的插入操作可能会导致原有平衡二叉树发生不平衡:  
（1）LL：若某一节点的平衡因子为1，当在其左子树的左子树上插入一个新结点时会导致该结点的平衡因子由1 变为2。  
（2）RR：若某一节点的平衡因子为-1，当在其右子树的右子树上插入一个新结点时会导致该结点的平衡因子由-1 变为-2。  
（3）LR：若某一节点的平衡因子为1，当在其左子树的右子树上插入一个新结点时会导致该结点的平衡因子由1 变为2。  
（4）RL：若某一节点的平衡因子为-1，当在其右子树的左子树上插入一个新结点时会导致该结点的平衡因子由-1 变为-2。  
平衡二叉树有四种基本的旋转方式，分别为：左旋转，右旋转，先左后右旋转，先右后左旋转。针对上述四种情况可能导致的不平衡，可通过旋转的方式使得平衡二叉树恢复平衡，具体做法如下（箭头中数字为子树的高度，结点旁边的数字为其平衡因子）：  
![图 $9{-}30~\mathrm{LL}$  情况旋转](images/ca76734b4d3583b5c59b3d750c1c21778ffd2f87170aec4bd9132947c230f2d0.jpg)  
![图9-31RR 情况旋转 ](images/de09284418b14138ebb993596ee227f73dfbd205bc84b4dc9b8dc270f608bf3d.jpg)  
（1）LL 型调整：插入操作，当三个结点处于一条直线，并均是左结点时(导致LL 情况)需要以中间结点为旋转轴向右侧(顺时针)旋转一次。如图9-30 所示。具体步骤如下：  
步骤一：将 $𝐴$ 的左子树 $B$ 提升为新二叉树的根  
步骤二：将原来的 $𝐴$ 连同其右子树 ${\mathbf{}}A_{R}$ 向下旋转，使其成为 𝐵 的右子树  
步骤三：将$B$的原右子树${B_{R}}$作为左子树连接到𝐴上  
（2）RR 型调整：插入操作，当三个结点处于一条直线，并均是右结点时(导致RR 情况)需要以中间的结点为旋转轴向左侧(逆时针)旋转一次。如图9-31 所示。具体步骤如下：  
步骤一：将 $𝐴$ 的右子树 $B$ 提升为新二叉树的根  
步骤二：将原来的 $𝐴 $连同其左子树 ${}^{;}A_{L}$ 向下旋转，使其成为 $𝐵$ 的左子树  
步骤三：将$\cdot B$的原左子树$B_{L}$作为左子树连接到𝐴上  
（3）LR 型调整：插入操作，当三结点不在一直线且均是左结点时，需以插入结点为旋转轴向左侧(逆时针)旋转一次，然后向右侧(顺时针)旋转一次，即先做RR 操作再做一次LL 操作（在LR 情况，需要先将$B$左旋转，再将𝐴右旋转），如图9-32 所示。具体步骤如下：  
首先执行RR 旋转：  
步骤一：将 $B$ 的右子树 $C$ 提升为新二叉树的“根”  
步骤二：将原来的 $B$ 连同其左子树 ${'}B_{L}$ 向下旋转，使其成为 𝐶 的左子树  
步骤三：将$C$的原左子树$C_{L}$作为右子树连接到$B$上  
然后再执行LL 旋转：  
步骤四：将$𝐴 $的左子树 $C$ 提升为新二叉树的根  
步骤五：将原来的 $𝐴$ 连同其右子树 ${\mathbf{}}A_{R}$ 向下旋转，使其成为 $𝐶$ 的右子树  
步骤六：将𝐶的原右子树$C_{R}$作为左子树连接到𝐴上  
![图9-32 平衡二叉树插入操作LR 情况旋转](images/86ffa77dc86336b0d7814938270d287104a964c00ad6b86a183a77c341a73ccd.jpg)
![图9-33  RL 情况旋转 ](images/73d2aa49589db07f2f0cd8ac54b27db44de079203d670420e8cc6330c886ef14.jpg)  
（4）RL 型调整：插入操作，当三结点不在一直线且均是右结点时，需以插入结点为旋转轴向右侧(顺时针)旋转一次，然后向左侧(逆时针)旋转一次，即先做LL 操作再做一次RR 操作（在RL 情况，需先将$B$右旋转，再将𝐴左旋转）。如图9-33 所示。具体步骤如下：  
首先执行LL 旋转  
步骤一：将 $B$ 的左子树 $C$ 提升为新二叉树的“根”  
步骤二：将原来的 $B$ 连同其右子树 $B_{R}$ 向下旋转，使其成为 $𝐶$ 的右子树  
步骤三：将$𝐶$的原右子树$C_{R}$作为左子树连接到$B$上  
然后再执行 RR  旋转  
步骤四：将 $𝐴$ 的右子树 $C$ 提升为新二叉树的根  
步骤五：将原来的 $𝐴$ 连同其左子树 ${}^{;}A_{L}$ 向下旋转，使其成为 $𝐶$ 的左子树  
步骤六：将$𝐶$的原左子树$C_{L}$作为右子树连接到$𝐴$上 在上述四种旋转基础上，就可对平衡二叉树进行插入和删除操作，具体如下：  
（1）插入操作：插入完成后需要从插入的结点开始维护一个到根结点的路径，每经过一个结点都要维持树的平衡，需要根据高度差的特点采取不同的旋转策略进行调整，使整棵树恢复成为平衡树。  
（2）删除操作：首先定位要删除的结点，删除完成后，要从删除结点的父亲开始向上维护树的平衡一直到根结点，然后采取不同的旋转策略调整，使整棵树恢复成为平衡树。",删除操作导致不平衡时，通过旋转操作恢复平衡二叉树的平衡
红黑树,包含,红黑树插入操作,,"红黑树是一种自平衡二叉查找树。与其他二叉查找树的不同，红黑树在每个结点上增加一个存储位来表示结点的颜色，可以是红色或黑色，通过自动控制红色和黑色这两种颜色的结点分布，以保证树的高度达到近似平衡，从而能够得到比较高的算法效率。  
一棵红黑树需要满足以下五条性质：（1）每个结点是红色或者是黑色；（2）根结点是黑色；（3）每个叶结点，即空结点（NIL）是黑色的；（4）如果一个结点是红色，那么它的两个子结点都是黑色；（5）对每个结点，从该结点到其所有后代叶结点的所有路径上包含相同数目的黑结点。  
其中性质（4）保证了红黑树中任何一条简单路径上不可能出现两个相邻的红色结点，因此最短路径上可能全为黑色结点，最长路径可能为相互交替的红色和黑色结点；性质（5）决定了所有最长的路径都包含相同数目的黑色结点。这两个性质表明，在红黑树中，从根到叶子的最长路径长度不大于最短的路径的两倍，这样就有效地限制了红黑树的高度。由此可以设计出高效的查找算法。  
在对红黑树进行插入和删除等操作时，可能会破坏红黑树的性质，需要及时对红黑树进行调整，以继续保持或恢复红黑树的性质。具体调整方法包括对结点重新着色，以及对树进行旋转操作，即：通过修改某些结点的颜色及指针结构，使得红黑树在插入或删除结点等操作后仍能保持其性质或平衡。下面具体介绍红黑树插入和删除操作算法。  
插入操作主要为以下3 个基本步骤：  
步骤1： 查找要插入的位置；  
步骤2： 将新结点的颜色域赋值为红色；  
步骤3： 自下而上重新调整该树为红黑树；  
在步骤1 中，查找方法与一般二叉查找树类似，不再赘述；在步骤2 中，把新结点的颜色赋值为红色的原因是：如果将其颜色赋值为黑色，将会使得从根到叶子的路径中有一条路上会出现一个额外的黑色结点，这个在后续的修改中难以调整。相反，将其赋值为红色，尽管可能会出现连续两个红色结点的情况，但是这种情况可以在后续的修改中通过旋转和颜色变换进行调整，而且比较容易。下面着重讨论步骤3 的具体实现方法：  
假设要插入的结点为𝑁，其父亲结点为𝑃，$P$的兄弟结点为𝑈。考虑以下两类情况：  
（1）如果𝑃是黑色的，那么整棵树已经是红黑树不需要再进行调整。  
（2）如果𝑃是红色的，那么插入$N$后，将与第4 条性质不符，这时需要进行旋转调整。具体的调整方法又可以分为以下3 种情况：  
![图9-34 红黑树插入操作  ](images/8bd6c0a70e2a8649a7fb851c10f9905d23db3b6c289402fd8842f4278893f2b7.jpg)  
![图9-35 红黑树插入操作-2  ](images/f808bae43e7a0570870b22efe58b1909de1a064dbbaead3d369a5aec53c4e236.jpg)  
1）如图9-34 所示，$N$的叔叔$U$是红色（图中使用阴影表示红色），将结点$P$和结点𝑈的定义为黑色并定义结点𝐺为红色。此时，插入结点𝑁的父亲结点𝑃为黑色。因为通过父结点$P$或结点$U$的任何路径都必定通过结点$G$，而在这些路径上黑色结点的数目没有改变。但是，结点$G$的父结也可能是红色的，因此需要以结点$G$向上递归调整结点颜色。  
2）如图9-35 所示，$N$的叔叔$𝑈$是黑色的，且$N$是右孩子，此时对结点$P$进行一次左旋转调换，然后按情形3）的方法处理。  
3）如图9-36 所示，$N$的叔叔𝑈是黑色的，且$N$是左孩子，此时需对结点$G$ 做一次右旋转调换，使得在变换后的树中结点$P$是新结点𝑁和结点$G$ 的父结点，然后调换之前的结点$P$和结点𝐺的颜色，使之满足第4 和第5 条性质。  
![图9-36 红黑树插入操作-3  ](images/da48b9badf77a4563a4cf7fd2e71f030801d96719268fe4da2f52d1d425a5d37.jpg)  
下面介绍红黑树的删除操作算法。  
红黑树结点删除方法和二叉搜索树的删除方法基本相同，分如下三种情况：若结点没有子女，则直接删除该结点；若结点只有一个子女，则修改它的父结点，使父结点直接连接其子结点；若结点有两个子女的话，则可以找到该结点的前驱或者后继，然后更换两个结点的值，再将前驱或者后继结点删除（由于任意一个结点的前驱或者后继都必定至多只有一个非空子结点，因而删除这样的结点就可以按照前两种情形进行处理）。  
由上分析可知，红黑树删除操作分为以下三个基本步骤：  
(1) 查找要删除结点的位置；  
(2) 用其后继替换该结点；  
(3) 若替换结点为黑色，则需重新调整树模型使其重新成为红黑树。  
其中：步骤1 中查找方法和一般二叉查找树类似，不再赘述；步骤2 使用后继结点替换被删除结点，可保证该结点以上部分仍为红黑树；在步骤3 中，若被删除结点为红色，则其父结点和孩子结点全为黑，此时可直接删除该结点，若被删除结点为黑色，则要分以下四种情况分别进行处理：  
设被删除的结点为$N$，其父结点为$𝑃$，其兄弟结点为$𝑆$。由于结点$𝑁$是黑色的，则结点$P$和$𝑆$都有可能是黑色或红色。  
（1）结点$𝑆$是红色的。此时结点$𝑃$肯定是黑色。对结点$𝑁$的父结点$P$做左旋转，然后把红色兄弟结点转换成结点$𝑁$的祖父。接着转换结点$𝑁$的父亲和祖父的颜色。接下去按 第二、第三或第四种情况来处理，如图9-37 所示。  
（2）结点$𝑆$及其的孩子全是黑色的。这种情况下，结点$𝑃$可能是黑色也可能是红色的。此时，首先把结点$𝑆$赋值为红色。然后要调整以$𝑃$作为$𝑁$递归调整树，如图9-8 所示。  
![图9-37 红黑树删除操作  ](images/b3460c71a5b1c7c1c9b4c9242d7893ecef8d9825641f105235f110c638e75690.jpg)  
![图9-38 红黑树删除操作-2  ](images/6d059b6e8bbc9c108767847f20d92206bfe3e6857f8c49ababf7c2b4c9137a93.jpg)  
（3）$𝑆$是黑色的，$𝑆$的左孩子是红色，右孩子是黑色。这种情况下，对结点$𝑆$做右旋转，这样 $S$ 的左孩子就成为 $S$ 的父亲和$𝑁$的新兄弟。这样就将问题转化到第四种情况。此时${\mathbf{}}N$和它的父结点都不受这个变换的影响，如图9-39 所示。  
（4）$𝑆$是黑色的，$𝑆$的右孩子是红色。这种情况下，对$𝑁$的父结点做左旋转，这样$𝑆$成为$𝑁$的父结点和$𝑆$右儿子父结点。接着交换$𝑁$的父结点和$𝑆$的颜色，并使$𝑆$的右儿子为黑色。此时，$N$增加了一个黑色祖先: 要么$𝑁$的父结点变成黑色，要么它是黑色而$𝑆$增加了一个黑色祖父。所以，通过$𝑁$的路径都增加了一个黑色结点，如图9-40 所示。  
![图9-39 红黑树删除操作](images/363e7f72d31896e14f6e326b2edde90d72e436cd1e992a4ca212937b247077c0.jpg)  
![图9-40 红黑树删除操作-4  ](images/8107cf243ab295d16e40201bcd4c536b2bfa28c0236bf69abebf9defaea42241.jpg)",红黑树插入操作是红黑树维护自平衡性质的关键操作之一，通过插入新结点并调整树的结构和颜色，确保红黑树的性质不被破坏。
红黑树,包含,红黑树删除操作,,"红黑树是一种自平衡二叉查找树。与其他二叉查找树的不同，红黑树在每个结点上增加一个存储位来表示结点的颜色，可以是红色或黑色，通过自动控制红色和黑色这两种颜色的结点分布，以保证树的高度达到近似平衡，从而能够得到比较高的算法效率。  
一棵红黑树需要满足以下五条性质：（1）每个结点是红色或者是黑色；（2）根结点是黑色；（3）每个叶结点，即空结点（NIL）是黑色的；（4）如果一个结点是红色，那么它的两个子结点都是黑色；（5）对每个结点，从该结点到其所有后代叶结点的所有路径上包含相同数目的黑结点。  
其中性质（4）保证了红黑树中任何一条简单路径上不可能出现两个相邻的红色结点，因此最短路径上可能全为黑色结点，最长路径可能为相互交替的红色和黑色结点；性质（5）决定了所有最长的路径都包含相同数目的黑色结点。这两个性质表明，在红黑树中，从根到叶子的最长路径长度不大于最短的路径的两倍，这样就有效地限制了红黑树的高度。由此可以设计出高效的查找算法。  
在对红黑树进行插入和删除等操作时，可能会破坏红黑树的性质，需要及时对红黑树进行调整，以继续保持或恢复红黑树的性质。具体调整方法包括对结点重新着色，以及对树进行旋转操作，即：通过修改某些结点的颜色及指针结构，使得红黑树在插入或删除结点等操作后仍能保持其性质或平衡。下面具体介绍红黑树插入和删除操作算法。  
插入操作主要为以下3 个基本步骤：  
步骤1： 查找要插入的位置；  
步骤2： 将新结点的颜色域赋值为红色；  
步骤3： 自下而上重新调整该树为红黑树；  
在步骤1 中，查找方法与一般二叉查找树类似，不再赘述；在步骤2 中，把新结点的颜色赋值为红色的原因是：如果将其颜色赋值为黑色，将会使得从根到叶子的路径中有一条路上会出现一个额外的黑色结点，这个在后续的修改中难以调整。相反，将其赋值为红色，尽管可能会出现连续两个红色结点的情况，但是这种情况可以在后续的修改中通过旋转和颜色变换进行调整，而且比较容易。下面着重讨论步骤3 的具体实现方法：  
假设要插入的结点为𝑁，其父亲结点为𝑃，$P$的兄弟结点为𝑈。考虑以下两类情况：  
（1）如果𝑃是黑色的，那么整棵树已经是红黑树不需要再进行调整。  
（2）如果𝑃是红色的，那么插入$N$后，将与第4 条性质不符，这时需要进行旋转调整。具体的调整方法又可以分为以下3 种情况：  
![图9-34 红黑树插入操作  ](images/8bd6c0a70e2a8649a7fb851c10f9905d23db3b6c289402fd8842f4278893f2b7.jpg)  
![图9-35 红黑树插入操作-2  ](images/f808bae43e7a0570870b22efe58b1909de1a064dbbaead3d369a5aec53c4e236.jpg)  
1）如图9-34 所示，$N$的叔叔$U$是红色（图中使用阴影表示红色），将结点$P$和结点𝑈的定义为黑色并定义结点𝐺为红色。此时，插入结点𝑁的父亲结点𝑃为黑色。因为通过父结点$P$或结点$U$的任何路径都必定通过结点$G$，而在这些路径上黑色结点的数目没有改变。但是，结点$G$的父结也可能是红色的，因此需要以结点$G$向上递归调整结点颜色。  
2）如图9-35 所示，$N$的叔叔$𝑈$是黑色的，且$N$是右孩子，此时对结点$P$进行一次左旋转调换，然后按情形3）的方法处理。  
3）如图9-36 所示，$N$的叔叔𝑈是黑色的，且$N$是左孩子，此时需对结点$G$ 做一次右旋转调换，使得在变换后的树中结点$P$是新结点𝑁和结点$G$ 的父结点，然后调换之前的结点$P$和结点𝐺的颜色，使之满足第4 和第5 条性质。  
![图9-36 红黑树插入操作-3  ](images/da48b9badf77a4563a4cf7fd2e71f030801d96719268fe4da2f52d1d425a5d37.jpg)  
下面介绍红黑树的删除操作算法。  
红黑树结点删除方法和二叉搜索树的删除方法基本相同，分如下三种情况：若结点没有子女，则直接删除该结点；若结点只有一个子女，则修改它的父结点，使父结点直接连接其子结点；若结点有两个子女的话，则可以找到该结点的前驱或者后继，然后更换两个结点的值，再将前驱或者后继结点删除（由于任意一个结点的前驱或者后继都必定至多只有一个非空子结点，因而删除这样的结点就可以按照前两种情形进行处理）。  
由上分析可知，红黑树删除操作分为以下三个基本步骤：  
(1) 查找要删除结点的位置；  
(2) 用其后继替换该结点；  
(3) 若替换结点为黑色，则需重新调整树模型使其重新成为红黑树。  
其中：步骤1 中查找方法和一般二叉查找树类似，不再赘述；步骤2 使用后继结点替换被删除结点，可保证该结点以上部分仍为红黑树；在步骤3 中，若被删除结点为红色，则其父结点和孩子结点全为黑，此时可直接删除该结点，若被删除结点为黑色，则要分以下四种情况分别进行处理：  
设被删除的结点为$N$，其父结点为$𝑃$，其兄弟结点为$𝑆$。由于结点$𝑁$是黑色的，则结点$P$和$𝑆$都有可能是黑色或红色。  
（1）结点$𝑆$是红色的。此时结点$𝑃$肯定是黑色。对结点$𝑁$的父结点$P$做左旋转，然后把红色兄弟结点转换成结点$𝑁$的祖父。接着转换结点$𝑁$的父亲和祖父的颜色。接下去按 第二、第三或第四种情况来处理，如图9-37 所示。  
（2）结点$𝑆$及其的孩子全是黑色的。这种情况下，结点$𝑃$可能是黑色也可能是红色的。此时，首先把结点$𝑆$赋值为红色。然后要调整以$𝑃$作为$𝑁$递归调整树，如图9-8 所示。  
![图9-37 红黑树删除操作  ](images/b3460c71a5b1c7c1c9b4c9242d7893ecef8d9825641f105235f110c638e75690.jpg)  
![图9-38 红黑树删除操作-2  ](images/6d059b6e8bbc9c108767847f20d92206bfe3e6857f8c49ababf7c2b4c9137a93.jpg)  
（3）$𝑆$是黑色的，$𝑆$的左孩子是红色，右孩子是黑色。这种情况下，对结点$𝑆$做右旋转，这样 $S$ 的左孩子就成为 $S$ 的父亲和$𝑁$的新兄弟。这样就将问题转化到第四种情况。此时${\mathbf{}}N$和它的父结点都不受这个变换的影响，如图9-39 所示。  
（4）$𝑆$是黑色的，$𝑆$的右孩子是红色。这种情况下，对$𝑁$的父结点做左旋转，这样$𝑆$成为$𝑁$的父结点和$𝑆$右儿子父结点。接着交换$𝑁$的父结点和$𝑆$的颜色，并使$𝑆$的右儿子为黑色。此时，$N$增加了一个黑色祖先: 要么$𝑁$的父结点变成黑色，要么它是黑色而$𝑆$增加了一个黑色祖父。所以，通过$𝑁$的路径都增加了一个黑色结点，如图9-40 所示。  
![图9-39 红黑树删除操作](images/363e7f72d31896e14f6e326b2edde90d72e436cd1e992a4ca212937b247077c0.jpg)  
![图9-40 红黑树删除操作-4  ](images/8107cf243ab295d16e40201bcd4c536b2bfa28c0236bf69abebf9defaea42241.jpg)",红黑树删除操作是红黑树维护自平衡性质的另一关键操作，通过删除结点并调整树的结构和颜色，确保红黑树的性质不被破坏。
红黑树插入操作,并列,红黑树删除操作,,"红黑树是一种自平衡二叉查找树。与其他二叉查找树的不同，红黑树在每个结点上增加一个存储位来表示结点的颜色，可以是红色或黑色，通过自动控制红色和黑色这两种颜色的结点分布，以保证树的高度达到近似平衡，从而能够得到比较高的算法效率。  
一棵红黑树需要满足以下五条性质：（1）每个结点是红色或者是黑色；（2）根结点是黑色；（3）每个叶结点，即空结点（NIL）是黑色的；（4）如果一个结点是红色，那么它的两个子结点都是黑色；（5）对每个结点，从该结点到其所有后代叶结点的所有路径上包含相同数目的黑结点。  
其中性质（4）保证了红黑树中任何一条简单路径上不可能出现两个相邻的红色结点，因此最短路径上可能全为黑色结点，最长路径可能为相互交替的红色和黑色结点；性质（5）决定了所有最长的路径都包含相同数目的黑色结点。这两个性质表明，在红黑树中，从根到叶子的最长路径长度不大于最短的路径的两倍，这样就有效地限制了红黑树的高度。由此可以设计出高效的查找算法。  
在对红黑树进行插入和删除等操作时，可能会破坏红黑树的性质，需要及时对红黑树进行调整，以继续保持或恢复红黑树的性质。具体调整方法包括对结点重新着色，以及对树进行旋转操作，即：通过修改某些结点的颜色及指针结构，使得红黑树在插入或删除结点等操作后仍能保持其性质或平衡。下面具体介绍红黑树插入和删除操作算法。  
插入操作主要为以下3 个基本步骤：  
步骤1： 查找要插入的位置；  
步骤2： 将新结点的颜色域赋值为红色；  
步骤3： 自下而上重新调整该树为红黑树；  
在步骤1 中，查找方法与一般二叉查找树类似，不再赘述；在步骤2 中，把新结点的颜色赋值为红色的原因是：如果将其颜色赋值为黑色，将会使得从根到叶子的路径中有一条路上会出现一个额外的黑色结点，这个在后续的修改中难以调整。相反，将其赋值为红色，尽管可能会出现连续两个红色结点的情况，但是这种情况可以在后续的修改中通过旋转和颜色变换进行调整，而且比较容易。下面着重讨论步骤3 的具体实现方法：  
假设要插入的结点为𝑁，其父亲结点为𝑃，$P$的兄弟结点为𝑈。考虑以下两类情况：  
（1）如果𝑃是黑色的，那么整棵树已经是红黑树不需要再进行调整。  
（2）如果𝑃是红色的，那么插入$N$后，将与第4 条性质不符，这时需要进行旋转调整。具体的调整方法又可以分为以下3 种情况：  
![图9-34 红黑树插入操作  ](images/8bd6c0a70e2a8649a7fb851c10f9905d23db3b6c289402fd8842f4278893f2b7.jpg)  
![图9-35 红黑树插入操作-2  ](images/f808bae43e7a0570870b22efe58b1909de1a064dbbaead3d369a5aec53c4e236.jpg)  
1）如图9-34 所示，$N$的叔叔$U$是红色（图中使用阴影表示红色），将结点$P$和结点𝑈的定义为黑色并定义结点𝐺为红色。此时，插入结点𝑁的父亲结点𝑃为黑色。因为通过父结点$P$或结点$U$的任何路径都必定通过结点$G$，而在这些路径上黑色结点的数目没有改变。但是，结点$G$的父结也可能是红色的，因此需要以结点$G$向上递归调整结点颜色。  
2）如图9-35 所示，$N$的叔叔$𝑈$是黑色的，且$N$是右孩子，此时对结点$P$进行一次左旋转调换，然后按情形3）的方法处理。  
3）如图9-36 所示，$N$的叔叔𝑈是黑色的，且$N$是左孩子，此时需对结点$G$ 做一次右旋转调换，使得在变换后的树中结点$P$是新结点𝑁和结点$G$ 的父结点，然后调换之前的结点$P$和结点𝐺的颜色，使之满足第4 和第5 条性质。  
![图9-36 红黑树插入操作-3  ](images/da48b9badf77a4563a4cf7fd2e71f030801d96719268fe4da2f52d1d425a5d37.jpg)  
下面介绍红黑树的删除操作算法。  
红黑树结点删除方法和二叉搜索树的删除方法基本相同，分如下三种情况：若结点没有子女，则直接删除该结点；若结点只有一个子女，则修改它的父结点，使父结点直接连接其子结点；若结点有两个子女的话，则可以找到该结点的前驱或者后继，然后更换两个结点的值，再将前驱或者后继结点删除（由于任意一个结点的前驱或者后继都必定至多只有一个非空子结点，因而删除这样的结点就可以按照前两种情形进行处理）。  
由上分析可知，红黑树删除操作分为以下三个基本步骤：  
(1) 查找要删除结点的位置；  
(2) 用其后继替换该结点；  
(3) 若替换结点为黑色，则需重新调整树模型使其重新成为红黑树。  
其中：步骤1 中查找方法和一般二叉查找树类似，不再赘述；步骤2 使用后继结点替换被删除结点，可保证该结点以上部分仍为红黑树；在步骤3 中，若被删除结点为红色，则其父结点和孩子结点全为黑，此时可直接删除该结点，若被删除结点为黑色，则要分以下四种情况分别进行处理：  
设被删除的结点为$N$，其父结点为$𝑃$，其兄弟结点为$𝑆$。由于结点$𝑁$是黑色的，则结点$P$和$𝑆$都有可能是黑色或红色。  
（1）结点$𝑆$是红色的。此时结点$𝑃$肯定是黑色。对结点$𝑁$的父结点$P$做左旋转，然后把红色兄弟结点转换成结点$𝑁$的祖父。接着转换结点$𝑁$的父亲和祖父的颜色。接下去按 第二、第三或第四种情况来处理，如图9-37 所示。  
（2）结点$𝑆$及其的孩子全是黑色的。这种情况下，结点$𝑃$可能是黑色也可能是红色的。此时，首先把结点$𝑆$赋值为红色。然后要调整以$𝑃$作为$𝑁$递归调整树，如图9-8 所示。  
![图9-37 红黑树删除操作  ](images/b3460c71a5b1c7c1c9b4c9242d7893ecef8d9825641f105235f110c638e75690.jpg)  
![图9-38 红黑树删除操作-2  ](images/6d059b6e8bbc9c108767847f20d92206bfe3e6857f8c49ababf7c2b4c9137a93.jpg)  
（3）$𝑆$是黑色的，$𝑆$的左孩子是红色，右孩子是黑色。这种情况下，对结点$𝑆$做右旋转，这样 $S$ 的左孩子就成为 $S$ 的父亲和$𝑁$的新兄弟。这样就将问题转化到第四种情况。此时${\mathbf{}}N$和它的父结点都不受这个变换的影响，如图9-39 所示。  
（4）$𝑆$是黑色的，$𝑆$的右孩子是红色。这种情况下，对$𝑁$的父结点做左旋转，这样$𝑆$成为$𝑁$的父结点和$𝑆$右儿子父结点。接着交换$𝑁$的父结点和$𝑆$的颜色，并使$𝑆$的右儿子为黑色。此时，$N$增加了一个黑色祖先: 要么$𝑁$的父结点变成黑色，要么它是黑色而$𝑆$增加了一个黑色祖父。所以，通过$𝑁$的路径都增加了一个黑色结点，如图9-40 所示。  
![图9-39 红黑树删除操作](images/363e7f72d31896e14f6e326b2edde90d72e436cd1e992a4ca212937b247077c0.jpg)  
![图9-40 红黑树删除操作-4  ](images/8107cf243ab295d16e40201bcd4c536b2bfa28c0236bf69abebf9defaea42241.jpg)",红黑树插入操作和红黑树删除操作都是红黑树维护自平衡性质的基本操作，分别处理结点的插入和删除，并确保红黑树的性质得以保持。
B树,实例化,B树模型,,"B树是一种为磁盘或其他直接存取存储设备而设计的平衡多路查找树。与红黑树类似，两者都是平衡搜索树，而且具有 ${n}$ 个结点的$ 𝐵$ 树与具有 ${n}$ 个结点的红黑树高度一样，都 为$O(l o g\,n)$。但是$B$树的每个结点可以有很多孩子，而红黑树最多只能有两个孩子，因此𝐵树在磁盘${I}/O$ 操作上更为简洁，在数据库系统等动态集合操作方面具有广泛应用。我们先给出$B$树的基本性质，然后详细讨论其查找、插入和删除操作算法。  
$B$树中所有结点的孩子结点数目的最大值称为$ B$树的阶，通常用$m$表示，出于查找效率考虑，要求$m\geq3$。一棵$m$阶$B$树一般具有以下性质：  
（1）每个结点最多有$m$个分支，最少分支数要看是否为根结点，若为根结点，则根结点的分支数至少为2，否则非根结点至少有$\lfloor m/2\rfloor$个分支。  
（2）结点的分支数等于关键字数加1，即 $n(k\leq n\leq m)$个分支的结点含有$n-1$个关键字，它们按递增顺序排列。其中，$k=2$(根结点)或$\lfloor m/2\rfloor$ (非根结点)。  
（3）每个结点的结构如下：  
![](images/30c566c6692c85f6ebd6a8a173d7cbf20b86d1aecac9ef6959a564ffe4fb5cd7.jpg)  
其中，$n$为结点中关键字个数，$k_{i}(1\leq i\leq n)$表示该结点的关键字，且$k_{i}<k_{i+1}$。$P_{i}(1\le$$i\leq n)$表示该结点的孩子结点指针，且$P_{i}(1\leq i\leq n-1)$指向的结点的键值介于$k_{i}$和$k_{i+1}$之间，$P_{0}$指向的结点上的关键字值小于$ k_{1}$，$P_{n}$指向的结点上的键值大于$K_{n}$。  
（4）结点内各关键字互不相同，并按升序排列。  
（5）各个底层结点都是叶子结点，并且处于同一层。  
例如，图9-41 表示为一棵5 阶𝐵树（即树中任一结点至多含有4 个关键字，5 棵子树），下每将以该𝐵树为例详细介绍𝐵树的查找、插入、删除操作。  
![图9-41 一棵5 阶𝐵树  ](images/e5016d24716df866cf87809885a7b154edb22a71164e4c032f96e4bc7bfd5da9.jpg)",B树是B树模型的具体实例，B树模型描述了B树的结构和性质
B树模型,应用,B树查找算法,,根据结点的孩子数做分支界定。比较要查找的值与当前值的大小，若比当前值小则在其左子树，否则在其右子树，递归查找，直到找到相等的结点为止，并返回该结点的位置。如果直到叶子结点仍然没有找到则返回$Null$。在本书第七章查找算法设计中将详细介绍和讨论$𝐵$树查找算法，不再赘述。,B树查找算法应用于B树模型中进行结点的查找和定位
B树,操作过程,B树插入,,"插入操作后所构成的新树必须满足$B$树性质，因此插入结点时需注意关键字的个数$n$不大于$m-1$。对于高度为ℎ的$m$阶$B$树，新结点一般插在第$B$层。通过查找算法可确定关键字应该插入的结点位置。确定插入结点位置后，分两种情况讨论具体的插入算法：  
（1）若该结点中关键字个数小于$m-1$，则直接插入即可。  
（2）若该结点中关键字个数等于$m-1$，则将引起结点的分裂，以中间关键字为界将结点一分为二，产生一个新结点，并把中间关键字插入到父结点中；  
重复上述步骤，直到完成插入过程。最坏情况是一直分裂到根结点，建立一个新的根结点，此时整个$ B$树增加一层。  
下面举例说明插入操作过程。插入以下字符到一棵空的5 阶𝐵树中（非根结点关键字数小于2 个就合并，大于4 个就分裂）：A C G N H E K Q M F W L T Z D P R X Y S。  
（1）首先，结点空间足够，4 个字母插入相同的结点中，如图9-42 所示。  
（2）当尝试插入H 时，结点空间不够，所以将其分裂成2 个结点，中间元素G 向上移动到新的根结点中。如图9-43 所示。  
![](images/4252a61f0ce4fd7310cb10ae1c8ef9c4cfae235cd68e80db30453bdc99e5d47e.jpg)  
（3）当插入E，K，Q 时，不需要任何分裂操作，直接插入即可。 如图9-44 所示。  
（4）当插入M 时，需要一次分裂操作，M 恰好是关键字中间元素，所以向上移动到父结点中。如图9-45 所示。  
![图9-44 插入关键字E、K、 ](images/413fc8320073f6da8cae62a3551646b6ad17f52b2f2f3caa12b077b03b93686c.jpg)  
![图9-45 插入关键字M ](images/76c9ba7db0359db7182dec9348774647f14e47a0638c3639e74fc1bfaea175f7.jpg)  
（5）当插入F，W，L，T 时，不需要任何分裂操作，直接插入即可。如图9-46 所示：  
（6）当插入Z 时，由于最右侧的叶子结点空间满了，所以需要进行分裂操作，其中间元素T 向上移动到父结点中。如图9-47 所示。  
![图9-46 插入关键字F、W、L、](images/d374a861c9384b4be501fa4310531c8976cfd9c204a9c7d08ed4c30a0261306f.jpg)  
![图9-47 插入关键字Z ](images/42aa51968fd33b9d1c3398201657eb65ce8553616837c9b57361320bef21dce1.jpg)  
（7）当插入D 时，由于最左侧的叶子结点空间满了，所以需要进行分裂操作，D 恰好也是中间元素，向上移动到父结点中，然后继续插入字符P，R，X，Y，不需要任何分裂操作，直接插入即可。如图9-48 所示。  
![图9-48 插入关键字 ](images/1874fefa5d34c0110fe81e072d0de6ba5528071a8c60552512913414998d6a65.jpg)  
![图 9-49   插入 关键字 S  ](images/53a2894f1112d19b944696c842dc4e67f6f7578920a01e421aa4d4aefbc623c2.jpg)  
（8）最后，当插入S 时，含有N，P，Q，R 的结点需要进行分裂操作，把中间元素Q向上移动到父结点中，但是，父结点中已经满了，所以也需要进行分裂，将父结点中的中间元素M 向上移动到新形成的根结点中。这样具体的插入操作完成，如图9-49 所示。",B树插入操作需满足B树性质，通过查找算法确定插入位置，根据结点关键字个数决定是否分裂结点，最坏情况可能分裂到根结点，增加树的一层。
B树模型,限制条件,插入操作,,"插入操作只可以从叶结点插入，而删除则可以从任意结点中删除一个关键字，所以删除操作比插入操作需要考虑的情况更加复杂。  
如果待删除关键字所在的结点是叶子结点，则此时可以分3 种情况进行讨论。第一种情况，若删除前该结点中关键字个数$n\geq\lceil m/2\rceil$，那么直接删除该结点。  
下图9-50 所示为从一棵3 阶$B$树上删除关键字34，由于关键字34 所在的结点为叶子结点，并且该结点中关键字个数为2，满足$n\geq\lceil m/2\rceil$，意味着删除一个关键字后任然满足结点中关键字数目的下限，因此可以直接删去该结点。  
第二种情况，删除前结点关键字个数为$n=\lceil m/2\rceil-1$，若这时与该结点相邻结点的关键字个数$ n\geq\lceil m/2\rceil$，则进行如下操作。  
（1）将双亲结点中刚刚大于（或小于）该被删除关键字的关键字$K_{i}$，$1\leq i\leq n$下移。  
（2）将右兄弟（或左兄弟）结点中的最小（或最大）关键字上移到双亲节点的$K_{i}$ 位置。  
（3）将右兄弟（或左兄弟）结点中的最左（或最右）子树指针平移到被删关键字所在结点中最后（或最前）子树指针位置的$K_{i}$位置。  
（4）在右兄弟（或左兄弟）结点中，将被移走的关键字和指针位置用剩余的关键字和指针填补，在将结点中的关键字个数减1。  
![图9-50 删除关键字34 ](images/f864ab87d251f5dafed3b48570754b8e2382312f7013353a88638ad1de9a43c0.jpg)  
图9-51 表示从三阶$B$树上删除关键字58。由于关键字58 所在结点为叶子结点但 不是根结点，所在叶子结点的关键字个数为1，为$n=\lceil m/2\rceil-1$，且相邻的右兄弟结点有两个关键字，满足$.n\geq\lceil m/2\rceil$，因此我们从58 所在结点的双亲结点找到刚刚大于58 的关键字77，将关键字70 下移，而把相邻的右兄弟结点中最小的关键字77 上移，最后在右兄弟结点中将被移走的关键字77 和对应的指针位置用这个阶段中剩下的关键字和指针填充，并将右兄弟结点的关键字数目减1。  
![图9-51 删除关键字58](images/684ee19f4e14eabfcd5ca29d8d44bd71b07f16b7cf5ac37941b5adf82507b091.jpg)  
第三种情况，删除前结点关键字个数$n=\lceil m/2\rceil-1$，若这时与该结点相邻结点的关键字个数$n=\lceil m/2\rceil-1$，则需要合并结点，此时进行如下操作。  
（1）将双亲结点$p$中相应关键字下移到选定保留的结点中。若要合并$ p$中的子树指针$p_{i}$与$p_{i+1}$所指的结点，且保留$p_{i}$所指结点，则把$p$中的关键字 $K_{i+1}$下移到${p_{i}}$所指的结点中。  
（2）把$p$中子树指针$p_{i+1}$所指结点中的全部指针和关键字都照搬到$p_{i}$所指结点的后面。删除$p_{i+1}$所指的结点。  
（3）在结点$p$中用后面剩余的关键字和指针填补关键字$ K_{i+1}$和指针$p_{i+1}$。（4）修改结点$p$和选定保留结点的关键字个数。  
![图9-52 删除关键字34 ](images/130adeccab6191bae16abb56a1ff2b3f7f293b7623158136968270de0ce26b94.jpg)  
图9-52 表示从散阶$\cdot B$树中删除关键字34。由于34 所在结点关键字个数为1，满足 $n=\lceil m/2\rceil-1$，其右兄弟结点的关键字数目也为1，且满足$n=\lceil m/2\rceil-1$，因此需要合并结点。我们将双亲结点中相应的关键字52 下移到关键字34 所在结点，然后把关键字58 所在结点也合并过来；然后我们删除关键字34，并把后面的关键字和指针进行填充，修改这个新结点和双亲结点的关键字数目。  
需要指出的是，删除操作有可能并未结束。可以看到，在合并结点的过程中，双亲节点中的关键字个数减少了。这里还需要分情况讨论，如果双亲节点是根结点且结点关键字个数减到0，则该双亲结点应从树上删去，合并后保留的结点成为新的根结点；如果双亲结点不是根结点，且关键字个数减到$\lceil m/2\rceil-2$，就要与它自己的兄弟结点合并，重复上面的合并步骤。最坏情况下这种结点合并处理要自底向上直到根结点。  
讨论完待删除关键字所在结点为叶结点的情况之后，现在再看待删除关键字所在结点不是叶结点的情况。如果关键字所在街道不是叶子结点，则在删去该关键字之后，以该结点$p_{i}$所指示子树中的最小关键字$x$来代替被删除关键字$ k_{i}$所在的位置，然后再$x$ 所在的叶子结点中删除$x$。此时，问题就转化为已讨论过的删除关键字所在的叶子结点的情况。  
![图9-53 删除关键字26  ](images/489b496fafb3e3db479d787ce84e086bf73b456a443ded3cb295556432ff8f58.jpg)  
如图9-53 所示从三阶$B$树中删除关键字26。关键字26 所在结点不是叶子结点，所以从右子树中取出最小关键字34 代替26，然后从叶子结点中删除关键字34，由于叶子结点中关键字个数满足$n\geq\lceil m/2\rceil$，所以直接删去这个关键字就可以了。",在B树模型中，插入操作只能从叶结点进行。
B树模型,复杂度,删除操作,,"插入操作只可以从叶结点插入，而删除则可以从任意结点中删除一个关键字，所以删除操作比插入操作需要考虑的情况更加复杂。  
如果待删除关键字所在的结点是叶子结点，则此时可以分3 种情况进行讨论。第一种情况，若删除前该结点中关键字个数$n\geq\lceil m/2\rceil$，那么直接删除该结点。  
下图9-50 所示为从一棵3 阶$B$树上删除关键字34，由于关键字34 所在的结点为叶子结点，并且该结点中关键字个数为2，满足$n\geq\lceil m/2\rceil$，意味着删除一个关键字后任然满足结点中关键字数目的下限，因此可以直接删去该结点。  
第二种情况，删除前结点关键字个数为$n=\lceil m/2\rceil-1$，若这时与该结点相邻结点的关键字个数$ n\geq\lceil m/2\rceil$，则进行如下操作。  
（1）将双亲结点中刚刚大于（或小于）该被删除关键字的关键字$K_{i}$，$1\leq i\leq n$下移。  
（2）将右兄弟（或左兄弟）结点中的最小（或最大）关键字上移到双亲节点的$K_{i}$ 位置。  
（3）将右兄弟（或左兄弟）结点中的最左（或最右）子树指针平移到被删关键字所在结点中最后（或最前）子树指针位置的$K_{i}$位置。  
（4）在右兄弟（或左兄弟）结点中，将被移走的关键字和指针位置用剩余的关键字和指针填补，在将结点中的关键字个数减1。  
![图9-50 删除关键字34 ](images/f864ab87d251f5dafed3b48570754b8e2382312f7013353a88638ad1de9a43c0.jpg)  
图9-51 表示从三阶$B$树上删除关键字58。由于关键字58 所在结点为叶子结点但 不是根结点，所在叶子结点的关键字个数为1，为$n=\lceil m/2\rceil-1$，且相邻的右兄弟结点有两个关键字，满足$.n\geq\lceil m/2\rceil$，因此我们从58 所在结点的双亲结点找到刚刚大于58 的关键字77，将关键字70 下移，而把相邻的右兄弟结点中最小的关键字77 上移，最后在右兄弟结点中将被移走的关键字77 和对应的指针位置用这个阶段中剩下的关键字和指针填充，并将右兄弟结点的关键字数目减1。  
![图9-51 删除关键字58](images/684ee19f4e14eabfcd5ca29d8d44bd71b07f16b7cf5ac37941b5adf82507b091.jpg)  
第三种情况，删除前结点关键字个数$n=\lceil m/2\rceil-1$，若这时与该结点相邻结点的关键字个数$n=\lceil m/2\rceil-1$，则需要合并结点，此时进行如下操作。  
（1）将双亲结点$p$中相应关键字下移到选定保留的结点中。若要合并$ p$中的子树指针$p_{i}$与$p_{i+1}$所指的结点，且保留$p_{i}$所指结点，则把$p$中的关键字 $K_{i+1}$下移到${p_{i}}$所指的结点中。  
（2）把$p$中子树指针$p_{i+1}$所指结点中的全部指针和关键字都照搬到$p_{i}$所指结点的后面。删除$p_{i+1}$所指的结点。  
（3）在结点$p$中用后面剩余的关键字和指针填补关键字$ K_{i+1}$和指针$p_{i+1}$。（4）修改结点$p$和选定保留结点的关键字个数。  
![图9-52 删除关键字34 ](images/130adeccab6191bae16abb56a1ff2b3f7f293b7623158136968270de0ce26b94.jpg)  
图9-52 表示从散阶$\cdot B$树中删除关键字34。由于34 所在结点关键字个数为1，满足 $n=\lceil m/2\rceil-1$，其右兄弟结点的关键字数目也为1，且满足$n=\lceil m/2\rceil-1$，因此需要合并结点。我们将双亲结点中相应的关键字52 下移到关键字34 所在结点，然后把关键字58 所在结点也合并过来；然后我们删除关键字34，并把后面的关键字和指针进行填充，修改这个新结点和双亲结点的关键字数目。  
需要指出的是，删除操作有可能并未结束。可以看到，在合并结点的过程中，双亲节点中的关键字个数减少了。这里还需要分情况讨论，如果双亲节点是根结点且结点关键字个数减到0，则该双亲结点应从树上删去，合并后保留的结点成为新的根结点；如果双亲结点不是根结点，且关键字个数减到$\lceil m/2\rceil-2$，就要与它自己的兄弟结点合并，重复上面的合并步骤。最坏情况下这种结点合并处理要自底向上直到根结点。  
讨论完待删除关键字所在结点为叶结点的情况之后，现在再看待删除关键字所在结点不是叶结点的情况。如果关键字所在街道不是叶子结点，则在删去该关键字之后，以该结点$p_{i}$所指示子树中的最小关键字$x$来代替被删除关键字$ k_{i}$所在的位置，然后再$x$ 所在的叶子结点中删除$x$。此时，问题就转化为已讨论过的删除关键字所在的叶子结点的情况。  
![图9-53 删除关键字26  ](images/489b496fafb3e3db479d787ce84e086bf73b456a443ded3cb295556432ff8f58.jpg)  
如图9-53 所示从三阶$B$树中删除关键字26。关键字26 所在结点不是叶子结点，所以从右子树中取出最小关键字34 代替26，然后从叶子结点中删除关键字34，由于叶子结点中关键字个数满足$n\geq\lceil m/2\rceil$，所以直接删去这个关键字就可以了。",在B树模型中，删除操作可以从任意结点进行，比插入操作更复杂。
B树模型,删除操作,叶子结点,,"插入操作只可以从叶结点插入，而删除则可以从任意结点中删除一个关键字，所以删除操作比插入操作需要考虑的情况更加复杂。  
如果待删除关键字所在的结点是叶子结点，则此时可以分3 种情况进行讨论。第一种情况，若删除前该结点中关键字个数$n\geq\lceil m/2\rceil$，那么直接删除该结点。  
下图9-50 所示为从一棵3 阶$B$树上删除关键字34，由于关键字34 所在的结点为叶子结点，并且该结点中关键字个数为2，满足$n\geq\lceil m/2\rceil$，意味着删除一个关键字后任然满足结点中关键字数目的下限，因此可以直接删去该结点。  
第二种情况，删除前结点关键字个数为$n=\lceil m/2\rceil-1$，若这时与该结点相邻结点的关键字个数$ n\geq\lceil m/2\rceil$，则进行如下操作。  
（1）将双亲结点中刚刚大于（或小于）该被删除关键字的关键字$K_{i}$，$1\leq i\leq n$下移。  
（2）将右兄弟（或左兄弟）结点中的最小（或最大）关键字上移到双亲节点的$K_{i}$ 位置。  
（3）将右兄弟（或左兄弟）结点中的最左（或最右）子树指针平移到被删关键字所在结点中最后（或最前）子树指针位置的$K_{i}$位置。  
（4）在右兄弟（或左兄弟）结点中，将被移走的关键字和指针位置用剩余的关键字和指针填补，在将结点中的关键字个数减1。  
![图9-50 删除关键字34 ](images/f864ab87d251f5dafed3b48570754b8e2382312f7013353a88638ad1de9a43c0.jpg)  
图9-51 表示从三阶$B$树上删除关键字58。由于关键字58 所在结点为叶子结点但 不是根结点，所在叶子结点的关键字个数为1，为$n=\lceil m/2\rceil-1$，且相邻的右兄弟结点有两个关键字，满足$.n\geq\lceil m/2\rceil$，因此我们从58 所在结点的双亲结点找到刚刚大于58 的关键字77，将关键字70 下移，而把相邻的右兄弟结点中最小的关键字77 上移，最后在右兄弟结点中将被移走的关键字77 和对应的指针位置用这个阶段中剩下的关键字和指针填充，并将右兄弟结点的关键字数目减1。  
![图9-51 删除关键字58](images/684ee19f4e14eabfcd5ca29d8d44bd71b07f16b7cf5ac37941b5adf82507b091.jpg)  
第三种情况，删除前结点关键字个数$n=\lceil m/2\rceil-1$，若这时与该结点相邻结点的关键字个数$n=\lceil m/2\rceil-1$，则需要合并结点，此时进行如下操作。  
（1）将双亲结点$p$中相应关键字下移到选定保留的结点中。若要合并$ p$中的子树指针$p_{i}$与$p_{i+1}$所指的结点，且保留$p_{i}$所指结点，则把$p$中的关键字 $K_{i+1}$下移到${p_{i}}$所指的结点中。  
（2）把$p$中子树指针$p_{i+1}$所指结点中的全部指针和关键字都照搬到$p_{i}$所指结点的后面。删除$p_{i+1}$所指的结点。  
（3）在结点$p$中用后面剩余的关键字和指针填补关键字$ K_{i+1}$和指针$p_{i+1}$。（4）修改结点$p$和选定保留结点的关键字个数。  
![图9-52 删除关键字34 ](images/130adeccab6191bae16abb56a1ff2b3f7f293b7623158136968270de0ce26b94.jpg)  
图9-52 表示从散阶$\cdot B$树中删除关键字34。由于34 所在结点关键字个数为1，满足 $n=\lceil m/2\rceil-1$，其右兄弟结点的关键字数目也为1，且满足$n=\lceil m/2\rceil-1$，因此需要合并结点。我们将双亲结点中相应的关键字52 下移到关键字34 所在结点，然后把关键字58 所在结点也合并过来；然后我们删除关键字34，并把后面的关键字和指针进行填充，修改这个新结点和双亲结点的关键字数目。  
需要指出的是，删除操作有可能并未结束。可以看到，在合并结点的过程中，双亲节点中的关键字个数减少了。这里还需要分情况讨论，如果双亲节点是根结点且结点关键字个数减到0，则该双亲结点应从树上删去，合并后保留的结点成为新的根结点；如果双亲结点不是根结点，且关键字个数减到$\lceil m/2\rceil-2$，就要与它自己的兄弟结点合并，重复上面的合并步骤。最坏情况下这种结点合并处理要自底向上直到根结点。  
讨论完待删除关键字所在结点为叶结点的情况之后，现在再看待删除关键字所在结点不是叶结点的情况。如果关键字所在街道不是叶子结点，则在删去该关键字之后，以该结点$p_{i}$所指示子树中的最小关键字$x$来代替被删除关键字$ k_{i}$所在的位置，然后再$x$ 所在的叶子结点中删除$x$。此时，问题就转化为已讨论过的删除关键字所在的叶子结点的情况。  
![图9-53 删除关键字26  ](images/489b496fafb3e3db479d787ce84e086bf73b456a443ded3cb295556432ff8f58.jpg)  
如图9-53 所示从三阶$B$树中删除关键字26。关键字26 所在结点不是叶子结点，所以从右子树中取出最小关键字34 代替26，然后从叶子结点中删除关键字34，由于叶子结点中关键字个数满足$n\geq\lceil m/2\rceil$，所以直接删去这个关键字就可以了。",在B树模型中，删除叶子结点的关键字分为三种情况处理。
B树模型,关键字下移,双亲结点,,"插入操作只可以从叶结点插入，而删除则可以从任意结点中删除一个关键字，所以删除操作比插入操作需要考虑的情况更加复杂。  
如果待删除关键字所在的结点是叶子结点，则此时可以分3 种情况进行讨论。第一种情况，若删除前该结点中关键字个数$n\geq\lceil m/2\rceil$，那么直接删除该结点。  
下图9-50 所示为从一棵3 阶$B$树上删除关键字34，由于关键字34 所在的结点为叶子结点，并且该结点中关键字个数为2，满足$n\geq\lceil m/2\rceil$，意味着删除一个关键字后任然满足结点中关键字数目的下限，因此可以直接删去该结点。  
第二种情况，删除前结点关键字个数为$n=\lceil m/2\rceil-1$，若这时与该结点相邻结点的关键字个数$ n\geq\lceil m/2\rceil$，则进行如下操作。  
（1）将双亲结点中刚刚大于（或小于）该被删除关键字的关键字$K_{i}$，$1\leq i\leq n$下移。  
（2）将右兄弟（或左兄弟）结点中的最小（或最大）关键字上移到双亲节点的$K_{i}$ 位置。  
（3）将右兄弟（或左兄弟）结点中的最左（或最右）子树指针平移到被删关键字所在结点中最后（或最前）子树指针位置的$K_{i}$位置。  
（4）在右兄弟（或左兄弟）结点中，将被移走的关键字和指针位置用剩余的关键字和指针填补，在将结点中的关键字个数减1。  
![图9-50 删除关键字34 ](images/f864ab87d251f5dafed3b48570754b8e2382312f7013353a88638ad1de9a43c0.jpg)  
图9-51 表示从三阶$B$树上删除关键字58。由于关键字58 所在结点为叶子结点但 不是根结点，所在叶子结点的关键字个数为1，为$n=\lceil m/2\rceil-1$，且相邻的右兄弟结点有两个关键字，满足$.n\geq\lceil m/2\rceil$，因此我们从58 所在结点的双亲结点找到刚刚大于58 的关键字77，将关键字70 下移，而把相邻的右兄弟结点中最小的关键字77 上移，最后在右兄弟结点中将被移走的关键字77 和对应的指针位置用这个阶段中剩下的关键字和指针填充，并将右兄弟结点的关键字数目减1。  
![图9-51 删除关键字58](images/684ee19f4e14eabfcd5ca29d8d44bd71b07f16b7cf5ac37941b5adf82507b091.jpg)  
第三种情况，删除前结点关键字个数$n=\lceil m/2\rceil-1$，若这时与该结点相邻结点的关键字个数$n=\lceil m/2\rceil-1$，则需要合并结点，此时进行如下操作。  
（1）将双亲结点$p$中相应关键字下移到选定保留的结点中。若要合并$ p$中的子树指针$p_{i}$与$p_{i+1}$所指的结点，且保留$p_{i}$所指结点，则把$p$中的关键字 $K_{i+1}$下移到${p_{i}}$所指的结点中。  
（2）把$p$中子树指针$p_{i+1}$所指结点中的全部指针和关键字都照搬到$p_{i}$所指结点的后面。删除$p_{i+1}$所指的结点。  
（3）在结点$p$中用后面剩余的关键字和指针填补关键字$ K_{i+1}$和指针$p_{i+1}$。（4）修改结点$p$和选定保留结点的关键字个数。  
![图9-52 删除关键字34 ](images/130adeccab6191bae16abb56a1ff2b3f7f293b7623158136968270de0ce26b94.jpg)  
图9-52 表示从散阶$\cdot B$树中删除关键字34。由于34 所在结点关键字个数为1，满足 $n=\lceil m/2\rceil-1$，其右兄弟结点的关键字数目也为1，且满足$n=\lceil m/2\rceil-1$，因此需要合并结点。我们将双亲结点中相应的关键字52 下移到关键字34 所在结点，然后把关键字58 所在结点也合并过来；然后我们删除关键字34，并把后面的关键字和指针进行填充，修改这个新结点和双亲结点的关键字数目。  
需要指出的是，删除操作有可能并未结束。可以看到，在合并结点的过程中，双亲节点中的关键字个数减少了。这里还需要分情况讨论，如果双亲节点是根结点且结点关键字个数减到0，则该双亲结点应从树上删去，合并后保留的结点成为新的根结点；如果双亲结点不是根结点，且关键字个数减到$\lceil m/2\rceil-2$，就要与它自己的兄弟结点合并，重复上面的合并步骤。最坏情况下这种结点合并处理要自底向上直到根结点。  
讨论完待删除关键字所在结点为叶结点的情况之后，现在再看待删除关键字所在结点不是叶结点的情况。如果关键字所在街道不是叶子结点，则在删去该关键字之后，以该结点$p_{i}$所指示子树中的最小关键字$x$来代替被删除关键字$ k_{i}$所在的位置，然后再$x$ 所在的叶子结点中删除$x$。此时，问题就转化为已讨论过的删除关键字所在的叶子结点的情况。  
![图9-53 删除关键字26  ](images/489b496fafb3e3db479d787ce84e086bf73b456a443ded3cb295556432ff8f58.jpg)  
如图9-53 所示从三阶$B$树中删除关键字26。关键字26 所在结点不是叶子结点，所以从右子树中取出最小关键字34 代替26，然后从叶子结点中删除关键字34，由于叶子结点中关键字个数满足$n\geq\lceil m/2\rceil$，所以直接删去这个关键字就可以了。",在B树模型中，删除操作可能需要将双亲结点中的关键字下移。
B树模型,关键字上移,兄弟结点,,"插入操作只可以从叶结点插入，而删除则可以从任意结点中删除一个关键字，所以删除操作比插入操作需要考虑的情况更加复杂。  
如果待删除关键字所在的结点是叶子结点，则此时可以分3 种情况进行讨论。第一种情况，若删除前该结点中关键字个数$n\geq\lceil m/2\rceil$，那么直接删除该结点。  
下图9-50 所示为从一棵3 阶$B$树上删除关键字34，由于关键字34 所在的结点为叶子结点，并且该结点中关键字个数为2，满足$n\geq\lceil m/2\rceil$，意味着删除一个关键字后任然满足结点中关键字数目的下限，因此可以直接删去该结点。  
第二种情况，删除前结点关键字个数为$n=\lceil m/2\rceil-1$，若这时与该结点相邻结点的关键字个数$ n\geq\lceil m/2\rceil$，则进行如下操作。  
（1）将双亲结点中刚刚大于（或小于）该被删除关键字的关键字$K_{i}$，$1\leq i\leq n$下移。  
（2）将右兄弟（或左兄弟）结点中的最小（或最大）关键字上移到双亲节点的$K_{i}$ 位置。  
（3）将右兄弟（或左兄弟）结点中的最左（或最右）子树指针平移到被删关键字所在结点中最后（或最前）子树指针位置的$K_{i}$位置。  
（4）在右兄弟（或左兄弟）结点中，将被移走的关键字和指针位置用剩余的关键字和指针填补，在将结点中的关键字个数减1。  
![图9-50 删除关键字34 ](images/f864ab87d251f5dafed3b48570754b8e2382312f7013353a88638ad1de9a43c0.jpg)  
图9-51 表示从三阶$B$树上删除关键字58。由于关键字58 所在结点为叶子结点但 不是根结点，所在叶子结点的关键字个数为1，为$n=\lceil m/2\rceil-1$，且相邻的右兄弟结点有两个关键字，满足$.n\geq\lceil m/2\rceil$，因此我们从58 所在结点的双亲结点找到刚刚大于58 的关键字77，将关键字70 下移，而把相邻的右兄弟结点中最小的关键字77 上移，最后在右兄弟结点中将被移走的关键字77 和对应的指针位置用这个阶段中剩下的关键字和指针填充，并将右兄弟结点的关键字数目减1。  
![图9-51 删除关键字58](images/684ee19f4e14eabfcd5ca29d8d44bd71b07f16b7cf5ac37941b5adf82507b091.jpg)  
第三种情况，删除前结点关键字个数$n=\lceil m/2\rceil-1$，若这时与该结点相邻结点的关键字个数$n=\lceil m/2\rceil-1$，则需要合并结点，此时进行如下操作。  
（1）将双亲结点$p$中相应关键字下移到选定保留的结点中。若要合并$ p$中的子树指针$p_{i}$与$p_{i+1}$所指的结点，且保留$p_{i}$所指结点，则把$p$中的关键字 $K_{i+1}$下移到${p_{i}}$所指的结点中。  
（2）把$p$中子树指针$p_{i+1}$所指结点中的全部指针和关键字都照搬到$p_{i}$所指结点的后面。删除$p_{i+1}$所指的结点。  
（3）在结点$p$中用后面剩余的关键字和指针填补关键字$ K_{i+1}$和指针$p_{i+1}$。（4）修改结点$p$和选定保留结点的关键字个数。  
![图9-52 删除关键字34 ](images/130adeccab6191bae16abb56a1ff2b3f7f293b7623158136968270de0ce26b94.jpg)  
图9-52 表示从散阶$\cdot B$树中删除关键字34。由于34 所在结点关键字个数为1，满足 $n=\lceil m/2\rceil-1$，其右兄弟结点的关键字数目也为1，且满足$n=\lceil m/2\rceil-1$，因此需要合并结点。我们将双亲结点中相应的关键字52 下移到关键字34 所在结点，然后把关键字58 所在结点也合并过来；然后我们删除关键字34，并把后面的关键字和指针进行填充，修改这个新结点和双亲结点的关键字数目。  
需要指出的是，删除操作有可能并未结束。可以看到，在合并结点的过程中，双亲节点中的关键字个数减少了。这里还需要分情况讨论，如果双亲节点是根结点且结点关键字个数减到0，则该双亲结点应从树上删去，合并后保留的结点成为新的根结点；如果双亲结点不是根结点，且关键字个数减到$\lceil m/2\rceil-2$，就要与它自己的兄弟结点合并，重复上面的合并步骤。最坏情况下这种结点合并处理要自底向上直到根结点。  
讨论完待删除关键字所在结点为叶结点的情况之后，现在再看待删除关键字所在结点不是叶结点的情况。如果关键字所在街道不是叶子结点，则在删去该关键字之后，以该结点$p_{i}$所指示子树中的最小关键字$x$来代替被删除关键字$ k_{i}$所在的位置，然后再$x$ 所在的叶子结点中删除$x$。此时，问题就转化为已讨论过的删除关键字所在的叶子结点的情况。  
![图9-53 删除关键字26  ](images/489b496fafb3e3db479d787ce84e086bf73b456a443ded3cb295556432ff8f58.jpg)  
如图9-53 所示从三阶$B$树中删除关键字26。关键字26 所在结点不是叶子结点，所以从右子树中取出最小关键字34 代替26，然后从叶子结点中删除关键字34，由于叶子结点中关键字个数满足$n\geq\lceil m/2\rceil$，所以直接删去这个关键字就可以了。",在B树模型中，删除操作可能需要将兄弟结点中的关键字上移。
B树模型,删除操作,结点合并,,"插入操作只可以从叶结点插入，而删除则可以从任意结点中删除一个关键字，所以删除操作比插入操作需要考虑的情况更加复杂。  
如果待删除关键字所在的结点是叶子结点，则此时可以分3 种情况进行讨论。第一种情况，若删除前该结点中关键字个数$n\geq\lceil m/2\rceil$，那么直接删除该结点。  
下图9-50 所示为从一棵3 阶$B$树上删除关键字34，由于关键字34 所在的结点为叶子结点，并且该结点中关键字个数为2，满足$n\geq\lceil m/2\rceil$，意味着删除一个关键字后任然满足结点中关键字数目的下限，因此可以直接删去该结点。  
第二种情况，删除前结点关键字个数为$n=\lceil m/2\rceil-1$，若这时与该结点相邻结点的关键字个数$ n\geq\lceil m/2\rceil$，则进行如下操作。  
（1）将双亲结点中刚刚大于（或小于）该被删除关键字的关键字$K_{i}$，$1\leq i\leq n$下移。  
（2）将右兄弟（或左兄弟）结点中的最小（或最大）关键字上移到双亲节点的$K_{i}$ 位置。  
（3）将右兄弟（或左兄弟）结点中的最左（或最右）子树指针平移到被删关键字所在结点中最后（或最前）子树指针位置的$K_{i}$位置。  
（4）在右兄弟（或左兄弟）结点中，将被移走的关键字和指针位置用剩余的关键字和指针填补，在将结点中的关键字个数减1。  
![图9-50 删除关键字34 ](images/f864ab87d251f5dafed3b48570754b8e2382312f7013353a88638ad1de9a43c0.jpg)  
图9-51 表示从三阶$B$树上删除关键字58。由于关键字58 所在结点为叶子结点但 不是根结点，所在叶子结点的关键字个数为1，为$n=\lceil m/2\rceil-1$，且相邻的右兄弟结点有两个关键字，满足$.n\geq\lceil m/2\rceil$，因此我们从58 所在结点的双亲结点找到刚刚大于58 的关键字77，将关键字70 下移，而把相邻的右兄弟结点中最小的关键字77 上移，最后在右兄弟结点中将被移走的关键字77 和对应的指针位置用这个阶段中剩下的关键字和指针填充，并将右兄弟结点的关键字数目减1。  
![图9-51 删除关键字58](images/684ee19f4e14eabfcd5ca29d8d44bd71b07f16b7cf5ac37941b5adf82507b091.jpg)  
第三种情况，删除前结点关键字个数$n=\lceil m/2\rceil-1$，若这时与该结点相邻结点的关键字个数$n=\lceil m/2\rceil-1$，则需要合并结点，此时进行如下操作。  
（1）将双亲结点$p$中相应关键字下移到选定保留的结点中。若要合并$ p$中的子树指针$p_{i}$与$p_{i+1}$所指的结点，且保留$p_{i}$所指结点，则把$p$中的关键字 $K_{i+1}$下移到${p_{i}}$所指的结点中。  
（2）把$p$中子树指针$p_{i+1}$所指结点中的全部指针和关键字都照搬到$p_{i}$所指结点的后面。删除$p_{i+1}$所指的结点。  
（3）在结点$p$中用后面剩余的关键字和指针填补关键字$ K_{i+1}$和指针$p_{i+1}$。（4）修改结点$p$和选定保留结点的关键字个数。  
![图9-52 删除关键字34 ](images/130adeccab6191bae16abb56a1ff2b3f7f293b7623158136968270de0ce26b94.jpg)  
图9-52 表示从散阶$\cdot B$树中删除关键字34。由于34 所在结点关键字个数为1，满足 $n=\lceil m/2\rceil-1$，其右兄弟结点的关键字数目也为1，且满足$n=\lceil m/2\rceil-1$，因此需要合并结点。我们将双亲结点中相应的关键字52 下移到关键字34 所在结点，然后把关键字58 所在结点也合并过来；然后我们删除关键字34，并把后面的关键字和指针进行填充，修改这个新结点和双亲结点的关键字数目。  
需要指出的是，删除操作有可能并未结束。可以看到，在合并结点的过程中，双亲节点中的关键字个数减少了。这里还需要分情况讨论，如果双亲节点是根结点且结点关键字个数减到0，则该双亲结点应从树上删去，合并后保留的结点成为新的根结点；如果双亲结点不是根结点，且关键字个数减到$\lceil m/2\rceil-2$，就要与它自己的兄弟结点合并，重复上面的合并步骤。最坏情况下这种结点合并处理要自底向上直到根结点。  
讨论完待删除关键字所在结点为叶结点的情况之后，现在再看待删除关键字所在结点不是叶结点的情况。如果关键字所在街道不是叶子结点，则在删去该关键字之后，以该结点$p_{i}$所指示子树中的最小关键字$x$来代替被删除关键字$ k_{i}$所在的位置，然后再$x$ 所在的叶子结点中删除$x$。此时，问题就转化为已讨论过的删除关键字所在的叶子结点的情况。  
![图9-53 删除关键字26  ](images/489b496fafb3e3db479d787ce84e086bf73b456a443ded3cb295556432ff8f58.jpg)  
如图9-53 所示从三阶$B$树中删除关键字26。关键字26 所在结点不是叶子结点，所以从右子树中取出最小关键字34 代替26，然后从叶子结点中删除关键字34，由于叶子结点中关键字个数满足$n\geq\lceil m/2\rceil$，所以直接删去这个关键字就可以了。",在B树模型中，删除操作可能导致结点合并，以保持树的平衡。
B树模型,删除操作影响,根结点,,"插入操作只可以从叶结点插入，而删除则可以从任意结点中删除一个关键字，所以删除操作比插入操作需要考虑的情况更加复杂。  
如果待删除关键字所在的结点是叶子结点，则此时可以分3 种情况进行讨论。第一种情况，若删除前该结点中关键字个数$n\geq\lceil m/2\rceil$，那么直接删除该结点。  
下图9-50 所示为从一棵3 阶$B$树上删除关键字34，由于关键字34 所在的结点为叶子结点，并且该结点中关键字个数为2，满足$n\geq\lceil m/2\rceil$，意味着删除一个关键字后任然满足结点中关键字数目的下限，因此可以直接删去该结点。  
第二种情况，删除前结点关键字个数为$n=\lceil m/2\rceil-1$，若这时与该结点相邻结点的关键字个数$ n\geq\lceil m/2\rceil$，则进行如下操作。  
（1）将双亲结点中刚刚大于（或小于）该被删除关键字的关键字$K_{i}$，$1\leq i\leq n$下移。  
（2）将右兄弟（或左兄弟）结点中的最小（或最大）关键字上移到双亲节点的$K_{i}$ 位置。  
（3）将右兄弟（或左兄弟）结点中的最左（或最右）子树指针平移到被删关键字所在结点中最后（或最前）子树指针位置的$K_{i}$位置。  
（4）在右兄弟（或左兄弟）结点中，将被移走的关键字和指针位置用剩余的关键字和指针填补，在将结点中的关键字个数减1。  
![图9-50 删除关键字34 ](images/f864ab87d251f5dafed3b48570754b8e2382312f7013353a88638ad1de9a43c0.jpg)  
图9-51 表示从三阶$B$树上删除关键字58。由于关键字58 所在结点为叶子结点但 不是根结点，所在叶子结点的关键字个数为1，为$n=\lceil m/2\rceil-1$，且相邻的右兄弟结点有两个关键字，满足$.n\geq\lceil m/2\rceil$，因此我们从58 所在结点的双亲结点找到刚刚大于58 的关键字77，将关键字70 下移，而把相邻的右兄弟结点中最小的关键字77 上移，最后在右兄弟结点中将被移走的关键字77 和对应的指针位置用这个阶段中剩下的关键字和指针填充，并将右兄弟结点的关键字数目减1。  
![图9-51 删除关键字58](images/684ee19f4e14eabfcd5ca29d8d44bd71b07f16b7cf5ac37941b5adf82507b091.jpg)  
第三种情况，删除前结点关键字个数$n=\lceil m/2\rceil-1$，若这时与该结点相邻结点的关键字个数$n=\lceil m/2\rceil-1$，则需要合并结点，此时进行如下操作。  
（1）将双亲结点$p$中相应关键字下移到选定保留的结点中。若要合并$ p$中的子树指针$p_{i}$与$p_{i+1}$所指的结点，且保留$p_{i}$所指结点，则把$p$中的关键字 $K_{i+1}$下移到${p_{i}}$所指的结点中。  
（2）把$p$中子树指针$p_{i+1}$所指结点中的全部指针和关键字都照搬到$p_{i}$所指结点的后面。删除$p_{i+1}$所指的结点。  
（3）在结点$p$中用后面剩余的关键字和指针填补关键字$ K_{i+1}$和指针$p_{i+1}$。（4）修改结点$p$和选定保留结点的关键字个数。  
![图9-52 删除关键字34 ](images/130adeccab6191bae16abb56a1ff2b3f7f293b7623158136968270de0ce26b94.jpg)  
图9-52 表示从散阶$\cdot B$树中删除关键字34。由于34 所在结点关键字个数为1，满足 $n=\lceil m/2\rceil-1$，其右兄弟结点的关键字数目也为1，且满足$n=\lceil m/2\rceil-1$，因此需要合并结点。我们将双亲结点中相应的关键字52 下移到关键字34 所在结点，然后把关键字58 所在结点也合并过来；然后我们删除关键字34，并把后面的关键字和指针进行填充，修改这个新结点和双亲结点的关键字数目。  
需要指出的是，删除操作有可能并未结束。可以看到，在合并结点的过程中，双亲节点中的关键字个数减少了。这里还需要分情况讨论，如果双亲节点是根结点且结点关键字个数减到0，则该双亲结点应从树上删去，合并后保留的结点成为新的根结点；如果双亲结点不是根结点，且关键字个数减到$\lceil m/2\rceil-2$，就要与它自己的兄弟结点合并，重复上面的合并步骤。最坏情况下这种结点合并处理要自底向上直到根结点。  
讨论完待删除关键字所在结点为叶结点的情况之后，现在再看待删除关键字所在结点不是叶结点的情况。如果关键字所在街道不是叶子结点，则在删去该关键字之后，以该结点$p_{i}$所指示子树中的最小关键字$x$来代替被删除关键字$ k_{i}$所在的位置，然后再$x$ 所在的叶子结点中删除$x$。此时，问题就转化为已讨论过的删除关键字所在的叶子结点的情况。  
![图9-53 删除关键字26  ](images/489b496fafb3e3db479d787ce84e086bf73b456a443ded3cb295556432ff8f58.jpg)  
如图9-53 所示从三阶$B$树中删除关键字26。关键字26 所在结点不是叶子结点，所以从右子树中取出最小关键字34 代替26，然后从叶子结点中删除关键字34，由于叶子结点中关键字个数满足$n\geq\lceil m/2\rceil$，所以直接删去这个关键字就可以了。",在B树模型中，删除操作可能导致根结点的变化，甚至删除根结点。
B树模型,删除操作,非叶子结点,,"插入操作只可以从叶结点插入，而删除则可以从任意结点中删除一个关键字，所以删除操作比插入操作需要考虑的情况更加复杂。  
如果待删除关键字所在的结点是叶子结点，则此时可以分3 种情况进行讨论。第一种情况，若删除前该结点中关键字个数$n\geq\lceil m/2\rceil$，那么直接删除该结点。  
下图9-50 所示为从一棵3 阶$B$树上删除关键字34，由于关键字34 所在的结点为叶子结点，并且该结点中关键字个数为2，满足$n\geq\lceil m/2\rceil$，意味着删除一个关键字后任然满足结点中关键字数目的下限，因此可以直接删去该结点。  
第二种情况，删除前结点关键字个数为$n=\lceil m/2\rceil-1$，若这时与该结点相邻结点的关键字个数$ n\geq\lceil m/2\rceil$，则进行如下操作。  
（1）将双亲结点中刚刚大于（或小于）该被删除关键字的关键字$K_{i}$，$1\leq i\leq n$下移。  
（2）将右兄弟（或左兄弟）结点中的最小（或最大）关键字上移到双亲节点的$K_{i}$ 位置。  
（3）将右兄弟（或左兄弟）结点中的最左（或最右）子树指针平移到被删关键字所在结点中最后（或最前）子树指针位置的$K_{i}$位置。  
（4）在右兄弟（或左兄弟）结点中，将被移走的关键字和指针位置用剩余的关键字和指针填补，在将结点中的关键字个数减1。  
![图9-50 删除关键字34 ](images/f864ab87d251f5dafed3b48570754b8e2382312f7013353a88638ad1de9a43c0.jpg)  
图9-51 表示从三阶$B$树上删除关键字58。由于关键字58 所在结点为叶子结点但 不是根结点，所在叶子结点的关键字个数为1，为$n=\lceil m/2\rceil-1$，且相邻的右兄弟结点有两个关键字，满足$.n\geq\lceil m/2\rceil$，因此我们从58 所在结点的双亲结点找到刚刚大于58 的关键字77，将关键字70 下移，而把相邻的右兄弟结点中最小的关键字77 上移，最后在右兄弟结点中将被移走的关键字77 和对应的指针位置用这个阶段中剩下的关键字和指针填充，并将右兄弟结点的关键字数目减1。  
![图9-51 删除关键字58](images/684ee19f4e14eabfcd5ca29d8d44bd71b07f16b7cf5ac37941b5adf82507b091.jpg)  
第三种情况，删除前结点关键字个数$n=\lceil m/2\rceil-1$，若这时与该结点相邻结点的关键字个数$n=\lceil m/2\rceil-1$，则需要合并结点，此时进行如下操作。  
（1）将双亲结点$p$中相应关键字下移到选定保留的结点中。若要合并$ p$中的子树指针$p_{i}$与$p_{i+1}$所指的结点，且保留$p_{i}$所指结点，则把$p$中的关键字 $K_{i+1}$下移到${p_{i}}$所指的结点中。  
（2）把$p$中子树指针$p_{i+1}$所指结点中的全部指针和关键字都照搬到$p_{i}$所指结点的后面。删除$p_{i+1}$所指的结点。  
（3）在结点$p$中用后面剩余的关键字和指针填补关键字$ K_{i+1}$和指针$p_{i+1}$。（4）修改结点$p$和选定保留结点的关键字个数。  
![图9-52 删除关键字34 ](images/130adeccab6191bae16abb56a1ff2b3f7f293b7623158136968270de0ce26b94.jpg)  
图9-52 表示从散阶$\cdot B$树中删除关键字34。由于34 所在结点关键字个数为1，满足 $n=\lceil m/2\rceil-1$，其右兄弟结点的关键字数目也为1，且满足$n=\lceil m/2\rceil-1$，因此需要合并结点。我们将双亲结点中相应的关键字52 下移到关键字34 所在结点，然后把关键字58 所在结点也合并过来；然后我们删除关键字34，并把后面的关键字和指针进行填充，修改这个新结点和双亲结点的关键字数目。  
需要指出的是，删除操作有可能并未结束。可以看到，在合并结点的过程中，双亲节点中的关键字个数减少了。这里还需要分情况讨论，如果双亲节点是根结点且结点关键字个数减到0，则该双亲结点应从树上删去，合并后保留的结点成为新的根结点；如果双亲结点不是根结点，且关键字个数减到$\lceil m/2\rceil-2$，就要与它自己的兄弟结点合并，重复上面的合并步骤。最坏情况下这种结点合并处理要自底向上直到根结点。  
讨论完待删除关键字所在结点为叶结点的情况之后，现在再看待删除关键字所在结点不是叶结点的情况。如果关键字所在街道不是叶子结点，则在删去该关键字之后，以该结点$p_{i}$所指示子树中的最小关键字$x$来代替被删除关键字$ k_{i}$所在的位置，然后再$x$ 所在的叶子结点中删除$x$。此时，问题就转化为已讨论过的删除关键字所在的叶子结点的情况。  
![图9-53 删除关键字26  ](images/489b496fafb3e3db479d787ce84e086bf73b456a443ded3cb295556432ff8f58.jpg)  
如图9-53 所示从三阶$B$树中删除关键字26。关键字26 所在结点不是叶子结点，所以从右子树中取出最小关键字34 代替26，然后从叶子结点中删除关键字34，由于叶子结点中关键字个数满足$n\geq\lceil m/2\rceil$，所以直接删去这个关键字就可以了。",在B树模型中，删除非叶子结点的关键字需要用子树中的最小关键字替代。
树模型,应用,树模型算法,,基于树模型的算法应用范围十分广泛，本节通过介绍若干树模型的一些常见应用，以进一步阐述树模型算法的构造、优化原则和方法，便于读者更加深入彻底地认识和掌握该类算法的设计与应用。,树模型算法是基于树模型的应用，通过介绍树模型的常见应用，阐述树模型算法的构造、优化原则和方法
找假币问题,应用,决策树,,"所谓找假币问题，就是有若干外观完全一样的硬币，其中有一个是假币，该假币的种类与其余硬币在重量上有一定差异，需要通过称重的方式把该假币找出来。这种找假币问题，其实可以看作为一种决策问题，即根据每一步的决策，选择走相应的步骤。  
对于决策问题，首先想到的是使用决策树来解决。从树根开始，每次回答一个问题，走相应的边，最后将会达到一个叶结点，即做出了选择。这样的一棵树称为决策树。例如，女孩子被父母安排相亲，为了确定见与不见，他可能会考虑诸如：年龄、长相、收入等问题。图9-54 所示的决策树就是她可能的一种决策过程。  
决策树作为树模型的一个典型应用，它可以把做出判决的逻辑关系用树结构的形式表现出来，最后的结果都集中在叶子上，条理清晰，一目了然，并且可以用决策树表示算法，使得在最坏情形下花费时间最少。因此，可以采取一种经典的树模型——决策树来解决这个问题。下面介绍两种基于决策树的解法，分别体现在如下问题一和问题二中，一种是基于两两比较的策略，另一种是基于分组比较的策略。  
![图9-54 是否相亲决策树  ](images/55dcf1b53e3f3d285d392dd47362956c928f6b44dead3c11e073f8a4468ae02e.jpg)  
![图9-55  3 元决策树](images/a77add97a68ea00460ddd28f80a5c06982291c918c8a7cf75e04eb033d4979ac.jpg)  
问题一、现有5 枚外观相同的硬币，其中有1 枚是假的，假币与真币在重量上有差异，但不知孰重孰轻。问如何使用一架无砝码天平找出假币并判别其与真币的重量关系？  
问题分析与求解：用天平来称𝐴和𝐵两枚硬币，只有$A<B$、$A=B$、$A>B$三种可能的情形，因此可构造3 元决策树来解决。如图9-54 所示。  
由图9-55 可知，从根到叶就是一种求解过程，由于该树有10 片叶子，因此最多有十种可能的解。又由于树高为3，因此最坏情形下需要3 次判别就能得到结论。  
问题二、现有12 个外观相同的硬币，其中有一枚是假的，且已知假币比真币重，要求用一个无砝码天平，只称3 次，把假币找出来。  
问题分析与求解：把硬币等分成三份，用天平分别对这三份进行称重。确定假币在哪一份，之后再对假币所在的那一份进行等分，并称重，直到找到假币。如图9-56 所示。  
![图9-56 决策树  ](images/db3a037f92dd9e6a550f65f863d04f248565341ddf14fb1910ec84f7e7556b97.jpg)  
决策树在生活中有着广泛的应用，除了解决假币问题，还可以解决排序类问题。  
例如，为了确定$𝐴$，$B$，$C$的大小顺序，我们可以采用如图9-57 所示的决策树模型来解决，每条边都用非叶结点基于问题答案的表排列进行标注，叶结点给出了排好的顺序.令最坏情形下的比较次数为排序的最坏时间情形，图9-57 所示的算法给出的最坏情形时间为3，可以证明这个算法是最优的。  
可以用反证法证明，没有其它算法能在最坏时间小于3 对3 个项排好序。假设存在一个这样的算法，并用基础上描述，因为最坏情形排序时间小于等于2，树高则小于等于2，因为每个叶结点最多有两个子结点，则这棵树最多有4 个叶结点。每个叶结点对应一个可能的结果，所以决策树高度小于等于2 的决策树最多只有4 个结果，但3 个项的排序有6种可能结果，这就产生了矛盾。因此，图9-58 的算法是最优的。  
同理，因为$4!=\!24$，所以对4 个项排序有24 种结果。对应24 个叶结点，必须要有树高至少为5 的决策树，因此对4 个项排序的任一算法，在最坏情形下至少要进行5 次比较。更多项的排序可以此类推，不再赘述。",找假币问题可以通过决策树来解决，决策树能够将决策逻辑用树结构表示，帮助找到假币并判断其重量关系
决策树,应用,排序类问题,,"所谓找假币问题，就是有若干外观完全一样的硬币，其中有一个是假币，该假币的种类与其余硬币在重量上有一定差异，需要通过称重的方式把该假币找出来。这种找假币问题，其实可以看作为一种决策问题，即根据每一步的决策，选择走相应的步骤。  
对于决策问题，首先想到的是使用决策树来解决。从树根开始，每次回答一个问题，走相应的边，最后将会达到一个叶结点，即做出了选择。这样的一棵树称为决策树。例如，女孩子被父母安排相亲，为了确定见与不见，他可能会考虑诸如：年龄、长相、收入等问题。图9-54 所示的决策树就是她可能的一种决策过程。  
决策树作为树模型的一个典型应用，它可以把做出判决的逻辑关系用树结构的形式表现出来，最后的结果都集中在叶子上，条理清晰，一目了然，并且可以用决策树表示算法，使得在最坏情形下花费时间最少。因此，可以采取一种经典的树模型——决策树来解决这个问题。下面介绍两种基于决策树的解法，分别体现在如下问题一和问题二中，一种是基于两两比较的策略，另一种是基于分组比较的策略。  
![图9-54 是否相亲决策树  ](images/55dcf1b53e3f3d285d392dd47362956c928f6b44dead3c11e073f8a4468ae02e.jpg)  
![图9-55  3 元决策树](images/a77add97a68ea00460ddd28f80a5c06982291c918c8a7cf75e04eb033d4979ac.jpg)  
问题一、现有5 枚外观相同的硬币，其中有1 枚是假的，假币与真币在重量上有差异，但不知孰重孰轻。问如何使用一架无砝码天平找出假币并判别其与真币的重量关系？  
问题分析与求解：用天平来称𝐴和𝐵两枚硬币，只有$A<B$、$A=B$、$A>B$三种可能的情形，因此可构造3 元决策树来解决。如图9-54 所示。  
由图9-55 可知，从根到叶就是一种求解过程，由于该树有10 片叶子，因此最多有十种可能的解。又由于树高为3，因此最坏情形下需要3 次判别就能得到结论。  
问题二、现有12 个外观相同的硬币，其中有一枚是假的，且已知假币比真币重，要求用一个无砝码天平，只称3 次，把假币找出来。  
问题分析与求解：把硬币等分成三份，用天平分别对这三份进行称重。确定假币在哪一份，之后再对假币所在的那一份进行等分，并称重，直到找到假币。如图9-56 所示。  
![图9-56 决策树  ](images/db3a037f92dd9e6a550f65f863d04f248565341ddf14fb1910ec84f7e7556b97.jpg)  
决策树在生活中有着广泛的应用，除了解决假币问题，还可以解决排序类问题。  
例如，为了确定$𝐴$，$B$，$C$的大小顺序，我们可以采用如图9-57 所示的决策树模型来解决，每条边都用非叶结点基于问题答案的表排列进行标注，叶结点给出了排好的顺序.令最坏情形下的比较次数为排序的最坏时间情形，图9-57 所示的算法给出的最坏情形时间为3，可以证明这个算法是最优的。  
可以用反证法证明，没有其它算法能在最坏时间小于3 对3 个项排好序。假设存在一个这样的算法，并用基础上描述，因为最坏情形排序时间小于等于2，树高则小于等于2，因为每个叶结点最多有两个子结点，则这棵树最多有4 个叶结点。每个叶结点对应一个可能的结果，所以决策树高度小于等于2 的决策树最多只有4 个结果，但3 个项的排序有6种可能结果，这就产生了矛盾。因此，图9-58 的算法是最优的。  
同理，因为$4!=\!24$，所以对4 个项排序有24 种结果。对应24 个叶结点，必须要有树高至少为5 的决策树，因此对4 个项排序的任一算法，在最坏情形下至少要进行5 次比较。更多项的排序可以此类推，不再赘述。",决策树可以应用于排序类问题，通过树结构模型确定项的顺序，并优化最坏情况下的比较次数
博弈,包含,轮流摸牌问题,,"生活中，下棋、打牌、竞技等一类竞争性的活动称为博弈。对垒的双方轮流采取行动，博弈的结果仅有三种：胜、败、平局。在对垒过程中，任何一方都了解当前的格局及过去的历史。任何一方在采取行动前都要根据当前的实际情况，进行得失分析，选取对自己有利而对对方最为不利的对策，不存在掷骰子之类的破运气因素，双方必须很明智的决定自己的行为。轮流摸牌问题，作为一种经典的博奕类游戏，问题的具体描述如下：  
桌上有𝑀堆扑克牌，每堆牌的数量分别为$N_{i}(i=1,2,\dots,M)$。现有两个选手，分别记为先手和后手，轮流进行摸牌，每一次摸牌可以任意选择一堆并取走其中的任意张牌，规定每次至少取一张，多者不限；桌上的扑克牌全部取光，则游戏结束，那么最后一次摸牌的选手即为胜者。现在问题如下：先手如果想赢，第一步有几种选择?  
轮流摸牌问题可以采用博弈树解决。博弈树是一种特殊的树模型，它的每个结点表示游戏进行时的一种局面，用每条边表示这些局面之间合乎规则的演变或移动。博弈树通常比较庞大，通常需要对其进行化简才能高效地使用。  
图9-58 所示为初始的三堆扑克牌数量。第一堆和第二堆的扑克牌数量都为3 张，第三 堆扑克牌的数量为1 张，组成了初始状态(3，3，1)。  
![图9-57  大小排序决策树 ](images/f1b07d5e01fd3916fd51d458c21160476d888d5cdc01f2f4b52f54e88d66df57.jpg)  
![图9-58 三堆扑克牌  ](images/785c75f0b4653bbc64b450a41c28647f0642a850ef357c53771601a74297ee17.jpg)  
图9-58 所示的博弈树表示轮流摸扑克牌游戏在给定初始状态（3，3，1）扩展下的所 有对弈策略。用不同堆中扑克牌数组成的无序序列表示每个局面（堆的顺序无关紧要）。先手第一次可以从有3 张扑克牌的堆中摸1 张牌（剩下包含3 张、2 张、1 张扑克牌的3堆）；也可以从有3 张扑克牌的堆中取3 张（剩下包含3 张、1 张扑克牌的2 堆）；也可以从有1 张扑克牌的堆中取1 张（剩下包含3 张扑克牌的2 堆）。当扑克牌被最后一个选手取完了，下一个选手就无法再继续摸牌，这样的局面就是终局。轮流摸扑克牌游戏是非胜即负的游戏，规定用$F$ 标记表示先手获胜，用$L$ 标记表示后手获胜。  
![图9-59 轮流取扑克牌游戏的博弈树 ](images/3e2c6b2d2a79242f7f10f5a0e2d1714f56d6c5d793d99a4f5932038bcf4cd8fa.jpg)  
根据图9-59，我们可以发现，先手如果想必赢，第一步只有一种选择，即只能从有1 张扑克牌的堆中取1 张，而不能从其它堆中摸扑克牌。  
进一步对图9-59 进行分析，可知：  
1）状态（3，3，1）必胜点，那么先手取完棋子后，后手必落在必败点；  
2）若初始状态下，只有一堆扑克牌，先手必胜； 3）若有$𝑀$堆扑克牌，每堆只有一张扑克牌，$M$为奇数时，先手必胜；  
4）若有𝑀堆扑克牌，每堆只有$k$张扑克牌，$M$为奇数时，先手必胜；  
5）先手摸𝑘张扑克牌，轮到对手时，若对手取$𝑘$张，则先手也取$𝑘$张；若对手取$x<k$张，则先手也取另外一堆的$𝑥$张。因为剩下的是偶数堆，则先手也取$𝑘$张扑克牌，总能将剩下的堆变成若干个两两相等的堆。只要始终保持这种取法，先手总能取到最后的扑克牌。  
可以将上述局面推广至一般：若某个初始局面为先手必胜，那么每走一步都必须使后首落在必败点。因此对于每一个局面，要么为胜局面，要么为负局面。用非0 表示表示胜局面，0 表示负局面。对于某一个局面，若为非0 局面，它的任务就是要寻找某一种取法，使局面变为 0  局面。那么其对手无论怎么取，都会使局面又变为 0  局面。  
那么这种对弈有什么规律呢？  
如果一个局面为先手必胜，就称这为$N$局面；反之称之为$ P$局面。对于一个局面，令$S=$$P_{1}\oplus P_{2}\oplus\ldots\oplus P_{n}$。若$S=0$则为$ P$局面，否则就为$ N$局面（⊕为异或）。  
对于图9-4-5，我们将3 堆扑克牌数异或，即$3{\oplus}3{\oplus}1{=}011{\oplus}011{\oplus}001{=}1$，异或结果为非0，那么先手将赢得这局游戏。因此先手第一步需要从第三堆中摸一张扑克牌。  
下面我们考虑下4 堆扑克牌对弈策略。其中各堆的大小分别为4，5，9，15。用二进制表示各数分别为0100，0101，1001，1111。表4-1 为各堆数量对应的二进制数。  
将这四堆扑克牌数进行异或，得到0100⊕0101⊕1001⊕1111=0111。结果非0，那么先手会赢。因此先手可以从大小为4 的堆中取走1 张牌剩下3 张，后者从大小为5 的堆中取走 3  张牌剩下 2  张，再或者从大小为 15  的堆中取走 7  张牌剩下 8  张。  
轮流摸扑克牌游戏为典型的尼姆博弈问题。尼姆博弈的关键在于游戏开始时游戏处于何种状态（平衡或非平衡）和先手是否能够按照取子游戏的获胜策略来进行游戏。  
![表9-1  各堆数量对应的二进制数 ](images/621116a8789d5d8ecab422f6290df5764c10b51f7ad37caba7ad4b05a6de41e9.jpg)  
实际生活中还有许多有益的博弈，比如一字棋、国际象棋和方棋格等等。此外，这种博弈的方法已经应用到很多的计算机程序研究中。某些博弈程序都能做到与人类选手进行对决，比如国际象棋等，可以看到如何将树应用到博弈策略的研究中具有重要的现实意义.有关博弈策略的更多内容，读者可以查阅相关资料进一步学习，这里不再赘述。",轮流摸牌问题是博弈的一种经典形式
轮流摸牌问题,应用,博弈树,,"生活中，下棋、打牌、竞技等一类竞争性的活动称为博弈。对垒的双方轮流采取行动，博弈的结果仅有三种：胜、败、平局。在对垒过程中，任何一方都了解当前的格局及过去的历史。任何一方在采取行动前都要根据当前的实际情况，进行得失分析，选取对自己有利而对对方最为不利的对策，不存在掷骰子之类的破运气因素，双方必须很明智的决定自己的行为。轮流摸牌问题，作为一种经典的博奕类游戏，问题的具体描述如下：  
桌上有𝑀堆扑克牌，每堆牌的数量分别为$N_{i}(i=1,2,\dots,M)$。现有两个选手，分别记为先手和后手，轮流进行摸牌，每一次摸牌可以任意选择一堆并取走其中的任意张牌，规定每次至少取一张，多者不限；桌上的扑克牌全部取光，则游戏结束，那么最后一次摸牌的选手即为胜者。现在问题如下：先手如果想赢，第一步有几种选择?  
轮流摸牌问题可以采用博弈树解决。博弈树是一种特殊的树模型，它的每个结点表示游戏进行时的一种局面，用每条边表示这些局面之间合乎规则的演变或移动。博弈树通常比较庞大，通常需要对其进行化简才能高效地使用。  
图9-58 所示为初始的三堆扑克牌数量。第一堆和第二堆的扑克牌数量都为3 张，第三 堆扑克牌的数量为1 张，组成了初始状态(3，3，1)。  
![图9-57  大小排序决策树 ](images/f1b07d5e01fd3916fd51d458c21160476d888d5cdc01f2f4b52f54e88d66df57.jpg)  
![图9-58 三堆扑克牌  ](images/785c75f0b4653bbc64b450a41c28647f0642a850ef357c53771601a74297ee17.jpg)  
图9-58 所示的博弈树表示轮流摸扑克牌游戏在给定初始状态（3，3，1）扩展下的所 有对弈策略。用不同堆中扑克牌数组成的无序序列表示每个局面（堆的顺序无关紧要）。先手第一次可以从有3 张扑克牌的堆中摸1 张牌（剩下包含3 张、2 张、1 张扑克牌的3堆）；也可以从有3 张扑克牌的堆中取3 张（剩下包含3 张、1 张扑克牌的2 堆）；也可以从有1 张扑克牌的堆中取1 张（剩下包含3 张扑克牌的2 堆）。当扑克牌被最后一个选手取完了，下一个选手就无法再继续摸牌，这样的局面就是终局。轮流摸扑克牌游戏是非胜即负的游戏，规定用$F$ 标记表示先手获胜，用$L$ 标记表示后手获胜。  
![图9-59 轮流取扑克牌游戏的博弈树 ](images/3e2c6b2d2a79242f7f10f5a0e2d1714f56d6c5d793d99a4f5932038bcf4cd8fa.jpg)  
根据图9-59，我们可以发现，先手如果想必赢，第一步只有一种选择，即只能从有1 张扑克牌的堆中取1 张，而不能从其它堆中摸扑克牌。  
进一步对图9-59 进行分析，可知：  
1）状态（3，3，1）必胜点，那么先手取完棋子后，后手必落在必败点；  
2）若初始状态下，只有一堆扑克牌，先手必胜； 3）若有$𝑀$堆扑克牌，每堆只有一张扑克牌，$M$为奇数时，先手必胜；  
4）若有𝑀堆扑克牌，每堆只有$k$张扑克牌，$M$为奇数时，先手必胜；  
5）先手摸𝑘张扑克牌，轮到对手时，若对手取$𝑘$张，则先手也取$𝑘$张；若对手取$x<k$张，则先手也取另外一堆的$𝑥$张。因为剩下的是偶数堆，则先手也取$𝑘$张扑克牌，总能将剩下的堆变成若干个两两相等的堆。只要始终保持这种取法，先手总能取到最后的扑克牌。  
可以将上述局面推广至一般：若某个初始局面为先手必胜，那么每走一步都必须使后首落在必败点。因此对于每一个局面，要么为胜局面，要么为负局面。用非0 表示表示胜局面，0 表示负局面。对于某一个局面，若为非0 局面，它的任务就是要寻找某一种取法，使局面变为 0  局面。那么其对手无论怎么取，都会使局面又变为 0  局面。  
那么这种对弈有什么规律呢？  
如果一个局面为先手必胜，就称这为$N$局面；反之称之为$ P$局面。对于一个局面，令$S=$$P_{1}\oplus P_{2}\oplus\ldots\oplus P_{n}$。若$S=0$则为$ P$局面，否则就为$ N$局面（⊕为异或）。  
对于图9-4-5，我们将3 堆扑克牌数异或，即$3{\oplus}3{\oplus}1{=}011{\oplus}011{\oplus}001{=}1$，异或结果为非0，那么先手将赢得这局游戏。因此先手第一步需要从第三堆中摸一张扑克牌。  
下面我们考虑下4 堆扑克牌对弈策略。其中各堆的大小分别为4，5，9，15。用二进制表示各数分别为0100，0101，1001，1111。表4-1 为各堆数量对应的二进制数。  
将这四堆扑克牌数进行异或，得到0100⊕0101⊕1001⊕1111=0111。结果非0，那么先手会赢。因此先手可以从大小为4 的堆中取走1 张牌剩下3 张，后者从大小为5 的堆中取走 3  张牌剩下 2  张，再或者从大小为 15  的堆中取走 7  张牌剩下 8  张。  
轮流摸扑克牌游戏为典型的尼姆博弈问题。尼姆博弈的关键在于游戏开始时游戏处于何种状态（平衡或非平衡）和先手是否能够按照取子游戏的获胜策略来进行游戏。  
![表9-1  各堆数量对应的二进制数 ](images/621116a8789d5d8ecab422f6290df5764c10b51f7ad37caba7ad4b05a6de41e9.jpg)  
实际生活中还有许多有益的博弈，比如一字棋、国际象棋和方棋格等等。此外，这种博弈的方法已经应用到很多的计算机程序研究中。某些博弈程序都能做到与人类选手进行对决，比如国际象棋等，可以看到如何将树应用到博弈策略的研究中具有重要的现实意义.有关博弈策略的更多内容，读者可以查阅相关资料进一步学习，这里不再赘述。",轮流摸牌问题可以通过博弈树来解决
博弈树,表示,局面,,"生活中，下棋、打牌、竞技等一类竞争性的活动称为博弈。对垒的双方轮流采取行动，博弈的结果仅有三种：胜、败、平局。在对垒过程中，任何一方都了解当前的格局及过去的历史。任何一方在采取行动前都要根据当前的实际情况，进行得失分析，选取对自己有利而对对方最为不利的对策，不存在掷骰子之类的破运气因素，双方必须很明智的决定自己的行为。轮流摸牌问题，作为一种经典的博奕类游戏，问题的具体描述如下：  
桌上有𝑀堆扑克牌，每堆牌的数量分别为$N_{i}(i=1,2,\dots,M)$。现有两个选手，分别记为先手和后手，轮流进行摸牌，每一次摸牌可以任意选择一堆并取走其中的任意张牌，规定每次至少取一张，多者不限；桌上的扑克牌全部取光，则游戏结束，那么最后一次摸牌的选手即为胜者。现在问题如下：先手如果想赢，第一步有几种选择?  
轮流摸牌问题可以采用博弈树解决。博弈树是一种特殊的树模型，它的每个结点表示游戏进行时的一种局面，用每条边表示这些局面之间合乎规则的演变或移动。博弈树通常比较庞大，通常需要对其进行化简才能高效地使用。  
图9-58 所示为初始的三堆扑克牌数量。第一堆和第二堆的扑克牌数量都为3 张，第三 堆扑克牌的数量为1 张，组成了初始状态(3，3，1)。  
![图9-57  大小排序决策树 ](images/f1b07d5e01fd3916fd51d458c21160476d888d5cdc01f2f4b52f54e88d66df57.jpg)  
![图9-58 三堆扑克牌  ](images/785c75f0b4653bbc64b450a41c28647f0642a850ef357c53771601a74297ee17.jpg)  
图9-58 所示的博弈树表示轮流摸扑克牌游戏在给定初始状态（3，3，1）扩展下的所 有对弈策略。用不同堆中扑克牌数组成的无序序列表示每个局面（堆的顺序无关紧要）。先手第一次可以从有3 张扑克牌的堆中摸1 张牌（剩下包含3 张、2 张、1 张扑克牌的3堆）；也可以从有3 张扑克牌的堆中取3 张（剩下包含3 张、1 张扑克牌的2 堆）；也可以从有1 张扑克牌的堆中取1 张（剩下包含3 张扑克牌的2 堆）。当扑克牌被最后一个选手取完了，下一个选手就无法再继续摸牌，这样的局面就是终局。轮流摸扑克牌游戏是非胜即负的游戏，规定用$F$ 标记表示先手获胜，用$L$ 标记表示后手获胜。  
![图9-59 轮流取扑克牌游戏的博弈树 ](images/3e2c6b2d2a79242f7f10f5a0e2d1714f56d6c5d793d99a4f5932038bcf4cd8fa.jpg)  
根据图9-59，我们可以发现，先手如果想必赢，第一步只有一种选择，即只能从有1 张扑克牌的堆中取1 张，而不能从其它堆中摸扑克牌。  
进一步对图9-59 进行分析，可知：  
1）状态（3，3，1）必胜点，那么先手取完棋子后，后手必落在必败点；  
2）若初始状态下，只有一堆扑克牌，先手必胜； 3）若有$𝑀$堆扑克牌，每堆只有一张扑克牌，$M$为奇数时，先手必胜；  
4）若有𝑀堆扑克牌，每堆只有$k$张扑克牌，$M$为奇数时，先手必胜；  
5）先手摸𝑘张扑克牌，轮到对手时，若对手取$𝑘$张，则先手也取$𝑘$张；若对手取$x<k$张，则先手也取另外一堆的$𝑥$张。因为剩下的是偶数堆，则先手也取$𝑘$张扑克牌，总能将剩下的堆变成若干个两两相等的堆。只要始终保持这种取法，先手总能取到最后的扑克牌。  
可以将上述局面推广至一般：若某个初始局面为先手必胜，那么每走一步都必须使后首落在必败点。因此对于每一个局面，要么为胜局面，要么为负局面。用非0 表示表示胜局面，0 表示负局面。对于某一个局面，若为非0 局面，它的任务就是要寻找某一种取法，使局面变为 0  局面。那么其对手无论怎么取，都会使局面又变为 0  局面。  
那么这种对弈有什么规律呢？  
如果一个局面为先手必胜，就称这为$N$局面；反之称之为$ P$局面。对于一个局面，令$S=$$P_{1}\oplus P_{2}\oplus\ldots\oplus P_{n}$。若$S=0$则为$ P$局面，否则就为$ N$局面（⊕为异或）。  
对于图9-4-5，我们将3 堆扑克牌数异或，即$3{\oplus}3{\oplus}1{=}011{\oplus}011{\oplus}001{=}1$，异或结果为非0，那么先手将赢得这局游戏。因此先手第一步需要从第三堆中摸一张扑克牌。  
下面我们考虑下4 堆扑克牌对弈策略。其中各堆的大小分别为4，5，9，15。用二进制表示各数分别为0100，0101，1001，1111。表4-1 为各堆数量对应的二进制数。  
将这四堆扑克牌数进行异或，得到0100⊕0101⊕1001⊕1111=0111。结果非0，那么先手会赢。因此先手可以从大小为4 的堆中取走1 张牌剩下3 张，后者从大小为5 的堆中取走 3  张牌剩下 2  张，再或者从大小为 15  的堆中取走 7  张牌剩下 8  张。  
轮流摸扑克牌游戏为典型的尼姆博弈问题。尼姆博弈的关键在于游戏开始时游戏处于何种状态（平衡或非平衡）和先手是否能够按照取子游戏的获胜策略来进行游戏。  
![表9-1  各堆数量对应的二进制数 ](images/621116a8789d5d8ecab422f6290df5764c10b51f7ad37caba7ad4b05a6de41e9.jpg)  
实际生活中还有许多有益的博弈，比如一字棋、国际象棋和方棋格等等。此外，这种博弈的方法已经应用到很多的计算机程序研究中。某些博弈程序都能做到与人类选手进行对决，比如国际象棋等，可以看到如何将树应用到博弈策略的研究中具有重要的现实意义.有关博弈策略的更多内容，读者可以查阅相关资料进一步学习，这里不再赘述。",博弈树的每个节点表示游戏进行时的一种局面
轮流摸牌问题,属于,尼姆博弈,,"生活中，下棋、打牌、竞技等一类竞争性的活动称为博弈。对垒的双方轮流采取行动，博弈的结果仅有三种：胜、败、平局。在对垒过程中，任何一方都了解当前的格局及过去的历史。任何一方在采取行动前都要根据当前的实际情况，进行得失分析，选取对自己有利而对对方最为不利的对策，不存在掷骰子之类的破运气因素，双方必须很明智的决定自己的行为。轮流摸牌问题，作为一种经典的博奕类游戏，问题的具体描述如下：  
桌上有𝑀堆扑克牌，每堆牌的数量分别为$N_{i}(i=1,2,\dots,M)$。现有两个选手，分别记为先手和后手，轮流进行摸牌，每一次摸牌可以任意选择一堆并取走其中的任意张牌，规定每次至少取一张，多者不限；桌上的扑克牌全部取光，则游戏结束，那么最后一次摸牌的选手即为胜者。现在问题如下：先手如果想赢，第一步有几种选择?  
轮流摸牌问题可以采用博弈树解决。博弈树是一种特殊的树模型，它的每个结点表示游戏进行时的一种局面，用每条边表示这些局面之间合乎规则的演变或移动。博弈树通常比较庞大，通常需要对其进行化简才能高效地使用。  
图9-58 所示为初始的三堆扑克牌数量。第一堆和第二堆的扑克牌数量都为3 张，第三 堆扑克牌的数量为1 张，组成了初始状态(3，3，1)。  
![图9-57  大小排序决策树 ](images/f1b07d5e01fd3916fd51d458c21160476d888d5cdc01f2f4b52f54e88d66df57.jpg)  
![图9-58 三堆扑克牌  ](images/785c75f0b4653bbc64b450a41c28647f0642a850ef357c53771601a74297ee17.jpg)  
图9-58 所示的博弈树表示轮流摸扑克牌游戏在给定初始状态（3，3，1）扩展下的所 有对弈策略。用不同堆中扑克牌数组成的无序序列表示每个局面（堆的顺序无关紧要）。先手第一次可以从有3 张扑克牌的堆中摸1 张牌（剩下包含3 张、2 张、1 张扑克牌的3堆）；也可以从有3 张扑克牌的堆中取3 张（剩下包含3 张、1 张扑克牌的2 堆）；也可以从有1 张扑克牌的堆中取1 张（剩下包含3 张扑克牌的2 堆）。当扑克牌被最后一个选手取完了，下一个选手就无法再继续摸牌，这样的局面就是终局。轮流摸扑克牌游戏是非胜即负的游戏，规定用$F$ 标记表示先手获胜，用$L$ 标记表示后手获胜。  
![图9-59 轮流取扑克牌游戏的博弈树 ](images/3e2c6b2d2a79242f7f10f5a0e2d1714f56d6c5d793d99a4f5932038bcf4cd8fa.jpg)  
根据图9-59，我们可以发现，先手如果想必赢，第一步只有一种选择，即只能从有1 张扑克牌的堆中取1 张，而不能从其它堆中摸扑克牌。  
进一步对图9-59 进行分析，可知：  
1）状态（3，3，1）必胜点，那么先手取完棋子后，后手必落在必败点；  
2）若初始状态下，只有一堆扑克牌，先手必胜； 3）若有$𝑀$堆扑克牌，每堆只有一张扑克牌，$M$为奇数时，先手必胜；  
4）若有𝑀堆扑克牌，每堆只有$k$张扑克牌，$M$为奇数时，先手必胜；  
5）先手摸𝑘张扑克牌，轮到对手时，若对手取$𝑘$张，则先手也取$𝑘$张；若对手取$x<k$张，则先手也取另外一堆的$𝑥$张。因为剩下的是偶数堆，则先手也取$𝑘$张扑克牌，总能将剩下的堆变成若干个两两相等的堆。只要始终保持这种取法，先手总能取到最后的扑克牌。  
可以将上述局面推广至一般：若某个初始局面为先手必胜，那么每走一步都必须使后首落在必败点。因此对于每一个局面，要么为胜局面，要么为负局面。用非0 表示表示胜局面，0 表示负局面。对于某一个局面，若为非0 局面，它的任务就是要寻找某一种取法，使局面变为 0  局面。那么其对手无论怎么取，都会使局面又变为 0  局面。  
那么这种对弈有什么规律呢？  
如果一个局面为先手必胜，就称这为$N$局面；反之称之为$ P$局面。对于一个局面，令$S=$$P_{1}\oplus P_{2}\oplus\ldots\oplus P_{n}$。若$S=0$则为$ P$局面，否则就为$ N$局面（⊕为异或）。  
对于图9-4-5，我们将3 堆扑克牌数异或，即$3{\oplus}3{\oplus}1{=}011{\oplus}011{\oplus}001{=}1$，异或结果为非0，那么先手将赢得这局游戏。因此先手第一步需要从第三堆中摸一张扑克牌。  
下面我们考虑下4 堆扑克牌对弈策略。其中各堆的大小分别为4，5，9，15。用二进制表示各数分别为0100，0101，1001，1111。表4-1 为各堆数量对应的二进制数。  
将这四堆扑克牌数进行异或，得到0100⊕0101⊕1001⊕1111=0111。结果非0，那么先手会赢。因此先手可以从大小为4 的堆中取走1 张牌剩下3 张，后者从大小为5 的堆中取走 3  张牌剩下 2  张，再或者从大小为 15  的堆中取走 7  张牌剩下 8  张。  
轮流摸扑克牌游戏为典型的尼姆博弈问题。尼姆博弈的关键在于游戏开始时游戏处于何种状态（平衡或非平衡）和先手是否能够按照取子游戏的获胜策略来进行游戏。  
![表9-1  各堆数量对应的二进制数 ](images/621116a8789d5d8ecab422f6290df5764c10b51f7ad37caba7ad4b05a6de41e9.jpg)  
实际生活中还有许多有益的博弈，比如一字棋、国际象棋和方棋格等等。此外，这种博弈的方法已经应用到很多的计算机程序研究中。某些博弈程序都能做到与人类选手进行对决，比如国际象棋等，可以看到如何将树应用到博弈策略的研究中具有重要的现实意义.有关博弈策略的更多内容，读者可以查阅相关资料进一步学习，这里不再赘述。",轮流摸牌游戏是典型的尼姆博弈问题
尼姆博弈,关键,状态,,"生活中，下棋、打牌、竞技等一类竞争性的活动称为博弈。对垒的双方轮流采取行动，博弈的结果仅有三种：胜、败、平局。在对垒过程中，任何一方都了解当前的格局及过去的历史。任何一方在采取行动前都要根据当前的实际情况，进行得失分析，选取对自己有利而对对方最为不利的对策，不存在掷骰子之类的破运气因素，双方必须很明智的决定自己的行为。轮流摸牌问题，作为一种经典的博奕类游戏，问题的具体描述如下：  
桌上有𝑀堆扑克牌，每堆牌的数量分别为$N_{i}(i=1,2,\dots,M)$。现有两个选手，分别记为先手和后手，轮流进行摸牌，每一次摸牌可以任意选择一堆并取走其中的任意张牌，规定每次至少取一张，多者不限；桌上的扑克牌全部取光，则游戏结束，那么最后一次摸牌的选手即为胜者。现在问题如下：先手如果想赢，第一步有几种选择?  
轮流摸牌问题可以采用博弈树解决。博弈树是一种特殊的树模型，它的每个结点表示游戏进行时的一种局面，用每条边表示这些局面之间合乎规则的演变或移动。博弈树通常比较庞大，通常需要对其进行化简才能高效地使用。  
图9-58 所示为初始的三堆扑克牌数量。第一堆和第二堆的扑克牌数量都为3 张，第三 堆扑克牌的数量为1 张，组成了初始状态(3，3，1)。  
![图9-57  大小排序决策树 ](images/f1b07d5e01fd3916fd51d458c21160476d888d5cdc01f2f4b52f54e88d66df57.jpg)  
![图9-58 三堆扑克牌  ](images/785c75f0b4653bbc64b450a41c28647f0642a850ef357c53771601a74297ee17.jpg)  
图9-58 所示的博弈树表示轮流摸扑克牌游戏在给定初始状态（3，3，1）扩展下的所 有对弈策略。用不同堆中扑克牌数组成的无序序列表示每个局面（堆的顺序无关紧要）。先手第一次可以从有3 张扑克牌的堆中摸1 张牌（剩下包含3 张、2 张、1 张扑克牌的3堆）；也可以从有3 张扑克牌的堆中取3 张（剩下包含3 张、1 张扑克牌的2 堆）；也可以从有1 张扑克牌的堆中取1 张（剩下包含3 张扑克牌的2 堆）。当扑克牌被最后一个选手取完了，下一个选手就无法再继续摸牌，这样的局面就是终局。轮流摸扑克牌游戏是非胜即负的游戏，规定用$F$ 标记表示先手获胜，用$L$ 标记表示后手获胜。  
![图9-59 轮流取扑克牌游戏的博弈树 ](images/3e2c6b2d2a79242f7f10f5a0e2d1714f56d6c5d793d99a4f5932038bcf4cd8fa.jpg)  
根据图9-59，我们可以发现，先手如果想必赢，第一步只有一种选择，即只能从有1 张扑克牌的堆中取1 张，而不能从其它堆中摸扑克牌。  
进一步对图9-59 进行分析，可知：  
1）状态（3，3，1）必胜点，那么先手取完棋子后，后手必落在必败点；  
2）若初始状态下，只有一堆扑克牌，先手必胜； 3）若有$𝑀$堆扑克牌，每堆只有一张扑克牌，$M$为奇数时，先手必胜；  
4）若有𝑀堆扑克牌，每堆只有$k$张扑克牌，$M$为奇数时，先手必胜；  
5）先手摸𝑘张扑克牌，轮到对手时，若对手取$𝑘$张，则先手也取$𝑘$张；若对手取$x<k$张，则先手也取另外一堆的$𝑥$张。因为剩下的是偶数堆，则先手也取$𝑘$张扑克牌，总能将剩下的堆变成若干个两两相等的堆。只要始终保持这种取法，先手总能取到最后的扑克牌。  
可以将上述局面推广至一般：若某个初始局面为先手必胜，那么每走一步都必须使后首落在必败点。因此对于每一个局面，要么为胜局面，要么为负局面。用非0 表示表示胜局面，0 表示负局面。对于某一个局面，若为非0 局面，它的任务就是要寻找某一种取法，使局面变为 0  局面。那么其对手无论怎么取，都会使局面又变为 0  局面。  
那么这种对弈有什么规律呢？  
如果一个局面为先手必胜，就称这为$N$局面；反之称之为$ P$局面。对于一个局面，令$S=$$P_{1}\oplus P_{2}\oplus\ldots\oplus P_{n}$。若$S=0$则为$ P$局面，否则就为$ N$局面（⊕为异或）。  
对于图9-4-5，我们将3 堆扑克牌数异或，即$3{\oplus}3{\oplus}1{=}011{\oplus}011{\oplus}001{=}1$，异或结果为非0，那么先手将赢得这局游戏。因此先手第一步需要从第三堆中摸一张扑克牌。  
下面我们考虑下4 堆扑克牌对弈策略。其中各堆的大小分别为4，5，9，15。用二进制表示各数分别为0100，0101，1001，1111。表4-1 为各堆数量对应的二进制数。  
将这四堆扑克牌数进行异或，得到0100⊕0101⊕1001⊕1111=0111。结果非0，那么先手会赢。因此先手可以从大小为4 的堆中取走1 张牌剩下3 张，后者从大小为5 的堆中取走 3  张牌剩下 2  张，再或者从大小为 15  的堆中取走 7  张牌剩下 8  张。  
轮流摸扑克牌游戏为典型的尼姆博弈问题。尼姆博弈的关键在于游戏开始时游戏处于何种状态（平衡或非平衡）和先手是否能够按照取子游戏的获胜策略来进行游戏。  
![表9-1  各堆数量对应的二进制数 ](images/621116a8789d5d8ecab422f6290df5764c10b51f7ad37caba7ad4b05a6de41e9.jpg)  
实际生活中还有许多有益的博弈，比如一字棋、国际象棋和方棋格等等。此外，这种博弈的方法已经应用到很多的计算机程序研究中。某些博弈程序都能做到与人类选手进行对决，比如国际象棋等，可以看到如何将树应用到博弈策略的研究中具有重要的现实意义.有关博弈策略的更多内容，读者可以查阅相关资料进一步学习，这里不再赘述。",尼姆博弈的关键在于游戏开始时的状态（平衡或非平衡）
关键道路问题,解决,PERT图模型,,"一项工程往往由许多作业构成，其中某些作业可以同时进行，而某些作业却必须按照一定先后顺序执行。例如，在建筑工程中，一般涉及到采购材料、平整地基、预制构件、埋设管道、砌墙立屋、室内装修等多个作业。其中平整地基和预制构件可以同时进行，而室内装修却必须在砌墙立屋之后才能动工等。这样就存在问题：为了使使得工期最短、成本最低，我们应该采取什么方法安排各个作业实施？  
我们知道，PERT 图模型可以很好地解决这类问题。图9-60 是一个PERT 图，图中不含有向回路。在作业网络中每条有向边表示一个作业，边上的权表示完成该项作业所需要的时间（或者费用）。源点（简称源）$𝑠$表示工程的开始，汇点（简称汇）$𝑡$表示工程的结束，其余结点$V_i$表示以该结点为终点的有向边代表的作业的结束和以该结点为始点的有向边代表的作业的开始。  
![](images/8a39c66fbf3ebe2db46646bd71380173dfca51b0b0532f41788a6ce4873cbcb6.jpg)  
第 8 章采用直接计算各个作业最早完成时间和最晚完成时间的方法计算关键路径，现在采用生成树方法计算源到其它结点的最长道路即关键道路，计算思路如下：  
（1）构造一棵以源 𝑠 为根的生成根树 $T$，且求出$s$到根树的各个结点 $v$ 的距离$L\left(\nu\right)$ 。  
（2）对任何一条权为$𝑊$$(u,v)$的弦$\langle u,v\rangle$，若$L(v)<\ L(u)+\ W(u,v)$，则从$T$中去掉以$v$为终点的有向边，而以有向边$\langle u,v\rangle$代之，同时使以$v$为根的子树中的各结点距离都增加$W(u,v)$，如此反复进行，直到考察完所有的弦。  
【例题9.21】求如图9-60 所示的作业网络的关键路径。  
【解】先构造由源𝑠到各个结点的最长道路的生成根树，即优化生成树，如图9-61 (a)- (d) 所示。再构造各个结点到汇 𝑡 的生成树，如图 $9–61\ (\mathsf{e})\tilde{\mathbf{\tau}}(\mathsf{g})$ 所示，然后在原图各个结点 $v$ 处 标以一个有序对$(a,b)$，其中$a$是图9-61 (d)中各$\mathbf{\nabla}^{\mathcal{V}}$的值，$b$是最长道路的权减去图9-61 (g)中各𝑣的值后的结果，如表9-2 所示。其中$a$与𝑏相等的结点所对应作业即为关键作业，由此可以得到如图9-61 (h)所示的关键路径。  
![](images/afad317ae3fcf5f241994658e1d9b51d47e2a890fb3c403b89c9e67033bfa386.jpg)  
![表 9-2  各个结点对应的有序对 ](images/2a1c04e98ea2f09c56274c954a2e76e48122dca03ff9c00a36aff31b122580fe.jpg)  
从图9-61 可知，$P=s V_{3}V_{1}V_{2}V_{4}t$是关键道路，$P$上的作业是关键作业。不在$P$上的作业都有缓冲期，例如$\langle s,V_{1}\rangle$只需3 个单位时间，在整个工程中它的动工时间为0，最晚完成时间为8，有5 个单位的多余机动时间。又比如作业$\langle V_{5},V_{6}\rangle$其最早动工时间为7，最晚完成时间为17，作业所需的时间为4，因此右6 个单位的机动时间，即使从时间13 开始也能按期完成。通过关键道路算法，重视关键作业的完成并合理利用非关键作业的缓冲期，就能做到整个项目的全盘把握，合理分配使用人力物力资源。",PERT图模型可以很好地解决关键道路问题
关键道路问题,计算,生成树方法,,"一项工程往往由许多作业构成，其中某些作业可以同时进行，而某些作业却必须按照一定先后顺序执行。例如，在建筑工程中，一般涉及到采购材料、平整地基、预制构件、埋设管道、砌墙立屋、室内装修等多个作业。其中平整地基和预制构件可以同时进行，而室内装修却必须在砌墙立屋之后才能动工等。这样就存在问题：为了使使得工期最短、成本最低，我们应该采取什么方法安排各个作业实施？  
我们知道，PERT 图模型可以很好地解决这类问题。图9-60 是一个PERT 图，图中不含有向回路。在作业网络中每条有向边表示一个作业，边上的权表示完成该项作业所需要的时间（或者费用）。源点（简称源）$𝑠$表示工程的开始，汇点（简称汇）$𝑡$表示工程的结束，其余结点$V_i$表示以该结点为终点的有向边代表的作业的结束和以该结点为始点的有向边代表的作业的开始。  
![](images/8a39c66fbf3ebe2db46646bd71380173dfca51b0b0532f41788a6ce4873cbcb6.jpg)  
第 8 章采用直接计算各个作业最早完成时间和最晚完成时间的方法计算关键路径，现在采用生成树方法计算源到其它结点的最长道路即关键道路，计算思路如下：  
（1）构造一棵以源 𝑠 为根的生成根树 $T$，且求出$s$到根树的各个结点 $v$ 的距离$L\left(\nu\right)$ 。  
（2）对任何一条权为$𝑊$$(u,v)$的弦$\langle u,v\rangle$，若$L(v)<\ L(u)+\ W(u,v)$，则从$T$中去掉以$v$为终点的有向边，而以有向边$\langle u,v\rangle$代之，同时使以$v$为根的子树中的各结点距离都增加$W(u,v)$，如此反复进行，直到考察完所有的弦。  
【例题9.21】求如图9-60 所示的作业网络的关键路径。  
【解】先构造由源𝑠到各个结点的最长道路的生成根树，即优化生成树，如图9-61 (a)- (d) 所示。再构造各个结点到汇 𝑡 的生成树，如图 $9–61\ (\mathsf{e})\tilde{\mathbf{\tau}}(\mathsf{g})$ 所示，然后在原图各个结点 $v$ 处 标以一个有序对$(a,b)$，其中$a$是图9-61 (d)中各$\mathbf{\nabla}^{\mathcal{V}}$的值，$b$是最长道路的权减去图9-61 (g)中各𝑣的值后的结果，如表9-2 所示。其中$a$与𝑏相等的结点所对应作业即为关键作业，由此可以得到如图9-61 (h)所示的关键路径。  
![](images/afad317ae3fcf5f241994658e1d9b51d47e2a890fb3c403b89c9e67033bfa386.jpg)  
![表 9-2  各个结点对应的有序对 ](images/2a1c04e98ea2f09c56274c954a2e76e48122dca03ff9c00a36aff31b122580fe.jpg)  
从图9-61 可知，$P=s V_{3}V_{1}V_{2}V_{4}t$是关键道路，$P$上的作业是关键作业。不在$P$上的作业都有缓冲期，例如$\langle s,V_{1}\rangle$只需3 个单位时间，在整个工程中它的动工时间为0，最晚完成时间为8，有5 个单位的多余机动时间。又比如作业$\langle V_{5},V_{6}\rangle$其最早动工时间为7，最晚完成时间为17，作业所需的时间为4，因此右6 个单位的机动时间，即使从时间13 开始也能按期完成。通过关键道路算法，重视关键作业的完成并合理利用非关键作业的缓冲期，就能做到整个项目的全盘把握，合理分配使用人力物力资源。",生成树方法用于计算关键道路问题中的关键路径
