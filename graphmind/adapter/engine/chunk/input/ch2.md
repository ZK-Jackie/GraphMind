# 第二章  整数与算法设计基础

整数作为一种最基本的离散量和离散结构不仅是离散数学的研究对象，而且其自身也是研究其它离散结构的一项基本工具，在离散量的度量、计数和算法设计等方面发挥重要的基础性作用。整数是人类最早认识和使用的数，专门研究整数及其性质的整数理论是一个具有几千年历史的非常古老的数学分支。在很长一段时期内，整数理论被认为仅仅是思想的体操、数学思维能力的训练工具，其实用性并没有得到充分重视。著名数学家数学王子高斯就曾给出这样的评价：如果说数学是科学的皇后，那么整数理论则是皇后头上美丽的皇冠。意指其仅仅是漂亮而不够实用。直到20 世纪70 年代基于整数模余运算理论的非对称加密算法被设计出来并取得成功应用，整数理论的实用性才得到广泛重视。事实上，算法概念正是诞生于整数的算术运算，这使得整数理论与计算机算法有着一种天然的紧密联系。计算机学科的诞生与兴起让整数理论这门古老的学科重新焕发出新的生命并得到蓬勃发展。目前，整数理论已经成为算法设计与算法度量的一项基本工具，在散列函数构造、伪随机数生成、信息编码与加密等多个领域得到广泛应用。其实除整数之外，离散数学中很多其它离散结构模型，例如图模型、关系模型、群代数结构模型等，也都是通过相关算法在计算机领域发挥重要作用。因此，算法设计技术是学习与应用离散数学所必备的基本知识。  

综上所述，作为学习离散数学的另一入门基础，本章比较系统地介绍整数理论与算法设计的基本知识，具体包括整除的基本概念与运算性质、模余运算的基础知识、同余方程及其解法、非对称加密算法、算法设计的基本知识、算法设计的基本策略与应用等。  

## § 2.1 整数的基本知识

本节主要介绍整数理论中若干最基本的知识。我们知道，整数相加、相减、相乘的结果都是整数，而除法结果却不一定是整数。因此，整数理论研究的重点自然是运算结果相对比较复杂的除法。通过整数的除法运算可以得到整数的素因数分解，由此我们便可以素数为基本构件来考察或窥探整数的离散结构特征与变化规律。在这个过程中，素数作为构造整数的基本构件，其性质与分布规律自然是整数理论的重要内容。因此，本节内容主要包括整数与整数除法的概念、公因数与公倍数、整数的素因数分解、素数的性质及相关算法等。  

### 2.1.1 整数与整数除法

在第一章，我们得到自然数和自然数集的定义。在自然数集中加入每个非零元素的相反数就得到整数集合，整数集中每个元素称为整数。也就是说，对于整数集合$z$，有：  

$$
Z\!=\!\{\cdots\!,\,\!-4,\,\!-3,\,\!-2,\,\!-1,\,0,\,1,\,2,\,3,\,4,\,\cdots\}
$$

对于整数，我们主要考察其除法运算，包括整除和带余除法，由此可以得到倍数与因子、素数与合数、商与余数的相关概念和性质。  

首先在整数及其乘法运算基础上，考察整除的概念与性质。  

【定义2.1】假设$a$ 和$b$ 是任意给定的两个整数且$a\neq0$，若存在整数$q$，满足$b=a\cdot q($其中“∙”表示普通数乘运算，通常将其省略)，则称$\pmb{a}$ 能整除$\pmb{b}$，或$\pmb{b}$ 能被$\pmb{a}$ 整除，记为a|b。此时，又称$a$ 是$b$ 的因子或$b$ 是$a$ 的倍数。若不存在任何整数$q$，满足$b=a q$，则称$\pmb{a}$ 不能整除$\pmb{b}$，或$\pmb{b}$ 不能被$\pmb{a}$ 整除，记为$a\nmid b$。  

例如：5|25，13 ∤120，7|49，13|0，$^{-3}\vert$-12，9 ∤−56；8 的因子有$\pm1$，$\pm2$，$\pm4$和$\pm8$，7的因子有$\pm1$和$\pm7$。显然，对于任意一个给定的整数$a$，它至少能够被$\pm1$或$\pm n$整除。因此，这四个是$a$ 的因子，称其为$a$ 的平凡因子。$a$ 的其它因子称为非平凡因子。  

【定义2.2】对于任意一个给定的非零整数$a$，若$a\ne\pm1$且没有非平凡因子，则称$a$ 为素数或质数；否则称$a$ 为合数。  

从一定意义上讲，素数是构成整数的基本要素，在整数理论中具有极其重要的地位。若非特别说明，我们所说的素数都是指正素数。2 是第一个正素数，其后还有3, 5, 7, 11,…, 等等。我们还会后续相关内容中详细讨论素数的性质与应用。  

例如，整数2, 3, 5, 7, 11, 13 都是素数，而4, 10, 16, 21 都不是素数。  

对于一个不是很大的整数，显然可用一个比较简单的方法来判定一个大于2 的正整数$b$是否为素数：用从2 到$b-1$的每一个整数去除$b$，如果这些整数都不是$b$ 的因子，那么$b$是素数。注意到：若$a k=b$，则$a$ 或$k$ 小于或等于$\sqrt{b}$。由此可知，如果$b$ 不是素数，那么它必有一个因子$k$ 满足不等式$1<k\leq{\sqrt{b}}$ 。因此，为得到更高的效率，只需在这个范围里检验因子。同样，如果$b$ 有一偶数因子，那么2 一定是该因子的一个因子。因此，在通过2 的整除性检验后，可以跳过所有偶数。要判断一个很大的整数是否为素数则不是一件容易的事情，我们将在本章后续的相关部分具体介绍整数集合中大素数的分布和查找知识。  

整数的整除运算具有如下基本性质：  

【定理2.1】假设$a,b,c$ 是3 个任意给定的整数，则有：  

（1）$a|b$ 当且仅当$\pm a|\pm b$； 

（2）若$a|b,\ b|c$，则 $a|c$； 

（3）若$;b|a_{i},\;\;i=1,\;\;2,\;\;\cdots,\;\;k$，则 $b|a_{1}x_{1}+a_{2}x_{2}+\cdots+a_{k}x_{k}$，此处 $x_{i}(i=1,\ \ 2$，$\cdots,\;\;k)$也是任意的整数； 

（4）若$b|a$，则 $b p|a p$，此处$p$ 是任意非零整数； 

（5）若$b|a$，$a\neq0$，则 $|b|\leq|a|$； 下面仅证明（3）和（5），其余性质的证明与此类似，读者可自行给出。 





根据整除的定义，我们知道任意两个整数之间并不一定满足整除关系。为使整数能够正常进行除法运算，必须对整除概念进行推广。事实上，对于任意两个整数，虽然它们之间不一定具有整除关系，但总存在如下关系：  

【定理2.2】假设$a$ 和$b$ 是任意给定的两个整数且$a\neq0$，则必然存在唯一确定的一对整数$q$ 和$r$，满足下列等式：  

$$
b=a q+r,\;\;0\leq r<|a|	\tag{2-1}
$$

此时称整数$a$ 为除数、$b$ 为被除数、$q$为$b$ 除以$a$的商、$r$为$b$ 除以$a$ 的余数。



### 2.1.2 整数的因数分解

对于任意两个整数，它们之间可以进行加法运算、减法运算和乘法运算，却不一定能够进行整除运算。因此，我们可以将整除运算作为一个基本工具来考察单个整数的离散结构特征以及整数与整数之间的各种联系。本节首先介绍公因数和公倍数的相关概念与性质，然后给出最大公因数的经典构造算法，最后讨论整数基于整除性质的分解。由于非零整数的正负号不影响其整除性质，因此，不失一般性，以下关于整数的讨论，在默认状态下是针对非负整数范围，所得结论可直接推广到所有整数的范围。  

#### 一、公因数与公倍数

假设$a$ 和$b$ 是任意给定的两个整数，如果$b$ 能够整除$a$，那么$b$ 就是$a$的一个因数、$a$就是$b$ 的一个倍数，此时可分别从因数和倍数这两个角度对整数进行考察。  

具体地说，如果$b$ 也是另外一个整数$c$ 的因数，则$b$ 就反映出$a$ 和$c$ 的某种共同特征，或者说整数$a$ 和$c$ 具有一个相同的构件$b$，通常将其称为$a$ 与$c$的公因数。同样，如果整数$a$ 也是另外一个整数$s$ 的倍数，则$b$ 和$s$ 就有一个共同的倍数$a$，通常称之为公倍数。公因数和公倍数分别从两个不同角度考察任意两个整数之间的联系，具体定义如下：  

【定义2.3】假设$i$ 和$j$是任意两个整数，如果整数$b$ 能够同时整除$i$和$j$，则称$b$ 是$i$和$j$ 的一个公因数，如果$i$ 和$j$都能够整除整数$a$，则称$a$ 是$i$ 和$j$的一个公倍数。  

自然数1 可以整除任意整数，因此对于任意两个整数，它们的公因数总是存在的。公因数表达的是两个整数的共同部分，通常需要考察两个整数之间的共同部分最大值能达到多少，故有所谓最大公因数的概念。同样，对于任意两个整数，这两个整数的乘积就是它们的公倍数，因此，公倍数总是存在的，需要着重考察的通常式公倍数的最小值，因而有最小公倍数的概念。最大公因数和最小公倍数的具体定义如下：  

【定义2.4】假设$a$ 和$b$ 是任意给定的两个整数，$a$ 和$b$ 的所有公因数中最大的那个整数称为$a$ 和$b$ 的最大公因数，记为$\operatorname*{gcd}(a,b)$或$(a,b)$，$a$ 和$b$ 的所有公倍数中最小的那个整数称为$a$ 和$b$ 的最小公倍数，记为$\operatorname{lcm}(a,b)$或$[a,b]$。  

例如： $\operatorname*{gcd}(5,7)=1$$\operatorname*{gcd}(15,21)=3;\;\;\operatorname*{gcd}(132,240)=12;$； $\operatorname{lcm}(5,7)=35;\ \operatorname{lcm}(15,21)=105;\ \operatorname{lcm}(132,240)=2640$ 

规定g$\mathtt{c d}(0,0)=0$。易知若$a$，$b$不全为零，则$\operatorname*{gcd}(a,\ b)>0$。  

【定理2.3】假设$a$ 和$b$ 是任意给定的两个整数，则有：  

$$
a\cdot b=\left(a,b\right)\cdot\ \left[a,b\right]\tag{2-2}
$$

【定理2.4】假设$a$ 和$b$ 是任意给定的两个整数，如果$a$ 和$b$ 都能整除整数$k$，则其最小公倍数$[a,b]$也能整除$k$。  



显然，可以将公因数和公倍数的相关直接概念推广到如下多个整数的情形：  

【定义2.5】假设$a_{1},a_{2},\cdots,a_{k}$是$k$ 个不全为零的整数，如果$s$ 是其中每个整数的因数，则称$t$是$a_{1},a_{2},\cdots,a_{k}$的一个公因数。对于给定的整数$a_{1},a_{2},\cdots,a_{k}$，它们的公因数只有有限多个，其中最大的那个公因数称为$a_{1},a_{2},\cdots,a_{k}$的最大公因数，记为gc$\mathfrak{d}(a_{1},a_{2},\cdots,a_{k}).$。  

【定义2.6】假设$a_{1},a_{2},\cdots,a_{k}$是$k$ 个不全为零的整数，如果$t$是其中每个整数的倍数，则称$t$ 是$a_{1},a_{2},\cdots,a_{k}$的一个公倍数。$a_{1},a_{2},\cdots,a_{k}$的所有公倍数中数值最小的那个公倍数，称为$a_{1},a_{2},\cdots,a_{k}$的最小公倍数，记为$\operatorname{lcm}(a_{1},a_{2},\cdots,a_{k})$。  



下面定理是最大公因数的一个重要定理，它刻画了最大公因数在带余除法中的不变性质，为最大公因数的构造算法——辗转相除法提供了坚实的理论基础。  

【定理2.5】假设$a$ 和$b$ 是任意给定的两个整数，若有$b=a q+r$，$0\leq|r|<a$，则必有：$\operatorname*{gcd}(b,a)=\operatorname*{gcd}(a,r).$。  



【定理2.6】假设$a$ 和$b$ 是任意两个整数，则必然存在两个整数$\cdot k_{1}$和$k_{2}$，满足：  
$$
\operatorname*{gcd}(b,a)=k_{1}\cdot b+k_{2}\cdot a\tag{2-3}
$$



上述定理表明，整数$a$ 和$b$ 的最大公因数可以表示为它们的一个线性组合。这就给出了最大公因式一种具体表达形式，这种表达形式对于考察最大公因数的性质具有非常重要的作用。例如，使用上述线性组合表达式，可得到最大公因数下述性质：  

【定理2.7】假设$a$ 和$b$ 是任意给定的两个整数，如果$d$ 是$a$ 和$b$ 的任意一个公因数，则$d$一定能整除$\operatorname*{gcd}(a,b)$。  



####  二、互素的概念与性质

从整除的角度看，两个整数的公因数表达的是这两个整数共性成分。如果两个整数的最大公因数为1，则表明这两个整数除1 之外没有任何额外的共性成分。因此，从结构上看，这两个整数之间具有很强的独立性。这种很强的独立性我们称之为互素。互素是整数理论中一个非常重要的基本概念，整数的很多性质都与互素的概念有关，其具体定义如下：  

【定义2.7】假设$a_{1},a_{2},\cdots,a_{k}$是$k$个不全为零的整数，如果有$\operatorname*{gcd}(a_{1},a_{2},\cdots,a_{k})=1$，则称这$k$ 个整数$a_{1},a_{2},\cdots,a_{k}$为互素；如果$a_{1},a_{2},\cdots,a_{k}$中任意两个整数的最大公因数均为1，则称这$k$ 个整数$a_{1},a_{2},\cdots,a_{k}$为两两互素。  

$a_{1},a_{2},\cdots,a_{k}$互素与$a_{1},a_{2},\cdots,a_{k}$两两互素是两个不同的概念，在实际使用过程中应注意加以区分，避免混淆。显然，由$a_{1},a_{2},\cdots,a_{k}$两两互素可以推出$a_{1},a_{2},\cdots,a_{k}$互素，反之不然。例如，$\operatorname*{gcd}(3,6,9,10)=1$，此时这4 个整数仅仅为互素的关系，因为其中的3, 6, 9的最大公因数并不为1，所以不符合两两互素。  



【定理2.8】设$a$，$b$ 是任意两个整数，若$\operatorname*{gcd}(a,b)=a s+b t$，则$s$ 与$t$是互素的。  



【定理2.9】如果整数$a$ 与整数$b_{1},b_{2},\cdots,b_{n}$中的每一个都互质，那么$a$ 与乘积$b_{1}b_{2}\cdots b_{n}$也互质。  



【定理2.10】对于任意的整数$a$，$b$，$c$，下面结论成立： 

（1）若$b|a c$且$\operatorname*{gcd}(a,b)=1$，则有$b|c$； 

（2）若$b|c$且$a|c$，则有$a b|c$。  



【定理 2.11 】若 $\operatorname*{gcd}(a,b)=1$ ，则 $\operatorname*{gcd}(a,b k)=\operatorname*{gcd}(a,k)\,.$  



#### 三、算术基本定理

对于是任意给定的两个整数$a$ 和$b$，如果$a$ 能够整除$b$，则通过整数$a$ 实现了对整数$b$的一个分解，即将$b$ 分解成$a$ 和另外一个整数的乘积。现在我们从整除的角度讨论整数的分解问题，亦即整数的因数分解问题。  

我们知道，素数是整个整数中不能够再分解的数，因为素数除了±1和其自身之外，没有其它的非平凡因子。因此，在对整数进行因数分解的过程中可以将素数看出是构成整数的最基本的要素或构件。通过对整数进行到素数层次的因数分解，就可以从整除的角度比较完整地考察整数的基本结构，并由此探究整数的基本性质和基本规律。  

【定理2.12】任何大于1 的正整数$a$，或为一素数，或可以写成若干素数的积，即$a=$$p_{1}p_{2}\cdots p_{b}$，其中$p_{i}(1\leq i\leq b)$是素数。  



[定理2.13] (算术基本定理) 任何大于1 的整数$a$可以唯一表示成  
$$
a=p_{1}^{a_{1}}p_{2}^{a_{2}}\cdots p_{k}^{a_{k}}\tag{2-4}
$$

其中$p_{1},p_{2},\cdots,p_{k}$是素数，$p_{1}<p_{2}<\dots<p_{k}$，$a_{1},a_{2},\cdots,a_{k}$是正整数。



上述定理给出了整数素数分解的存在性与唯一性，称之为算术基本定理。由此可以看出，整数的素数分解在整数理论以及在整数初等数学中的重要性。  

【定义2.8】若$p_{1},p_{2},\cdots,p_{k}$是素数，$p_{1}<p_{2}<\cdots<p_{k},$，$a_{1},a_{2},\cdots,a_{k}$是正整数，那么称  

$$
a=p_{1}^{a_{1}}p_{2}^{a_{2}}\cdots p_{k}^{a_{k}}\tag{2-6}
$$

是整数$a$ 的素幂分解式，其中$p_{i}$是素数，$p_{1}<p_{2}<\dots<p_{k}$，$a_{i}$是正整数。【例题2.12】写出51480 的素幂分解式。  



整数的素幂分解式给出了整数一种基于素数的结构表达，在数论研究中具有非常重要的作用。例如，下面两个定理表明，可以使用其素幂分解式计算两个整数的最大公约数和最小公倍数，还可以证明最大公约数和最小公倍数之间的关系。  

【定理2.14】设整数$a,~b$ 的素因子分解式分别为：  

$$
a=p_{1}^{a_{1}}\cdots p_{k}^{a_{k}};\,\,\,b=p_{1}^{b_{1}}\cdots p_{k}^{b_{k}}
$$

其中$p_{1},\cdots,p_{k}$是互不相同的素数，$a_{1},\cdots,a_{k},\;\;b_{1},\cdots,b_{k}$是非负整数。则有：  

$$
{\operatorname*{gcd}(a,b)=p_{1}^{m i n(a_{1},b_{1})}\cdots p_{k}^{m i n(a_{k},b_{k})\tag{2-7}}}
$$

$$
 {\operatorname{lcm}(a,b)=p_{1}^{m a x(a_{1},b_{1})}\cdots p_{k}^{m a x(a_{k},b_{k})}}\tag{2-8}
$$



### 2.1.3 素数的性质与查找  

通过算术基本定理可以看出，素数是构成所有整数的基本要素，在整个整数理论中占据非常重要的基础性地位。现在我们就来学习有关素数的基本知识，讨论素数的若干基本性质、素数的分布以及相关的查找方法。  

素数的一个非常独特性质是它与其它整数之间具有如下非常简单而直接的关系，这种简单直接的关系是使用素数考察整数性质的基础。  

【定理2.15】假设$p$ 是任意一个给定的素数，则它与其它任意整数$a$ 之间的关系是：要么$p$ 与$a$ 互素，要么$p$ 能够整除$a$。  



可以通过上述定理证明下面结论：  

【定理2.16】假设$p$ 是任意一个给定的素数，$a$ 和$b$ 是任意两个整数，如果$p$ 能整除$a$与$b$ 的乘积，则$p$ 至少能整除$a$ 与$b$ 中的一个。更一般地，假设$a_{1},a_{2},\cdots,a_{k}$是任意给出的$k$个整数，如果素数$p$ 能够整除$a_{1},a_{2},\cdots,a_{k}$，则$p$ 至少能够整除$a_{1},a_{2},\cdots,a_{k}$中的一个。  



下面讨论素数的计数问题。首先考虑在整个正整数集合中，到底有多少个素数？下面的定理给出了答案：  

【定理2.17】正整数集合中的素数有无穷多个。



下面进一步讨论有限正整数集合中素数的计数与分布情况：  

【定理2.18】设$a$是任意大于1 的整数，则$a$除1 外的最小正因数$q$一定是素数，并且，当$a$是合数时，$q\leq{\sqrt{a}}$，亦即：若$a$ 是合数，则$a$ 必有一个小于等于$\sqrt{a}$的素因子。  





使用上述定理，可以获得一种名为爱氏筛法的素数查找方法。对于任意给定的一个正整数$N$，可以使用该方法找到所有不超过$N$的素数，具体做法如下：  

首先把所有不超过$N$的正整数按从小到大的次序排成一个队列，然后在队列中划去1以及划去一切不超过$\sqrt{N}$的素数的所有倍数，剩下的数即为所求的素数。  



由于有无穷多个素数，因此人们总是希望能够找到尽可能大的素数。300 年来人们找到的最大素数都是$2^{p}-1$这种形式的整数，其中$p$ 也是素数。我们将具有这种形式的素数称为梅森素数，目前有一个名为互联网梅森素数大搜索组织专门搜索大素数，有兴趣的读者可以查阅有关资料了解大素数查找的进展情况。  

## § 2.2 同余算术及其应用

前面关于整数理论的讨论主要基于整数整除的概念与性质。由于整除是一个是整数之间一个比较强的约束关系，很多整数都不能满足，因此引入一种具有普适性的带余除法概念，将整数的整除归结为一种余数为0 的特殊带余除法。德国数学家高斯则是从带余除法的角度对整除的概念进行推广，引入同余的概念及相关算术。从带余除法的角度看，同余并非像整除那样要求余数一定为0，而只要求两个整数被某个除数做带余除法后得到的余数相等，这个约束显然比整除的约束宽松很多。同余算术是整理理论一个重要发展并构成初等数论的理论核心，它从在一种比整除约束更为宽松的条件下考察整数的运算及性质并得到很多非常精彩的数论成果，这些成果在整数加密算法设计等多个领域得到广泛应用。本节主要介绍同余算术的概念、性质与应用，具体包括同余关系及其运算、剩余系的概念与性质、同余方程与方程组的求解、若干经典的整数加密算法。  

### 2.2.1 同余关系及其运算

在很多场合，我们往往只关心用某一特定正整数除以整数得到的余数。例如，星期日期就是从某个星期日开始经历的天数除以7 得到的余数，通过对天数取以7 为除数的余数，就可以用短短的7 个数字借助以7 为周期的循环机制表示无穷无尽的天数。事实上，取余数是一种以有限驾驭无限的重要智慧，对于任一给定的正整数$m$，通过考察所有整数除以$m$ 所得余数的差异，把所有具有相同余数的整数归为一类，则可将所有整数分为$m$ 个基本类型。若分别从每个类中取一个整数作为代表构成一个$m$ 元有限集，则可将这个有限集看成是对整数集的一个抽象，由此完成了整数集从无限向有限的转化。在这个分类过程中，整数之间是否具有相同余数的关系起着非常关键的作用，由此得到如下同余的概念：  

【定义2.9】假设$m$ 是任一给定的正整数，对于任意两个整数$a$和$b$，它们除以$m$ 后得到的余数分别记为$a({\bmod{\ m}})$和$b({\bmod{\ m}})$，如果这两个余数相等，即有：  

$$
a({\bmod{\ m}})=b({\bmod{\ m}})\tag{2-9}
$$

则称$a$与$b$具有模$\pmb{m}$同余关系，简称为$a$与$b$模$\pmb{m}$同余或同余，记为$a\equiv b({\bmod{m}})$或$b\equiv$$a({\bmod{\ m}})$；否则称$a$与$b$对于模$\mathbfit{m}$不同余，记为$a\not\equiv b({\bmod{{m}}})$或$b\not\equiv a({\bmod{\ m}})$。  

根据上述定义，不难证明下面关于模$_m$同余的判定定理：  

【定理2.19】假设$m$是任一给定的正整数，任意两个整数$a$和$b$具有模$_m$同余关系，当且仅当$m$能够整除$a-b$。  



【定理2.20】假设$m$ 是任一给定的正整数，任意两个整数$a$ 和$b$ 具有模$m$同余关系，  

当且仅当存在整数$k$，使得整除$a=b+k m$  



下面定理表明了同余关系的保加性和保乘性：  

【定理2.21】设$m$ 是任一正整数，若整数$a$ 与$b$ 模$m$ 同余，整数$c$与$d$ 同余模$m$，则它们的和与积也分别模$m$ 同余。即：若$a\equiv b({\bmod{\ }}m)$，$c\equiv d({\bmod{\pmod{m}}})$，则有：  

$$
a+c\equiv(b+d)(\bmod{\ m}),\ \ a c\equiv b d(\bmod{\ m})
$$



【定理2.22】假设$m$ 是任一给定的正整数，则对任意两个整数$a$ 和$b$，成立下面两个关于余数的计算公式：  

$$
(a+b){\bmod{\ m}}=((a{\bmod{\ m}})+(b{\bmod{\ m}})){\bmod{\ m}}\tag{2-10}
$$

$$
ab\ {\bmod{\ m}}=((a{\bmod{\ m}})(b{\bmod{\ m}}))\ {\bmod{\ m}}\tag{2-11}
$$



例如，对于$7\equiv2{\bmod{\mathrm{~5~}}}$和$11\equiv1{\bmod{\mathrm{~5~}}}$，由定理2.21 知：  

$$
18=7+11\equiv2+1=3({\bmod{\mathrm{~}}}5)
$$

$$
77=7\cdot11\equiv2\cdot1=2{\pmod{5}}
$$

再如，对于任意三个数，比如说1, 2 和5，由定理2.22 知存在如下等式：  

$$
(1+2)({\bmod{\ }}5)=((1\ \,({\bmod{\ }}5)+(2\ \,({\bmod{\ }}5))({\bmod{\ }}5)
$$

$$
2\,\bmod\,5=\left((1\,\bmod\,5)(2\,\bmod\,5)\right)\,(\bmod\,5)
$$

值得注意的是，同余关系在一般情况下不满足消去律，例如 $8\equiv12({\bmod{\mathrm{~}}}4)$，两边同除以4 后，$2\equiv3({\bmod{\mathrm{~}}}4)$显然是不成立的，但是存在下列性质：  

【定理2.23】若$a c\equiv b c({\bmod{\pmod{m}}})$，且$c$ 与$m$ 互素，则有：$a\equiv b({\bmod{\ }}m)$  



如前所述，使用同余可以实现对整数集合的划分或分类，现在就来讨论这个问题。由同余的定义可知，对于任意给定的正整数$m$，可依照除以$m$ 后的余数值以及模$m$ 同余关系，将所有整数划分为$m$ 个互不相交的子集合。据此，我们引入如下同余类的概念：  

【定义2.10】设$m$ 是任一给定正整数，对于每个整数$i$，$0\leq i<m$，定义如下集合：  

$$
R_{i}(m)=\{n|n\equiv i({\bmod{\pmod{\ m}}},n\in Z\}\tag{2-12}
$$

则称每个$^{}R_{i}(m)$分别是模$m$ 的一个同余类或剩余类，在不引起混淆的情况下，通常也将$R_{i}(m)$简记为$[i]$，并记为：$Z_{m}=\{[0],[1],\cdots[m-1]\}.$。  

【定理2.24】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m),$所有模$m$ 同余类，则有下述结论成立：  

（1）每个整数$a$ 都恰好属于某个同余类，通常将这个同余类记为$[a]_{m}$或$[a]$

（2）对于任意的两个整数$a$ 和$b$，它们属于同一个同余类的充分必要条件是：  
$$
a\equiv b({\bmod{m}})
$$



上述定理表明，每个整数必定属于且仅属于其中一个剩余类，属于同一个剩余类的任意两个整数都是模$m$ 同余的，属于不同剩余类的任意两个整数不可能是模$m$ 同余的。  

根据定理，可以在$.Z_{m}=\{[0],[1],\cdots[m-1]\}$上定义关于同余类的加法和乘法运算：

【定义2.11】假设$m$ 是任一给定的正整数对于任意给定的两个整数$a$和$b$，定义：  
$$
[a]_{m}+[b]_{m}=[a+b]_{m}
$$

$$
[a]_{m}\cdot[b]_{m}=[a\cdot b]_{m}
$$



【定义2.12】假设$m$ 是任一给定的正整数，$R_{0}(m),R_{1}(m),\cdots,R_{m-1}(m)$是所有模$m$ 同余类，如果从每个同余类$R_{i}(m)$中分别取一个整数$x_{i}$构成一个$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$，则称该有限集合为模$m$ 的一个完全剩余系，简称为完全系；称$m$ 元有限集合$\{0,\ 1,\ 2,\ \cdots\ ,$为最小非负完全剩余系。  

对于正整数$m$，假设$m$ 元有限集合$\{x_{0},\ x_{1},\ \cdots,x_{m-1}\}$是模$m$ 的一个完全剩余系，对于其中的任意一个整数$\cdot x_{i}$，如果${\bf\nabla}_{}^{}$与$m$ 互素，则$x_{i}$所在同余类${\mathbf{}}R_{i}(m)$中每个整数$k$ 都与$m$ 互素。这是因为根据$k\equiv x_{i}({\bmod{\pmod{m}}})$，即有$\cdot_{x_{i}}=k+q m$。由此可知，如果$k$ 与$m$有大于1 的公因子，那么$x_{i}$必然与$m$ 有大于1 的公因子。类似地，如果$x_{i}$与$m$ 互素，则$x_{i}$所在同余类$R_{i}(m)$中每个整数$k$ 都与$m$ 不互素。由此得到如下简化同余类和简化剩余系的概念：  

【定义2.13】对于正整数$m$，假设$R_{i}(m)$是任意一个模$m$ 同余类，若$R_{i}(m)$中存在一个整数与 $m$  互素，则称 $\ R_{i}(m)$ 是一个模 $\pmb{m}$  简化同余类或模 $\pmb{m}$  简化剩余类。如果分别从每个模 $m$ 简化同余类中取出一个整数作为代表$x_{i}$构成一个有限集合$\{x_{0},\ x_{1},\ \cdots,x_{\varphi(m-1)}\}$，则称该集合为模$m$ 的一个简化剩余系，简称为简化系。其中$\varphi(m)$称为欧拉函数，表示模$m$ 简化剩余类的数目，亦即不超过$m$ 且与$m$ 互素的正整数个数。  

因为所有模$m$ 同余类构成整数集合的一个划分，所以每个与$m$ 互质的整数仅存在于它  所在的简化同余类中。由此可以看出，简化同余类以及欧拉函数$\varphi(m)$在整数互质性质的研究中具有非常重要的作用，后面将使用这些概念证明欧拉定理和费马小定理。这两个定理不仅是整数理论中非常著名而重要的定理，而且还是现代非对称数论加密算法的基础。  



### 2.2.2 同余方程与方程组

相等的两个整数除以某一正整数$m$ 后得到的余数自然是相等的。因此，两个整数之间的同余关系不仅可以看成是对整除关系的一种推广，而且还可以看成是对两个整数相等关系的一种推广。下面定理表明整数相等关系与同余关系自己具有共同本质属性。  

【定理2.25】假设$m$ 是任一给定的正整数，则模$m$ 同余关系满足下列性质：  

(1) 自反性：$a\equiv a({\bmod{\ m}})$，对一切整数$a$ 成立；

 (2) 对称性：若$a\equiv b({\bmod{\ }}m)$，则$b\equiv a({\bmod{\ m}}).$； 

(3) 传递性：若$a\equiv b({\bmod{\ }}m)$，$b\equiv c({{\pmod{m}}})$，则$a\equiv c({{\pmod{m}}}).$。 



我们知道，根据整数之间相等关系的制约可以列出相应的整数方程和方程组。那么，根据整数同余关系的制约是否也可以列出相应的方程和方程组呢？如果可以，那么这些方程和方程组如何求解？本节我们就来讨论这些问题。  

【定义2.14】假设$m$ 是任一给定的正整数，$a$ 和$b$ 是任意给定的两个整数，下式：  

$$
a x\equiv b({\bmod{m}})\tag{2-13}
$$

称为关于未知数$x$ 的一次线性同余方程，简称为同余方程，其中$x$ 为未知整数。若存在一个整数$\cdot x_{0}$，当$x=x_{0}$时，成立$.a x\equiv b({\bmod{\pmod{m}}})$，则称$\cdot x_{0}$是该同余方程的一个解。  

显然，如果$x_{0}$是某个同余方程的一个解，则与$x_{0}$同余的所有整数都是该同余方程的解，这是一种平凡情形，通常将与$x_{0}$同余的所有整数与$x_{0}$一起看成是同一个解。因此，同余方程解的计数标准为：凡是相互之间模$m$ 同余的解都视为同一个解，同余方程解的个数是指它的关于模$m$ 互不同余所有解的个数，亦即在模$m$ 的一个完全剩余系中解的个数。  

下面考察一次线性同余方程解的存在性：  

【定理2.26】假设$m$ 是任一给定的正整数，$a,b$ 是任意给定的两个整数，如果$a$ 与$m$之间没有整除关系，即有$a\not\equiv0({\bmod{m}})$ ，则下列同余方程  

$$
a x\equiv b({\bmod{m}})
$$

有解的充要条件是$a$ 与$m$ 的最大公因数能够整除$b$。若有解，则解的个数为$\operatorname*{gcd}(a,m)$。  





对于同余方程$a\cdot x \equiv 1(\mod m)$，其有解的充要条件是$a$ 与$m$ 的最大公因数能够整除1，即互素$a$ 与$m$。且有解的情况下只有唯一解。由此给出如下关于$\bar{a}$的定义：  

【定义2.15】设$m$ 是任一给定的正整数，$a$ 是任一与$m$ 互素的整数，满足$a\cdot x\equiv$1 (mod $m^{\prime}$)的最小正整数解称为整数$a$的模$\pmb{m}$ 逆，记为$\cdot\bar{a}$。  

下面定理的证明过程给出了整数$a$ 模$m$ 逆$\bar{a}$的一个具体求法：  

【定理2.27】设$m$ 和$a$ 是两个互素的整数，且$m>1$，则存在唯一一个小于$m$ 的正整数$\bar{a}$，它是$a$ 的模$m$ 逆，即有：${\bar{a}}\cdot a\equiv1({\bmod{{m}}})$。  



【定义2.16】假设$m_{1},m_{2},\cdots,m_{k}$为$k$个正整数，$a_{1},a_{2},\cdots,a_{k}$为$k$ 个整数，由下列$k$ 个以$x$ 为未知整数的同余方程联立而成的方程组，称为同余方程组：  

$$
\left\{\begin{array}{l l}{x\equiv a_{1}(\bmod~m_{1})}\\ {x\equiv a_{2}(\bmod m_{2})}\\ {\qquad\dots}\\ {x\equiv a_{k}(\bmod~m_{k})}\end{array}\right.\tag{2-14}
$$

若存在一个整数$\cdot x_{0}$满足上述所有同余方程，则称$\cdot x_{0}$是该同余方程组的一个解。  

当以上定义的同余方程组中所有模两两互素时，方程组一定有唯一的一组解。下面的中国余数定理是整数理论中一个非常著名的定理，又称为孙子定理。该定理不仅确认了上述结论，而且其证明过程其实给出了一个具体的求解方法。  

【定理2.28】（中国余数定理）设$m_{1}$$\cdot\ \ m_{2},\ \ \cdots m_{k}$是两两互素的正整数，那么同余式组（2-14）有唯一的以$M=m_{1}m_{2}\cdots m_{k}$为模的解。  



### 2.2.3 整数加密算法  

为防止机密信息被泄露或破坏，需采用数据加密技术对其进行保护。数据加密的基本思想是对原始数据加以伪装，使非法接入者无法理解信息的真正含义，基本过程就是对原来为明文信息或数据按某种算法进行处理，使其成为不可读的一段代码，称为密文，使其只能在输入相应密钥之后才能显示出本来内容。数据加密通常分为对称式加密和非对称式加密两大类。本节介绍两种基于整数理论的经典加密算法，一种是名为仿射加密算法的对称加密算法，另一种是名为RSA 的非对称加密算法。  

仿射加密算法又称为凯撒加密算法，是一种简单且广为人知的加密技术。它是一种替换加密技术，基本思想如下：首先使用0 到25 之间的数字表示A 到Z 这26 个字母。然后，对于每个不大于25 的非负整数$\cdot p$，定义其加密函数值$f(p)$为$\{0,1,2,\ \cdots,25\}$中某个数字。加密函数$f(p)$的有多种定义方法，例如可采用如下加密函数：  

$$
f(p)=(p+3)\;{\bmod{\,}}26
$$

对于上述加密函数，此时用整数$(p+3)\,\mathrm{mod}\,26$代表的字母替代由整数$p$表示的字母实现加密。例如，对“WELCOME TO HEFEI”进行加密，首先用数字代替字母，然后使用加密函数$f(p)=(p+3)\mod 26$ 代替$p$，翻译成字母后，得到获得到的加密信息为：“ZHOFRPH VR KHIHL”具体过程如下：  

表2-3 凯撒密码的加密过程
![](images/168580ee1913d8c32220b048da1875515ce367981f5bce7472f95af1471231b8.jpg)  

解密则需要使用加密函数的$f(p)$反函数 $f^{-1}(p)$  

$$
f^{-1}(p)=(p-3){\bmod{\,}}26
$$

解密时需将加密信息转换成数字，然后使用$f^{-1}(p)$把$\{0,1,2,\ \cdots,25\}$中整数$\cdot p$恢复成信息原文对应的整数，之后再将数字装换成字母获得原文。  

RSA 算法由三位数学家Rivest、Shamir 和Adleman 于1977 年共同提出，是至今最为广泛使用的非对称加密算法，特别适合于对通过互联网传送的数据进行加密，通常于数字签名等场合。RSA 算法使用整数模余运算性质生成公钥和私钥，并进行加密和解密。RSA 算法原理基于欧拉定理和费马小定理，为此首先介绍这两个定理。  

【定理2.29】（欧拉定理）设$m$ 是任一正整数，$a$ 是任一与$m$ 互素的整数，则有：  

$$
a^{\varphi(m)}\equiv1({\bmod{\ m}})\tag{2-15}
$$

其中$\varphi(m)$是欧拉函数。  



如果上述猜想能够成立，则提供了一个非常有效的素数判定方法。但是遗憾的是，上述猜想并不成立。事实上，$p$ 为只要是素数，则其必满足上式，但反之不然。法国数学家给出了如下称之为费马小定理更一般结论：  

【定理2.30】（费马小定理）假设$p$ 是一个任意给定的素数，则对于任意整数$a$，有：  

$$
a^{p}\equiv a({\bmod{\ p}})\tag{2-16}
$$

特别地，当$a$与$p$ 互素时，有：$a^{p-1}\equiv1({\bmod{\ p}})$。  



下面介绍RSA 算法的基本原理和具体计算过程。RSA 算法理论基础是同余算术以及欧拉定理和费马小定理，其安全性依赖于大整数素因子分解的困难性，即已知整数$n$ 是两个大素数$p$ 和$q$ 的乘积，则难以在可接受的时间范围内通过$n$ 的素因子分解方法获得$p$ 和$q$ 的取值。RSA 算法的密钥生成、加密、解密的具体过程如下：  

1） 密钥的生成  

首先生成两个互不相同的大素数$p$ 和$q$，并令$n=p\cdot q$。其中$p$ 和$q$ 是属于解密信息，不可对外公开，整数$n$ 属于加密信息，需要对外公开。  

然后，令$\varphi(n)=(p-1)(q-1)$，并任意选择一个与$\varphi(n)$互素的正整数$e$，满足：  

$2\leq e\leq\varphi(n)$  

其中$\varphi(n)$不可对外公开，$e$ 为加密密钥，需要对外公开。  

由于$p$ 和$q$ 都是素数，故小于$p$ 且与$p$ 互素的非负整数的个数为$(p-1)$个，小于$q$ 且与$q$ 互素的非负整数的个数为$(q-1)$个。注意到$n=p\cdot q$，由计数的乘法原理及素数的性质可知，小于$\cdot n$且与$n$互素的非负整数的个数为$(p-1)$ $(q-1)$个，因此，$\varphi(n)=(p-1)(q-$1)其实就是欧拉函数。  

由于$e$ 的模$\varphi(n)$互素，因此$e$ 的模$\varphi(n)$同余逆$d$存在且唯一。算出$e$ 的模$\varphi(n)$同余逆$d$，使其满足：  

$$
e d\equiv1({\bmod{\ }}\varphi(n))\tag{2-17}
$$

整数$d$ 属于解密密钥，不可对外公开。  

由此得到RSA 加密算法中作为公钥的加密密钥$e$，作为私钥的解密密钥$d$。  

2） 加密过程  

在RSA 加密算法中，要将明文信息转化成若干组整数序列。为此，首先将每个字母翻译成相应的整数，例如可以使用前述的凯撒加密算法完成这项工作。然后，将这些由明文字母对应的整数合并成若干组，每个组分别形成一个大整数，代表一个字母段。  

RSA 加密过程其实就是每个表示明文字母段的大整数$M$逐个转化为表示密文字母段的大整数$C$，具体转化公式如下：  

$$
C=M^{e}{\pmod{n}}\tag{2-18}
$$

在转化过程中总是假定$M<n$。如果$M\geq n$，则需要对表示明文的所有整数重新进行分组以确保每个字母段对应的大整数小于$n$。  

3） 解密过程  

由于$d$ 是$e$ 的模$\varphi(n)$逆，即是$e$ 的模$(p-1)(q-1)$逆，故有：  

$$
e d\equiv1(\bmod(p-1)(q-1))\tag{2-19}
$$

也就是说，$_{e d}$除以$(p-1)(q-1)$的余数为1，故存在整数$k$，使得：  

$$
e d={\begin{array}{l}{(p-1)(q-1)k+1}\end{array}}
$$

故有：  

$$
C^{d}\equiv(M^{e})^{d}\equiv M^{e d}\equiv M^{(p-1)(q-1)k+1}\,({\mathrm{mod}}\,\,n)
$$

假定$M$与$p$ 和$q$ 均为互素，则根据费马小定理有：  

$$
M^{p-1}\equiv1(\mathrm{\;mod}\;\left(p\right))\mathcal{X}M^{p-1}\equiv1(\mathrm{\;mod}\;\,q)
$$

从而有：  

$$
\begin{array}{r}{C^{d}\equiv M^{(p-1)(q-1)k+1}\equiv\!\!M\!\cdot\!(M^{p-1})^{k(q-1)}\!\!\equiv\!\!M\!\cdot\!1\!\equiv\!\!M\,(\mathrm{mod}\,p)}\\ {C^{d}\equiv M^{(p-1)(q-1)k+1}\equiv\!\!M\!\cdot\!(M^{q-1})^{k(p-1)}\!\!\equiv\!\!M\!\cdot\!1\!\equiv\!\!M\,(\mathrm{mod}\,q)}\end{array}
$$

由于$p$ 与$q$ 互素，则根据中国余数定理，有：  

$$
C^{d}\equiv M\,({\sf m o d}\,\,\,p\cdot q)\mathbb{\bar{X}}C^{d}\equiv M\,({\sf m o d}\,\,\,n)
$$

由于$M<n$，故必有：$M=C^{d}\;({\mathsf{m o d}}\;\,n)$  

因此，若已知解密密钥$d$，就可使用公式$M=C^{d}\,({\sf m o d}\,n),$对密文$C$ 进行解密。  

在RSA 加密和解密算法中，如果$p,\ q$ 被信息窃取者获得，则可算出$(p-1)(q-1).$。由于$e$ 是公开密钥，且$d$是$e$ 关于关于模$(p-1)(q-1)$的逆，则不难求出$d$，如此RSA 系统便被完全攻破，信息窃取者就会很容易获得加密的信息。  

RSA 算法中的素数都是十进制整数，怎样才能选择好的$p$ 和$q$，这是$R S A$ 加密算法最关键的问题。针对素数$p$ 和$q$ 的选择，1978 年Rivest 等人在关于RSA 公开密钥的论文中，建议对素数$p$ 和$q$ 的选择应当满足：  

1）$p$ 和$q$ 要足够长，在长度上应相差几位，且二者之差与$p$ 和$q$ 位数相近；  

2）$p{-}1$ 和$q{-}1$ 的最大公约数$\operatorname*{gcd}(p -1\,,\,\,\,q-\!\!1)$要尽量小；  

3）$p{-}1$ 和$q{-}1$ 均应至少含有一个大的素数因子。  

并把满足这些条件的素数称为安全素数。  



从实用的观点看，如果加密后的信息能够保证在足够长的时间内不能被破解，则认为这个加密方法是安全的。相对于RSA 加密算法而言，如果整数$n$ 不是足够大，例如只有10 位，那么按照计算机目前的计算能力，几乎可以立刻求出其所有素因子实现对RSA 加密算法的破解。如果计算机的计算能力得到进一步的提高，则或许能够破解200 位的整数$n$。但是，如果使用200 素数$p$ 和200 位素数$q$ 构成400 位整数$n$，则计算机无法破解由此设计的RSA加密算法。因此，就目前以及今后一段时间而言，RSA 加密算法具有较好的安全性。  

## § 2.3 算法设计的基本知识  

在前面整数理论中有不少关于整数的算法，例如求最大公因数的辗转相除算法、素数查找算法、 凯撒整数加密算法、 RSA  整数加密算法等等。 所谓算法， 简单地说就是算术之法， 也就是说通过运算的方式按照机械的步骤逐步实现对问题的求解。算法的这种基于构造性和机械性的运算体系非常契合计算机的运算特点和需求。因此，随着计算机的诞生和兴起，算法设计理论与技术迅速得到广泛重视和深入研究。目前，除了整数理论之外，在离散数学的其它内容中很多也都是通过一些非常精彩算法形式为计算机提供服务。为更好地学习离散数学及其应用知识，本节简要介绍算法设计的基本知识。  

### 2.3.1 算法的基本概念  

计算机是处理数据并将数据转化为有用信息的电子设备。任何计算机都由程序指令控制，程序指令规定计算机的用途，并告诉计算机需要完成的工作。因此，要使计算机工作就需要编写计算机程序，告诉计算机如何按照步骤执行程序，以实现最终目标。值得注意的是：根据计算机的特点，在告诉计算机需要它完成什么任务的同时，还需要进一步确定或选择让它怎样去完成，这正是计算机算法的由来。  

算法一词出自《周髀算经》，即算术之法。目前，关于算法的概念有很多种不同的定义，至今没有一种得到大家的公认，但可从这些不同定义中找到一些基本的共识。为求同存异，现从广义和狭义这两个不同的角度来诠释与理解算法的概念。  

【定义2.17】从广义上讲，算法是指通过运算的方式按照某种机械的步骤逐步实现对问题的求解，从这个角度看，现实生活中的很多工作流程都可以看成是算法，例如烧菜的菜谱、理发的流程等，都可以叫算法。从狭义上讲，算法是一个由已知推求未知的过程，对于符合一定规范的输入，它能够在有限的时间内获得所需的输出。在计算机专业领域，主要是从狭义的角度来理解算法。  

本书的算法设计，主要是从计算机专业角度来理解算法。在计算机专业领域，对算法的理解不仅是狭义的，而且对算法概念诠释更加明确具体，即：算法是指用于计算机解决问题的清晰有穷指令序列，且满足以下五条基本性质：  

1) 有穷性：算法中每条指令的执行次数和时间均有限。执行次数或执行时间无穷的算法，对实际生产生活几乎没有意义，而且还会造成资源浪费。  

2) 确定性：对算法的描述必须无歧义，以保证算法执行结果是确定的，且符合要求和期望。如果算法对于同样的输入，在相同环境下产生不确定的结果，则是不能接受的。  

3) 输入：一个算法有0 个或多个输入，以确定运算对象的初始情况。所谓0 个输入是  

指算法本身给定了初始条件。  

4) 输出：一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的。  

5) 可行性：算法中有待实现的运算都是基本运算，算法原则上要能够精确地运行，且人们用笔和纸做有限次运算后就可以完成。  

从计算机专业角度来看，一个完整的算法应该具备如下三个基本要素：  

1) 基本运算和操作  

算法的实现形式有多种，但是这些实现形式都具有相同的基本运算和操作。这些基本运算和操作有以下四类：  

算术运算：加减乘除等运算；关系运算：大于、小于、等于、不等于等运算；逻辑运算：或、与、非等运算；数据操作：输入、输出、赋值等运算。  

2) 控制结构  

一个算法的功能结构不仅取决于所选用的操作，而且还与各操作之间的执行顺序紧密相关。算法的控制结构确定了算法的基本框架，决定着各个操作的执行顺序。算法控制结构有三种，即顺序结构、选择结构和循环结构。  

3) 数据结构  

在计算机领域，算法的操作对象是数据。为了方便快速的存取，数据一般以一些特定的结构进行存储，另一方面，具体实际问题及其数学模型的结构特点决定了数据之间总是存在着一些特定的逻辑关系或逻辑结构。这些存储结构和逻辑结构统称为数据结构。  

一个算法可以采用多种不同的形式进行表示，常用的表示方法有：自然语言、流程图、伪代码等。本书后面各章节的算法将主要采用伪代码进行描述，以利于读者将理论与实际相结合，通过自己亲自动手描述和实现算法，加深对算法的理解。  

伪代码不是真正编程语言，而是一种算法描述语言，使用介于自然语言和程序设计语言之间的文字符号来描述算法。使用伪代码描述算法，能够使被描述的算法可以容易地以任何一种编程语言实现。伪代码可以综合使用多种编程语言中的语法、保留字，甚至会用到自然语言。 因此，伪代码结构清晰，简单且易于修改，可读性较好，并且类似自然语言。  

### 2.3.2 算法效率的度量  

从实际应用考虑，如果一个算法的运行时间过久，比如需要长达数年的时间，那么该算法就不适合用来解决问题。同样，一个算法如果需要占用很大的内存开销，导致系统无法为其它程序提供必须的内存资源，那么这也是不能够接受的。因此，对于设计出来的算法，需要对其利用时间和内存空间的效率进行分析，这就是算法的效率分析。无论是时间效率还是空间效率上看，算法的效率都是问题规模的某个函数，并且函数值随着问题规模的增长而增长。如果函数值随问题规模的增长而增长得很快，则说明算法效率很低，反之，如果函数值随问题规模的增长而增长得很慢，则说明算法效率很高。  

因此，为了更好地分析算法的效率，需要一些合适的方法来描述或度量函数值随自变量增长而增长的速度，如果不能精确地算出函数增长的速度，那么至少也要针对函数增长的不同速度划分出若干性质不同的等级，这就是函数增长的阶。当输入规模足够大时，精确表示的运行时间函数中的常系数和低阶项会被输入规模所掩盖。此时，只需要考虑高阶项即可。比如若复杂度为多项式$x^{2+}\!x$，$x$的复杂度会被$x^{2}$的复杂所吸收，因此只需考虑最高阶。  

事实上，在分析和度量算法效率的时候，重点考虑的是当问题规模充分大时的函数值增长的情况。因此，分析和度量算法效率时，一般都使用渐近效率的概念，即从极限的角度考虑运行时间如何随输入规模的增长而增长。为了更加准确地阐释和度量算法复杂度随问题规模增长而增长的速度，计算机科学家在算法领域引入了一些函数增长符号，其中时间复杂度常用大𝑂符号表述，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间。使用这种方式时，时间复杂度可被称为是渐近的，它主要考察当输入值充分大时的情况。  

对于绝大多数算法来说，其复杂度的增长速度还可以使用基本或常用函数增长类型通过示例性的方法来描述或表示，如常数级、对数级、多项式级、指数级、阶乘级增长速度，等等。这些常用函数的增长速度非常直观，以它们增长速度为标准对算法的计算复杂度进行度量，会使得算法复杂度分析变得易于理解。因此，掌握这些常用函数的基本增长类型对算法设计具有非常重要的指导意义，下面对其做简要介绍：  

（1）$\mathrm{O}(1)$：复杂度为常数级，例如从一个数据集中取出第一个元素；  

（2）$\mathrm{O}(\lg n)$：该类型常见于将一个数据集分成两半，然后将其中每一半再分成两半，以此类推。例如对有序数组进行二分查找，其时间复杂度就是$\mathrm{O}(\lg n)$； 

（3）$\mathrm{O}(n)$：该类型常见于数据集中的遍历，例如在线性结构中顺序查找某个元素的算法，其时间复杂度就是$\mathrm{O}(n)$；  

（4）$\mathrm{O}(n\lg n)$：该类型与前面所述的$\mathbf O(1g\ n)$有点类似，常见于将一个数据集分成两半，然后将每一半再分成两半，并且对每一半数据进行遍历，以此类推，例如归并排序时间复杂度就是$\mathrm{O}(n\,1\mathrm{g}\,n)$；  

（5）${\mathrm{O}}(n^{2})$：常见于两重嵌套循环的算法之中，也就是说在遍历一个数据集中的每一个元素的时候同时遍历另一个数量级相同的数据集，基本排序算法（如冒泡排序、直接插入排序、直接选择排序等）的时间复杂度是${\mathrm{O}}(n^{2})$；  

（6）${\mathrm{O}}(n^{3})$：该类型常见于三重嵌套循环的算法之中，在线性代数中，两个$n$阶方阵相乘的时间复杂度就是${\mathrm{O}}(n^{3})$，著名求解最短路径Floyd 算法的时间复杂度也是${\mathrm{O}}(n^{3})$；  

（7）$\mathrm{O}(2^{n})$：为一个数据集生成所有的子集，这种数量级的算法可以说是很低效的，在规模较大的时候是不可行的；  

（8）$\mathrm{O}(n!)$：对具有$n$ 个元素的集合进行全排列时就是该类型的典型例子，这种数量级的算法基本上是不可行的。  

### 2.3.3 算法设计应用举例  



## § 2.4 算法设计策略与应用  

计算机问题求解算法虽然千差万别，但都遵循一些基本的设计策略。这些策略蕴含着很多非常深刻而又普适的求解智慧。例如，分治策略把一个问题分解为若干规模较小的子问题，然后以递归的方式求解它们并通过合并它们的解来实现对原问题的求解，而回溯策略则认为对未知世界的探索是一个试错的过程，并给出具体的试错方案，这恰恰是对人类生活经验的一种抽象和总结。不断学习、领会和掌握这些智慧，就可逐步形成良好的算法思维，从而能够更加透彻地从本质上理解算法设计的精髓，为设计出高水平算法打下坚实的基础。本章主要结合具体应用实例介绍和分析算法设计的若干基本策略，包括蛮力与贪心策略、递归与分治策略、回溯与动态规划策略。  

### 2.4.1 蛮力与贪心  

计算机处理的对象及其结构都是离散的，对这种离散对象与结构的求解，显然有一种最直观、最基本的方法，就是枚举出所有可能状态，然后在这些状态中找到所需的解。这就是蛮力法。该方法最大优点就是普适性高，几乎可以解决任何问题，最大的缺点就是计算量太大，很多情况下不可行。此外，还有一种非常直观的、非常基本的方法，那就是贪心法。该方法在每一步都获得当前状态下最好的结果，通过使用局部最优解步步逼近的方式获得问题全局最优解。贪心法的优点是思想直观，易于理解，缺点是算法没有总体控制机制，缺少远见和大局观，有时难以保证算法的正确性。蛮力法和贪心法的共同特点是算法思想简单，易于理解，但都存在比较明显的局限性，在很多情况下难以直接使用。  

#### 一、蛮力策略  

【定义2.18】蛮力策略或蛮力法，亦称为穷举法或暴力法，就是用最原始、最暴力的方式解决问题，基本思路是以扫描的模式依次处理问题域所有元素，并将所有可能的结果枚举出来，进而实现对问题的求解。  

从算法思想的角度来看，蛮力法直接基于问题的描述和所涉及概念的定义来解决问题，即用最直接的方式解决问题。例如：求$.1+{\begin{array}{l}{2+3+\cdots+n}\end{array}}$的结果。蛮力法就是逐次将$n$个元素一个一个累加起来得到结果。  

蛮力法的设计一般没有技巧性，因此巧妙和高效的算法很少来自蛮力法。但是，蛮力法在算法设计策略中仍然占据着不可替代的重要地位，原因在于：  

（1）在可枚举的离散结构中，蛮力法是一种几乎可以解决任何问题的一般性方法。  

（2）若要解决的问题规模不大，且使用蛮力法的效率可以接受，就可直接使用蛮力法。此时，设计一个更高效算法所花费的代价很可能是不值得的。  

（3）可将蛮力法作为一个基准，来衡量同样问题更高效的算法，为研究提供服务。蛮力法的求解一般由如下两个基本步骤组成：  

1）找到枚举范围：分析问题，找到所涉及的每一种情况。

2）找到约束条件：解析约束条件，并用逻辑表达式表示。  



#### 二、贪心策略  

【定义2.19】贪心算法，就是从问题的某个初始解出发，通过在每一步构造当前状态下局部最优解的方式（即在每个局部阶段都贪心地做出当前状态下一个最优决策），一步一步地向全局最优解逼近，最终获取全局最优解。  

从算法设计的角度看，贪心算法具有思维复杂度低、代码量小、运行效率高、空间复杂度低等优点。但是，其局限性也是很明显的：贪心算法合理性的前提是每一步的局部最优解一定能够逼近到全局最优解，有时很难保证能够做到这一点，这称为贪心算法的非完美性。贪心算法从本质上缺少大局观思想，会给我们直接使用贪心算法带来很大的困难，因为有时很难找到一个简单可行并具有完美性的贪心思路，即使找到一个看上去很完美的贪心思路，也需要严格地证明其正确性。不过值得庆幸的是，虽然并不是所有问题都可通过贪心算法获得整体最优解，但是由此至少可以得到一个近似最优解。  



### 2.4.2 递归与分治  

递归是算法设计中一项非常重要的策略，其基本思想是把一个问题归结为一个或多个规模更小的子问题，然后用同样的方法解规模更小的子问题，要求子问题与原问题保持同一类型以保证可用同样方法求解，如此下去，直到子问题的规模小到可以直接求解为止。分治策略的思想则是将一个难以解决的大问题，分割成一些与原问题相同的、规模较小的子问题，以便分而治之，然后递归地解决子问题，最后把子问题的解组合成原问题的解。递归和分治就像一对孪生兄弟，经常同时应用在算法设计之中，并由此形成很多高效的算法。  

#### 一、递归策略  

【定义2.20】若一个算法通过把问题转化到带更小输入的相同问题的实例，来求解原来的问题，则这个算法称为递归的。  

其算法思想就是把求解的问题转化成规模较小的子问题，然后，再把该子问题继续转化为更小的子问题，通过多次转化，使得问题的规模小到可以直接求解，并得到最小解，然后将最小解逐层向上返回调用，最终得到整个问题的解。通俗地说，递归法就是大事化小、小事化了。例如，求两个正整数$a$ 和$b$ 的最大公因子的问题，其中$b{>}a$，就可以转化到求一对更小的整数（即$b$ 𝑚𝑜𝑑 $a$ 和$a$）的最大公因子问题，因为gcd($\cdot b$𝑚𝑜𝑑 $a,\ a)=\operatorname*{gcd}(a,\ b)$。  

递归算法有三个基本要求：  

（1）递归中每次循环都必须使问题规模变小；  

（2）递归操作中每相邻两步都是紧密关联的，在递归返回到上一层的操作中，前一次的输出便是后一次的输入；  

（3）当子问题的规模足够小时，必须能够直接求出该子问题的解，也就是说必须具备结束递归的初始条件（即得到递归出口：当问题规模 $n$小到某个值时，能够直接求解）。  



#### 二、分治策略  

【定义2.21】对于一个规模为$n$ 的问题，若该问题可以容易地解决（比如说规模$n$ 较小）则直接解决，否则将其分解为$k$个规模较小的子问题，这些子问题互相独立且与原问题形式相同，求解这些子问题，然后将各子问题的解合并得到原问题的解。  

如定义所述，由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术解  决并实现分治策略提供了方便。分治法也可以看成是一种递归，因为必要时可把分解求得的子问题的解合并起来获得原问题的解。  

分治算法一般分为如下三个基本步骤：（1）将原问题分解为若干相同的子问题；（2）若子问题的规模容易解决则直接求解，否则继续分解；3）将子问题的解合并得到原问题的解，当遇到如折半查找等某些不必求出所有子问题的解的情况时，则省略合并操作。  

分治算法的计算复杂性可以通过构造递推表达式进行分析：假设一个递归算法把一个规模为$n$ 的问题分成$a$ 个子问题，其中每个子问题的规模是$n/b$（为简单起见，假设$n$是$b$的倍数），并设在把子问题解组合成原问题解的处理中需要总量为$g(n)$的额外运算。  

【定义2.22】若$f\!\!\left(n\right)$表示求解规模为$n$ 的问题所需的运算数，则$f$满足如下递推关系：  

$$
f~(n)=a f(n/b)+g(n)\tag{2-23}
$$

上式称为分治递推关系。  

可通过上述递推关系来分析算法的复杂度。  

【定理2.31】假设$f$是满足递推关系：  

$$
f(n)=a f(n/b)+c
$$

的增函数，其中$n$ 被$b$ 整除，$a{\geq}1$，$b$ 是大于1 的整数，$c$ 是一个正实数。则有：  

$$
f(n)={\left\{\begin{array}{l l}{O(n^{l o g_{b}\,a})}&{{如果a>1}}\\ {O(l o g\,n)}&{{如果a=1}}\end{array}\right.}\tag{2-24}
$$

进一步，当$n=b^{k}$时（$k$ 是正整数），则有：  

$$
f(n)=C_{1}n^{l o g_{b}\,a}+C_{2}\tag{2-25}
$$

其中$C_{1}{=}f\!\!(1){+}c/(a{\cdot}1)$且$C_{2}=-c/(a-1)$  



### 2.4.3  回溯与动态规划  

回溯是一种基于解空间搜索的方法。基本思路类似于蛮力法，首先对所有的解状态进行枚举，生成解空间或状态空间，然后通过在解空间中搜索获得所需要的解。与蛮力法不同的是，这里的解空间是有结构的，换句话说，解空间以空间树的结构方式存在，由此可以根据这种特殊结构设计出很多高效的搜索方法。动态规划策略则是把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，通过对单阶段问题的逐个求解，实现对整个问题的求解，多年来，回溯和动态规划策略在最短路线、库存管理、资源分配、设备更新、排序、装载等问题求解算法中得到广泛应用。  

#### 一、回溯策略  

【定义2.23】回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。  

回溯法是一个既有系统性又有跳跃性的搜索算法，基本思路是在包含问题所有解的空间树中，按照深度优先的策略，从根节点出发搜索解的空间树。当算法搜索至某一节点时，先判断该节点是否包含问题的解，如果肯定不包含，则跳过以该节点为根的子树，逐层向其先前的节点回溯；否则，就进入该子树，继续按深度优先的策略进行搜索。回溯法的解空间为树结构，比较适合解决一些规模较大的问题。  

在用回溯法求解问题时，需要确定问题的解空间。所谓解空间，就是满足问题所有可能的解组成的集合，并且至少包含问题的一个（最优）解。  

由回溯法得到的解可以表示成$_{,n}$元向量$(X_{1},X_{2},\cdots,X_{n})$的形式。解向量一般具有显性或隐性的约束条件，在算法设计时，应该仔细分析，不能忽略。例如，当$n=3$ 时，0-1 背包问题可用一棵完全二叉树表示其解空间，如图2-14 所示。  

![](images/b415fb2b375de62d1f97720c41a6931e01b566d3978cde4ab5b4f6710e0bbacd.jpg)  
图2-14  $n{=}3$ 时背包问题的解空间  

在作为解空间的树结构中，从第𝑖层到第$i{+}1$ 层边上的标号给出了变量$X_{i}$ 的值。从树根到叶的任一路径表示解的空间中的一个元素，即一个具体的解向量。例如，从根节点$A$ 到叶子节点$H$ 的路径相应于解空间中的元素（1,1,1）。  

回溯算法需要搜索整棵解空间树，当问题规模很大时，计算量比较大。此时可用剪枝的方法对搜索策略进行优化。  

【定义2.24】剪枝就是通过某种判断避免一些不必要的遍历过程，剪去解空间树中的一些不必要的枝条，从而缩小搜索规模。  

剪枝函数通常有两种策略，一是用约束函数在扩展节点处剪去不满足约束条件的子树，二是用限界函数剪去不能得到最优解的子树。对于限界函数，一般是添加一个全局变量记录当前最优解，在到达节点时计算该节点预期值并与当前最优解比较，若不好，则回溯。  

综上所述，回溯法解题一般包括三个基本步骤：(1)定义问题的解空间；(2)确定解空间结构；(3)以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。  

![](images/94c98789a7564cef4defce6c521572031ed59be149b82dc63805c35507db88a6.jpg)  
图$2{\mathrm{-}}15\ 8{\times}8$ 棋盘  



#### 二、动态规划策略  

【定义2.25】动态规划是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。  

当问题的数学模型是递推式时，按理应该使用递归算法求解。但是，递归算法有时存在大量重复计算，使得算法时间复杂度过高。实际上，不同子问题的个数往往只有多项式数量级，若将已经计算过的子问题中间数据和计算结果记录下来，需要某个子问题的解时就直接调用，则可避免大量的重复计算，甚至可以获得多项式时间的算法计算量。动态规划算法正是遵循这种思想，将求解过程中所有子问题的解全部记录下来，不管该子问题以后是否会被其它子问题用到。可以看出，动态规划采用的是以空间换取时间的策略。  

动态规划法的有效性依赖于求解问题的两个重要性质，即：最优子结构性质和子问题重叠性质。  

$\bullet$ 最优子结构性质  如果问题最优解所包含子问题的解也是最优的，则称该问题具有最优子结构性质。最优子结构性质是动态规划求解问题的必要条件。

 $\bullet$ 子问题重叠性质  子问题重叠性质是指在用递归算法由自顶向下的方式对问题求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。当再次需要计算已经计算过的子问题时，无需再次计算，只需查表即可。 当确定待解决的问题可以使用动态规划算法求解时，通常按照以下几个步骤进行： 

（1）把所有最优化问题分成若干个阶段，找出最优解的性质，并刻画其结构特性。

（2）将问题发展到各个阶段时所处的不同状态表示出来，确定各个阶段状态之间的递推（或递归）关系，并确定初始（边界）条件。 

（3）应用递推（或递归）关系求解最优值。 

（4）根据计算最优值时得到的信息，构造最优解。  

以上（1）~（3）步是动态规划算法解决问题的基本步骤，在只需要计算最优值的问题中，完成这三个基本步骤即可。  

如果问题需要构造最优解，仍需执行第（4）步；此时，在第（3）步通常需要记录更多的信息，以便在步骤（4）中有足够信息快速地构造出最优解。  
